/********************************************************************************
 *                                                                              *
 * This file is part of IfcOpenShell.                                           *
 *                                                                              *
 * IfcOpenShell is free software: you can redistribute it and/or modify         *
 * it under the terms of the Lesser GNU General Public License as published by  *
 * the Free Software Foundation, either version 3.0 of the License, or          *
 * (at your option) any later version.                                          *
 *                                                                              *
 * IfcOpenShell is distributed in the hope that it will be useful,              *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of               *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the                 *
 * Lesser GNU General Public License for more details.                          *
 *                                                                              *
 * You should have received a copy of the Lesser GNU General Public License     *
 * along with this program. If not, see <http://www.gnu.org/licenses/>.         *
 *                                                                              *
 ********************************************************************************/

/********************************************************************************
 *                                                                              *
 * This file has been generated from IFC2X3_TC1.exp. Do not make modifications  *
 * but instead modify the python script that has been used to generate this.    *
 *                                                                              *
 ********************************************************************************/

#ifndef IFC2X3_H
#define IFC2X3_H

#include <string>
#include <vector>
#include <map>

#include <boost/optional.hpp>

#include "../ifcparse/IfcUtil.h"
#include "../ifcparse/IfcException.h"
#include "../ifcparse/Ifc2x3enum.h"

#define IfcSchema Ifc2x3

namespace Ifc2x3 {

const char* const Identifier = "IFC2X3";

// Forward definitions
class Ifc2DCompositeCurve; class IfcActionRequest; class IfcActor; class IfcActorRole; class IfcActuatorType; class IfcAddress; class IfcAirTerminalBoxType; class IfcAirTerminalType; class IfcAirToAirHeatRecoveryType; class IfcAlarmType; class IfcAngularDimension; class IfcAnnotation; class IfcAnnotationCurveOccurrence; class IfcAnnotationFillArea; class IfcAnnotationFillAreaOccurrence; class IfcAnnotationOccurrence; class IfcAnnotationSurface; class IfcAnnotationSurfaceOccurrence; class IfcAnnotationSymbolOccurrence; class IfcAnnotationTextOccurrence; class IfcApplication; class IfcAppliedValue; class IfcAppliedValueRelationship; class IfcApproval; class IfcApprovalActorRelationship; class IfcApprovalPropertyRelationship; class IfcApprovalRelationship; class IfcArbitraryClosedProfileDef; class IfcArbitraryOpenProfileDef; class IfcArbitraryProfileDefWithVoids; class IfcAsset; class IfcAsymmetricIShapeProfileDef; class IfcAxis1Placement; class IfcAxis2Placement2D; class IfcAxis2Placement3D; class IfcBSplineCurve; class IfcBeam; class IfcBeamType; class IfcBezierCurve; class IfcBlobTexture; class IfcBlock; class IfcBoilerType; class IfcBooleanClippingResult; class IfcBooleanResult; class IfcBoundaryCondition; class IfcBoundaryEdgeCondition; class IfcBoundaryFaceCondition; class IfcBoundaryNodeCondition; class IfcBoundaryNodeConditionWarping; class IfcBoundedCurve; class IfcBoundedSurface; class IfcBoundingBox; class IfcBoxedHalfSpace; class IfcBuilding; class IfcBuildingElement; class IfcBuildingElementComponent; class IfcBuildingElementPart; class IfcBuildingElementProxy; class IfcBuildingElementProxyType; class IfcBuildingElementType; class IfcBuildingStorey; class IfcCShapeProfileDef; class IfcCableCarrierFittingType; class IfcCableCarrierSegmentType; class IfcCableSegmentType; class IfcCalendarDate; class IfcCartesianPoint; class IfcCartesianTransformationOperator; class IfcCartesianTransformationOperator2D; class IfcCartesianTransformationOperator2DnonUniform; class IfcCartesianTransformationOperator3D; class IfcCartesianTransformationOperator3DnonUniform; class IfcCenterLineProfileDef; class IfcChamferEdgeFeature; class IfcChillerType; class IfcCircle; class IfcCircleHollowProfileDef; class IfcCircleProfileDef; class IfcClassification; class IfcClassificationItem; class IfcClassificationItemRelationship; class IfcClassificationNotation; class IfcClassificationNotationFacet; class IfcClassificationReference; class IfcClosedShell; class IfcCoilType; class IfcColourRgb; class IfcColourSpecification; class IfcColumn; class IfcColumnType; class IfcComplexProperty; class IfcCompositeCurve; class IfcCompositeCurveSegment; class IfcCompositeProfileDef; class IfcCompressorType; class IfcCondenserType; class IfcCondition; class IfcConditionCriterion; class IfcConic; class IfcConnectedFaceSet; class IfcConnectionCurveGeometry; class IfcConnectionGeometry; class IfcConnectionPointEccentricity; class IfcConnectionPointGeometry; class IfcConnectionPortGeometry; class IfcConnectionSurfaceGeometry; class IfcConstraint; class IfcConstraintAggregationRelationship; class IfcConstraintClassificationRelationship; class IfcConstraintRelationship; class IfcConstructionEquipmentResource; class IfcConstructionMaterialResource; class IfcConstructionProductResource; class IfcConstructionResource; class IfcContextDependentUnit; class IfcControl; class IfcControllerType; class IfcConversionBasedUnit; class IfcCooledBeamType; class IfcCoolingTowerType; class IfcCoordinatedUniversalTimeOffset; class IfcCostItem; class IfcCostSchedule; class IfcCostValue; class IfcCovering; class IfcCoveringType; class IfcCraneRailAShapeProfileDef; class IfcCraneRailFShapeProfileDef; class IfcCrewResource; class IfcCsgPrimitive3D; class IfcCsgSolid; class IfcCurrencyRelationship; class IfcCurtainWall; class IfcCurtainWallType; class IfcCurve; class IfcCurveBoundedPlane; class IfcCurveStyle; class IfcCurveStyleFont; class IfcCurveStyleFontAndScaling; class IfcCurveStyleFontPattern; class IfcDamperType; class IfcDateAndTime; class IfcDefinedSymbol; class IfcDerivedProfileDef; class IfcDerivedUnit; class IfcDerivedUnitElement; class IfcDiameterDimension; class IfcDimensionCalloutRelationship; class IfcDimensionCurve; class IfcDimensionCurveDirectedCallout; class IfcDimensionCurveTerminator; class IfcDimensionPair; class IfcDimensionalExponents; class IfcDirection; class IfcDiscreteAccessory; class IfcDiscreteAccessoryType; class IfcDistributionChamberElement; class IfcDistributionChamberElementType; class IfcDistributionControlElement; class IfcDistributionControlElementType; class IfcDistributionElement; class IfcDistributionElementType; class IfcDistributionFlowElement; class IfcDistributionFlowElementType; class IfcDistributionPort; class IfcDocumentElectronicFormat; class IfcDocumentInformation; class IfcDocumentInformationRelationship; class IfcDocumentReference; class IfcDoor; class IfcDoorLiningProperties; class IfcDoorPanelProperties; class IfcDoorStyle; class IfcDraughtingCallout; class IfcDraughtingCalloutRelationship; class IfcDraughtingPreDefinedColour; class IfcDraughtingPreDefinedCurveFont; class IfcDraughtingPreDefinedTextFont; class IfcDuctFittingType; class IfcDuctSegmentType; class IfcDuctSilencerType; class IfcEdge; class IfcEdgeCurve; class IfcEdgeFeature; class IfcEdgeLoop; class IfcElectricApplianceType; class IfcElectricDistributionPoint; class IfcElectricFlowStorageDeviceType; class IfcElectricGeneratorType; class IfcElectricHeaterType; class IfcElectricMotorType; class IfcElectricTimeControlType; class IfcElectricalBaseProperties; class IfcElectricalCircuit; class IfcElectricalElement; class IfcElement; class IfcElementAssembly; class IfcElementComponent; class IfcElementComponentType; class IfcElementQuantity; class IfcElementType; class IfcElementarySurface; class IfcEllipse; class IfcEllipseProfileDef; class IfcEnergyConversionDevice; class IfcEnergyConversionDeviceType; class IfcEnergyProperties; class IfcEnvironmentalImpactValue; class IfcEquipmentElement; class IfcEquipmentStandard; class IfcEvaporativeCoolerType; class IfcEvaporatorType; class IfcExtendedMaterialProperties; class IfcExternalReference; class IfcExternallyDefinedHatchStyle; class IfcExternallyDefinedSurfaceStyle; class IfcExternallyDefinedSymbol; class IfcExternallyDefinedTextFont; class IfcExtrudedAreaSolid; class IfcFace; class IfcFaceBasedSurfaceModel; class IfcFaceBound; class IfcFaceOuterBound; class IfcFaceSurface; class IfcFacetedBrep; class IfcFacetedBrepWithVoids; class IfcFailureConnectionCondition; class IfcFanType; class IfcFastener; class IfcFastenerType; class IfcFeatureElement; class IfcFeatureElementAddition; class IfcFeatureElementSubtraction; class IfcFillAreaStyle; class IfcFillAreaStyleHatching; class IfcFillAreaStyleTileSymbolWithStyle; class IfcFillAreaStyleTiles; class IfcFilterType; class IfcFireSuppressionTerminalType; class IfcFlowController; class IfcFlowControllerType; class IfcFlowFitting; class IfcFlowFittingType; class IfcFlowInstrumentType; class IfcFlowMeterType; class IfcFlowMovingDevice; class IfcFlowMovingDeviceType; class IfcFlowSegment; class IfcFlowSegmentType; class IfcFlowStorageDevice; class IfcFlowStorageDeviceType; class IfcFlowTerminal; class IfcFlowTerminalType; class IfcFlowTreatmentDevice; class IfcFlowTreatmentDeviceType; class IfcFluidFlowProperties; class IfcFooting; class IfcFuelProperties; class IfcFurnishingElement; class IfcFurnishingElementType; class IfcFurnitureStandard; class IfcFurnitureType; class IfcGasTerminalType; class IfcGeneralMaterialProperties; class IfcGeneralProfileProperties; class IfcGeometricCurveSet; class IfcGeometricRepresentationContext; class IfcGeometricRepresentationItem; class IfcGeometricRepresentationSubContext; class IfcGeometricSet; class IfcGrid; class IfcGridAxis; class IfcGridPlacement; class IfcGroup; class IfcHalfSpaceSolid; class IfcHeatExchangerType; class IfcHumidifierType; class IfcHygroscopicMaterialProperties; class IfcIShapeProfileDef; class IfcImageTexture; class IfcInventory; class IfcIrregularTimeSeries; class IfcIrregularTimeSeriesValue; class IfcJunctionBoxType; class IfcLShapeProfileDef; class IfcLaborResource; class IfcLampType; class IfcLibraryInformation; class IfcLibraryReference; class IfcLightDistributionData; class IfcLightFixtureType; class IfcLightIntensityDistribution; class IfcLightSource; class IfcLightSourceAmbient; class IfcLightSourceDirectional; class IfcLightSourceGoniometric; class IfcLightSourcePositional; class IfcLightSourceSpot; class IfcLine; class IfcLinearDimension; class IfcLocalPlacement; class IfcLocalTime; class IfcLoop; class IfcManifoldSolidBrep; class IfcMappedItem; class IfcMaterial; class IfcMaterialClassificationRelationship; class IfcMaterialDefinitionRepresentation; class IfcMaterialLayer; class IfcMaterialLayerSet; class IfcMaterialLayerSetUsage; class IfcMaterialList; class IfcMaterialProperties; class IfcMeasureWithUnit; class IfcMechanicalConcreteMaterialProperties; class IfcMechanicalFastener; class IfcMechanicalFastenerType; class IfcMechanicalMaterialProperties; class IfcMechanicalSteelMaterialProperties; class IfcMember; class IfcMemberType; class IfcMetric; class IfcMonetaryUnit; class IfcMotorConnectionType; class IfcMove; class IfcNamedUnit; class IfcObject; class IfcObjectDefinition; class IfcObjectPlacement; class IfcObjective; class IfcOccupant; class IfcOffsetCurve2D; class IfcOffsetCurve3D; class IfcOneDirectionRepeatFactor; class IfcOpenShell; class IfcOpeningElement; class IfcOpticalMaterialProperties; class IfcOrderAction; class IfcOrganization; class IfcOrganizationRelationship; class IfcOrientedEdge; class IfcOutletType; class IfcOwnerHistory; class IfcParameterizedProfileDef; class IfcPath; class IfcPerformanceHistory; class IfcPermeableCoveringProperties; class IfcPermit; class IfcPerson; class IfcPersonAndOrganization; class IfcPhysicalComplexQuantity; class IfcPhysicalQuantity; class IfcPhysicalSimpleQuantity; class IfcPile; class IfcPipeFittingType; class IfcPipeSegmentType; class IfcPixelTexture; class IfcPlacement; class IfcPlanarBox; class IfcPlanarExtent; class IfcPlane; class IfcPlate; class IfcPlateType; class IfcPoint; class IfcPointOnCurve; class IfcPointOnSurface; class IfcPolyLoop; class IfcPolygonalBoundedHalfSpace; class IfcPolyline; class IfcPort; class IfcPostalAddress; class IfcPreDefinedColour; class IfcPreDefinedCurveFont; class IfcPreDefinedDimensionSymbol; class IfcPreDefinedItem; class IfcPreDefinedPointMarkerSymbol; class IfcPreDefinedSymbol; class IfcPreDefinedTerminatorSymbol; class IfcPreDefinedTextFont; class IfcPresentationLayerAssignment; class IfcPresentationLayerWithStyle; class IfcPresentationStyle; class IfcPresentationStyleAssignment; class IfcProcedure; class IfcProcess; class IfcProduct; class IfcProductDefinitionShape; class IfcProductRepresentation; class IfcProductsOfCombustionProperties; class IfcProfileDef; class IfcProfileProperties; class IfcProject; class IfcProjectOrder; class IfcProjectOrderRecord; class IfcProjectionCurve; class IfcProjectionElement; class IfcProperty; class IfcPropertyBoundedValue; class IfcPropertyConstraintRelationship; class IfcPropertyDefinition; class IfcPropertyDependencyRelationship; class IfcPropertyEnumeratedValue; class IfcPropertyEnumeration; class IfcPropertyListValue; class IfcPropertyReferenceValue; class IfcPropertySet; class IfcPropertySetDefinition; class IfcPropertySingleValue; class IfcPropertyTableValue; class IfcProtectiveDeviceType; class IfcProxy; class IfcPumpType; class IfcQuantityArea; class IfcQuantityCount; class IfcQuantityLength; class IfcQuantityTime; class IfcQuantityVolume; class IfcQuantityWeight; class IfcRadiusDimension; class IfcRailing; class IfcRailingType; class IfcRamp; class IfcRampFlight; class IfcRampFlightType; class IfcRationalBezierCurve; class IfcRectangleHollowProfileDef; class IfcRectangleProfileDef; class IfcRectangularPyramid; class IfcRectangularTrimmedSurface; class IfcReferencesValueDocument; class IfcRegularTimeSeries; class IfcReinforcementBarProperties; class IfcReinforcementDefinitionProperties; class IfcReinforcingBar; class IfcReinforcingElement; class IfcReinforcingMesh; class IfcRelAggregates; class IfcRelAssigns; class IfcRelAssignsTasks; class IfcRelAssignsToActor; class IfcRelAssignsToControl; class IfcRelAssignsToGroup; class IfcRelAssignsToProcess; class IfcRelAssignsToProduct; class IfcRelAssignsToProjectOrder; class IfcRelAssignsToResource; class IfcRelAssociates; class IfcRelAssociatesAppliedValue; class IfcRelAssociatesApproval; class IfcRelAssociatesClassification; class IfcRelAssociatesConstraint; class IfcRelAssociatesDocument; class IfcRelAssociatesLibrary; class IfcRelAssociatesMaterial; class IfcRelAssociatesProfileProperties; class IfcRelConnects; class IfcRelConnectsElements; class IfcRelConnectsPathElements; class IfcRelConnectsPortToElement; class IfcRelConnectsPorts; class IfcRelConnectsStructuralActivity; class IfcRelConnectsStructuralElement; class IfcRelConnectsStructuralMember; class IfcRelConnectsWithEccentricity; class IfcRelConnectsWithRealizingElements; class IfcRelContainedInSpatialStructure; class IfcRelCoversBldgElements; class IfcRelCoversSpaces; class IfcRelDecomposes; class IfcRelDefines; class IfcRelDefinesByProperties; class IfcRelDefinesByType; class IfcRelFillsElement; class IfcRelFlowControlElements; class IfcRelInteractionRequirements; class IfcRelNests; class IfcRelOccupiesSpaces; class IfcRelOverridesProperties; class IfcRelProjectsElement; class IfcRelReferencedInSpatialStructure; class IfcRelSchedulesCostItems; class IfcRelSequence; class IfcRelServicesBuildings; class IfcRelSpaceBoundary; class IfcRelVoidsElement; class IfcRelationship; class IfcRelaxation; class IfcRepresentation; class IfcRepresentationContext; class IfcRepresentationItem; class IfcRepresentationMap; class IfcResource; class IfcRevolvedAreaSolid; class IfcRibPlateProfileProperties; class IfcRightCircularCone; class IfcRightCircularCylinder; class IfcRoof; class IfcRoot; class IfcRoundedEdgeFeature; class IfcRoundedRectangleProfileDef; class IfcSIUnit; class IfcSanitaryTerminalType; class IfcScheduleTimeControl; class IfcSectionProperties; class IfcSectionReinforcementProperties; class IfcSectionedSpine; class IfcSensorType; class IfcServiceLife; class IfcServiceLifeFactor; class IfcShapeAspect; class IfcShapeModel; class IfcShapeRepresentation; class IfcShellBasedSurfaceModel; class IfcSimpleProperty; class IfcSite; class IfcSlab; class IfcSlabType; class IfcSlippageConnectionCondition; class IfcSolidModel; class IfcSoundProperties; class IfcSoundValue; class IfcSpace; class IfcSpaceHeaterType; class IfcSpaceProgram; class IfcSpaceThermalLoadProperties; class IfcSpaceType; class IfcSpatialStructureElement; class IfcSpatialStructureElementType; class IfcSphere; class IfcStackTerminalType; class IfcStair; class IfcStairFlight; class IfcStairFlightType; class IfcStructuralAction; class IfcStructuralActivity; class IfcStructuralAnalysisModel; class IfcStructuralConnection; class IfcStructuralConnectionCondition; class IfcStructuralCurveConnection; class IfcStructuralCurveMember; class IfcStructuralCurveMemberVarying; class IfcStructuralItem; class IfcStructuralLinearAction; class IfcStructuralLinearActionVarying; class IfcStructuralLoad; class IfcStructuralLoadGroup; class IfcStructuralLoadLinearForce; class IfcStructuralLoadPlanarForce; class IfcStructuralLoadSingleDisplacement; class IfcStructuralLoadSingleDisplacementDistortion; class IfcStructuralLoadSingleForce; class IfcStructuralLoadSingleForceWarping; class IfcStructuralLoadStatic; class IfcStructuralLoadTemperature; class IfcStructuralMember; class IfcStructuralPlanarAction; class IfcStructuralPlanarActionVarying; class IfcStructuralPointAction; class IfcStructuralPointConnection; class IfcStructuralPointReaction; class IfcStructuralProfileProperties; class IfcStructuralReaction; class IfcStructuralResultGroup; class IfcStructuralSteelProfileProperties; class IfcStructuralSurfaceConnection; class IfcStructuralSurfaceMember; class IfcStructuralSurfaceMemberVarying; class IfcStructuredDimensionCallout; class IfcStyleModel; class IfcStyledItem; class IfcStyledRepresentation; class IfcSubContractResource; class IfcSubedge; class IfcSurface; class IfcSurfaceCurveSweptAreaSolid; class IfcSurfaceOfLinearExtrusion; class IfcSurfaceOfRevolution; class IfcSurfaceStyle; class IfcSurfaceStyleLighting; class IfcSurfaceStyleRefraction; class IfcSurfaceStyleRendering; class IfcSurfaceStyleShading; class IfcSurfaceStyleWithTextures; class IfcSurfaceTexture; class IfcSweptAreaSolid; class IfcSweptDiskSolid; class IfcSweptSurface; class IfcSwitchingDeviceType; class IfcSymbolStyle; class IfcSystem; class IfcSystemFurnitureElementType; class IfcTShapeProfileDef; class IfcTable; class IfcTableRow; class IfcTankType; class IfcTask; class IfcTelecomAddress; class IfcTendon; class IfcTendonAnchor; class IfcTerminatorSymbol; class IfcTextLiteral; class IfcTextLiteralWithExtent; class IfcTextStyle; class IfcTextStyleFontModel; class IfcTextStyleForDefinedFont; class IfcTextStyleTextModel; class IfcTextStyleWithBoxCharacteristics; class IfcTextureCoordinate; class IfcTextureCoordinateGenerator; class IfcTextureMap; class IfcTextureVertex; class IfcThermalMaterialProperties; class IfcTimeSeries; class IfcTimeSeriesReferenceRelationship; class IfcTimeSeriesSchedule; class IfcTimeSeriesValue; class IfcTopologicalRepresentationItem; class IfcTopologyRepresentation; class IfcTransformerType; class IfcTransportElement; class IfcTransportElementType; class IfcTrapeziumProfileDef; class IfcTrimmedCurve; class IfcTubeBundleType; class IfcTwoDirectionRepeatFactor; class IfcTypeObject; class IfcTypeProduct; class IfcUShapeProfileDef; class IfcUnitAssignment; class IfcUnitaryEquipmentType; class IfcValveType; class IfcVector; class IfcVertex; class IfcVertexBasedTextureMap; class IfcVertexLoop; class IfcVertexPoint; class IfcVibrationIsolatorType; class IfcVirtualElement; class IfcVirtualGridIntersection; class IfcWall; class IfcWallStandardCase; class IfcWallType; class IfcWasteTerminalType; class IfcWaterProperties; class IfcWindow; class IfcWindowLiningProperties; class IfcWindowPanelProperties; class IfcWindowStyle; class IfcWorkControl; class IfcWorkPlan; class IfcWorkSchedule; class IfcZShapeProfileDef; class IfcZone; class IfcAbsorbedDoseMeasure; class IfcAccelerationMeasure; class IfcAmountOfSubstanceMeasure; class IfcAngularVelocityMeasure; class IfcAreaMeasure; class IfcBoolean; class IfcBoxAlignment; class IfcComplexNumber; class IfcCompoundPlaneAngleMeasure; class IfcContextDependentMeasure; class IfcCountMeasure; class IfcCurvatureMeasure; class IfcDayInMonthNumber; class IfcDaylightSavingHour; class IfcDescriptiveMeasure; class IfcDimensionCount; class IfcDoseEquivalentMeasure; class IfcDynamicViscosityMeasure; class IfcElectricCapacitanceMeasure; class IfcElectricChargeMeasure; class IfcElectricConductanceMeasure; class IfcElectricCurrentMeasure; class IfcElectricResistanceMeasure; class IfcElectricVoltageMeasure; class IfcEnergyMeasure; class IfcFontStyle; class IfcFontVariant; class IfcFontWeight; class IfcForceMeasure; class IfcFrequencyMeasure; class IfcGloballyUniqueId; class IfcHeatFluxDensityMeasure; class IfcHeatingValueMeasure; class IfcHourInDay; class IfcIdentifier; class IfcIlluminanceMeasure; class IfcInductanceMeasure; class IfcInteger; class IfcIntegerCountRateMeasure; class IfcIonConcentrationMeasure; class IfcIsothermalMoistureCapacityMeasure; class IfcKinematicViscosityMeasure; class IfcLabel; class IfcLengthMeasure; class IfcLinearForceMeasure; class IfcLinearMomentMeasure; class IfcLinearStiffnessMeasure; class IfcLinearVelocityMeasure; class IfcLogical; class IfcLuminousFluxMeasure; class IfcLuminousIntensityDistributionMeasure; class IfcLuminousIntensityMeasure; class IfcMagneticFluxDensityMeasure; class IfcMagneticFluxMeasure; class IfcMassDensityMeasure; class IfcMassFlowRateMeasure; class IfcMassMeasure; class IfcMassPerLengthMeasure; class IfcMinuteInHour; class IfcModulusOfElasticityMeasure; class IfcModulusOfLinearSubgradeReactionMeasure; class IfcModulusOfRotationalSubgradeReactionMeasure; class IfcModulusOfSubgradeReactionMeasure; class IfcMoistureDiffusivityMeasure; class IfcMolecularWeightMeasure; class IfcMomentOfInertiaMeasure; class IfcMonetaryMeasure; class IfcMonthInYearNumber; class IfcNormalisedRatioMeasure; class IfcNumericMeasure; class IfcPHMeasure; class IfcParameterValue; class IfcPlanarForceMeasure; class IfcPlaneAngleMeasure; class IfcPositiveLengthMeasure; class IfcPositivePlaneAngleMeasure; class IfcPositiveRatioMeasure; class IfcPowerMeasure; class IfcPresentableText; class IfcPressureMeasure; class IfcRadioActivityMeasure; class IfcRatioMeasure; class IfcReal; class IfcRotationalFrequencyMeasure; class IfcRotationalMassMeasure; class IfcRotationalStiffnessMeasure; class IfcSecondInMinute; class IfcSectionModulusMeasure; class IfcSectionalAreaIntegralMeasure; class IfcShearModulusMeasure; class IfcSolidAngleMeasure; class IfcSoundPowerMeasure; class IfcSoundPressureMeasure; class IfcSpecificHeatCapacityMeasure; class IfcSpecularExponent; class IfcSpecularRoughness; class IfcTemperatureGradientMeasure; class IfcText; class IfcTextAlignment; class IfcTextDecoration; class IfcTextFontName; class IfcTextTransformation; class IfcThermalAdmittanceMeasure; class IfcThermalConductivityMeasure; class IfcThermalExpansionCoefficientMeasure; class IfcThermalResistanceMeasure; class IfcThermalTransmittanceMeasure; class IfcThermodynamicTemperatureMeasure; class IfcTimeMeasure; class IfcTimeStamp; class IfcTorqueMeasure; class IfcVaporPermeabilityMeasure; class IfcVolumeMeasure; class IfcVolumetricFlowRateMeasure; class IfcWarpingConstantMeasure; class IfcWarpingMomentMeasure; class IfcYearNumber; 

/// The actor select type allows a person, or an organization, or a person associated with an organization to be referenced.
/// 
/// NOTE Corresponds to the following entity in ISO 10303-41: person_organization_select.
/// 
/// HISTORY New entity in IFC Release 1.5.1
/// 
/// SELECT 
/// 
/// IfcOrganization An organization. 
/// IfcPerson A person. 
/// IfcPersonAndOrganization A person related to an organization.
typedef IfcUtil::IfcBaseClass IfcActorSelect;
/// IfcAppliedValueSelect defines the selection of whether a value (expressed as a ratio) or an amount should be used as the value for an IfcAppliedValue. 
/// 
/// Select from:  
/// 
/// IfcMeasureWithUnit 
///   IfcMonetaryMeasure 
///   IfcRatioMeasure 
/// 
/// HISTORY: New SELECT type in IFC 2x2.
/// 
/// Use definitions 
/// Selecting IfcMeasureWithUnit allows the specification of both the actual figure for the value together with the currency in which the value is represented. 
/// Selecting IfcMonetaryMeasure allows the specification only of the value, the currency being as set by the global context 
/// Selecting IfcRatioMeasure assumes that the amount is a percentage or other REAL number. Note that if the amount is normally specified as -20%, then this figure will need to be converted to a multiplier of 0.8
typedef IfcUtil::IfcBaseClass IfcAppliedValueSelect;
/// Definition from ISO/CD 10303-42:1992: This select type collects together both versions of the placement as used in two dimensional or in three dimensional Cartesian space. This enables entities requiring this information to reference them without specifying the space dimensionality.  
/// 
/// NOTE: Corresponding STEP type: axis2_placement, please refer to ISO/IS 10303-42:1994, p. 19 for the final definition of the formal standard.
/// 
/// HISTORY: New type in IFC Release 1.5
typedef IfcUtil::IfcBaseClass IfcAxis2Placement;
/// Definition from ISO/CD 10303-42:1992: This select type identifies
///   all those types of entities which may participate in a Boolean operation to
///   form a CSG solid.  
///   Definition from IAI: CSG primitives are out of scope for the
///   current IFC Release. Only faceted B-reps, swept area solids and half space
///   solids are available as Boolean operands. Boolean results themselves can be used
///   as operands thus enabling nested Boolean operations. 
/// 
/// NOTE Corresponding STEP type:
///   boolean_operand, please refer to ISO/IS 10303-42:1994, p.167 for the final
///   definition of the formal standard. In IFC Release 1.5.1 & 2.0 only Boolean
///   results (IfcBooleanResult), half space solids
///   (IfcHalfSpaceSolid), faceted B-Rep, extruded solids and revolved solids
///   (IfcSolidModel) are defined for being valid Boolean operands.
/// 
/// HISTORY: New Type in IFC Release 1.5.1
typedef IfcUtil::IfcBaseClass IfcBooleanOperand;
/// The character style select allows for a selection of character styles for text. Currently only text color and background color is selectable.
/// 
/// NOTE  Corresponding ISO 10303 name: character_style_select. Please refer to ISO/IS
/// 10303-46:1994, p. 89 for the final definition of the formal standard.
/// 
/// HISTORY  New type in IFC2x2.
/// 
/// IFC2x3 CHANGE  The SELECT item IfcTextStyleForDefinedFont replaces the old IfcColour.
typedef IfcUtil::IfcBaseClass IfcCharacterStyleSelect;

typedef IfcUtil::IfcBaseClass IfcClassificationNotationSelect;
/// Definition from ISO/CD 10303-46:1992: The colour entity defines a basic appearance of elements which shall be visualized in a picture.
/// 
/// NOTE  Corresponding STEP name: colour. It has been made into a SELECT type in IFC to avoid multiple inheritance for pre defined colour. Please refer to ISO/IS 10303-46:1994, p. 138 for the final definition of the formal standard.
/// 
/// HISTORY  New entity in IFC2x2.
typedef IfcUtil::IfcBaseClass IfcColour;
/// The IfcColourOrFactor enables the selection of either a RGB colour value or a scalar factor value for the use as values of the reflectance components.
/// 
/// HISTORY: New type in IFC2x2.
typedef IfcUtil::IfcBaseClass IfcColourOrFactor;

typedef IfcUtil::IfcBaseClass IfcConditionCriterionSelect;
/// Definition from ISO/CD 10303-42:1992: This type identifies the types of entity which may be selected as the root of a CSG tree including a single CSG primitive as a special case.
/// Definition from IAI: The IfcBooleanResult, and subtypes of IfcCsgPrimitive3D are defined as potential root tree expression (at IfcCsgSolid). A subtype of IfcCsgPrimitive3D marks the special case of a CSG solid solely expressed by a single primitive.
/// 
/// NOTE Corresponding ISO 10303-42 type: csg_select, please refer to ISO/IS 10303-42:1994, p.168 for the final definition of the formal standard.
/// 
/// HISTORY New Type in IFC Release 1.5.1.
typedef IfcUtil::IfcBaseClass IfcCsgSelect;
/// Definition from ISO/CD 10303-46:1992: The curve font or scaled curve font select is a selection of either a curve font style select (being either a predefined curve font or an explicitly defined curve font) or a curve style font and scaling. 
/// 
/// NOTE Corresponding ISO 10303 name: curve_font_or_scaled_curve_font_select. Please refer to ISO/IS 10303-46:1994 for the final definition of the formal standard.
/// 
/// HISTORY New entity in IFC2x2.
typedef IfcUtil::IfcBaseClass IfcCurveFontOrScaledCurveFontSelect;
/// IfcCurveOrEdgeCurve provides the option to either select a geometric curve (IfcCurve
/// and subtypes) within a geometric model, or a curve with associated geometry and coordinates (IfcEdgeCurve) within a topological model.
/// SELECT 
/// 
/// IfcCurve
///   IfcEdgeCurve
/// 
/// HISTORY  New select type in IFC2x Edition 3.
typedef IfcUtil::IfcBaseClass IfcCurveOrEdgeCurve;
/// Definition from ISO/CD 10303-46:1992: The curve style font select is a selection of a curve style font or a predefined curve style font. 
/// 
/// NOTE Corresponding ISO 10303 name: curve_style_font_select. Please refer to ISO/IS 10303-46:1994 for the final definition of the formal standard.
/// 
/// HISTORY New entity in IFC2x2.
typedef IfcUtil::IfcBaseClass IfcCurveStyleFontSelect;

typedef IfcUtil::IfcBaseClass IfcDateTimeSelect;
/// The defined symbol select is a selection between a predefined symbol and an externally defined symbol. 
/// 
/// NOTE Corresponding ISO 10303 name: defined_symbol_select. Please refer to ISO/IS 10303-46:1994 for the final definition of the formal standard.
/// 
/// HISTORY New type in IFC2x2.
typedef IfcUtil::IfcBaseClass IfcDefinedSymbolSelect;
/// IfcDerivedMeasureValue is a select type for selecting between derived measure types.
/// 
/// SELECT 
/// 
/// IfcAbsorbedDoseMeasure 
///   IfcAccelerationMeasure 
///   IfcAngularVelocityMeasure 
///   IfcCompoundPlaneAngleMeasure 
///   IfcDoseEquivalentMeasure 
///   IfcDynamicViscosityMeasure 
///   IfcElectricCapacitanceMeasure 
///   IfcElectricChargeMeasure 
///   IfcElectricConductanceMeasure 
///   IfcElectricResistanceMeasure 
///   IfcElectricVoltageMeasure 
///   IfcEnergyMeasure 
///   IfcForceMeasure 
///   IfcFrequencyMeasure 
///   IfcHeatFluxDensityMeasure 
///   IfcIlluminanceMeasure 
///   IfcInductanceMeasure 
///   IfcIntegerCountRateMeasure 
///   IfcIsothermalMoisturecapacityMeasure 
///   IfcKinematicViscosityMeasure 
///   IfcLinearForceMeasure 
///   IfcLinearMomentMeasure  
///   IfcLinearStiffnessMeasure 
///   IfcLinearVelocityMeasure 
///   IfcLuminousFluxMeasure 
///   IfcMagneticFluxDensityMeasure 
///   IfcMagneticFluxMeasure 
///   IfcMassDensityMeasure 
///   IfcMassFlowRateMeasure 
///   IfcModulusOfElasticityMeasure 
///   IfcModulusOfSubgradeReactionMeasure 
///   IfcMoistureDiffusivityMeasure 
///   IfcMolecularWeightMeasure 
///   IfcMomentOfInertiaMeasure  
///   IfcMonetaryMeasure 
///   IfcPlanarForceMeasure 
///   IfcPowerMeasure 
///   IfcPressureMeasure 
///   IfcRadioActivityMeasure 
///   IfcRotationalFrequencyMeasure 
///   IfcRotationalStiffnessMeasure 
///   IfcShearModulusMeasure 
///   IfcSpecificHeatCapacityMeasure 
///   IfcThermalAdmittanceMeasure 
///   IfcThermalConductivityMeasure 
///   IfcThermalResistanceMeasure 
///   IfcThermalTransmittanceMeasure 
///   IfcTimeStamp 
///   IfcTorqueMeasure 
///   IfcVaporPermeabilityMeasure 
///   IfcVolumetricFlowRateMeasure 
///   IfcCurvatureMeasure 
///   IfcMassPerLengthMeasure 
///   IfcRotationalMassMeasure 
///   IfcSectionalAreaIntegralMeasure 
///   IfcSectionModulusMeasure 
///   IfcTemperatureGradientMeasure 
///   IfcTemperatureRateOfChangeMeasure 
///   IfcWarpingConstantMeasure 
///   IfcWarpingMomentMeasure 
///   IfcThermalExpansionCoefficientMeasure 
///   IfcModulusOfLinearSubgradeReactionMeasure 
///   IfcModulusOfRotationalSubgradeReactionMeasure 
///   IfcLuminousIntensityDistributionMeasure 
///   IfcSoundPowerMeasure 
///   IfcSoundPressureMeasure 
/// 
/// HISTORY New type in IFC Release 2x.
/// 
/// IFC2x4 change: added IfcTemperatureRateOfChangeMeasure.
typedef IfcUtil::IfcBaseClass IfcDerivedMeasureValue;
/// IfcDocumentSelect enables selection of whether document information is to be contained within an IFC model or is to be referenced from an external source. 
/// 
/// HISTORY: New Select Type in IFC 2x
/// 
/// Select From: 
/// 
/// IfcDocumentInformation (for "metadata" of an external document)  
/// IfcDocumentReference (for reference within a document)
typedef IfcUtil::IfcBaseClass IfcDocumentSelect;

typedef IfcUtil::IfcBaseClass IfcDraughtingCalloutElement;
/// The fill area style tile shape select is used to make a selection for the style of the fill area style tile.
/// 
/// NOTE: The IfcFillAreaStyleTileShapeSelect is an entity that had been adopted from ISO 10303, Industrial automation systems and integration&#151;Product data representation and exchange, Part 46: Integrated generic resources: Visual presentation.
/// 
/// NOTE Corresponding ISO 10303 name: fill_area_style_tile_shape_select. Please refer to ISO/IS 10303-46:1994 for the final definition of the formal standard.
/// 
/// HISTORY New type in IFC2x2.
typedef IfcUtil::IfcBaseClass IfcFillAreaStyleTileShapeSelect;
/// Definition from ISO/CD 10303-46:1992: The fill style select is a selection between different fill area styles.
/// 
/// NOTE Corresponding ISO 10303 name: fill_style_select. Please refer to ISO/IS 10303-46:1994 for
/// the final definition of the formal standard.
/// 
/// HISTORY New type in IFC2x2.
typedef IfcUtil::IfcBaseClass IfcFillStyleSelect;
/// Definition from ISO/CD 10303-42:1992: This select type identifies the types of entities which can occur in a geometric set. 
/// 
/// NOTE: Corresponding ISO 10303 type: geometric_set_select. Please refer to ISO/IS 10303-42:1994, p. 169 for the final definition of the formal standard.
/// 
/// HISTORY: New type in IFC Release 2x.
typedef IfcUtil::IfcBaseClass IfcGeometricSetSelect;
/// The IfcHatchLineDistanceSelect is a selection between different ways to determine the distance and potentially start point of hatch lines, either by an offset distance length measure or by a vector.
/// 
/// HISTORY  New type in IFC2x3.
typedef IfcUtil::IfcBaseClass IfcHatchLineDistanceSelect;
/// Definition from ISO/CD 10303-46:1992: The layered things type selects those things, which can be grouped in layers. 
/// 
/// It is the collection of all those items, that are assigned to a single layer. These items are representation items or complete representations (IfcRepresentationItem, IfcRepresentation). If an IfcRepresentation is referenced, all IfcRepresentationItem within its set of Items are assigned to the same layer. 
/// 
/// NOTE: Corresponding ISO 10303 name: layered_item. It was called layered_things in the ISO/CD version and had been renamed to layered_item in the ISO/IS final version. Please refer to ISO/IS 10303-46:1994, p. 13 for the final definition of the formal standard.
/// 
/// HISTORY: New type in IFC2x2.
typedef IfcUtil::IfcBaseClass IfcLayeredItem;
/// IfcLibrarySelect enables selection of whether library information is to be contained within an IFC model or is to be referenced from an external source. 
/// 
/// HISTORY: New Select Type in IFC2x
/// 
/// Select From: 
/// 
/// IfcLibraryInformation (for library information)  
/// IfcLibraryReference (for reference into a library of information by location)  
/// 
/// Generally, it is expected that selection will be IfcLibraryReference and only rarely IfcLibraryInformation. IfcLibraryInformation should only be selected in circumstances where there could be a need to indicate the libraries that will be used without making individual references. This may occur for higher level objects such as a project or building.
typedef IfcUtil::IfcBaseClass IfcLibrarySelect;
/// A goniometric light gets its intensity distribution function (how much light goes in any one direction) from one of two sources: (i) an industry-standard file, (ii) from distribution data passed directly via the IfcLightIntensityDistribution. 
/// 
/// The light distribution provides the luminous intensity distribution according to some standardized light distribution curves. 
/// 
/// Select: 
/// 
/// Type 
///   Definition 
/// 
/// IfcExternalReference 
///   Light distribution is represented by a standard photometric data file such as Eulumdat, IES, CIBSE TM14.  
/// 
/// IfcLightIntensityDistribution 
///   For representing a light distribution directly the
///   following values needs to be given in a table like structure with column and
///   row headings. These headings should contain the angles (C/&#947; or B/&#946; )
///   and the table body contains the intensity values, (normally normalized to
///   cd/Klm). The angles can be non- equidistant and the angle steps can be almost
///   any value in the valid range, so a list of all available angles in both
///   directions covers all cases.  
/// 
/// HISTORY New type in IFC2x2.
typedef IfcUtil::IfcBaseClass IfcLightDistributionDataSourceSelect;
/// IfcMaterialSelect provides selection of either a material
/// definition or a material usage definition that can be assigned to
/// an element, a resource or another entity within IFC.
/// SELECT
/// 
/// IfcMaterialDefinition
/// 
/// IfcMaterial
/// IfcMaterialLayer
/// IfcMaterialLayerSet
/// IfcMaterialProfile
/// IfcMaterialProfileSet
/// IfcMaterialConstituent
/// IfcMaterialConstituentSet
/// 
/// IfcMaterialUsageDefinition
/// 
/// IfcMaterialLayerSetUsage
/// IfcMaterialProfileSetUsage
/// 
/// IfcMaterialList
/// 
/// HISTORY New select in IFC 1.0
/// 
/// IFC2x4 CHANGE The select now includes two new abstract entities IfcMaterialDefinition
/// and IfcMaterialUsageDefinition with upward compatibility.  The use of IfcMaterialList is deprecated from IFC2x4 onwards.
typedef IfcUtil::IfcBaseClass IfcMaterialSelect;
/// Definition from ISO/CD 10303-41:1992: A measure value is a value as defined in ISO 31-0 (clause 2).
/// 
/// NOTE IfcMeasureValue is a select data type for most basic measure types coming from ISO 10303-41.  Select item IfcNonNegativeLengthMeasure is in addition to ISO 10303-41.
/// 
/// NOTE Corresponding ISO 10303 name: measure_value, please refer to ISO/IS 10303-41 for the final definition of the formal standard.
/// 
/// HISTORY New type in IFC Release 1.5.1.
/// 
/// IFC 2x4 change: added IfcNonNegativeLengthMeasure
typedef IfcUtil::IfcBaseClass IfcMeasureValue;
/// IfcMetricValueSelect is a select type that enables selection of the data type for the value component of an IfcMetric. 
/// 
/// HISTORY: New type in IFC Release 2.0
/// 
/// Select 
/// 
/// IfcCostValue
///   IfcDateTime 
///   IfcMeasureWithUnit 
///   IfcTable 
///   IfcText 
///   IfcTimeSeries
typedef IfcUtil::IfcBaseClass IfcMetricValueSelect;
/// IfcObjectReferenceSelect is a select type, that holds a list of resource level entities that can be used as properties within a property set. 
/// 
/// HISTORY  New select type in IFC Release 2.0.
typedef IfcUtil::IfcBaseClass IfcObjectReferenceSelect;

typedef IfcUtil::IfcBaseClass IfcOrientationSelect;
/// IfcPointOrVertexPoint provides the option to either select a geometric point (IfcPoint and subtypes) within a geometric model, or a vertex with associated point coordinates (IfcVertexPoint) within a topological model.
/// SELECT 
/// 
/// IfcPoint, 
///   IfcVertexPoint
/// 
/// HISTORY  New select type in IFC2x Edition 3.
typedef IfcUtil::IfcBaseClass IfcPointOrVertexPoint;
/// Definition from ISO/CD 10303-46:1992: The presentation style select is a selection of one of many kinds of styles, a different one for each kind of geometric representation item to be styled.
/// 
/// NOTE Corresponding ISO 10303 name: presentation_style_Select. Please refer to ISO/IS
/// 10303-46:1994 for the final definition of the formal standard.
/// 
/// HISTORY New type in IFC2x2.
/// 
/// IFC2x4 CHANGE The select type has been deprecated.
typedef IfcUtil::IfcBaseClass IfcPresentationStyleSelect;
/// Definition from ISO/CD 10303-42:1992 This type collects together, for reference when constructing more complex models, the subtypes which have the characteristics of a shell. A shell is a connected object of fixed dimensionality d = 0; 1; or 2, typically used to bound a region. The domain of a shell, if present, includes its bounds and 0 £ X < ¥.  
/// 
/// A shell of dimensionality 0 is represented by a graph consisting of a single vertex. The vertex shall not have any associated edges. 
/// A shell of dimensionality 1 is represented by a connected graph of dimensionality 1. 
/// A shell of dimensionality 2 is a topological entity constructed by joining faces along edges. Its domain, if present, is a connected, orientable 2-manifold with boundary, that is, a connected, oriented, finite, non-self-intersecting surface, which may be closed or open. 
/// 
/// Shells of dimensionality 0 and 1 are not part of the current IFC release. 
/// 
/// NOTE  Corresponding ISO 10303 type: shell. Please refer to ISO/IS 10303-42:1994, p. 127 for the final definition of the formal standard. Only the select items closed_shell (IfcClosedShell) and open_shell (IfcOpenShell) have been incorporated in the current IFC release. 
/// 
/// HISTORY  New type in IFC2x.
typedef IfcUtil::IfcBaseClass IfcShell;
/// IfcSimpleValue is a select type for selecting between simple value types.
/// 
/// SELECT 
/// 
/// IfcInteger: Defined type of simple type INTEGER. 
///   IfcReal: Defined type of simple type REAL. 
///   IfcBoolean: Defined type of simple type BOOLEAN. 
///   IfcLogical: Defined type of simple type LOGICAL. 
///   IfcIdentifier: Defined type of simple type STRING for identification purposes. 
///   IfcLabel: Defined type of simple type STRING for naming purposes. 
///   IfcText: Defined type of simple type STRING for descriptive purposes. 
///   IfcDateTime: Defined type of simple type STRING to represent a date and time. 
///   IfcDate: Defined type of simple type STRING to represent a date. 
///   IfcTime: Defined type of simple type STRING to represent a time. 
///   IfcDuration: Defined type of simple type STRING to represent a duration. 
/// 
/// HISTORY New type in IFC Release 2x.
/// 
/// IFC2x4 CHANGE Items IfcDateTime, IfcDate, IfcTime, IfcDuration added.
typedef IfcUtil::IfcBaseClass IfcSimpleValue;
/// Definition from ISO/CD 10303-46:1992: The size select is a selection of a specific positive length measure.
/// 
/// Definition from ISO: The size (or width) measure value is given in the global drawing length units.
/// 
/// NOTE  global units are defined at the single IfcProject instance, given by UnitsInContext:IfcUnitAssignment, the same units are used for the geometric representation items and for the style definitions.
/// 
/// NOTE  Corresponding ISO 10303 name: size_select. Please refer to ISO/IS 10303-46:1994 for the final
/// definition of the formal standard.
/// 
/// HISTORY  New type in IFC2x2.
/// 
/// IFC2x3 CHANGE  The SELECT item IfcMeasureWithUnit has been removed from the IfcSizeSelect, the IfcRatioMeasure and IfcDescriptiveMeasure has been added.
typedef IfcUtil::IfcBaseClass IfcSizeSelect;
/// The IfcSpecularHighlightSelect defines the selectable types of value for specular highlight sharpness. 
/// 
/// NOTE: The two select types relate to the different ways to specifiy the sharpness (or shininess) of the specular part of the reflectance equation. It relates to the attributes: 
/// 
/// in ISO10303-46 the attribute specular_exponent is given 
///   in VRML97 the attribute shininess is given 
/// 
/// For each surface side style only one of the two methods is needed for calculating the specular part of the equation.
/// 
/// HISTORY: New type in IFC2x2.
typedef IfcUtil::IfcBaseClass IfcSpecularHighlightSelect;
/// Definition from IAI: This type definition shall be used to
///   distinguish between a reference to an instance either of
///   IfcStructuralItem or IfcBuildingElement. The
///   IfcStructuralActivityAssignmentSelect type is referenced by the entity
///   IfcRelConnectsStructuralActivity which defines the connection between
///   activities (IfcStructuralActivity) and the loaded element.  
/// 
/// HISTORY: New type in Release IFC2x
///   Edition 2.
typedef IfcUtil::IfcBaseClass IfcStructuralActivityAssignmentSelect;
/// IfcSurfaceOrFaceSurface provides the option to either select a geometric surface (IfcSurface
/// and subtypes) within a geometric model, or a face with associated surface geometry and coordinates (IfcFaceSurface) within a topological model.
/// SELECT 
/// 
/// IfcSurface 
///   IfcFaceSurface
///   IfcFaceBasedSurfaceModel (a connected face set, representing a faceted surface as an approximation of a non planar, non rectangular bounded surface)
/// 
/// HISTORY  New select type in IFC2x3.
typedef IfcUtil::IfcBaseClass IfcSurfaceOrFaceSurface;
/// Definition from ISO/CD 10303-46:1992: The surface style element select is a selection of the different surface styles to use in the presentation of the side of a surface. 
/// 
/// The select type only includes the IfcSurfaceStyleRendering (which is the equivalent to surface_style_rendering) from the select type surface_style_element_select. In addition it has the IfcSurfaceStyleLighting, which holds the exact physically based lighting properties for lighting based calculation algorithms (as the opposite to the rendering based calculation), the IfcSurfaceStyleRefraction (for more advanced refraction indices) and IfcSurfaceStyleWithTextures (to allow for image textures applied to surfaces). In addition an IfcExternallyDefinedSurfaceStyle can be selected that points into an external material library. 
/// 
/// NOTE The IfcSurfaceLightingProperties are needed for exact lighting calculation, because physically based lighting calculation algorithms need exact physically based parameters. The factors in IfcSurfaceStyleRendering lack the physical base, they are intended for rendering calculations, but a lighting calculation based software cannot use these values.
/// 
/// NOTE: Corresponding ISO 10303 type: surface_style_element_select. Please refer to ISO/IS 10303-46:1994, p. 85 for the final definition of the formal standard.
/// 
/// HISTORY: New Select type in IFC2x2.
typedef IfcUtil::IfcBaseClass IfcSurfaceStyleElementSelect;
/// The symbol style select allows for the selection of styles to be assigned to an annotated symbol.
/// 
/// NOTE: The selection is restricted to colour within the current release of IFC
/// 
/// NOTE Corresponding ISO 10303 name: symbol_style_select. Please refer to ISO/IS 10303-46:1994 for the final definition of the formal standard.
/// 
/// HISTORY New entity in IFC2x2.
typedef IfcUtil::IfcBaseClass IfcSymbolStyleSelect;
/// IfcTextFontSelect allows for either a predefined text font, a text font model or an externally defined text font to be used to describe the font of a text literal. The definition of the text font model is based on W3C TR Cascading Style Sheet Version 1, whereas the definition of predefined text font is based on ISO 10303.
/// 
/// NOTE  IfcTextFontSelect is an entity that had been adopted from ISO 10303, Industrial automation systems and integration—Product data representation and exchange, Part 46: Integrated generic resources: Visual presentation. Corresponding ISO 10303 name: font_select. Please refer to ISO/IS 10303-46:1994, p. 133 for the final definition of the formal standard.
/// 
/// HISTORY  New type in IFC2x2.
/// 
/// IFC2x3 CHANGE  The select type has been renamed from IfcFontSelect.
typedef IfcUtil::IfcBaseClass IfcTextFontSelect;
/// The text style select allows for the selection of styles to be assigned to an annotated text. The text style determines the text model that affect the visual presentation of characters, spaces, words, and paragraphs. There are two choices:
/// 
/// IfcTextStyleWithBoxCharacteristics for definitions from ISO/IS 10303-46:1994 for (old) vector based and monospace text.
///   IfcTextStyleTextModel for definitions from Cascading
/// Style Sheets, level 1, W3C Recommendation 17 Dec 1996, revised 11 Jan 1999, CSS1, for all true type text. The use of the CSS1 definitions is the preferred way to represent text styles.
/// 
/// HISTORY  New type in IFC2x2.
/// 
/// IFC2x3 CHANGE  The items within the IfcTextStyleSelect have changed to IfcTextStyleWithBoxCharacteristics and IfcTextStyleTextModel.
typedef IfcUtil::IfcBaseClass IfcTextStyleSelect;
/// Definition from ISO/CD 10303-42:1992: This select type identifies the two possible ways of trimming a parametric curve; by a Cartesian point on the curve, or by a REAL number defining a parameter value within the parametric range of the curve. 
/// 
/// NOTE Corresponding ISO 10303 type: trimming_select, please refer to ISO/IS 10303-42:1994, p. 20 for the final definition of the formal standard.
/// 
/// HISTORY New Type in IFC Release 1.0
typedef IfcUtil::IfcBaseClass IfcTrimmingSelect;
/// Definition from ISO/CD 10303-41:1992: A unit is a physical quantity, with a value of one, which is used as a standard in terms of which other quantities are expressed.
/// 
/// NOTE: Select item IfcMonetaryUnit is an addition to ISO 10303-41.
/// 
/// NOTE: Corresponding ISO 10303 name: unit, please refer to ISO/IS 10303-41 for the final definition of the formal standard.
/// 
/// SELECT 
/// 
/// IfcNamedUnit: A unit which is identified by a name.
/// IfcDerivedUnit: A unit which is derived from an expression of units. 
/// IfcMonetaryUnit: A unit for defining currencies. 
/// 
/// HISTORY: New type in IFC Release 1.5.1.
typedef IfcUtil::IfcBaseClass IfcUnit;
/// IfcValue is a select type for selecting between more specialised select types IfcSimpleValue,
/// IfcMeasureValue and IfcDerivedMeasureValue.
/// 
/// SELECT 
/// 
/// IfcSimpleValue A select type for basic defined types of simple data type. 
///   IfcMeasureValue A select type for basic measure types of ISO 10303-41. 
///   IfcDerivedMeasureValue A select type for derived measure types.
/// 
/// HISTORY New type in IFC Release 2x.
typedef IfcUtil::IfcBaseClass IfcValue;
/// Definition from ISO/CD 10303-42:1992: This type is used to
///   identify the types of entity which can participate in vector computations. 
/// 
/// NOTE Corresponding STEP type:
///   vector_or_direction, please refer to ISO/IS 10303-42:1994, p. 20 for the final
///   definition of the formal standard.  
///   HISTORY New Type in IFC Release
///   1.5
typedef IfcUtil::IfcBaseClass IfcVectorOrDirection;
namespace IfcActionSourceTypeEnum {
/// Definition from IAI:This enumeration type contains possible
///   action sources. 
/// 
/// HISTORY: New type in Release IFC2x
///   Edition 2.
typedef enum {IfcActionSourceType_DEAD_LOAD_G, IfcActionSourceType_COMPLETION_G1, IfcActionSourceType_LIVE_LOAD_Q, IfcActionSourceType_SNOW_S, IfcActionSourceType_WIND_W, IfcActionSourceType_PRESTRESSING_P, IfcActionSourceType_SETTLEMENT_U, IfcActionSourceType_TEMPERATURE_T, IfcActionSourceType_EARTHQUAKE_E, IfcActionSourceType_FIRE, IfcActionSourceType_IMPULSE, IfcActionSourceType_IMPACT, IfcActionSourceType_TRANSPORT, IfcActionSourceType_ERECTION, IfcActionSourceType_PROPPING, IfcActionSourceType_SYSTEM_IMPERFECTION, IfcActionSourceType_SHRINKAGE, IfcActionSourceType_CREEP, IfcActionSourceType_LACK_OF_FIT, IfcActionSourceType_BUOYANCY, IfcActionSourceType_ICE, IfcActionSourceType_CURRENT, IfcActionSourceType_WAVE, IfcActionSourceType_RAIN, IfcActionSourceType_BRAKES, IfcActionSourceType_USERDEFINED, IfcActionSourceType_NOTDEFINED} IfcActionSourceTypeEnum;
const char* ToString(IfcActionSourceTypeEnum v);
IfcActionSourceTypeEnum FromString(const std::string& s);
}
namespace IfcActionTypeEnum {
/// Definition from IAI: This enumeration type is used to distinguish
///   between possible action types at a high level. It can be used for an automated
///   definition of load combinations and for dimensioning. The contained items and
///   their acronyms are adopted from the Eurocode standard. 
/// 
/// HISTORY: New type in Release IFC2x
///   Edition 2.
typedef enum {IfcActionType_PERMANENT_G, IfcActionType_VARIABLE_Q, IfcActionType_EXTRAORDINARY_A, IfcActionType_USERDEFINED, IfcActionType_NOTDEFINED} IfcActionTypeEnum;
const char* ToString(IfcActionTypeEnum v);
IfcActionTypeEnum FromString(const std::string& s);
}
namespace IfcActuatorTypeEnum {
/// The IfcActuatorTypeEnum defines the range of different types of actuator that can be specified. 
/// 
/// HISTORY: New type in IFC
///   R2.0  
///   Enumeration 
/// 
/// ELECTRICACTUATOR: A device that electrically actuates a control element.  
/// PNEUMATICACTUATOR<: A device that pneumatically actuates a control element  
/// HYDRAULICACTUATOR: A device that electrically actuates a control element.  
/// HANDOPERATEDACTUATOR: A device that manually actuates a control element. 
/// THERMOSTATICACTUATOR: A device that thermostatically actuates a control element. 
/// USERDEFINED: User-defined type. 
/// NOTDEFINED: Undefined type. 
/// 
/// See property set of actuator common attributes for specification of
///   properties for hand operated actuators.
typedef enum {IfcActuatorType_ELECTRICACTUATOR, IfcActuatorType_HANDOPERATEDACTUATOR, IfcActuatorType_HYDRAULICACTUATOR, IfcActuatorType_PNEUMATICACTUATOR, IfcActuatorType_THERMOSTATICACTUATOR, IfcActuatorType_USERDEFINED, IfcActuatorType_NOTDEFINED} IfcActuatorTypeEnum;
const char* ToString(IfcActuatorTypeEnum v);
IfcActuatorTypeEnum FromString(const std::string& s);
}
namespace IfcAddressTypeEnum {
/// Definition from IAI: Identifies the logical location of the address.
/// 
/// HISTORY New type in IFC Release 2x.
/// 
/// ENUMERATION 
/// 
/// OFFICE An office address. 
///   SITE A site address.
///   HOME A home address.
///   DISTRIBUTIONPOINT A postal distribution point address.
///   USERDEFINED A user defined address type to be provided.
typedef enum {IfcAddressType_OFFICE, IfcAddressType_SITE, IfcAddressType_HOME, IfcAddressType_DISTRIBUTIONPOINT, IfcAddressType_USERDEFINED} IfcAddressTypeEnum;
const char* ToString(IfcAddressTypeEnum v);
IfcAddressTypeEnum FromString(const std::string& s);
}
namespace IfcAheadOrBehind {

typedef enum {IfcAheadOrBehind_AHEAD, IfcAheadOrBehind_BEHIND} IfcAheadOrBehind;
const char* ToString(IfcAheadOrBehind v);
IfcAheadOrBehind FromString(const std::string& s);
}
namespace IfcAirTerminalBoxTypeEnum {
/// This enumeration identifies different types of air terminal boxes.   
/// 
/// Valid enumerations are:
/// 
/// CONSTANTFLOW:  Terminal box does not include a means to reset the volume automatically to an outside signal such as thermostat.
///   VARIABLEFLOWPRESSUREDEPENDANT:  terminal box includes a means to reset the volume automatically to a different control point in response to an outside signal such as thermostat: air-flow rate depends on supply pressure.
///   VARIABLEFLOWPRESSUREINDEPENDANT:  terminal box includes a means to reset the volume automatically to a different control point in response to an outside signal such as thermostat: air-flow rate is independant of supply pressure.
///   USERDEFINED:				  User-defined terminal box.
///   NOTDEFINED:					  Undefined terminal box.
/// 
/// HISTORY: New enumeration in IFC R2.0
typedef enum {IfcAirTerminalBoxType_CONSTANTFLOW, IfcAirTerminalBoxType_VARIABLEFLOWPRESSUREDEPENDANT, IfcAirTerminalBoxType_VARIABLEFLOWPRESSUREINDEPENDANT, IfcAirTerminalBoxType_USERDEFINED, IfcAirTerminalBoxType_NOTDEFINED} IfcAirTerminalBoxTypeEnum;
const char* ToString(IfcAirTerminalBoxTypeEnum v);
IfcAirTerminalBoxTypeEnum FromString(const std::string& s);
}
namespace IfcAirTerminalTypeEnum {
/// Enumeration defining the functional types of air terminals. 
///   The IfcAirTerminalTypeEnum contains the following:
/// 
/// GRILLE: A covering for any area through which air passes.
///   REGISTER: A grille typically equipped with a damper or control valve.
///   DIFFUSER: An outlet discharging supply air in various directions and planes.
///   LOUVRE: A rectilinear louvre.
///   USERDEFINED: User-defined air terminal type.
///   NOTDEFINED:  Undefined air terminal type.
/// 
/// NOTE: Architectural louvres within doors or windows are defined by IfcPermeableCoveringProperties.
/// 
/// HISTORY: New enumeration in IFC R2x2.  Modified in IFC R2x4 to add LOUVRE and remove EYEBALL, IRIS, LINEARGRILLE, LINEARDIFFUSER
typedef enum {IfcAirTerminalType_GRILLE, IfcAirTerminalType_REGISTER, IfcAirTerminalType_DIFFUSER, IfcAirTerminalType_EYEBALL, IfcAirTerminalType_IRIS, IfcAirTerminalType_LINEARGRILLE, IfcAirTerminalType_LINEARDIFFUSER, IfcAirTerminalType_USERDEFINED, IfcAirTerminalType_NOTDEFINED} IfcAirTerminalTypeEnum;
const char* ToString(IfcAirTerminalTypeEnum v);
IfcAirTerminalTypeEnum FromString(const std::string& s);
}
namespace IfcAirToAirHeatRecoveryTypeEnum {
/// Defines general types of pumps.
///   The IfcPumpTypeEnum contains the following:
/// 
/// FIXEDPLATECOUNTERFLOWEXCHANGER: Heat exchanger with moving parts and alternate layers of plates, separated and sealed from the exhaust and supply air stream passages with primary air enters at secondary air outlet location and exits at secondary air inlet location.
///   FIXEDPLATECROSSFLOWEXCHANGER: Heat exchanger with moving parts and alternate layers of plates, separated and sealed from the exhaust and supply air stream passages with secondary air flow in the direction perpendicular to primary air flow.
///   FIXEDPLATEPARALLELFLOWEXCHANGER: Heat exchanger with moving parts and alternate layers of plates, separated and sealed from the exhaust and supply air stream passages with primary air enters at secondary air inlet location and exits at secondary air outlet location.
///   ROTARYWHEEL: A heat wheel with a revolving cylinder filled with an air-permeable medium having a large internal surface area.
///   RUNAROUNDCOILLOOP: A typical coil energy recovery loop places extended surface, finned tube water coils in the supply and exhaust airstreams of a building.
///   HEATPIPE: A passive energy recovery device with a heat pipe divided into evaporator and condenser sections.
///   TWINTOWERENTHALPYRECOVERYLOOPS: An air-to-liquid, liquid-to-air enthalpy recovery system with a sorbent liquid circulates continuously between supply and exhaust airstreams, alternately contacting both airstreams directly in contactor towers.
///   THERMOSIPHONSEALEDTUBEHEATEXCHANGERS: Sealed systems that consist of an evaporator, a condenser, interconnecting piping, and an intermediate working fluid that is present in both liquid and vapor phases where the evaporator and the condenser are usually at opposite ends of a bundle of straight, individual thermosiphon tubes and the exhaust and supply ducts are adjacent to each other.
///   THERMOSIPHONCOILTYPEHEATEXCHANGERS: Sealed systems that consist of an evaporator, a condenser, interconnecting piping, and an intermediate working fluid that is present in both liquid and vapor phases where the evaporator and condensor coils are installed independently in the ducts and are interconnected by the working fluid piping.
///   USERDEFINED: User-defined air to air heat recovery type.
///   NOTDEFINED:  Undefined air to air heat recovery type.
/// 
/// HISTORY: New enumeration in IFC R2x.
typedef enum {IfcAirToAirHeatRecoveryType_FIXEDPLATECOUNTERFLOWEXCHANGER, IfcAirToAirHeatRecoveryType_FIXEDPLATECROSSFLOWEXCHANGER, IfcAirToAirHeatRecoveryType_FIXEDPLATEPARALLELFLOWEXCHANGER, IfcAirToAirHeatRecoveryType_ROTARYWHEEL, IfcAirToAirHeatRecoveryType_RUNAROUNDCOILLOOP, IfcAirToAirHeatRecoveryType_HEATPIPE, IfcAirToAirHeatRecoveryType_TWINTOWERENTHALPYRECOVERYLOOPS, IfcAirToAirHeatRecoveryType_THERMOSIPHONSEALEDTUBEHEATEXCHANGERS, IfcAirToAirHeatRecoveryType_THERMOSIPHONCOILTYPEHEATEXCHANGERS, IfcAirToAirHeatRecoveryType_USERDEFINED, IfcAirToAirHeatRecoveryType_NOTDEFINED} IfcAirToAirHeatRecoveryTypeEnum;
const char* ToString(IfcAirToAirHeatRecoveryTypeEnum v);
IfcAirToAirHeatRecoveryTypeEnum FromString(const std::string& s);
}
namespace IfcAlarmTypeEnum {
/// The IfcAlarmTypeEnum defines the range of different types of alarm that can be specified. 
/// 
/// HISTORY: New type in IFC 2x2
/// 
/// Enumeration 
/// 
/// BELL: An audible alarm. 
/// BREAKGLASSBUTTON: An alarm activation mechanism in which a protective glass has to be broken to enable a button to be pressed. 
/// LIGHT: A visual alarm. 
/// MANUALPULLBOX: An alarm activation mechanism in which activation is achieved by a pulling action. 
/// SIREN: An audible alarm. 
/// WHISTLE: An audible alarm.  
/// USERDEFINED: User-defined type. 
/// NOTDEFINED: Undefined type.
typedef enum {IfcAlarmType_BELL, IfcAlarmType_BREAKGLASSBUTTON, IfcAlarmType_LIGHT, IfcAlarmType_MANUALPULLBOX, IfcAlarmType_SIREN, IfcAlarmType_WHISTLE, IfcAlarmType_USERDEFINED, IfcAlarmType_NOTDEFINED} IfcAlarmTypeEnum;
const char* ToString(IfcAlarmTypeEnum v);
IfcAlarmTypeEnum FromString(const std::string& s);
}
namespace IfcAnalysisModelTypeEnum {
/// Definition from IAI: This type definition is used to distinguish
///   between different types of structural analysis models. The analysis models are
///   differentiated by their dimensionality. 
/// 
/// HISTORY: New type in Release IFC2x
///   Edition 2.
typedef enum {IfcAnalysisModelType_IN_PLANE_LOADING_2D, IfcAnalysisModelType_OUT_PLANE_LOADING_2D, IfcAnalysisModelType_LOADING_3D, IfcAnalysisModelType_USERDEFINED, IfcAnalysisModelType_NOTDEFINED} IfcAnalysisModelTypeEnum;
const char* ToString(IfcAnalysisModelTypeEnum v);
IfcAnalysisModelTypeEnum FromString(const std::string& s);
}
namespace IfcAnalysisTheoryTypeEnum {
/// Definition from IAI: This type definition is used to distinguish
///   between different types of structural analysis methods, i.e. first order
///   theory, second order theory (small deformations), third order theory (large
///   deformations) and the full nonlinear theory (geometric nonlinearity together with other nonlinearities, e.g. plasticity). 
/// 
/// HISTORY: New type in Release IFC2x
///   Edition 2.
typedef enum {IfcAnalysisTheoryType_FIRST_ORDER_THEORY, IfcAnalysisTheoryType_SECOND_ORDER_THEORY, IfcAnalysisTheoryType_THIRD_ORDER_THEORY, IfcAnalysisTheoryType_FULL_NONLINEAR_THEORY, IfcAnalysisTheoryType_USERDEFINED, IfcAnalysisTheoryType_NOTDEFINED} IfcAnalysisTheoryTypeEnum;
const char* ToString(IfcAnalysisTheoryTypeEnum v);
IfcAnalysisTheoryTypeEnum FromString(const std::string& s);
}
namespace IfcArithmeticOperatorEnum {
/// IfcArithmeticOperatorEnum specifies the form of arithmetical operation implied by the relationship. 
/// Enumeration 
/// 
/// ADD 
///   DIVIDE 
///   MULTIPLY 
///   SUBTRACT 
/// 
/// HISTORY: New enumeration in IFC2x2.
/// 
/// Use definitions 
/// There can be only one arithmetic operator for each applied value relationship. This is to enforce arithmetic consistency. Given this consistency, the cardinality of the IfcAppliedValueRelationship.Components attribute is a set of one to many applied values that are components of an applied value.
typedef enum {IfcArithmeticOperator_ADD, IfcArithmeticOperator_DIVIDE, IfcArithmeticOperator_MULTIPLY, IfcArithmeticOperator_SUBTRACT} IfcArithmeticOperatorEnum;
const char* ToString(IfcArithmeticOperatorEnum v);
IfcArithmeticOperatorEnum FromString(const std::string& s);
}
namespace IfcAssemblyPlaceEnum {
/// Definition from IAI: Enumeration defining where the
///   assembly is intended to take place, either in a factory or
///   on the building site.
/// 
/// HISTORY New enumeration in
///   Release IFC2x Edition 2.
/// 
/// Enumeration
/// 
/// SITE - this assembly is assembled at site
/// 
/// FACTORY - this assembly is assembled in a factory
typedef enum {IfcAssemblyPlace_SITE, IfcAssemblyPlace_FACTORY, IfcAssemblyPlace_NOTDEFINED} IfcAssemblyPlaceEnum;
const char* ToString(IfcAssemblyPlaceEnum v);
IfcAssemblyPlaceEnum FromString(const std::string& s);
}
namespace IfcBSplineCurveForm {
/// Definition from ISO/CD 10303-42:1992: This type is used to indicate that the B-spline curve represents a part of a curve of some specific form.
/// 
/// Enumeration
/// 
/// polyline form: A connected sequence of line segments represented by degree 1 B-spline basis functions.
/// circular arc: An arc of a circle, or a complete circle represented by a B-spline curve.
/// elliptic arc: An arc of an ellipse, or a complete ellipse, represented by a B-spline curve.
/// parabolic arc: An arc of finite length of a parabola represented by a B-spline curve.
/// hyperbolic arc: An arc of finite length of one branch of a hyperbola represented by a B-spline curve.
/// unspecified: A B-spline curve for which no particular form is specified.
/// 
/// NOTE  Corresponding ISO 10303 type: b_spline_curve_form. Please refer to ISO/IS 10303-42:1994, p. 15 for the final definition of the formal standard.
/// 
/// HISTORY  New type in Release IFC2x2.
typedef enum {IfcBSplineCurveForm_POLYLINE_FORM, IfcBSplineCurveForm_CIRCULAR_ARC, IfcBSplineCurveForm_ELLIPTIC_ARC, IfcBSplineCurveForm_PARABOLIC_ARC, IfcBSplineCurveForm_HYPERBOLIC_ARC, IfcBSplineCurveForm_UNSPECIFIED} IfcBSplineCurveForm;
const char* ToString(IfcBSplineCurveForm v);
IfcBSplineCurveForm FromString(const std::string& s);
}
namespace IfcBeamTypeEnum {
/// Definition from IAI: This enumeration defines the
/// different types of linear elements an IfcBeamType object
/// can fulfill:
/// 
/// BEAM: A standard beam usually used horizontally.
/// JOIST: A beam used to support a floor or ceiling.
/// HOLLOWCORE: A wide often prestressed beam with a
/// hollow-core profile that usually serves as a slab component.
/// LINTEL: A beam or horizontal piece of material over an
/// opening (e.g. door, window).
/// SPANDREL: A tall beam placed on the facade of a
/// building. One tall side is usually finished to provide the
/// exterior of the building. Can be used to support joists or slab
/// elements on its interior side.
/// 
/// NOTE  They are also referred to as "spandrel
/// panels", which are parts of a facade and sometimes have
/// supporting consoles for floor slabs
/// integrated.
/// 
/// T_BEAM: A beam that forms part of a slab construction
/// and acts together with the slab which its carries. Such beams are
/// often of T-shape (therefore the English name), but may have other
/// shapes as well, e.g. an L-Shape or an Inverted-T-Shape.
/// 
/// NOTE  In order to distinguish beams by shape,
/// the assigned IfcProfileDef subtypes provide the shape type
/// and, if using a subtype of
/// IfcParameterizedProfileDef, also the shape
/// parameterization.
/// 
/// USERDEFINED: User-defined linear beam element.
/// NOTDEFINED: Undefined linear beam element
/// 
/// HISTORY  New Enumeration
/// in Release IFC2x Edition 2.
/// IFC2x4 CHANGE  The enumerators
/// HOLLOWCORE and SPANDREL have been
/// added.
typedef enum {IfcBeamType_BEAM, IfcBeamType_JOIST, IfcBeamType_LINTEL, IfcBeamType_T_BEAM, IfcBeamType_USERDEFINED, IfcBeamType_NOTDEFINED} IfcBeamTypeEnum;
const char* ToString(IfcBeamTypeEnum v);
IfcBeamTypeEnum FromString(const std::string& s);
}
namespace IfcBenchmarkEnum {
/// IfcBenchmarkEnum is an enumeration used to identify the logical comparators that can be applied in conjunction with constraint values. 
/// 
/// HISTORY: New type in IFC Release 2.0
/// 
/// IFC2x4 CHANGE: Extended to include comparators for item-set and set-item comparisons: INCLUDES, NOTINCLUDES, INCLUDEDIN and NOTINCLUDEDIN, to test if an individual item is a member of a given aggregation, or if an aggregation has a given individual item as a member.
/// 
/// Enumeration 
/// 
/// Value 
///   Definition 
/// 
/// GREATERTHAN 
///   Identifies that a value must be greater than that set by the constraint. 
/// 
/// GREATERTHANOREQUALTO 
///   Identifies that a value must be either greater than or equal to that set by the constraint. 
/// 
/// LESSTHAN 
///   Identifies that a value must be less than that set by the constraint. 
/// 
/// LESSTHANOREQUALTO 
///   Identifies that a value must be either less than or equal to that set by the constraint. 
/// 
/// EQUALTO 
///   Identifies that a value must be equal to that set by the constraint. 
/// 
/// NOTEQUALTO 
///   Identifies that a value must be not equal to that set by the constraint. 
/// 
/// INCLUDES 
///   Identifies that an aggregation (set, list or table) must include the value (individual item) set by the constraint. 
/// 
/// NOTINCLUDES 
///   Identifies that an aggregation (set, list or table) must not include (i.e must exclude) the value (individual item) set by the constraint. 
/// 
/// INCLUDEDIN 
///   Identifies that a value (individual item) must be included in the aggregation (set, list or table) set by the constraint. 
/// 
/// NOTINCLUDEDIN 
///   Identifies that a value (individual item) must not be included (i.e. must be excluded) in the aggregation (set, list or table) set by the constraint.
typedef enum {IfcBenchmark_GREATERTHAN, IfcBenchmark_GREATERTHANOREQUALTO, IfcBenchmark_LESSTHAN, IfcBenchmark_LESSTHANOREQUALTO, IfcBenchmark_EQUALTO, IfcBenchmark_NOTEQUALTO} IfcBenchmarkEnum;
const char* ToString(IfcBenchmarkEnum v);
IfcBenchmarkEnum FromString(const std::string& s);
}
namespace IfcBoilerTypeEnum {
/// Enumeration defining the typical types of boilers.
///   The IfcBoilerTypeEnum contains the following:
/// 
/// WATER: Water boiler.
///   STEAM: Steam boiler.
///   USERDEFINED: User-defined Boiler type.
///   NOTDEFINED:  Undefined Boiler type.
/// 
/// HISTORY: New enumeration in IFC R2x.
typedef enum {IfcBoilerType_WATER, IfcBoilerType_STEAM, IfcBoilerType_USERDEFINED, IfcBoilerType_NOTDEFINED} IfcBoilerTypeEnum;
const char* ToString(IfcBoilerTypeEnum v);
IfcBoilerTypeEnum FromString(const std::string& s);
}
namespace IfcBooleanOperator {
/// Definition from ISO/CD 10303-42:1992: This type defines the three Boolean operators used in the definition of CSG solids.
/// 
/// UNION: The operation of constructing the regularized set theoretic union of the volumes defined by two solids.
/// INTERSECTION: The operation of constructing the regularised set theoretic intersection of the volumes defined by two solids.
/// DIFFERENCE: The operation of constructing the regularized set theoretic intersection of the volumes defined by two solids.
/// 
/// NOTE Corresponding STEP type: boolean_operator, please refer to ISO/IS 10303-42:1994, p.167 for the final definition of the formal standard.
/// 
/// HISTORY New Type in IFC Release 1.5.1.
typedef enum {IfcBooleanOperator_UNION, IfcBooleanOperator_INTERSECTION, IfcBooleanOperator_DIFFERENCE} IfcBooleanOperator;
const char* ToString(IfcBooleanOperator v);
IfcBooleanOperator FromString(const std::string& s);
}
namespace IfcBuildingElementProxyTypeEnum {
/// Definition from IAI: This enumeration defines the
///   available generic types for IfcBuildingElementProxyType.
/// 
/// HISTORY  New enumeration
///   in Release IFC2x Edition 3.
/// 
/// Enumeration
/// 
/// USERDEFINED
/// 
/// NOTDEFINED
typedef enum {IfcBuildingElementProxyType_USERDEFINED, IfcBuildingElementProxyType_NOTDEFINED} IfcBuildingElementProxyTypeEnum;
const char* ToString(IfcBuildingElementProxyTypeEnum v);
IfcBuildingElementProxyTypeEnum FromString(const std::string& s);
}
namespace IfcCableCarrierFittingTypeEnum {
/// The IfcCableCarrierFittingTypeEnum defines the range of different types of cable carrier fitting that can be specified. 
///   HISTORY: New type in IFC 2x2  
///   Enumeration 
/// 
/// BEND: A fitting that changes the route of the cable carrier. 
/// CROSS: A fitting at which two branches are taken from the main route of the cable carrier simultaneously. 
/// REDUCER: A fitting that changes the physical size of the main route of the cable carrier. 
/// TEE: A fitting at which a branch is taken from the main route of the cable carrier. 
/// USERDEFINED: User-defined type. 
/// NOTDEFINED: Undefined type.
typedef enum {IfcCableCarrierFittingType_BEND, IfcCableCarrierFittingType_CROSS, IfcCableCarrierFittingType_REDUCER, IfcCableCarrierFittingType_TEE, IfcCableCarrierFittingType_USERDEFINED, IfcCableCarrierFittingType_NOTDEFINED} IfcCableCarrierFittingTypeEnum;
const char* ToString(IfcCableCarrierFittingTypeEnum v);
IfcCableCarrierFittingTypeEnum FromString(const std::string& s);
}
namespace IfcCableCarrierSegmentTypeEnum {
/// The IfcCableCarrierSegmentTypeEnum defines the range of different types of cable carrier segment that can be specified. 
///   HISTORY: New type in IFC 2x2  
///   Enumeration 
/// 
/// CABLELADDERSEGMENT: An open carrier segment on which cables are carried on a ladder structure.
/// CABLETRAYSEGMENT: A (typically) open carrier segment onto which cables are laid.
/// CABLETRUNKINGSEGMENT: An enclosed carrier segment with one or more compartments into which cables are placed.
/// CONDUITSEGMENT: An enclosed tubular carrier segment through which cables are pulled.
/// USERDEFINED: User-defined type.  
/// NOTDEFINED: Undefined type.
typedef enum {IfcCableCarrierSegmentType_CABLELADDERSEGMENT, IfcCableCarrierSegmentType_CABLETRAYSEGMENT, IfcCableCarrierSegmentType_CABLETRUNKINGSEGMENT, IfcCableCarrierSegmentType_CONDUITSEGMENT, IfcCableCarrierSegmentType_USERDEFINED, IfcCableCarrierSegmentType_NOTDEFINED} IfcCableCarrierSegmentTypeEnum;
const char* ToString(IfcCableCarrierSegmentTypeEnum v);
IfcCableCarrierSegmentTypeEnum FromString(const std::string& s);
}
namespace IfcCableSegmentTypeEnum {
/// The IfcCableSegmentTypeEnum defines the range of different types of cable segment that can be specified. 
/// 
/// HISTORY: New type in IFC
///   2x2. Core and busbar segment added in IFC 2x4.  
///   Enumeration 
/// 
/// BUSBARSEGMENT: Electrical conductor that makes a common connection between several electrical circuits. Properties of a busbar are the same as those of a cable segment and are captured by the cable segment property set. 
/// CABLESEGMENT: Cable with a specific purpose to lead electric current within a circuit or any other electric construction. Includes all types of electric cables, mainly several core segments or conductor segments wrapped together. 
/// CONDUCTORSEGMENT: A single linear element within a cable or an exposed wire (such as for grounding) with the specific purpose to lead electric current, data, or a telecommunications signal.  
/// CORESEGMENT: A self contained element of a  cable that comprises one or more conductors and sheathing.The core of one lead is normally single wired or multiwired which are intertwined.  
/// USERDEFINED: User-defined type.  
/// NOTDEFINED: Undefined type.
typedef enum {IfcCableSegmentType_CABLESEGMENT, IfcCableSegmentType_CONDUCTORSEGMENT, IfcCableSegmentType_USERDEFINED, IfcCableSegmentType_NOTDEFINED} IfcCableSegmentTypeEnum;
const char* ToString(IfcCableSegmentTypeEnum v);
IfcCableSegmentTypeEnum FromString(const std::string& s);
}
namespace IfcChangeActionEnum {
/// IfcChangeActionEnum identifies the type of change that might have occurred to the object during the last session (for example, added, modified, deleted). This information is required in a partial model exchange scenario so that an application or model server will know how an object might have been affected by the previous application. Valid enumerations are:
/// 
/// NOCHANGE: Object has not been modified.
/// 
/// MODIFIED: A modification to the object has been made by the user and application defined by the LastModifyingUser and LastModifyingApplication respectively.
/// 
/// ADDED: The object has been created by the user and application defined by the OwningUser and OwningApplication respectively.
/// 
/// DELETED: The object has been deleted by the user and application defined by the LastModifyingUser and LastModifyingApplication respectively.
/// 
/// NOTDEFINED: The change action is not known or has not been defined.
/// 
/// Consider Application A will create an IFC dataset that it wants to publish to others for modification and have the ability to subsequently merge these changes back into the original model. Before publication, it may want to set the IfcChangeActionEnum to NOCHANGE to establish a baseline so that other application changes can be easily identified. Application B then receives this IFC dataset and adds a new object and sets IfcChangeActionEnum to ADDED with Application B defined as the OwningApplication. Application B then modifies an existing object and (re)defines the LastModifiedDate to the time of the modification, LastModifyingUser to the IfcPersonAndOrganization making the change, and sets the LastModifyingApplication to Application B. When Application A receives this modified dataset, it can determine which objects have been added and modified by Application B and either merge or reject these changes as necessary. Consequently, the intent is that an application only modifies the value of IfcChangeActionEnum when it does something to the object, with the further intent that a model server is responsible for clearing the IfcChangeActionEnum back to NOCHANGE when it is ready to be republished.
/// 
/// HISTORY: New enumeration in IFC R2.0. Modified in IFC2x4.
typedef enum {IfcChangeAction_NOCHANGE, IfcChangeAction_MODIFIED, IfcChangeAction_ADDED, IfcChangeAction_DELETED, IfcChangeAction_MODIFIEDADDED, IfcChangeAction_MODIFIEDDELETED} IfcChangeActionEnum;
const char* ToString(IfcChangeActionEnum v);
IfcChangeActionEnum FromString(const std::string& s);
}
namespace IfcChillerTypeEnum {
/// Enumeration defining the typical types of Chillers classified by their method of heat rejection. 
///   The IfcChillerTypeEnum contains the following:
/// 
/// AIRCOOLED: Air cooled chiller.
///   WATERCOOLED: Water cooled chiller.
///   HEATRECOVERY: Heat recovery chiller.
///   USERDEFINED:	User-defined chiller type.
///   NOTDEFINED: Undefined chiller type.
/// 
/// HISTORY: New enumeration in IFC R2x.
typedef enum {IfcChillerType_AIRCOOLED, IfcChillerType_WATERCOOLED, IfcChillerType_HEATRECOVERY, IfcChillerType_USERDEFINED, IfcChillerType_NOTDEFINED} IfcChillerTypeEnum;
const char* ToString(IfcChillerTypeEnum v);
IfcChillerTypeEnum FromString(const std::string& s);
}
namespace IfcCoilTypeEnum {
/// Enumeration defining the typical types of coils.
/// 
/// The IfcCoilTypeEnum contains the following:
/// 
/// DXCOOLINGCOIL: Cooling coil using a refrigerant to cool the air stream directly.
/// 
/// WATERCOOLINGCOIL: Cooling coil using chilled water. HYDRONICCOIL supercedes this enumerator.
/// 
/// STEAMHEATINGCOIL: Heating coil using steam as heating source.
/// 
/// WATERHEATINGCOIL: Heating coil using hot water as a heating source. HYDRONICCOIL supercedes this enumerator.
/// 
/// ELECTRICHEATINGCOIL: Heating coil using electricity as a heating source.
/// 
/// GASHEATINGCOIL: Heating coil using gas as a heating source.
/// 
/// HYDRONICCOIL: Cooling or Heating coil that uses a hydronic fluid as a cooling or heating source.
///   USERDEFINED: User-defined coil type.
/// 
/// NOTDEFINED:  Undefined coil type.
/// 
/// HISTORY: New enumeration in IFC R2x.
typedef enum {IfcCoilType_DXCOOLINGCOIL, IfcCoilType_WATERCOOLINGCOIL, IfcCoilType_STEAMHEATINGCOIL, IfcCoilType_WATERHEATINGCOIL, IfcCoilType_ELECTRICHEATINGCOIL, IfcCoilType_GASHEATINGCOIL, IfcCoilType_USERDEFINED, IfcCoilType_NOTDEFINED} IfcCoilTypeEnum;
const char* ToString(IfcCoilTypeEnum v);
IfcCoilTypeEnum FromString(const std::string& s);
}
namespace IfcColumnTypeEnum {
/// Definition from IAI: This enumeration defines the
/// different types of linear elements an IfcColumnType object
/// can fulfill:
/// 
/// COLUMN: A standard column element usually used
/// vertically.
/// USERDEFINED: User-defined linear element.
/// NOTDEFINED: Undefined linear element
/// 
/// NOTE: This enumeration has been mainly
/// introduced to allow further detailing of the type information in
/// future releases of IFC.
/// HISTORY New Enumeration
/// in Release IFC2x Edition 2.
typedef enum {IfcColumnType_COLUMN, IfcColumnType_USERDEFINED, IfcColumnType_NOTDEFINED} IfcColumnTypeEnum;
const char* ToString(IfcColumnTypeEnum v);
IfcColumnTypeEnum FromString(const std::string& s);
}
namespace IfcCompressorTypeEnum {
/// Types of compressors.
///   The IfcCompressorTypeEnum contains the following:
/// 
/// DYNAMIC: The pressure of refrigerant vapor is increased by a continuous transfer of angular momentum from a rotating member to the vapor followed by conversion of this momentum into static pressure.
///   RECIPROCATING: Positive-displacement compressor using a piston driven by a connecting rod from a crankshaft.
///   ROTARY: Positive-displacement compressor using a roller or rotor device.
///   SCROLL: Positive-displacement compressor using two inter-fitting, spiral-shaped scroll members.
///   TROCHOIDAL: Positive-displacement compressor using a rolling motion of one circle outside or inside the circumference of a basic circle and produce either epitrochoids or hypotrochoids.
///   SINGLESTAGE: Positive-displacement reciprocating compressor where vapor is compressed in a single stage.
///   BOOSTER: Positive-displacement reciprocating compressor where pressure is increased by a booster.
///   OPENTYPE: Positive-displacement reciprocating compressor where the shaft extends through a seal in the crankcase for an external drive.
///   HERMETIC: Positive-displacement reciprocating compressor where the motor and compressor are contained within the same housing, with the motor shaft integral with the compressor crankshaft and the motor in contact with refrigerant.
///   SEMIHERMETIC: Positive-displacement reciprocating compressor where the hermetic compressors use bolted construction amenable to field repair.
///   WELDEDSHELLHERMETIC: Positive-displacement reciprocating compressor where the motor compressor is mounted inside a steel shell, which, in turn is sealed by welding.
///   ROLLINGPISTON: Positive-displacement rotary compressor using a roller mounted on the eccentric of a shaft with a single vane in the nonrotating cylindrical housing.
///   ROTARYVANE: Positive-displacement rotary compressor using a roller mounted on the eccentric of a shaft with multiple vanes in the nontotating cylindrical housing.
///   SINGLESCREW: Positive-displacement rotary compressor using a single cylindrical main rotor that works with a pair of gate rotors.
///   TWINSCREW: Positive-displacement rotary compressor using two mating helically grooved rotors, male (lobes) and female (flutes) in a stationary housing with inlet and outlet gas ports.
///   USERDEFINED: User-defined compressor type.
///   NOTDEFINED:  Undefined compressor type.
/// 
/// HISTORY: New enumeration in IFC R2x.
typedef enum {IfcCompressorType_DYNAMIC, IfcCompressorType_RECIPROCATING, IfcCompressorType_ROTARY, IfcCompressorType_SCROLL, IfcCompressorType_TROCHOIDAL, IfcCompressorType_SINGLESTAGE, IfcCompressorType_BOOSTER, IfcCompressorType_OPENTYPE, IfcCompressorType_HERMETIC, IfcCompressorType_SEMIHERMETIC, IfcCompressorType_WELDEDSHELLHERMETIC, IfcCompressorType_ROLLINGPISTON, IfcCompressorType_ROTARYVANE, IfcCompressorType_SINGLESCREW, IfcCompressorType_TWINSCREW, IfcCompressorType_USERDEFINED, IfcCompressorType_NOTDEFINED} IfcCompressorTypeEnum;
const char* ToString(IfcCompressorTypeEnum v);
IfcCompressorTypeEnum FromString(const std::string& s);
}
namespace IfcCondenserTypeEnum {
/// Enumeration defining the typical types of condensers.  Air is used as the cooling medium for AIRCOOLED; water is used as the cooling medium for all other types.  The IfcCondenserTypeEnum contains the following:
/// 
/// AIRCOOLED: A condenser in which heat is transferred to an air-stream.
///   EVAPORATIVECOOLED: A condenser that is cooled evaporatively.
///   WATERCOOLED: Water-cooled condenser with unspecified operation.
///   WATERCOOLEDSHELLTUBE: Water-cooled condenser with cooling water circulated through one or more tubes contained within the shell.
///   WATERCOOLEDSHELLCOIL: Water-cooled condenser with cooling water circulated through one or more continuous or assembled coils contained within the shell.
///   WATERCOOLEDTUBEINTUBE: Water-cooled condenser consisting of one or more assemblies of two tubes, one within the other.
///   WATERCOOLEDBRAZEDPLATE: Water-cooled condenser condenser with plates brazed together to form an assembly of separate channels.
///   USERDEFINED: User-defined condenser type.
///   NOTDEFINED:  Undefined condenser type.
/// 
/// HISTORY: New enumeration in IFC 2x2.  WATERCOOLED added in IFC 2x4.
typedef enum {IfcCondenserType_WATERCOOLEDSHELLTUBE, IfcCondenserType_WATERCOOLEDSHELLCOIL, IfcCondenserType_WATERCOOLEDTUBEINTUBE, IfcCondenserType_WATERCOOLEDBRAZEDPLATE, IfcCondenserType_AIRCOOLED, IfcCondenserType_EVAPORATIVECOOLED, IfcCondenserType_USERDEFINED, IfcCondenserType_NOTDEFINED} IfcCondenserTypeEnum;
const char* ToString(IfcCondenserTypeEnum v);
IfcCondenserTypeEnum FromString(const std::string& s);
}
namespace IfcConnectionTypeEnum {
/// This enumeration defines the different ways how path based elements (such as IfcWallStandardCase) can connect, as shown in Figure 65. 
/// 
/// HISTORY New type in IFC Release 2.0 
/// 
/// L-Shape Connection 
/// 
/// RelatingConnectionType: AtStart 
///   RelatedConnectionType: AtStart 
/// 
/// L-Shape Connection 
/// 
/// RelatingConnectionType: AtEnd 
///   RelatedConnectionType: AtStart 
/// 
/// T-Shape Connection 
/// 
/// RelatingConnectionType: AtPath 
///   RelatedConnectionType: AtStart 
/// 
/// Figure 65 — Connection types</td
typedef enum {IfcConnectionType_ATPATH, IfcConnectionType_ATSTART, IfcConnectionType_ATEND, IfcConnectionType_NOTDEFINED} IfcConnectionTypeEnum;
const char* ToString(IfcConnectionTypeEnum v);
IfcConnectionTypeEnum FromString(const std::string& s);
}
namespace IfcConstraintEnum {
/// IfcConstraintEnum is an enumeration used to qualify a constraint. 
/// 
/// HISTORY: New type in IFC Release 2.0
/// 
/// Enumeration 
/// 
/// Value 
///   Definition 
/// 
/// HARD 
///   Qualifies a constraint such that it must be followed rigidly within or at the values set. 
/// 
/// SOFT 
///   Qualifies a constraint such that it should be followed within or at the values set. 
/// 
/// ADVISORY 
///   Qualifies a constraint such that it is advised that it is followed within or at the values set.
typedef enum {IfcConstraint_HARD, IfcConstraint_SOFT, IfcConstraint_ADVISORY, IfcConstraint_USERDEFINED, IfcConstraint_NOTDEFINED} IfcConstraintEnum;
const char* ToString(IfcConstraintEnum v);
IfcConstraintEnum FromString(const std::string& s);
}
namespace IfcControllerTypeEnum {
/// The IfcControllerTypeEnum defines the range of different types of controller that can be specified.
/// 
/// HISTORY: New type in IFC R2.0
///   Documentation extended in IFC 2x4. PROPORTIONALINTEGRAL and PROPORTIONALINTEGRALDERIVATIVE values deleted (property set enumeration now used).  MULTIPOSITION added.
/// 
/// Enumeration
/// 
/// FLOATING: Output increases or decreases at a constant or accelerating rate.
/// MULTIPOSITION: Output is discrete value, can be one of three or more values.
/// PROGRAMMABLE: Output is programmable such as Discrete Digital Control (DDC).
/// PROPORTIONAL: Output is proportional to the control error and optionally time integral and derivative.
/// TWOPOSITION: Output can be either on or off
/// USERDEFINED: User-defined type.
/// NOTDEFINED: Undefined type.
typedef enum {IfcControllerType_FLOATING, IfcControllerType_PROPORTIONAL, IfcControllerType_PROPORTIONALINTEGRAL, IfcControllerType_PROPORTIONALINTEGRALDERIVATIVE, IfcControllerType_TIMEDTWOPOSITION, IfcControllerType_TWOPOSITION, IfcControllerType_USERDEFINED, IfcControllerType_NOTDEFINED} IfcControllerTypeEnum;
const char* ToString(IfcControllerTypeEnum v);
IfcControllerTypeEnum FromString(const std::string& s);
}
namespace IfcCooledBeamTypeEnum {
/// There are two general types of cooled or chilled beams: passive and active.
/// 
/// An active Cooled Beam uses a fan or other auxilliary device to aid in air recirculation, while a passive
/// 
/// Cooled Beam relies solely on convection to cool the space.
/// 
/// Enumeration defining the typical types of cooled beams.
/// 
/// The IfcCooledBeamTypeEnum contains the following:
/// 
/// ACTIVE: An active or ventilated cooled beam provides cooling (and heating) but can also function as an air terminal in a ventilation system.
/// 
/// PASSIVE: A passive or static cooled beam provides cooling (and heating) to a room or zone.
/// 
/// USERDEFINED: User-defined cooled beam type.
/// 
/// NOTDEFINED:  Undefined cooled beam type.
/// 
/// HISTORY: New enumeration in IFC 2x2.
typedef enum {IfcCooledBeamType_ACTIVE, IfcCooledBeamType_PASSIVE, IfcCooledBeamType_USERDEFINED, IfcCooledBeamType_NOTDEFINED} IfcCooledBeamTypeEnum;
const char* ToString(IfcCooledBeamTypeEnum v);
IfcCooledBeamTypeEnum FromString(const std::string& s);
}
namespace IfcCoolingTowerTypeEnum {
/// Enumeration defining the typical types of cooling towers. 
///   The IfcCoolingTowerTypeEnum contains the following:
/// 
/// NATURALDRAFT: Air flow is produced naturally.
///   MECHANICALINDUCEDDRAFT: Air flow is produced by a mechanical device, typically one or more fans, located on 
/// 
/// the air outlet side of the cooling tower.
///   MECHANICALFORCEDDRAFT: Air flow is produced by a mechanical device, typically one or more fans, located on 
/// 
/// the inlet air side of the cooling tower.
///   USERDEFINED:  User-defined cooling tower type.
///   NOTDEFINED:  Undefined cooling tower type.
/// 
/// HISTORY: New enumeration in IFC R2x.
typedef enum {IfcCoolingTowerType_NATURALDRAFT, IfcCoolingTowerType_MECHANICALINDUCEDDRAFT, IfcCoolingTowerType_MECHANICALFORCEDDRAFT, IfcCoolingTowerType_USERDEFINED, IfcCoolingTowerType_NOTDEFINED} IfcCoolingTowerTypeEnum;
const char* ToString(IfcCoolingTowerTypeEnum v);
IfcCoolingTowerTypeEnum FromString(const std::string& s);
}
namespace IfcCostScheduleTypeEnum {
/// An IfcCostScheduleTypeEnum is a list of the available types of cost schedule from which that required may be selected. 
///   HISTORY: New type in IFC 2x2  
///   Enumeration 
/// 
/// BUDGET: An allocation of money for a particular purpose. 
/// COSTPLAN: An assessment of the amount of money needing to be expended for a defined purpose based on incomplete information about the goods and services required for a construction or installation.  
/// ESTIMATE: An assessment of the amount of money needing to be expended for a defined purpose based on actual information about the goods and services required for a construction or installation. 
/// TENDER: An offer to provide goods and services.  
/// PRICEDBILLOFQUANTITIES: A complete listing of all work items forming construction or installation works in which costs have been allocated to work items.  
/// UNPRICEDBILLOFQUANTITIES: A complete listing of all work items forming construction or installation works in which costs have not yet been allocated to work items. 
/// SCHEDULEOFRATES: A listing of each type of goods forming construction or installation works with the cost of purchase, construction/installation, overheads and profit assigned so that additional items of that type can be costed.  
/// USERDEFINED: User-defined type. 
/// NOTDEFINED: Undefined type.
typedef enum {IfcCostScheduleType_BUDGET, IfcCostScheduleType_COSTPLAN, IfcCostScheduleType_ESTIMATE, IfcCostScheduleType_TENDER, IfcCostScheduleType_PRICEDBILLOFQUANTITIES, IfcCostScheduleType_UNPRICEDBILLOFQUANTITIES, IfcCostScheduleType_SCHEDULEOFRATES, IfcCostScheduleType_USERDEFINED, IfcCostScheduleType_NOTDEFINED} IfcCostScheduleTypeEnum;
const char* ToString(IfcCostScheduleTypeEnum v);
IfcCostScheduleTypeEnum FromString(const std::string& s);
}
namespace IfcCoveringTypeEnum {
/// Definition from IAI: This enumeration defines the range
/// of different types of covering that can further specify an
/// IfcCovering or an IfcCoveringType.
/// HISTORY New enumeration
/// in IFC Release 1.0
/// IFC2x4 CHANGE The following
/// enumerators of the IfcCoveringTypeEnum have been
/// deprecated INSULATION, SLEEVING and
/// WRAPPING.
/// Enumeration
/// 
/// CEILING: the covering is used to
/// represent a ceiling
/// FLOORING: the covering is used to
/// represent a flooring
/// CLADDING: the covering is used to
/// represent a cladding
/// ROOFING: the covering is used to
/// represent a roof
/// 
/// INSULATION: the covering is used to
/// insulate an element for thermal or acoustic purposes.
/// IFC2x4 NOTE The use of this
/// enumerator is deprecated.
/// MEMBRANE: an impervious layer that
/// could be used for e.g. roof covering (below tiling - that may be
/// known as sarking etc.) or as a damp proof course membrane
/// IFC2x4 NOTE The use of this
/// enumerator is deprecated.
/// SLEEVING: the covering is used to
/// isolate a distribution element from a space in which it is
/// contained.
/// IFC2x4 NOTE The use of this
/// enumerator is deprecated.
/// WRAPPING: the covering is used for
/// wrapping particularly of distribution elements using tape.
/// IFC2x4 NOTE The use of this
/// enumerator is deprecated.
/// 
/// USERDEFINED: user defined type of
/// covering
/// NOTDEFINED: undefined type of
/// covering
typedef enum {IfcCoveringType_CEILING, IfcCoveringType_FLOORING, IfcCoveringType_CLADDING, IfcCoveringType_ROOFING, IfcCoveringType_INSULATION, IfcCoveringType_MEMBRANE, IfcCoveringType_SLEEVING, IfcCoveringType_WRAPPING, IfcCoveringType_USERDEFINED, IfcCoveringType_NOTDEFINED} IfcCoveringTypeEnum;
const char* ToString(IfcCoveringTypeEnum v);
IfcCoveringTypeEnum FromString(const std::string& s);
}
namespace IfcCurrencyEnum {

typedef enum {IfcCurrency_AED, IfcCurrency_AES, IfcCurrency_ATS, IfcCurrency_AUD, IfcCurrency_BBD, IfcCurrency_BEG, IfcCurrency_BGL, IfcCurrency_BHD, IfcCurrency_BMD, IfcCurrency_BND, IfcCurrency_BRL, IfcCurrency_BSD, IfcCurrency_BWP, IfcCurrency_BZD, IfcCurrency_CAD, IfcCurrency_CBD, IfcCurrency_CHF, IfcCurrency_CLP, IfcCurrency_CNY, IfcCurrency_CYS, IfcCurrency_CZK, IfcCurrency_DDP, IfcCurrency_DEM, IfcCurrency_DKK, IfcCurrency_EGL, IfcCurrency_EST, IfcCurrency_EUR, IfcCurrency_FAK, IfcCurrency_FIM, IfcCurrency_FJD, IfcCurrency_FKP, IfcCurrency_FRF, IfcCurrency_GBP, IfcCurrency_GIP, IfcCurrency_GMD, IfcCurrency_GRX, IfcCurrency_HKD, IfcCurrency_HUF, IfcCurrency_ICK, IfcCurrency_IDR, IfcCurrency_ILS, IfcCurrency_INR, IfcCurrency_IRP, IfcCurrency_ITL, IfcCurrency_JMD, IfcCurrency_JOD, IfcCurrency_JPY, IfcCurrency_KES, IfcCurrency_KRW, IfcCurrency_KWD, IfcCurrency_KYD, IfcCurrency_LKR, IfcCurrency_LUF, IfcCurrency_MTL, IfcCurrency_MUR, IfcCurrency_MXN, IfcCurrency_MYR, IfcCurrency_NLG, IfcCurrency_NZD, IfcCurrency_OMR, IfcCurrency_PGK, IfcCurrency_PHP, IfcCurrency_PKR, IfcCurrency_PLN, IfcCurrency_PTN, IfcCurrency_QAR, IfcCurrency_RUR, IfcCurrency_SAR, IfcCurrency_SCR, IfcCurrency_SEK, IfcCurrency_SGD, IfcCurrency_SKP, IfcCurrency_THB, IfcCurrency_TRL, IfcCurrency_TTD, IfcCurrency_TWD, IfcCurrency_USD, IfcCurrency_VEB, IfcCurrency_VND, IfcCurrency_XEU, IfcCurrency_ZAR, IfcCurrency_ZWD, IfcCurrency_NOK} IfcCurrencyEnum;
const char* ToString(IfcCurrencyEnum v);
IfcCurrencyEnum FromString(const std::string& s);
}
namespace IfcCurtainWallTypeEnum {
/// Definition from IAI: Enumeration defining
/// the valid types of curtain wall that can be predefined using the
/// enumeration values. 
/// HISTORY 
/// New Enumeration in Release IFC2x Edition 3
/// NOTE  Currently there
/// are no specific enumerators defined, the IfcCurtainWallTypeEnum
/// has
/// been added for future extensions.
typedef enum {IfcCurtainWallType_USERDEFINED, IfcCurtainWallType_NOTDEFINED} IfcCurtainWallTypeEnum;
const char* ToString(IfcCurtainWallTypeEnum v);
IfcCurtainWallTypeEnum FromString(const std::string& s);
}
namespace IfcDamperTypeEnum {
/// This enumeration defines the various types of damper:
/// 
/// BALANCINGDAMPER: Damper used for purposes of manually balancing pressure differences.  Commonly operated by mechanical adjustment.
/// BACKDRAFTDAMPER: Backdraft damper used to restrict the movement of air in one direction.  Commonly operated by mechanical spring.
/// BLASTDAMPER: Blast damper use to prevent protect occupants and equipment against overpressures resultant of an explosion.  Commonly operated by mechanical spring.
/// CONTROLDAMPER: Control damper used to modulate the flow of air by adjusting the position of the blades.  Commonly operated by an actuator of a building automation system.
/// FIREDAMPER: Fire damper used to prevent the spread of fire for a specified duration.  Commonly operated by fusable link that melts above a certain temperature.
/// FIRESMOKEDAMPER: Combination fire and smoke damper used to preven the spread of fire and smoke.  Commonly operated by a fusable link and a smoke detector
/// FUMEHOODEXHAUST: Fume hood exhaust damper.  Commonly operated by actuator.
/// GRAVITYDAMPER: Gravity damper closes from the force of gravity.  Commonly operated by gravitational weight.
/// GRAVITYRELIEFDAMPER: Gravity-relief damper used to allow air to move upon a buildup of enough pressure to overcome the gravitational force exerted upon the damper blades.  Commonly operated by gravitational weight.
/// RELIEFDAMPER: Relief damper used to allow air to move upon a buildup of a specified pressure differential.  Commonly operated by mechanical spring.
/// SMOKEDAMPER: Smoke damper used to prevent the spread of smoke.  Commonly operated by a smoke detector of a building automation system.
/// USERDEFINED: User-defined damper.
/// NOTDEFINED: Undefined damper.
/// 
/// HISTORY: New enumeration in IFC R2.0
typedef enum {IfcDamperType_CONTROLDAMPER, IfcDamperType_FIREDAMPER, IfcDamperType_SMOKEDAMPER, IfcDamperType_FIRESMOKEDAMPER, IfcDamperType_BACKDRAFTDAMPER, IfcDamperType_RELIEFDAMPER, IfcDamperType_BLASTDAMPER, IfcDamperType_GRAVITYDAMPER, IfcDamperType_GRAVITYRELIEFDAMPER, IfcDamperType_BALANCINGDAMPER, IfcDamperType_FUMEHOODEXHAUST, IfcDamperType_USERDEFINED, IfcDamperType_NOTDEFINED} IfcDamperTypeEnum;
const char* ToString(IfcDamperTypeEnum v);
IfcDamperTypeEnum FromString(const std::string& s);
}
namespace IfcDataOriginEnum {
/// IfcDataOriginEnum identifies the origin of time data:
/// 
/// MEASURED: The origin of the time data is a measurement device.
///   PREDICTED: The time data are a prediction.
///   SIMULATED: The origin of the time data is a simulation.
///   NOTDEFINED: The origin of the time data is undefined.
/// 
/// HISTORY: New enumeration in IFC 2x2.
typedef enum {IfcDataOrigin_MEASURED, IfcDataOrigin_PREDICTED, IfcDataOrigin_SIMULATED, IfcDataOrigin_USERDEFINED, IfcDataOrigin_NOTDEFINED} IfcDataOriginEnum;
const char* ToString(IfcDataOriginEnum v);
IfcDataOriginEnum FromString(const std::string& s);
}
namespace IfcDerivedUnitEnum {
/// IfcDerivedUnitEnum is an enumeration type for allowed types of derived units.
/// ENUMERATION 
/// 
/// ACCELERATIONUNIT 
///   ANGULARVELOCITYUNIT 
///   COMPOUNDPLANEANGLEUNIT 
///   DYNAMICVISCOSITYUNIT 
///   HEATFLUXDENSITYUNIT 
///   INTEGERCOUNTRATEUNIT 
///   ISOTHERMALMOISTURECAPACITYUNIT 
///   KINEMATICVISCOSITYUNIT 
///   LINEARFORCEUNIT 
///   LINEARMOMENTUNIT 
///   LINEARSTIFFNESSUNIT 
///   LINEARVELOCITYUNIT 
///   MASSDENSITYUNIT 
///   MASSFLOWRATEUNIT 
///   MODULUSOFELASTICITYUNIT 
///   MODULUSOFSUBGRADEREACTIONUNIT 
///   MOISTUREDIFFUSIVITYUNIT 
///   MOLECULARWEIGHTUNIT 
///   MOMENTORINERTIAUNIT 
///   PLANARFORCEUNIT 
///   ROTATIONALFREQUENCYUNIT 
///   ROTATIONALSTIFFNESSUNIT 
///   SHEARMODULUSUNIT 
///   SPECIFICHEATCAPACITYUNIT 
///   THERMALADMITTANCEUNIT 
///   THERMALCONDUCTANCEUNIT 
///   THERMALRESISTANCEUNIT 
///   THERMALTRANSMITTANCEUNIT 
///   TORQUEUNIT 
///   VAPORPERMEABILITYUNIT 
///   VOLUMETRICFLOWRATEUNIT 
///   CURVATUREUNIT 
///   HEATINGVALUEUNIT 
///   IONCONCENTRATIONUNIT 
///   LUMINOUSINTENSITYDISTRIBUTIONUNIT 
///   MASSPERLENGTHUNIT 
///   MODULUSOFLINEARSUBGRADEREACTIONUNIT 
///   MODULUSOFROTATIONALSUBGRADEREACTIONUNIT 
///   PHUNIT 
///   ROTATIONALMASSUNIT 
///   SECTIONAREAINTEGRALUNIT 
///   SECTIONMODULUSUNIT 
///   SOUNDPOWERUNIT 
///   SOUNDPRESSUREUNIT 
///   TEMPERATUREGRADIENTUNIT 
///   TEMPERATURERATEOFCHANGE 
///   THERMALEXPANSIONCOEFFICIENTUNIT 
///   WARPINGCONSTANTUNIT 
///   WARPINGMOMENTUNIT 
///   USERDEFINED: User defined derived unit. 
/// 
/// HISTORY: New type in IFC Release 2.0.
/// 
/// IFC 2x4 change: added TEMPERATURERATEOFCHANGE.
typedef enum {IfcDerivedUnit_ANGULARVELOCITYUNIT, IfcDerivedUnit_COMPOUNDPLANEANGLEUNIT, IfcDerivedUnit_DYNAMICVISCOSITYUNIT, IfcDerivedUnit_HEATFLUXDENSITYUNIT, IfcDerivedUnit_INTEGERCOUNTRATEUNIT, IfcDerivedUnit_ISOTHERMALMOISTURECAPACITYUNIT, IfcDerivedUnit_KINEMATICVISCOSITYUNIT, IfcDerivedUnit_LINEARVELOCITYUNIT, IfcDerivedUnit_MASSDENSITYUNIT, IfcDerivedUnit_MASSFLOWRATEUNIT, IfcDerivedUnit_MOISTUREDIFFUSIVITYUNIT, IfcDerivedUnit_MOLECULARWEIGHTUNIT, IfcDerivedUnit_SPECIFICHEATCAPACITYUNIT, IfcDerivedUnit_THERMALADMITTANCEUNIT, IfcDerivedUnit_THERMALCONDUCTANCEUNIT, IfcDerivedUnit_THERMALRESISTANCEUNIT, IfcDerivedUnit_THERMALTRANSMITTANCEUNIT, IfcDerivedUnit_VAPORPERMEABILITYUNIT, IfcDerivedUnit_VOLUMETRICFLOWRATEUNIT, IfcDerivedUnit_ROTATIONALFREQUENCYUNIT, IfcDerivedUnit_TORQUEUNIT, IfcDerivedUnit_MOMENTOFINERTIAUNIT, IfcDerivedUnit_LINEARMOMENTUNIT, IfcDerivedUnit_LINEARFORCEUNIT, IfcDerivedUnit_PLANARFORCEUNIT, IfcDerivedUnit_MODULUSOFELASTICITYUNIT, IfcDerivedUnit_SHEARMODULUSUNIT, IfcDerivedUnit_LINEARSTIFFNESSUNIT, IfcDerivedUnit_ROTATIONALSTIFFNESSUNIT, IfcDerivedUnit_MODULUSOFSUBGRADEREACTIONUNIT, IfcDerivedUnit_ACCELERATIONUNIT, IfcDerivedUnit_CURVATUREUNIT, IfcDerivedUnit_HEATINGVALUEUNIT, IfcDerivedUnit_IONCONCENTRATIONUNIT, IfcDerivedUnit_LUMINOUSINTENSITYDISTRIBUTIONUNIT, IfcDerivedUnit_MASSPERLENGTHUNIT, IfcDerivedUnit_MODULUSOFLINEARSUBGRADEREACTIONUNIT, IfcDerivedUnit_MODULUSOFROTATIONALSUBGRADEREACTIONUNIT, IfcDerivedUnit_PHUNIT, IfcDerivedUnit_ROTATIONALMASSUNIT, IfcDerivedUnit_SECTIONAREAINTEGRALUNIT, IfcDerivedUnit_SECTIONMODULUSUNIT, IfcDerivedUnit_SOUNDPOWERUNIT, IfcDerivedUnit_SOUNDPRESSUREUNIT, IfcDerivedUnit_TEMPERATUREGRADIENTUNIT, IfcDerivedUnit_THERMALEXPANSIONCOEFFICIENTUNIT, IfcDerivedUnit_WARPINGCONSTANTUNIT, IfcDerivedUnit_WARPINGMOMENTUNIT, IfcDerivedUnit_USERDEFINED} IfcDerivedUnitEnum;
const char* ToString(IfcDerivedUnitEnum v);
IfcDerivedUnitEnum FromString(const std::string& s);
}
namespace IfcDimensionExtentUsage {

typedef enum {IfcDimensionExtentUsage_ORIGIN, IfcDimensionExtentUsage_TARGET} IfcDimensionExtentUsage;
const char* ToString(IfcDimensionExtentUsage v);
IfcDimensionExtentUsage FromString(const std::string& s);
}
namespace IfcDirectionSenseEnum {
/// IfcDirectionSenseEnum is an enumeration denoting whether sense of direction is positive or negative along the given axis.
/// 
/// ENUMERATION
/// 
/// POSITIVE: Direction defined to be positive.
/// NEGATIVE: Direction defined to be negative.
/// 
/// HISTORY New Type in IFC2x.
typedef enum {IfcDirectionSense_POSITIVE, IfcDirectionSense_NEGATIVE} IfcDirectionSenseEnum;
const char* ToString(IfcDirectionSenseEnum v);
IfcDirectionSenseEnum FromString(const std::string& s);
}
namespace IfcDistributionChamberElementTypeEnum {
/// This enumeration identifies different types of distribution chambers.
/// 
/// Valid enumerations are:
/// 
/// FORMEDDUCT: Space formed in the ground for the passage of pipes, cables, ducts.
/// INSPECTIONCHAMBER: Chamber constructed on a drain, sewer or pipeline with a removable cover that permits visble inspection.
/// INSPECTIONPIT:  Recess or chamber formed to permit access for inspection of substructure and services.
/// MANHOLE: Chamber constructed on a drain, sewer or pipeline with a removable cover that permits the entry of a person.
/// METERCHAMBER: Chamber that houses a meter(s).
/// SUMP: Recessed or small chamber into which liquid is drained to facilitate its collection for removal.
/// TRENCH: Excavated chamber, the length of which typically exceeds the width.
/// VALVECHAMBER: Chamber that houses a valve(s).
/// USERDEFINED: User-defined chamber type.
/// NOTDEFINED: Undefined chamber type.
/// 
/// HISTORY: New enumeration in IFC R2x2
typedef enum {IfcDistributionChamberElementType_FORMEDDUCT, IfcDistributionChamberElementType_INSPECTIONCHAMBER, IfcDistributionChamberElementType_INSPECTIONPIT, IfcDistributionChamberElementType_MANHOLE, IfcDistributionChamberElementType_METERCHAMBER, IfcDistributionChamberElementType_SUMP, IfcDistributionChamberElementType_TRENCH, IfcDistributionChamberElementType_VALVECHAMBER, IfcDistributionChamberElementType_USERDEFINED, IfcDistributionChamberElementType_NOTDEFINED} IfcDistributionChamberElementTypeEnum;
const char* ToString(IfcDistributionChamberElementTypeEnum v);
IfcDistributionChamberElementTypeEnum FromString(const std::string& s);
}
namespace IfcDocumentConfidentialityEnum {
/// IfcDocumentConfidentialityEnum enables selection of the level of confidentiality of document information from a list of choices. 
/// 
/// HISTORY: New enumeration in IFC 2x
/// 
/// Enumeration 
/// 
/// PUBLIC: Document is publicly available. 
/// RESTRICTED: Document availability is restricted. 
/// CONFIDENTIAL: Document is confidential and its contents should not be revealed without permission. 
/// PERSONAL: Document is personal to the author. 
/// USERDEFINED 
/// NOTDEFINED
typedef enum {IfcDocumentConfidentiality_PUBLIC, IfcDocumentConfidentiality_RESTRICTED, IfcDocumentConfidentiality_CONFIDENTIAL, IfcDocumentConfidentiality_PERSONAL, IfcDocumentConfidentiality_USERDEFINED, IfcDocumentConfidentiality_NOTDEFINED} IfcDocumentConfidentialityEnum;
const char* ToString(IfcDocumentConfidentialityEnum v);
IfcDocumentConfidentialityEnum FromString(const std::string& s);
}
namespace IfcDocumentStatusEnum {
/// IfcDocumentStatusEnum enables selection of the status of document information from a list of choices.
/// 
/// HISTORY: New enumeration in IFC Release 2x.
typedef enum {IfcDocumentStatus_DRAFT, IfcDocumentStatus_FINALDRAFT, IfcDocumentStatus_FINAL, IfcDocumentStatus_REVISION, IfcDocumentStatus_NOTDEFINED} IfcDocumentStatusEnum;
const char* ToString(IfcDocumentStatusEnum v);
IfcDocumentStatusEnum FromString(const std::string& s);
}
namespace IfcDoorPanelOperationEnum {
/// This enumeration defines the basic ways how individual door panels operate as shown in Figure 164.
/// HISTORY New Enumeration in IFC Release 2.0.
/// IFC2x4 CHANGE Enumerator FIXEDPANELadded.
/// 
/// Swinging
/// 
/// DoubleActing
/// 
/// Sliding
/// 
/// Folding
/// 
/// Revolving
/// 
/// Rollingup
/// 
/// FixedPanel
/// 
/// NOTE Enumerator added in IFC2x4.
/// 
/// UserDefined
///  
/// 
/// NotDefined
///  
/// 
/// Figure 164 — Door operations
/// 
/// The opening direction of the door panels is given by the local
/// placement of the IfcDoor. The positive y-axis determines
/// the direction as shown in Figure 165.
/// 
/// Figure 165 — Door panel operations
/// 
/// NOTE  Figures (symbolic representation) depend on the national building code.  These figures are only shown as illustrations
typedef enum {IfcDoorPanelOperation_SWINGING, IfcDoorPanelOperation_DOUBLE_ACTING, IfcDoorPanelOperation_SLIDING, IfcDoorPanelOperation_FOLDING, IfcDoorPanelOperation_REVOLVING, IfcDoorPanelOperation_ROLLINGUP, IfcDoorPanelOperation_USERDEFINED, IfcDoorPanelOperation_NOTDEFINED} IfcDoorPanelOperationEnum;
const char* ToString(IfcDoorPanelOperationEnum v);
IfcDoorPanelOperationEnum FromString(const std::string& s);
}
namespace IfcDoorPanelPositionEnum {
/// Definition: This enumeration defines the basic ways to describe the location of a door panel within a door lining.
/// 
/// HISTORY New Enumeration in IFC Release 2.x
/// 
/// Figure 166 shows the designation of a door panel with PanelPosition = LEFT and a door panel with PanelPosition = RIGHT within a door style with OperationType = DOUBLE_DOOR_SINGLE_SWING. The position is given as shown in the XZ plane of the local placement, looking into the direction of the positive Y axis. 
/// 
/// Figure 166 — Door panel positions
typedef enum {IfcDoorPanelPosition_LEFT, IfcDoorPanelPosition_MIDDLE, IfcDoorPanelPosition_RIGHT, IfcDoorPanelPosition_NOTDEFINED} IfcDoorPanelPositionEnum;
const char* ToString(IfcDoorPanelPositionEnum v);
IfcDoorPanelPositionEnum FromString(const std::string& s);
}
namespace IfcDoorStyleConstructionEnum {
/// Definition from IAI: This enumeration defines the
///   basic types of construction of doors. The construction type
///   relates to the main material (or material combination) used
///   for making the door.
/// 
/// HISTORY New Enumeration in
///   IFC Release 2x .
typedef enum {IfcDoorStyleConstruction_ALUMINIUM, IfcDoorStyleConstruction_HIGH_GRADE_STEEL, IfcDoorStyleConstruction_STEEL, IfcDoorStyleConstruction_WOOD, IfcDoorStyleConstruction_ALUMINIUM_WOOD, IfcDoorStyleConstruction_ALUMINIUM_PLASTIC, IfcDoorStyleConstruction_PLASTIC, IfcDoorStyleConstruction_USERDEFINED, IfcDoorStyleConstruction_NOTDEFINED} IfcDoorStyleConstructionEnum;
const char* ToString(IfcDoorStyleConstructionEnum v);
IfcDoorStyleConstructionEnum FromString(const std::string& s);
}
namespace IfcDoorStyleOperationEnum {
/// This enumeration defines the basic ways to describe how doors operate as shown in Figure 167.
/// HISTORY  New Enumeration in Release IFC2x.
/// 
/// Enumerator
///   Description
///   Figure
/// 
/// SINGLE_SWING_LEFT
/// 
/// Door with one
/// panel that opens (swings) to the
/// left. The hinges are on the left side as viewed in the direction of the
/// positive y-axis.
///   Note: Direction of swing (whether
/// in or out)
/// is determined at the IfcDoor.
/// 
/// SINGLE_SWING_RIGHT
/// 
/// Door with one
/// panel that opens (swings) to the
/// right. The hinges are on the right side as viewed in the direction of
/// the positive y-axis.
///   Note: Direction of swing (whether
/// in or out)
/// is determined at the IfcDoor.
/// 
/// DOUBLE_DOOR_
/// SINGLE_SWING
/// 
/// Door with two
/// panels, one opens (swings) to the
/// left the other opens (swings) to the right.
///   Note: Direction of swing (whether
/// in or out)
/// is determined at the IfcDoor. 
/// 
/// DOUBLE_SWING_LEFT
/// 
/// Door with one
/// panel that swings in both
/// directions and to the left in the main trafic direction. Also called
/// double acting door.
///   Note: Direction of main swing
/// (whether in or
/// out) is determined at the IfcDoor. 
/// 
/// DOUBLE_SWING_RIGHT
/// 
/// Door with one
/// panel that swings in both
/// directions and to the right in the main trafic direction. Also called
/// double acting door.
///   Note: Direction of main swing
/// (whether in or
/// out) is determined at the IfcDoor.
/// 
/// DOUBLE_DOOR_
/// DOUBLE_SWING
/// 
/// Door with two
/// panels, one swings in both
/// directions and to the right in the main trafic direction the other
/// swings also in both directions and to the left in the main trafic
/// direction.
///   Note: Direction of main swing
/// (whether in or
/// out) is determined at the IfcDoor.
/// 
/// DOUBLE_DOOR_
/// SINGLE_SWING_
/// OPPOSITE_LEFT
/// 
/// Door with two
/// panels that both open to the left,
/// one panel swings in one direction and the other panel swings in the
/// opposite direction.
///   Note: Direction of main swing
/// (whether in or
/// out) is determined at the IfcDoor.
/// 
/// DOUBLE_DOOR_
/// SINGLE_SWING_
/// OPPOSITE_RIGHT
///   Door with two
/// panels that both open to the right,
/// one panel swings in one direction and the other panel swings in the
/// opposite direction.
///   Note: Direction of main swing
/// (whether in or
/// out) is determined at the IfcDoor.
/// 
/// SLIDING_TO_LEFT
/// 
/// Door with one
/// panel that is sliding to the left. 
/// 
/// SLIDING_TO_RIGHT
/// 
/// Door with one
/// panel that is sliding to the right. 
/// 
/// DOUBLE_DOOR_SLIDING
/// 
/// Door with two
/// panels, one is sliding to the left
/// the other is sliding to the right. 
/// 
/// FOLDING_TO_LEFT
/// 
/// Door with one
/// panel that is folding to the left. 
/// 
/// FOLDING_TO_RIGHT
///   Door with one
/// panel that is folding to the right. 
/// 
/// DOUBLE_DOOR_FOLDING
/// 
/// Door with two
/// panels, one is folding to the left
/// the other is folding to the right. 
/// 
/// REVOLVING
/// 
/// An entrance door
/// consisting of four leaves set in
/// a form of a cross and revolving around a central vertical axis (the
/// four panels are described by a single IfcDoor panel
/// property). 
/// 
/// ROLLINGUP
/// 
/// Door that opens
/// by rolling up.
///   Note: Whether it rolls up to the
/// inside or
/// outside is determined at the IfcDoor.
/// 
/// USERDEFINED
///   User defined
/// operation type
///    
/// 
/// NOTDEFINED
///   A door with a
/// not defined operation type is
/// considered as a door with a lining, but no panels. It is thereby always
/// open.
///    
/// 
/// Figure 167 — Door style operations
/// 
/// NOTE
/// 
/// Figures are shown in the ground view.
///   Figures (symbolic representation) depend on the national
/// building
/// code.
///   These figures are only shown as illustrations, the actual
/// representation in the ground view might differ. 
///   Open to the outside is declared as open into the direction
/// of the
/// positive y-axis, determined by the ObjectPlacement
/// at IfcDoor
///   The location of the panel relative to the wall thickness is
/// defined by the ObjectPlacement at IfcDoor,
/// and the IfcDoorLiningProperties.LiningOffset
/// parameter.
typedef enum {IfcDoorStyleOperation_SINGLE_SWING_LEFT, IfcDoorStyleOperation_SINGLE_SWING_RIGHT, IfcDoorStyleOperation_DOUBLE_DOOR_SINGLE_SWING, IfcDoorStyleOperation_DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_LEFT, IfcDoorStyleOperation_DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_RIGHT, IfcDoorStyleOperation_DOUBLE_SWING_LEFT, IfcDoorStyleOperation_DOUBLE_SWING_RIGHT, IfcDoorStyleOperation_DOUBLE_DOOR_DOUBLE_SWING, IfcDoorStyleOperation_SLIDING_TO_LEFT, IfcDoorStyleOperation_SLIDING_TO_RIGHT, IfcDoorStyleOperation_DOUBLE_DOOR_SLIDING, IfcDoorStyleOperation_FOLDING_TO_LEFT, IfcDoorStyleOperation_FOLDING_TO_RIGHT, IfcDoorStyleOperation_DOUBLE_DOOR_FOLDING, IfcDoorStyleOperation_REVOLVING, IfcDoorStyleOperation_ROLLINGUP, IfcDoorStyleOperation_USERDEFINED, IfcDoorStyleOperation_NOTDEFINED} IfcDoorStyleOperationEnum;
const char* ToString(IfcDoorStyleOperationEnum v);
IfcDoorStyleOperationEnum FromString(const std::string& s);
}
namespace IfcDuctFittingTypeEnum {
/// This enumeration is used to identify the primary purpose of a duct fitting. This is a very basic categorization mechanism
///   to generically identify the duct fitting type. Subcategories
///   of duct fittings are not enumerated. 
///   The IfcDuctFittingTypeEnum contains the following:
/// 
/// BEND:		A fitting with typically two ports used to change 
///   the direction of flow between connected elements.
///   CONNECTOR:   Connector fitting, typically used to join two
///   ports together within a flow distribution system 
///   (e.g., a coupling used to join two duct segments).
///   ENTRY:       Entry fitting, typically unconnected at one port
///   and connected to a flow distribution system at 
///   the other (e.g., an outside air duct system 
///   intake opening).
///   EXIT:        Exit fitting, typically unconnected at one port
///   and connected to a flow distribution system at 
///   the other (e.g., an exhaust air discharge 
///   opening).
///   JUNCTION:	A fitting with typically more than two ports used
///   to redistribute flow among the ports and/or to
///   change the direction of flow between connected
///   elements (e.g, tee, cross, wye, etc.).
///   OBSTRUCTION: A fitting with typically two ports used to 
///   obstruct or restrict flow between the connected
///   elements (e.g., screen, perforated plate, etc.).
///   TRANSITION:	A fitting with typically two ports having
///   different shapes or sizes. Can also be used to
///   change the direction of flow between connected
///   elements.
///   USERDEFINED: User-defined fitting.
///   NOTDEFINED:  Undefined fitting.
/// 
/// HISTORY: New enumeration in IFC 2x2
typedef enum {IfcDuctFittingType_BEND, IfcDuctFittingType_CONNECTOR, IfcDuctFittingType_ENTRY, IfcDuctFittingType_EXIT, IfcDuctFittingType_JUNCTION, IfcDuctFittingType_OBSTRUCTION, IfcDuctFittingType_TRANSITION, IfcDuctFittingType_USERDEFINED, IfcDuctFittingType_NOTDEFINED} IfcDuctFittingTypeEnum;
const char* ToString(IfcDuctFittingTypeEnum v);
IfcDuctFittingTypeEnum FromString(const std::string& s);
}
namespace IfcDuctSegmentTypeEnum {
/// This enumeration is used to identify the primary purpose of a
///   duct segment. This is a very basic categorization mechanism
///   to generically identify the duct segment type. Subcategories
///   of duct segments are not enumerated. 
///   The IfcDuctSegmentTypeEnum contains the following:
/// 
/// RIGIDSEGMENT: A rigid segment is continuous linear segment of duct
///   that cannot be deformed.
///   FLEXIBLESEGMENT:  A flexible segment is a continuous non-linear segment
///   of duct that can be deformed and change the direction 
///   of flow.
///   USERDEFINED: User-defined segment.
///   NOTDEFINED:  Undefined segment.
/// 
/// HISTORY: New enumeration in IFC 2x2
typedef enum {IfcDuctSegmentType_RIGIDSEGMENT, IfcDuctSegmentType_FLEXIBLESEGMENT, IfcDuctSegmentType_USERDEFINED, IfcDuctSegmentType_NOTDEFINED} IfcDuctSegmentTypeEnum;
const char* ToString(IfcDuctSegmentTypeEnum v);
IfcDuctSegmentTypeEnum FromString(const std::string& s);
}
namespace IfcDuctSilencerTypeEnum {
/// Enumeration defining the typical types of duct silencers. 
///   The IfcDuctSilencerTypeEnum contains the following:
/// 
/// FLATOVAL:  Flat-oval shaped duct silencer type.
///   RECTANGULAR:  Rectangular shaped duct silencer type.
///   ROUND:  Round duct silencer type.
///   USERDEFINED:  User-defined duct silencer type.
///   NOTDEFINED:  Undefined duct silencer type.
/// 
/// HISTORY: New enumeration in IFC 2x2.
typedef enum {IfcDuctSilencerType_FLATOVAL, IfcDuctSilencerType_RECTANGULAR, IfcDuctSilencerType_ROUND, IfcDuctSilencerType_USERDEFINED, IfcDuctSilencerType_NOTDEFINED} IfcDuctSilencerTypeEnum;
const char* ToString(IfcDuctSilencerTypeEnum v);
IfcDuctSilencerTypeEnum FromString(const std::string& s);
}
namespace IfcElectricApplianceTypeEnum {
/// The IfcElectricApplianceTypeEnum defines the range of different types of electrical appliance that can be specified. 
/// 
/// HISTORY: New type in IFC R2.0.
///   Renamed from IfcElectricalApplianceTypeEnum if IFC 2x2.IFC 2x2 Addendum 1:
///   Missing enumeration values added (ELECTRICHEATER, TUMBLEDRYER and
///   WATERHEATER)
///   IFC 2x4: ELECTRICHEATER changed to FREESTANDINGELECTRICHEATER and noted as being for occasional use. RADIANTHEATER removed as part of general 'heater consolidation'. WATERHEATER, DIRECTWATERHEATER and INDIRECTWATERHEATER rationalized to FREESTANDINGWATERHEATER. WATERCOOLER changed to FREESTANDINGWATERCOOLER.
///   COMPUTER, FACSIMILE (FAX), PRINTER, SCANNER, TELEPHONE, TV (TELEVISION) moved to IfcAudioVisualApplianceTypeEnum and IfcCommunicationsApplianceTypeEnum. KITCHENMACHINE added.
/// 
/// Enumeration 
/// 
/// DISHWASHER: An appliance that has the primary function of washing dishes. 
/// ELECTRICCOOKER: An electrical appliance that has the primary function of cooking food (including oven, hob, grill). 
/// FREESTANDINGELECTRICHEATER: An electrical appliance that is used occasionally to provide heat. A freestanding electric heater is a 'plugged' appliance whose load may be removed from an electric circuit. 
/// FREESTANDINGFAN: An electrical appliance that is used occasionally to provide ventilation. A freestanding fan is a 'plugged' appliance whose load may be removed from an electric circuit. 
/// FREESTANDINGWATERHEATER: A small, local electrical appliance for heating water. A freestanding water heater is a 'plugged' appliance whose load may be removed from an electric circuit. 
/// FREESTANDINGWATERCOOLER: A small, local electrical appliance for cooling water. A freestanding water cooler is a 'plugged' appliance whose load may be removed from an electric circuit. 
/// FREEZER: An electrical appliance that has the primary function of storing food at temperatures below the freezing point of water. 
/// FRIDGE_FREEZER: An electrical appliance that combines the functions of a freezer and a refrigerator through the provision of separate compartments. 
/// KITCHENMACHINE: A specialized appliance used in commercial kitchens such as a mixer. 
/// HANDDRYER: An electrical appliance that has the primary function of drying hands. 
/// MICROWAVE: An electrical appliance that has the primary function of cooking food using microwaves. 
/// PHOTOCOPIER: A machine that has the primary function of reproduction of printed matter. 
/// REFRIGERATOR: An electrical appliance that has the primary function of storing food at low temperature but above the freezing point of water. 
/// TUMBLEDRYER: An electrical appliance that has the primary function of drying clothes. 
/// VENDINGMACHINE: An appliance that stores and vends goods including food, drink and goods of various types. 
/// WASHINGMACHINE: An appliance that has the primary function of washing clothes. 	  
/// USERDEFINED: User-defined type. 
/// NOTDEFINED: Undefined type.
typedef enum {IfcElectricApplianceType_COMPUTER, IfcElectricApplianceType_DIRECTWATERHEATER, IfcElectricApplianceType_DISHWASHER, IfcElectricApplianceType_ELECTRICCOOKER, IfcElectricApplianceType_ELECTRICHEATER, IfcElectricApplianceType_FACSIMILE, IfcElectricApplianceType_FREESTANDINGFAN, IfcElectricApplianceType_FREEZER, IfcElectricApplianceType_FRIDGE_FREEZER, IfcElectricApplianceType_HANDDRYER, IfcElectricApplianceType_INDIRECTWATERHEATER, IfcElectricApplianceType_MICROWAVE, IfcElectricApplianceType_PHOTOCOPIER, IfcElectricApplianceType_PRINTER, IfcElectricApplianceType_REFRIGERATOR, IfcElectricApplianceType_RADIANTHEATER, IfcElectricApplianceType_SCANNER, IfcElectricApplianceType_TELEPHONE, IfcElectricApplianceType_TUMBLEDRYER, IfcElectricApplianceType_TV, IfcElectricApplianceType_VENDINGMACHINE, IfcElectricApplianceType_WASHINGMACHINE, IfcElectricApplianceType_WATERHEATER, IfcElectricApplianceType_WATERCOOLER, IfcElectricApplianceType_USERDEFINED, IfcElectricApplianceType_NOTDEFINED} IfcElectricApplianceTypeEnum;
const char* ToString(IfcElectricApplianceTypeEnum v);
IfcElectricApplianceTypeEnum FromString(const std::string& s);
}
namespace IfcElectricCurrentEnum {

typedef enum {IfcElectricCurrent_ALTERNATING, IfcElectricCurrent_DIRECT, IfcElectricCurrent_NOTDEFINED} IfcElectricCurrentEnum;
const char* ToString(IfcElectricCurrentEnum v);
IfcElectricCurrentEnum FromString(const std::string& s);
}
namespace IfcElectricDistributionPointFunctionEnum {

typedef enum {IfcElectricDistributionPointFunction_ALARMPANEL, IfcElectricDistributionPointFunction_CONSUMERUNIT, IfcElectricDistributionPointFunction_CONTROLPANEL, IfcElectricDistributionPointFunction_DISTRIBUTIONBOARD, IfcElectricDistributionPointFunction_GASDETECTORPANEL, IfcElectricDistributionPointFunction_INDICATORPANEL, IfcElectricDistributionPointFunction_MIMICPANEL, IfcElectricDistributionPointFunction_MOTORCONTROLCENTRE, IfcElectricDistributionPointFunction_SWITCHBOARD, IfcElectricDistributionPointFunction_USERDEFINED, IfcElectricDistributionPointFunction_NOTDEFINED} IfcElectricDistributionPointFunctionEnum;
const char* ToString(IfcElectricDistributionPointFunctionEnum v);
IfcElectricDistributionPointFunctionEnum FromString(const std::string& s);
}
namespace IfcElectricFlowStorageDeviceTypeEnum {
/// The IfcElectricFlowStorageDeviceTypeEnum defines the range of different types of electrical flow storage device available. 
///   HISTORY: New type in IFC 2x2  
///   Enumeration 
/// 
/// BATTERY: A device for storing energy in chemical form so that it can be released as electrical energy. 
/// CAPACITORBANK: A device that stores electrical energy when an external power supply is present using the electrical property of capacitance 
/// HARMONICFILTER: A device that constantly injects currents that precisely correspond to the harmonic components drawn by the load. 
/// UPS: A device that provides a time limited alternative source of power supply in the event of failure of the main supply.  
/// USERDEFINED: User-defined type.  
/// NOTDEFINED: Undefined type.
typedef enum {IfcElectricFlowStorageDeviceType_BATTERY, IfcElectricFlowStorageDeviceType_CAPACITORBANK, IfcElectricFlowStorageDeviceType_HARMONICFILTER, IfcElectricFlowStorageDeviceType_INDUCTORBANK, IfcElectricFlowStorageDeviceType_UPS, IfcElectricFlowStorageDeviceType_USERDEFINED, IfcElectricFlowStorageDeviceType_NOTDEFINED} IfcElectricFlowStorageDeviceTypeEnum;
const char* ToString(IfcElectricFlowStorageDeviceTypeEnum v);
IfcElectricFlowStorageDeviceTypeEnum FromString(const std::string& s);
}
namespace IfcElectricGeneratorTypeEnum {
/// The IfcElectricGeneratorTypeEnum defines the range of types of electric generators available.
///   HISTORY: New type in IFC 2x2.  Values added in IFC 2x4. 
/// 
/// Enumeration 
/// 
/// CHP: Combined heat and power supply, used not only as a source of electric energy but also as a heating source for the building. It may therefore be not only part of an electrical system but also of a heating system. 
/// ENGINEGENERATOR: Electrical generator with a fuel-driven engine, for example a diesel-driven emergency power supply. 
/// STANDALONE: Electrical generator which does not include its source of kinetic energy, that is, a motor, engine, or turbine is modeled by a separate object. 
/// USERDEFINED: User-defined type. 
/// NOTDEFINED: Undefined type.
typedef enum {IfcElectricGeneratorType_USERDEFINED, IfcElectricGeneratorType_NOTDEFINED} IfcElectricGeneratorTypeEnum;
const char* ToString(IfcElectricGeneratorTypeEnum v);
IfcElectricGeneratorTypeEnum FromString(const std::string& s);
}
namespace IfcElectricHeaterTypeEnum {

typedef enum {IfcElectricHeaterType_ELECTRICPOINTHEATER, IfcElectricHeaterType_ELECTRICCABLEHEATER, IfcElectricHeaterType_ELECTRICMATHEATER, IfcElectricHeaterType_USERDEFINED, IfcElectricHeaterType_NOTDEFINED} IfcElectricHeaterTypeEnum;
const char* ToString(IfcElectricHeaterTypeEnum v);
IfcElectricHeaterTypeEnum FromString(const std::string& s);
}
namespace IfcElectricMotorTypeEnum {
/// The IfcElectricMotorTypeEnum defines the range of different types of electric motor that can be specified. 
///   HISTORY: New type in IFC 2x2  
///   Enumeration 
/// 
/// DC: A motor using either generated or rectified D.C. power. 
/// INDUCTION: An alternating current motor in which the primary winding on one member (usually the stator) is connected to the power source and a secondary winding or a squirrel-cage secondary winding on the other member (usually the rotor) carries the induced current. There is no physical electrical connection to the secondary winding, its current is induced. 
/// POLYPHASE: A two or three-phase induction motor in which the windings, one for each phase, are evenly divided by the same number of electrical degrees.  
/// RELUCTANCESYNCHRONOUS: A synchronous motor with a special rotor design which directly lines the rotor up with the rotating magnetic field of the stator, allowing for no slip under load.  
/// SYNCHRONOUS: A motor that operates at a constant speed up to full load. The rotor speed is equal to the speed of the rotating magnetic field of the stator; there is no slip. 
/// USERDEFINED: User-defined type. 
/// NOTDEFINED: Undefined type.
typedef enum {IfcElectricMotorType_DC, IfcElectricMotorType_INDUCTION, IfcElectricMotorType_POLYPHASE, IfcElectricMotorType_RELUCTANCESYNCHRONOUS, IfcElectricMotorType_SYNCHRONOUS, IfcElectricMotorType_USERDEFINED, IfcElectricMotorType_NOTDEFINED} IfcElectricMotorTypeEnum;
const char* ToString(IfcElectricMotorTypeEnum v);
IfcElectricMotorTypeEnum FromString(const std::string& s);
}
namespace IfcElectricTimeControlTypeEnum {
/// The IfcElectricTimeControlTypeEnum defines the range of types of electrical time control available. 
///   HISTORY: New type in IFC 2x2  
///   Enumeration 
/// 
/// TIMECLOCK: A control that causes action to occur at set times. 
/// TIMEDELAY: A control that causes action to occur following a set duration. 
/// RELAY: Electromagnetically operated contactor for making or breaking a control circuit. 
/// USERDEFINED: User-defined type. 
/// NOTDEFINED: Undefined type.
typedef enum {IfcElectricTimeControlType_TIMECLOCK, IfcElectricTimeControlType_TIMEDELAY, IfcElectricTimeControlType_RELAY, IfcElectricTimeControlType_USERDEFINED, IfcElectricTimeControlType_NOTDEFINED} IfcElectricTimeControlTypeEnum;
const char* ToString(IfcElectricTimeControlTypeEnum v);
IfcElectricTimeControlTypeEnum FromString(const std::string& s);
}
namespace IfcElementAssemblyTypeEnum {
/// Definition from IAI: An enumeration defining the
///   basic configuration types for element assemblies.
/// 
/// HISTORY New enumeration type
///   in Release IFC2x Edition 2.
/// 
/// Enumeration
/// 
/// ACCESSORY_ASSEMBLY: Assembled accessories or components
///   ARCH: A curved structure
///   BEAM_GRID: Interconnected beams, located in one (typically horizontal) plane
///   BRACED_FRAME: A rigid frame with additional bracing members
///   GIRDER: A beam-like superstructure
///   REINFORCEMENT_UNIT: Assembled reinforcement elements
///   RIGID_FRAME: A structure built up of beams, columns, etc. with moment-resisting joints
///   SLAB_FIELD: Slabs, laid out in one plane
///   TRUSS: A structure built up of members with (quasi) pinned joints
///   USERDEFINED: User-defined element assembly
///   NOTDEFINED: Undefined element assembly
typedef enum {IfcElementAssemblyType_ACCESSORY_ASSEMBLY, IfcElementAssemblyType_ARCH, IfcElementAssemblyType_BEAM_GRID, IfcElementAssemblyType_BRACED_FRAME, IfcElementAssemblyType_GIRDER, IfcElementAssemblyType_REINFORCEMENT_UNIT, IfcElementAssemblyType_RIGID_FRAME, IfcElementAssemblyType_SLAB_FIELD, IfcElementAssemblyType_TRUSS, IfcElementAssemblyType_USERDEFINED, IfcElementAssemblyType_NOTDEFINED} IfcElementAssemblyTypeEnum;
const char* ToString(IfcElementAssemblyTypeEnum v);
IfcElementAssemblyTypeEnum FromString(const std::string& s);
}
namespace IfcElementCompositionEnum {
/// Definition from IAI: Enumeration that provides an
///   indication, whether the spatial structure element or proxy
///   represents a:
/// 
/// COMPLEX - a group or aggregation of similar elements
/// 
/// ELEMENT - a (undivided) element itself
/// 
/// PARTIAL - a subelement or part
/// 
/// HISTORY New enumeration in
///   IFC Release 2.x
typedef enum {IfcElementComposition_COMPLEX, IfcElementComposition_ELEMENT, IfcElementComposition_PARTIAL} IfcElementCompositionEnum;
const char* ToString(IfcElementCompositionEnum v);
IfcElementCompositionEnum FromString(const std::string& s);
}
namespace IfcEnergySequenceEnum {

typedef enum {IfcEnergySequence_PRIMARY, IfcEnergySequence_SECONDARY, IfcEnergySequence_TERTIARY, IfcEnergySequence_AUXILIARY, IfcEnergySequence_USERDEFINED, IfcEnergySequence_NOTDEFINED} IfcEnergySequenceEnum;
const char* ToString(IfcEnergySequenceEnum v);
IfcEnergySequenceEnum FromString(const std::string& s);
}
namespace IfcEnvironmentalImpactCategoryEnum {

typedef enum {IfcEnvironmentalImpactCategory_COMBINEDVALUE, IfcEnvironmentalImpactCategory_DISPOSAL, IfcEnvironmentalImpactCategory_EXTRACTION, IfcEnvironmentalImpactCategory_INSTALLATION, IfcEnvironmentalImpactCategory_MANUFACTURE, IfcEnvironmentalImpactCategory_TRANSPORTATION, IfcEnvironmentalImpactCategory_USERDEFINED, IfcEnvironmentalImpactCategory_NOTDEFINED} IfcEnvironmentalImpactCategoryEnum;
const char* ToString(IfcEnvironmentalImpactCategoryEnum v);
IfcEnvironmentalImpactCategoryEnum FromString(const std::string& s);
}
namespace IfcEvaporativeCoolerTypeEnum {
/// Enumeration defining the typical types of evaporative coolers. 
///   The IfcEvaporativeCoolerTypeEnum contains the following:
/// 
/// DIRECTEVAPORATIVERANDOMMEDIAAIRCOOLER: Direct evaporative random media air cooler: Cools the air stream by evaporating water dircectly into the air stream using coolers with evaporative pads, usually of aspen wood or plastic fiber/foam.
///   DIRECTEVAPORATIVERIGIDMEDIAAIRCOOLER: Direct evaporative rigid media air cooler: Cools the air stream by evaporating water dircectly into the air stream using coolers with sheets of rigid, corrugated material as the wetted surface.
///   DIRECTEVAPORATIVESLINGERSPACKAGEDAIRCOOLER: Direct evaporative slingers packaged air cooler: Cools the air stream by evaporating water dircectly into the air stream using coolers with a water slinger in an evaporative cooling section and a fan section.
///   DIRECTEVAPORATIVEPACKAGEDROTARYAIRCOOLER: Direct evaporative packaged rotary air cooler: Cools the air stream by evaporating water dircectly into the air stream using coolers that wet and wash the evaporative pad by rotating it through a water bath.
///   DIRECTEVAPORATIVEAIRWASHER: Direct evaporative air washer: Cools the air stream by evaporating water dircectly into the air stream using coolers with spray-type air washer consist of a chamber or casing containing spray nozzles, and tank for collecting spray water, and an eliminator section for removing entrained drops of water from the air.
///   INDIRECTEVAPORATIVEPACKAGEAIRCOOLER: Indirect evaporative package air cooler: Cools the air stream by evaporating water indirectly and without adding moisture into the air stream. On one side of the heat exchanger, the secondary air stream is cooled by evaporation, while on the other side of heat exchanger, the primary air stream (conditioned air to be supplied to the room) is sensibly cooled by the heat exchanger surfaces.
///   INDIRECTEVAPORATIVEWETCOIL: Indirect evaporative wet coil: Cools the air stream by evaporating water indirectly and without adding moisture into the air stream. Water is sprayed directly on the tubes of the heat exchanger where latent cooling takes place and the vaporization of the water on the outside of the heat exchanger tubes allows the simultaneous heat and mass transfer which removes heat from the supply air on the tube side.
///   INDIRECTEVAPORATIVECOOLINGTOWERORCOILCOOLER: Indirect evaporative cooling tower or coil cooler: Cools the air stream by evaporating water indirectly and without adding moisture into the air stream using a combination of a cooling tower or other evaporative water cooler with a water-to-air heat exchanger coil and water circulating pump.
///   INDIRECTDIRECTCOMBINATION: Indirect/Direct combination: Cools the air stream by evaporating water indirectly and without adding moisture into the air stream using a two-stage cooler with a first-stage indirect evaporative cooler and second-stage direct evaporative cooler.
///   USERDEFINED:  User-defined evaporative cooler type.
///   NOTDEFINED:  Undefined evaporative cooler type.
/// 
/// HISTORY: New enumeration in IFC 2x2.
typedef enum {IfcEvaporativeCoolerType_DIRECTEVAPORATIVERANDOMMEDIAAIRCOOLER, IfcEvaporativeCoolerType_DIRECTEVAPORATIVERIGIDMEDIAAIRCOOLER, IfcEvaporativeCoolerType_DIRECTEVAPORATIVESLINGERSPACKAGEDAIRCOOLER, IfcEvaporativeCoolerType_DIRECTEVAPORATIVEPACKAGEDROTARYAIRCOOLER, IfcEvaporativeCoolerType_DIRECTEVAPORATIVEAIRWASHER, IfcEvaporativeCoolerType_INDIRECTEVAPORATIVEPACKAGEAIRCOOLER, IfcEvaporativeCoolerType_INDIRECTEVAPORATIVEWETCOIL, IfcEvaporativeCoolerType_INDIRECTEVAPORATIVECOOLINGTOWERORCOILCOOLER, IfcEvaporativeCoolerType_INDIRECTDIRECTCOMBINATION, IfcEvaporativeCoolerType_USERDEFINED, IfcEvaporativeCoolerType_NOTDEFINED} IfcEvaporativeCoolerTypeEnum;
const char* ToString(IfcEvaporativeCoolerTypeEnum v);
IfcEvaporativeCoolerTypeEnum FromString(const std::string& s);
}
namespace IfcEvaporatorTypeEnum {
/// Enumeration defining the typical types of evaporators. 
///   The IfcEvaporatorTypeEnum contains the following:
/// 
/// DIRECTEXPANSION: Direct-expansion evaporator.
///   DIRECTEXPANSIONSHELLANDTUBE: Direct-expansion evaporator where a refrigerant evaporates inside a series of baffles that channel the fluid throughout the shell side.
///   DIRECTEXPANSIONTUBEINTUBE: Direct-expansion evaporator where a refrigerant evaporates inside one or more pairs of coaxial tubes.
///   DIRECTEXPANSIONBRAZEDPLATE: Direct-expansion evaporator where a refrigerant evaporates inside plates brazed or welded together to make up an assembly of separate channels.
///   FLOODEDSHELLANDTUBE: Evaporator in which refrigerant evaporates outside tubes.
///   SHELLANDCOIL: Evaporator in which refrigerant evaporates inside a simple coiled tube immersed in the fluid to be cooled.
///   USERDEFINED:  User-defined evaporator type.
///   NOTDEFINED:  Undefined evaporator type.
/// 
/// HISTORY: New enumeration in IFC 2x2.
typedef enum {IfcEvaporatorType_DIRECTEXPANSIONSHELLANDTUBE, IfcEvaporatorType_DIRECTEXPANSIONTUBEINTUBE, IfcEvaporatorType_DIRECTEXPANSIONBRAZEDPLATE, IfcEvaporatorType_FLOODEDSHELLANDTUBE, IfcEvaporatorType_SHELLANDCOIL, IfcEvaporatorType_USERDEFINED, IfcEvaporatorType_NOTDEFINED} IfcEvaporatorTypeEnum;
const char* ToString(IfcEvaporatorTypeEnum v);
IfcEvaporatorTypeEnum FromString(const std::string& s);
}
namespace IfcFanTypeEnum {
/// Enumeration defining the typical types of fans.
///   The IfcFanTypeEnum contains the following:
/// 
/// CENTRIFUGALFORWARDCURVED: Air flows through the impeller radially using blades that are forward curved.
///   CENTRIFUGALRADIAL: Air flows through the impeller radially using blades that are uncurved or slightl forward curved.
///   CENTRIFUGALBACKWARDINCLINEDCURVED: Air flows through the impeller radially using blades that are backward curved.
///   CENTRIFUGALAIRFOIL: Air flows through the impeller radially using blades are airfoil shaped.
///   TUBEAXIAL: Air flows through the impeller axially with reduced tip clearance and operating at higher tip speeds.
///   VANEAXIAL: Air flows through the impeller axially with guide vanes and reduced running blade tip clearance.
///   PROPELLORAXIAL: Air flows through the impeller axially and small hub-to-tip ratio impeller mounted in an orifice plate or inlet ring.
///   USERDEFINED:	User-defined fan type.
///   NOTDEFINED: Undefined fan type.
/// 
/// HISTORY: New enumeration in IFC 2x2.
typedef enum {IfcFanType_CENTRIFUGALFORWARDCURVED, IfcFanType_CENTRIFUGALRADIAL, IfcFanType_CENTRIFUGALBACKWARDINCLINEDCURVED, IfcFanType_CENTRIFUGALAIRFOIL, IfcFanType_TUBEAXIAL, IfcFanType_VANEAXIAL, IfcFanType_PROPELLORAXIAL, IfcFanType_USERDEFINED, IfcFanType_NOTDEFINED} IfcFanTypeEnum;
const char* ToString(IfcFanTypeEnum v);
IfcFanTypeEnum FromString(const std::string& s);
}
namespace IfcFilterTypeEnum {
/// This enumeration defines the various types of filter typically used
///   within building services distribution systems:
/// 
/// AIRPARTICLEFILTER: A filter used to remove particulates from air.
///   COMPRESSEDAIRFILTER: A filter used to remove particulates from compressed air.
///   ODORFILTER: A filter used to remove odors from air.
///   OILFILTER: A filter used to remove particulates from oil.
///   STRAINER: A filter used to remove particulates from a fluid.
///   WATERFILTER: A filter used to remove particulates from water.
///   USERDEFINED:	User-defined filter type.
///   NOTDEFINED:	Undefined filter type.
/// 
/// HISTORY: New enumeration in IFC R2x.  COMPRESSEDAIRFILTER added in IFC2x4.
typedef enum {IfcFilterType_AIRPARTICLEFILTER, IfcFilterType_ODORFILTER, IfcFilterType_OILFILTER, IfcFilterType_STRAINER, IfcFilterType_WATERFILTER, IfcFilterType_USERDEFINED, IfcFilterType_NOTDEFINED} IfcFilterTypeEnum;
const char* ToString(IfcFilterTypeEnum v);
IfcFilterTypeEnum FromString(const std::string& s);
}
namespace IfcFireSuppressionTerminalTypeEnum {
/// The IfcFireSuppressionTerminalTypeEnum defines the range of different types of fire suppression terminal that can be specified. 
/// 
/// HISTORY: New type in IFC 2x2
/// 
/// Enumeration
/// 
/// BREECHINGINLET: Symmetrical pipe fitting that unites two or more inlets into a single pipe (BS6100 330 114 adapted). A breeching inlet may be used on either a wet or dry riser. Used by fire services personnel for fast connection of fire appliance hose reels. May also be used for foam. 
/// FIREHYDRANT: Device, fitted to a pipe, through which a temporary supply of water may be provided (BS6100 330 6107).  May also be termed a stand pipe. 
/// HOSEREEL: A supporting framework on which a hose may be wound (BS6100 155 8201). 
/// SPRINKLER: Device for sprinkling water from a pipe under pressure over an area (BS6100 100 3432). 
/// SPRINKLERDEFLECTOR: Device attached to a sprinkler to deflect the water flow into a spread pattern to cover the required area. 
/// USERDEFINED: User-defined type. 
/// NOTDEFINED: Underined type.
typedef enum {IfcFireSuppressionTerminalType_BREECHINGINLET, IfcFireSuppressionTerminalType_FIREHYDRANT, IfcFireSuppressionTerminalType_HOSEREEL, IfcFireSuppressionTerminalType_SPRINKLER, IfcFireSuppressionTerminalType_SPRINKLERDEFLECTOR, IfcFireSuppressionTerminalType_USERDEFINED, IfcFireSuppressionTerminalType_NOTDEFINED} IfcFireSuppressionTerminalTypeEnum;
const char* ToString(IfcFireSuppressionTerminalTypeEnum v);
IfcFireSuppressionTerminalTypeEnum FromString(const std::string& s);
}
namespace IfcFlowDirectionEnum {
/// This enumeration defines the flow direction at a port as either a SOURCE, SINK, or SOURCEANDSINK.  For solids, liquids, or gas, the direction is the physical flow direction.  For electric power (circuits containing hot, neutral, ground), the direction is from the origination of power (from a distribution board to protective devices to switches to fixtures).  For communication signals, the direction originates from where the signal is shaped, such as a sensor.  For communicaton networks, the direction originates from the up-level network host, such as a router (having SOURCE ports) hosting multiple computers (having SINK ports).
/// 
/// SOURCE:        A flow source, where a substance flows out of the connection.
///   SINK:          A flow sink, where a substance flows into the connection.
///   SOURCEANDSINK: Both a source and sink, where a substance flows both into and out of the connection simultaneously.
///   NOTDEFINED:    Undefined flow direction.
/// 
/// HISTORY: New enumeration in IFC R2.0
typedef enum {IfcFlowDirection_SOURCE, IfcFlowDirection_SINK, IfcFlowDirection_SOURCEANDSINK, IfcFlowDirection_NOTDEFINED} IfcFlowDirectionEnum;
const char* ToString(IfcFlowDirectionEnum v);
IfcFlowDirectionEnum FromString(const std::string& s);
}
namespace IfcFlowInstrumentTypeEnum {
/// The IfcFlowInstrumentTypeEnum defines the range of different types of flow instrument that can be specified. 
/// 
/// HISTORY: New type in IFC
///   2x2  
///   Enumeration 
/// 
/// PRESSUREGAUGE: A device that reads and displays a pressure value at a point or the pressure difference between two points. 
/// THERMOMETER: A device that reads and displays a temperature value at a point. 
/// AMMETER: A device that reads and displays the current flow in a circuit. 
/// FREQUENCYMETER: A device that reads and displays the electrical frequency of an alternating current circuit. 
/// PHASEANGLEMETER: A device that reads and displays the phase angle of a phase in a polyphase electrical circuit. 
/// POWERFACTORMETER: A device that reads and displays the power factor of an electrical circuit. 
/// VOLTMETER_PEAK: A device that reads and displays the peak voltage in an electrical circuit. 
/// VOLTMETER_RMS: A device that reads and displays the RMS (mean) voltage in an electrical circuit. 
/// USERDEFINED: User-defined type. 
/// NOTDEFINED: Undefined type.
typedef enum {IfcFlowInstrumentType_PRESSUREGAUGE, IfcFlowInstrumentType_THERMOMETER, IfcFlowInstrumentType_AMMETER, IfcFlowInstrumentType_FREQUENCYMETER, IfcFlowInstrumentType_POWERFACTORMETER, IfcFlowInstrumentType_PHASEANGLEMETER, IfcFlowInstrumentType_VOLTMETER_PEAK, IfcFlowInstrumentType_VOLTMETER_RMS, IfcFlowInstrumentType_USERDEFINED, IfcFlowInstrumentType_NOTDEFINED} IfcFlowInstrumentTypeEnum;
const char* ToString(IfcFlowInstrumentTypeEnum v);
IfcFlowInstrumentTypeEnum FromString(const std::string& s);
}
namespace IfcFlowMeterTypeEnum {
/// This enumeration defines various types of flow meter:
/// 
/// ENERGYMETER:   An electric meter or energy meter is a device that measures the amount of electrical energy supplied to or produced by a residence, business or machine.
/// 
/// GASMETER:   A device that measures the quantity of a gas or fuel.
/// 
/// OILMETER:   A device that measures the quantity of oil.
/// 
/// WATERMETER:   A device that measures the quantity of water.
/// 
/// USERDEFINED:   User-defined meter type
/// 
/// NOTDEFINED:    Undefined meter type
/// 
/// HISTORY: New enumeration in IFC 2x2
typedef enum {IfcFlowMeterType_ELECTRICMETER, IfcFlowMeterType_ENERGYMETER, IfcFlowMeterType_FLOWMETER, IfcFlowMeterType_GASMETER, IfcFlowMeterType_OILMETER, IfcFlowMeterType_WATERMETER, IfcFlowMeterType_USERDEFINED, IfcFlowMeterType_NOTDEFINED} IfcFlowMeterTypeEnum;
const char* ToString(IfcFlowMeterTypeEnum v);
IfcFlowMeterTypeEnum FromString(const std::string& s);
}
namespace IfcFootingTypeEnum {
/// Definition from IAI: Enumeration defining the generic footing type.
/// 
/// HISTORY New type in IFC Release 2x2
/// IFC 2x4 change:  Item CAISSON_FOUNDATION added
/// 
/// ENUMERATION 
/// 
/// CAISSON_FOUNDATION A foundation construction type used in underwater construction.
///   FOOTING_BEAM Footing elements that are in bending and are supported clear of the ground. They will normally span between piers, piles or pile caps. They are distinguished from beams in the building superstructure since they will normally require a lower grade of finish. They are distinguished from STRIP_FOOTING since they are clear of the ground surface and hence require support to the lower face while the concrete is curing.
///   PAD_FOOTING An element that transfers the load of a single column (possibly two) to the ground.
///   PILE_CAP An element that transfers the load from a column or group of columns to a pier or pile or group of piers or piles.
///   STRIP_FOOTING A linear element that transfers loads into the ground from either a continuous element, such as a wall, or from a series of elements, such as columns.
///   USERDEFINED Special types of footings which meet specific local requirements.
///   NOTDEFINED The type of footing is not defined.
typedef enum {IfcFootingType_FOOTING_BEAM, IfcFootingType_PAD_FOOTING, IfcFootingType_PILE_CAP, IfcFootingType_STRIP_FOOTING, IfcFootingType_USERDEFINED, IfcFootingType_NOTDEFINED} IfcFootingTypeEnum;
const char* ToString(IfcFootingTypeEnum v);
IfcFootingTypeEnum FromString(const std::string& s);
}
namespace IfcGasTerminalTypeEnum {

typedef enum {IfcGasTerminalType_GASAPPLIANCE, IfcGasTerminalType_GASBOOSTER, IfcGasTerminalType_GASBURNER, IfcGasTerminalType_USERDEFINED, IfcGasTerminalType_NOTDEFINED} IfcGasTerminalTypeEnum;
const char* ToString(IfcGasTerminalTypeEnum v);
IfcGasTerminalTypeEnum FromString(const std::string& s);
}
namespace IfcGeometricProjectionEnum {
/// IfcGeometricProjectionEnum defines the various representation types that can be semantically distinguished. Often different levels of detail of the shape representation are controlled by the representation type.
/// 
/// GRAPH_VIEW:
/// Geometric display representation that shows an abstract, often 1D
/// element representation, e.g. representing a wall by its axis line.
///   SKETCH_VIEW:
/// Geometric display representation that shows an abstract, often 2D
/// element representation, e.g. representing a wall by its two foot print
/// edges, surpressing any inner layer representation.
///   MODEL_VIEW:
/// Geometric display representation that shows a full 3D element
/// representation, e.g. representing a wall by its volumetric body.
///   PLAN_VIEW:
/// Geometric display representation that shows a full 2D element
/// representation, the level of detail often depends on the target scale,
/// e.g. representing a wall by its two foot print edges and the edges of
/// all inner layers. The projection is shown in ground view as seen from
/// above.
///   REFLECTED_PLAN_VIEW:
/// Geometric display representation that shows a full 2D element
/// representation, the level of detail often depends on the target scale,
/// e.g. representing a wall by its two foot print edges and the edges of
/// all inner layers. The projection is shown in ground view as seen from
/// below.
///   SECTION_VIEW:
/// Geometric display representation that shows a full 2D element
/// representation, the level of detail often depends on the target scale,
/// e.g. representing a wall by its two inner/outer edges and the edges of
/// all inner layers, if the element is cut by the section line.
///   ELEVATION_VIEW:
/// Geometric display representation that shows a full 2D element
/// representation, the level of detail often depends on the target scale,
/// e.g. representing a wall by its bounding edges if the element is within
/// an elevation view.
///   USERDEFINED:
/// A user defined specification is given by the value of the UserDefinedTargetView
/// attribute.
///   NOTDEFINED:
/// No specification given.
/// 
/// HISTORY: New Type in Release IFC2x2.
typedef enum {IfcGeometricProjection_GRAPH_VIEW, IfcGeometricProjection_SKETCH_VIEW, IfcGeometricProjection_MODEL_VIEW, IfcGeometricProjection_PLAN_VIEW, IfcGeometricProjection_REFLECTED_PLAN_VIEW, IfcGeometricProjection_SECTION_VIEW, IfcGeometricProjection_ELEVATION_VIEW, IfcGeometricProjection_USERDEFINED, IfcGeometricProjection_NOTDEFINED} IfcGeometricProjectionEnum;
const char* ToString(IfcGeometricProjectionEnum v);
IfcGeometricProjectionEnum FromString(const std::string& s);
}
namespace IfcGlobalOrLocalEnum {
/// This enumeration type defines if the local object coordinate system or the global world coordinate system for the project is used to describe the measure values of entities which have a reference to this type.
/// 
/// NOTE  The world coordinate system is given by the IfcGeometricRepresentationContext.WorldCoordinateSystem
/// and is unique within the project. The local (or object) coordinate system is given by IfcProduct.ObjectPlacement and is used by all IfcRepresentation's within the IfcProduct.Representation.
/// 
/// HISTORY: New type in IFC2x2.
typedef enum {IfcGlobalOrLocal_GLOBAL_COORDS, IfcGlobalOrLocal_LOCAL_COORDS} IfcGlobalOrLocalEnum;
const char* ToString(IfcGlobalOrLocalEnum v);
IfcGlobalOrLocalEnum FromString(const std::string& s);
}
namespace IfcHeatExchangerTypeEnum {
/// Enumeration defining the typical types of heat exchangers. 
///   The IfcHeatExchangerTypeEnum contains the following:
/// 
/// PLATE: Plate heat exchanger.
///   SHELLANDTUBE: Shell and Tube heat exchanger.
///   USERDEFINED:  User-defined heat exchanger type.
///   NOTDEFINED:  Undefined heat exchanger type.
/// 
/// HISTORY: New enumeration in IFC R2x.
typedef enum {IfcHeatExchangerType_PLATE, IfcHeatExchangerType_SHELLANDTUBE, IfcHeatExchangerType_USERDEFINED, IfcHeatExchangerType_NOTDEFINED} IfcHeatExchangerTypeEnum;
const char* ToString(IfcHeatExchangerTypeEnum v);
IfcHeatExchangerTypeEnum FromString(const std::string& s);
}
namespace IfcHumidifierTypeEnum {
/// Enumeration defining the typical types of humidifiers. 
///   The IfcHumidifierTypeEnum contains the following:
/// 
/// STEAMINJECTION: Water vapor is added into the airstream through direction steam injection.
///   ADIABATICAIRWASHER: Water vapor is added into the airstream through adiabatic evaporation using an air washing element.
///   ADIABATICPAN:  Water vapor is added into the airstream through adiabatic evaporation using a pan.
///   ADIABATICWETTEDELEMENT: Water vapor is added into the airstream through adiabatic evaporation using a wetted element.
///   ADIABATICATOMIZING: Water vapor is added into the airstream through adiabatic evaporation using an atomizing element.
///   ADIABATICULTRASONIC: Water vapor is added into the airstream through adiabatic evaporation using an ultrasonic element.
///   ADIABATICRIGIDMEDIA: Water vapor is added into the airstream through adiabatic evaporation using a rigid media.
///   ADIABATICCOMPRESSEDAIRNOZZLE: Water vapor is added into the airstream through adiabatic evaporation using a compressed air nozzle.
///   ASSISTEDELECTRIC: Water vapor is added into the airstream through water heated evaporation using an electric heater.
///   ASSISTEDNATURALGAS: Water vapor is added into the airstream through water heated evaporation using a natural gas heater.
///   ASSISTEDPROPANE: Water vapor is added into the airstream through water heated evaporation using a propane heater.
///   ASSISTEDBUTANE: Water vapor is added into the airstream through water heated evaporation using a butane heater.
///   ASSISTEDSTEAM: Water vapor is added into the airstream through water heated evaporation using a steam heater.
///   USERDEFINED:  User-defined humidifier type.
///   NOTDEFINED:  Undefined humidifier type.
/// 
/// HISTORY: New enumeration in IFC 2x2.
typedef enum {IfcHumidifierType_STEAMINJECTION, IfcHumidifierType_ADIABATICAIRWASHER, IfcHumidifierType_ADIABATICPAN, IfcHumidifierType_ADIABATICWETTEDELEMENT, IfcHumidifierType_ADIABATICATOMIZING, IfcHumidifierType_ADIABATICULTRASONIC, IfcHumidifierType_ADIABATICRIGIDMEDIA, IfcHumidifierType_ADIABATICCOMPRESSEDAIRNOZZLE, IfcHumidifierType_ASSISTEDELECTRIC, IfcHumidifierType_ASSISTEDNATURALGAS, IfcHumidifierType_ASSISTEDPROPANE, IfcHumidifierType_ASSISTEDBUTANE, IfcHumidifierType_ASSISTEDSTEAM, IfcHumidifierType_USERDEFINED, IfcHumidifierType_NOTDEFINED} IfcHumidifierTypeEnum;
const char* ToString(IfcHumidifierTypeEnum v);
IfcHumidifierTypeEnum FromString(const std::string& s);
}
namespace IfcInternalOrExternalEnum {
/// Definition from IAI: This enumeration defines the
/// different types of space boundaries in terms of either being
/// inside the building or outside the building.
/// Enumeration:
/// 
/// INTERNAL
/// 
/// IfcSpaceBoundary
/// The space boundary faces a physical
/// or virtual element where there is an internal space on the other
/// side.
/// 
/// EXTERNAL
/// 
/// IfcSpaceBoundary
/// The space boundary faces a physical
/// or virtual element where there is an external space on the other
/// side (i.e. air). Or it is the space boundary of that external
/// space against the building.
/// 
/// EXTERNAL_EARTH
/// 
/// IfcSpaceBoundary
/// The space boundary faces a physical
/// or virtual element where there is earth (or terrain) on the other
/// side. Or it is the space boundary of that earth (or terrain
/// object) external space against the building.
/// 
/// EXTERNAL_WATER
/// 
/// IfcSpaceBoundary
/// The space boundary faces a physical
/// or virtual element where there is water (water component of
/// terrain) on the other side. Or it is the space boundary of that
/// object representing water external space against the
/// building.
/// 
/// EXTERNAL_FIRE
/// 
/// IfcSpaceBoundary
/// The space boundary faces a physical
/// or virtual element where there is another building on the other
/// side. Or it is the space boundary of that other neighbor building
/// against the building in question.
/// 
/// NOTDEFINED
/// 
/// No information available.
/// 
/// HISTORY: New enumeration
/// in IFC Release 2.0
/// IFC2x4 CHANGE: Enumeration no longer
/// applicable to IfcSpace. The following enumerators are
/// added: EXTERNAL_EARTH, EXTERNAL_WATER,
/// EXTERNAL_FIRE.
typedef enum {IfcInternalOrExternal_INTERNAL, IfcInternalOrExternal_EXTERNAL, IfcInternalOrExternal_NOTDEFINED} IfcInternalOrExternalEnum;
const char* ToString(IfcInternalOrExternalEnum v);
IfcInternalOrExternalEnum FromString(const std::string& s);
}
namespace IfcInventoryTypeEnum {
/// IfcInventoryTypeEnum defines the types of inventory that can be defined. 
///   HISTORY: New Enumeration in IFC Release 2.0  
///   Enumeration: 
/// 
/// ASSETINVENTORY: A collection of asset instances of type IfcAsset 
/// SPACEINVENTORY: A collection of space instances of type IfcSpace 
/// FURNITUREINVENTORY: A collection of furniture instances of type IfcFurnishingElement 
/// USERDEFINED: User-defined type. 
/// NOTDEFINED: Undefined type.
typedef enum {IfcInventoryType_ASSETINVENTORY, IfcInventoryType_SPACEINVENTORY, IfcInventoryType_FURNITUREINVENTORY, IfcInventoryType_USERDEFINED, IfcInventoryType_NOTDEFINED} IfcInventoryTypeEnum;
const char* ToString(IfcInventoryTypeEnum v);
IfcInventoryTypeEnum FromString(const std::string& s);
}
namespace IfcJunctionBoxTypeEnum {
/// The IfcJunctionBoxTypeEnum defines the range of types of junction boxes available.
///   HISTORY: New type in IFC 2x2.  Values added in IFC 2x4. 
/// 
/// POWER: Contains cables, outlets, and/or switches for electrical power.
/// DATA: Contains cables, outlets, and/or switches for communications use.
/// USERDEFINED: User-defined type.
/// NOTDEFINED: Undefined type.
typedef enum {IfcJunctionBoxType_USERDEFINED, IfcJunctionBoxType_NOTDEFINED} IfcJunctionBoxTypeEnum;
const char* ToString(IfcJunctionBoxTypeEnum v);
IfcJunctionBoxTypeEnum FromString(const std::string& s);
}
namespace IfcLampTypeEnum {
/// The IfcLampTypeEnum defines the range of different types of lamp available. 
/// 
/// HISTORY: New type in IFC 2x2 Addendum
///   1  
///   Enumeration 
/// 
/// COMPACTFLUORESCENT: A fluorescent lamp having a compact form factor produced by shaping the tube. 
/// FLUORESCENT: A typically tubular discharge lamp in which most of the light is emitted by one or several layers of phosphors excited by ultraviolet radiation from the discharge.
/// HALOGEN: an incandescent lamp in which a tungsten filament is sealed into a compact transport envelope filled with an inert gas and a small amount of halogen such as iodine or bromine.
/// HIGHPRESSUREMERCURY: A discharge lamp in which most of the light is emitted by exciting mercury at high pressure.
/// HIGHPRESSURESODIUM: A discharge lamp in which most of the light is emitted by exciting sodium at high pressure.
/// LED: a solid state lamp that uses light-emitting diodes as the source of light.
/// METALHALIDE: A discharge lamp in which most of the light is emitted by exciting a metal halide.
/// OLED: a solid state lamp that uses light-emitting diodes as the source of light whose emissive electroluminescent layer is composed of a film of organic compounds.
/// TUNGSTENFILAMENT: A lamp that emits light by passing an electrical current through a tungsten wire filament in a near vacuum.
/// USERDEFINED: User-defined type.
/// NOTDEFINED: Undefined type.
typedef enum {IfcLampType_COMPACTFLUORESCENT, IfcLampType_FLUORESCENT, IfcLampType_HIGHPRESSUREMERCURY, IfcLampType_HIGHPRESSURESODIUM, IfcLampType_METALHALIDE, IfcLampType_TUNGSTENFILAMENT, IfcLampType_USERDEFINED, IfcLampType_NOTDEFINED} IfcLampTypeEnum;
const char* ToString(IfcLampTypeEnum v);
IfcLampTypeEnum FromString(const std::string& s);
}
namespace IfcLayerSetDirectionEnum {
/// IfcLayerSetDirectionEnum provides identification of the axis of element geometry, denoting the layer set thickness direction, or direction of layer offsets.
/// 
/// ENUMERATION
/// 
/// AXIS1: Usually x-axis.
/// AXIS2: Usually y-axis.
/// AXIS3: Usually z-axis.
/// 
/// HISTORY: New Type in IFC2x.
typedef enum {IfcLayerSetDirection_AXIS1, IfcLayerSetDirection_AXIS2, IfcLayerSetDirection_AXIS3} IfcLayerSetDirectionEnum;
const char* ToString(IfcLayerSetDirectionEnum v);
IfcLayerSetDirectionEnum FromString(const std::string& s);
}
namespace IfcLightDistributionCurveEnum {
/// There are three kinds of light distribution curves, according to Standard CEN TC 169, prEN 13032-1, CIE 121: 
/// 
/// TYPE_A: Type A is basically not used. For completeness the Type A Photometry equals the Type B rotated 90° around the Z-Axis counter clockwise. 
/// TYPE_B: Type B is sometimes used for floodlights. The B-Plane System has a horizontal axis. B-Angles are valid from -180° to +180° with B 0° at the bottom and B180°/B-180° at the top, &#946;-Angles are valid from -90° to +90°. (See Figure 302.)
/// TYPE_C: Type C is the recommended standard system. The C-Plane system equals a globe with a vertical axis. C-Angles are valid from 0° to 360°, &#947;-Angles are valid from 0° (south pole) to 180° (north pole). (See Figure 302.) 
/// 
/// <table
/// 
/// B-Type System 
///   C-Type System 
/// 
/// Figure 302 — Light distribution curves
/// 
/// HISTORY  This is a new enumeration in IFC2x2.
typedef enum {IfcLightDistributionCurve_TYPE_A, IfcLightDistributionCurve_TYPE_B, IfcLightDistributionCurve_TYPE_C, IfcLightDistributionCurve_NOTDEFINED} IfcLightDistributionCurveEnum;
const char* ToString(IfcLightDistributionCurveEnum v);
IfcLightDistributionCurveEnum FromString(const std::string& s);
}
namespace IfcLightEmissionSourceEnum {
/// IfcLightEmissionSourceEnum defines the range of different types of light emitter available. 
/// 
/// HISTORY: New type in IFC2x2.
/// 
/// Enumeration 
/// 
/// COMPACTFLUORESCENT
/// FLUORESCENT
/// HIGHPRESSUREMERCURY
/// HIGHPRESSURESODIUM
/// LIGHTEMITTINGDIODE
/// LOWPRESSURESODIUM
/// LOWVOLTAGEHALOGEN
/// MAINVOLTAGEHALOGEN
/// METALHALIDE 
/// TUNGSTENFILAMENT 
/// NOTDEFINED
typedef enum {IfcLightEmissionSource_COMPACTFLUORESCENT, IfcLightEmissionSource_FLUORESCENT, IfcLightEmissionSource_HIGHPRESSUREMERCURY, IfcLightEmissionSource_HIGHPRESSURESODIUM, IfcLightEmissionSource_LIGHTEMITTINGDIODE, IfcLightEmissionSource_LOWPRESSURESODIUM, IfcLightEmissionSource_LOWVOLTAGEHALOGEN, IfcLightEmissionSource_MAINVOLTAGEHALOGEN, IfcLightEmissionSource_METALHALIDE, IfcLightEmissionSource_TUNGSTENFILAMENT, IfcLightEmissionSource_NOTDEFINED} IfcLightEmissionSourceEnum;
const char* ToString(IfcLightEmissionSourceEnum v);
IfcLightEmissionSourceEnum FromString(const std::string& s);
}
namespace IfcLightFixtureTypeEnum {
/// The IfcLightFixtureTypeEnum defines the range of different types of light fixture available.
/// 
/// HISTORY: New type in IFC 2x Edition 2IFC 2x4: SECURITYLIGHTING added
/// 
/// Enumeration
/// 
/// POINTSOURCE: A light fixture that is considered to have negligible area and that emit light with approximately equal intensity in all directions.  A light fixture containing a tungsten, halogen or similar bulb is an example of a point source.
/// DIRECTIONSOURCE: A light fixture that is considered to have a length or surface area from which it emits light in a direction. A light fixture containing one or more fluorescent lamps is an example of a direction source. 
/// SECURITYLIGHTING: A light fixture having specific purpose of directing occupants in an emergency, such as an illuminated exit sign or emergency flood light. 
/// USERDEFINED: User-defined type.
/// NOTDEFINED: Undefined type.
typedef enum {IfcLightFixtureType_POINTSOURCE, IfcLightFixtureType_DIRECTIONSOURCE, IfcLightFixtureType_USERDEFINED, IfcLightFixtureType_NOTDEFINED} IfcLightFixtureTypeEnum;
const char* ToString(IfcLightFixtureTypeEnum v);
IfcLightFixtureTypeEnum FromString(const std::string& s);
}
namespace IfcLoadGroupTypeEnum {
/// Definition from IAI: This type definition is used to distinguish between different levels
/// of load grouping.  It allows to differentiate between load groups, load cases, and load combinations.
/// Normally, these enumeration types shall be used in the following context:
/// 
/// LOAD_GROUP groups instances of subtypes of IfcStructuralAction.  It shall be used as a
///   container for loads grouped together for specific purposes, e.g. loads which are part of a
///   special load pattern.
///   LOAD_CASE groups LOAD_GROUPs and instances of subtypes of IfcStructuralAction.
///   It should be used as a container for loads with the same origin.
///   LOAD_COMBINATION_GROUP is an intermediate level between LOAD_CASE and LOAD_COMBINATION.
///   The purpose of this level is to provide a factor with which one or more LOAD_CASEs occur in a
///   LOAD_COMBINATION.  This factor cannot be specified directly at the load case if the load case
///   is meant to occur in more than one combination with different factors.
///   This intermediate level is obsolete.  Instead, 
///   LOAD_COMBINATION is used to group load cases which act together into a load combination.
///   USERDEFINED:  A grouping level which does not follow the standard hierarchy of load group types.
///   NOTDEFINED:  The grouping level is not yet known.
/// 
/// HISTORY: New type in IFC 2x2.
/// 
/// IFC 2x4 change:  Obsolete item LOAD_COMBINATION_GROUP removed.  Load cases are directly assigned to load combinations with different factors for each load case—load combination pair by means of IfcRelAssignsToGroupByFactor.
typedef enum {IfcLoadGroupType_LOAD_GROUP, IfcLoadGroupType_LOAD_CASE, IfcLoadGroupType_LOAD_COMBINATION_GROUP, IfcLoadGroupType_LOAD_COMBINATION, IfcLoadGroupType_USERDEFINED, IfcLoadGroupType_NOTDEFINED} IfcLoadGroupTypeEnum;
const char* ToString(IfcLoadGroupTypeEnum v);
IfcLoadGroupTypeEnum FromString(const std::string& s);
}
namespace IfcLogicalOperatorEnum {
/// Definition: IfcLogicalOperatorEnum is an enumeration that defines the logical operators that may be applied for the satisfaction of one or more operands (IfcConstraint) at a time. 
/// 
/// HISTORY  New type in IFC Release 2.0.  Renamed from IfcConstraintAggregatorEnum in IFC 2x2
/// 
/// IFC2x4 CHANGE: Extended to include LOGICALXOR, LOGICALNOTAND and LOGICALNOTOR.
/// 
/// Enumeration 
/// 
/// Value 
///   Definition 
/// 
/// LOGICALAND 
///   Defines a relationship between operands whereby the result is true if all operands are true, i.e. false if at least 
/// 
/// one operand is false. 
/// 
/// LOGICALOR 
///   Defines a relationship between operands whereby the result is true if at least one operand is true, i.e false if 
/// 
/// all operands are false. 
/// 
/// LOGICALXOR 
///   Defines a relationship between operands whereby the result is true if exactly one operand is true (exclusive or). 
/// 
/// LOGICALNOTAND 
///   Defines a relationship between operands whereby the result is true if at least one operand is false, i.e false if 
/// 
/// all operands are true. 
/// 
/// LOGICALNOTOR 
///   Defines a relationship between operands whereby the result is true if all operands are false, i.e false if at least 
/// 
/// one operand is true. 
/// 
/// Use Definition 
/// 
/// The IfcLogicalOperatorEnum, when applied in a case of three operands, A, B and C, evaluates for each operator as 
/// 
/// follows:
/// 
/// TRUTH TABLE: LOGICALAND(A,B,C)
/// 
/// A
/// F
/// F
/// F
/// T
/// F
/// T
/// T
/// T
/// 
/// B
/// F
/// F
/// T
/// F
/// T
/// F
/// T
/// T
/// 
/// C
/// F
/// T
/// F
/// F
/// T
/// T
/// F
/// T
/// 
/// AND
/// F
/// F
/// F
/// F
/// F
/// F
/// F
/// T
/// 
/// TRUTH TABLE: LOGICALOR(A,B,C)
/// 
/// A
/// F
/// F
/// F
/// T
/// F
/// T
/// T
/// T
/// 
/// B
/// F
/// F
/// T
/// F
/// T
/// F
/// T
/// T
/// 
/// C
/// F
/// T
/// F
/// F
/// T
/// T
/// F
/// T
/// 
/// OR
/// F
/// T
/// T
/// T
/// T
/// T
/// T
/// T
/// 
/// TRUTH TABLE: LOGICALXOR(A,B,C)
/// 
/// A
/// F
/// F
/// F
/// T
/// F
/// T
/// T
/// T
/// 
/// B
/// F
/// F
/// T
/// F
/// T
/// F
/// T
/// T
/// 
/// C
/// F
/// T
/// F
/// F
/// T
/// T
/// F
/// T
/// 
/// XOR
/// F
/// T
/// T
/// T
/// F
/// F
/// F
/// F
/// 
/// TRUTH TABLE: LOGICALNOTAND(A,B,C)
/// 
/// A
/// F
/// F
/// F
/// T
/// F
/// T
/// T
/// T
/// 
/// B
/// F
/// F
/// T
/// F
/// T
/// F
/// T
/// T
/// 
/// C
/// F
/// T
/// F
/// F
/// T
/// T
/// F
/// T
/// 
/// NOTAND
/// T
/// T
/// T
/// T
/// T
/// T
/// T
/// F
/// 
/// TRUTH TABLE: LOGICALNOTOR(A,B,C)
/// 
/// A
/// F
/// F
/// F
/// T
/// F
/// T
/// T
/// T
/// 
/// B
/// F
/// F
/// T
/// F
/// T
/// F
/// T
/// T
/// 
/// C
/// F
/// T
/// F
/// F
/// T
/// T
/// F
/// T
/// 
/// NOTOR
/// T
/// F
/// F
/// F
/// F
/// F
/// F
/// F
typedef enum {IfcLogicalOperator_LOGICALAND, IfcLogicalOperator_LOGICALOR} IfcLogicalOperatorEnum;
const char* ToString(IfcLogicalOperatorEnum v);
IfcLogicalOperatorEnum FromString(const std::string& s);
}
namespace IfcMemberTypeEnum {
/// Definition from IAI: This enumeration defines the
/// different types of linear elements an IfcMemberType object
/// can fulfill:
/// 
/// BRACE: A linear element (usually sloped) often used
/// for bracing of a girder or truss.
/// CHORD: Upper or lower longitudinal member of a truss,
/// used horizontally or sloped.
/// COLLAR: A linear element (usually used horizontally)
/// within a roof structure to connect rafters and posts.
/// MEMBER: A linear element within a girder or truss with
/// no further meaning.
/// MULLION: A linear element within a curtain wall system
/// to connect two (or more) panels.
/// PLATE: A linear continuous horizontal element in wall
/// framing, e.g. a head piece or a sole plate.
/// 
/// NOTE  This head piece or sole plate shall not
/// be mixed up with planar elements, such as sheets and panels, that
/// are handled as IfcPlate (and
/// IfcPlateType).
/// 
/// POST: A linear member (usually used vertically) within
/// a roof structure to support purlins.
/// PURLIN: A linear element (usually used horizontally)
/// within a roof structure to support rafters
/// RAFTER: A linear elements used to support roof slabs
/// or roof covering, usually used with slope.
/// STRINGER: A linear element used to support stair or
/// ramp flights, usually used with slope.
/// STRUT: A linear element often used within a girder or
/// truss.
/// STUD: Vertical element in wall framing.
/// USERDEFINED: User-defined linear element.
/// NOTDEFINED: Undefined linear element
/// 
/// HISTORY: New
/// Enumeration in Release IFC2x Edition 2.
/// IFC2x Edition 2
/// Addendum 1 CHANGE  The additional identifiers CHORD, PLATE, STUD
/// are added.
/// IFC2x Edition 3 CHANGE  The additional identifier MULLION has
/// been added.
typedef enum {IfcMemberType_BRACE, IfcMemberType_CHORD, IfcMemberType_COLLAR, IfcMemberType_MEMBER, IfcMemberType_MULLION, IfcMemberType_PLATE, IfcMemberType_POST, IfcMemberType_PURLIN, IfcMemberType_RAFTER, IfcMemberType_STRINGER, IfcMemberType_STRUT, IfcMemberType_STUD, IfcMemberType_USERDEFINED, IfcMemberType_NOTDEFINED} IfcMemberTypeEnum;
const char* ToString(IfcMemberTypeEnum v);
IfcMemberTypeEnum FromString(const std::string& s);
}
namespace IfcMotorConnectionTypeEnum {
/// The IfcMotorConnectionTypeEnum defines the range of different types of motor connection that can be specified. 
///   HISTORY: New type in IFC 2x.  
///   Enumeration 
/// 
/// BELTDRIVE: An indirect connection made through the medium of a shaped, flexible continuous loop. 
/// COUPLING: An indirect connection made through the medium of the viscosity of a fluid. 
/// DIRECTDRIVE: A direct, physical connection made between the motor and the driven device. 
/// USERDEFINED: User-defined type. 
/// NOTDEFINED: Undefined type.
typedef enum {IfcMotorConnectionType_BELTDRIVE, IfcMotorConnectionType_COUPLING, IfcMotorConnectionType_DIRECTDRIVE, IfcMotorConnectionType_USERDEFINED, IfcMotorConnectionType_NOTDEFINED} IfcMotorConnectionTypeEnum;
const char* ToString(IfcMotorConnectionTypeEnum v);
IfcMotorConnectionTypeEnum FromString(const std::string& s);
}
namespace IfcNullStyle {
/// Definition from ISO/CD 10303-46:1992: The null style type specifies, that a representation item is not styled.
/// 
/// NOTE  Corresponding ISO 10303 name: null_style. Please refer to ISO/IS 10303-46:1994 for the final
/// definition of the formal standard.
/// 
/// HISTORY  New enumeration in IFC2x2.
/// 
/// IFC2x4 CHANGE  The enumeration is deprecated.
typedef enum {IfcNullStyle_NULL} IfcNullStyle;
const char* ToString(IfcNullStyle v);
IfcNullStyle FromString(const std::string& s);
}
namespace IfcObjectTypeEnum {
/// This enumeration defines the applicable object categories, that is, the subtypes at the 2nd level of the IFC inheritance tree. Attached to an object, it indicates to which subtype of IfcObject the entity referencing it would otherwise comply with. 
/// 
/// HISTORY New entity in IFC Release 1.0, has been renamed from IfcProxyEnum in IFC 2x.
typedef enum {IfcObjectType_PRODUCT, IfcObjectType_PROCESS, IfcObjectType_CONTROL, IfcObjectType_RESOURCE, IfcObjectType_ACTOR, IfcObjectType_GROUP, IfcObjectType_PROJECT, IfcObjectType_NOTDEFINED} IfcObjectTypeEnum;
const char* ToString(IfcObjectTypeEnum v);
IfcObjectTypeEnum FromString(const std::string& s);
}
namespace IfcObjectiveEnum {
/// IfcObjectiveEnum is an enumeration used to determine the objective for which purpose the constraint needs to be satisfied. 
/// 
/// HISTORY: IFC2x4 CHANGE: Extended to include CODEWAIVER.
/// 
/// Enumeration 
/// 
/// Value 
///   Definition 
/// 
/// CODECOMPLIANCE 
///   A constraint whose objective is to ensure satisfaction of a code compliance provision. 
/// 
/// CODEWAIVER 
///   A constraint whose objective is to identify an agreement that code compliance requirements (the waiver) will not be enforced. 
/// 
/// DESIGNINTENT 
///   A constraint whose objective is to ensure satisfaction of a design intent provision. 
/// 
/// HEALTHANDSAFETY 
///   A constraint whose objective is to ensure satisfaction of a health and safety provision. 
/// 
/// REQUIREMENT 
///   A constraint whose objective is to ensure satisfaction of a project requirement provision. 
/// 
/// SPECIFICATION 
///   A constraint whose objective is to ensure satisfaction of a specification provision. 
/// 
/// TRIGGERCONDITION 
///   A constraint whose objective is to indicate a limiting value beyond which the condition of an object requires a particular form of attention.
typedef enum {IfcObjective_CODECOMPLIANCE, IfcObjective_DESIGNINTENT, IfcObjective_HEALTHANDSAFETY, IfcObjective_REQUIREMENT, IfcObjective_SPECIFICATION, IfcObjective_TRIGGERCONDITION, IfcObjective_USERDEFINED, IfcObjective_NOTDEFINED} IfcObjectiveEnum;
const char* ToString(IfcObjectiveEnum v);
IfcObjectiveEnum FromString(const std::string& s);
}
namespace IfcOccupantTypeEnum {
/// IfcOccupantTypeEnum defines the types of occupant from which the type required can be selected. 
///   HISTORY: New Enumeration in IFC Release 2.0 Modified in IFC 2x2 
///   Enumeration: 
/// 
/// ASSIGNEE: Actor receiving the assignment of a property agreement from an assignor  
/// ASSIGNOR: Actor assigning a property agreement to an assignor  
/// LESSEE: Actor receiving the lease of a property from a lessor  
/// LESSOR: Actor leasing a property to a lessee  
/// LETTINGAGENT: Actor participating in a property agreement on behalf of an owner, lessor or assignor  
/// OWNER: Actor that owns a property  
/// TENANT: Actor renting the use of a property fro a period of time  
/// USERDEFINED: User-defined type.  
/// NOTDEFINED: Undefined type.
typedef enum {IfcOccupantType_ASSIGNEE, IfcOccupantType_ASSIGNOR, IfcOccupantType_LESSEE, IfcOccupantType_LESSOR, IfcOccupantType_LETTINGAGENT, IfcOccupantType_OWNER, IfcOccupantType_TENANT, IfcOccupantType_USERDEFINED, IfcOccupantType_NOTDEFINED} IfcOccupantTypeEnum;
const char* ToString(IfcOccupantTypeEnum v);
IfcOccupantTypeEnum FromString(const std::string& s);
}
namespace IfcOutletTypeEnum {
/// The IfcOutletTypeEnum defines the range of different types of outlet that can be specified. 
/// 
/// HISTORY: New type in IFC 2x. Telephone and Data outlets added in IFC 2x4
/// 
/// Enumeration 
/// 
/// AUDIOVISUALOUTLET: An outlet used for an audio or visual device. 
/// COMMUNICATIONSOUTLET: An outlet used for connecting communications equipment. 
/// POWEROUTLET: An outlet used for connecting electrical devices requiring power.  
/// DATAOUTLET: An outlet used for connecting data communications equipment. 
/// TELEPHONEOUTLET: An outlet used for connecting telephone communications equipment.  
/// USERDEFINED: User-defined type. 
/// NOTDEFINED: Undefined type.
typedef enum {IfcOutletType_AUDIOVISUALOUTLET, IfcOutletType_COMMUNICATIONSOUTLET, IfcOutletType_POWEROUTLET, IfcOutletType_USERDEFINED, IfcOutletType_NOTDEFINED} IfcOutletTypeEnum;
const char* ToString(IfcOutletTypeEnum v);
IfcOutletTypeEnum FromString(const std::string& s);
}
namespace IfcPermeableCoveringOperationEnum {
/// Definition: Enumeration defining the valid types of permeable coverings. 
/// 
/// Enumeration:
/// 
/// GRILL 
///   protective screen of metal bars or wires
/// 
/// LOUVER 
///   set of fixed or movable strips of wood, metal, etc. arranged to let
///   air in while keeping light or rain out
/// 
/// SCREEN 
///   upright, fixed or movable, sometimes folding framework used for
///   protection against heat, light, access or similar
/// 
/// USERDEFINED 
///   user defined permeable covering type
/// 
/// NOTDEFINED 
///   no information available
/// 
/// HISTORY: New Enumeration in IFC Release 2.0
typedef enum {IfcPermeableCoveringOperation_GRILL, IfcPermeableCoveringOperation_LOUVER, IfcPermeableCoveringOperation_SCREEN, IfcPermeableCoveringOperation_USERDEFINED, IfcPermeableCoveringOperation_NOTDEFINED} IfcPermeableCoveringOperationEnum;
const char* ToString(IfcPermeableCoveringOperationEnum v);
IfcPermeableCoveringOperationEnum FromString(const std::string& s);
}
namespace IfcPhysicalOrVirtualEnum {
/// Definition from IAI: This enumeration defines the
///   different types of space boundaries in terms of its
///   physical manifestation. A space boundary can either be
///   physically dividing or can be a virtual divider.
/// 
/// Enumeration:
/// 
/// PHYSICAL
/// 
/// The space boundary is provided physically, i.e. by an
///   physical element.
/// 
/// VIRTUAL
/// 
/// The space boundary is provided virtually, i.e. by a
///   logical divider that has no physical manifestation.
/// 
/// NOTDEFINED
/// 
/// No information available.
/// 
/// HISTORY: New enumeration in
///   IFC Release 2.0
typedef enum {IfcPhysicalOrVirtual_PHYSICAL, IfcPhysicalOrVirtual_VIRTUAL, IfcPhysicalOrVirtual_NOTDEFINED} IfcPhysicalOrVirtualEnum;
const char* ToString(IfcPhysicalOrVirtualEnum v);
IfcPhysicalOrVirtualEnum FromString(const std::string& s);
}
namespace IfcPileConstructionEnum {
/// Definition from IAI: Enumeration defining the construction type
///   for piles. The type is mainly based on how the piles are used and manufactured.
///   Some material information is mixed in because this affects the way the piles
///   are used.  
/// 
/// HISTORY New type in IFC Release 2x2
/// 
/// ENUMERATION 
/// 
/// CAST_IN_PLACE Piles and piers that are excavated and poured in
///   place. 
///   COMPOSITE Piles that are a mix of components, such as a steel
///   outer casing which is driven into the ground with a cast-in-place concrete
///   core. 
///   PRECAST_CONCRETE Piles that are entirely of precast concrete
///   (possibly with some steel or other fixtures). 
///   PREFAB_STEEL Prefabricated piles made entirely out of steel.
///   It will also include steel sheet piles where these are not part of another
///   construction element. 
///   USERDEFINED Special types of pile construction which meet
///   specific local requirements. 
///   NOTDEFINED The type of pile construction is not defined.
typedef enum {IfcPileConstruction_CAST_IN_PLACE, IfcPileConstruction_COMPOSITE, IfcPileConstruction_PRECAST_CONCRETE, IfcPileConstruction_PREFAB_STEEL, IfcPileConstruction_USERDEFINED, IfcPileConstruction_NOTDEFINED} IfcPileConstructionEnum;
const char* ToString(IfcPileConstructionEnum v);
IfcPileConstructionEnum FromString(const std::string& s);
}
namespace IfcPileTypeEnum {
/// Definition from IAI: Enumeration defining the pile type. 
/// 
/// HISTORY New type in IFC Release 2x2
/// IFC 2x4 change:  Items BORED, DRIVEN, JETGROUTING added
/// 
/// BORED A bore pile.
///   DRIVEN A rammed, vibrated, or otherwise driven pile.
///   JETGROUTING An injected pile-like construction.
///   COHESION A cohesion pile.
///   FRICTION A friction pile.
///   SUPPORT A support pile.
///   USERDEFINED The type of pile function is user defined.
///   NOTDEFINED The type of pile function is not defined.
typedef enum {IfcPileType_COHESION, IfcPileType_FRICTION, IfcPileType_SUPPORT, IfcPileType_USERDEFINED, IfcPileType_NOTDEFINED} IfcPileTypeEnum;
const char* ToString(IfcPileTypeEnum v);
IfcPileTypeEnum FromString(const std::string& s);
}
namespace IfcPipeFittingTypeEnum {
/// This enumeration is used to identify the primary purpose of a pipe fitting. This is a very basic categorization mechanism
///   to generically identify the pipe fitting type. Subcategories
///   of pipe fittings are not enumerated. 
///   The IfcpipeFittingTypeEnum contains the following:
/// 
/// BEND:		A fitting with typically two ports used to change 
///   the direction of flow between connected elements.
///   CONNECTOR:   Connector fitting, typically used to join two
///   ports together within a flow distribution system 
///   (e.g., a coupling used to join two pipe segments).
///   ENTRY:       Entry fitting, typically unconnected at one port
///   and connected to a flow distribution system at 
///   the other (e.g., a breeching inlet).
///   EXIT:        Exit fitting, typically unconnected at one port
///   and connected to a flow distribution system at 
///   the other (e.g., a hose bibb).
///   JUNCTION:	A fitting with typically more than two ports used
///   to redistribute flow among the ports and/or to
///   change the direction of flow between connected
///   elements (e.g, tee, cross, wye, etc.).
///   OBSTRUCTION: A fitting with typically two ports used to 
///   obstruct or restrict flow between the connected
///   elements (e.g., screen, perforated plate, etc.).
///   TRANSITION:	A fitting with typically two ports having
///   different shapes or sizes. Can also be used to
///   change the direction of flow between connected
///   elements.
///   USERDEFINED: User-defined fitting.
///   NOTDEFINED:  Undefined fitting.
/// 
/// HISTORY: New enumeration in IFC 2x2
typedef enum {IfcPipeFittingType_BEND, IfcPipeFittingType_CONNECTOR, IfcPipeFittingType_ENTRY, IfcPipeFittingType_EXIT, IfcPipeFittingType_JUNCTION, IfcPipeFittingType_OBSTRUCTION, IfcPipeFittingType_TRANSITION, IfcPipeFittingType_USERDEFINED, IfcPipeFittingType_NOTDEFINED} IfcPipeFittingTypeEnum;
const char* ToString(IfcPipeFittingTypeEnum v);
IfcPipeFittingTypeEnum FromString(const std::string& s);
}
namespace IfcPipeSegmentTypeEnum {
/// This enumeration is used to identify the primary purpose of a
///   pipe segment. This is a very basic categorization mechanism
///   to generically identify the pipe segment type. Subcategories
///   of pipe segments are not enumerated. 
///   The IfcPipeSegmentTypeEnum contains the following:
/// 
/// CULVERT: A covered channel or large pipe that forms a watercourse below ground level, usually under a road or railway.
///   RIGIDSEGMENT: A rigid segment is continuous linear segment of pipe that cannot be deformed.
///   FLEXIBLESEGMENT:  A flexible segment is a continuous non-linear segment of pipe that can be deformed and change the direction of flow.
///   GUTTER: A gutter segment is a continuous open-channel segment of pipe.
///   SPOOL: A type of rigid segment that is typically shorter and used for providing connectivity within a piping network.
///   USERDEFINED: User-defined segment.
///   NOTDEFINED:  Undefined segment.
/// 
/// HISTORY: New enumeration in IFC 2x2
typedef enum {IfcPipeSegmentType_FLEXIBLESEGMENT, IfcPipeSegmentType_RIGIDSEGMENT, IfcPipeSegmentType_GUTTER, IfcPipeSegmentType_SPOOL, IfcPipeSegmentType_USERDEFINED, IfcPipeSegmentType_NOTDEFINED} IfcPipeSegmentTypeEnum;
const char* ToString(IfcPipeSegmentTypeEnum v);
IfcPipeSegmentTypeEnum FromString(const std::string& s);
}
namespace IfcPlateTypeEnum {
/// Definition from IAI: This enumeration
/// defines the different types of planar elements an IfcPlateType
/// object can fulfill:
/// 
/// CURTAIN_PANEL: A planar element within a
/// curtain wall, often consisting of a frame with fixed glazing.
///   SHEET: A planar, flat and thin element,
/// comes usually as metal sheet, and is often used as an additonal part
/// within an assembly.
///   USERDEFINED: User-defined linear element.
///   NOTDEFINED: Undefined linear element
/// 
/// HISTORY  New Enumeration in Release IFC2x Edition 2. 
/// IFC2x
/// Edition 3
/// CHANGE  The additional identifiers CURTAIN_PANEL, SHEET have
/// been
/// added.
typedef enum {IfcPlateType_CURTAIN_PANEL, IfcPlateType_SHEET, IfcPlateType_USERDEFINED, IfcPlateType_NOTDEFINED} IfcPlateTypeEnum;
const char* ToString(IfcPlateTypeEnum v);
IfcPlateTypeEnum FromString(const std::string& s);
}
namespace IfcProcedureTypeEnum {
/// The IfcProcedureTypeEnum defines the range of different types of procedure that can be specified.
/// 
/// HISTORY: New type in IFC2x2
/// 
/// Enumeration:
/// 
/// ADVICE_CAUTION: A caution that should be taken note of as a procedure or when carrying out a procedure
/// ADVICE_NOTE: Additional information or advice that should be taken note of as a procedure or when carrying out a procedure
/// ADVICE_WARNING: A warning of potential danger that should be taken note of as a procedure or when carrying out a procedure
/// CALIBRATION: A procedure undertaken to calibrate an artifact
/// SHUTDOWN: A procedure undertaken to shutdown the operation an artifact
/// STARTUP: A procedure undertaken to start up the operation an artifact
/// USERDEFINED
/// NOTDEFINED
typedef enum {IfcProcedureType_ADVICE_CAUTION, IfcProcedureType_ADVICE_NOTE, IfcProcedureType_ADVICE_WARNING, IfcProcedureType_CALIBRATION, IfcProcedureType_DIAGNOSTIC, IfcProcedureType_SHUTDOWN, IfcProcedureType_STARTUP, IfcProcedureType_USERDEFINED, IfcProcedureType_NOTDEFINED} IfcProcedureTypeEnum;
const char* ToString(IfcProcedureTypeEnum v);
IfcProcedureTypeEnum FromString(const std::string& s);
}
namespace IfcProfileTypeEnum {
/// The enumeration defines whether the definition of a profile shape shall be geometrically resolved into a curve or into a surface.
/// 
/// HISTORY: New type in IFC 1.5.
/// 
/// Enumeration values:
/// 
/// CURVE: The resulting geometric item is of type curve and closed (with the only exception of the curve created by the IfcArbitraryOpenProfileDef which resolves into an open curve). The resulting geometry after applying a sweeping operation is a swept surface. This can be used to define shapes with thin sheets, such as ducts, where the thickness is not appropriate for geometric representation.
/// AREA: The resulting geometric item is of type surface. The resulting geometry after applying a sweeping operation is a swept solid with defined volume.
typedef enum {IfcProfileType_CURVE, IfcProfileType_AREA} IfcProfileTypeEnum;
const char* ToString(IfcProfileTypeEnum v);
IfcProfileTypeEnum FromString(const std::string& s);
}
namespace IfcProjectOrderRecordTypeEnum {

typedef enum {IfcProjectOrderRecordType_CHANGE, IfcProjectOrderRecordType_MAINTENANCE, IfcProjectOrderRecordType_MOVE, IfcProjectOrderRecordType_PURCHASE, IfcProjectOrderRecordType_WORK, IfcProjectOrderRecordType_USERDEFINED, IfcProjectOrderRecordType_NOTDEFINED} IfcProjectOrderRecordTypeEnum;
const char* ToString(IfcProjectOrderRecordTypeEnum v);
IfcProjectOrderRecordTypeEnum FromString(const std::string& s);
}
namespace IfcProjectOrderTypeEnum {
/// An IfcProjectOrderTypeEnum is a list of the types of project order that may be identified. 
///   HISTORY: New type in IFC 2x2  
///   Enumeration 
/// 
/// CHANGEORDER: An instruction to make a change to a product or work being undertaken and a description of the work that is to be performed. 
/// MAINTENANCEWORKORDER: An instruction to carry out maintenance work and a description of the work that is to be performed. 
/// MOVEORDER: An instruction to move persons and artefacts and a description of the move locations, objects to be moved, etc.  
/// PURCHASEORDER: An instruction to purchase goods and/or services and a description of the goods and/or services to be purchased that is to be performed. 
/// WORKORDER: A general instruction to carry out work and a description of the work to be done. Note the difference between a work order generally and a maintenance work order. 
/// USERDEFINED: User-defined type. 
/// NOTDEFINED: Undefined type.
typedef enum {IfcProjectOrderType_CHANGEORDER, IfcProjectOrderType_MAINTENANCEWORKORDER, IfcProjectOrderType_MOVEORDER, IfcProjectOrderType_PURCHASEORDER, IfcProjectOrderType_WORKORDER, IfcProjectOrderType_USERDEFINED, IfcProjectOrderType_NOTDEFINED} IfcProjectOrderTypeEnum;
const char* ToString(IfcProjectOrderTypeEnum v);
IfcProjectOrderTypeEnum FromString(const std::string& s);
}
namespace IfcProjectedOrTrueLengthEnum {
/// This enumeration type is needed for load definition and is only considered if the load values are given as global actions and if they define linear or planar loads (that is, one- or two-dimensionally distributed loads).
/// Figure 234 illustrates the interpretation of a load definition depending on the enumeration types IfcGlobalOrLocalEnum and IfcProjectedOrTrueLengthEnum.
/// 
/// HISTORY  New type in IFC2x2. 
/// 
/// Figure 234 — Projected or true length
typedef enum {IfcProjectedOrTrueLength_PROJECTED_LENGTH, IfcProjectedOrTrueLength_TRUE_LENGTH} IfcProjectedOrTrueLengthEnum;
const char* ToString(IfcProjectedOrTrueLengthEnum v);
IfcProjectedOrTrueLengthEnum FromString(const std::string& s);
}
namespace IfcPropertySourceEnum {

typedef enum {IfcPropertySource_DESIGN, IfcPropertySource_DESIGNMAXIMUM, IfcPropertySource_DESIGNMINIMUM, IfcPropertySource_SIMULATED, IfcPropertySource_ASBUILT, IfcPropertySource_COMMISSIONING, IfcPropertySource_MEASURED, IfcPropertySource_USERDEFINED, IfcPropertySource_NOTKNOWN} IfcPropertySourceEnum;
const char* ToString(IfcPropertySourceEnum v);
IfcPropertySourceEnum FromString(const std::string& s);
}
namespace IfcProtectiveDeviceTypeEnum {
/// The IfcProtectiveDeviceTypeEnum specifically defines the range of different breaker unit types that can be used in conjunction with protective device. Types may also be used as a reference to a complete protective device in circumstances where tripping units are not separately identified (typically expected to be the case during earlier stages of design). 
/// 
/// HISTORY: New type in IFC 2x2. Modified definition and usage in IFC 2x4 
/// 
/// Enumeration
/// 
/// FUSEDISCONNECTOR: A device that will electrically open the circuit after a period of prolonged, abnormal current flow.
/// CIRCUITBREAKER: A mechanical switching device capable of making, carrying, and breaking currents under normal circuit conditions and also making, carrying for a specified time and breaking, current under specified abnormal circuit conditions such as those of short circuit.
/// EARTHINGSWITCH: A safety device used to open or close a circuit when there is no current. Used to isolate a part of a circuit, a machine, a part of an overhead line or an underground line so that maintenance can be safely conducted.
/// EARTHLEAKAGECIRCUITBREAKER: A device that opens, closes, or isolates a circuit and has short circuit protection but no overload protection.  It attempts to break the circuit when there is a leakage of current from phase to earth, by measuring voltage on the earth conductor.
/// RESIDUALCURRENTCIRCUITBREAKER: A device that opens, closes, or isolates a circuit and has short circuit and overload protection.  It attempts to break the circuit when there is a difference in current between any two phases.  May also be referred to as 'Ground Fault Interupter (GFI)' or 'Ground Fault Circuit Interuptor (GFCI)'
/// RESIDUALCURRENTSWITCH: A device that opens, closes or isolates a circuit and has no short circuit or overload protection.  May also be identified as a 'ground fault switch'.
/// VARISTOR: A high voltage surge protection device.
/// USERDEFINED: User-defined type.
/// NOTDEFINED: Undefined type.
typedef enum {IfcProtectiveDeviceType_FUSEDISCONNECTOR, IfcProtectiveDeviceType_CIRCUITBREAKER, IfcProtectiveDeviceType_EARTHFAILUREDEVICE, IfcProtectiveDeviceType_RESIDUALCURRENTCIRCUITBREAKER, IfcProtectiveDeviceType_RESIDUALCURRENTSWITCH, IfcProtectiveDeviceType_VARISTOR, IfcProtectiveDeviceType_USERDEFINED, IfcProtectiveDeviceType_NOTDEFINED} IfcProtectiveDeviceTypeEnum;
const char* ToString(IfcProtectiveDeviceTypeEnum v);
IfcProtectiveDeviceTypeEnum FromString(const std::string& s);
}
namespace IfcPumpTypeEnum {
/// Defines general types of pumps.
/// 
/// The IfcPumpTypeEnum contains the following:
/// 
/// CIRCULATOR: A Circulator pump is a generic low-pressure, low-capacity pump. It may have a wet rotor and
///   may be driven by a flexible-coupled motor.
/// 
/// ENDSUCTION: An End Suction pump, when mounted horizontally, has a single horizontal inlet on the impeller suction side
///   and a vertical discharge. It may have a direct or close-coupled motor.
/// 
/// SPLITCASE: A Split Case pump, when mounted horizontally, has an inlet and outlet on each side of the impeller.
///   The impeller can be easily accessed by removing the front of the impeller casing. It may have a direct or close-coupled motor.
/// 
/// SUBMERSIBLEPUMP: A pump designed to be immersed in a fluid, typically a collection tank.
/// 
/// SUMPPUMP: A pump designed to sit above a collection tank with a suction inlet extending into the tank.
/// 
/// VERTICALINLINE: A Vertical Inline pump has the pump and motor close-coupled on the pump casing.
///   The pump depends on the connected, horizontal piping for support, with the suction and discharge along the piping axis.
/// 
/// VERTICALTURBINE: A Vertical Turbine pump has a motor mounted vertically on the pump casing for either
///   wet-pit sump mounting or dry-well mounting.
/// 
/// USERDEFINED: User-defined pump type.
/// 
/// NOTDEFINED:  Pump type has not been defined.
/// 
/// HISTORY: New enumeration in IFC R2x.  SUBMERSIBLEPUMP and SUMPPUMP added in IFC2x4.
typedef enum {IfcPumpType_CIRCULATOR, IfcPumpType_ENDSUCTION, IfcPumpType_SPLITCASE, IfcPumpType_VERTICALINLINE, IfcPumpType_VERTICALTURBINE, IfcPumpType_USERDEFINED, IfcPumpType_NOTDEFINED} IfcPumpTypeEnum;
const char* ToString(IfcPumpTypeEnum v);
IfcPumpTypeEnum FromString(const std::string& s);
}
namespace IfcRailingTypeEnum {
/// Definition from IAI: Enumeration defining the valid types of
///   railings that can be predefined using the enumeration values.  
///   HISTORY: New Enumeration in IFC
///   Release 2.0  
///   Enumeration 
/// 
/// HANDRAIL: A type of railing designed to serve as an optional
///   structural support for loads applied by human occupants (at hand height).
///   Generally located adjacent to ramps and stairs. Generally floor or wall
///   mounted. 
///   GUARDRAIL: A type of railing designed to guard human occupants
///   from falling off a stair, ramp or landing where there is a vertical drop at the
///   edge of such floors/landings. 
///   BALUSTRADE: Similar to the definitions of a guardrail except
///   the location is at the edge of a floor, rather then a stair or ramp. Examples
///   are balustrates at roof-tops or balconies. 
///   USERDEFINED: User-defined railing element, a term to identify
///   the user type is given by the attribute IfcRailing.ObjectType. 
///   NOTDEFINED: Undefined railing element, no type information
///   available.
typedef enum {IfcRailingType_HANDRAIL, IfcRailingType_GUARDRAIL, IfcRailingType_BALUSTRADE, IfcRailingType_USERDEFINED, IfcRailingType_NOTDEFINED} IfcRailingTypeEnum;
const char* ToString(IfcRailingTypeEnum v);
IfcRailingTypeEnum FromString(const std::string& s);
}
namespace IfcRampFlightTypeEnum {
/// Definition from IAI: This enumeration defines the different types
///   of linear elements an IfcRampFlightType object can fulfill: 
/// 
/// STRAIGHT: A ramp flight with a straight walking line.  
///   SPIRAL: A ramp flight with a circular or elliptic walking
///   line. 
///   USERDEFINED: User-defined ramp flight. 
///   NOTDEFINED: Undefined ramp flight. 
/// 
/// HISTORY: New Enumeration in
///   Release IFC2x Edition 2.
typedef enum {IfcRampFlightType_STRAIGHT, IfcRampFlightType_SPIRAL, IfcRampFlightType_USERDEFINED, IfcRampFlightType_NOTDEFINED} IfcRampFlightTypeEnum;
const char* ToString(IfcRampFlightTypeEnum v);
IfcRampFlightTypeEnum FromString(const std::string& s);
}
namespace IfcRampTypeEnum {
/// This enumeration defines the basic configuration of the ramp type in terms of the number and shape of ramp flights, as shown in Figure 67. The type also distinguished turns by landings. In addition the subdivision of the straight and changing direction ramps is included. The ramp configurations are given for ramps without and with one and two landings. 
/// 
/// Ramps which are subdivided into more than two landings have to be defined by the geometry only. Also ramps with non-regular shapes have to be defined by the geometry only. The type of such ramps is USERDEFINED. 
/// 
/// HISTORY New Enumeration in IFC Release 2.0. 
/// 
/// Enumerator 
///   Description 
///   Figure 
/// 
/// StraightRunRamp 
///   A ramp - which is a sloping
///   floor, walk, or roadway - connecting two levels. The straight ramp consists of
///   one straight flight without turns or winders.  
/// 
/// TwoStraightRunRamp 
///   A straight ramp consisting of
///   two straight flights without turns but with one landing. 
/// 
/// QuarterTurnRamp 
///   A ramp making a 90° turn,
///   consisting of two straight flights connected by a quarterspace landing. The
///   direction of the turn is determined by the walking line. 
/// 
/// TwoQuarterTurnRamp 
///   A ramp making a 180°
///   turn, consisting of three straight flights connected by two quarterspace
///   landings. The direction of the turn is determined by the walking line. 
/// 
/// HalfTurnRamp 
///   A ramp making a 180°
///   turn, consisting of two straight flights connected by a halfspace landing. The
///   orientation of the turn is determined by the walking line. 
/// 
/// SpiralRamp 
///   A ramp constructed around a
///   circular or elliptical well without newels and landings. 
/// 
/// UserDefined 
///   Free form ramp (user defined
///   operation type) 
///     
/// 
/// NotDefined 
///     
///     
/// 
/// Figure 67 — Ramp types
typedef enum {IfcRampType_STRAIGHT_RUN_RAMP, IfcRampType_TWO_STRAIGHT_RUN_RAMP, IfcRampType_QUARTER_TURN_RAMP, IfcRampType_TWO_QUARTER_TURN_RAMP, IfcRampType_HALF_TURN_RAMP, IfcRampType_SPIRAL_RAMP, IfcRampType_USERDEFINED, IfcRampType_NOTDEFINED} IfcRampTypeEnum;
const char* ToString(IfcRampTypeEnum v);
IfcRampTypeEnum FromString(const std::string& s);
}
namespace IfcReflectanceMethodEnum {
/// The IfcReflectanceMethodEnum defines the range of different reflectance methods available. 
/// 
/// HISTORY: New type in IFC 2x2.
/// 
/// Enumeration 
/// 
/// BLINN: A reflectance model providing a smooth, slightly shiny appearance.
/// FLAT: A reflectance model providing a constant colour. This model ignores the effect of all light sources. 
/// GLASS: A reflectance model that supports an approximation of glass-like materials that have both reflective and transmissive properties. 
/// MATT: A reflectance model providing a dull matte appearance. 
/// METAL: A reflectance model providing a specular metallic appearance. 
/// MIRROR: A reflectance model that supports secondary mirrored views through ray tracing. 
/// PHONG: A reflectance model conforming with the Phong model in which reflections are greatest in the `mirror' direction of a surface opposite the viewing direction with respect to the surface normal. 
/// PLASTIC: A reflectance model providing a specular effect which is similar to the Phong model. 
/// STRAUSS: A reflectance model for metallic and non-metallic appearance based on a limited set of control parameter.
/// NOTDEFINED
typedef enum {IfcReflectanceMethod_BLINN, IfcReflectanceMethod_FLAT, IfcReflectanceMethod_GLASS, IfcReflectanceMethod_MATT, IfcReflectanceMethod_METAL, IfcReflectanceMethod_MIRROR, IfcReflectanceMethod_PHONG, IfcReflectanceMethod_PLASTIC, IfcReflectanceMethod_STRAUSS, IfcReflectanceMethod_NOTDEFINED} IfcReflectanceMethodEnum;
const char* ToString(IfcReflectanceMethodEnum v);
IfcReflectanceMethodEnum FromString(const std::string& s);
}
namespace IfcReinforcingBarRoleEnum {
/// Definition from IAI: Enumeration defining standard types for the
///   role, purpose or usage of the bar, i.e. the kind of loads and stresses they are
///   intended to carry.  
/// 
/// HISTORY New type in IFC Release 2x2.
///   Item ANCHORING (documented since IFC 2x2) added to the EXPRESS definition in IFC 2x4.
/// 
/// ENUMERATION 
/// 
/// MAIN The reinforcing bar is a main bar. 
///   SHEAR The reinforcing bar is a shear bar. 
///   LIGATURE The reinforcing bar is a ligature (link, stirrup). 
///   STUD The reinforcing bar is a stud. 
///   PUNCHING Punching reinforcement. 
///   EDGE Edge reinforcement. 
///   RING Ring reinforcement. 
///   ANCHORING Anchoring reinforcement. 
///   USERDEFINED The type of reinforcement is user defined. 
///   NOTDEFINED The type of reinforcement is not defined.
typedef enum {IfcReinforcingBarRole_MAIN, IfcReinforcingBarRole_SHEAR, IfcReinforcingBarRole_LIGATURE, IfcReinforcingBarRole_STUD, IfcReinforcingBarRole_PUNCHING, IfcReinforcingBarRole_EDGE, IfcReinforcingBarRole_RING, IfcReinforcingBarRole_USERDEFINED, IfcReinforcingBarRole_NOTDEFINED} IfcReinforcingBarRoleEnum;
const char* ToString(IfcReinforcingBarRoleEnum v);
IfcReinforcingBarRoleEnum FromString(const std::string& s);
}
namespace IfcReinforcingBarSurfaceEnum {
/// Definition from IAI: Enumeration indicating whether the bar has a
///   plain or textured (ribbed) surface.  
/// 
/// HISTORY New type in IFC Release 2x2
/// 
/// ENUMERATION 
/// 
/// PLAIN The reinforcing bar surface is plain. 
///   TEXTURED The reinforcing bar surface is textured (ribbed).
typedef enum {IfcReinforcingBarSurface_PLAIN, IfcReinforcingBarSurface_TEXTURED} IfcReinforcingBarSurfaceEnum;
const char* ToString(IfcReinforcingBarSurfaceEnum v);
IfcReinforcingBarSurfaceEnum FromString(const std::string& s);
}
namespace IfcResourceConsumptionEnum {
/// The IfcResourceConsumptionEnum indicates how a construction resource is consumed during its use.  The IfcResourceConsumptionEnum contains the following:
/// 
/// CONSUMED: Resource is production-based and is immediately consumed at the start of its usage.
/// PARTIALLYCONSUMED: Resource is production-based and is consumed over its usage.
/// NOTCONSUMED: Resource is production-based and is not consumed during its usage.
/// OCCUPIED: Resource is duration-based and is immediately consumed at the start of its usage.
/// PARTIALLYOCCUPIED: Resource is duration-based and is consumed over its usage.
/// NOTOCCUPIED: Resource is duration-based and is not consumed during its usage.
/// USERDEFINED: User-defined consumption; custom property sets must indicate usage.
/// NOTDEFINED: Undefined consumption.
/// 
/// HISTORY: New Enumeration in IFC Release 2.0.
typedef enum {IfcResourceConsumption_CONSUMED, IfcResourceConsumption_PARTIALLYCONSUMED, IfcResourceConsumption_NOTCONSUMED, IfcResourceConsumption_OCCUPIED, IfcResourceConsumption_PARTIALLYOCCUPIED, IfcResourceConsumption_NOTOCCUPIED, IfcResourceConsumption_USERDEFINED, IfcResourceConsumption_NOTDEFINED} IfcResourceConsumptionEnum;
const char* ToString(IfcResourceConsumptionEnum v);
IfcResourceConsumptionEnum FromString(const std::string& s);
}
namespace IfcRibPlateDirectionEnum {

typedef enum {IfcRibPlateDirection_DIRECTION_X, IfcRibPlateDirection_DIRECTION_Y} IfcRibPlateDirectionEnum;
const char* ToString(IfcRibPlateDirectionEnum v);
IfcRibPlateDirectionEnum FromString(const std::string& s);
}
namespace IfcRoleEnum {
/// Definition: Roles which may be played by an actor.
/// 
/// HISTORY This type has changes after IFC Release 2.0.  Spelling of COMMISSIONINGENGINEER fixed in IFC 2x4.
/// 
/// ENUMERATION 
/// 
/// SUPPLIER
///   MANUFACTURER
///   CONTRACTOR 
///   SUBCONTRACTOR
///   ARCHITECT
///   STRUCTURALENGINEER
///   COSTENGINEER 
///   CLIENT
///   BUILDINGOWNER
///   BUILDINGOPERATOR
///   MECHANICALENGINEER 
///   ELECTRICALENGINEER
///   PROJECTMANAGER
///   FACILITIESMANAGER
///   CIVILENGINEER
///   COMMISSIONINGENGINEER 
///   ENGINEER
///   OWNER
///   CONSULTANT
///   CONSTRUCTIONMANAGER
///   FIELDCONSTRUCTIONMANAGER 
///   RESELLER
///   USERDEFINED User defined value to be provided.
typedef enum {IfcRole_SUPPLIER, IfcRole_MANUFACTURER, IfcRole_CONTRACTOR, IfcRole_SUBCONTRACTOR, IfcRole_ARCHITECT, IfcRole_STRUCTURALENGINEER, IfcRole_COSTENGINEER, IfcRole_CLIENT, IfcRole_BUILDINGOWNER, IfcRole_BUILDINGOPERATOR, IfcRole_MECHANICALENGINEER, IfcRole_ELECTRICALENGINEER, IfcRole_PROJECTMANAGER, IfcRole_FACILITIESMANAGER, IfcRole_CIVILENGINEER, IfcRole_COMISSIONINGENGINEER, IfcRole_ENGINEER, IfcRole_OWNER, IfcRole_CONSULTANT, IfcRole_CONSTRUCTIONMANAGER, IfcRole_FIELDCONSTRUCTIONMANAGER, IfcRole_RESELLER, IfcRole_USERDEFINED} IfcRoleEnum;
const char* ToString(IfcRoleEnum v);
IfcRoleEnum FromString(const std::string& s);
}
namespace IfcRoofTypeEnum {
/// This enumeration defines the basic configuration of the roof in terms of the different roof shapes, as illustrated in Figure 68.
/// 
/// Roofs which are subdivided into more than these basic shapes have to be defined by the geometry only. Also roofs with non-regular shapes (free form roof) have to be defined by the geometry only. The type of such roofs is FREEFORM. 
/// 
/// HISTORY New Enumeration in IFC Release 2x. 
/// 
/// Enumerator 
///   Description 
///   Figure 
/// 
/// FLAT_ROOF 
///   A roof having no slope, or
///   one with only a slight pitch so as to drain rainwater. 
/// 
/// SHED_ROOF 
///   A roof having a single
///   slope. 
/// 
/// GABLE_ROOF 
///   A roof sloping downward in
///   two parts from a central ridge, so as to form a gable at each end. 
/// 
/// HIP_ROOF 
///   A roof having sloping ends
///   and sides meeting at an inclined projecting angle. 
/// 
/// HIPPED_GABLE_ROOF 
///   A roof having a hipped end
///   truncating a gable. 
/// 
/// GAMBREL_ROOF 
///   A ridged roof divided on each
///   side into a shallower slope above a steeper one. 
/// 
/// MANSARD_ROOF 
///   A roof having on each side a
///   steeper lower part and a shallower upper part. 
/// 
/// BARREL_ROOF 
///   A roof or ceiling having a
///   semicylindrical form. 
/// 
/// RAINBOW_ROOF 
///   A gable roof in the form of a
///   broad Gothic arch, with gently sloping convex surfaces. 
/// 
/// BUTTERFLY_ROOF 
///   A roof having two slopes,
///   each descending inward from the eaves. 
/// 
/// PAVILION_ROOF 
///   A pyramidal hip roof. 
/// 
/// DOME_ROOF 
///   A hemispherical hip
///   roof. 
/// 
/// FREEFORM 
///   Free form roof  
///     
/// 
/// NOTDEFINED 
///   No specification given 
///     
/// 
/// Figure 68 — Roof types
typedef enum {IfcRoofType_FLAT_ROOF, IfcRoofType_SHED_ROOF, IfcRoofType_GABLE_ROOF, IfcRoofType_HIP_ROOF, IfcRoofType_HIPPED_GABLE_ROOF, IfcRoofType_GAMBREL_ROOF, IfcRoofType_MANSARD_ROOF, IfcRoofType_BARREL_ROOF, IfcRoofType_RAINBOW_ROOF, IfcRoofType_BUTTERFLY_ROOF, IfcRoofType_PAVILION_ROOF, IfcRoofType_DOME_ROOF, IfcRoofType_FREEFORM, IfcRoofType_NOTDEFINED} IfcRoofTypeEnum;
const char* ToString(IfcRoofTypeEnum v);
IfcRoofTypeEnum FromString(const std::string& s);
}
namespace IfcSIPrefix {
/// Definition from ISO/CD 10303-41:1992: An SI prefix is the name of a prefix that may be associated 
/// with an SI unit. The definitions of SI prefixes are specified in ISO 1000 (clause 3).
/// 
/// NOTE The prefix defines multiples and submultiples of the SI units.
/// 
/// NOTE Corresponding ISO 10303 name: SI_prefix, please refer to ISO/IS 10303-41 for the final definition of the formal standard.
/// 
/// ENUMERATION 
/// 
/// EXA: 10^18. 
///   PETA: 10^15. 
///   TERA: 10^12. 
///   GIGA: 10^9. 
///   MEGA: 10^6. 
///   KILO: 10^3. 
///   HECTO: 10^2.  
///   DECA: 10. 
///   DECI: 10^-1. 
///   CENTI: 10^-2. 
///   MILLI: 10^-3. 
///   MICRO: 10^-6. 
///   NANO: 10^-9. 
///   PICO: 10^-12. 
///   FEMTO: 10^-15. 
///   ATTO: 10^-18. 
/// 
/// HISTORY New entity in IFC Release 1.5.1.
typedef enum {IfcSIPrefix_EXA, IfcSIPrefix_PETA, IfcSIPrefix_TERA, IfcSIPrefix_GIGA, IfcSIPrefix_MEGA, IfcSIPrefix_KILO, IfcSIPrefix_HECTO, IfcSIPrefix_DECA, IfcSIPrefix_DECI, IfcSIPrefix_CENTI, IfcSIPrefix_MILLI, IfcSIPrefix_MICRO, IfcSIPrefix_NANO, IfcSIPrefix_PICO, IfcSIPrefix_FEMTO, IfcSIPrefix_ATTO} IfcSIPrefix;
const char* ToString(IfcSIPrefix v);
IfcSIPrefix FromString(const std::string& s);
}
namespace IfcSIUnitName {
/// Definition from ISO/CD 10303-41:1992: An SI unit name is the name of an SI unit. The definitions of the 
/// names of SI units are specified in ISO 1000 (clause 2).
/// 
/// NOTE Corresponding STEP name: SI_unit_name, please refer to ISO/IS 10303-41 for the final definition of the formal standard.
/// 
/// ENUMERATION 
/// 
/// AMPERE: Unit for electric current. 
///   BECQUEREL: Unit for radioactivity. 
///   CANDELA: Unit for luminousintensity. 
///   COULOMB: Unit for electric charge. 
///   CUBIC_METRE: Unit for volume. 
///   DEGREE_CELSIUS: Unit for thermodynamic temperature. 
///   FARAD: Unit for electric capacitance. 
///   GRAM: Unit for mass. 
///   GRAY: Unit for absorbed radioactive dose. 
///   HENRY: Unit for inductance. 
///   HERTZ: Unit for frequency. 
///   JOULE: Unit for energy. 
///   KELVIN: Unit for thermodynamic temperature. 
///   LUMEN: Unit for luminous flux. 
///   LUX: Unit for illuminance. 
///   METRE: Unit for length. 
///   MOLE: Unit for amount of substance. 
///   NEWTON: Unit for force. 
///   OHM: Unit for electric resistance. 
///   PASCAL: Unit for pressure. 
///   RADIAN: Unit for plane angle. 
///   SECOND: Unit for time. 
///   SIEMENS: Unit for electric conductance. 
///   SIEVERT: Unit for radioactive dose equivalent. 
///   SQUARE_METRE: Unit for area. 
///   STERADIAN: Unit for solid angle. 
///   TESLA: Unit for magnetic flux density. 
///   VOLT: Unit for electric voltage. 
///   WATT: Unit for power. 
///   WEBER: Unit for magnetic flux. 
/// 
/// HISTORY New entity in IFC Release 1.5.1.
typedef enum {IfcSIUnitName_AMPERE, IfcSIUnitName_BECQUEREL, IfcSIUnitName_CANDELA, IfcSIUnitName_COULOMB, IfcSIUnitName_CUBIC_METRE, IfcSIUnitName_DEGREE_CELSIUS, IfcSIUnitName_FARAD, IfcSIUnitName_GRAM, IfcSIUnitName_GRAY, IfcSIUnitName_HENRY, IfcSIUnitName_HERTZ, IfcSIUnitName_JOULE, IfcSIUnitName_KELVIN, IfcSIUnitName_LUMEN, IfcSIUnitName_LUX, IfcSIUnitName_METRE, IfcSIUnitName_MOLE, IfcSIUnitName_NEWTON, IfcSIUnitName_OHM, IfcSIUnitName_PASCAL, IfcSIUnitName_RADIAN, IfcSIUnitName_SECOND, IfcSIUnitName_SIEMENS, IfcSIUnitName_SIEVERT, IfcSIUnitName_SQUARE_METRE, IfcSIUnitName_STERADIAN, IfcSIUnitName_TESLA, IfcSIUnitName_VOLT, IfcSIUnitName_WATT, IfcSIUnitName_WEBER} IfcSIUnitName;
const char* ToString(IfcSIUnitName v);
IfcSIUnitName FromString(const std::string& s);
}
namespace IfcSanitaryTerminalTypeEnum {
/// The IfcSanitaryTerminalTypeEnum defines the range of different types of sanitary terminal that can be specified. 
/// 
/// NOTE: The value WCSEAT has been deprecated and should no longer be used; toilet seats should be represented by IfcDiscreteAccessory with ObjectType 'WC Seat'. 
///   HISTORY: New type in IFC 2x2 
/// 
/// Enumeration 
/// 
/// BATH: Sanitary appliance for immersion of the human body or parts of it. 
/// BIDET: Waste water appliance for washing the excretory organs while sitting astride the bowl. 
/// CISTERN: A water storage unit attached to a sanitary terminal that is fitted with a device, operated automatically or by the user, that discharges water to cleanse a water closet (toilet) pan, urinal or slop hopper. 
/// SHOWER: Installation or waste water appliance that emits a spray of water to wash the human body. 
/// SINK: Waste water appliance for receiving, retaining or disposing of domestic, culinary, laboratory or industrial process liquids. 
/// SANITARYFOUNTAIN: A sanitary terminal that provides a low pressure jet of water for a specific purpose. 
/// TOILETPAN: Soil appliance for the disposal of excrement. 
/// URINAL: Soil appliance that receives urine and directs it to a waste outlet (BS6100). 
/// WASHHANDBASIN: Waste water appliance for washing the upper parts of the body. 
/// WCSEAT: [Deprecated] Hinged seat that fits on the top of a water closet (WC) pan. 
/// USERDEFINED: User-defined type. 
/// NOTDEFINED: Undefined type.
typedef enum {IfcSanitaryTerminalType_BATH, IfcSanitaryTerminalType_BIDET, IfcSanitaryTerminalType_CISTERN, IfcSanitaryTerminalType_SHOWER, IfcSanitaryTerminalType_SINK, IfcSanitaryTerminalType_SANITARYFOUNTAIN, IfcSanitaryTerminalType_TOILETPAN, IfcSanitaryTerminalType_URINAL, IfcSanitaryTerminalType_WASHHANDBASIN, IfcSanitaryTerminalType_WCSEAT, IfcSanitaryTerminalType_USERDEFINED, IfcSanitaryTerminalType_NOTDEFINED} IfcSanitaryTerminalTypeEnum;
const char* ToString(IfcSanitaryTerminalTypeEnum v);
IfcSanitaryTerminalTypeEnum FromString(const std::string& s);
}
namespace IfcSectionTypeEnum {
/// Definition from IAI: An enumeration indicating whether a
///   specific piece of a cross section is uniform or tapered in longitudinal
///   direction.  
///   HISTORY New type in IFC
///   Release 2x2  
///   ENUMERATION 
/// 
/// UNIFORM The section is uniform in longitudinal direction.
/// 
/// TAPERED The section is tapered in longitudinal direction.
typedef enum {IfcSectionType_UNIFORM, IfcSectionType_TAPERED} IfcSectionTypeEnum;
const char* ToString(IfcSectionTypeEnum v);
IfcSectionTypeEnum FromString(const std::string& s);
}
namespace IfcSensorTypeEnum {
/// The IfcSensorTypeEnum defines the range of different types of sensor that can be specified. 
/// 
/// HISTORY: New type in IFC R2.0.  Added missing enumerations in IFC2x4
/// 
/// Enumeration 
/// 
/// CONDUCTANCESENSOR: A device that senses or detects electrical conductance. 
/// CONTACTSENSOR: A device that senses or detects contact, such as for detecting if a door is closed. 
/// FIRESENSOR: A device that senses or detects fire. 
/// FLOWSENSOR: A device that senses or detects flow in a fluid. 
/// GASSENSOR: A device that senses or detects gas concentration. 
/// HEATSENSOR: A device that senses or detects heat. 
/// IONCONCENTRATIONSENSOR: A device that senses or detects ion concentration, such as for water hardness. 
/// LEVELSENSOR: A device that senses or detects fill level, such as for a tank. 
/// HUMIDITYSENSOR: A device that senses or detects humidity. 
/// LIGHTSENSOR: A device that senses or detects light. 
/// MOISTURESENSOR: A device that senses or detects moisture. 
/// MOVEMENTSENSOR: A device that senses or detects movement.  
/// PHSENSOR: A device that senses or detects acidity. 
/// PRESSURESENSOR: A device that senses or detects pressure. 
/// RADIATIONSENSOR: A device that senses or detects electromagnetic radiation. 
/// RADIOACTIVITYSENSOR: A device that senses or detects atomic decay. 
/// SMOKESENSOR: A device that senses or detects smoke. 
/// SOUNDSENSOR: A device that senses or detects sound.  
/// TEMPERATURESENSOR: A device that senses or detects temperature. 
/// WINDSENSOR: A device that senses or detects airflow speed and direction. 
/// USERDEFINED: User-defined type. 
/// NOTDEFINED: Undefined type.
typedef enum {IfcSensorType_CO2SENSOR, IfcSensorType_FIRESENSOR, IfcSensorType_FLOWSENSOR, IfcSensorType_GASSENSOR, IfcSensorType_HEATSENSOR, IfcSensorType_HUMIDITYSENSOR, IfcSensorType_LIGHTSENSOR, IfcSensorType_MOISTURESENSOR, IfcSensorType_MOVEMENTSENSOR, IfcSensorType_PRESSURESENSOR, IfcSensorType_SMOKESENSOR, IfcSensorType_SOUNDSENSOR, IfcSensorType_TEMPERATURESENSOR, IfcSensorType_USERDEFINED, IfcSensorType_NOTDEFINED} IfcSensorTypeEnum;
const char* ToString(IfcSensorTypeEnum v);
IfcSensorTypeEnum FromString(const std::string& s);
}
namespace IfcSequenceEnum {
/// IfcSequenceEnum is an
///   enumeration that defines the different ways in which a
///   time lag is applied to a sequence between two processes.
/// 
/// HISTORY  New entity in IFC 1.0
typedef enum {IfcSequence_START_START, IfcSequence_START_FINISH, IfcSequence_FINISH_START, IfcSequence_FINISH_FINISH, IfcSequence_NOTDEFINED} IfcSequenceEnum;
const char* ToString(IfcSequenceEnum v);
IfcSequenceEnum FromString(const std::string& s);
}
namespace IfcServiceLifeFactorTypeEnum {

typedef enum {IfcServiceLifeFactorType_A_QUALITYOFCOMPONENTS, IfcServiceLifeFactorType_B_DESIGNLEVEL, IfcServiceLifeFactorType_C_WORKEXECUTIONLEVEL, IfcServiceLifeFactorType_D_INDOORENVIRONMENT, IfcServiceLifeFactorType_E_OUTDOORENVIRONMENT, IfcServiceLifeFactorType_F_INUSECONDITIONS, IfcServiceLifeFactorType_G_MAINTENANCELEVEL, IfcServiceLifeFactorType_USERDEFINED, IfcServiceLifeFactorType_NOTDEFINED} IfcServiceLifeFactorTypeEnum;
const char* ToString(IfcServiceLifeFactorTypeEnum v);
IfcServiceLifeFactorTypeEnum FromString(const std::string& s);
}
namespace IfcServiceLifeTypeEnum {

typedef enum {IfcServiceLifeType_ACTUALSERVICELIFE, IfcServiceLifeType_EXPECTEDSERVICELIFE, IfcServiceLifeType_OPTIMISTICREFERENCESERVICELIFE, IfcServiceLifeType_PESSIMISTICREFERENCESERVICELIFE, IfcServiceLifeType_REFERENCESERVICELIFE} IfcServiceLifeTypeEnum;
const char* ToString(IfcServiceLifeTypeEnum v);
IfcServiceLifeTypeEnum FromString(const std::string& s);
}
namespace IfcSlabTypeEnum {
/// Definition from IAI: This enumeration defines the
///   available predefined types of a slab. The
///   IfcSlabTypeEnum can be used for slab occurrences,
///   IfcSlab, and slab types, IfcSlabType. A
///   special property set definition may be provided for each
///   predefined type.
/// 
/// HISTORY  New type in IFC
///   Release 2.0
/// 
/// Floor
/// 
/// The slab is used to represent a floor slab.
/// 
/// Roof
/// 
/// The slab is used to represent a roof slab (either
///   flat or sloped).
/// 
/// Landing
/// 
/// The slab is used to represent a landing within a
///   stair or ramp.
/// 
/// BaseSlab
/// 
/// The slab is used to represent a floor slab against
///   the ground (and thereby being a part of the
///   foundation). Another name is mat foundation.
/// 
/// IFC2x3 CHANGE
///    new enumerator added.
typedef enum {IfcSlabType_FLOOR, IfcSlabType_ROOF, IfcSlabType_LANDING, IfcSlabType_BASESLAB, IfcSlabType_USERDEFINED, IfcSlabType_NOTDEFINED} IfcSlabTypeEnum;
const char* ToString(IfcSlabTypeEnum v);
IfcSlabTypeEnum FromString(const std::string& s);
}
namespace IfcSoundScaleEnum {

typedef enum {IfcSoundScale_DBA, IfcSoundScale_DBB, IfcSoundScale_DBC, IfcSoundScale_NC, IfcSoundScale_NR, IfcSoundScale_USERDEFINED, IfcSoundScale_NOTDEFINED} IfcSoundScaleEnum;
const char* ToString(IfcSoundScaleEnum v);
IfcSoundScaleEnum FromString(const std::string& s);
}
namespace IfcSpaceHeaterTypeEnum {
/// Enumeration defining the functional type of space heater.
/// 
/// The IfcSpaceHeaterTypeEnum contains the following:
/// 
/// CONVECTOR: A heat-distributing unit that operates with gravity-circulated air.
/// RADIATOR: A heat-distributing unit that operates with thermal radiation.
/// USERDEFINED: User-defined space heater type.
/// NOTDEFINED:  Undefined space heater type.
/// 
/// NOTE: This enumeration was revised in IFC 2x4 and was renamed from IfcHydronicHeaterTypeEnum in IFC R2x.
/// 
/// HISTORY: New enumeration in IFC R2x.
typedef enum {IfcSpaceHeaterType_SECTIONALRADIATOR, IfcSpaceHeaterType_PANELRADIATOR, IfcSpaceHeaterType_TUBULARRADIATOR, IfcSpaceHeaterType_CONVECTOR, IfcSpaceHeaterType_BASEBOARDHEATER, IfcSpaceHeaterType_FINNEDTUBEUNIT, IfcSpaceHeaterType_UNITHEATER, IfcSpaceHeaterType_USERDEFINED, IfcSpaceHeaterType_NOTDEFINED} IfcSpaceHeaterTypeEnum;
const char* ToString(IfcSpaceHeaterTypeEnum v);
IfcSpaceHeaterTypeEnum FromString(const std::string& s);
}
namespace IfcSpaceTypeEnum {
/// Definition from IAI: This enumeration defines the
/// available generic types for IfcSpace and
/// IfcSpaceType.
/// HISTORY New enumeration
/// in IFC2x3.
/// IFC2x4 CHANGE The enumerators
/// INTERNAL and EXTERNAL have been added for upward compatibility to
/// replace InteriorOrExteriorSpace
/// usage.
/// Enumeration
/// 
/// SPACE Any space not falling into another category.
/// 
/// NOTE For classification of spaces according to its
/// function that is often determined by national classification
/// systems use IfcClassificationReference via the
/// relationship IfcRelAssociatesClassification.
/// 
/// PARKING A space dedication for use as a parking spot
/// for vehicles, including access, such as a parking aisle
/// GFA Gross Floor Area - a specific kind of space for
/// each building story that includes all net area and construction
/// area (also the external envelop). Provision of such a specific
/// space is often required by regulations.
/// INTERNAL
/// 
/// NOTE the use is deprecated and
/// only provided for backward compatibility
/// purposes.
/// 
/// EXTERNAL
/// 
/// NOTE the use is deprecated and
/// only provided for backward compatibility
/// purposes.
typedef enum {IfcSpaceType_USERDEFINED, IfcSpaceType_NOTDEFINED} IfcSpaceTypeEnum;
const char* ToString(IfcSpaceTypeEnum v);
IfcSpaceTypeEnum FromString(const std::string& s);
}
namespace IfcStackTerminalTypeEnum {
/// An IfcStackTerminalTypeEnum defines the range of different types of stack terminal that can be specified for use at the top of a vertical stack subsystem. 
///   HISTORY: New type in IFC 2x  
///   Enumeration 
/// 
/// BIRDCAGE: Guard cage, typically wire mesh, at the top of the stack preventing access by birds. 
/// COWL: A cowling placed at the top of a stack to eliminate downdraft. 
/// RAINWATERHOPPER: A box placed at the top of a rainwater downpipe to catch rainwater from guttering. 
/// USERDEFINED: User-defined type. 
/// NOTDEFINED: Undefined type.
typedef enum {IfcStackTerminalType_BIRDCAGE, IfcStackTerminalType_COWL, IfcStackTerminalType_RAINWATERHOPPER, IfcStackTerminalType_USERDEFINED, IfcStackTerminalType_NOTDEFINED} IfcStackTerminalTypeEnum;
const char* ToString(IfcStackTerminalTypeEnum v);
IfcStackTerminalTypeEnum FromString(const std::string& s);
}
namespace IfcStairFlightTypeEnum {
/// Definition from IAI: This enumeration defines the different types
///   of stair flights an IfcStairFlightType object can fulfill: 
/// 
/// STRAIGHT: A stair flight with a straight walking line.  
///   WINDER: A stair flight with a straight walking line. 
///   SPIRAL: A stair flight with a circular or elliptic walking
///   line. 
///   CURVED: A stair flight with a curved walking line. 
///   FREEFORM: A stair flight with a free form walking line (and
///   outer boundaries). 
///   USERDEFINED: User-defined stair flight . 
///   NOTDEFINED: Undefined stair flight . 
/// 
/// HISTORY: New Enumeration in
///   Release IFC2x Edition 2.
typedef enum {IfcStairFlightType_STRAIGHT, IfcStairFlightType_WINDER, IfcStairFlightType_SPIRAL, IfcStairFlightType_CURVED, IfcStairFlightType_FREEFORM, IfcStairFlightType_USERDEFINED, IfcStairFlightType_NOTDEFINED} IfcStairFlightTypeEnum;
const char* ToString(IfcStairFlightTypeEnum v);
IfcStairFlightTypeEnum FromString(const std::string& s);
}
namespace IfcStairTypeEnum {
/// This enumeration defines the basic configuration of the stair type in terms of the number of stair flights and the number of landings, as illustrated in Figure 69. The type also distinguished turns by windings or by landings. In addition the subdivision of the straight and changing direction stairs is included. The stair configurations are given for stairs without and with one, two or three landings. 
/// 
/// Stairs which are subdivided into more than three landings have to be defined by the geometry only. Also stairs with non-regular shapes have to be defined by the geometry only. The type of such stairs is OTHEROPERATION. 
/// 
/// HISTORY New Enumeration in IFC Release 2.0. 
/// 
/// Enumerator 
///   Description 
///   Figure 
/// 
/// StraightRunStair 
///   A stair extending from
///   one level to another without turns or winders. The stair consists of one
///   straight flight. 
/// 
/// TwoStraightRunStair 
///   A straight stair
///   consisting of two straight flights without turns but with one landing. 
/// 
/// QuarterWindingStair 
///   A stair consisting of one
///   flight with a quarter winder, which is making a 90° turn. The direction of
///   the turn is determined by the walking line. 
/// 
/// QuarterTurnStair 
///   A stair making a 90°
///   turn, consisting of two straight flights connected by a quarterspace landing.
///   The direction of the turn is determined by the walking line. 
/// 
/// HalfWindingStair 
///   A stair consisting of one
///   flight with one half winder, which makes a 180° turn. The orientation of
///   the turn is determined by the walking line. 
/// 
/// HalfTurnStair 
///   A stair making a 180°
///   turn, consisting of two straight flights connected by a halfspace landing. The
///   orientation of the turn is determined by the walking line. 
/// 
/// TwoQuarterWindingStair 
///   A stair consisting of one
///   flight with two quarter winders, which make a 90° turn. The stair makes a
///   180° turn. The direction of the turns is determined by the walking
///   line. 
/// 
/// TwoQuarterTurnStair 
///   A stair making a 180°
///   turn, consisting of three straight flights connected by two quarterspace
///   landings. The direction of the turns is determined by the walking line. 
/// 
/// ThreeQuarterWindingStair
/// 
/// A stair consisting of one
///   flight with three quarter winders, which make a 90° turn. The stair makes a
///   270° turn. The direction of the turns is determined by the walking
///   line. 
/// 
/// ThreeQuarterTurnStair 
///   A stair making a 270°
///   turn, consisting of four straight flights connected by three quarterspace
///   landings. The direction of the turns is determined by the walking line. 
/// 
/// SpiralStair 
///   A stair constructed with
///   winders around a circular newel often without landings. Depending on outer
///   boundary it can be either a circular, elliptical or rectangular spiral stair.
///   The orientation of the winding stairs is determined by the walking line. 
/// 
/// DoubleReturnStair 
///   A stair having one
///   straight flight to a wide quarterspace landing, and two side flights from that
///   landing into opposite directions. The stair is making a 90° turn. The
///   direction of traffic is determined by the walking line. 
/// 
/// CurvedRunStair 
///   A stair extending from one
///   level to another without turns or winders. The stair is consisting of one
///   curved flight. 
/// 
/// TwoCurvedRunStair 
///   A curved stair consisting of
///   two curved flights without turns but with one landing. 
/// 
/// OtherOperation 
///   Free form stair (user defined
///   operation type) 
///     
/// 
/// NotDefined 
///     
///     
/// 
/// Figure 69 — Stair types
typedef enum {IfcStairType_STRAIGHT_RUN_STAIR, IfcStairType_TWO_STRAIGHT_RUN_STAIR, IfcStairType_QUARTER_WINDING_STAIR, IfcStairType_QUARTER_TURN_STAIR, IfcStairType_HALF_WINDING_STAIR, IfcStairType_HALF_TURN_STAIR, IfcStairType_TWO_QUARTER_WINDING_STAIR, IfcStairType_TWO_QUARTER_TURN_STAIR, IfcStairType_THREE_QUARTER_WINDING_STAIR, IfcStairType_THREE_QUARTER_TURN_STAIR, IfcStairType_SPIRAL_STAIR, IfcStairType_DOUBLE_RETURN_STAIR, IfcStairType_CURVED_RUN_STAIR, IfcStairType_TWO_CURVED_RUN_STAIR, IfcStairType_USERDEFINED, IfcStairType_NOTDEFINED} IfcStairTypeEnum;
const char* ToString(IfcStairTypeEnum v);
IfcStairTypeEnum FromString(const std::string& s);
}
namespace IfcStateEnum {
/// The IfcStateEnum enumeration identifies the state or accessibility of the object (for example, read/write, locked).
/// 
/// Valid enumerations are:
/// 
/// READWRITE: Object is in a Read-Write state. It may be modified by an application.
/// READONLY: Object is in a Read-Only state. It may be viewed but not modified by an application.
/// LOCKED: Object is in a Locked state. It may not be accessed by an application.
/// READWRITELOCKED: Object is in a Read-Write-Locked state. It may not be accessed by an application.
/// READONLYLOCKED: Object is in a Read-Only-Locked state. It may not be accessed by an application.
/// 
/// HISTORY  New enumeration in IFC R2.0.
/// 
/// IFC2x3 CHANGE  This concept was initially introduced in IFC 2.0 as IfcModifiedFlag of type BINARY(3) FIXED and has been modified in R2x to an enumeration. It was initially introduced as a first step towards providing facilities for partial model exchange from a server as requested by the IFC implementers. It is intended for use primarily by a model server so that an application can identify the state of the object.
typedef enum {IfcState_READWRITE, IfcState_READONLY, IfcState_LOCKED, IfcState_READWRITELOCKED, IfcState_READONLYLOCKED} IfcStateEnum;
const char* ToString(IfcStateEnum v);
IfcStateEnum FromString(const std::string& s);
}
namespace IfcStructuralCurveTypeEnum {

typedef enum {IfcStructuralCurveType_RIGID_JOINED_MEMBER, IfcStructuralCurveType_PIN_JOINED_MEMBER, IfcStructuralCurveType_CABLE, IfcStructuralCurveType_TENSION_MEMBER, IfcStructuralCurveType_COMPRESSION_MEMBER, IfcStructuralCurveType_USERDEFINED, IfcStructuralCurveType_NOTDEFINED} IfcStructuralCurveTypeEnum;
const char* ToString(IfcStructuralCurveTypeEnum v);
IfcStructuralCurveTypeEnum FromString(const std::string& s);
}
namespace IfcStructuralSurfaceTypeEnum {

typedef enum {IfcStructuralSurfaceType_BENDING_ELEMENT, IfcStructuralSurfaceType_MEMBRANE_ELEMENT, IfcStructuralSurfaceType_SHELL, IfcStructuralSurfaceType_USERDEFINED, IfcStructuralSurfaceType_NOTDEFINED} IfcStructuralSurfaceTypeEnum;
const char* ToString(IfcStructuralSurfaceTypeEnum v);
IfcStructuralSurfaceTypeEnum FromString(const std::string& s);
}
namespace IfcSurfaceSide {
/// IfcSurfaceSide is a denotion of whether negative, positive or both sides of a surface are being referenced. 
/// 
/// ENUMERATION Definition from ISO/CD 10303-46:1992: 
/// 
/// POSITIVE: The side of a surface which is in the same direction as the surface normal derived from the mathematical definition.  
/// NEGATIVE: The side of a surface which is in the opposite direction than the surface normal derived from the mathematical definition. 
/// BOTH: Both, positive and negative side. 
/// 
/// NOTE Corresponding ISO 10303 type: surface_side. Please refer to ISO/IS 10303-46:1994 for the final definition of the formal standard.
/// 
/// HISTORY: New Enumeration in IFC 2.0
typedef enum {IfcSurfaceSide_POSITIVE, IfcSurfaceSide_NEGATIVE, IfcSurfaceSide_BOTH} IfcSurfaceSide;
const char* ToString(IfcSurfaceSide v);
IfcSurfaceSide FromString(const std::string& s);
}
namespace IfcSurfaceTextureEnum {

typedef enum {IfcSurfaceTexture_BUMP, IfcSurfaceTexture_OPACITY, IfcSurfaceTexture_REFLECTION, IfcSurfaceTexture_SELFILLUMINATION, IfcSurfaceTexture_SHININESS, IfcSurfaceTexture_SPECULAR, IfcSurfaceTexture_TEXTURE, IfcSurfaceTexture_TRANSPARENCYMAP, IfcSurfaceTexture_NOTDEFINED} IfcSurfaceTextureEnum;
const char* ToString(IfcSurfaceTextureEnum v);
IfcSurfaceTextureEnum FromString(const std::string& s);
}
namespace IfcSwitchingDeviceTypeEnum {
/// The IfcSwitchingDeviceTypeEnum defines the range of different types of switch that can be specified. 
///   HISTORY: New type in IFC 2x2 
///   Enumeration 
/// 
/// CONTACTOR: An electrical device used to control the flow of power in a circuit on or off. 
/// DIMMERSWITCH: A dimmer switch has variable positions, and may adjust electrical power or other setting (according to the switched port type). 
/// EMERGENCYSTOP: An emergency stop device acts to remove as quickly as possible any danger that may have arisen unexpectedly. 
/// KEYPAD: A set of buttons or switches, each potentially applicable to a different device.  
/// MOMENTARYSWITCH: A momentary switch has no position, and may trigger some action to occur.  
/// SELECTORSWITCH: A selector switch has multiple positions, and may switch connectivity or other setting.  
/// STARTER: A starter is a switch which in the closed position controls the application of power to an electrical device. 
/// SWITCHDISCONNECTOR: A switch disconnector is a switch which in the open position satisfies the isolating requirements specified for a disconnector. 
/// SELECTORSWITCH: A selector switch has multiple positions, and may change the source or level of power or other setting (according to the switched port type). 
/// TOGGLESWITCH: A toggle switch has two positions, and may enable or isolate electrical power or other setting (according to the switched port type). 
/// USERDEFINED: User-defined type. 
/// NOTDEFINED: Undefined type.
typedef enum {IfcSwitchingDeviceType_CONTACTOR, IfcSwitchingDeviceType_EMERGENCYSTOP, IfcSwitchingDeviceType_STARTER, IfcSwitchingDeviceType_SWITCHDISCONNECTOR, IfcSwitchingDeviceType_TOGGLESWITCH, IfcSwitchingDeviceType_USERDEFINED, IfcSwitchingDeviceType_NOTDEFINED} IfcSwitchingDeviceTypeEnum;
const char* ToString(IfcSwitchingDeviceTypeEnum v);
IfcSwitchingDeviceTypeEnum FromString(const std::string& s);
}
namespace IfcTankTypeEnum {
/// Enumeration defining the typical types of tanks.
/// 
/// The IfcTankTypeEnum contains the following:
/// 
/// BASIN:  An arbitrary open tank type.
/// 
/// BREAKPRESSURE:  An open container that breaks the hydraulic pressure in a distribution system, typically located between the fluid reservoir and the fluid supply points. A typical break pressure tank allows the flow to discharge into the atmosphere, thereby reducing its hydrostatic pressure to zero.
/// 
/// EXPANSION:  A closed container used in a closed fluid distribution system to mitigate the effects of thermal expansion or water hammer. The tank is typically constructed with a diaphragm dividing the tank into two sections, with fluid on one side of the diaphragm and air on the other. One example application is when connected to the primary circuit of a hot water system to accommodate the increase in volume of the water when it is heated.
/// 
/// FEEDANDEXPANSION:  An open tank that is used for both storage and thermal expansion. A typical example is a tank used to store make-up water at ambient pressure for supply to a hot water system, simultaneously accommodating increases in volume of the water when heated.
/// 
/// PRESSUREVESSEL:  A closed container used for storing fluids or gases at a pressure different from the ambient pressure. A pressure vessel is typically rated by an authority having jurisdiction for the operational pressure.
/// 
/// STORAGE:  An open or closed containter used for storing a fluid at ambient pressure and from which it can be supplied to the fluid distribution system. There are many examples of storage tanks, such as potable water storage tanks, fuel storage tanks, etc.
/// 
/// VESSEL:  An arbitrary closed tank type.
/// 
/// USERDEFINED:  User-defined tank type.
/// 
/// NOTDEFINED:  Undefined tank type.
/// 
/// HISTORY: New enumeration in IFC 2x2.  BASIN and VESSEL added in IFC2x4.
typedef enum {IfcTankType_PREFORMED, IfcTankType_SECTIONAL, IfcTankType_EXPANSION, IfcTankType_PRESSUREVESSEL, IfcTankType_USERDEFINED, IfcTankType_NOTDEFINED} IfcTankTypeEnum;
const char* ToString(IfcTankTypeEnum v);
IfcTankTypeEnum FromString(const std::string& s);
}
namespace IfcTendonTypeEnum {

typedef enum {IfcTendonType_STRAND, IfcTendonType_WIRE, IfcTendonType_BAR, IfcTendonType_COATED, IfcTendonType_USERDEFINED, IfcTendonType_NOTDEFINED} IfcTendonTypeEnum;
const char* ToString(IfcTendonTypeEnum v);
IfcTendonTypeEnum FromString(const std::string& s);
}
namespace IfcTextPath {
/// The text path determines the direction of the text characters in respect to each other.
/// 
/// NOTE: The IfcTextPath is an entity that had been adopted from ISO 10303, Industrial automation systems and integration&#151;Product data representation and exchange, Part 46: Integrated generic resources: Visual presentation.
/// 
/// NOTE Corresponding ISO 10303 name:text_path . Please refer to ISO/IS 10303-46:1994 for the final definition of the formal standard.
/// 
/// HISTORY New entity in IFC2x2.
typedef enum {IfcTextPath_LEFT, IfcTextPath_RIGHT, IfcTextPath_UP, IfcTextPath_DOWN} IfcTextPath;
const char* ToString(IfcTextPath v);
IfcTextPath FromString(const std::string& s);
}
namespace IfcThermalLoadSourceEnum {

typedef enum {IfcThermalLoadSource_PEOPLE, IfcThermalLoadSource_LIGHTING, IfcThermalLoadSource_EQUIPMENT, IfcThermalLoadSource_VENTILATIONINDOORAIR, IfcThermalLoadSource_VENTILATIONOUTSIDEAIR, IfcThermalLoadSource_RECIRCULATEDAIR, IfcThermalLoadSource_EXHAUSTAIR, IfcThermalLoadSource_AIREXCHANGERATE, IfcThermalLoadSource_DRYBULBTEMPERATURE, IfcThermalLoadSource_RELATIVEHUMIDITY, IfcThermalLoadSource_INFILTRATION, IfcThermalLoadSource_USERDEFINED, IfcThermalLoadSource_NOTDEFINED} IfcThermalLoadSourceEnum;
const char* ToString(IfcThermalLoadSourceEnum v);
IfcThermalLoadSourceEnum FromString(const std::string& s);
}
namespace IfcThermalLoadTypeEnum {

typedef enum {IfcThermalLoadType_SENSIBLE, IfcThermalLoadType_LATENT, IfcThermalLoadType_RADIANT, IfcThermalLoadType_NOTDEFINED} IfcThermalLoadTypeEnum;
const char* ToString(IfcThermalLoadTypeEnum v);
IfcThermalLoadTypeEnum FromString(const std::string& s);
}
namespace IfcTimeSeriesDataTypeEnum {
/// IfcTimeSeriesDataTypeEnum describes a type of time series data and is used to determine a value during the time series which is not explicitly specified: 
/// 
/// CONTINUOUS: The time series data is continuous. 
///   DISCRETE: The time series data is discrete. 
///   DISCRETEBINARY: The time series data is discrete binary. 
///   PIECEWISEBINARY: The time series data is piecewise binary. 
///   PIECEWISECONSTANT: The time series data is piecewise constant. 
///   PIECEWISECONTINUOUS: The time series data is piecewise continuous. 
///   NOTDEFINED: The time series data is not defined. 
/// 
/// HISTORY: New enumeration in IFC2x2.
typedef enum {IfcTimeSeriesDataType_CONTINUOUS, IfcTimeSeriesDataType_DISCRETE, IfcTimeSeriesDataType_DISCRETEBINARY, IfcTimeSeriesDataType_PIECEWISEBINARY, IfcTimeSeriesDataType_PIECEWISECONSTANT, IfcTimeSeriesDataType_PIECEWISECONTINUOUS, IfcTimeSeriesDataType_NOTDEFINED} IfcTimeSeriesDataTypeEnum;
const char* ToString(IfcTimeSeriesDataTypeEnum v);
IfcTimeSeriesDataTypeEnum FromString(const std::string& s);
}
namespace IfcTimeSeriesScheduleTypeEnum {

typedef enum {IfcTimeSeriesScheduleType_ANNUAL, IfcTimeSeriesScheduleType_MONTHLY, IfcTimeSeriesScheduleType_WEEKLY, IfcTimeSeriesScheduleType_DAILY, IfcTimeSeriesScheduleType_USERDEFINED, IfcTimeSeriesScheduleType_NOTDEFINED} IfcTimeSeriesScheduleTypeEnum;
const char* ToString(IfcTimeSeriesScheduleTypeEnum v);
IfcTimeSeriesScheduleTypeEnum FromString(const std::string& s);
}
namespace IfcTransformerTypeEnum {
/// The IfcTransformerTypeEnum defines the range of different types of transformer that can be specified. 
///   HISTORY: New type in IFC 2x2 
///   Enumeration 
/// 
/// CURRENT: A transformer that changes the current between circuits. 
/// FREQUENCY: A transformer that changes the frequency between circuits. 
/// INVERTER: A transformer that converts from direct current (DC) to alternating current (AC). 
/// RECTIFIER: A transformer that converts from alternating current (AC) to direct current (DC).  
/// VOLTAGE: A transformer that changes the voltage between circuits.  
/// USERDEFINED: User-defined type. 
/// NOTDEFINED: Undefined type.
typedef enum {IfcTransformerType_CURRENT, IfcTransformerType_FREQUENCY, IfcTransformerType_VOLTAGE, IfcTransformerType_USERDEFINED, IfcTransformerType_NOTDEFINED} IfcTransformerTypeEnum;
const char* ToString(IfcTransformerTypeEnum v);
IfcTransformerTypeEnum FromString(const std::string& s);
}
namespace IfcTransitionCode {
/// Definition from ISO/CD 10303-42:1992: This type conveys the continuity properties of a composite curve or surface. The continuity referred to is geometric, not parametric continuity. For example, in ContSameGradient the tangent vectors of successive segments will have the same direction, but may have different magnitude.  
/// 
/// NOTE  Corresponding ISO 10303 type: transition_code, please refer to ISO/IS 10303-42:1994, p. 14 for the final definition of the formal standard.
/// 
/// HISTORY  New Type in IFC Release 1.0
/// 
/// Figure 273 (quoted from ISO/CD 10303-42:1992, p.55) illustrates transition types.
/// 
/// Figure 273 — Transition code
/// 
/// ENUMERATION 
/// 
/// DISCONTINUOUS: The segments do not join. This is permitted only at the boundary of the curve or surface to indicate that it is not closed.
/// CONTINUOUS: The segments join but no condition on their tangents is implied. 
/// CONTSAMEGRADIENT: The segments join and their tangent vectors or tangent planes are parallel and have the same direction at the joint: equality of derivatives is not required. 
/// CONTSAMEGRADIENTSAMECURVATURE: For a curve, the segments join, their tangent vectors are parallel and in the same direction and their curvatures are equal at the joint: equality of derivatives is not required. For a surface this implies that the principle curvatures are the same and the principle directions are coincident along the common boundary.
typedef enum {IfcTransitionCode_DISCONTINUOUS, IfcTransitionCode_CONTINUOUS, IfcTransitionCode_CONTSAMEGRADIENT, IfcTransitionCode_CONTSAMEGRADIENTSAMECURVATURE} IfcTransitionCode;
const char* ToString(IfcTransitionCode v);
IfcTransitionCode FromString(const std::string& s);
}
namespace IfcTransportElementTypeEnum {
/// Definition from IAI: This enumeration is used to
/// identify primary transport element types. The
/// IfcTransportElementTypeEnum contains the following:
/// 
/// ELEVATOR: Elevator or lift being a transport device to
/// move people of good vertically.
/// ESCALATOR: Escalator being a transport device to move
/// people. It consists of individual linked steps that move up and
/// down on tracks while keeping the threads horizontal.
/// MOVINGWALKWAY: Moving walkway being a transport device
/// to move people horizontally or on an incline. It is a slow
/// conveyor belt that transports people.
/// CRANEWAY: A crane way system, normally including the
/// crane rails, fasteners and the crane. It is primarily used to
/// move heavy goods in a factory or other industry buildings.
/// LIFTINGGEAR: A device used for lifting or lowering
/// heavy goods. It may be manually operated or electrically or
/// pneumatically driven.
/// 
/// HISTORY  New enumeration
/// in IFC Release 2x.
/// IFC2x4 CHANGE  New enumerators
/// CRANEWAY and LIFTINGGEAR added in
/// IFC2x4.
typedef enum {IfcTransportElementType_ELEVATOR, IfcTransportElementType_ESCALATOR, IfcTransportElementType_MOVINGWALKWAY, IfcTransportElementType_USERDEFINED, IfcTransportElementType_NOTDEFINED} IfcTransportElementTypeEnum;
const char* ToString(IfcTransportElementTypeEnum v);
IfcTransportElementTypeEnum FromString(const std::string& s);
}
namespace IfcTrimmingPreference {
/// Definition from ISO/CD 10303-42:1992: This type is used to describe the preferred way of trimming a parametric curve where the trimming is multiply defined. 
/// 
/// NOTE Corresponding ISO 10303 type: trimming_preference, please refer to ISO/IS 10303-42:1994, p. 18 for the final definition of the formal standard.
/// 
/// HISTORY New Type in IFC Release 1.0
/// 
/// ENUMERATION 
/// 
/// CARTESIAN: Indicates that trimming by Cartesian point is preferred. 
/// PARAMETER: Indicates the preference for the parameter value. 
/// UNSPECIFIED: Indicates that no preference is communicated.
typedef enum {IfcTrimmingPreference_CARTESIAN, IfcTrimmingPreference_PARAMETER, IfcTrimmingPreference_UNSPECIFIED} IfcTrimmingPreference;
const char* ToString(IfcTrimmingPreference v);
IfcTrimmingPreference FromString(const std::string& s);
}
namespace IfcTubeBundleTypeEnum {
/// Enumeration defining the typical types of tube bundles. 
///   The IfcTubeBundleTypeEnum contains the following:
/// 
/// FINNED:  Finned tube bundle type.
///   USERDEFINED:  User-defined tube bundle type.
///   NOTDEFINED:  Undefined tube bundle type.
/// 
/// HISTORY: New enumeration in IFC 2x2.
typedef enum {IfcTubeBundleType_FINNED, IfcTubeBundleType_USERDEFINED, IfcTubeBundleType_NOTDEFINED} IfcTubeBundleTypeEnum;
const char* ToString(IfcTubeBundleTypeEnum v);
IfcTubeBundleTypeEnum FromString(const std::string& s);
}
namespace IfcUnitEnum {
/// IfcUnitEnum is an enumeration type for allowed unit types of IfcNamedUnit.
/// 
/// ENUMERATION 
/// 
/// ABSORBEDDOSEUNIT
///   AMOUNTOFSUBSTANCEUNIT
///   AREAUNIT
///   DOSEEQUIVALENTUNIT
///   ELECTRICCAPACITANCEUNIT
///   ELECTRICCHARGEUNIT
///   ELECTRICCONDUCTANCEUNIT
///   ELECTRICCURRENTUNIT
///   ELECTRICRESISTANCEUNIT
///   ELECTRICVOLTAGEUNIT
///   ENERGYUNIT
///   FORCEUNIT
///   FREQUENCYUNIT
///   ILLUMINANCEUNIT
///   INDUCTANCEUNIT
///   LENGTHUNIT
///   LUMINOUSFLUXUNIT
///   LUMINOUSINTENSITYUNIT
///   MAGNETICFLUXDENSITYUNIT
///   MAGNETICFLUXUNIT
///   MASSUNIT
///   PLANEANGLEUNIT
///   POWERUNIT
///   PRESSUREUNIT
///   RADIOACTIVITYUNIT
///   SOLIDANGLEUNIT
///   THERMODYNAMICTEMPERATUREUNIT
///   TIMEUNIT
///   VOLUMEUNIT
///   USERDEFINED: User defined unit type. The type of unit is only implied by its name or the usage context.
/// 
/// HISTORY New type in IFC Release 1.5.1.
typedef enum {IfcUnit_ABSORBEDDOSEUNIT, IfcUnit_AMOUNTOFSUBSTANCEUNIT, IfcUnit_AREAUNIT, IfcUnit_DOSEEQUIVALENTUNIT, IfcUnit_ELECTRICCAPACITANCEUNIT, IfcUnit_ELECTRICCHARGEUNIT, IfcUnit_ELECTRICCONDUCTANCEUNIT, IfcUnit_ELECTRICCURRENTUNIT, IfcUnit_ELECTRICRESISTANCEUNIT, IfcUnit_ELECTRICVOLTAGEUNIT, IfcUnit_ENERGYUNIT, IfcUnit_FORCEUNIT, IfcUnit_FREQUENCYUNIT, IfcUnit_ILLUMINANCEUNIT, IfcUnit_INDUCTANCEUNIT, IfcUnit_LENGTHUNIT, IfcUnit_LUMINOUSFLUXUNIT, IfcUnit_LUMINOUSINTENSITYUNIT, IfcUnit_MAGNETICFLUXDENSITYUNIT, IfcUnit_MAGNETICFLUXUNIT, IfcUnit_MASSUNIT, IfcUnit_PLANEANGLEUNIT, IfcUnit_POWERUNIT, IfcUnit_PRESSUREUNIT, IfcUnit_RADIOACTIVITYUNIT, IfcUnit_SOLIDANGLEUNIT, IfcUnit_THERMODYNAMICTEMPERATUREUNIT, IfcUnit_TIMEUNIT, IfcUnit_VOLUMEUNIT, IfcUnit_USERDEFINED} IfcUnitEnum;
const char* ToString(IfcUnitEnum v);
IfcUnitEnum FromString(const std::string& s);
}
namespace IfcUnitaryEquipmentTypeEnum {
/// Enumeration defining the functional type of unitary equipment. 
///   The IfcUnitaryEquipmentTypeEnum contains the following:
/// 
/// AIRHANDLER: A unitary air handling unit typically containing a fan, economizer, and coils.
///   AIRCONDITIONINGUNIT: A unitary packaged air-conditioning unit typically used in residential or light commercial applications.
///   DEHUMIDIFIER: A unitary packaged dehumidification unit.  Note: units supporting multiple modes (dehumidification, cooling, and/or heating) should use AIRCONDITIONINGUNIT.
///   SPLITSYSTEM: A system which separates the compressor from the evaporator, but acts as a unitary component typically within residential or light commercial applications.
///   ROOFTOPUNIT: A packaged assembly that is either field-erected or manufactured atop the roof of a large residential or commercial building and acts as a unitary component.
///   USERDEFINED: User-defined unitary equipment type.
///   NOTDEFINED:  Undefined unitary equipment type.
/// 
/// HISTORY: New enumeration in IFC R2x.  DEHUMIDIFIER added in IFC 2x4
typedef enum {IfcUnitaryEquipmentType_AIRHANDLER, IfcUnitaryEquipmentType_AIRCONDITIONINGUNIT, IfcUnitaryEquipmentType_SPLITSYSTEM, IfcUnitaryEquipmentType_ROOFTOPUNIT, IfcUnitaryEquipmentType_USERDEFINED, IfcUnitaryEquipmentType_NOTDEFINED} IfcUnitaryEquipmentTypeEnum;
const char* ToString(IfcUnitaryEquipmentTypeEnum v);
IfcUnitaryEquipmentTypeEnum FromString(const std::string& s);
}
namespace IfcValveTypeEnum {
/// The IfcValveTypeEnum defines the
///   range of different types of valve that can be specified. These are typically
///   used in conjunction with Pset_ValveTypeCommon, which contains common
///   properties for all valve types. The IfcValveTypeEnum contains:
/// 
/// AIRRELEASE: Valve used to release air from a pipe or fitting.  
///   ANTIVACUUM: Valve that opens to admit air if the pressure falls below
///   atmospheric pressure (BS6100 330 4104) 
///   CHANGEOVER: Valve that enables flow to be switched between pipelines (3 or 4
///   port). 
///   CHECK: Valve that permits water to flow in one direction only and is
///   enclosed when there is no flow (2 port). 
///   COMMISSIONING: Valve used to facilitate commissioning of a system (2 port). 
///   DIVERTING: Valve that enables flow to be diverted from one branch of a
///   pipeline to another (3 port). 
///   DOUBLECHECK: An assembly that incorporates two valves used to prevent backflow
///   (BS6100 330 4106). 
///   DOUBLEREGULATING: Valve used to facilitate regulation of fluid flow in a system.
///   DRAWOFFCOCK: A valve used to remove fluid from a piping system.
///   FAUCET: Faucet valve typically used as a flow discharge.
///   FLUSHING: Valve that flushes a predetermined quantity of water to cleanse a
///   toilet, urinal, etc.
///   GASCOCK: Valve that is used for controlling the flow of gas. 
///   GASTAP: Gas tap typically used for venting or discharging gas from a system.
///   ISOLATING: Valve that closes off flow in a pipeline. 
///   MIXING: Valve that enables flow from two branches of a pipeline to be mixed
///   together (3 port). 
///   PRESSUREREDUCING: Valve that reduces the pressure of a fluid immediately downstream
///   of its position in a pipeline to a preselected value or by a predetermined
///   ratio. 
///   PRESSURERELIEF: Spring or weight loaded valve that automatically discharges to a
///   safe place fluid that has built up to excessive pressure in pipes or
///   fittings 
///   REGULATING: Valve used to facilitate regulation of fluid flow in a system.
///   SAFETYCUTOFF: Valve that closes under the action of a safety mechanism such as a
///   drop weight, solenoid etc. 
///   STEAMTRAP: Valve that restricts flow of steam while allowing condensate to 
///   pass through. 
///   STOPCOCK: An isolating valve used on a domestic water service. 
///   USERDEFINED: User-defined valve type. 
///   NOTDEFINED: Undefined valve type. 
/// 
/// HISTORY: New type in IFC R2.0
typedef enum {IfcValveType_AIRRELEASE, IfcValveType_ANTIVACUUM, IfcValveType_CHANGEOVER, IfcValveType_CHECK, IfcValveType_COMMISSIONING, IfcValveType_DIVERTING, IfcValveType_DRAWOFFCOCK, IfcValveType_DOUBLECHECK, IfcValveType_DOUBLEREGULATING, IfcValveType_FAUCET, IfcValveType_FLUSHING, IfcValveType_GASCOCK, IfcValveType_GASTAP, IfcValveType_ISOLATING, IfcValveType_MIXING, IfcValveType_PRESSUREREDUCING, IfcValveType_PRESSURERELIEF, IfcValveType_REGULATING, IfcValveType_SAFETYCUTOFF, IfcValveType_STEAMTRAP, IfcValveType_STOPCOCK, IfcValveType_USERDEFINED, IfcValveType_NOTDEFINED} IfcValveTypeEnum;
const char* ToString(IfcValveTypeEnum v);
IfcValveTypeEnum FromString(const std::string& s);
}
namespace IfcVibrationIsolatorTypeEnum {
/// Enumeration defining the typical types of vibration isolators. 
///   The IfcVibrationIsolatorTypeEnum contains the following:
/// 
/// COMPRESSION:  Compression type vibration isolator.
///   SPRING:  Spring type vibration isolator.
///   USERDEFINED:  User-defined vibration isolator type.
///   NOTDEFINED:  Undefined vibration isolator type.
/// 
/// HISTORY: New enumeration in IFC 2x2.
typedef enum {IfcVibrationIsolatorType_COMPRESSION, IfcVibrationIsolatorType_SPRING, IfcVibrationIsolatorType_USERDEFINED, IfcVibrationIsolatorType_NOTDEFINED} IfcVibrationIsolatorTypeEnum;
const char* ToString(IfcVibrationIsolatorTypeEnum v);
IfcVibrationIsolatorTypeEnum FromString(const std::string& s);
}
namespace IfcWallTypeEnum {
/// Definition from IAI: This enumeration defines the
/// different types of walls an IfcWallType object can
/// fulfill:
/// 
/// STANDARD: A standard wall, extruded vertically with a
/// constant thickness along the wall path.
/// POLYGONAL: A polygonal wall, extruded vertically,
/// where the wall thickness varies along the wall path.
/// SHEAR: A wall having a non-rectangular cross section
/// along the wall path.
/// 
/// NOTE The potentially misleading term shall not impose
/// a particular resistance against shear forces, but a particular
/// shape.
/// 
/// ELEMENTEDWALL: A stud wall framed with studs and faced
/// with sheatings, sidings, wallboard, or plasterwork.
/// PLUMBINGWALL: A pier, or enclosure, or encasement,
/// normally used to enclose plumbing in sanitary rooms.
/// MOVABLE: A movable wall that is either movable, e.g. a
/// folding wall, or a sliding wall, or can be easily removed as a
/// removable partitioning or mounting wall. Movable walls do
/// normally not define space boundaries and often belong to the
/// furnishing system.
/// USERDEFINED: User-defined wall element.
/// NOTDEFINED: Undefined wall element
/// 
/// HISTORY  New
/// Enumeration in Release IFC2x Edition 2.
/// IFC2x2 ADDENDUM CHANGE 
/// The enumerator POLYGON has been changed to
/// POLYGONAL.
/// IFC2x3 CHANGE  The enumerators
/// ELEMENTEDWALL and PLUMBINGWALL have been
/// added.
/// IFC2x4 CHANGE  New enumerator
/// MOVABLE has been added.
typedef enum {IfcWallType_STANDARD, IfcWallType_POLYGONAL, IfcWallType_SHEAR, IfcWallType_ELEMENTEDWALL, IfcWallType_PLUMBINGWALL, IfcWallType_USERDEFINED, IfcWallType_NOTDEFINED} IfcWallTypeEnum;
const char* ToString(IfcWallTypeEnum v);
IfcWallTypeEnum FromString(const std::string& s);
}
namespace IfcWasteTerminalTypeEnum {
/// The IfcWasteTerminalTypeEnum defines the range of different types of waste terminal that can be specified. 
///   HISTORY: New type in IFC 2x2.  GREASEINTERCEPTOR, OILINTERCEPTOR, PETROLINTERCEPTOR moved to IfcInterceptorTypeEnum in IFC2x4.
/// 
/// Enumeration 	 
/// 
/// FLOORTRAP: Pipe fitting, set into the floor, that retains liquid to prevent the passage of foul air 
/// FLOOORWASTE: Pipe fitting, set into the floor, that collects waste water and discharges it to a separate trap. 
/// GULLYSUMP: Pipe fitting or assembly of fittings to receive surface water or waste water, fitted with a grating or sealed cover. 
/// GULLYTRAP: Pipe fitting or assembly of fittings to receive surface water or waste water, fitted with a grating or sealed cover and discharging through a trap (BS6100 330 3504 modified). 
/// ROOFDRAIN: Pipe fitting, set into the roof, that collects rainwater for discharge into the rainwater system.  
/// WASTEDISPOSALUNIT: Electrically operated device that reduces kitchen or other waste into fragments small enough to be flushed into a drainage system. 
/// WASTETRAP: Pipe fitting, set adjacent to a sanitary terminal, that retains liquid to prevent the passage of foul air. 
/// USERDEFINED: User-defined type. 
/// NOTDEFINED: Undefined type.
typedef enum {IfcWasteTerminalType_FLOORTRAP, IfcWasteTerminalType_FLOORWASTE, IfcWasteTerminalType_GULLYSUMP, IfcWasteTerminalType_GULLYTRAP, IfcWasteTerminalType_GREASEINTERCEPTOR, IfcWasteTerminalType_OILINTERCEPTOR, IfcWasteTerminalType_PETROLINTERCEPTOR, IfcWasteTerminalType_ROOFDRAIN, IfcWasteTerminalType_WASTEDISPOSALUNIT, IfcWasteTerminalType_WASTETRAP, IfcWasteTerminalType_USERDEFINED, IfcWasteTerminalType_NOTDEFINED} IfcWasteTerminalTypeEnum;
const char* ToString(IfcWasteTerminalTypeEnum v);
IfcWasteTerminalTypeEnum FromString(const std::string& s);
}
namespace IfcWindowPanelOperationEnum {
/// This enumeration defines the basic ways to describe how window panels operate, as shown in Figure 168. 
/// 
/// HISTORY New Enumeration in IFC Release 2.0
/// 
/// Enumerator 
///   Description 
///   Figure 
/// 
/// SideHungRightHand 
///   panel that opens to the right
///   when viewed from the outside 
///     
/// 
/// SideHungLeftHand 
///   panel that opens to the left
///   when viewed from the outside 
///     
/// 
/// TiltAndTurnRightHand 
///   panel that opens to the right
///   and is bottom hung 
///     
/// 
/// TiltAndTurnLeftHand 
///   panel that opens to the left
///   and is bottom hung 
///     
/// 
/// TopHung 
///   panel is top hung 
///     
/// 
/// BottomHung 
///   panel is bottom hung 
///     
/// 
/// PivotHorizontal 
///   panel is swinging
///   horizontally (hinges are in the middle) 
///     
/// 
/// PivotVertical 
///   panel is swinging vertically
///   (hinges are in the middle) 
///     
/// 
/// SlidingHorizontal 
///   panel is sliding horizontally
/// 
///   
/// 
/// SlidingVertical 
///   panel is sliding
///   vertically 
///     
/// 
/// RemovableCasement 
///   panel is removable 
///     
/// 
/// FixedCasement 
///   panel is fixed 
///     
/// 
/// OtherOperation 
///   user defined operation type 
///     
/// 
/// NotDefined 
///     
///     
/// 
/// Figure 168 — Window panel operations
/// 
/// The opening direction of the window panels is given by the local placement of the IfcWindow. The positive y-axis determines the direction as shown in Figure 169.
///   NOTE 
/// 
/// Figures are shown as viewed from the outside (in direction of the
///   positive y-axis). 
///   Figures (symbolic representation) depend on the national building
///   code 
///   These figures are only shown as illustrations 
/// 
/// Figure 169 — Window panel directions
typedef enum {IfcWindowPanelOperation_SIDEHUNGRIGHTHAND, IfcWindowPanelOperation_SIDEHUNGLEFTHAND, IfcWindowPanelOperation_TILTANDTURNRIGHTHAND, IfcWindowPanelOperation_TILTANDTURNLEFTHAND, IfcWindowPanelOperation_TOPHUNG, IfcWindowPanelOperation_BOTTOMHUNG, IfcWindowPanelOperation_PIVOTHORIZONTAL, IfcWindowPanelOperation_PIVOTVERTICAL, IfcWindowPanelOperation_SLIDINGHORIZONTAL, IfcWindowPanelOperation_SLIDINGVERTICAL, IfcWindowPanelOperation_REMOVABLECASEMENT, IfcWindowPanelOperation_FIXEDCASEMENT, IfcWindowPanelOperation_OTHEROPERATION, IfcWindowPanelOperation_NOTDEFINED} IfcWindowPanelOperationEnum;
const char* ToString(IfcWindowPanelOperationEnum v);
IfcWindowPanelOperationEnum FromString(const std::string& s);
}
namespace IfcWindowPanelPositionEnum {
/// This enumeration defines the basic configuration of the window type in terms of the location of window panels. The window configurations are given for windows with one, two or three panels (including fixed panels) as shown in Figure 170. It corresponds to the OperationType of the IfcWindowStyle definition, which references the IfcWindowPanelProperties. 
/// 
/// Windows which are subdivided into more than three panels have to be defined by the geometry only. The type of such windows is given by an IfcWindowStyle.OperationType = USERDEFINED or NOTDEFINED (see IfcWindowStyleOperationEnum for details). 
/// 
/// HISTORY New Enumeration in IFC Release 2.0.
/// 
/// Enumerator from IfcWindowStyleOperationEnum 
///   Use of enumerators from IfcWindowPanelPositionEnum 
///   Figure 
/// 
/// DoublePanelVertical 
///   first
///   IfcWindowPanelProperties with PanelPosition = LEFTsecond
///   IfcWindowPanelProperties with PanelPosition = RIGHT 
/// 
/// DoublePanelHorizontal 
///   first
///   IfcWindowPanelProperties with PanelPosition = TOPsecond
///   IfcWindowPanelProperties with PanelPosition = BOTTOM 
/// 
/// TriplePanelVertical 
///   first
///   IfcWindowPanelProperties with PanelPosition = LEFTsecond
///   IfcWindowPanelProperties with PanelPosition = MIDDLEthird
///   IfcWindowPanelProperties with PanelPosition = RIGHT 
/// 
/// TriplePanelHorizontal  
///   first
///   IfcWindowPanelProperties with PanelPosition = TOPsecond
///   IfcWindowPanelProperties with PanelPosition = MIDDLEthird
///   IfcWindowPanelProperties with PanelPosition = BOTTOM 
/// 
/// TriplePanelBottom 
///   first
///   IfcWindowPanelProperties with PanelPosition = LEFTsecond
///   IfcWindowPanelProperties with PanelPosition = RIGHTthird
///   IfcWindowPanelProperties with PanelPosition = BOTTOM 
/// 
/// TriplePanelTop 
///   first
///   IfcWindowPanelProperties with PanelPosition = TOPsecond
///   IfcWindowPanelProperties with PanelPosition = LEFTthird
///   IfcWindowPanelProperties with PanelPosition = RIGHT 
/// 
/// TriplePanelLeft 
///   first
///   IfcWindowPanelProperties with PanelPosition = LEFTsecond
///   IfcWindowPanelProperties with PanelPosition = TOPthird
///   IfcWindowPanelProperties with PanelPosition = BOTTOM 
/// 
/// TriplePanelRight 
///   first
///   IfcWindowPanelProperties with PanelPosition = TOPsecond
///   IfcWindowPanelProperties with PanelPosition = BOTTOMthird
///   IfcWindowPanelProperties with PanelPosition = RIGHT 
/// 
/// Figure 170 — Window panel positions
/// 
/// NOTE 
/// 
/// The figures are shown as elevations in the XZ plane of the local
///   placement of the window, looking into the direction of the positive Y
///   axis. 
///   These figures are only shown as illustrations.
typedef enum {IfcWindowPanelPosition_LEFT, IfcWindowPanelPosition_MIDDLE, IfcWindowPanelPosition_RIGHT, IfcWindowPanelPosition_BOTTOM, IfcWindowPanelPosition_TOP, IfcWindowPanelPosition_NOTDEFINED} IfcWindowPanelPositionEnum;
const char* ToString(IfcWindowPanelPositionEnum v);
IfcWindowPanelPositionEnum FromString(const std::string& s);
}
namespace IfcWindowStyleConstructionEnum {
/// Definition from IAI: This enumeration defines the
///   basic types of construction of windows. The construction
///   type relates to the main material (or material combination)
///   used for making the window.
/// 
/// HISTORY New Enumeration in
///   IFC Release 2x .
typedef enum {IfcWindowStyleConstruction_ALUMINIUM, IfcWindowStyleConstruction_HIGH_GRADE_STEEL, IfcWindowStyleConstruction_STEEL, IfcWindowStyleConstruction_WOOD, IfcWindowStyleConstruction_ALUMINIUM_WOOD, IfcWindowStyleConstruction_PLASTIC, IfcWindowStyleConstruction_OTHER_CONSTRUCTION, IfcWindowStyleConstruction_NOTDEFINED} IfcWindowStyleConstructionEnum;
const char* ToString(IfcWindowStyleConstructionEnum v);
IfcWindowStyleConstructionEnum FromString(const std::string& s);
}
namespace IfcWindowStyleOperationEnum {
/// This enumeration defines the basic
///   configuration of the window type in terms of the number of window panels and
///   the subdivision of the total window. The window configurations are given for
///   windows with one, two or three panels (including fixed panels) as shown in Figure 171. 
///   Windows which are subdivided into more than three panels have to be
///   defined by the geometry only. The type of such windows is USERDEFINED. 
///   HISTORY New Enumeration in IFC Release 2.0. 
/// 
/// Enumerator 
///   Description 
///   Figure 
/// 
/// SinglePanel 
///   Window with one
///   panel. 
/// 
/// DoublePanelVertical 
///   Window with two panels. The
///   configuration of the panels is vertically. 
/// 
/// DoublePanelHorizontal 
///   Window with two panels. The
///   configuration of the panels is horizontally. 
/// 
/// TriplePanelVertical 
///   Window with three panels. The
///   configuration of the panels is vertically. 
/// 
/// TriplePanelHorizontal  
///   Window with three panels. The
///   configuration of the panels is horizontally. 
/// 
/// TriplePanelBottom 
///   Window with three panels. The
///   configuration of two panels is vertically and the third one is horizontally at
///   the bottom. 
/// 
/// TriplePanelTop 
///   Window with three panels. The
///   configuration of two panels is vertically and the third one is horizontally at
///   the top. 
/// 
/// TriplePanelLeft 
///   Window with three panels. The
///   configuration of two panels is horizontally and the third one is vertically at
///   the left hand side. 
/// 
/// TriplePanelRight 
///   Window with three panels. The
///   configuration of two panels is horizontally and the third one is vertically at
///   the right hand side. 
/// 
/// UserDefined 
///   user defined operation
///   type 
///     
/// 
/// NotDefined 
///     
///     
/// 
/// Figure 171 — Window style operations
/// 
/// NOTE 
/// 
/// The way how each panel operates is defined at the
///   IfcWindowPanelProperties.OperationType. 
///   The reference from the window panel to the location of that panel in
///   the window style configuration is handled by the
///   IfcWindowPanelProperties.PanelPosition. 
///   The figures are shown as elevations in the XZ plane of the local
///   placement of the window, looking into the direction of the positive Y
///   axis. 
///   These figures are only shown as illustrations
typedef enum {IfcWindowStyleOperation_SINGLE_PANEL, IfcWindowStyleOperation_DOUBLE_PANEL_VERTICAL, IfcWindowStyleOperation_DOUBLE_PANEL_HORIZONTAL, IfcWindowStyleOperation_TRIPLE_PANEL_VERTICAL, IfcWindowStyleOperation_TRIPLE_PANEL_BOTTOM, IfcWindowStyleOperation_TRIPLE_PANEL_TOP, IfcWindowStyleOperation_TRIPLE_PANEL_LEFT, IfcWindowStyleOperation_TRIPLE_PANEL_RIGHT, IfcWindowStyleOperation_TRIPLE_PANEL_HORIZONTAL, IfcWindowStyleOperation_USERDEFINED, IfcWindowStyleOperation_NOTDEFINED} IfcWindowStyleOperationEnum;
const char* ToString(IfcWindowStyleOperationEnum v);
IfcWindowStyleOperationEnum FromString(const std::string& s);
}
namespace IfcWorkControlTypeEnum {

typedef enum {IfcWorkControlType_ACTUAL, IfcWorkControlType_BASELINE, IfcWorkControlType_PLANNED, IfcWorkControlType_USERDEFINED, IfcWorkControlType_NOTDEFINED} IfcWorkControlTypeEnum;
const char* ToString(IfcWorkControlTypeEnum v);
IfcWorkControlTypeEnum FromString(const std::string& s);
}
/// IfcAbsorbedDoseMeasure is a measure of the absorbed radioactivity dose.
/// Usually measured in Gray (Gy, J/kg).
/// Type: REAL
/// 
/// HISTORY New type in IFC Release 2x.
class IfcAbsorbedDoseMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcAbsorbedDoseMeasure (IfcAbstractEntity* e);
    IfcAbsorbedDoseMeasure (double v);
    operator double() const;
};
/// IfcAccelerationMeasure is a measure of acceleration.
/// Usually measured in m/s2.
/// Type: REAL
/// 
/// HISTORY New type in IFC Release 2x.
class IfcAccelerationMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcAccelerationMeasure (IfcAbstractEntity* e);
    IfcAccelerationMeasure (double v);
    operator double() const;
};
/// Definition from ISO/CD 10303-41:1992: An amount of substance measure is the value for the quantity  of a substance when compared with the number of atoms in 0.012kilogram of carbon 12.
/// 
/// Usually measure in mole (mol).
/// Type: REAL
/// 
/// NOTE Corresponding ISO 10303 name: amount_of_substance_measure, please refer to ISO/IS 10303-41 for the final definition of the formal standard.
/// 
/// HISTORY New type in IFC Release 1.5.1.
class IfcAmountOfSubstanceMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcAmountOfSubstanceMeasure (IfcAbstractEntity* e);
    IfcAmountOfSubstanceMeasure (double v);
    operator double() const;
};
/// IfcAngularVelocityMeasure is a measure of the velocity of a body measured in terms of angle subtended per unit time.
/// Usually measured in radians/s.
/// Type: REAL
/// 
/// HISTORY New type in IFC Release 2.0.
class IfcAngularVelocityMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcAngularVelocityMeasure (IfcAbstractEntity* e);
    IfcAngularVelocityMeasure (double v);
    operator double() const;
};
/// Definition from ISO/CD 10303-41:1992: An area measure is the value of the extent of a surface.
/// Usually measured in square metre (m2).
/// Type: REAL
/// 
/// NOTE Corresponding ISO 10303 name: area_measure, please refer to ISO/IS 10303-41 for the final definition of the formal standard.
/// 
/// HISTORY New type in IFC Release 1.5.1.
class IfcAreaMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcAreaMeasure (IfcAbstractEntity* e);
    IfcAreaMeasure (double v);
    operator double() const;
};
/// IfcBoolean is a defined data type of simple data type Boolean. It is required since a select type (IfcSimpleValue) cannot directly include simple types in its select list.  A boolean type can have value TRUE or FALSE.
/// 
/// Type: BOOLEAN
/// 
/// HISTORY New type in IFC Release 1.5.1.
class IfcBoolean : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcBoolean (IfcAbstractEntity* e);
    IfcBoolean (bool v);
    operator bool() const;
};
/// IfcComplexNumber is a representation of a complex number expressed as an array with two elements.
///   The first element (index 1) denotes the real component which is the numerical
///   component of a complex number whose square roots can be calculated explicitly.
///   The second element (index 2) denotes the imaginary component which is the numerical
///   component of a complex number whose square roots cannot be determined other
///   than through the provision of the square of the imaginary number j where j^2 = -1.
///   Note that the imaginary component may be referred to as i in certain references.
/// 
/// Type: ARRAY [1:2] OF REAL
/// 
/// HISTORY New type in IFC Release 2x2.
class IfcComplexNumber : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcComplexNumber (IfcAbstractEntity* e);
    IfcComplexNumber (std::vector< double > /*[1:2]*/ v);
    operator std::vector< double > /*[1:2]*/() const;
};
/// IfcCompoundPlaneAngleMeasure is a compound measure of plane angle in degrees, minutes, seconds, and optionally millionth-seconds of arc.
/// 
/// NOTE: IfcCompoundPlaneAngleMeasure is used where angles need to be described to an accuracy as fine as one millionth of a degree and expressed as parts of an arc. It may be used for angular measurement by surveyors or for other angular measurements where precision is required. Another usage is exact or approximate global positioning against a geographic coordinate systems using longitude and latitude.
/// 
/// NOTE: While the unit of measurement of the type IfcPlaneAngleMeasure depends on unit assignment (radian or degree or other derived units; globally at the IfcPoject or locally at an IfcMeasureWithUnit), the units of IfcCompoundPlaneAngleMeasure are always degrees, minutes, seconds, and millionth-seconds irrespective of unit assignments.
/// 
/// HISTORY New type in IFC Release 1.5.1.
/// 
/// Type: LIST [3:4] OF INTEGER
/// 
/// Value restrictions
/// 
/// The first integer measure is the number of degrees and is generally not range-restricted.  However, when IfcCompoundPlaneAngleMeasure is used to express geographic coordinates, only latitudes of [-90, 90] and longitudes of [-180, 180] are used in practice.
/// The second integer measure is the number of minutes and shall be in the range (-60, 60).
/// The third integer measure is the number of seconds and shall be in the range (-60, 60).
/// The optional fourth integer measure is the number of millionth-seconds and shall be in the range (-1 000 000, 1 000 000).
/// 
/// Signedness
/// 
/// All measure components have the same sign (positive or negative).  It is therefore trivial to convert between floating point representation (decimal degrees) and compound representation regardless whether the angle is greater or smaller than zero.  Example:
/// 
/// LOCAL
///   a : IfcPlaneAngleMeasure := -50.975864;  (* decimal degrees, -50° 58' 33" 110400 *)
///   b : IfcPlaneAngleMeasure;
///   c : IfcCompoundPlaneAngleMeasure;
///   s : IfcText;
/// END_LOCAL;
/// 
/// (* convert from float to compound *)
///   c[1] :=    a;                                           -- -50
///   c[2] :=   (a - c[1]) * 60;                              -- -58
///   c[3] :=  ((a - c[1]) * 60 - c[2]) * 60;                 -- -33
///   c[4] := (((a - c[1]) * 60 - c[2]) * 60 - c[3]) * 1.e6;  -- -110400
/// 
/// (* convert from compound to float *)
///   b := c[1] + c[2]/60. + c[3]/3600. + c[4]/3600.e6;       -- -50.975864
/// 
/// Use in string representations
/// 
/// When a compound plane angle measure is formatted for display or printout, the signs of the fractional components will usually be discarded because, to a human reader, the sign of the first component alone already indicates the sense of the angle:
/// 
/// (* convert from compound to human-readable string *)
///   s := FORMAT(c[1], '+##')     + "000000B0"
///      + FORMAT(ABS(c[2]), '##') + ''''
///      + FORMAT(ABS(c[3]), '##') + '"'
///      + FORMAT(ABS(c[4]), '##');  -- -50° 58' 33" 110400
/// 
/// Another often encountered display format of latitudes and longitudes is to omit the signs and print N, S, E, W indicators instead, for example, 50°58'33"S.  When stored as IfcCompoundPlaneAngleMeasure however, a compound plane angle measure is always signed, with same sign of all components.
class IfcCompoundPlaneAngleMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcCompoundPlaneAngleMeasure (IfcAbstractEntity* e);
    IfcCompoundPlaneAngleMeasure (std::vector< int > /*[3:4]*/ v);
    operator std::vector< int > /*[3:4]*/() const;
};
/// Definition from ISO/CD 10303-41:1992: Is the value of a physical quantity as defined by an application context.
/// Type: REAL
/// 
/// NOTE Corresponding ISO 10303 name: context_dependent_measure, please refer to ISO/IS 10303-41 for the final definition of the formal standard.
/// 
/// HISTORY New type in IFC Release 1.5.1.
class IfcContextDependentMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcContextDependentMeasure (IfcAbstractEntity* e);
    IfcContextDependentMeasure (double v);
    operator double() const;
};
/// Definition from ISO/CD 10303-41:1992: A count measure is the value of a count.
/// Type: NUMBER
/// 
/// NOTE Corresponding ISO 10303 name: count_measure, please refer to ISO/IS 10303-41 for the final definition of the formal standard.
/// 
/// HISTORY New type in IFC Release 1.5.1.
class IfcCountMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcCountMeasure (IfcAbstractEntity* e);
    IfcCountMeasure (double v);
    operator double() const;
};
/// IfcCurvatureMeasure is a measure for curvature, which is defined as the change of slope per length.
///   This is typically a computed value in structural analysis.
///   It is usually measured in rad/m.
/// 
/// Type: REAL
/// 
/// HISTORY New type in IFC2x2.
class IfcCurvatureMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcCurvatureMeasure (IfcAbstractEntity* e);
    IfcCurvatureMeasure (double v);
    operator double() const;
};
/// Definition from IAI: The IfcDayInMonthNumber is
/// an integer that defines the position of the specified day in a
/// month.
/// Type: INTEGER
/// NOTE Corresponding STEP
/// name: day_in_month_number, please refer to ISO/IS 10303-41:1994
/// for the final definition of the formal
/// standard.
/// HISTORY New type in IFC
/// Release 1.5.1.
/// IFC2x4 CHANGE Where rule
/// ValidRange added.
class IfcDayInMonthNumber : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcDayInMonthNumber (IfcAbstractEntity* e);
    IfcDayInMonthNumber (int v);
    operator int() const;
};

class IfcDaylightSavingHour : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcDaylightSavingHour (IfcAbstractEntity* e);
    IfcDaylightSavingHour (int v);
    operator int() const;
};
/// Definition from ISO/CD 10303-41:1992: A descriptive measure is a human interpretable definition of a quantifiable value.
/// Type: STRING
/// 
/// NOTE Corresponding ISO 10303 name:descriptive_measure, please refer to ISO/IS 10303-41 for the final definition of the formal standard.
/// 
/// HISTORY New type in IFC Release 1.5.1.
class IfcDescriptiveMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcDescriptiveMeasure (IfcAbstractEntity* e);
    IfcDescriptiveMeasure (std::string v);
    operator std::string() const;
};
/// Definition from ISO/CD 10303-42:1992: A dimension count is a positive integer used to define the coordinate space dimensionality.  
/// 
/// The IfcDimensionCount is restricted to have the dimensionality of either 1, 2, or 3 - the WR1 had been added as an addition to the ISO 10303:42 entity dimension_count. In contrary to the ISO 10303:42 constraint, that all geometric representation items within a geometric representation context are forced to have the same dimension count, the IFC geometry allows mixed dimensions, particularly when defining the boundary of planar surfaces.  
/// 
/// NOTE Corresponding ISO 10303 type: dimension_count, please refer to ISO/IS 10303-42:1994, p. 14 for the final definition of the formal standard.
/// 
/// HISTORY New Type in IFC Release 1.5
class IfcDimensionCount : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcDimensionCount (IfcAbstractEntity* e);
    IfcDimensionCount (int v);
    operator int() const;
};
/// IfcDoseEquivalentMeasure is a measure of the radioactive dose equivalent.
/// Usually measured in Sievert (Sv, J/kg).
/// Type: REAL
/// 
/// HISTORY New type in IFC Release 2x.
class IfcDoseEquivalentMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcDoseEquivalentMeasure (IfcAbstractEntity* e);
    IfcDoseEquivalentMeasure (double v);
    operator double() const;
};
/// IfcDynamicViscosityMeasure is a measure of the viscous resistance of a medium.
/// 
/// Usually measured in Pascal second (Pa s).
/// Type: REAL 
/// 
/// HISTORY New type in IFC Release 2.0.
class IfcDynamicViscosityMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcDynamicViscosityMeasure (IfcAbstractEntity* e);
    IfcDynamicViscosityMeasure (double v);
    operator double() const;
};
/// IfcElectricCapacitanceMeasure is a measure of the electric capacitance.
/// Usually measured in Farad (F, C/V = A s/V).
/// Type: REAL
/// 
/// HISTORY New type in IFC Release 2x.
class IfcElectricCapacitanceMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcElectricCapacitanceMeasure (IfcAbstractEntity* e);
    IfcElectricCapacitanceMeasure (double v);
    operator double() const;
};
/// IfcElectricChargeMeasure is a measure of the electric charge.
/// Usually measured in Coulomb (C, A s).
/// Type: REAL
/// 
/// HISTORY New type in IFC Release 2x.
class IfcElectricChargeMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcElectricChargeMeasure (IfcAbstractEntity* e);
    IfcElectricChargeMeasure (double v);
    operator double() const;
};
/// IfcElectricConductanceMeasure is a measure of the electric conductance.
/// Usually measured in Siemens (S, 1/Ohm = A/V).
/// Type: REAL
/// 
/// HISTORY New type in IFC Release 2x.
class IfcElectricConductanceMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcElectricConductanceMeasure (IfcAbstractEntity* e);
    IfcElectricConductanceMeasure (double v);
    operator double() const;
};
/// Definition from ISO/CD 10303-41:1992: The value for the movement of electrically charged particles.
/// Usually measured in Ampere (A).
/// Type: REAL
/// 
/// NOTE Corresponding ISO 10303 name: electric_current_measure, please refer to ISO/IS 10303-41 for the final definition of the formal standard.
/// 
/// HISTORY New type in IFC Release 1.5.1.
class IfcElectricCurrentMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcElectricCurrentMeasure (IfcAbstractEntity* e);
    IfcElectricCurrentMeasure (double v);
    operator double() const;
};
/// IfcElectricResistanceMeasure is a measure of the electric resistance.
/// Usually measured in Ohm (V/A).
/// Type: REAL
/// 
/// HISTORY New type in IFC Release 2x.
class IfcElectricResistanceMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcElectricResistanceMeasure (IfcAbstractEntity* e);
    IfcElectricResistanceMeasure (double v);
    operator double() const;
};
/// IfcElectricVoltageMeasure is a measure of electromotive force.
/// Usually measured in Volts (V, W/A).
/// Type: REAL
/// 
/// HISTORY New type in IFC Release 2.0.
class IfcElectricVoltageMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcElectricVoltageMeasure (IfcAbstractEntity* e);
    IfcElectricVoltageMeasure (double v);
    operator double() const;
};
/// IfcEnergyMeasure is a measure of energy required or used.
/// Usually measured in Joules, (J, Nm).
/// Type: REAL
/// 
/// HISTORY New type in IFC Release 2.0.
class IfcEnergyMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcEnergyMeasure (IfcAbstractEntity* e);
    IfcEnergyMeasure (double v);
    operator double() const;
};
/// Definition from CSS1 (W3C Recommendation): The font-style property selects between normal (sometimes
/// referred to as "roman" or "upright"), italic and oblique faces within a font family. Values are:
/// 
/// normal 
///   italic 
///   oblique
/// 
/// A value of 'normal' selects a font that is classified as 'normal' in the user agents font database, while 'oblique' selects a font that is labeled 'oblique'. A value of 'italic' selects a font that is labeled 'italic', or, if that is not available, one labeled 'oblique'. The font that is labeled 'oblique' in the user agents font database may actually have been generated by electronically slanting a normal font.
/// 
/// Fonts with Oblique, Slanted or Incline in their names will typically be labeled 'oblique' in the user agents font database. Fonts with Italic, Cursive or Kursiv in their names will typically be labeled 'italic'.
/// 
/// NOTE  Corresponding CSS1 definitions is font-style.
/// 
/// HISTORY  New type in IFC2x3.
class IfcFontStyle : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcFontStyle (IfcAbstractEntity* e);
    IfcFontStyle (std::string v);
    operator std::string() const;
};
/// Definition from CSS1 (W3C Recommendation): The font-style property selects between normal and small-caps within a font family. Values are:
/// 
/// normal 
///   small-caps 
/// 
/// Another type of variation within a font family is the small-caps. In a small-caps font the lower case letters look similar to the uppercase ones, but in a smaller size and with slightly different proportions. The 'font-variant' property selects that font.
/// 
/// A value of 'normal' selects a font that is not a small-caps font, 'small-caps' selects a small-caps font. It is acceptable (but not required) in CSS1 if the small-caps font is a created by taking a normal font and replacing the lower case letters by scaled uppercase characters. As a last resort, uppercase letters will be used as replacement for a small-caps font.
/// 
/// NOTE  Corresponding CSS1 definitions is font-variant.
/// 
/// HISTORY  New type in IFC2x3.
class IfcFontVariant : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcFontVariant (IfcAbstractEntity* e);
    IfcFontVariant (std::string v);
    operator std::string() const;
};
/// Definition from CSS1 (W3C Recommendation): The 'font-weight' property selects the weight of the font. The values '100' to '900' form an ordered sequence, where each number indicates a weight that is at least as dark as its predecessor. The keyword 'normal' is synonymous with '400', and 'bold' is synonymous with '700'. Keywords other than 'normal' and 'bold' have been shown to be often confused with font names and a numerical scale was therefore chosen for the 9-value list. Values are:
/// 
/// normal 
///   bold 
///   100 | 200 | 300 | 400 | 500 | 600 | 700 | 800 | 900
/// 
/// Fonts (the font data) typically have one or more properties whose values are names that are descriptive of the "weight" of a font. There is no accepted, universal meaning to these weight names. Their primary role is to distinguish faces of differing darkness within a single font family. Usage across font families is quite variant; for example a font that you might think of as being bold might be described as being Regular, Roman, Book, Medium, Semi- or DemiBold, Bold, or Black, depending on how black the "normal" face of the font is within the design. Because there is no standard usage of names, the weight property values in CSS1 are given on a numerical scale in which the value '400' (or 'normal') corresponds to the "normal" text face for that family. The weight name associated with that face will typically be Book, Regular, Roman, Normal or sometimes Medium.
/// 
/// The association of other weights within a family to the numerical weight values is intended only to preserve the ordering of darkness within that family. However, the following heuristics tell how the assignment is done in typical cases:
/// 
/// If the font family already uses a numerical scale with nine values (such as with OpenType), the font weights should be mapped directly. 
///   If there is both a face labeled Medium and one labeled Book, Regular, Roman or Normal, then the Medium is normally assigned to the '500'. 
///   The font labeled "Bold" will often correspond to the weight value '700'. 
///   If there are fewer then 9 weights in the family, the default algorithm for filling the "holes" is as follows. If '500' is unassigned, it will be assigned the same font as '400'. If any of the values '600', '700', '800' or '900' remains unassigned, they are assigned to the same face as the next darker assigned keyword, if any, or the next lighter one otherwise. If any of '300', '200' or '100' remains unassigned, it is assigned to the next lighter assigned keyword, if any, or the next darker otherwise. 
/// 
/// The following two examples illustrate the process. Assume four weights in the "Example1" family, from lightest to darkest: Regular, Medium, Bold, Heavy. And assume six weights in the "Example2" family: Book, Medium, Bold, Heavy, Black, ExtraBlack. Note how in the second example it has been decided not to assign "Example2 ExtraBlack" to anything.
/// 
/// Available faces       | Assignments   | Filling the holes----------------------+---------------+-------------------"Example1 Regular"    | 400           | 100, 200, 300"Example1 Medium"     | 500           |"Example1 Bold"       | 700           | 600"Example1 Heavy"      | 800           | 900
/// Available faces       | Assignments   | Filling the holes----------------------+---------------+-------------------"Example2 Book"       | 400           | 100, 200, 300"Example2 Medium"     | 500           |"Example2 Bold"       | 700           | 600 "Example2 Heavy"      | 800           |"Example2 Black"      | 900           |"Example2 ExtraBlack" | (none)        |
/// 
/// NOTE  Corresponding CSS1 definitions is font-weight.
/// 
/// HISTORY  New type in IFC2x2 Addendum 2.
class IfcFontWeight : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcFontWeight (IfcAbstractEntity* e);
    IfcFontWeight (std::string v);
    operator std::string() const;
};
/// IfcForceMeasure is a measure of the force.
/// Usually measured in Newton (N, kg m/s2).
/// Type: REAL
/// 
/// HISTORY New type in IFC Release 2x.
class IfcForceMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcForceMeasure (IfcAbstractEntity* e);
    IfcForceMeasure (double v);
    operator double() const;
};
/// IfcFrequencyMeasure is a measure of the number of times that an item vibrates in unit time.
/// Usually measured in cycles/s or Herz (Hz).
/// Type: REAL
/// 
/// HISTORY New type in IFC Release 2.0.
class IfcFrequencyMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcFrequencyMeasure (IfcAbstractEntity* e);
    IfcFrequencyMeasure (double v);
    operator double() const;
};
/// An IfcGloballyUniqueId holds an encoded string identifier that is used to uniquely identify an IFC object. An IfcGloballyUniqueId is a Globally
///   Unique Identifier (GUID) which is an auto-generated 128-bit number. Since this identifier is
///   required for all IFC object instances, it is desirable to compress it to reduce overhead. The encoding of the base 64 character set is shown below:
/// 
///            1         2         3         4         5         6
/// 
///  0123456789012345678901234567890123456789012345678901234567890123
/// 
/// "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_$";
/// 
/// The resulting string is a fixed 22 character length string to be exchanged within the IFC exchange file structure.
/// 
/// Refer to the BuildingSMART website (www.buildingsmart-tech.org) for more information and sample encoding algorithms.
/// 
/// HISTORY  New type in IFC R1.5.1.
class IfcGloballyUniqueId : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcGloballyUniqueId (IfcAbstractEntity* e);
    IfcGloballyUniqueId (std::string v);
    operator std::string() const;
};
/// IfcHeatFluxDensityMeasure is a measure of the density of heat flux within a body.
/// Usually measured in W/m2 (J/s m2).
/// Type: REAL
/// 
/// HISTORY New type in IFC Release 2.0.
class IfcHeatFluxDensityMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcHeatFluxDensityMeasure (IfcAbstractEntity* e);
    IfcHeatFluxDensityMeasure (double v);
    operator double() const;
};
/// IfcHeatingValueMeasure defines the amount of energy released (usually in MJ/kg) when a fuel is burned.
/// 
/// HISTORY: This is new type in IFC2x2.
class IfcHeatingValueMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcHeatingValueMeasure (IfcAbstractEntity* e);
    IfcHeatingValueMeasure (double v);
    operator double() const;
};

class IfcHourInDay : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcHourInDay (IfcAbstractEntity* e);
    IfcHourInDay (int v);
    operator int() const;
};
/// Definition from ISO/CD 10303-41:1992: An identifier is an alphanumeric string which allows an individual thing to be identified. It may not provide natural-language meaning.
/// 
/// Type: STRING of up to 255 characters
/// 
/// NOTE Corresponding STEP name: identifier, please refer to ISO/IS 10303-41 for the final definition of the formal standard.
/// 
/// HISTORY New type in IFC Release 2x.
/// IFC 2x4 CHANGE: Previously recommended size restriction of 255 characters is now mandatory.
/// 
/// As a merely machine-readable string for identification purposes, an identifier is usually machine-generated and locale-independent (in contrast to human-readable labels, IfcLabel).
/// 
/// Per ISO 10303-11, the set of characters that may appear in STRINGs is defined in ISO 10646.  The encoding of characters in case of file-based exchange is defined in ISO 10303-21 (STEP physical files) and ISO 10303-28 (XML files).  Among else, these specifications define the encoding of 8-bit characters from ISO 8859-1...-16 and of 2-byte Unicode characters.
/// 
/// Note that while IfcIdentifier is restricted to 255 characters, the size in exchange files after encoding may be considerably larger than 255 octets, depending on the particular encoding and on the contents of the identifier.
class IfcIdentifier : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcIdentifier (IfcAbstractEntity* e);
    IfcIdentifier (std::string v);
    operator std::string() const;
};
/// IfcIlluminanceMeasure is a measure of the illuminance.
/// Usually measured in Lux (lx, Lumen/m2 = Candela Steradian/m2).
/// Type: REAL
/// 
/// HISTORY New type in IFC Release 2x.
class IfcIlluminanceMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcIlluminanceMeasure (IfcAbstractEntity* e);
    IfcIlluminanceMeasure (double v);
    operator double() const;
};
/// IfcInductanceMeasure is a measure of the inductance.
/// Usually measure in Henry (H, Weber/A = V s/A).
/// Type: REAL
/// 
/// HISTORY New type in IFC Release 2x.
class IfcInductanceMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcInductanceMeasure (IfcAbstractEntity* e);
    IfcInductanceMeasure (double v);
    operator double() const;
};
/// IfcInteger is a defined type of simple data type Integer. It is required since a select type (IfcSimpleValue) cannot include directly simple types in its select list.
/// 
/// In principle, the domain of IfcInteger (being an Integer) is all integer numbers. Here the number of bits used for the IfcInteger representation is unconstrained, but in practice it is implementation specific.
/// 
/// Type: INTEGER
/// 
/// HISTORY New type in IFC Release 1.5.1.
class IfcInteger : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcInteger (IfcAbstractEntity* e);
    IfcInteger (int v);
    operator int() const;
};
/// IfcIntegerCountRateMeasure is a measure of the integer number of units flowing per unit time.
/// 
/// EXAMPLE: This measure may be used for measuring integer units per second or per hour. For example, it may be used to measure the number of books per hour passing along a part of a mechanical book handling system, the number of people per hour travelling along a moving walkway or the number of vehicles per hour travelling along a section of road.
/// 
/// Type: INTEGER
/// 
/// HISTORY New type in IFC Release 2.0.
class IfcIntegerCountRateMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcIntegerCountRateMeasure (IfcAbstractEntity* e);
    IfcIntegerCountRateMeasure (int v);
    operator int() const;
};
/// IfcIonConcentrationMeasure is a measure of particular ion concentration in a liquid, given in mg/L.
/// 
/// HISTORY: New type in IFC2x2.
class IfcIonConcentrationMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcIonConcentrationMeasure (IfcAbstractEntity* e);
    IfcIonConcentrationMeasure (double v);
    operator double() const;
};
/// IfcIsothermalMoistureCapacityMeasure is a measure of isothermal moisture capacity.
/// Usually measured in m3/kg.
/// Type: REAL
/// 
/// HISTORY New type in IFC Release 2x.
class IfcIsothermalMoistureCapacityMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcIsothermalMoistureCapacityMeasure (IfcAbstractEntity* e);
    IfcIsothermalMoistureCapacityMeasure (double v);
    operator double() const;
};
/// IfcKinematicViscosityMeasure is a measure of the viscous resistance of a medium to a moving body.
/// Usually measured in m2/s.
/// Type: REAL
/// 
/// HISTORY New type in IFC Release 2.0.
class IfcKinematicViscosityMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcKinematicViscosityMeasure (IfcAbstractEntity* e);
    IfcKinematicViscosityMeasure (double v);
    operator double() const;
};
/// Definition from ISO/CD 10303-41:1992: A label is the term by which something may be referred to.  It is a string which represents the human-interpretable name of something and shall have a natural-language meaning.
/// 
/// Type: STRING of up to 255 characters
/// 
/// NOTE Corresponding STEP name: label, please refer to ISO/IS 10303-41 for the final definition of the formal standard.
/// 
/// HISTORY New type in IFC Release 2x.
/// IFC 2x4 CHANGE: Previously recommended size restriction of 255 characters is now mandatory.
/// 
/// As a human-readable string for naming purposes, a label is usually human-specified and locale-dependent (in contrast to purely machine-readable identifiers, IfcIdentifier).
/// 
/// Per ISO 10303-11, the set of characters that may appear in STRINGs is defined in ISO 10646.  The encoding of characters in case of file-based exchange is defined in ISO 10303-21 (STEP physical files) and ISO 10303-28 (XML files).  Among else, these specifications define the encoding of 8-bit characters from ISO 8859-1...-16 and of 2-byte Unicode characters.
/// 
/// Note that while IfcLabel is restricted to 255 characters, the size in exchange files after encoding may be considerably larger than 255 octets, depending on the particular encoding and on the contents of the label.
class IfcLabel : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcLabel (IfcAbstractEntity* e);
    IfcLabel (std::string v);
    operator std::string() const;
};
/// Definition from ISO/CD 10303-41:1992: A length measure is the value of a distance.
/// Usually measured in millimeters (mm).
/// Type: REAL
/// 
/// NOTE Corresponding ISO 10303 name: length_measure, please refer to ISO/IS 10303-41 for the final definition of the formal standard.
/// 
/// HISTORY New type in IFC Release 1.5.1.
class IfcLengthMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcLengthMeasure (IfcAbstractEntity* e);
    IfcLengthMeasure (double v);
    operator double() const;
};
/// IfcLinearForceMeasure is a measure of linear force.
/// Usually measured in N/m.
/// Type: REAL
/// 
/// HISTORY New type in IFC Release 2x.
class IfcLinearForceMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcLinearForceMeasure (IfcAbstractEntity* e);
    IfcLinearForceMeasure (double v);
    operator double() const;
};
/// IfcLinearMomentMeasure is a measure of linear moment.
/// Usually measured in Nm/m.
/// Type: REAL
/// 
/// HISTORY New type in IFC Release 2x.
class IfcLinearMomentMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcLinearMomentMeasure (IfcAbstractEntity* e);
    IfcLinearMomentMeasure (double v);
    operator double() const;
};
/// IfcLinearStiffnessMeasureA measure of linear stiffness.
/// Usually measured in N/m.
/// Type: REAL
/// 
/// HISTORY New type in IFC Release 2x.
class IfcLinearStiffnessMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcLinearStiffnessMeasure (IfcAbstractEntity* e);
    IfcLinearStiffnessMeasure (double v);
    operator double() const;
};
/// IfcLinearVelocityMeasure is a measure of the velocity of a body measured in terms of distance moved per unit time.
/// Usually measured in m/s.
/// Type: REAL
/// 
/// HISTORY New type in IFC Release 2.0.
class IfcLinearVelocityMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcLinearVelocityMeasure (IfcAbstractEntity* e);
    IfcLinearVelocityMeasure (double v);
    operator double() const;
};
/// IfcLogical</iL is a defined type of simple type Logical. It is required since a select type (IfcSimpleValue) cannot directly include simple types in its select list). Logical datatype can have values TRUE, FALSE or UNKNOWN.
/// 
/// Type: LOGICAL
/// 
/// HISTORY New type in IFC Release 2x.
class IfcLogical : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcLogical (IfcAbstractEntity* e);
    IfcLogical (bool v);
    operator bool() const;
};
/// IfcLuminousFluxMeasure is a measure of the luminous flux.
/// Usually measured in Lumen (lm, Candela Steradian).
/// Type: REAL
/// 
/// HISTORY New type in IFC Release 2x.
class IfcLuminousFluxMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcLuminousFluxMeasure (IfcAbstractEntity* e);
    IfcLuminousFluxMeasure (double v);
    operator double() const;
};
/// IfcLuminousIntensityDistributionMeasure is a measure of the luminous intensity of a light source that changes according to the direction of the ray. It is normally based on some standardized distribution light distribution curves. 
/// 
/// Usually measured in Candela/Lumen (cd/lm) or (cd/klm).  
/// 
/// Type: REAL  
/// 
/// HISTORY New type in IFC2x2.
class IfcLuminousIntensityDistributionMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcLuminousIntensityDistributionMeasure (IfcAbstractEntity* e);
    IfcLuminousIntensityDistributionMeasure (double v);
    operator double() const;
};
/// Definition from ISO/CD 10303-41:1992: A luminous intensity measure is the value for the brightness of a body.
/// Usually measured in candela (cd).
/// Type: REAL
/// 
/// NOTE Corresponding ISO 10303 name: luminous_intensity_measure, please refer to ISO/IS 10303-41 for the final definition of the formal standard.
/// 
/// HISTORY New type in IFC Release 1.5.1.
class IfcLuminousIntensityMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcLuminousIntensityMeasure (IfcAbstractEntity* e);
    IfcLuminousIntensityMeasure (double v);
    operator double() const;
};
/// IfcMagneticFluxDensityMeasure is a measure of the magnetic flux density.
/// Usually measured in Tesla (T, Weber/m2 = V s/m2).
/// Type: REAL
/// 
/// HISTORY New type in IFC Release 2x.
class IfcMagneticFluxDensityMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcMagneticFluxDensityMeasure (IfcAbstractEntity* e);
    IfcMagneticFluxDensityMeasure (double v);
    operator double() const;
};
/// IfcMagneticFluxMeasure is a measure of the magnetic flux.
/// Usually measured in Weber (Wb, V s).
/// Type: REAL
/// 
/// HISTORY New type in IFC Release 2x.
class IfcMagneticFluxMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcMagneticFluxMeasure (IfcAbstractEntity* e);
    IfcMagneticFluxMeasure (double v);
    operator double() const;
};
/// IfcMassDensityMeasure is a measure of the density of a medium.
/// Usually measured in kg/m3.
/// Type: REAL
/// 
/// HISTORY New type in IFC Release 2.0.
class IfcMassDensityMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcMassDensityMeasure (IfcAbstractEntity* e);
    IfcMassDensityMeasure (double v);
    operator double() const;
};
/// IfcMassFlowRateMeasure is a measure of the mass of a medium flowing per unit time.
/// Usually measured in kg/s.
/// Type: REAL
/// 
/// HISTORY New type in IFC Release 2.0.
class IfcMassFlowRateMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcMassFlowRateMeasure (IfcAbstractEntity* e);
    IfcMassFlowRateMeasure (double v);
    operator double() const;
};
/// Definition from ISO/CD 10303-41:1992: A mass measure is the value of the amount of matter that a body contains.
/// Usually measured in kilograms (kg) or grams (g).
/// Type: REAL
/// 
/// NOTE Corresponding ISO 10303 name: mass_measure, please refer to ISO/IS 10303-41 for the final definition of the formal standard.
/// 
/// HISTORY New type in IFC Release 1.5.1.
class IfcMassMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcMassMeasure (IfcAbstractEntity* e);
    IfcMassMeasure (double v);
    operator double() const;
};
/// IfcMassPerLengthMeasure is a measure for mass per length. For example for rolled steel profiles the weight of
///   an imaginary beam is usually expressed by kg/m length for cost calculation and
///   structural analysis purposes.
/// 
/// Type: REAL
/// 
/// HISTORY New type in IFC2x2.
class IfcMassPerLengthMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcMassPerLengthMeasure (IfcAbstractEntity* e);
    IfcMassPerLengthMeasure (double v);
    operator double() const;
};

class IfcMinuteInHour : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcMinuteInHour (IfcAbstractEntity* e);
    IfcMinuteInHour (int v);
    operator int() const;
};
/// IfcModulusOfElasticityMeasure is a measure of modulus of elasticity.
/// Usually measured in N/m2.
/// Type: REAL
/// 
/// HISTORY New type in IFC Release 2x.
class IfcModulusOfElasticityMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcModulusOfElasticityMeasure (IfcAbstractEntity* e);
    IfcModulusOfElasticityMeasure (double v);
    operator double() const;
};
/// IfcModulusOfLinearSubgradeReactionMeasure is a measure for modulus of linear subgrade reaction, which expresses the elastic bedding of a linear structural element per length, such as for a beam. It is typically measured in N/m^2.
/// 
/// Type: REAL  
/// 
/// HISTORY New type in IFC Release 2x2.
class IfcModulusOfLinearSubgradeReactionMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcModulusOfLinearSubgradeReactionMeasure (IfcAbstractEntity* e);
    IfcModulusOfLinearSubgradeReactionMeasure (double v);
    operator double() const;
};
/// IfcModulusOfRotationalSubgradeReactionMeasure is a measure for modulus of rotational subgrade reaction, which expresses the rotational elastic bedding of a linear structural element per length, such as for a beam. It is typically measured in Nm/(m*rad). 
/// 
/// Type: REAL  
/// 
/// HISTORY New type in IFC2x2.
class IfcModulusOfRotationalSubgradeReactionMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcModulusOfRotationalSubgradeReactionMeasure (IfcAbstractEntity* e);
    IfcModulusOfRotationalSubgradeReactionMeasure (double v);
    operator double() const;
};
/// IfcModulusOfSubgradeReactionMeasure is a geotechnical measure describing interaction between foundation structures and the soil. May also be known as bedding measure. 
///   Usually measured in N/m3.  
///   Type: REAL  
/// 
/// HISTORY New type in IFC Release 2x.
/// 
/// Figure 290 illustrates elastic support of a planar member.
/// 
/// Figure 290 — Modulus of subgrade reaction measure
class IfcModulusOfSubgradeReactionMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcModulusOfSubgradeReactionMeasure (IfcAbstractEntity* e);
    IfcModulusOfSubgradeReactionMeasure (double v);
    operator double() const;
};
/// IfcMoistureDiffusivityMeasure is a measure of moisture diffusivity.
/// Usually measured in m3/s.
/// Type: REAL
/// 
/// HISTORY New type in IFC Release 2x.
class IfcMoistureDiffusivityMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcMoistureDiffusivityMeasure (IfcAbstractEntity* e);
    IfcMoistureDiffusivityMeasure (double v);
    operator double() const;
};
/// IfcMolecularWeightMeasure is a measure of molecular weight of material (typically gas).
/// Usually measured in g/mole.
/// Type: REAL
/// 
/// HISTORY New type in IFC Release 2x.
class IfcMolecularWeightMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcMolecularWeightMeasure (IfcAbstractEntity* e);
    IfcMolecularWeightMeasure (double v);
    operator double() const;
};
/// IfcMomentOfInertiaMeasure is a measure of moment of inertia.
/// Usually measured in m4.
/// Type: REAL
/// 
/// HISTORY New type in IFC Release 2x.
class IfcMomentOfInertiaMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcMomentOfInertiaMeasure (IfcAbstractEntity* e);
    IfcMomentOfInertiaMeasure (double v);
    operator double() const;
};
/// A monetary measure is the value of an amount of money without regard to its currency.
/// Type: REAL
/// 
/// HISTORY New type in IFC Release 2.0.
class IfcMonetaryMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcMonetaryMeasure (IfcAbstractEntity* e);
    IfcMonetaryMeasure (double v);
    operator double() const;
};
/// Definition from IAI: The IfcDayInMonthNumber is
/// an integer that defines the position of the specified month in a
/// year. The positions have the following meaning (according to
/// ISO8601 "calendar month") that assigns the Calendar month number
/// to the Calender month name.
/// NOTE Refer to ISO 8601 for the definitions for
/// using the Gregorian calendar as the standard for the
/// identification of calendar days.
/// 
/// Calendar month number
/// Calendar month
/// name
/// 
/// 01
/// January
/// 
/// 02
/// February
/// 
/// 03
/// March
/// 
/// 04
/// April
/// 
/// 05
/// May
/// 
/// 06
/// June
/// 
/// 07
/// July
/// 
/// 08
/// August
/// 
/// 09
/// September
/// 
/// 10
/// October
/// 
/// 11
/// November
/// 
/// 12
/// December
/// 
/// Type: INTEGER
/// NOTE Corresponding STEP
/// name: month_in_year_number, please refer to ISO/IS 10303-41:1994
/// for the final definition of the formal
/// standard.
/// HISTORY New type in IFC
/// Release 1.5.1.
class IfcMonthInYearNumber : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcMonthInYearNumber (IfcAbstractEntity* e);
    IfcMonthInYearNumber (int v);
    operator int() const;
};
/// Definition from ISO/CD 10303-41:1992: A numeric measure is the numeric value of a physical quantity.
/// Type: NUMBER
/// 
/// NOTE Corresponding ISO 10303 name: numeric_measure, please refer to ISO/IS 10303-41 for the final definition of the formal standard.
/// 
/// HISTORY New type in IFC Release 1.5.1.
class IfcNumericMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcNumericMeasure (IfcAbstractEntity* e);
    IfcNumericMeasure (double v);
    operator double() const;
};
/// IfcPHMeasure is a measure of the molar hydrogen ion concentration in a liquid (usually defined as the measure of acidity) in a range from 0 to 14.
/// 
/// HISTORY: New type in IFC 2x2.
class IfcPHMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcPHMeasure (IfcAbstractEntity* e);
    IfcPHMeasure (double v);
    operator double() const;
};
/// Definition from ISO/CD 10303-41:1992: A parameter value is the value which specifies the amount of a 
/// parameter in some parameter space.
/// Type: REAL
/// 
/// NOTE Corresponding STEP name: parameter_value, please refer to ISO/IS 10303-41 for the final definition of the formal standard.
/// 
/// HISTORY New type in IFC Release 1.5.1.
class IfcParameterValue : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcParameterValue (IfcAbstractEntity* e);
    IfcParameterValue (double v);
    operator double() const;
};
/// IfcPlanarForceMeasure is a measure of force on an area.
/// Usually measured in N/m2.
/// Type: REAL
/// 
/// HISTORY New type in IFC Release 2x.
class IfcPlanarForceMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcPlanarForceMeasure (IfcAbstractEntity* e);
    IfcPlanarForceMeasure (double v);
    operator double() const;
};
/// Definition from ISO/CD 10303-41:1992: A plane angle measure is the value of an angle in a plane.
/// 
/// Usually measured in radian (rad, m/m = 1), but also grads may be used. The grad unit may be declared as a conversion based unit based on radian unit.
/// 
/// NOTE IfcPlaneAngleMeasure is used where angles need to be described to an accuracy of less than one degree and expressed as decimal parts of an angle. It is widely used for angular measurement except for situations where accuracy needs to be defined using arc measurement; for which purpose the IfcCompoundPlaneAngleMeasure is provided.
/// 
/// Type: REAL
/// 
/// NOTE Corresponding ISO 10303 name: plane_angle_measure, please refer to ISO/IS 10303-41 for the final definition of the formal standard.
/// 
/// HISTORY New type in IFC Release 1.5.1.
class IfcPlaneAngleMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcPlaneAngleMeasure (IfcAbstractEntity* e);
    IfcPlaneAngleMeasure (double v);
    operator double() const;
};
/// Definition from ISO/CD 10303-41:1992: A positive length measure is a length measure that is greater than zero.
/// Type: IfcLengthMeasure
/// 
/// NOTE Corresponding ISO 10303 name: positive_length_measure, please refer to ISO/IS 10303-41 for the final definition of the formal standard.
/// 
/// HISTORY New type in IFC Release 1.5.1.
class IfcPositiveLengthMeasure : public IfcLengthMeasure {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcPositiveLengthMeasure (IfcAbstractEntity* e);
    IfcPositiveLengthMeasure (double v);
    operator double() const;
};
/// Definition from ISO/CD 10303-41:1992: Positive plane angle measure is a plane angle measure that is greater than zero.
/// Type: IfcPlaneAngleMeasure 
/// 
/// NOTE Corresponding STEP name: positive_plane_angle_measure, please refer to ISO/IS 10303-41 for the final definition of the formal standard.
/// 
/// HISTORY New type in IFC Release 1.5.1.
class IfcPositivePlaneAngleMeasure : public IfcPlaneAngleMeasure {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcPositivePlaneAngleMeasure (IfcAbstractEntity* e);
    IfcPositivePlaneAngleMeasure (double v);
    operator double() const;
};
/// IfcPowerMeasure is a measure of power required or used.
/// Usually measured in Watts (W, J/s).
/// Type: REAL
/// 
/// HISTORY New type in IFC Release 2.0.
class IfcPowerMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcPowerMeasure (IfcAbstractEntity* e);
    IfcPowerMeasure (double v);
    operator double() const;
};
/// IfcPresentableText is a text string used to capture the content of a text literal for the purpose of presentation. The IfcPresentableText can include multiple lines of text, for which the line feed character LF, 0x0A, should be used to separate lines.
/// 
/// NOTE  The non printable characters are converted within the standard exchange format ISO 10303-21 (STEP physical file format), commonly the \X\09 represents the TAB, and \X\0A the LF character.
/// 
/// NOTE  The IfcPresentableText is an entity that had been adopted from ISO 10303, Industrial automation systems and integration—Product data representation and exchange, Part 46: Integrated generic resources: Visual presentation.
/// 
/// NOTE  Corresponding ISO 10303 name: presentable_text. Please refer to ISO/IS 10303-46:1994, p. 133 for the final definition of the formal standard.
/// 
/// HISTORY  New type in IFC2x2.
class IfcPresentableText : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcPresentableText (IfcAbstractEntity* e);
    IfcPresentableText (std::string v);
    operator std::string() const;
};
/// IfcPressureMeasure is a measure of the quantity of a medium acting on a unit area.
/// Usually measured in Pascals (Pa, N/m2).
/// Type: REAL
/// 
/// HISTORY New type in IFC Release 2.0.
class IfcPressureMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcPressureMeasure (IfcAbstractEntity* e);
    IfcPressureMeasure (double v);
    operator double() const;
};
/// IfcRadioActivityMeasure is a measure of activity of radionuclide.
/// Usually measured in Becquerel (Bq, 1/s).
/// Type: REAL
/// 
/// HISTORY New type in IFC Release 2x.
class IfcRadioActivityMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcRadioActivityMeasure (IfcAbstractEntity* e);
    IfcRadioActivityMeasure (double v);
    operator double() const;
};
/// Definition from ISO/CD 10303-41:1992: A ratio measure is the value of the relation between two 
/// physical quantities that are of the same kind.
/// 
/// NOTE: Input given in percent is to be divided by 100% when stored as an IfcRatioMeasure. For example, 25% becomes 0.25.
/// 
/// Type: REAL
/// 
/// NOTE Corresponding STEP name: ratio_measure, please refer to ISO/IS 10303-41 for the final definition of the formal standard.
/// 
/// HISTORY New type in IFC Release 1.5.1.
class IfcRatioMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcRatioMeasure (IfcAbstractEntity* e);
    IfcRatioMeasure (double v);
    operator double() const;
};
/// IfcReal is a defined type of simple data type REAL.  It is required since a select type (IfcSimpleValue), cannot directly include simple types in its select list.
/// 
/// In principle, the domain of IfcReal (being a Real) is all rational, irrational and scientific real numbers. Here the precision is unconstrained, but in practice it is implementation specific.
/// 
/// Type: REAL
/// 
/// HISTORY: New type in IFC Release 1.5.1.
class IfcReal : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcReal (IfcAbstractEntity* e);
    IfcReal (double v);
    operator double() const;
};
/// IfcRotationalFrequencyMeasure is a measure of the number of cycles that an item revolves in unit time.
/// Usually measured in cycles/s.
/// Type: REAL
/// 
/// HISTORY New type in IFC Release 2x.
class IfcRotationalFrequencyMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcRotationalFrequencyMeasure (IfcAbstractEntity* e);
    IfcRotationalFrequencyMeasure (double v);
    operator double() const;
};
/// The rotational mass measure denotes the inertia of a body with respect to angular acceleration.
/// It is usually measured in kg*m^2.
/// 
/// Type: REAL  
/// 
/// HISTORY New type in IFC2x2.
class IfcRotationalMassMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcRotationalMassMeasure (IfcAbstractEntity* e);
    IfcRotationalMassMeasure (double v);
    operator double() const;
};
/// IfcRotationalStiffnessMeasure is a measure of rotational stiffness.
/// Usually measured in Nm/rad.
/// Type: REAL
/// 
/// HISTORY New type in IFC Release 2x.
class IfcRotationalStiffnessMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcRotationalStiffnessMeasure (IfcAbstractEntity* e);
    IfcRotationalStiffnessMeasure (double v);
    operator double() const;
};

class IfcSecondInMinute : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcSecondInMinute (IfcAbstractEntity* e);
    IfcSecondInMinute (double v);
    operator double() const;
};
/// IfcSectionModulusMeasure is a measure for the resistance of a cross section against bending or torsional moment.  It is usually measured in m^3.
/// 
/// Type: REAL 
/// 
/// HISTORY New type in IFC Release 2x2.
class IfcSectionModulusMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcSectionModulusMeasure (IfcAbstractEntity* e);
    IfcSectionModulusMeasure (double v);
    operator double() const;
};
/// The sectional area integral measure is typically used in torsional analysis. It is usually measured in m^5.
/// 
/// Type: REAL  
/// 
/// HISTORY New type in IFC2x2.
class IfcSectionalAreaIntegralMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcSectionalAreaIntegralMeasure (IfcAbstractEntity* e);
    IfcSectionalAreaIntegralMeasure (double v);
    operator double() const;
};
/// IfcShearModulusMeasure is a measure of shear modulus.
/// Usually measured in N/m2.
/// Type: REAL
/// 
/// HISTORY New type in IFC Release 2x.
class IfcShearModulusMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcShearModulusMeasure (IfcAbstractEntity* e);
    IfcShearModulusMeasure (double v);
    operator double() const;
};
/// Definition from ISO/CD 10303-41:1992: A solid angle measure is the value of an angle in a solid.
/// Usually measured in Steradians, (sr, m2/m2).
/// Type: REAL
/// 
/// NOTE Corresponding ISO 10303 name: solid_angle_measure, please refer to ISO/IS 10303-41 for the final definition of the formal standard.
/// 
/// HISTORY New type in IFC Release 1.5.1.
class IfcSolidAngleMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcSolidAngleMeasure (IfcAbstractEntity* e);
    IfcSolidAngleMeasure (double v);
    operator double() const;
};
/// A sound power measure is a measure of total radiated noise with units of decibels with a reference value of picowatts.
/// 
/// Type: REAL  
/// 
/// HISTORY New type in IFC2x2.
class IfcSoundPowerMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcSoundPowerMeasure (IfcAbstractEntity* e);
    IfcSoundPowerMeasure (double v);
    operator double() const;
};
/// A sound pressure measure is a measure of the pressure fluctuations superimposed over the ambient pressure level with units of decibels with a reference value of micropascals. 
/// 
/// Type: REAL  
/// 
/// HISTORY New type in IFC2x2.
class IfcSoundPressureMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcSoundPressureMeasure (IfcAbstractEntity* e);
    IfcSoundPressureMeasure (double v);
    operator double() const;
};
/// IfcSpecificHeatCapacityMeasure defines the specific heat of material: The heat energy absorbed per temperature unit.
/// Usually measured in J / kg Kelvin.
/// Type: REAL
/// 
/// HISTORY New type in IFC Release 2x.
class IfcSpecificHeatCapacityMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcSpecificHeatCapacityMeasure (IfcAbstractEntity* e);
    IfcSpecificHeatCapacityMeasure (double v);
    operator double() const;
};
/// The IfcSpecularExponent defines the datatype for exponent determining the sharpness of the 'reflection'. reflection is made sharper with large values of the exponent, such as 10.0. Small values, such as 1.0, decrease the specular fall-off. 
/// 
/// IfcSpecularExponent is of type REAL.
/// 
/// NOTE: The datatype relates to the definition of specular_exponent in ISO 10303-46 entity surface_style_reflectance_ambient_diffuse_specular.
/// 
/// HISTORY: New type in IFC2x2.
class IfcSpecularExponent : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcSpecularExponent (IfcAbstractEntity* e);
    IfcSpecularExponent (double v);
    operator double() const;
};
/// The IfcSpecularRoughness defines the datatype for the reflection resulting from the roughness of a surface through the height of surface impurities where the specular highlight is made sharper with small values for the roughness, such as 0.1.  
/// 
/// Applies to "glass", "metal", "mirror" and "plastic" reflection models. Larger values, close to 1.0 decrease the specular fall-off. 
/// 
/// IfcSpecularRoughness is of type REAL. It is constraint to values between (and including) 0 and 1.
/// 
/// NOTE: The datatype relates to the definition of "shiness" in VRML97, which is the reciprocate value to the specular roughness.
/// 
/// HISTORY: New type in Release IFC2x2.
class IfcSpecularRoughness : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcSpecularRoughness (IfcAbstractEntity* e);
    IfcSpecularRoughness (double v);
    operator double() const;
};
/// The temperature gradient measures the difference of a temperature per lenght, as for instance used in an external wall or its layers.  It is usually measured in K/m.
/// 
/// Type: REAL  
/// 
/// HISTORY New type in IFC2x2.
class IfcTemperatureGradientMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcTemperatureGradientMeasure (IfcAbstractEntity* e);
    IfcTemperatureGradientMeasure (double v);
    operator double() const;
};
/// Definition from ISO/CD 10303-41:1992: A text is an alphanumeric string of characters which is intended to be read and understood by a human being. It is for information purposes only.
/// 
/// Type: STRING
/// 
/// NOTE Corresponding STEP name: text, please refer to ISO/IS 10303-41 for the final definition of the formal standard.
/// 
/// HISTORY New type in IFC Release 2x.
/// 
/// Per ISO 10303-11, the set of characters that may appear in STRINGs is defined in ISO 10646.  The encoding of characters in case of file-based exchange is defined in ISO 10303-21 (STEP physical files) and ISO 10303-28 (XML files).  Among else, these specifications define the encoding of 8-bit characters from ISO 8859-1...-16 and of 2-byte Unicode characters.
/// 
/// Note that while IfcText is not formally restricted in length, the size of a string in ISO 10303-21:2002 conforming exchange files must not exceed 32767 octets after encoding and escaping.
class IfcText : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcText (IfcAbstractEntity* e);
    IfcText (std::string v);
    operator std::string() const;
};
/// Definition from CSS1 (W3C Recommendation): This property describes how text is aligned within the element. The actual justification algorithm used is user agent and human language dependent. If 'justify' is not supported, the user agent will supply a replacement. Typically, this will be 'left' for western languages. Values are:
/// 
/// left
///   right
///   center
///   justify
/// 
/// NOTE  Corresponding CSS1 definition is text-align.
/// 
/// HISTORY  New type in IFC2x3.
class IfcTextAlignment : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcTextAlignment (IfcAbstractEntity* e);
    IfcTextAlignment (std::string v);
    operator std::string() const;
};
/// Definition from CSS1 (W3C Recommendation): This property describes decorations that are added to the text of an element. A value of 'blink' causes the text to blink.. Values are:
/// 
/// none
///   underline
///   overline
///   line-through
///   blink
/// 
/// User agents must recognize the keyword 'blink', but are not required to support the blink effect.
/// 
/// NOTE  Corresponding CSS1 definition is text-decoration.
/// 
/// HISTORY  New type in IFC2x3.
class IfcTextDecoration : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcTextDecoration (IfcAbstractEntity* e);
    IfcTextDecoration (std::string v);
    operator std::string() const;
};
/// Definition from CSS1 (W3C Recommendation): The value is a font family name and/or generic family name. Values are:
/// 
/// The name of a font family of choice. For example, "gill" and "helvetica" are font families.
/// 
/// In the example above, the last value is a generic family name. The following generic families are defined:
/// 
/// 'serif' (Example: Times)
///   'sans-serif' (Example: Helvetica)
///   'cursive' (Example: Zapf-Chancery)
///   'fantasy' (Example: Western)
///   'monospace' (Example: Courier)
/// 
/// It is encouraged to offer a generic font family as a last alternative.
/// 
/// NOTE  Corresponding CSS1 definitions are font-family.
/// 
/// HISTORY  New type in IFC2x2 Addendum 2.
/// 
/// IFC2x2 Addendum 2 CHANGE: The IfcFontFamily has been added.
class IfcTextFontName : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcTextFontName (IfcAbstractEntity* e);
    IfcTextFontName (std::string v);
    operator std::string() const;
};
/// Definition from CSS1 (W3C Recommendation): This property describes how the cases of characters are handled. Values are:
/// 
/// capitalize: uppercases the first character of each word
///   uppercase: uppercases all letters of the element
///   lowercase: lowercases all letters of the element
///   none
/// 
/// NOTE  Corresponding CSS1 definition is text-transform.
/// 
/// HISTORY  New type in IFC2x3.
class IfcTextTransformation : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcTextTransformation (IfcAbstractEntity* e);
    IfcTextTransformation (std::string v);
    operator std::string() const;
};
/// IfcThermalAdmittanceMeasure is the measure of the ability of a surface to smooth out temperature variations.
/// Usually measured in Watt / m2 Kelvin.
/// Type: REAL
/// 
/// HISTORY New type in IFC Release 2.0.
class IfcThermalAdmittanceMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcThermalAdmittanceMeasure (IfcAbstractEntity* e);
    IfcThermalAdmittanceMeasure (double v);
    operator double() const;
};
/// IfcThermalConductivityMeasure is a measure of thermal conductivity.
/// Usually measured in Watt / m Kelvin.
/// Type: REAL
/// 
/// HISTORY New type in IFC Release 2x.
class IfcThermalConductivityMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcThermalConductivityMeasure (IfcAbstractEntity* e);
    IfcThermalConductivityMeasure (double v);
    operator double() const;
};
/// IfcThermalExpansionCoeffientMeasure is a measure of the thermal expansion coefficient of a material, which expresses its elongation (as a ratio) per temperature difference. It is usually measured in 1/K. A positive elongation per (positive) rise of temperature is expressed by a positive value.
/// Type: REAL  
/// 
/// HISTORY New type in IFC2x2.
class IfcThermalExpansionCoefficientMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcThermalExpansionCoefficientMeasure (IfcAbstractEntity* e);
    IfcThermalExpansionCoefficientMeasure (double v);
    operator double() const;
};
/// IfcThermalResistanceMeasure is a measure of the resistance offered by a body to the flow of energy.
/// Usually measured in m2 Kelvin/Watt.
/// 
/// HISTORY New type in IFC Release 2.0.
class IfcThermalResistanceMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcThermalResistanceMeasure (IfcAbstractEntity* e);
    IfcThermalResistanceMeasure (double v);
    operator double() const;
};
/// IfcThermalTransmittanceMeasure is a measure of the rate at which energy is transmitted through a body.
/// Usually measured in Watts/m2 Kelvin.
/// Type: REAL
/// 
/// HISTORY New type in IFC Release 2.0.
class IfcThermalTransmittanceMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcThermalTransmittanceMeasure (IfcAbstractEntity* e);
    IfcThermalTransmittanceMeasure (double v);
    operator double() const;
};
/// Definition from ISO/CD 10303-41:1992: A thermodynamic temperature measure is the value for the degree of heat of a body.
/// Usually measured in degrees Kelvin (K).
/// Type: REAL
/// 
/// NOTE Corresponding ISO 10303 name: thermodynamic_temperature_measure, please refer to ISO/IS 10303-41 for the final definition of the formal standard.
/// 
/// HISTORY New type in IFC Release 1.5.1.
class IfcThermodynamicTemperatureMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcThermodynamicTemperatureMeasure (IfcAbstractEntity* e);
    IfcThermodynamicTemperatureMeasure (double v);
    operator double() const;
};
/// Definition from ISO/CD 10303-41:1992: A time measure is the value of the duration of periods.
/// Measured in seconds (s) or days (d) or other units of time.
/// Type: REAL
/// 
/// NOTE Corresponding ISO 10303 name: time_measure, please refer to ISO/IS 10303-41 for the final definition of the formal standard.
/// 
/// HISTORY New type in IFC Release 1.5.1.
class IfcTimeMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcTimeMeasure (IfcAbstractEntity* e);
    IfcTimeMeasure (double v);
    operator double() const;
};
/// IfcTimeStamp is an indication of date and time by measuring the number of seconds which have elapsed since the beginning of the year 1970.
/// Type: INTEGER
/// 
/// HISTORY New type in IFC Release 1.5.1.
class IfcTimeStamp : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcTimeStamp (IfcAbstractEntity* e);
    IfcTimeStamp (int v);
    operator int() const;
};
/// IfcTorqueMeasure is a measure of the torque or moment of a couple.
/// Usually measured in N m.
/// Type: REAL
/// 
/// HISTORY New type in IFC Release 2x.
class IfcTorqueMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcTorqueMeasure (IfcAbstractEntity* e);
    IfcTorqueMeasure (double v);
    operator double() const;
};
/// IfcVaporPermeabilityMeasure is a measure of vapor permeability.
/// Usually measured in kg / s m Pascal.
/// Type: REAL
/// 
/// HISTORY New type in IFC Release 2x.
class IfcVaporPermeabilityMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcVaporPermeabilityMeasure (IfcAbstractEntity* e);
    IfcVaporPermeabilityMeasure (double v);
    operator double() const;
};
/// Definition from ISO/CD 10303-41:1992: A volume measure is the value of the solid content of a body.
/// Usually measured in cubic metre (m3).
/// Type: REAL
/// 
/// NOTE Corresponding ISO 10303 name: volume_measure, please refer to ISO/IS 10303-41 for the final definition of the formal standard.
/// 
/// HISTORY New type in IFC Release 1.5.1.
class IfcVolumeMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcVolumeMeasure (IfcAbstractEntity* e);
    IfcVolumeMeasure (double v);
    operator double() const;
};
/// IfcVolumetricFlowRateMeasure is a measure of the volume of a medium flowing per unit time.
/// Usually measured in m3/s.
/// Type: REAL
/// 
/// HISTORY New type in IFC Release 2.0.
class IfcVolumetricFlowRateMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcVolumetricFlowRateMeasure (IfcAbstractEntity* e);
    IfcVolumetricFlowRateMeasure (double v);
    operator double() const;
};
/// IfcWarpingConstantMeasure is a measure for the warping constant or warping resistance of a cross section under torsional loading. It is usually measured in m^6.
/// 
/// Type: REAL  
/// 
/// HISTORY New type in IFC2x2.
class IfcWarpingConstantMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcWarpingConstantMeasure (IfcAbstractEntity* e);
    IfcWarpingConstantMeasure (double v);
    operator double() const;
};
/// The warping moment measure is a measure for the warping moment, which occurs in warping torsional analysis. It is usually measured in kN*m^2.
/// 
/// Type: REAL  
/// 
/// HISTORY New type in IFC2x2.
class IfcWarpingMomentMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcWarpingMomentMeasure (IfcAbstractEntity* e);
    IfcWarpingMomentMeasure (double v);
    operator double() const;
};

class IfcYearNumber : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcYearNumber (IfcAbstractEntity* e);
    IfcYearNumber (int v);
    operator int() const;
};
/// The box alignment specifies the alignment of the text box relative to its position. The following string values shall be used:
/// 
/// top-left
///   top-middle
///   top-right
///   middle-left
///   center
///   middle-right
///   bottom-left
///   bottom-middle
///   bottom-right
/// 
/// NOTE  The top-left is the default value.
/// 
/// Figure 298 illustrates alignment values.
/// 
/// Figure 298 — Box alignment values
/// 
/// Figure 299 illustrates use of alignment values together with the placement and planar extent.
/// 
/// Figure 299 — Box alignment examples
/// 
/// HISTORY  New type in IFC2x2 Addendum2.
/// 
/// IFC2x3 CHANGE  The IfcBoxAlignment has been added.
class IfcBoxAlignment : public IfcLabel {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcBoxAlignment (IfcAbstractEntity* e);
    IfcBoxAlignment (std::string v);
    operator std::string() const;
};
/// IfcNormalisedRatioMeasure is a dimensionless measure to express ratio values ranging from 0.0 to 1.0.
/// 
/// Type: REAL
/// 
/// HISTORY New type in IFC Release 2x.
class IfcNormalisedRatioMeasure : public IfcRatioMeasure {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcNormalisedRatioMeasure (IfcAbstractEntity* e);
    IfcNormalisedRatioMeasure (double v);
    operator double() const;
};
/// Definition from ISO/CD 10303-41:1992: A positive ratio measure is a ratio measure that is greater than zero.
/// Type: IfcRatioMeasure
/// 
/// NOTE Corresponding ISO 10303 name: positive_ratio_measure, please refer to ISO/IS 10303-41 for the final definition of the formal standard.
/// 
/// HISTORY New type in IFC Release 1.5.1.
class IfcPositiveRatioMeasure : public IfcRatioMeasure {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcPositiveRatioMeasure (IfcAbstractEntity* e);
    IfcPositiveRatioMeasure (double v);
    operator double() const;
};


/// Definition: A role which is performed by an actor, either a person, an organization or a 
/// person related to an organization.
/// 
/// NOTE: The list of roles of the enumeration values of the Role attribute can never
/// be complete. Therefore using enumeration value USERDEFINED, the user can provide his/her own role as a value 
/// of the attribute UserDefinedRole.
/// 
/// Corresponds to the following entity in ISO-10303-41: organization_role and person_role.
/// 
/// HISTORY New entity in IFC Release 1.5.1
class IfcActorRole : public IfcUtil::IfcBaseEntity {
public:
    /// The name of the role played by an actor. If the Role has value USERDEFINED, then
    /// the user defined role shall be provided as a value of the attribute UserDefinedRole.
    IfcRoleEnum::IfcRoleEnum Role() const;
    void setRole(IfcRoleEnum::IfcRoleEnum v);
    /// Whether the optional attribute UserDefinedRole is defined for this IfcActorRole
    bool hasUserDefinedRole() const;
    /// Allows for specification of user defined roles beyond the 
    /// enumeration values provided by Role attribute of type IfcRoleEnum. 
    /// When a value is provided for attribute UserDefinedRole in parallel 
    /// the attribute Role shall have enumeration value USERDEFINED.
    std::string UserDefinedRole() const;
    void setUserDefinedRole(std::string v);
    /// Whether the optional attribute Description is defined for this IfcActorRole
    bool hasDescription() const;
    /// A textual description relating the nature of the role played by an actor.
    std::string Description() const;
    void setDescription(std::string v);
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENUMERATION; case 1: return IfcUtil::Argument_STRING; case 2: return IfcUtil::Argument_STRING; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcRoleEnum; case 1: return Type::IfcLabel; case 2: return Type::IfcText; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Role"; case 1: return "UserDefinedRole"; case 2: return "Description"; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcActorRole (IfcAbstractEntity* e);
    IfcActorRole (IfcRoleEnum::IfcRoleEnum v1_Role, boost::optional< std::string > v2_UserDefinedRole, boost::optional< std::string > v3_Description);
    typedef IfcTemplatedEntityList< IfcActorRole > list;
};
/// Definition: An abstract entity type for various kinds of postal and telecom addresses.
/// 
/// NOTE Corresponds to the following entity in ISO-10303-41: address.
/// 
/// HISTORY New entity in IFC Release 1.5.1.
class IfcAddress : public IfcUtil::IfcBaseEntity {
public:
    /// Whether the optional attribute Purpose is defined for this IfcAddress
    bool hasPurpose() const;
    /// Identifies the logical location of the address.
    IfcAddressTypeEnum::IfcAddressTypeEnum Purpose() const;
    void setPurpose(IfcAddressTypeEnum::IfcAddressTypeEnum v);
    /// Whether the optional attribute Description is defined for this IfcAddress
    bool hasDescription() const;
    /// Text that relates the nature of the address.
    std::string Description() const;
    void setDescription(std::string v);
    /// Whether the optional attribute UserDefinedPurpose is defined for this IfcAddress
    bool hasUserDefinedPurpose() const;
    /// Allows for specification of user specific purpose of the address beyond the 
    /// enumeration values provided by Purpose attribute of type IfcAddressTypeEnum. 
    /// When a value is provided for attribute UserDefinedPurpose, in parallel the 
    /// attribute Purpose shall have enumeration value USERDEFINED.
    std::string UserDefinedPurpose() const;
    void setUserDefinedPurpose(std::string v);
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENUMERATION; case 1: return IfcUtil::Argument_STRING; case 2: return IfcUtil::Argument_STRING; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcAddressTypeEnum; case 1: return Type::IfcText; case 2: return Type::IfcLabel; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Purpose"; case 1: return "Description"; case 2: return "UserDefinedPurpose"; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcPerson >::ptr OfPerson() const; // INVERSE IfcPerson::Addresses
    IfcTemplatedEntityList< IfcOrganization >::ptr OfOrganization() const; // INVERSE IfcOrganization::Addresses
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcAddress (IfcAbstractEntity* e);
    IfcAddress (boost::optional< IfcAddressTypeEnum::IfcAddressTypeEnum > v1_Purpose, boost::optional< std::string > v2_Description, boost::optional< std::string > v3_UserDefinedPurpose);
    typedef IfcTemplatedEntityList< IfcAddress > list;
};
/// IfcApplication holds the information about an IFC compliant application developed by an application developer. The IfcApplication utilizes a short identifying name as provided by the application developer.
/// 
/// HISTORY  New entity in IFC R1.5.
class IfcApplication : public IfcUtil::IfcBaseEntity {
public:
    /// Name of the application developer, being requested to be member of the IAI.
    IfcOrganization* ApplicationDeveloper() const;
    void setApplicationDeveloper(IfcOrganization* v);
    /// The version number of this software as specified by the developer of the application.
    std::string Version() const;
    void setVersion(std::string v);
    /// The full name of the application as specified by the application developer.
    std::string ApplicationFullName() const;
    void setApplicationFullName(std::string v);
    /// Short identifying name for the application.
    std::string ApplicationIdentifier() const;
    void setApplicationIdentifier(std::string v);
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_STRING; case 2: return IfcUtil::Argument_STRING; case 3: return IfcUtil::Argument_STRING; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcOrganization; case 1: return Type::IfcLabel; case 2: return Type::IfcLabel; case 3: return Type::IfcIdentifier; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "ApplicationDeveloper"; case 1: return "Version"; case 2: return "ApplicationFullName"; case 3: return "ApplicationIdentifier"; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcApplication (IfcAbstractEntity* e);
    IfcApplication (IfcOrganization* v1_ApplicationDeveloper, std::string v2_Version, std::string v3_ApplicationFullName, std::string v4_ApplicationIdentifier);
    typedef IfcTemplatedEntityList< IfcApplication > list;
};
/// IfcAppliedValue is an abstract supertype that specifies the common attributes for cost values. 
/// 
/// HISTORY: New Entity in IFC2x2.  Modifed in IFC2x4 to use IfcDate for date values.
/// 
/// Use definitions 
/// The extent of the IfcAppliedValue is determined by the AppliedValue attribute which may be defined either as an IfcMeasureWithUnit or as an IfcMonetaryMeasure or as an IfcRatioMeasure via the IfcAppliedValueSelect type.  
/// 
/// Optionally, an IfcAppliedValue may have an applicable date. This is intended to fix the date on which the value became relevant for use. It may be the date on which the value was set in the model or it may be a prior or future date when the value becomes operable.
/// 
/// Similarly, an IfcAppliedValue may have a 'fixed until' date. This is intended to fix the date on which the value ceases to be relevant for use. 
/// 
/// An instance of IfcAppliedValue may have a unit basis asserted.  This is defined as an IfcMeasureWithUnit that determines the extent of the unit value for application purposes. It is assumed that when this attribute is asserted, then the value given to IfcAppliedValue is that for unit quantity. This is not enforced within the IFC schema and thus needs to be controlled within an application.
/// 
/// Applied values may be referenced from a document (such as a price list). The relationship between one or more occurrences of IfcAppliedValue (or its subtypes) is achieved through the use of the IfcExternalReferenceRelationship in which the document provides the IfcExternalReferenceRelationship.RelatingExtReference and the value occurrences are the IfcExternalReferenceRelationship.RelatedResourceObjects.
class IfcAppliedValue : public IfcUtil::IfcBaseEntity {
public:
    /// Whether the optional attribute Name is defined for this IfcAppliedValue
    bool hasName() const;
    /// A name or additional clarification given to a cost value.
    std::string Name() const;
    void setName(std::string v);
    /// Whether the optional attribute Description is defined for this IfcAppliedValue
    bool hasDescription() const;
    /// The description that may apply additional information about a cost value.
    std::string Description() const;
    void setDescription(std::string v);
    /// Whether the optional attribute AppliedValue is defined for this IfcAppliedValue
    bool hasAppliedValue() const;
    /// The extent or quantity or amount of an applied value.
    IfcAppliedValueSelect* AppliedValue() const;
    void setAppliedValue(IfcAppliedValueSelect* v);
    /// Whether the optional attribute UnitBasis is defined for this IfcAppliedValue
    bool hasUnitBasis() const;
    /// The number and unit of measure on which the unit cost is based.
    /// 
    /// Note: As well as the normally expected units of measure such as length, area, volume etc., costs may be based on units of measure which need to be defined e.g. sack, drum, pallet, item etc. Unit costs may be based on quantities greater (or lesser) than a unitary value of the basis measure. For instance, timber may have a unit cost rate per X meters where X > 1; similarly for cable, piping and many other items. The basis number may be either an integer or a real value.
    /// 
    /// Note: This attribute should be asserted for all circumstances where the cost to be applied is per unit quantity. It may be asserted even for circumstances where an item price is used, in which case the unit cost basis should be by item (or equivalent definition).
    IfcMeasureWithUnit* UnitBasis() const;
    void setUnitBasis(IfcMeasureWithUnit* v);
    /// Whether the optional attribute ApplicableDate is defined for this IfcAppliedValue
    bool hasApplicableDate() const;
    /// The date on or from which an applied value is applicable.
    /// 
    /// IFC2x4 CHANGE Type changed from IfcDateTimeSelect.
    IfcDateTimeSelect* ApplicableDate() const;
    void setApplicableDate(IfcDateTimeSelect* v);
    /// Whether the optional attribute FixedUntilDate is defined for this IfcAppliedValue
    bool hasFixedUntilDate() const;
    /// The date until which applied value is applicable.
    /// 
    /// IFC2x4 CHANGE Type changed from IfcDateTimeSelect.
    IfcDateTimeSelect* FixedUntilDate() const;
    void setFixedUntilDate(IfcDateTimeSelect* v);
    virtual unsigned int getArgumentCount() const { return 6; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_STRING; case 1: return IfcUtil::Argument_STRING; case 2: return IfcUtil::Argument_ENTITY_INSTANCE; case 3: return IfcUtil::Argument_ENTITY_INSTANCE; case 4: return IfcUtil::Argument_ENTITY_INSTANCE; case 5: return IfcUtil::Argument_ENTITY_INSTANCE; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcLabel; case 1: return Type::IfcText; case 2: return Type::IfcAppliedValueSelect; case 3: return Type::IfcMeasureWithUnit; case 4: return Type::IfcDateTimeSelect; case 5: return Type::IfcDateTimeSelect; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Name"; case 1: return "Description"; case 2: return "AppliedValue"; case 3: return "UnitBasis"; case 4: return "ApplicableDate"; case 5: return "FixedUntilDate"; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcReferencesValueDocument >::ptr ValuesReferenced() const; // INVERSE IfcReferencesValueDocument::ReferencingValues
    IfcTemplatedEntityList< IfcAppliedValueRelationship >::ptr ValueOfComponents() const; // INVERSE IfcAppliedValueRelationship::ComponentOfTotal
    IfcTemplatedEntityList< IfcAppliedValueRelationship >::ptr IsComponentIn() const; // INVERSE IfcAppliedValueRelationship::Components
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcAppliedValue (IfcAbstractEntity* e);
    IfcAppliedValue (boost::optional< std::string > v1_Name, boost::optional< std::string > v2_Description, IfcAppliedValueSelect* v3_AppliedValue, IfcMeasureWithUnit* v4_UnitBasis, IfcDateTimeSelect* v5_ApplicableDate, IfcDateTimeSelect* v6_FixedUntilDate);
    typedef IfcTemplatedEntityList< IfcAppliedValue > list;
};
/// An IfcAppliedValueRelationship is a relationship class that enables cost values to be aggregated together as components of another cost value.
/// 
/// HISTORY  New Entity in Release IFC2.0.
/// 
/// IFC2x4 CHANGE  Subtyped from IfcResourceLevelRelationship, attribute order changed.
/// 
/// Use definitions
/// Dependency relationships can exist between applied values on the basis that one particular value may be determined by operations on one or more other values. This is captured through the IfcAppliedValueRelationship entity. In this relationship, one instance of IfcAppliedValue acts as the principal (IfcAppliedValueRelationship.ComponentOf) whose value may be
/// determined from the instances of IfcAppliedValue that are defined as its components
/// (IfcAppliedValueRelationship.Components)
/// An IfcAppliedValueRelationship has an ArithmeticOperator attribute that specifies the form of arithmetical operation implied by the relationship.
/// A practical consideration when using the applied value relationship is that when the arithmetic operator is ADD, then the
/// type of the IfcAppliedValue.AppliedValue attribute will be IfcMeasureWithUnit or IfcMonetaryMeasure while if the arithmetic operator is MULTIPLY, then the type of the IfcAppliedValue.AppliedValue attribute for one instance of
/// IfcAppliedValue will be IfcMeasureWithUnit or IfcMonetaryMeasure while for other instances it will be
/// IfcRatioMeasure.
/// If the arithmetic operator is SUBTRACT or DIVIDE then there can only be two occurrences of IfcAppliedValue that can contribute and the order in which they occur is significant. The value of (A - B) will usually differ from the value of (B - A) whilst (X / Y) is the reciprocal of (Y / X).
/// 
/// Figure 239 illustrates one level aggregation of applied values. A relationship exists between applied value A and applied values B, C and D such that the value of A is determined by the addition of B, C and D such that: A = B + C + D
/// 
/// Figure 239 — Applied value relationship single level
/// 
/// Figure 240 illustrates two level aggregation of applied values. It is possible to develop more complex applied value specifications by creating hierarchies of applied value relationships. In the diagram, the development of a applied value is shown whereby, because B = E * F and D = G * H * J, then: A = ((E * F) + C + (G * H * J)).
/// 
/// Figure 240 — Applied value relationship multiple level
class IfcAppliedValueRelationship : public IfcUtil::IfcBaseEntity {
public:
    /// The applied value (total or subtotal) of which the value being considered is a component.
    IfcAppliedValue* ComponentOfTotal() const;
    void setComponentOfTotal(IfcAppliedValue* v);
    /// Applied values that are components of another applied value and from which that applied value may be deduced.
    IfcTemplatedEntityList< IfcAppliedValue >::ptr Components() const;
    void setComponents(IfcTemplatedEntityList< IfcAppliedValue >::ptr v);
    /// The arithmetic operator applied in an applied value relationship.
    IfcArithmeticOperatorEnum::IfcArithmeticOperatorEnum ArithmeticOperator() const;
    void setArithmeticOperator(IfcArithmeticOperatorEnum::IfcArithmeticOperatorEnum v);
    /// Whether the optional attribute Name is defined for this IfcAppliedValueRelationship
    bool hasName() const;
    std::string Name() const;
    void setName(std::string v);
    /// Whether the optional attribute Description is defined for this IfcAppliedValueRelationship
    bool hasDescription() const;
    std::string Description() const;
    void setDescription(std::string v);
    virtual unsigned int getArgumentCount() const { return 5; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 2: return IfcUtil::Argument_ENUMERATION; case 3: return IfcUtil::Argument_STRING; case 4: return IfcUtil::Argument_STRING; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcAppliedValue; case 1: return Type::IfcAppliedValue; case 2: return Type::IfcArithmeticOperatorEnum; case 3: return Type::IfcLabel; case 4: return Type::IfcText; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "ComponentOfTotal"; case 1: return "Components"; case 2: return "ArithmeticOperator"; case 3: return "Name"; case 4: return "Description"; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcAppliedValueRelationship (IfcAbstractEntity* e);
    IfcAppliedValueRelationship (IfcAppliedValue* v1_ComponentOfTotal, IfcTemplatedEntityList< IfcAppliedValue >::ptr v2_Components, IfcArithmeticOperatorEnum::IfcArithmeticOperatorEnum v3_ArithmeticOperator, boost::optional< std::string > v4_Name, boost::optional< std::string > v5_Description);
    typedef IfcTemplatedEntityList< IfcAppliedValueRelationship > list;
};
/// Definition: An IfcApproval represents information about approval processes such as for a plan, a design, a proposal, or a change order in a construction or facilities management project. IfcApproval is referenced by IfcRelAssociatesApproval in IfcControlExtension schema, and thereby can be related to all subtypes of IfcRoot. An approval may also be given to resource objects using IfcResourceApprovalRelationship
/// 
/// HISTORY New Entity in IFC Release 2.0
/// 
/// IFC2x Edition 4 CHANGE  Attributes Identifier and Name made optional, where rule added to require at least one of them being asserted. Inverse attributes ApprovedObjects, ApprovedResources and HasExternalReferences added. Inverse attribute Properties deleted (more general relationship via inverse ApprovedResources to be used instead).
class IfcApproval : public IfcUtil::IfcBaseEntity {
public:
    /// Whether the optional attribute Description is defined for this IfcApproval
    bool hasDescription() const;
    /// A general textual description of a design, work task, plan, etc. that is being approved for.
    std::string Description() const;
    void setDescription(std::string v);
    IfcDateTimeSelect* ApprovalDateTime() const;
    void setApprovalDateTime(IfcDateTimeSelect* v);
    /// Whether the optional attribute ApprovalStatus is defined for this IfcApproval
    bool hasApprovalStatus() const;
    std::string ApprovalStatus() const;
    void setApprovalStatus(std::string v);
    /// Whether the optional attribute ApprovalLevel is defined for this IfcApproval
    bool hasApprovalLevel() const;
    std::string ApprovalLevel() const;
    void setApprovalLevel(std::string v);
    /// Whether the optional attribute ApprovalQualifier is defined for this IfcApproval
    bool hasApprovalQualifier() const;
    std::string ApprovalQualifier() const;
    void setApprovalQualifier(std::string v);
    /// A human readable name given to an approval.
    std::string Name() const;
    void setName(std::string v);
    /// A computer interpretable identifier by which the approval is known.
    std::string Identifier() const;
    void setIdentifier(std::string v);
    virtual unsigned int getArgumentCount() const { return 7; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_STRING; case 1: return IfcUtil::Argument_ENTITY_INSTANCE; case 2: return IfcUtil::Argument_STRING; case 3: return IfcUtil::Argument_STRING; case 4: return IfcUtil::Argument_STRING; case 5: return IfcUtil::Argument_STRING; case 6: return IfcUtil::Argument_STRING; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcText; case 1: return Type::IfcDateTimeSelect; case 2: return Type::IfcLabel; case 3: return Type::IfcLabel; case 4: return Type::IfcText; case 5: return Type::IfcLabel; case 6: return Type::IfcIdentifier; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Description"; case 1: return "ApprovalDateTime"; case 2: return "ApprovalStatus"; case 3: return "ApprovalLevel"; case 4: return "ApprovalQualifier"; case 5: return "Name"; case 6: return "Identifier"; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcApprovalActorRelationship >::ptr Actors() const; // INVERSE IfcApprovalActorRelationship::Approval
    IfcTemplatedEntityList< IfcApprovalRelationship >::ptr IsRelatedWith() const; // INVERSE IfcApprovalRelationship::RelatedApproval
    IfcTemplatedEntityList< IfcApprovalRelationship >::ptr Relates() const; // INVERSE IfcApprovalRelationship::RelatingApproval
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcApproval (IfcAbstractEntity* e);
    IfcApproval (boost::optional< std::string > v1_Description, IfcDateTimeSelect* v2_ApprovalDateTime, boost::optional< std::string > v3_ApprovalStatus, boost::optional< std::string > v4_ApprovalLevel, boost::optional< std::string > v5_ApprovalQualifier, std::string v6_Name, std::string v7_Identifier);
    typedef IfcTemplatedEntityList< IfcApproval > list;
};

class IfcApprovalActorRelationship : public IfcUtil::IfcBaseEntity {
public:
    IfcActorSelect* Actor() const;
    void setActor(IfcActorSelect* v);
    IfcApproval* Approval() const;
    void setApproval(IfcApproval* v);
    IfcActorRole* Role() const;
    void setRole(IfcActorRole* v);
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_ENTITY_INSTANCE; case 2: return IfcUtil::Argument_ENTITY_INSTANCE; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcActorSelect; case 1: return Type::IfcApproval; case 2: return Type::IfcActorRole; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Actor"; case 1: return "Approval"; case 2: return "Role"; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcApprovalActorRelationship (IfcAbstractEntity* e);
    IfcApprovalActorRelationship (IfcActorSelect* v1_Actor, IfcApproval* v2_Approval, IfcActorRole* v3_Role);
    typedef IfcTemplatedEntityList< IfcApprovalActorRelationship > list;
};

class IfcApprovalPropertyRelationship : public IfcUtil::IfcBaseEntity {
public:
    IfcTemplatedEntityList< IfcProperty >::ptr ApprovedProperties() const;
    void setApprovedProperties(IfcTemplatedEntityList< IfcProperty >::ptr v);
    IfcApproval* Approval() const;
    void setApproval(IfcApproval* v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_ENTITY_INSTANCE; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcProperty; case 1: return Type::IfcApproval; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "ApprovedProperties"; case 1: return "Approval"; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcApprovalPropertyRelationship (IfcAbstractEntity* e);
    IfcApprovalPropertyRelationship (IfcTemplatedEntityList< IfcProperty >::ptr v1_ApprovedProperties, IfcApproval* v2_Approval);
    typedef IfcTemplatedEntityList< IfcApprovalPropertyRelationship > list;
};
/// An IfcApprovalRelationship associates approvals (one
/// relating approval and one or more related approvals), each having different status or level as the approval process or the approved
/// objects evolve.
/// 
/// HISTORY: New entity in Release IFC2x2.
/// 
/// IFC2x4 CHANGE  Subtyped from IfcResourceLevelRelationship, order of attributes changed.
class IfcApprovalRelationship : public IfcUtil::IfcBaseEntity {
public:
    IfcApproval* RelatedApproval() const;
    void setRelatedApproval(IfcApproval* v);
    /// The approval that other approval is related to.
    IfcApproval* RelatingApproval() const;
    void setRelatingApproval(IfcApproval* v);
    /// Whether the optional attribute Description is defined for this IfcApprovalRelationship
    bool hasDescription() const;
    std::string Description() const;
    void setDescription(std::string v);
    std::string Name() const;
    void setName(std::string v);
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_ENTITY_INSTANCE; case 2: return IfcUtil::Argument_STRING; case 3: return IfcUtil::Argument_STRING; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcApproval; case 1: return Type::IfcApproval; case 2: return Type::IfcText; case 3: return Type::IfcLabel; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "RelatedApproval"; case 1: return "RelatingApproval"; case 2: return "Description"; case 3: return "Name"; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcApprovalRelationship (IfcAbstractEntity* e);
    IfcApprovalRelationship (IfcApproval* v1_RelatedApproval, IfcApproval* v2_RelatingApproval, boost::optional< std::string > v3_Description, std::string v4_Name);
    typedef IfcTemplatedEntityList< IfcApprovalRelationship > list;
};
/// Definition
/// from IAI: The abstract entity IfcBoundaryCondition
/// is the supertype of all boundary conditions that can be applied to
/// structural connection definitions, either directly for the connection
/// (e.g. the joint) or for the relation between a structural member and
/// the connection.
/// NOTE: The boundary conditions are used
/// within other parts, mainly by instances of IfcStructuralConnection
/// (for the definition of supports) and instances of IfcRelConnectsStructuralMember
/// (for the definition of connections between structural members and
/// structural connections). 
/// 
/// HISTORY: New entity
/// in Release IFC2x Edition
/// 2.
class IfcBoundaryCondition : public IfcUtil::IfcBaseEntity {
public:
    /// Whether the optional attribute Name is defined for this IfcBoundaryCondition
    bool hasName() const;
    /// Optionally defines a name for this boundary condition.
    std::string Name() const;
    void setName(std::string v);
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_STRING; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcLabel; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Name"; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcBoundaryCondition (IfcAbstractEntity* e);
    IfcBoundaryCondition (boost::optional< std::string > v1_Name);
    typedef IfcTemplatedEntityList< IfcBoundaryCondition > list;
};
/// Definition from IAI: Describes linearly elastic support conditions or connection conditions.
/// 
/// Applicability:
/// 
/// Curve supports and connections.
/// 
/// HISTORY: New entity in IFC 2x2.
/// IFC 2x4 change: Attributes LinearStiffnessX/Y/Z renamed to TranslationalStiffnessX/Y/Z.
/// 
/// IFC 2x4 change: All attribute data types changed from numeric to SELECT between Boolean and numeric.  Stiffnesses may now also be negative, for example to capture destabilizing effects in boundary conditions.  The IFC 2x3 convention of -1. representing infinite stiffness is no longer valid and must not be used.  Infinite stiffness, i.e. fixed supports, are now modeled by the Boolean value TRUE.
class IfcBoundaryEdgeCondition : public IfcBoundaryCondition {
public:
    /// Whether the optional attribute LinearStiffnessByLengthX is defined for this IfcBoundaryEdgeCondition
    bool hasLinearStiffnessByLengthX() const;
    double LinearStiffnessByLengthX() const;
    void setLinearStiffnessByLengthX(double v);
    /// Whether the optional attribute LinearStiffnessByLengthY is defined for this IfcBoundaryEdgeCondition
    bool hasLinearStiffnessByLengthY() const;
    double LinearStiffnessByLengthY() const;
    void setLinearStiffnessByLengthY(double v);
    /// Whether the optional attribute LinearStiffnessByLengthZ is defined for this IfcBoundaryEdgeCondition
    bool hasLinearStiffnessByLengthZ() const;
    double LinearStiffnessByLengthZ() const;
    void setLinearStiffnessByLengthZ(double v);
    /// Whether the optional attribute RotationalStiffnessByLengthX is defined for this IfcBoundaryEdgeCondition
    bool hasRotationalStiffnessByLengthX() const;
    /// Rotational stiffness value about the x-axis of the coordinate system defined by the instance which uses this resource object.
    double RotationalStiffnessByLengthX() const;
    void setRotationalStiffnessByLengthX(double v);
    /// Whether the optional attribute RotationalStiffnessByLengthY is defined for this IfcBoundaryEdgeCondition
    bool hasRotationalStiffnessByLengthY() const;
    /// Rotational stiffness value about the y-axis of the coordinate system defined by the instance which uses this resource object.
    double RotationalStiffnessByLengthY() const;
    void setRotationalStiffnessByLengthY(double v);
    /// Whether the optional attribute RotationalStiffnessByLengthZ is defined for this IfcBoundaryEdgeCondition
    bool hasRotationalStiffnessByLengthZ() const;
    /// Rotational stiffness value about the z-axis of the coordinate system defined by the instance which uses this resource object.
    double RotationalStiffnessByLengthZ() const;
    void setRotationalStiffnessByLengthZ(double v);
    virtual unsigned int getArgumentCount() const { return 7; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 1: return IfcUtil::Argument_DOUBLE; case 2: return IfcUtil::Argument_DOUBLE; case 3: return IfcUtil::Argument_DOUBLE; case 4: return IfcUtil::Argument_DOUBLE; case 5: return IfcUtil::Argument_DOUBLE; case 6: return IfcUtil::Argument_DOUBLE; } return IfcBoundaryCondition::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 1: return Type::IfcModulusOfLinearSubgradeReactionMeasure; case 2: return Type::IfcModulusOfLinearSubgradeReactionMeasure; case 3: return Type::IfcModulusOfLinearSubgradeReactionMeasure; case 4: return Type::IfcModulusOfRotationalSubgradeReactionMeasure; case 5: return Type::IfcModulusOfRotationalSubgradeReactionMeasure; case 6: return Type::IfcModulusOfRotationalSubgradeReactionMeasure; } return IfcBoundaryCondition::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 1: return "LinearStiffnessByLengthX"; case 2: return "LinearStiffnessByLengthY"; case 3: return "LinearStiffnessByLengthZ"; case 4: return "RotationalStiffnessByLengthX"; case 5: return "RotationalStiffnessByLengthY"; case 6: return "RotationalStiffnessByLengthZ"; } return IfcBoundaryCondition::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcBoundaryEdgeCondition (IfcAbstractEntity* e);
    IfcBoundaryEdgeCondition (boost::optional< std::string > v1_Name, boost::optional< double > v2_LinearStiffnessByLengthX, boost::optional< double > v3_LinearStiffnessByLengthY, boost::optional< double > v4_LinearStiffnessByLengthZ, boost::optional< double > v5_RotationalStiffnessByLengthX, boost::optional< double > v6_RotationalStiffnessByLengthY, boost::optional< double > v7_RotationalStiffnessByLengthZ);
    typedef IfcTemplatedEntityList< IfcBoundaryEdgeCondition > list;
};
/// Definition from IAI: Describes linearly elastic support conditions or connection conditions.
/// 
/// Applicability:
/// 
/// Surface supports and connections.
/// 
/// HISTORY: New entity in IFC 2x2.
/// IFC 2x4 change: Attributes LinearStiffnessX/Y/Z renamed to TranslationalStiffnessX/Y/Z.
/// 
/// IFC 2x4 change: All attribute data types changed from numeric to SELECT between Boolean and numeric.  Stiffnesses may now also be negative, for example to capture destabilizing effects in boundary conditions.  The IFC 2x3 convention of -1. representing infinite stiffness is no longer valid and must not be used.  Infinite stiffness, i.e. fixed supports, are now modeled by the Boolean value TRUE.
class IfcBoundaryFaceCondition : public IfcBoundaryCondition {
public:
    /// Whether the optional attribute LinearStiffnessByAreaX is defined for this IfcBoundaryFaceCondition
    bool hasLinearStiffnessByAreaX() const;
    double LinearStiffnessByAreaX() const;
    void setLinearStiffnessByAreaX(double v);
    /// Whether the optional attribute LinearStiffnessByAreaY is defined for this IfcBoundaryFaceCondition
    bool hasLinearStiffnessByAreaY() const;
    double LinearStiffnessByAreaY() const;
    void setLinearStiffnessByAreaY(double v);
    /// Whether the optional attribute LinearStiffnessByAreaZ is defined for this IfcBoundaryFaceCondition
    bool hasLinearStiffnessByAreaZ() const;
    double LinearStiffnessByAreaZ() const;
    void setLinearStiffnessByAreaZ(double v);
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 1: return IfcUtil::Argument_DOUBLE; case 2: return IfcUtil::Argument_DOUBLE; case 3: return IfcUtil::Argument_DOUBLE; } return IfcBoundaryCondition::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 1: return Type::IfcModulusOfSubgradeReactionMeasure; case 2: return Type::IfcModulusOfSubgradeReactionMeasure; case 3: return Type::IfcModulusOfSubgradeReactionMeasure; } return IfcBoundaryCondition::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 1: return "LinearStiffnessByAreaX"; case 2: return "LinearStiffnessByAreaY"; case 3: return "LinearStiffnessByAreaZ"; } return IfcBoundaryCondition::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcBoundaryFaceCondition (IfcAbstractEntity* e);
    IfcBoundaryFaceCondition (boost::optional< std::string > v1_Name, boost::optional< double > v2_LinearStiffnessByAreaX, boost::optional< double > v3_LinearStiffnessByAreaY, boost::optional< double > v4_LinearStiffnessByAreaZ);
    typedef IfcTemplatedEntityList< IfcBoundaryFaceCondition > list;
};
/// Definition from IAI: Describes linearly elastic support conditions or connection conditions.
/// 
/// Applicability:
/// 
/// Point supports and connections.
/// 
/// HISTORY: New entity in IFC 2x2.
/// IFC 2x4 change: Attributes LinearStiffnessX/Y/Z renamed to TranslationalStiffnessX/Y/Z.
/// 
/// IFC 2x4 change: All attribute data types changed from numeric to SELECT between Boolean and numeric.  Stiffnesses may now also be negative, for example to capture destabilizing effects in boundary conditions.  The IFC 2x3 convention of -1. representing infinite stiffness is no longer valid and must not be used.  Infinite stiffness, i.e. fixed supports, are now modeled by the Boolean value TRUE.
class IfcBoundaryNodeCondition : public IfcBoundaryCondition {
public:
    /// Whether the optional attribute LinearStiffnessX is defined for this IfcBoundaryNodeCondition
    bool hasLinearStiffnessX() const;
    double LinearStiffnessX() const;
    void setLinearStiffnessX(double v);
    /// Whether the optional attribute LinearStiffnessY is defined for this IfcBoundaryNodeCondition
    bool hasLinearStiffnessY() const;
    double LinearStiffnessY() const;
    void setLinearStiffnessY(double v);
    /// Whether the optional attribute LinearStiffnessZ is defined for this IfcBoundaryNodeCondition
    bool hasLinearStiffnessZ() const;
    double LinearStiffnessZ() const;
    void setLinearStiffnessZ(double v);
    /// Whether the optional attribute RotationalStiffnessX is defined for this IfcBoundaryNodeCondition
    bool hasRotationalStiffnessX() const;
    /// Rotational stiffness value about the x-axis of the coordinate system defined by the instance which uses this resource object.
    double RotationalStiffnessX() const;
    void setRotationalStiffnessX(double v);
    /// Whether the optional attribute RotationalStiffnessY is defined for this IfcBoundaryNodeCondition
    bool hasRotationalStiffnessY() const;
    /// Rotational stiffness value about the y-axis of the coordinate system defined by the instance which uses this resource object.
    double RotationalStiffnessY() const;
    void setRotationalStiffnessY(double v);
    /// Whether the optional attribute RotationalStiffnessZ is defined for this IfcBoundaryNodeCondition
    bool hasRotationalStiffnessZ() const;
    /// Rotational stiffness value about the z-axis of the coordinate system defined by the instance which uses this resource object.
    double RotationalStiffnessZ() const;
    void setRotationalStiffnessZ(double v);
    virtual unsigned int getArgumentCount() const { return 7; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 1: return IfcUtil::Argument_DOUBLE; case 2: return IfcUtil::Argument_DOUBLE; case 3: return IfcUtil::Argument_DOUBLE; case 4: return IfcUtil::Argument_DOUBLE; case 5: return IfcUtil::Argument_DOUBLE; case 6: return IfcUtil::Argument_DOUBLE; } return IfcBoundaryCondition::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 1: return Type::IfcLinearStiffnessMeasure; case 2: return Type::IfcLinearStiffnessMeasure; case 3: return Type::IfcLinearStiffnessMeasure; case 4: return Type::IfcRotationalStiffnessMeasure; case 5: return Type::IfcRotationalStiffnessMeasure; case 6: return Type::IfcRotationalStiffnessMeasure; } return IfcBoundaryCondition::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 1: return "LinearStiffnessX"; case 2: return "LinearStiffnessY"; case 3: return "LinearStiffnessZ"; case 4: return "RotationalStiffnessX"; case 5: return "RotationalStiffnessY"; case 6: return "RotationalStiffnessZ"; } return IfcBoundaryCondition::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcBoundaryNodeCondition (IfcAbstractEntity* e);
    IfcBoundaryNodeCondition (boost::optional< std::string > v1_Name, boost::optional< double > v2_LinearStiffnessX, boost::optional< double > v3_LinearStiffnessY, boost::optional< double > v4_LinearStiffnessZ, boost::optional< double > v5_RotationalStiffnessX, boost::optional< double > v6_RotationalStiffnessY, boost::optional< double > v7_RotationalStiffnessZ);
    typedef IfcTemplatedEntityList< IfcBoundaryNodeCondition > list;
};
/// Definition from IAI: Describes linearly elastic support conditions or connection conditions, including linearly elastic warping restraints.
/// 
/// Applicability:
/// 
/// Point supports and connections.
/// 
/// HISTORY: New entity in IFC 2x2. 
/// 
/// IFC 2x4 change: All attribute data types changed from numeric to SELECT between Boolean and numeric.  Stiffnesses may now also be negative, for example to capture destabilizing effects in boundary conditions.  The IFC 2x3 convention of -1. representing infinite stiffness is no longer valid and must not be used.  Infinite stiffness, i.e. fixed supports, are now modeled by the Boolean value TRUE.
class IfcBoundaryNodeConditionWarping : public IfcBoundaryNodeCondition {
public:
    /// Whether the optional attribute WarpingStiffness is defined for this IfcBoundaryNodeConditionWarping
    bool hasWarpingStiffness() const;
    /// Defines the warping stiffness value.
    double WarpingStiffness() const;
    void setWarpingStiffness(double v);
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 7: return IfcUtil::Argument_DOUBLE; } return IfcBoundaryNodeCondition::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 7: return Type::IfcWarpingMomentMeasure; } return IfcBoundaryNodeCondition::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 7: return "WarpingStiffness"; } return IfcBoundaryNodeCondition::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcBoundaryNodeConditionWarping (IfcAbstractEntity* e);
    IfcBoundaryNodeConditionWarping (boost::optional< std::string > v1_Name, boost::optional< double > v2_LinearStiffnessX, boost::optional< double > v3_LinearStiffnessY, boost::optional< double > v4_LinearStiffnessZ, boost::optional< double > v5_RotationalStiffnessX, boost::optional< double > v6_RotationalStiffnessY, boost::optional< double > v7_RotationalStiffnessZ, boost::optional< double > v8_WarpingStiffness);
    typedef IfcTemplatedEntityList< IfcBoundaryNodeConditionWarping > list;
};

class IfcCalendarDate : public IfcUtil::IfcBaseEntity {
public:
    int DayComponent() const;
    void setDayComponent(int v);
    int MonthComponent() const;
    void setMonthComponent(int v);
    int YearComponent() const;
    void setYearComponent(int v);
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_INT; case 1: return IfcUtil::Argument_INT; case 2: return IfcUtil::Argument_INT; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcDayInMonthNumber; case 1: return Type::IfcMonthInYearNumber; case 2: return Type::IfcYearNumber; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "DayComponent"; case 1: return "MonthComponent"; case 2: return "YearComponent"; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCalendarDate (IfcAbstractEntity* e);
    IfcCalendarDate (int v1_DayComponent, int v2_MonthComponent, int v3_YearComponent);
    typedef IfcTemplatedEntityList< IfcCalendarDate > list;
};
/// An IfcClassification is used for the arrangement of objects into a class or category according to a common purpose or their possession of common
/// characteristics. A classification in the sense of IfcClassification is taxonomy, or taxonomic scheme, arranged in a hierarchical structure. A category of objects relates to other categories in a generalization-specialization relationship. Therefore the classification items in an
/// classification are organized in a tree structure.
/// 
/// HISTORY New class in IFC Release 1.5. Modified in IFC 2x.
/// 
/// IFC 2x4 CHANGE Attribute Edition made optional. Attributes: PublicationLocation, Description and ReferenceTokens added. Inverse attribute HasClassificationReferences added.
/// 
/// Classification use definitions
/// IfcClassification identifies the classification system or source from which a classification notation is derived. Each classification reference or classification item, belonging to a single classification system, shall reference a single instance of IfcClassification. Therefore, each particular classification system or source used should have only one IfcClassification instance. However, because multiple classification is allowed, there may be many IfcClassification objects used, each identifying a different classification system or source.
/// 
/// A classification system declared may be either formally published (such as Omniclass, Uniclass, Masterformat, or DIN) or it may be a locally defined method of classifiying information.  There are two methods to define a classification system within an IFC dataset:
/// 
/// Including the classification system structure within the dataset: Here a hierarchical tree of IfcClassificationItem's is included that defines the classification system including the relationship between the classification items. An IfcClassificationNotation is used to classify an object.
/// Referencing the classification system by a classification key or id: Here the IfcClassificationReference is used to assign a classification id or key to each classified object.
class IfcClassification : public IfcUtil::IfcBaseEntity {
public:
    /// Source (or publisher) for this classification.
    /// 
    /// NOTE that the source of the classification means the person or organization that was the original author or the person or organization currently acting as the publisher.
    std::string Source() const;
    void setSource(std::string v);
    /// The edition or version of the classification system from which the classification notation is derived.
    /// 
    /// NOTE the version labeling system is specific to the classification system. 
    /// 
    /// IFC2x4 CHANGE The attribute has been changed to be optional.
    std::string Edition() const;
    void setEdition(std::string v);
    /// Whether the optional attribute EditionDate is defined for this IfcClassification
    bool hasEditionDate() const;
    /// The date on which the edition of the classification used became valid.
    /// 
    /// NOTE The indication of edition may be sufficient to identify the classification source uniquely but the edition date is provided as an optional attribute to enable more precise identification where required.
    /// 
    /// IFC2x4 CHANGE The data type has been changed to IfcDate, the date string according to ISO8601.
    IfcCalendarDate* EditionDate() const;
    void setEditionDate(IfcCalendarDate* v);
    /// The name or label by which the classification used is normally known.
    /// 
    /// NOTE Examples of names include CI/SfB, Masterformat, BSAB, Uniclass, STABU, DIN276, DIN277 etc.
    std::string Name() const;
    void setName(std::string v);
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_STRING; case 1: return IfcUtil::Argument_STRING; case 2: return IfcUtil::Argument_ENTITY_INSTANCE; case 3: return IfcUtil::Argument_STRING; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcLabel; case 1: return Type::IfcLabel; case 2: return Type::IfcCalendarDate; case 3: return Type::IfcLabel; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Source"; case 1: return "Edition"; case 2: return "EditionDate"; case 3: return "Name"; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcClassificationItem >::ptr Contains() const; // INVERSE IfcClassificationItem::ItemOf
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcClassification (IfcAbstractEntity* e);
    IfcClassification (std::string v1_Source, std::string v2_Edition, IfcCalendarDate* v3_EditionDate, std::string v4_Name);
    typedef IfcTemplatedEntityList< IfcClassification > list;
};

class IfcClassificationItem : public IfcUtil::IfcBaseEntity {
public:
    IfcClassificationNotationFacet* Notation() const;
    void setNotation(IfcClassificationNotationFacet* v);
    /// Whether the optional attribute ItemOf is defined for this IfcClassificationItem
    bool hasItemOf() const;
    IfcClassification* ItemOf() const;
    void setItemOf(IfcClassification* v);
    std::string Title() const;
    void setTitle(std::string v);
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_ENTITY_INSTANCE; case 2: return IfcUtil::Argument_STRING; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcClassificationNotationFacet; case 1: return Type::IfcClassification; case 2: return Type::IfcLabel; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Notation"; case 1: return "ItemOf"; case 2: return "Title"; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcClassificationItemRelationship >::ptr IsClassifiedItemIn() const; // INVERSE IfcClassificationItemRelationship::RelatedItems
    IfcTemplatedEntityList< IfcClassificationItemRelationship >::ptr IsClassifyingItemIn() const; // INVERSE IfcClassificationItemRelationship::RelatingItem
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcClassificationItem (IfcAbstractEntity* e);
    IfcClassificationItem (IfcClassificationNotationFacet* v1_Notation, IfcClassification* v2_ItemOf, std::string v3_Title);
    typedef IfcTemplatedEntityList< IfcClassificationItem > list;
};

class IfcClassificationItemRelationship : public IfcUtil::IfcBaseEntity {
public:
    IfcClassificationItem* RelatingItem() const;
    void setRelatingItem(IfcClassificationItem* v);
    IfcTemplatedEntityList< IfcClassificationItem >::ptr RelatedItems() const;
    void setRelatedItems(IfcTemplatedEntityList< IfcClassificationItem >::ptr v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcClassificationItem; case 1: return Type::IfcClassificationItem; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "RelatingItem"; case 1: return "RelatedItems"; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcClassificationItemRelationship (IfcAbstractEntity* e);
    IfcClassificationItemRelationship (IfcClassificationItem* v1_RelatingItem, IfcTemplatedEntityList< IfcClassificationItem >::ptr v2_RelatedItems);
    typedef IfcTemplatedEntityList< IfcClassificationItemRelationship > list;
};

class IfcClassificationNotation : public IfcUtil::IfcBaseEntity {
public:
    IfcTemplatedEntityList< IfcClassificationNotationFacet >::ptr NotationFacets() const;
    void setNotationFacets(IfcTemplatedEntityList< IfcClassificationNotationFacet >::ptr v);
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcClassificationNotationFacet; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "NotationFacets"; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcClassificationNotation (IfcAbstractEntity* e);
    IfcClassificationNotation (IfcTemplatedEntityList< IfcClassificationNotationFacet >::ptr v1_NotationFacets);
    typedef IfcTemplatedEntityList< IfcClassificationNotation > list;
};

class IfcClassificationNotationFacet : public IfcUtil::IfcBaseEntity {
public:
    std::string NotationValue() const;
    void setNotationValue(std::string v);
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_STRING; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcLabel; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "NotationValue"; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcClassificationNotationFacet (IfcAbstractEntity* e);
    IfcClassificationNotationFacet (std::string v1_NotationValue);
    typedef IfcTemplatedEntityList< IfcClassificationNotationFacet > list;
};
/// Definition from ISO/CD 10303-46:1992: The colour specification entity contains a direct colour definition. Colour component values refer directly to a specific colour space.
/// 
/// NOTE  Corresponding ISO 10303 name: colour_specification. It has been made into an abstract entity in IFC. Please refer to ISO/IS 10303-46:1994, p. 138 for the final definition of the formal standard.
/// 
/// HISTORY  New entity in IFC2x2.
class IfcColourSpecification : public IfcUtil::IfcBaseEntity {
public:
    /// Whether the optional attribute Name is defined for this IfcColourSpecification
    bool hasName() const;
    /// Optional name given to a particular colour specification in addition to the colour components (like the RGB values).
    /// 
    /// NOTE  Examples are the names of a industry colour classification, such as RAL.
    /// IFC2x Edition 3 CHANGE  Attribute added.
    std::string Name() const;
    void setName(std::string v);
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_STRING; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcLabel; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Name"; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcColourSpecification (IfcAbstractEntity* e);
    IfcColourSpecification (boost::optional< std::string > v1_Name);
    typedef IfcTemplatedEntityList< IfcColourSpecification > list;
};
/// IfcConnectionGeometry is used to describe the geometric and topological constraints that facilitate the physical connection of two objects. It is envisioned as a control that applies to the element connection relationships.
/// 
/// NOTE  The element connection relationship normally provides for a logical connection information, by referencing the relating and related elements. If in addition an IfcConnectionGeometry is provided, physical connection information is given by specifying exactly where at the relating and related element the element connection occurs. 
/// Using the eccentricity subtypes, the connection can also be described when there is a physical distance (or eccentricity) between the connection elements.
/// 
/// The IfcConnectionGeometry allows for the provision of connection constraints between geometric and topological elements, the following connection geometry/topology types are in scope:
/// 
/// point | vertex point,
///   curve | edge curve,
///   surface | face surface,
/// 
/// HISTORY  New entity in IFC Release 1.5.
/// 
/// IFC2x Edition 3 CHANGE  The definition of the subtypes has been enhanced by allowing either geometric representation items (point | curve | surface) or topological representation items with associated geometry (vertex point | edge curve | face  surface).
class IfcConnectionGeometry : public IfcUtil::IfcBaseEntity {
public:
    virtual unsigned int getArgumentCount() const { return 0; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcConnectionGeometry (IfcAbstractEntity* e);
    IfcConnectionGeometry ();
    typedef IfcTemplatedEntityList< IfcConnectionGeometry > list;
};
/// IfcConnectionPointGeometry
/// is used to describe the geometric constraints that facilitate the
/// physical connection of two objects at a point (here IfcCartesianPoint) or at an vertex with point
/// coordinates associated. It is envisioned as a control that applies to the element connection relationships. 
/// 
/// EXAMPLE  The connection relationship between two path based elements (like a column and a beam) has a geometric constraint which describes the connection points by a PointOnRelatingElement for the column and a PointOnRelatedElement for the beam. The exact usage of the IfcConnectionPointGeometry is further defined in the geometry use sections of the elements that use it.
/// 
/// NOTE  If the point connection has an offset (if the two points or vertex points at the relating and related element do not physically match), the subtype IfcConnectionPointEccentricity shall be used.
/// 
/// HISTORY  New entity in IFC Release 1.5, has been renamed from IfcPointConnectionGeometry in IFC Release 2x.
/// 
/// IFC2x Edition 3 CHANGE  The provision of topology with associated geometry, IfcVertexPoint, is
/// enabled by using the IfcPointOrVertexPoint.
/// 
/// Geometry use definitions
/// The IfcPoint (or the IfcVertexPoint with an associated IfcPoint) at the PointOnRelatingElement attribute defines the point where the basic geometry items of the connected elements connect. The point coordinates are provided within the local coordinate system of the RelatingElement, as specified at the IfcRelConnectsSubtype that utilizes the IfcConnectionPointGeometry. Optionally, the same point coordinates can also be provided within the local coordinate system of the RelatedElement by using the PointOnRelatedElement attribute. If both point coordinates are not identical within a common parent coordinate system (ultimately within the world coordinate system), the subtype IfcConnectionPointEccentricity shall be used.
class IfcConnectionPointGeometry : public IfcConnectionGeometry {
public:
    /// Point at which the connected object is aligned at the relating element, given in the LCS of the relating element.
    IfcPointOrVertexPoint* PointOnRelatingElement() const;
    void setPointOnRelatingElement(IfcPointOrVertexPoint* v);
    /// Whether the optional attribute PointOnRelatedElement is defined for this IfcConnectionPointGeometry
    bool hasPointOnRelatedElement() const;
    /// Point at which connected objects are aligned at the related element, given in the LCS of the related element. If the information is omitted, then the origin of the related element is used.
    IfcPointOrVertexPoint* PointOnRelatedElement() const;
    void setPointOnRelatedElement(IfcPointOrVertexPoint* v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcConnectionGeometry::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcPointOrVertexPoint; case 1: return Type::IfcPointOrVertexPoint; } return IfcConnectionGeometry::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "PointOnRelatingElement"; case 1: return "PointOnRelatedElement"; } return IfcConnectionGeometry::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcConnectionPointGeometry (IfcAbstractEntity* e);
    IfcConnectionPointGeometry (IfcPointOrVertexPoint* v1_PointOnRelatingElement, IfcPointOrVertexPoint* v2_PointOnRelatedElement);
    typedef IfcTemplatedEntityList< IfcConnectionPointGeometry > list;
};

class IfcConnectionPortGeometry : public IfcConnectionGeometry {
public:
    IfcAxis2Placement* LocationAtRelatingElement() const;
    void setLocationAtRelatingElement(IfcAxis2Placement* v);
    /// Whether the optional attribute LocationAtRelatedElement is defined for this IfcConnectionPortGeometry
    bool hasLocationAtRelatedElement() const;
    IfcAxis2Placement* LocationAtRelatedElement() const;
    void setLocationAtRelatedElement(IfcAxis2Placement* v);
    IfcProfileDef* ProfileOfPort() const;
    void setProfileOfPort(IfcProfileDef* v);
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_ENTITY_INSTANCE; case 2: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcConnectionGeometry::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcAxis2Placement; case 1: return Type::IfcAxis2Placement; case 2: return Type::IfcProfileDef; } return IfcConnectionGeometry::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "LocationAtRelatingElement"; case 1: return "LocationAtRelatedElement"; case 2: return "ProfileOfPort"; } return IfcConnectionGeometry::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcConnectionPortGeometry (IfcAbstractEntity* e);
    IfcConnectionPortGeometry (IfcAxis2Placement* v1_LocationAtRelatingElement, IfcAxis2Placement* v2_LocationAtRelatedElement, IfcProfileDef* v3_ProfileOfPort);
    typedef IfcTemplatedEntityList< IfcConnectionPortGeometry > list;
};
/// IfcConnectionSurfaceGeometry is used to describe the geometric constraints that facilitate the physical connection of two objects at a surface or at a face with surface geometry associated. It is envisioned as a control that applies to the element connection relationships. 
/// 
/// HISTORY  New entity in IFC Release 2x.
/// 
/// IFC2x Edition 3 CHANGE  The provision of topology with associated geometry, IfcFaceSurface, is enabled by using the IfcSurfaceOrFaceSurface.
/// 
/// Geometry use definitions 
/// The IfcSurface (or the IfcFaceSurface with an associated IfcSurface) at the SurfaceOnRelatingElement attribute defines the surface where the basic geometry items of the connected elements connects. The surface geometry and coordinates are provided within the local coordinate system of the RelatingElement, as specified at the IfcRelConnectsSubtype that utilizes the IfcConnectionSurfaceGeometry. Optionally, the same surface geometry and coordinates can also be provided within the local coordinate system of the RelatedElement by using the SurfaceOnRelatedElement attribute.
class IfcConnectionSurfaceGeometry : public IfcConnectionGeometry {
public:
    /// Surface at which related object is aligned at the relating element, given in the LCS of the relating element.
    IfcSurfaceOrFaceSurface* SurfaceOnRelatingElement() const;
    void setSurfaceOnRelatingElement(IfcSurfaceOrFaceSurface* v);
    /// Whether the optional attribute SurfaceOnRelatedElement is defined for this IfcConnectionSurfaceGeometry
    bool hasSurfaceOnRelatedElement() const;
    /// Surface at which the relating element is aligned at the related element, given in the LCS of the related element. If the information is omitted, then the origin of the related element is used.
    IfcSurfaceOrFaceSurface* SurfaceOnRelatedElement() const;
    void setSurfaceOnRelatedElement(IfcSurfaceOrFaceSurface* v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcConnectionGeometry::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcSurfaceOrFaceSurface; case 1: return Type::IfcSurfaceOrFaceSurface; } return IfcConnectionGeometry::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "SurfaceOnRelatingElement"; case 1: return "SurfaceOnRelatedElement"; } return IfcConnectionGeometry::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcConnectionSurfaceGeometry (IfcAbstractEntity* e);
    IfcConnectionSurfaceGeometry (IfcSurfaceOrFaceSurface* v1_SurfaceOnRelatingElement, IfcSurfaceOrFaceSurface* v2_SurfaceOnRelatedElement);
    typedef IfcTemplatedEntityList< IfcConnectionSurfaceGeometry > list;
};
/// An IfcConstraint is used to define a constraint or limiting value or boundary condition that may be applied to an object or to the value of a property.  
/// 
/// HISTORY: New Entity in IFC Release 2.0
/// 
/// Use Definition 
/// IfcConstraint may be associated with any subtype of IfcRoot (unless restricted in specific subtypes) through the IfcRelAssociatesConstraint relationship in the IfcControlExtension schema, or may be associated with IfcProperty by IfcPropertyConstraintRelationship. 
/// 
/// A constraint may aggregate other constraints through the IfcConstraintAggregationRelationship through which a logical association between constraints may be applied, or constraints may have other defined relationship to other constraints via IfcConstraintRelationship. 
/// 
/// A constraint must have a name applied through the IfcConstraint.Name attribute and optionally, a description through IfcConstraint.Description. The grade of the constraint (hard, soft, advisory) must be specified through IfcConstraint.ConstraintGrade or IfcConstraint.UserDefinedGrade whilst the source, creating actor and time at which the constraint is created may be optionally asserted through IfcConstraint.ConstraintSource, IfcConstraint.CreatingActor and IfcConstraint.CreationTime. 
/// 
/// A constraint may also have additional external information (such as classification or document information) associated to it by IfcExternalReferenceRelationship, accessible through inverse attribute IfcConstraint.HasExternalReferences
class IfcConstraint : public IfcUtil::IfcBaseEntity {
public:
    /// A name to be used for the constraint (e.g., ChillerCoefficientOfPerformance).
    std::string Name() const;
    void setName(std::string v);
    /// Whether the optional attribute Description is defined for this IfcConstraint
    bool hasDescription() const;
    /// A description that may apply additional information about a constraint.
    std::string Description() const;
    void setDescription(std::string v);
    /// Enumeration that qualifies the type of constraint.
    IfcConstraintEnum::IfcConstraintEnum ConstraintGrade() const;
    void setConstraintGrade(IfcConstraintEnum::IfcConstraintEnum v);
    /// Whether the optional attribute ConstraintSource is defined for this IfcConstraint
    bool hasConstraintSource() const;
    /// Any source material, such as a code or standard, from which the constraint originated.
    std::string ConstraintSource() const;
    void setConstraintSource(std::string v);
    /// Whether the optional attribute CreatingActor is defined for this IfcConstraint
    bool hasCreatingActor() const;
    /// Person and/or organization that has created the constraint.
    IfcActorSelect* CreatingActor() const;
    void setCreatingActor(IfcActorSelect* v);
    /// Whether the optional attribute CreationTime is defined for this IfcConstraint
    bool hasCreationTime() const;
    /// Time when information specifying the constraint instance was created.
    /// 
    /// Note IFC2x4 CHANGE: Attribute data type changed to IfcDateTime using ISO 8601 representation
    IfcDateTimeSelect* CreationTime() const;
    void setCreationTime(IfcDateTimeSelect* v);
    /// Whether the optional attribute UserDefinedGrade is defined for this IfcConstraint
    bool hasUserDefinedGrade() const;
    /// Allows for specification of user defined grade of the constraint  beyond the enumeration values (hard, soft, advisory) provided by ConstraintGrade attribute of type IfcConstraintEnum. 
    /// When a value is provided for attribute UserDefinedGrade in parallel the attribute ConstraintGrade shall have enumeration value USERDEFINED.
    std::string UserDefinedGrade() const;
    void setUserDefinedGrade(std::string v);
    virtual unsigned int getArgumentCount() const { return 7; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_STRING; case 1: return IfcUtil::Argument_STRING; case 2: return IfcUtil::Argument_ENUMERATION; case 3: return IfcUtil::Argument_STRING; case 4: return IfcUtil::Argument_ENTITY_INSTANCE; case 5: return IfcUtil::Argument_ENTITY_INSTANCE; case 6: return IfcUtil::Argument_STRING; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcLabel; case 1: return Type::IfcText; case 2: return Type::IfcConstraintEnum; case 3: return Type::IfcLabel; case 4: return Type::IfcActorSelect; case 5: return Type::IfcDateTimeSelect; case 6: return Type::IfcLabel; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Name"; case 1: return "Description"; case 2: return "ConstraintGrade"; case 3: return "ConstraintSource"; case 4: return "CreatingActor"; case 5: return "CreationTime"; case 6: return "UserDefinedGrade"; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcConstraintClassificationRelationship >::ptr ClassifiedAs() const; // INVERSE IfcConstraintClassificationRelationship::ClassifiedConstraint
    IfcTemplatedEntityList< IfcConstraintRelationship >::ptr RelatesConstraints() const; // INVERSE IfcConstraintRelationship::RelatingConstraint
    IfcTemplatedEntityList< IfcConstraintRelationship >::ptr IsRelatedWith() const; // INVERSE IfcConstraintRelationship::RelatedConstraints
    IfcTemplatedEntityList< IfcPropertyConstraintRelationship >::ptr PropertiesForConstraint() const; // INVERSE IfcPropertyConstraintRelationship::RelatingConstraint
    IfcTemplatedEntityList< IfcConstraintAggregationRelationship >::ptr Aggregates() const; // INVERSE IfcConstraintAggregationRelationship::RelatingConstraint
    IfcTemplatedEntityList< IfcConstraintAggregationRelationship >::ptr IsAggregatedIn() const; // INVERSE IfcConstraintAggregationRelationship::RelatedConstraints
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcConstraint (IfcAbstractEntity* e);
    IfcConstraint (std::string v1_Name, boost::optional< std::string > v2_Description, IfcConstraintEnum::IfcConstraintEnum v3_ConstraintGrade, boost::optional< std::string > v4_ConstraintSource, IfcActorSelect* v5_CreatingActor, IfcDateTimeSelect* v6_CreationTime, boost::optional< std::string > v7_UserDefinedGrade);
    typedef IfcTemplatedEntityList< IfcConstraint > list;
};
/// An IfcConstraintAggregationRelationship is an objectified relationship that enables instances of IfcConstraint subtypes to be aggregated together logically. 
/// 
/// HISTORY  New Entity in IFC Release 2.0. Modified in IFC2x2.
/// 
/// IFC2x4 CHANGE  Subtyped from IfcConstraintRelationship
/// 
/// Use definition 
/// IfcConstraintAggregationRelationship allows the aggregation link between subtypes of constraint to be logically defined (AND, OR, XOR, NOTAND, NOTOR). In this way, whereby an object or property can have multiple constraints assigned, and the logical linkage between them can be specified. Thus linked constraints might show as for example (> X AND < Y) which is useful for an allowed range, or bounded value, for example, (A OR B OR C) which is valuable for an enumerated property where a selection is constrained to be (at least) one of A, B or C. 
/// Figure 237 illustrates constraint aggregation.
/// 
/// Figure 237 — Constraint aggregation
class IfcConstraintAggregationRelationship : public IfcUtil::IfcBaseEntity {
public:
    /// Whether the optional attribute Name is defined for this IfcConstraintAggregationRelationship
    bool hasName() const;
    std::string Name() const;
    void setName(std::string v);
    /// Whether the optional attribute Description is defined for this IfcConstraintAggregationRelationship
    bool hasDescription() const;
    std::string Description() const;
    void setDescription(std::string v);
    IfcConstraint* RelatingConstraint() const;
    void setRelatingConstraint(IfcConstraint* v);
    IfcTemplatedEntityList< IfcConstraint >::ptr RelatedConstraints() const;
    void setRelatedConstraints(IfcTemplatedEntityList< IfcConstraint >::ptr v);
    /// Enumeration that identifies the logical type of aggregation.
    IfcLogicalOperatorEnum::IfcLogicalOperatorEnum LogicalAggregator() const;
    void setLogicalAggregator(IfcLogicalOperatorEnum::IfcLogicalOperatorEnum v);
    virtual unsigned int getArgumentCount() const { return 5; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_STRING; case 1: return IfcUtil::Argument_STRING; case 2: return IfcUtil::Argument_ENTITY_INSTANCE; case 3: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 4: return IfcUtil::Argument_ENUMERATION; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcLabel; case 1: return Type::IfcText; case 2: return Type::IfcConstraint; case 3: return Type::IfcConstraint; case 4: return Type::IfcLogicalOperatorEnum; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Name"; case 1: return "Description"; case 2: return "RelatingConstraint"; case 3: return "RelatedConstraints"; case 4: return "LogicalAggregator"; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcConstraintAggregationRelationship (IfcAbstractEntity* e);
    IfcConstraintAggregationRelationship (boost::optional< std::string > v1_Name, boost::optional< std::string > v2_Description, IfcConstraint* v3_RelatingConstraint, IfcTemplatedEntityList< IfcConstraint >::ptr v4_RelatedConstraints, IfcLogicalOperatorEnum::IfcLogicalOperatorEnum v5_LogicalAggregator);
    typedef IfcTemplatedEntityList< IfcConstraintAggregationRelationship > list;
};

class IfcConstraintClassificationRelationship : public IfcUtil::IfcBaseEntity {
public:
    IfcConstraint* ClassifiedConstraint() const;
    void setClassifiedConstraint(IfcConstraint* v);
    IfcEntityList::ptr RelatedClassifications() const;
    void setRelatedClassifications(IfcEntityList::ptr v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcConstraint; case 1: return Type::IfcClassificationNotationSelect; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "ClassifiedConstraint"; case 1: return "RelatedClassifications"; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcConstraintClassificationRelationship (IfcAbstractEntity* e);
    IfcConstraintClassificationRelationship (IfcConstraint* v1_ClassifiedConstraint, IfcEntityList::ptr v2_RelatedClassifications);
    typedef IfcTemplatedEntityList< IfcConstraintClassificationRelationship > list;
};
/// An IfcConstraintRelationship is an objectified relationship that enables instances of IfcConstraint and its
/// subtypes to be associated to each other. Logical aggregation of instances of IfcConstraint and its subtypes is handled by the subtype IfcConstraintAggregationRelationship.
/// 
/// EXAMPLE: Certain constraints related to an IfcWall may be derived from a constraint related to an
/// IfcSpace.
/// 
/// HISTORY  New entity in Release IFC2x2 (Addendum 1).
/// 
/// IFC2x4 CHANGE  Subtyped from IfcResourceLevelRelationship.
class IfcConstraintRelationship : public IfcUtil::IfcBaseEntity {
public:
    /// Whether the optional attribute Name is defined for this IfcConstraintRelationship
    bool hasName() const;
    std::string Name() const;
    void setName(std::string v);
    /// Whether the optional attribute Description is defined for this IfcConstraintRelationship
    bool hasDescription() const;
    std::string Description() const;
    void setDescription(std::string v);
    /// Constraint with which the other Constraints referenced by attribute RelatedConstraints are related.
    IfcConstraint* RelatingConstraint() const;
    void setRelatingConstraint(IfcConstraint* v);
    /// Constraints that are related with the one referenced as RelatingConstraint.
    IfcTemplatedEntityList< IfcConstraint >::ptr RelatedConstraints() const;
    void setRelatedConstraints(IfcTemplatedEntityList< IfcConstraint >::ptr v);
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_STRING; case 1: return IfcUtil::Argument_STRING; case 2: return IfcUtil::Argument_ENTITY_INSTANCE; case 3: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcLabel; case 1: return Type::IfcText; case 2: return Type::IfcConstraint; case 3: return Type::IfcConstraint; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Name"; case 1: return "Description"; case 2: return "RelatingConstraint"; case 3: return "RelatedConstraints"; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcConstraintRelationship (IfcAbstractEntity* e);
    IfcConstraintRelationship (boost::optional< std::string > v1_Name, boost::optional< std::string > v2_Description, IfcConstraint* v3_RelatingConstraint, IfcTemplatedEntityList< IfcConstraint >::ptr v4_RelatedConstraints);
    typedef IfcTemplatedEntityList< IfcConstraintRelationship > list;
};

class IfcCoordinatedUniversalTimeOffset : public IfcUtil::IfcBaseEntity {
public:
    int HourOffset() const;
    void setHourOffset(int v);
    /// Whether the optional attribute MinuteOffset is defined for this IfcCoordinatedUniversalTimeOffset
    bool hasMinuteOffset() const;
    int MinuteOffset() const;
    void setMinuteOffset(int v);
    IfcAheadOrBehind::IfcAheadOrBehind Sense() const;
    void setSense(IfcAheadOrBehind::IfcAheadOrBehind v);
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_INT; case 1: return IfcUtil::Argument_INT; case 2: return IfcUtil::Argument_ENUMERATION; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcHourInDay; case 1: return Type::IfcMinuteInHour; case 2: return Type::IfcAheadOrBehind; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "HourOffset"; case 1: return "MinuteOffset"; case 2: return "Sense"; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCoordinatedUniversalTimeOffset (IfcAbstractEntity* e);
    IfcCoordinatedUniversalTimeOffset (int v1_HourOffset, boost::optional< int > v2_MinuteOffset, IfcAheadOrBehind::IfcAheadOrBehind v3_Sense);
    typedef IfcTemplatedEntityList< IfcCoordinatedUniversalTimeOffset > list;
};
/// IfcCostValue is an amount of money or a value that affects an amount of money. 
/// 
/// HISTORY: New Entity in IFC Release 1.0
/// 
/// Use definitions 
/// Each instance of IfcCostValue may also have a CostType. There are many possible types of cost value that may be identified. While there is a broad understanding of the meaning of names that may be assigned to different types of costs, there is no general standard for naming cost types nor are there any broadly defined classifications. To allow for any type of cost value, the IfcLabel datatype is assigned.
/// 
/// The following defines some cost types that might be applied:  
/// 
/// Annual rate of return
/// Bonus
/// Bulk purchase rebate
/// Contract
/// Consultancy
/// Delivery
/// Estimated cost
/// Hire
/// Installation
/// Interest rate
/// Labor
/// Lease
/// List price
/// Maintenance
/// Material
/// Overhead
/// Postage and packing
/// Profit
/// Purchase 
/// Rental
/// Repair
/// Replacement
/// Sale
/// Small quantity surcharge
/// Spares
/// Storage
/// Sub-Contract
/// Trade discount
/// Transportation
/// Waste allowance
/// Whole life
/// 
/// In the absence of any well-defined standard, it is recommended that local agreements should be made to define allowable and understandable cost value types within a project or region.
class IfcCostValue : public IfcAppliedValue {
public:
    /// Specification of the type of cost type used.
    /// 
    /// NOTE: There are many possible types of cost value that may be identified. Whilst there is a broad understanding of the meaning of names that may be assigned to different types of costs, there is no general standard for naming cost types nor are there any broadly defined classifications. To allow for any type of cost value, the IfcLabel datatype is assigned.
    /// 
    /// In the absence of any well defined standard, it is recommended that local agreements should be made to define allowable and understandable cost value types within a project or region.
    std::string CostType() const;
    void setCostType(std::string v);
    /// Whether the optional attribute Condition is defined for this IfcCostValue
    bool hasCondition() const;
    /// The condition under which a cost value applies.
    std::string Condition() const;
    void setCondition(std::string v);
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 6: return IfcUtil::Argument_STRING; case 7: return IfcUtil::Argument_STRING; } return IfcAppliedValue::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 6: return Type::IfcLabel; case 7: return Type::IfcText; } return IfcAppliedValue::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 6: return "CostType"; case 7: return "Condition"; } return IfcAppliedValue::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCostValue (IfcAbstractEntity* e);
    IfcCostValue (boost::optional< std::string > v1_Name, boost::optional< std::string > v2_Description, IfcAppliedValueSelect* v3_AppliedValue, IfcMeasureWithUnit* v4_UnitBasis, IfcDateTimeSelect* v5_ApplicableDate, IfcDateTimeSelect* v6_FixedUntilDate, std::string v7_CostType, boost::optional< std::string > v8_Condition);
    typedef IfcTemplatedEntityList< IfcCostValue > list;
};
/// IfcCurrencyRelationship defines the rate of exchange
/// that applies between two designated currencies at a particular time
/// and as published by a particular source.
/// 
/// HISTORY  New Entity in IFC2x2.
/// 
/// IFC2x4 CHANGE  Subtyped from IfcResourceLevelRelationship, attribute order changed.
/// 
/// Use definitions
/// An IfcCurrencyRelationship is used where there may be a need to reference an IfcCostValue in one currency to an IfcCostValue in another currency. It takes account of fact that currency exchange rates may vary by requiring the recording the date and time of the currency exchange rate used and the source that publishes the rate. There may be many sources and there are different strategies for currency conversion (spot rate, forward buying of currency at a fixed rate).
/// The source for the currency exchange is defined as an instance of IfcLibraryInformation that includes a name and a URL.
class IfcCurrencyRelationship : public IfcUtil::IfcBaseEntity {
public:
    /// The monetary unit from which an exchange is derived. For instance, in the case of a conversion from GBP to USD, the relating monetary unit is GBP.
    IfcMonetaryUnit* RelatingMonetaryUnit() const;
    void setRelatingMonetaryUnit(IfcMonetaryUnit* v);
    /// The monetary unit to which an exchange results. For instance, in the case of a conversion from GBP to USD, the related monetary unit is USD.
    IfcMonetaryUnit* RelatedMonetaryUnit() const;
    void setRelatedMonetaryUnit(IfcMonetaryUnit* v);
    /// The currently agreed ratio of the amount of a related monetary unit that is equivalent to a unit amount of the relating monetary unit in a currency relationship. For instance, in the case of a conversion from GBP to USD, the value of the exchange rate may be 1.486 (USD) : 1 (GBP).
    double ExchangeRate() const;
    void setExchangeRate(double v);
    /// The date and time at which an exchange rate applies.
    /// 
    /// IFC2x4 CHANGE Type changed from IfcDateTimeSelect. Attribute made optional.
    IfcDateAndTime* RateDateTime() const;
    void setRateDateTime(IfcDateAndTime* v);
    /// Whether the optional attribute RateSource is defined for this IfcCurrencyRelationship
    bool hasRateSource() const;
    /// The source from which an exchange rate is obtained.
    IfcLibraryInformation* RateSource() const;
    void setRateSource(IfcLibraryInformation* v);
    virtual unsigned int getArgumentCount() const { return 5; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_ENTITY_INSTANCE; case 2: return IfcUtil::Argument_DOUBLE; case 3: return IfcUtil::Argument_ENTITY_INSTANCE; case 4: return IfcUtil::Argument_ENTITY_INSTANCE; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcMonetaryUnit; case 1: return Type::IfcMonetaryUnit; case 2: return Type::IfcPositiveRatioMeasure; case 3: return Type::IfcDateAndTime; case 4: return Type::IfcLibraryInformation; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "RelatingMonetaryUnit"; case 1: return "RelatedMonetaryUnit"; case 2: return "ExchangeRate"; case 3: return "RateDateTime"; case 4: return "RateSource"; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCurrencyRelationship (IfcAbstractEntity* e);
    IfcCurrencyRelationship (IfcMonetaryUnit* v1_RelatingMonetaryUnit, IfcMonetaryUnit* v2_RelatedMonetaryUnit, double v3_ExchangeRate, IfcDateAndTime* v4_RateDateTime, IfcLibraryInformation* v5_RateSource);
    typedef IfcTemplatedEntityList< IfcCurrencyRelationship > list;
};
/// Definition from ISO/CD 10303-46:1992: A curve style font combines several curve style font pattern entities into a more complex pattern. The resulting pattern is repeated along the curve. 
/// 
/// NOTE: Corresponding ISO 10303 name: curve_style_font. Please refer to ISO/IS 10303-46:1994 for the final definition of the formal standard.
/// 
/// HISTORY: New entity in IFC2x2.
class IfcCurveStyleFont : public IfcUtil::IfcBaseEntity {
public:
    /// Whether the optional attribute Name is defined for this IfcCurveStyleFont
    bool hasName() const;
    /// Name that may be assigned with the curve font.
    std::string Name() const;
    void setName(std::string v);
    /// A list of curve font pattern entities, that contains the simple patterns used for drawing curves. The patterns are applied in the order they occur in the list.
    IfcTemplatedEntityList< IfcCurveStyleFontPattern >::ptr PatternList() const;
    void setPatternList(IfcTemplatedEntityList< IfcCurveStyleFontPattern >::ptr v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_STRING; case 1: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcLabel; case 1: return Type::IfcCurveStyleFontPattern; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Name"; case 1: return "PatternList"; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCurveStyleFont (IfcAbstractEntity* e);
    IfcCurveStyleFont (boost::optional< std::string > v1_Name, IfcTemplatedEntityList< IfcCurveStyleFontPattern >::ptr v2_PatternList);
    typedef IfcTemplatedEntityList< IfcCurveStyleFont > list;
};
/// Definition from ISO/CD 10303-46:1992: A curve style font and scaling is a curve style font and a scalar factor for that font, so that a given curve style font may be applied at various scales.
/// 
/// The IfcCurveStyleFontAndScaling allows for the reuse of the same curve style definition in several sizes. The definition of the CurveFontScale is the scaling of a base curve style pattern to be used as a new or derived curve style pattern.
/// 
/// NOTE  The CurveFontScale should not be mixed up with the target plot scale.
/// 
/// An example for IfcCurveStyleFontAndScaling is the sizing of a basic curve style dash pattern 'dash' (visible 0.01m, invisible 0.005m) into 'dash large' with CurveFontScale = 2 (resulting in visible 0.02m, invisible 0.01m), and into 'dash small' with CurveFontScale = 0.5 (resulting in visible 0.005m, invisible 0.0025m).
/// 
/// NOTE  Corresponding ISO 10303 name: curve_style_font_and_scaling. Please refer to ISO/IS 10303-46:1994 for the final definition of the formal standard.
/// 
/// HISTORY  New entity in IFC2x2.
class IfcCurveStyleFontAndScaling : public IfcUtil::IfcBaseEntity {
public:
    /// Whether the optional attribute Name is defined for this IfcCurveStyleFontAndScaling
    bool hasName() const;
    /// Name that may be assigned with the scaling of a curve font.
    std::string Name() const;
    void setName(std::string v);
    /// The curve font to be scaled.
    IfcCurveStyleFontSelect* CurveFont() const;
    void setCurveFont(IfcCurveStyleFontSelect* v);
    /// The scale factor.
    double CurveFontScaling() const;
    void setCurveFontScaling(double v);
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_STRING; case 1: return IfcUtil::Argument_ENTITY_INSTANCE; case 2: return IfcUtil::Argument_DOUBLE; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcLabel; case 1: return Type::IfcCurveStyleFontSelect; case 2: return Type::IfcPositiveRatioMeasure; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Name"; case 1: return "CurveFont"; case 2: return "CurveFontScaling"; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCurveStyleFontAndScaling (IfcAbstractEntity* e);
    IfcCurveStyleFontAndScaling (boost::optional< std::string > v1_Name, IfcCurveStyleFontSelect* v2_CurveFont, double v3_CurveFontScaling);
    typedef IfcTemplatedEntityList< IfcCurveStyleFontAndScaling > list;
};
/// Definition from ISO/CD 10303-46:1992: A curve style font pattern is a pair of visible and invisible curve segment length measures in presentation area units. 
/// 
/// NOTE Corresponding ISO 10303 name: curve_style_font_pattern. Please refer to ISO/IS 10303-46:1994 for the final definition of the formal standard.
/// 
/// HISTORY New entity in IFC2x2.
class IfcCurveStyleFontPattern : public IfcUtil::IfcBaseEntity {
public:
    /// The length of the visible segment in the pattern definition.
    /// 
    /// NOTE  For a visible segment representing a point, the value 0. should be assigned.
    /// 
    /// IFC2x Edition 3 CHANGE  The datatype has been changed to IfcLengthMeasure with upward compatibility for file-based exchange.
    double VisibleSegmentLength() const;
    void setVisibleSegmentLength(double v);
    /// The length of the invisible segment in the pattern definition.
    double InvisibleSegmentLength() const;
    void setInvisibleSegmentLength(double v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_DOUBLE; case 1: return IfcUtil::Argument_DOUBLE; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcLengthMeasure; case 1: return Type::IfcPositiveLengthMeasure; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "VisibleSegmentLength"; case 1: return "InvisibleSegmentLength"; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCurveStyleFontPattern (IfcAbstractEntity* e);
    IfcCurveStyleFontPattern (double v1_VisibleSegmentLength, double v2_InvisibleSegmentLength);
    typedef IfcTemplatedEntityList< IfcCurveStyleFontPattern > list;
};

class IfcDateAndTime : public IfcUtil::IfcBaseEntity {
public:
    IfcCalendarDate* DateComponent() const;
    void setDateComponent(IfcCalendarDate* v);
    IfcLocalTime* TimeComponent() const;
    void setTimeComponent(IfcLocalTime* v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_ENTITY_INSTANCE; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcCalendarDate; case 1: return Type::IfcLocalTime; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "DateComponent"; case 1: return "TimeComponent"; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcDateAndTime (IfcAbstractEntity* e);
    IfcDateAndTime (IfcCalendarDate* v1_DateComponent, IfcLocalTime* v2_TimeComponent);
    typedef IfcTemplatedEntityList< IfcDateAndTime > list;
};
/// Definition from ISO/CD 10303-41:1992: A derived unit is an expression of units.
/// 
/// EXAMPLE: Newton per square millimetre is a derived unit.
/// 
/// NOTE: Corresponding ISO 10303 name: derived_unit, please refer to ISO/IS 10303-41 for the final definition of the formal standard.
/// 
/// HISTORY: New entity in IFC Release 1.5.1.
class IfcDerivedUnit : public IfcUtil::IfcBaseEntity {
public:
    /// The group of units and their exponents that define the derived unit.
    IfcTemplatedEntityList< IfcDerivedUnitElement >::ptr Elements() const;
    void setElements(IfcTemplatedEntityList< IfcDerivedUnitElement >::ptr v);
    /// Name of the derived unit chosen from an enumeration of derived unit types for use in IFC models.
    IfcDerivedUnitEnum::IfcDerivedUnitEnum UnitType() const;
    void setUnitType(IfcDerivedUnitEnum::IfcDerivedUnitEnum v);
    /// Whether the optional attribute UserDefinedType is defined for this IfcDerivedUnit
    bool hasUserDefinedType() const;
    std::string UserDefinedType() const;
    void setUserDefinedType(std::string v);
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_ENUMERATION; case 2: return IfcUtil::Argument_STRING; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcDerivedUnitElement; case 1: return Type::IfcDerivedUnitEnum; case 2: return Type::IfcLabel; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Elements"; case 1: return "UnitType"; case 2: return "UserDefinedType"; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcDerivedUnit (IfcAbstractEntity* e);
    IfcDerivedUnit (IfcTemplatedEntityList< IfcDerivedUnitElement >::ptr v1_Elements, IfcDerivedUnitEnum::IfcDerivedUnitEnum v2_UnitType, boost::optional< std::string > v3_UserDefinedType);
    typedef IfcTemplatedEntityList< IfcDerivedUnit > list;
};
/// Definition from ISO/CD 10303-41:1992: A derived unit element is one of the unit quantities 
/// which makes up a derived unit.
/// 
/// EXAMPLE: Newtons per square millimetre is a derived unit. 
/// It has two elements, Newton whose exponent has a value of 1 and millimetre whose exponent is -2.
/// 
/// NOTE: Corresponding ISO 10303 name: derived_unit_element, please refer to ISO/IS 10303-41 for the final definition of the formal standard.
/// 
/// HISTORY New entity in IFC Release 1.5.1.
class IfcDerivedUnitElement : public IfcUtil::IfcBaseEntity {
public:
    /// The fixed quantity which is used as the mathematical factor.
    IfcNamedUnit* Unit() const;
    void setUnit(IfcNamedUnit* v);
    /// The power that is applied to the unit attribute.
    int Exponent() const;
    void setExponent(int v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_INT; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcNamedUnit; case 1: return Type::UNDEFINED; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Unit"; case 1: return "Exponent"; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcDerivedUnitElement (IfcAbstractEntity* e);
    IfcDerivedUnitElement (IfcNamedUnit* v1_Unit, int v2_Exponent);
    typedef IfcTemplatedEntityList< IfcDerivedUnitElement > list;
};
/// Definition from ISO/CD 10303-41:1992: The dimensionality of any quantity can be expressed as a product of powers of the dimensions of base quantities. 
/// The dimensional exponents entity defines the powers of the dimensions of the base quantities. All the physical 
/// quantities are founded on seven base quantities (ISO 31 (clause 2)).
/// 
/// NOTE: Length, mass, time, electric current, thermodynamic temperature, amount of substance, 
/// and luminous intensity are the seven base quantities.
/// 
/// EXAMPLE: A length of 2 millimetres has a length exponent of 1. The remaining exponents 
/// are equal to 0.
/// 
/// EXAMPLE: A velocity of 2 millimetres per second has a length exponent of 1 and 
/// a time exponent of -1. The remaining exponents are equal to 0.
/// 
/// NOTE Corresponding STEP name: dimensional_exponents, please refer to ISO/IS 10303-41
///   for the final definition of the formal standard.
/// 
/// HISTORY New entity in IFC Release 1.5.1.
class IfcDimensionalExponents : public IfcUtil::IfcBaseEntity {
public:
    /// The power of the length base quantity.
    int LengthExponent() const;
    void setLengthExponent(int v);
    /// The power of the mass base quantity.
    int MassExponent() const;
    void setMassExponent(int v);
    /// The power of the time base quantity.
    int TimeExponent() const;
    void setTimeExponent(int v);
    /// The power of the electric current base quantity.
    int ElectricCurrentExponent() const;
    void setElectricCurrentExponent(int v);
    /// The power of the thermodynamic temperature base quantity.
    int ThermodynamicTemperatureExponent() const;
    void setThermodynamicTemperatureExponent(int v);
    /// The power of the amount of substance base quantity.
    int AmountOfSubstanceExponent() const;
    void setAmountOfSubstanceExponent(int v);
    /// The power of the luminous intensity base quantity.
    int LuminousIntensityExponent() const;
    void setLuminousIntensityExponent(int v);
    virtual unsigned int getArgumentCount() const { return 7; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_INT; case 1: return IfcUtil::Argument_INT; case 2: return IfcUtil::Argument_INT; case 3: return IfcUtil::Argument_INT; case 4: return IfcUtil::Argument_INT; case 5: return IfcUtil::Argument_INT; case 6: return IfcUtil::Argument_INT; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::UNDEFINED; case 1: return Type::UNDEFINED; case 2: return Type::UNDEFINED; case 3: return Type::UNDEFINED; case 4: return Type::UNDEFINED; case 5: return Type::UNDEFINED; case 6: return Type::UNDEFINED; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "LengthExponent"; case 1: return "MassExponent"; case 2: return "TimeExponent"; case 3: return "ElectricCurrentExponent"; case 4: return "ThermodynamicTemperatureExponent"; case 5: return "AmountOfSubstanceExponent"; case 6: return "LuminousIntensityExponent"; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcDimensionalExponents (IfcAbstractEntity* e);
    IfcDimensionalExponents (int v1_LengthExponent, int v2_MassExponent, int v3_TimeExponent, int v4_ElectricCurrentExponent, int v5_ThermodynamicTemperatureExponent, int v6_AmountOfSubstanceExponent, int v7_LuminousIntensityExponent);
    typedef IfcTemplatedEntityList< IfcDimensionalExponents > list;
};
/// IfcDocumentElectronicFormat captures the type of document being referenced as an external source, and for which metadata is specified by IfcDocumentInformation. 
/// 
/// HISTORY: New entity in IFC 2x
class IfcDocumentElectronicFormat : public IfcUtil::IfcBaseEntity {
public:
    /// Whether the optional attribute FileExtension is defined for this IfcDocumentElectronicFormat
    bool hasFileExtension() const;
    /// File extension of electronic document used by computer operating system.
    std::string FileExtension() const;
    void setFileExtension(std::string v);
    /// Whether the optional attribute MimeContentType is defined for this IfcDocumentElectronicFormat
    bool hasMimeContentType() const;
    /// Main Mime type (as published by W3C or as user defined application type).
    std::string MimeContentType() const;
    void setMimeContentType(std::string v);
    /// Whether the optional attribute MimeSubtype is defined for this IfcDocumentElectronicFormat
    bool hasMimeSubtype() const;
    /// Mime subtype information.
    std::string MimeSubtype() const;
    void setMimeSubtype(std::string v);
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_STRING; case 1: return IfcUtil::Argument_STRING; case 2: return IfcUtil::Argument_STRING; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcLabel; case 1: return Type::IfcLabel; case 2: return Type::IfcLabel; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "FileExtension"; case 1: return "MimeContentType"; case 2: return "MimeSubtype"; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcDocumentElectronicFormat (IfcAbstractEntity* e);
    IfcDocumentElectronicFormat (boost::optional< std::string > v1_FileExtension, boost::optional< std::string > v2_MimeContentType, boost::optional< std::string > v3_MimeSubtype);
    typedef IfcTemplatedEntityList< IfcDocumentElectronicFormat > list;
};
/// IfcDocumentInformation captures "metadata" of an external document. The actual content of the document is not defined in IFC; instead, it can be found following the reference given to IfcDocumentReference. 
/// 
/// HISTORY: New entity in IFC 2x.
class IfcDocumentInformation : public IfcUtil::IfcBaseEntity {
public:
    /// Identifier that uniquely identifies a document.
    std::string DocumentId() const;
    void setDocumentId(std::string v);
    /// File name or document name assigned by owner.
    std::string Name() const;
    void setName(std::string v);
    /// Whether the optional attribute Description is defined for this IfcDocumentInformation
    bool hasDescription() const;
    /// Description of document and its content.
    std::string Description() const;
    void setDescription(std::string v);
    /// Whether the optional attribute DocumentReferences is defined for this IfcDocumentInformation
    bool hasDocumentReferences() const;
    IfcTemplatedEntityList< IfcDocumentReference >::ptr DocumentReferences() const;
    void setDocumentReferences(IfcTemplatedEntityList< IfcDocumentReference >::ptr v);
    /// Whether the optional attribute Purpose is defined for this IfcDocumentInformation
    bool hasPurpose() const;
    /// Purpose for this document.
    std::string Purpose() const;
    void setPurpose(std::string v);
    /// Whether the optional attribute IntendedUse is defined for this IfcDocumentInformation
    bool hasIntendedUse() const;
    /// Intended use for this document.
    std::string IntendedUse() const;
    void setIntendedUse(std::string v);
    /// Whether the optional attribute Scope is defined for this IfcDocumentInformation
    bool hasScope() const;
    /// Scope for this document.
    std::string Scope() const;
    void setScope(std::string v);
    /// Whether the optional attribute Revision is defined for this IfcDocumentInformation
    bool hasRevision() const;
    /// Document revision designation.
    std::string Revision() const;
    void setRevision(std::string v);
    /// Whether the optional attribute DocumentOwner is defined for this IfcDocumentInformation
    bool hasDocumentOwner() const;
    /// Information about the person and/or organization acknowledged as the 'owner' of this document. In some contexts, the document owner determines who has access to or editing right to the document.
    IfcActorSelect* DocumentOwner() const;
    void setDocumentOwner(IfcActorSelect* v);
    /// Whether the optional attribute Editors is defined for this IfcDocumentInformation
    bool hasEditors() const;
    /// The persons and/or organizations who have created this document or contributed to it.
    IfcEntityList::ptr Editors() const;
    void setEditors(IfcEntityList::ptr v);
    /// Whether the optional attribute CreationTime is defined for this IfcDocumentInformation
    bool hasCreationTime() const;
    /// Date and time stamp when the document was originally created.
    /// 
    /// IFC2x4 CHANGE The data type has been changed to IfcDateTime, the date time string according to ISO8601.
    IfcDateAndTime* CreationTime() const;
    void setCreationTime(IfcDateAndTime* v);
    /// Whether the optional attribute LastRevisionTime is defined for this IfcDocumentInformation
    bool hasLastRevisionTime() const;
    /// Date and time stamp when this document version was created.
    /// 
    /// IFC2x4 CHANGE The data type has been changed to IfcDateTime, the date time string according to ISO8601.
    IfcDateAndTime* LastRevisionTime() const;
    void setLastRevisionTime(IfcDateAndTime* v);
    /// Whether the optional attribute ElectronicFormat is defined for this IfcDocumentInformation
    bool hasElectronicFormat() const;
    /// Describes the electronic format of the document being referenced, providing the file extension and the manner in which the content is provided.
    IfcDocumentElectronicFormat* ElectronicFormat() const;
    void setElectronicFormat(IfcDocumentElectronicFormat* v);
    /// Whether the optional attribute ValidFrom is defined for this IfcDocumentInformation
    bool hasValidFrom() const;
    /// Date when the document becomes valid.
    /// 
    /// IFC2x4 CHANGE The data type has been changed to IfcDate, the date string according to ISO8601.
    IfcCalendarDate* ValidFrom() const;
    void setValidFrom(IfcCalendarDate* v);
    /// Whether the optional attribute ValidUntil is defined for this IfcDocumentInformation
    bool hasValidUntil() const;
    /// Date until which the document remains valid.
    /// 
    /// IFC2x4 CHANGE The data type has been changed to IfcDate, the date string according to ISO8601.
    IfcCalendarDate* ValidUntil() const;
    void setValidUntil(IfcCalendarDate* v);
    /// Whether the optional attribute Confidentiality is defined for this IfcDocumentInformation
    bool hasConfidentiality() const;
    /// The level of confidentiality of the document.
    IfcDocumentConfidentialityEnum::IfcDocumentConfidentialityEnum Confidentiality() const;
    void setConfidentiality(IfcDocumentConfidentialityEnum::IfcDocumentConfidentialityEnum v);
    /// Whether the optional attribute Status is defined for this IfcDocumentInformation
    bool hasStatus() const;
    /// The current status of the document. Examples of status values that might be used for a document information status include:
    /// - DRAFT
    /// - FINAL DRAFT
    /// - FINAL
    /// - REVISION
    IfcDocumentStatusEnum::IfcDocumentStatusEnum Status() const;
    void setStatus(IfcDocumentStatusEnum::IfcDocumentStatusEnum v);
    virtual unsigned int getArgumentCount() const { return 17; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_STRING; case 1: return IfcUtil::Argument_STRING; case 2: return IfcUtil::Argument_STRING; case 3: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 4: return IfcUtil::Argument_STRING; case 5: return IfcUtil::Argument_STRING; case 6: return IfcUtil::Argument_STRING; case 7: return IfcUtil::Argument_STRING; case 8: return IfcUtil::Argument_ENTITY_INSTANCE; case 9: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 10: return IfcUtil::Argument_ENTITY_INSTANCE; case 11: return IfcUtil::Argument_ENTITY_INSTANCE; case 12: return IfcUtil::Argument_ENTITY_INSTANCE; case 13: return IfcUtil::Argument_ENTITY_INSTANCE; case 14: return IfcUtil::Argument_ENTITY_INSTANCE; case 15: return IfcUtil::Argument_ENUMERATION; case 16: return IfcUtil::Argument_ENUMERATION; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcIdentifier; case 1: return Type::IfcLabel; case 2: return Type::IfcText; case 3: return Type::IfcDocumentReference; case 4: return Type::IfcText; case 5: return Type::IfcText; case 6: return Type::IfcText; case 7: return Type::IfcLabel; case 8: return Type::IfcActorSelect; case 9: return Type::IfcActorSelect; case 10: return Type::IfcDateAndTime; case 11: return Type::IfcDateAndTime; case 12: return Type::IfcDocumentElectronicFormat; case 13: return Type::IfcCalendarDate; case 14: return Type::IfcCalendarDate; case 15: return Type::IfcDocumentConfidentialityEnum; case 16: return Type::IfcDocumentStatusEnum; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "DocumentId"; case 1: return "Name"; case 2: return "Description"; case 3: return "DocumentReferences"; case 4: return "Purpose"; case 5: return "IntendedUse"; case 6: return "Scope"; case 7: return "Revision"; case 8: return "DocumentOwner"; case 9: return "Editors"; case 10: return "CreationTime"; case 11: return "LastRevisionTime"; case 12: return "ElectronicFormat"; case 13: return "ValidFrom"; case 14: return "ValidUntil"; case 15: return "Confidentiality"; case 16: return "Status"; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcDocumentInformationRelationship >::ptr IsPointedTo() const; // INVERSE IfcDocumentInformationRelationship::RelatedDocuments
    IfcTemplatedEntityList< IfcDocumentInformationRelationship >::ptr IsPointer() const; // INVERSE IfcDocumentInformationRelationship::RelatingDocument
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcDocumentInformation (IfcAbstractEntity* e);
    IfcDocumentInformation (std::string v1_DocumentId, std::string v2_Name, boost::optional< std::string > v3_Description, boost::optional< IfcTemplatedEntityList< IfcDocumentReference >::ptr > v4_DocumentReferences, boost::optional< std::string > v5_Purpose, boost::optional< std::string > v6_IntendedUse, boost::optional< std::string > v7_Scope, boost::optional< std::string > v8_Revision, IfcActorSelect* v9_DocumentOwner, boost::optional< IfcEntityList::ptr > v10_Editors, IfcDateAndTime* v11_CreationTime, IfcDateAndTime* v12_LastRevisionTime, IfcDocumentElectronicFormat* v13_ElectronicFormat, IfcCalendarDate* v14_ValidFrom, IfcCalendarDate* v15_ValidUntil, boost::optional< IfcDocumentConfidentialityEnum::IfcDocumentConfidentialityEnum > v16_Confidentiality, boost::optional< IfcDocumentStatusEnum::IfcDocumentStatusEnum > v17_Status);
    typedef IfcTemplatedEntityList< IfcDocumentInformation > list;
};
/// An IfcDocumentInformationRelationship is a relationship class that enables a document to have the ability to reference other documents.
/// 
/// HISTORY  New entity in Release IFC2x.
/// 
/// IFC2x4 CHANGE  Subtyped from IfcResourceLevelRelationship, order of attributes changed.
/// 
/// Use definitions
/// This class can be used to describe relationships in which one document may reference one or more other sub documents or where a document is used as a replacement for another document (but where both the original and the replacing document need to be retained).
class IfcDocumentInformationRelationship : public IfcUtil::IfcBaseEntity {
public:
    /// The document that acts as the parent, referencing or original document in a relationship.
    IfcDocumentInformation* RelatingDocument() const;
    void setRelatingDocument(IfcDocumentInformation* v);
    /// The document that acts as the child, referenced or replacing document in a relationship.
    IfcTemplatedEntityList< IfcDocumentInformation >::ptr RelatedDocuments() const;
    void setRelatedDocuments(IfcTemplatedEntityList< IfcDocumentInformation >::ptr v);
    /// Whether the optional attribute RelationshipType is defined for this IfcDocumentInformationRelationship
    bool hasRelationshipType() const;
    /// Describes the type of relationship between documents. This could be sub-document, replacement etc. The interpretation has to be established in an application context.
    std::string RelationshipType() const;
    void setRelationshipType(std::string v);
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 2: return IfcUtil::Argument_STRING; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcDocumentInformation; case 1: return Type::IfcDocumentInformation; case 2: return Type::IfcLabel; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "RelatingDocument"; case 1: return "RelatedDocuments"; case 2: return "RelationshipType"; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcDocumentInformationRelationship (IfcAbstractEntity* e);
    IfcDocumentInformationRelationship (IfcDocumentInformation* v1_RelatingDocument, IfcTemplatedEntityList< IfcDocumentInformation >::ptr v2_RelatedDocuments, boost::optional< std::string > v3_RelationshipType);
    typedef IfcTemplatedEntityList< IfcDocumentInformationRelationship > list;
};

class IfcDraughtingCalloutRelationship : public IfcUtil::IfcBaseEntity {
public:
    /// Whether the optional attribute Name is defined for this IfcDraughtingCalloutRelationship
    bool hasName() const;
    std::string Name() const;
    void setName(std::string v);
    /// Whether the optional attribute Description is defined for this IfcDraughtingCalloutRelationship
    bool hasDescription() const;
    std::string Description() const;
    void setDescription(std::string v);
    IfcDraughtingCallout* RelatingDraughtingCallout() const;
    void setRelatingDraughtingCallout(IfcDraughtingCallout* v);
    IfcDraughtingCallout* RelatedDraughtingCallout() const;
    void setRelatedDraughtingCallout(IfcDraughtingCallout* v);
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_STRING; case 1: return IfcUtil::Argument_STRING; case 2: return IfcUtil::Argument_ENTITY_INSTANCE; case 3: return IfcUtil::Argument_ENTITY_INSTANCE; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcLabel; case 1: return Type::IfcText; case 2: return Type::IfcDraughtingCallout; case 3: return Type::IfcDraughtingCallout; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Name"; case 1: return "Description"; case 2: return "RelatingDraughtingCallout"; case 3: return "RelatedDraughtingCallout"; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcDraughtingCalloutRelationship (IfcAbstractEntity* e);
    IfcDraughtingCalloutRelationship (boost::optional< std::string > v1_Name, boost::optional< std::string > v2_Description, IfcDraughtingCallout* v3_RelatingDraughtingCallout, IfcDraughtingCallout* v4_RelatedDraughtingCallout);
    typedef IfcTemplatedEntityList< IfcDraughtingCalloutRelationship > list;
};

class IfcEnvironmentalImpactValue : public IfcAppliedValue {
public:
    std::string ImpactType() const;
    void setImpactType(std::string v);
    IfcEnvironmentalImpactCategoryEnum::IfcEnvironmentalImpactCategoryEnum Category() const;
    void setCategory(IfcEnvironmentalImpactCategoryEnum::IfcEnvironmentalImpactCategoryEnum v);
    /// Whether the optional attribute UserDefinedCategory is defined for this IfcEnvironmentalImpactValue
    bool hasUserDefinedCategory() const;
    std::string UserDefinedCategory() const;
    void setUserDefinedCategory(std::string v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 6: return IfcUtil::Argument_STRING; case 7: return IfcUtil::Argument_ENUMERATION; case 8: return IfcUtil::Argument_STRING; } return IfcAppliedValue::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 6: return Type::IfcLabel; case 7: return Type::IfcEnvironmentalImpactCategoryEnum; case 8: return Type::IfcLabel; } return IfcAppliedValue::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 6: return "ImpactType"; case 7: return "Category"; case 8: return "UserDefinedCategory"; } return IfcAppliedValue::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcEnvironmentalImpactValue (IfcAbstractEntity* e);
    IfcEnvironmentalImpactValue (boost::optional< std::string > v1_Name, boost::optional< std::string > v2_Description, IfcAppliedValueSelect* v3_AppliedValue, IfcMeasureWithUnit* v4_UnitBasis, IfcDateTimeSelect* v5_ApplicableDate, IfcDateTimeSelect* v6_FixedUntilDate, std::string v7_ImpactType, IfcEnvironmentalImpactCategoryEnum::IfcEnvironmentalImpactCategoryEnum v8_Category, boost::optional< std::string > v9_UserDefinedCategory);
    typedef IfcTemplatedEntityList< IfcEnvironmentalImpactValue > list;
};
/// An IfcExternalReference is the identification of information that is not explicitly represented in the current model or in the project database (as an implementation of the current model). Such information may be contained in classifications, documents or libraries. The IfcExternalReference identifies a particular item, such as a
/// dictionary entry, a classification notation, or a document reference within the external source.
/// 
/// Only the Location (as a URL) is given to describe the place where the information can be found. Also an optional
/// Identification as a key to allow more specific references (as to sections or tables) is provided. The Identification defines a system interpretable method to identify the relevant part of information at the source. In addition a human interpretable Name can be assigned to identify the information subject, such as a classification code.
/// 
/// IfcExternalReference is an abstract supertype of all external reference entities.
/// 
/// HISTORY New entity in IFC2x.
class IfcExternalReference : public IfcUtil::IfcBaseEntity {
public:
    /// Whether the optional attribute Location is defined for this IfcExternalReference
    bool hasLocation() const;
    /// Location, where the external source (classification, document or library) can be accessed by electronic means. The electronic location is provided as an URI, and would normally be given as an URL location string.
    /// 
    /// IFC2x4 CHANGE  The data type has been changed from IfcLabel to IfcURIReference.
    std::string Location() const;
    void setLocation(std::string v);
    /// Whether the optional attribute ItemReference is defined for this IfcExternalReference
    bool hasItemReference() const;
    std::string ItemReference() const;
    void setItemReference(std::string v);
    /// Whether the optional attribute Name is defined for this IfcExternalReference
    bool hasName() const;
    /// Optional name to further specify the reference. It can provide a human readable identifier (which does not necessarily need to have a counterpart in the internal structure of the document).
    std::string Name() const;
    void setName(std::string v);
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_STRING; case 1: return IfcUtil::Argument_STRING; case 2: return IfcUtil::Argument_STRING; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcLabel; case 1: return Type::IfcIdentifier; case 2: return Type::IfcLabel; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Location"; case 1: return "ItemReference"; case 2: return "Name"; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcExternalReference (IfcAbstractEntity* e);
    IfcExternalReference (boost::optional< std::string > v1_Location, boost::optional< std::string > v2_ItemReference, boost::optional< std::string > v3_Name);
    typedef IfcTemplatedEntityList< IfcExternalReference > list;
};
/// Definition from ISO/CD 10303-46:1992: The externally defined hatch style is an entity which makes an external reference to a hatching style.
/// 
/// NOTE: The allowable values for the name source and item reference, by which the externally defined hatch style is identified, need to be determined by implementer agreements.
/// 
/// NOTE: Corresponding ISO 10303 name: fill_style_select. Please refer to ISO/IS 10303-46:1994 for
/// the final definition of the formal standard.
/// 
/// HISTORY: New entity in IFC2x2.
class IfcExternallyDefinedHatchStyle : public IfcExternalReference {
public:
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcExternalReference::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcExternalReference::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcExternalReference::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcExternallyDefinedHatchStyle (IfcAbstractEntity* e);
    IfcExternallyDefinedHatchStyle (boost::optional< std::string > v1_Location, boost::optional< std::string > v2_ItemReference, boost::optional< std::string > v3_Name);
    typedef IfcTemplatedEntityList< IfcExternallyDefinedHatchStyle > list;
};
/// IfcExternallyDefinedSurfaceStyle is a definition of a surface style through referencing an external source, such as a material library for rendering information.
/// 
/// NOTE  In order to achieve expected results, the externally defined surface style should normally only be given in addition to an explicitly defined surface styles.
/// 
/// HISTORY  New entity in IFC2x2.
/// 
/// IFC2x3 CHANGE  The spelling has been corrected from IfcExternallyDefinedSufaceStyle with no upward compatibility.
class IfcExternallyDefinedSurfaceStyle : public IfcExternalReference {
public:
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcExternalReference::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcExternalReference::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcExternalReference::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcExternallyDefinedSurfaceStyle (IfcAbstractEntity* e);
    IfcExternallyDefinedSurfaceStyle (boost::optional< std::string > v1_Location, boost::optional< std::string > v2_ItemReference, boost::optional< std::string > v3_Name);
    typedef IfcTemplatedEntityList< IfcExternallyDefinedSurfaceStyle > list;
};
/// An externally defined symbol is a symbol that gets its shape information by an agreed reference to an external source.
/// 
/// NOTE: The allowable symbol names and sources have to be established by implementers agreements.
/// 
/// NOTE: The IfcExternallyDefinedSymbol is an entity that had been adopted from ISO 10303, Industrial automation systems and integration&#151;Product data representation and exchange, Part 46: Integrated generic resources: Visual presentation.
/// 
/// NOTE Corresponding ISO 10303 name: externally_defined_symbol. Please refer to ISO/IS 10303-46:1994 for the final definition of the formal standard.
/// 
/// HISTORY New entity in IFC2x2.
class IfcExternallyDefinedSymbol : public IfcExternalReference {
public:
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcExternalReference::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcExternalReference::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcExternalReference::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcExternallyDefinedSymbol (IfcAbstractEntity* e);
    IfcExternallyDefinedSymbol (boost::optional< std::string > v1_Location, boost::optional< std::string > v2_ItemReference, boost::optional< std::string > v3_Name);
    typedef IfcTemplatedEntityList< IfcExternallyDefinedSymbol > list;
};
/// Definition from ISO/CD 10303-46:1992: The externally defined text font is an external reference to a text font 
/// 
/// NOTE  Restrictions of the font source and font names to be used may be exposed by implementation guidelines.
/// 
/// NOTE  Corresponding ISO 10303 name: externally_defined_text_font. Please refer to ISO/IS 10303-46:1994, p. 137 for the final definition of the formal standard.
/// 
/// HISTORY  New entity in IFC2x2.
class IfcExternallyDefinedTextFont : public IfcExternalReference {
public:
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcExternalReference::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcExternalReference::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcExternalReference::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcExternallyDefinedTextFont (IfcAbstractEntity* e);
    IfcExternallyDefinedTextFont (boost::optional< std::string > v1_Location, boost::optional< std::string > v2_ItemReference, boost::optional< std::string > v3_Name);
    typedef IfcTemplatedEntityList< IfcExternallyDefinedTextFont > list;
};
/// An individual axis, IfcGridAxis, is defined in the context of a design grid.  The axis definition is based on a curve of dimensionality 2. The grid axis is positioned within the XY plane of the position coordinate system defined by the IfcDesignGrid.
/// 
/// HISTORY  New entity in IFC Release 1.0
/// 
/// Geometry use definitions
/// The standard geometric representation of IfcGridAxis is
/// defined using a 2D curve entity. Grid axes are normally defined
/// by an offset to another axis. The IfcOffsetCurve2D
/// supports this concept.
/// Each grid axis has a sense given by the parameterization of
/// the curve. The attribute SameSense is an indicator of
/// whether or not the sense of the grid axis agrees with, or
/// opposes, that of the underlying curve.
/// As shown in Figure 242, the grid axis is defined as a 2D curve within
/// the xy plane of the position coordinate system. Any curve can be
/// used to define a grid axis, most common is the use of IfcLine for
/// linear grids and IfcCircle for radial grids.
/// Most grids are defined by a pair of axis
/// lists, each defined by a base grid axis and axes given by an
/// offset to the base axis. The use of IfcOffsetCurve2D as
/// underlying AxisCurve supports this concept.
/// 
/// Figure 242 — Grid axis
class IfcGridAxis : public IfcUtil::IfcBaseEntity {
public:
    /// Whether the optional attribute AxisTag is defined for this IfcGridAxis
    bool hasAxisTag() const;
    /// The tag or name for this grid axis.
    std::string AxisTag() const;
    void setAxisTag(std::string v);
    /// Underlying curve which provides the geometry for this grid axis.
    IfcCurve* AxisCurve() const;
    void setAxisCurve(IfcCurve* v);
    /// Defines whether the original sense of curve is used or whether it is reversed in the context of the grid axis.
    bool SameSense() const;
    void setSameSense(bool v);
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_STRING; case 1: return IfcUtil::Argument_ENTITY_INSTANCE; case 2: return IfcUtil::Argument_BOOL; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcLabel; case 1: return Type::IfcCurve; case 2: return Type::IfcBoolean; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "AxisTag"; case 1: return "AxisCurve"; case 2: return "SameSense"; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcGrid >::ptr PartOfW() const; // INVERSE IfcGrid::WAxes
    IfcTemplatedEntityList< IfcGrid >::ptr PartOfV() const; // INVERSE IfcGrid::VAxes
    IfcTemplatedEntityList< IfcGrid >::ptr PartOfU() const; // INVERSE IfcGrid::UAxes
    IfcTemplatedEntityList< IfcVirtualGridIntersection >::ptr HasIntersections() const; // INVERSE IfcVirtualGridIntersection::IntersectingAxes
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcGridAxis (IfcAbstractEntity* e);
    IfcGridAxis (boost::optional< std::string > v1_AxisTag, IfcCurve* v2_AxisCurve, bool v3_SameSense);
    typedef IfcTemplatedEntityList< IfcGridAxis > list;
};
/// The IfcIrregularTimeSeriesValue describes a value (or set of values) at a particular time point. 
/// 
/// HISTORY: New entity in IFC 2x2.
class IfcIrregularTimeSeriesValue : public IfcUtil::IfcBaseEntity {
public:
    /// The specification of the time point.
    IfcDateTimeSelect* TimeStamp() const;
    void setTimeStamp(IfcDateTimeSelect* v);
    /// A list of time-series values. At least one value is required.
    IfcEntityList::ptr ListValues() const;
    void setListValues(IfcEntityList::ptr v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcDateTimeSelect; case 1: return Type::IfcValue; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "TimeStamp"; case 1: return "ListValues"; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcIrregularTimeSeriesValue (IfcAbstractEntity* e);
    IfcIrregularTimeSeriesValue (IfcDateTimeSelect* v1_TimeStamp, IfcEntityList::ptr v2_ListValues);
    typedef IfcTemplatedEntityList< IfcIrregularTimeSeriesValue > list;
};
/// An IfcLibraryInformation describes a library where a library is a structured store of information, normally organized in a manner which allows information lookup through an index or reference value. IfcLibraryInformation provides the library Name and optional Version, VersionDate and Publisher attributes. A Location may be added for electronic access to the library.
/// 
/// NOTE  The complete definition of the information in an external library is out of scope in this IFC release.
/// 
/// HISTORY  New
/// Entity in IFC2x.
/// 
/// IFC2x4 CHANGE  Location attribute added, HasLibraryReferences inverse attribute added (previous LibraryReference changed to inverse).
class IfcLibraryInformation : public IfcUtil::IfcBaseEntity {
public:
    /// The name which is used to identify the library.
    std::string Name() const;
    void setName(std::string v);
    /// Whether the optional attribute Version is defined for this IfcLibraryInformation
    bool hasVersion() const;
    /// Identifier for the library version used for reference.
    std::string Version() const;
    void setVersion(std::string v);
    /// Whether the optional attribute Publisher is defined for this IfcLibraryInformation
    bool hasPublisher() const;
    /// Information of the organization that acts as the library publisher.
    IfcOrganization* Publisher() const;
    void setPublisher(IfcOrganization* v);
    /// Whether the optional attribute VersionDate is defined for this IfcLibraryInformation
    bool hasVersionDate() const;
    /// Date of the referenced version of the library.
    /// 
    /// IFC2x4 CHANGE  The data type has been changed to IfcDate, the date string according to ISO8601.
    IfcCalendarDate* VersionDate() const;
    void setVersionDate(IfcCalendarDate* v);
    /// Whether the optional attribute LibraryReference is defined for this IfcLibraryInformation
    bool hasLibraryReference() const;
    IfcTemplatedEntityList< IfcLibraryReference >::ptr LibraryReference() const;
    void setLibraryReference(IfcTemplatedEntityList< IfcLibraryReference >::ptr v);
    virtual unsigned int getArgumentCount() const { return 5; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_STRING; case 1: return IfcUtil::Argument_STRING; case 2: return IfcUtil::Argument_ENTITY_INSTANCE; case 3: return IfcUtil::Argument_ENTITY_INSTANCE; case 4: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcLabel; case 1: return Type::IfcLabel; case 2: return Type::IfcOrganization; case 3: return Type::IfcCalendarDate; case 4: return Type::IfcLibraryReference; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Name"; case 1: return "Version"; case 2: return "Publisher"; case 3: return "VersionDate"; case 4: return "LibraryReference"; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcLibraryInformation (IfcAbstractEntity* e);
    IfcLibraryInformation (std::string v1_Name, boost::optional< std::string > v2_Version, IfcOrganization* v3_Publisher, IfcCalendarDate* v4_VersionDate, boost::optional< IfcTemplatedEntityList< IfcLibraryReference >::ptr > v5_LibraryReference);
    typedef IfcTemplatedEntityList< IfcLibraryInformation > list;
};
/// An IfcLibraryReference is a reference into a library of information by Location (provided as a URI). It also provides an optional inherited Identification key to allow more specific references to library sections or tables. The inherited Name attribute allows for a human interpretable identification of the library item. Also, general information on the library from which the reference is taken, is given by the ReferencedLibrary relation which identifies the relevant occurrence of IfcLibraryInformation.
/// 
/// The ifcLibraryReference additionally provides the capability to handle multilingual library entries. The Language attribute then holds the language tag for the language used by the strings kept in the Name and the Description attribute.
/// 
/// HISTORY  New Entity in IFC2.0.
/// 
/// IFC2x4 CHANGE  Description and Language attribute added; ReferencedLibrary attribute added (reversing previous ReferenceIntoLibrary inverse relationship).
class IfcLibraryReference : public IfcExternalReference {
public:
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcExternalReference::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcExternalReference::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcExternalReference::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcLibraryInformation >::ptr ReferenceIntoLibrary() const; // INVERSE IfcLibraryInformation::LibraryReference
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcLibraryReference (IfcAbstractEntity* e);
    IfcLibraryReference (boost::optional< std::string > v1_Location, boost::optional< std::string > v2_ItemReference, boost::optional< std::string > v3_Name);
    typedef IfcTemplatedEntityList< IfcLibraryReference > list;
};
/// IfcLightDistributionData defines the luminous intensity of a light source given at a particular main plane angle. It is based on some standardized light distribution curves; the MainPlaneAngle is either the 
/// 
/// A angle; if the IfcLightDistributionCurveEnum is set to TYPE_A 
/// B angle; if the IfcLightDistributionCurveEnum is set to TYPE_B 
/// C angle; if the IfcLightDistributionCurveEnum is set to TYPE_C 
/// 
/// For each MainPlaneAngle (considered as being the row of a table) a list of SecondaryPlaneAngle's are given (considered to be the columns of a table). They are either the: 
/// 
/// &#945; angle; if the IfcLightDistributionCurveEnum is set to TYPE_A 
/// &#946; angle; if the IfcLightDistributionCurveEnum is set to TYPE_B 
/// &#947; angle; if the IfcLightDistributionCurveEnum is set to TYPE_C 
/// 
/// For each pair of MainPlaneAngle and SecondaryPlaneAngle the LuminousIntensity is provided (the unit is given by the IfcUnitAssignment referring to the LuminousIntensityDistributionUnit, normally cd/klm). 
/// 
/// HISTORY: New entity in IFC2x2.
class IfcLightDistributionData : public IfcUtil::IfcBaseEntity {
public:
    /// The main plane angle (A, B or C angles, according to the light distribution curve chosen).
    double MainPlaneAngle() const;
    void setMainPlaneAngle(double v);
    /// The list of secondary plane angles (the &#945;, &#946; or &#947; angles) according to the light distribution curve chosen.
    /// 
    /// NOTE: The SecondaryPlaneAngle and LuminousIntensity lists are corresponding lists.
    std::vector< double > /*[1:?]*/ SecondaryPlaneAngle() const;
    void setSecondaryPlaneAngle(std::vector< double > /*[1:?]*/ v);
    /// The luminous intensity distribution measure for this pair of main and secondary plane angles according to the light distribution curve chosen.
    std::vector< double > /*[1:?]*/ LuminousIntensity() const;
    void setLuminousIntensity(std::vector< double > /*[1:?]*/ v);
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_DOUBLE; case 1: return IfcUtil::Argument_AGGREGATE_OF_DOUBLE; case 2: return IfcUtil::Argument_AGGREGATE_OF_DOUBLE; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcPlaneAngleMeasure; case 1: return Type::IfcPlaneAngleMeasure; case 2: return Type::IfcLuminousIntensityDistributionMeasure; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "MainPlaneAngle"; case 1: return "SecondaryPlaneAngle"; case 2: return "LuminousIntensity"; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcLightDistributionData (IfcAbstractEntity* e);
    IfcLightDistributionData (double v1_MainPlaneAngle, std::vector< double > /*[1:?]*/ v2_SecondaryPlaneAngle, std::vector< double > /*[1:?]*/ v3_LuminousIntensity);
    typedef IfcTemplatedEntityList< IfcLightDistributionData > list;
};
/// IfcLightIntensityDistribution defines the the luminous intensity of a light source that changes according to the direction of the ray. It is based on some standardized light distribution curves, which are defined by the LightDistributionCurve attribute. 
/// 
/// New entity in IFC2x2.
class IfcLightIntensityDistribution : public IfcUtil::IfcBaseEntity {
public:
    /// Standardized  light distribution curve used to define the luminous intensity of the light in all directions.
    IfcLightDistributionCurveEnum::IfcLightDistributionCurveEnum LightDistributionCurve() const;
    void setLightDistributionCurve(IfcLightDistributionCurveEnum::IfcLightDistributionCurveEnum v);
    /// Light distribution data applied to the light source. It is defined by a list of main plane angles (B or C according to the light distribution curve chosen) that includes (for each B or C angle) a second list of secondary plane angles (the &#946; or &#947; angles) and the according luminous intensity distribution measures.
    IfcTemplatedEntityList< IfcLightDistributionData >::ptr DistributionData() const;
    void setDistributionData(IfcTemplatedEntityList< IfcLightDistributionData >::ptr v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENUMERATION; case 1: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcLightDistributionCurveEnum; case 1: return Type::IfcLightDistributionData; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "LightDistributionCurve"; case 1: return "DistributionData"; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcLightIntensityDistribution (IfcAbstractEntity* e);
    IfcLightIntensityDistribution (IfcLightDistributionCurveEnum::IfcLightDistributionCurveEnum v1_LightDistributionCurve, IfcTemplatedEntityList< IfcLightDistributionData >::ptr v2_DistributionData);
    typedef IfcTemplatedEntityList< IfcLightIntensityDistribution > list;
};

class IfcLocalTime : public IfcUtil::IfcBaseEntity {
public:
    int HourComponent() const;
    void setHourComponent(int v);
    /// Whether the optional attribute MinuteComponent is defined for this IfcLocalTime
    bool hasMinuteComponent() const;
    int MinuteComponent() const;
    void setMinuteComponent(int v);
    /// Whether the optional attribute SecondComponent is defined for this IfcLocalTime
    bool hasSecondComponent() const;
    double SecondComponent() const;
    void setSecondComponent(double v);
    /// Whether the optional attribute Zone is defined for this IfcLocalTime
    bool hasZone() const;
    IfcCoordinatedUniversalTimeOffset* Zone() const;
    void setZone(IfcCoordinatedUniversalTimeOffset* v);
    /// Whether the optional attribute DaylightSavingOffset is defined for this IfcLocalTime
    bool hasDaylightSavingOffset() const;
    int DaylightSavingOffset() const;
    void setDaylightSavingOffset(int v);
    virtual unsigned int getArgumentCount() const { return 5; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_INT; case 1: return IfcUtil::Argument_INT; case 2: return IfcUtil::Argument_DOUBLE; case 3: return IfcUtil::Argument_ENTITY_INSTANCE; case 4: return IfcUtil::Argument_INT; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcHourInDay; case 1: return Type::IfcMinuteInHour; case 2: return Type::IfcSecondInMinute; case 3: return Type::IfcCoordinatedUniversalTimeOffset; case 4: return Type::IfcDaylightSavingHour; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "HourComponent"; case 1: return "MinuteComponent"; case 2: return "SecondComponent"; case 3: return "Zone"; case 4: return "DaylightSavingOffset"; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcLocalTime (IfcAbstractEntity* e);
    IfcLocalTime (int v1_HourComponent, boost::optional< int > v2_MinuteComponent, boost::optional< double > v3_SecondComponent, IfcCoordinatedUniversalTimeOffset* v4_Zone, boost::optional< int > v5_DaylightSavingOffset);
    typedef IfcTemplatedEntityList< IfcLocalTime > list;
};
/// IfcMaterial is a homogeneous or inhomogeneous
/// substance that can be used to form elements (physical products or
/// their components).
/// IfcMaterial is the basic entity for material
/// designation and definition; this includes identification by name
/// and classification (via reference to an external classification),
/// as well as association of material properties (isotropic or
/// anisotropic) defined by (subtypes of)
/// IfcMaterialProperties. An instance of IfcMaterial
/// may be associated to an element or element type using the
/// IfcRelAssociatesMaterial relationship. The assignment
/// might either be direct as a single material information, or
/// via
/// 
/// a material layer set
/// a material profile set
/// a material constituent set
/// 
/// An IfcMaterial may also have presentation information
/// associated. Such presentation information is provided by
/// IfcMaterialDefinitionRepresentation, associating line
/// styles, hatching definitions or surface coloring/rendering
/// information to a material.
/// 
/// HISTORYÿNew entity in IFC2x4
/// 
/// IFC2x4 CHANGEÿ The attributes Description and Category have been added.
class IfcMaterial : public IfcUtil::IfcBaseEntity {
public:
    /// Name of the material. 
    /// 
    /// EXAMPLE A view definition may require Material.Name to uniquely specify e.g. concrete or steel grade, in which case the attribute Material.Category could take the value 'Concrete' or 'Steel'. 
    /// 
    /// NOTE Material grade may have diffenrent meaning in different view definitions, e.g. strength grade for structural design and analysis, or visible appearance grade in architectural application. Also, more elaborate material grade definition may be associated as classification via inverse attribute HasExternalReferences.
    std::string Name() const;
    void setName(std::string v);
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_STRING; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcLabel; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Name"; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcMaterialDefinitionRepresentation >::ptr HasRepresentation() const; // INVERSE IfcMaterialDefinitionRepresentation::RepresentedMaterial
    IfcTemplatedEntityList< IfcMaterialClassificationRelationship >::ptr ClassifiedAs() const; // INVERSE IfcMaterialClassificationRelationship::ClassifiedMaterial
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcMaterial (IfcAbstractEntity* e);
    IfcMaterial (std::string v1_Name);
    typedef IfcTemplatedEntityList< IfcMaterial > list;
};
/// IfcMaterialClassificationRelationship is a relationship assigning classifications to materials.
/// 
/// HISTORYÿ New entity in IFC2x.
/// 
/// IFC2x4 CHANGEÿ The entity IfcMaterialClassificationRelationship is deprecated since IFC2x4 and shall no longer be used. Use IfcExternalReferenceRelationship instead.
class IfcMaterialClassificationRelationship : public IfcUtil::IfcBaseEntity {
public:
    /// The material classifications identifying the type of material.
    IfcEntityList::ptr MaterialClassifications() const;
    void setMaterialClassifications(IfcEntityList::ptr v);
    /// Material being classified.
    IfcMaterial* ClassifiedMaterial() const;
    void setClassifiedMaterial(IfcMaterial* v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_ENTITY_INSTANCE; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcClassificationNotationSelect; case 1: return Type::IfcMaterial; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "MaterialClassifications"; case 1: return "ClassifiedMaterial"; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcMaterialClassificationRelationship (IfcAbstractEntity* e);
    IfcMaterialClassificationRelationship (IfcEntityList::ptr v1_MaterialClassifications, IfcMaterial* v2_ClassifiedMaterial);
    typedef IfcTemplatedEntityList< IfcMaterialClassificationRelationship > list;
};
/// IfcMaterialLayer is a single and identifiable part of an element which is constructed of a number of layers (one or more). Each IfcMaterialLayer has a constant thickness and is located relative to the referencing IfcMaterialLayerSet along the MlsBase.
/// 
/// EXAMPLE  A cavity wall with brick masonry used with
/// an air gap in between would be modeled using three
/// IfcMaterialLayer's: [1] Brick, [2] Air gap, [3] Brick. The
/// inner layer "Brick" would have a Name = "Brick", an
/// individual LayerThickness, and potentially a
/// Category indicating it as "load bearing", and a
/// Priority that controls how this material layer interacts
/// with other material layers in wall connections.
/// 
/// The IfcMaterialLayer may have a material layer name,
/// that might be different to the IfcMaterial name
/// referenced.
/// 
/// EXAMPLE  The IfcMaterialLayer name of an
/// insulation layer can be "Insulation", whereas the
/// IfcMaterial name is "polystyrene insulating
/// boards".
/// 
/// HISTORY  New entity in IFC 1.5
/// 
/// IFC2x4 CHANGE  The attributes Name, Description, Category, Priority have been added at the end of attribute list. Data type of LayerThickness relaxed to IfcNonNegativeLengthMeasure.
class IfcMaterialLayer : public IfcUtil::IfcBaseEntity {
public:
    /// Whether the optional attribute Material is defined for this IfcMaterialLayer
    bool hasMaterial() const;
    /// Optional reference to the material from which the layer is constructed. Note that if this value is not given, it does not denote a layer with no material (an air gap), it only means that the material is not specified at that point.
    IfcMaterial* Material() const;
    void setMaterial(IfcMaterial* v);
    /// The thickness of the material layer. The dimension is measured along the positive MlsDirection as specified in IfcMaterialLayerSet (that is mapped to AXIS-2, as specified in IfcMaterialLayerSetUsage for element occurrences supporting IfcMaterialLayerSetUsage.
    /// 
    /// NOTE  The attribute value can be 0. for material thicknesses very close to zero, such as for a membrane. Material layers with thickess 0. shall not be rendered in the geometric representation.
    /// 
    /// IFC2x4 CHANGE  The attribute datatype has been changed to IfcNonNegativeLengthMeasure allowing for 0. as thickness.
    double LayerThickness() const;
    void setLayerThickness(double v);
    /// Whether the optional attribute IsVentilated is defined for this IfcMaterialLayer
    bool hasIsVentilated() const;
    /// Indication of whether the material layer represents an air layer (or cavity). 
    /// 
    /// set to TRUE if the material layer is an air gap and provides air exchange from the layer to the outside air.
    ///   set to UNKNOWN if the material layer is an air gap and does not provide air exchange (or when this information about air exchange of the air gap is not available).
    ///   set to FALSE if the material layer is a solid material layer (the default).
    bool IsVentilated() const;
    void setIsVentilated(bool v);
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_DOUBLE; case 2: return IfcUtil::Argument_BOOL; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcMaterial; case 1: return Type::IfcPositiveLengthMeasure; case 2: return Type::IfcLogical; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Material"; case 1: return "LayerThickness"; case 2: return "IsVentilated"; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcMaterialLayerSet >::ptr ToMaterialLayerSet() const; // INVERSE IfcMaterialLayerSet::MaterialLayers
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcMaterialLayer (IfcAbstractEntity* e);
    IfcMaterialLayer (IfcMaterial* v1_Material, double v2_LayerThickness, boost::optional< bool > v3_IsVentilated);
    typedef IfcTemplatedEntityList< IfcMaterialLayer > list;
};
/// IfcMaterialLayerSet is a designation by which materials of an element constructed of a number of material layers is known and through which the relative positioning of individual layers can be expressed.
/// 
/// The Material Layer Set Base (MlsBase) describes the axis along
/// which the material layers are positioned. The MlsBase is positioned
/// along the reference axis or reference plane of the element
/// supporting the IfcMaterialLayerSetUsage concept with a
/// potential offset (see here). The positive Material Layer Set
/// Direction (MlsDirection) describes the direction by which the
/// individual material layers, with their material layer thicknesses
/// are stacked. IfcMaterialLayer's are stacked with no gap,
/// gaps within a material layer set are expresses as layers by
/// themselves.
/// 
/// EXAMPLE A cavity brick wall would be modeled as
/// IfcMaterialLayerSet consisting of three
/// IfcMaterialLayer's: brick, air cavity and brick. The air
/// gap is identified, using the IsVentilated flag at
/// IfcMaterialLayer.
/// 
/// HISTORY  New entity in IFC 1.0
/// 
/// IFC2x4 CHANGE  Subtyped from IfcMaterialDefinition, the attribute Description
/// has been added at the end of attribute list.
/// 
/// Attribute use definition
/// As shown in Figure 285, each IfcMaterialLayerSet implicitly defines a material
/// layer set base line (MlsBase), to which the start of the first
/// IfcMaterialLayer is aligned. The total thickness of a
/// layer set is calculated from the individual layer thicknesses, the
/// first layer starting from the MlsBase and following layers being
/// placed on top of the previous (no gaps or overlaps).
/// 
/// Figure 285 — Material layer set
class IfcMaterialLayerSet : public IfcUtil::IfcBaseEntity {
public:
    /// Identification of the layers from which the material layer set is composed.
    IfcTemplatedEntityList< IfcMaterialLayer >::ptr MaterialLayers() const;
    void setMaterialLayers(IfcTemplatedEntityList< IfcMaterialLayer >::ptr v);
    /// Whether the optional attribute LayerSetName is defined for this IfcMaterialLayerSet
    bool hasLayerSetName() const;
    /// The name by which the material layer set is known.
    std::string LayerSetName() const;
    void setLayerSetName(std::string v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_STRING; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcMaterialLayer; case 1: return Type::IfcLabel; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "MaterialLayers"; case 1: return "LayerSetName"; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcMaterialLayerSet (IfcAbstractEntity* e);
    IfcMaterialLayerSet (IfcTemplatedEntityList< IfcMaterialLayer >::ptr v1_MaterialLayers, boost::optional< std::string > v2_LayerSetName);
    typedef IfcTemplatedEntityList< IfcMaterialLayerSet > list;
};
/// IfcMaterialLayerSetUsage determines the usage of
/// IfcMaterialLayerSet in terms of its location and
/// orientation relative to the associated element geometry. The
/// location of material layer set shall be compatible with the
/// building element geometry (that is, material layers shall fit inside
/// the element geometry). The rules to ensure the compatibility
/// depend on the type of the building element.
/// 
/// EXAMPLE ÿFor a cavity brick wall with shape
/// representation SweptSolid, the
/// IfcMaterialLayerSet.TotalThickness shall be equal to the
/// wall thickness. Also the OffsetFromReferenceLine shall
/// match the exact positions between the two shape representations
/// of IfcWallStandardCase, i.e. the
/// IfcShapeRepresentation's with
/// RepresentationIdentifier="Axis" and
/// RepresentationIdentifier="Body".
/// 
/// NOTE ÿRefer to the implementation guide and agreements for
/// more information on matching between building element geometry
/// and material layer set usage.
/// 
/// The IfcMaterialLayerSetUsage is always assigned to an
/// individual occurrence object only (i.e. to relevant subtypes of
/// IfcElement). The IfcMaterialLayerSet, referenced by
/// ForLayerSet can however be shared among several occurrence
/// objects. If the element type is available (i.e. the relevant
/// subtype of IfcElementType, then the
/// IfcMaterialLayerSet can be assigned to the type object.
/// The assignment between aÿsubtype of IfcElement and the
/// IfcMaterialLayerSetUsage is handled by
/// IfcRelAssociatesMaterial.
/// 
/// Use definition
/// The IfcMaterialLayerSetUsage is primarily intended to
/// be associated with planar building elements having a constant
/// thickness. With further agreements on the interpretation of
/// LayerSetDirection, the usage can be extended also to other
/// cases, e.g. to curved building elements, provided that the
/// material layer thicknesses are constant.
/// Generally, an element may be layered in any of its primary
/// directions, denoted by its x, y or z axis. The geometry use
/// definitions at eachÿspecific types of building element will
/// determine the applicableÿLayerSetDirection.
/// 
/// The following examples illustrate how the IfcMaterialLayerSetUsage attributes (LayerSetDirection, DirectionSense, OffsetFromReferenceLine) can
/// be used in different cases. The normative material use definitions are documented at each element (how these shall be used).
/// 
/// Figure 286 shows an example of the use of IfcMaterialLayerSetUsage aligned to the axis of a wall.
/// 
/// EXAMPLE  For a standard wall with extruded
/// geometric representation (vertical extrusion), the layer set
/// direction will be perpendicular to extrusion direction,
/// andÿcan be derived from the direction of the wall
/// axis. With the DirectionSense(positive in
/// this example) the individual IfcMaterialLayers are
/// assigned consecutively right-to-left or left-to-right. For a
/// curved wall, "direction denoting the wall thickness" can be
/// derived from the direction of the wall axis, and it will remain
/// perpendicular to the wall path. The
/// DirectionSenseÿapplies as well.
/// 
/// NOTE  According to the IfcWallStandardCase material use
/// definition the LayerSetDirection for
/// IfcWallStandardCase is always AXIS2 (i.e. along the
/// y-axis), as shown in this example.
/// 
/// Figure 286 — Material layer set usage for wall
/// 
/// Figure 287 shows an example of the use of IfcMaterialLayerSetUsage aligned to a slab.
/// 
/// EXAMPLE ÿFor a slab with perpendicular
/// extruded geometric representation, the LayerSetDirection
/// will coincide with the extrusion direction (in positive or
/// negative sense). In this example, the material layer set base is
/// the extruded profile and consistent with the
/// IfcExtrudedAreaSolid.Position,ÿwith the
/// DirectionSensebeing positive, the
/// individual IfcMaterialLayers are built up from the base
/// towards positive z direction in this case.
/// 
/// NOTE ÿAccording to the IfcSlabStandardCase
/// material use definition the LayerSetDirection for
/// IfcSlabStandardCase is always AXIS3 (i.e. along the
/// z-axis).
/// 
/// Figure 287 — Material layer set usage for slab
/// 
/// Figure 288 shows an example of the use of IfcMaterialLayerSetUsage aligned to a roof slab with non-perpendicular extrusion.
/// 
/// EXAMPLE ÿFor a slab with non-perpendicular
/// extruded geometric representation, the guidelines above apply as
/// well. The material layer thickness and the
/// OffsetFromReferenceLine is always measured
/// perpendicularly, even if the extrusion direction is not
/// perpendicular. Therefore the total material layer thickness is
/// not equal to the extrusion depth of the
/// geometry.
/// 
/// Figure 288 — Material layer set usage for roof slab
class IfcMaterialLayerSetUsage : public IfcUtil::IfcBaseEntity {
public:
    /// The IfcMaterialLayerSet set to which the usage is applied.
    IfcMaterialLayerSet* ForLayerSet() const;
    void setForLayerSet(IfcMaterialLayerSet* v);
    /// Orientation of the material layer set relative to element reference geometry. The meaning of the value of this attribute shall be specified in the geometry use section for each element. For extruded shape representation, direction can be given along the extrusion path (e.g. for slabs) or perpendicular to it (e.g. for walls).
    /// 
    /// NOTE  the LayerSetDirection for IfcWallStandardCase shall be AXIS2 (i.e. the y-axis) and for IfcSlabStandardCase and IfcPlateStandardCase it shall be AXIS3 (i.e. the z-axis).
    /// 
    /// Whether the material layers of the set being used shall 'grow' into the positive or negative direction of the given axis, shall be deifned by DirectionSense attribute.
    IfcLayerSetDirectionEnum::IfcLayerSetDirectionEnum LayerSetDirection() const;
    void setLayerSetDirection(IfcLayerSetDirectionEnum::IfcLayerSetDirectionEnum v);
    /// Denotion whether the material layer set is oriented in positive or negative sense along the specified axis (defined by LayerSetDirection). "Positive" means that the consecutive layers (the IfcMaterialLayer instances in the list of  IfcMaterialLayerSet.MaterialLayers) are placed face-by-face in the direction of the positive axis as established by LayerSetDirection: for AXIS2 it would be in +y, for AXIS3 it would be +z. "Negative" means that the layers are placed face-by-face in the direction of the negative LayerSetDirection. In both cases,  starting at the material layer set base line.
    /// NOTE  the material layer set base line (MlsBase) is located by OffsetFromReferenceLine, and may be on the positive or negative side of the element reference line (or plane); positive or negative for MlsBase placement does not depend on the DirectionSense attribute, but on the relevant element axis.
    IfcDirectionSenseEnum::IfcDirectionSenseEnum DirectionSense() const;
    void setDirectionSense(IfcDirectionSenseEnum::IfcDirectionSenseEnum v);
    /// Offset of the material layer set base line (MlsBase) from reference geometry (line or plane) of element. The offset can be positive or negative, unless restricted for a particular building element type in its use definition or by implementer agreement. A positive value means, that the MlsBase is placed on the positive side of the reference line or plane, on the axis established by LayerSetDirection (in case of AXIS2 into the direction of +y, or in case of AXIS2 into the direction of +z). A negative value means that the MlsBase is placed on the negative side, as established by LayerSetDirection (in case of AXIS2 into the direction of -y). NOTE  the positive or negative sign in the offset only affects the MlsBase placement, it does not have any effect on the application of DirectionSense for orientation of the material layers; also DirectionSense does not change the MlsBase placement.
    double OffsetFromReferenceLine() const;
    void setOffsetFromReferenceLine(double v);
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_ENUMERATION; case 2: return IfcUtil::Argument_ENUMERATION; case 3: return IfcUtil::Argument_DOUBLE; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcMaterialLayerSet; case 1: return Type::IfcLayerSetDirectionEnum; case 2: return Type::IfcDirectionSenseEnum; case 3: return Type::IfcLengthMeasure; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "ForLayerSet"; case 1: return "LayerSetDirection"; case 2: return "DirectionSense"; case 3: return "OffsetFromReferenceLine"; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcMaterialLayerSetUsage (IfcAbstractEntity* e);
    IfcMaterialLayerSetUsage (IfcMaterialLayerSet* v1_ForLayerSet, IfcLayerSetDirectionEnum::IfcLayerSetDirectionEnum v2_LayerSetDirection, IfcDirectionSenseEnum::IfcDirectionSenseEnum v3_DirectionSense, double v4_OffsetFromReferenceLine);
    typedef IfcTemplatedEntityList< IfcMaterialLayerSetUsage > list;
};
/// IfcMaterialList is a list of the different materials
/// that are used in an element.
/// 
/// NOTE: The class IfcMaterialList will
/// normally be used where an element is described at a more abstract
/// level. For example, for an architectural specification writer,
/// the only information that may be needed about a concrete column
/// is that it contains concrete, reinforcing steel and mild steel
/// ligatures. It shall not be used for elements consisting of
/// material layers when the different layers can be defined and the
/// class IfcMaterialLayerSet can be used. Also,
/// IfcMaterialList shall not be used for elements consisting
/// of a single identifiable material (for example, to represent anisotropic
/// material).
/// 
/// IFC2x4 CHANGEÿ The entity IfcMaterialList is deprecated and shall no longer
/// be used. Use IfcMaterialConstituentSet instead.
class IfcMaterialList : public IfcUtil::IfcBaseEntity {
public:
    /// Materials used in a composition of substances.
    IfcTemplatedEntityList< IfcMaterial >::ptr Materials() const;
    void setMaterials(IfcTemplatedEntityList< IfcMaterial >::ptr v);
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcMaterial; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Materials"; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcMaterialList (IfcAbstractEntity* e);
    IfcMaterialList (IfcTemplatedEntityList< IfcMaterial >::ptr v1_Materials);
    typedef IfcTemplatedEntityList< IfcMaterialList > list;
};
/// IfcMaterialProperties is defined as an abstract
/// supertype for entities that apply material properties to material
/// definitions. A set of material properties that are assigned to an
/// individual material definiton may be identified by a Name
/// and a Description.
/// 
/// NOTE  The set of material properties can be assigned
/// to an individual IfcMaterial, a set or composite of
/// materials (IfcMaterialConstituent,
/// IfcMaterialConstituentSet), or set or individual material
/// layer (IfcMaterialLayer, IfcMaterialLayerSet), or
/// a set or individual material profile (IfcMaterialProfile,
/// IfcMaterialProfileSet)
/// 
/// The applicable set of material properties is defined at the
/// subtype IfcExtendedMaterialProperties. It includes
/// material properties defined in this IFC specification and those
/// defined as user-defined extended material properties.
/// 
/// HISTORY  New Entity in IFC 2x.
/// 
/// IFC2x4 CHANGE  The subtypes that represented a fixed list of statically defined material properties, IfcMechanicalMaterialProperties, IfcThermalMaterialProperties, IfcHygroscopicMaterialProperties, IfcGeneralMaterialProperties, IfcOpticalMaterialProperties, IfcWaterProperties, IfcFuelProperties, IfcProductsOfCombustionProperties have been deleted, use the generic IfcExtendedMaterialProperties instead.
class IfcMaterialProperties : public IfcUtil::IfcBaseEntity {
public:
    /// Reference to the material definition to which the set of properties is assigned.
    /// 
    /// IFC2x4 CHANGE  The datatype has been changed to supertype IfcMaterialDefinition.
    IfcMaterial* Material() const;
    void setMaterial(IfcMaterial* v);
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcMaterial; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Material"; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcMaterialProperties (IfcAbstractEntity* e);
    IfcMaterialProperties (IfcMaterial* v1_Material);
    typedef IfcTemplatedEntityList< IfcMaterialProperties > list;
};
/// Definition from ISO/CD 10303-41:1992: A measure with unit is the specification of a physical quantity  as defined in ISO 31 (clause 2).
/// 
/// IfcMeasureWithUnit has two usages:
/// 1. For representing measure value together with its unit on the entity type attribute level; thus
///   overriding the IFC model global unit assignments.
/// 2. For conversion based unit to give the conversion rate and its base.
/// 
/// NOTE Corresponding ISO 10303 name: measure_with_unit, please refer to ISO/IS 10303-41 for the final definition of the formal standard.
/// 
/// HISTORY New entity in IFC Release 1.5.1.
class IfcMeasureWithUnit : public IfcUtil::IfcBaseEntity {
public:
    /// The value of the physical quantity when expressed in the specified units.
    IfcValue* ValueComponent() const;
    void setValueComponent(IfcValue* v);
    /// The unit in which the physical quantity is expressed.
    IfcUnit* UnitComponent() const;
    void setUnitComponent(IfcUnit* v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_ENTITY_INSTANCE; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcValue; case 1: return Type::IfcUnit; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "ValueComponent"; case 1: return "UnitComponent"; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcMeasureWithUnit (IfcAbstractEntity* e);
    IfcMeasureWithUnit (IfcValue* v1_ValueComponent, IfcUnit* v2_UnitComponent);
    typedef IfcTemplatedEntityList< IfcMeasureWithUnit > list;
};

class IfcMechanicalMaterialProperties : public IfcMaterialProperties {
public:
    /// Whether the optional attribute DynamicViscosity is defined for this IfcMechanicalMaterialProperties
    bool hasDynamicViscosity() const;
    double DynamicViscosity() const;
    void setDynamicViscosity(double v);
    /// Whether the optional attribute YoungModulus is defined for this IfcMechanicalMaterialProperties
    bool hasYoungModulus() const;
    double YoungModulus() const;
    void setYoungModulus(double v);
    /// Whether the optional attribute ShearModulus is defined for this IfcMechanicalMaterialProperties
    bool hasShearModulus() const;
    double ShearModulus() const;
    void setShearModulus(double v);
    /// Whether the optional attribute PoissonRatio is defined for this IfcMechanicalMaterialProperties
    bool hasPoissonRatio() const;
    double PoissonRatio() const;
    void setPoissonRatio(double v);
    /// Whether the optional attribute ThermalExpansionCoefficient is defined for this IfcMechanicalMaterialProperties
    bool hasThermalExpansionCoefficient() const;
    double ThermalExpansionCoefficient() const;
    void setThermalExpansionCoefficient(double v);
    virtual unsigned int getArgumentCount() const { return 6; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 1: return IfcUtil::Argument_DOUBLE; case 2: return IfcUtil::Argument_DOUBLE; case 3: return IfcUtil::Argument_DOUBLE; case 4: return IfcUtil::Argument_DOUBLE; case 5: return IfcUtil::Argument_DOUBLE; } return IfcMaterialProperties::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 1: return Type::IfcDynamicViscosityMeasure; case 2: return Type::IfcModulusOfElasticityMeasure; case 3: return Type::IfcModulusOfElasticityMeasure; case 4: return Type::IfcPositiveRatioMeasure; case 5: return Type::IfcThermalExpansionCoefficientMeasure; } return IfcMaterialProperties::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 1: return "DynamicViscosity"; case 2: return "YoungModulus"; case 3: return "ShearModulus"; case 4: return "PoissonRatio"; case 5: return "ThermalExpansionCoefficient"; } return IfcMaterialProperties::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcMechanicalMaterialProperties (IfcAbstractEntity* e);
    IfcMechanicalMaterialProperties (IfcMaterial* v1_Material, boost::optional< double > v2_DynamicViscosity, boost::optional< double > v3_YoungModulus, boost::optional< double > v4_ShearModulus, boost::optional< double > v5_PoissonRatio, boost::optional< double > v6_ThermalExpansionCoefficient);
    typedef IfcTemplatedEntityList< IfcMechanicalMaterialProperties > list;
};

class IfcMechanicalSteelMaterialProperties : public IfcMechanicalMaterialProperties {
public:
    /// Whether the optional attribute YieldStress is defined for this IfcMechanicalSteelMaterialProperties
    bool hasYieldStress() const;
    double YieldStress() const;
    void setYieldStress(double v);
    /// Whether the optional attribute UltimateStress is defined for this IfcMechanicalSteelMaterialProperties
    bool hasUltimateStress() const;
    double UltimateStress() const;
    void setUltimateStress(double v);
    /// Whether the optional attribute UltimateStrain is defined for this IfcMechanicalSteelMaterialProperties
    bool hasUltimateStrain() const;
    double UltimateStrain() const;
    void setUltimateStrain(double v);
    /// Whether the optional attribute HardeningModule is defined for this IfcMechanicalSteelMaterialProperties
    bool hasHardeningModule() const;
    double HardeningModule() const;
    void setHardeningModule(double v);
    /// Whether the optional attribute ProportionalStress is defined for this IfcMechanicalSteelMaterialProperties
    bool hasProportionalStress() const;
    double ProportionalStress() const;
    void setProportionalStress(double v);
    /// Whether the optional attribute PlasticStrain is defined for this IfcMechanicalSteelMaterialProperties
    bool hasPlasticStrain() const;
    double PlasticStrain() const;
    void setPlasticStrain(double v);
    /// Whether the optional attribute Relaxations is defined for this IfcMechanicalSteelMaterialProperties
    bool hasRelaxations() const;
    IfcTemplatedEntityList< IfcRelaxation >::ptr Relaxations() const;
    void setRelaxations(IfcTemplatedEntityList< IfcRelaxation >::ptr v);
    virtual unsigned int getArgumentCount() const { return 13; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 6: return IfcUtil::Argument_DOUBLE; case 7: return IfcUtil::Argument_DOUBLE; case 8: return IfcUtil::Argument_DOUBLE; case 9: return IfcUtil::Argument_DOUBLE; case 10: return IfcUtil::Argument_DOUBLE; case 11: return IfcUtil::Argument_DOUBLE; case 12: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } return IfcMechanicalMaterialProperties::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 6: return Type::IfcPressureMeasure; case 7: return Type::IfcPressureMeasure; case 8: return Type::IfcPositiveRatioMeasure; case 9: return Type::IfcModulusOfElasticityMeasure; case 10: return Type::IfcPressureMeasure; case 11: return Type::IfcPositiveRatioMeasure; case 12: return Type::IfcRelaxation; } return IfcMechanicalMaterialProperties::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 6: return "YieldStress"; case 7: return "UltimateStress"; case 8: return "UltimateStrain"; case 9: return "HardeningModule"; case 10: return "ProportionalStress"; case 11: return "PlasticStrain"; case 12: return "Relaxations"; } return IfcMechanicalMaterialProperties::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcMechanicalSteelMaterialProperties (IfcAbstractEntity* e);
    IfcMechanicalSteelMaterialProperties (IfcMaterial* v1_Material, boost::optional< double > v2_DynamicViscosity, boost::optional< double > v3_YoungModulus, boost::optional< double > v4_ShearModulus, boost::optional< double > v5_PoissonRatio, boost::optional< double > v6_ThermalExpansionCoefficient, boost::optional< double > v7_YieldStress, boost::optional< double > v8_UltimateStress, boost::optional< double > v9_UltimateStrain, boost::optional< double > v10_HardeningModule, boost::optional< double > v11_ProportionalStress, boost::optional< double > v12_PlasticStrain, boost::optional< IfcTemplatedEntityList< IfcRelaxation >::ptr > v13_Relaxations);
    typedef IfcTemplatedEntityList< IfcMechanicalSteelMaterialProperties > list;
};
/// An IfcMetric is used to capture quantitative resultant metrics that can be applied to objectives. 
/// 
/// HISTORY: New Entity in IFC Release 2.0
/// 
/// Use Definition 
/// IfcMetric is a subtype of IfcConstraint and may be associated with any subtype of IfcRoot through the IfcRelAssociatesConstraint relationship in the IfcControlExtension schema, or may be associated with IfcProperty by IfcPropertyConstraintRelationship. 
/// 
/// The aim of IfcMetric is to capture the quantitative aspects of a constraint. 
/// 
/// For instance, when undertaking a move (instantiated through the IfcTask class), a constraint is instantiated as the class IfcMetric and may be named as a 'Move Start Constraint' or 'Move End Constraint' and described using one of a possible range of move constraints as shown in the table below. 
/// 
/// Constraint 
///   Description 
///   Benchmark 
///   Grade 
/// 
/// ASSOONASPOSSIBLE 
///   Action should commence at the earliest possible opportunity. 
///   GREATERTHANOREQUALTO 
///   SOFT 
/// 
/// MUSTSTARTON 
///   Action must start at a prescribed date/time. 
///   EQUALTO 
///   HARD 
/// 
/// MUSTSTARTBEFORE 
///   Action must start before a prescribed date/time. 
///   LESSTHANOREQUALTO 
///   HARD 
/// 
/// MUSTSTARTAFTER 
///   Action must not start before a prescribed date/time. 
///   GREATERTHANOREQUALTO 
///   HARD 
/// 
/// MAYSTARTAFTER 
///   Action may start at any time following a prescribed date/time. 
///   GREATERTHANOREQUALTO 
///   SOFT 
/// 
/// MUSTFINISHON 
///   Action must be complete at or by a prescribed date/time. 
///   EQUALTO 
///   HARD 
/// 
/// MUSTFINISHBEFORE 
///   Action must be complete before a prescribed date/time. 
///   LESSTHANOREQUALTO 
///   HARD 
/// 
/// This constraint (instantiated as IfcMetric) uses a Date/Time value in IfcMetric.DataValue through IfcMetricValueSelect. An appropriate benchmark is applied according to the requirement of the constraint (as indicated) by IfcMetric.Benchmark. The grade of the constraint (hard, soft, advisory) must be specified through		IfcConstraint.ConstraintGrade whilst the time at which the constraint is	created may be optionally asserted through IfcConstraint.CreationTime.
class IfcMetric : public IfcConstraint {
public:
    /// Enumeration that identifies the type of benchmark data.
    IfcBenchmarkEnum::IfcBenchmarkEnum Benchmark() const;
    void setBenchmark(IfcBenchmarkEnum::IfcBenchmarkEnum v);
    /// Whether the optional attribute ValueSource is defined for this IfcMetric
    bool hasValueSource() const;
    /// Reference source for data values.
    std::string ValueSource() const;
    void setValueSource(std::string v);
    /// The value with data type defined by the underlying type accesses via IfcMetricValueSelect.
    IfcMetricValueSelect* DataValue() const;
    void setDataValue(IfcMetricValueSelect* v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 7: return IfcUtil::Argument_ENUMERATION; case 8: return IfcUtil::Argument_STRING; case 9: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcConstraint::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 7: return Type::IfcBenchmarkEnum; case 8: return Type::IfcLabel; case 9: return Type::IfcMetricValueSelect; } return IfcConstraint::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 7: return "Benchmark"; case 8: return "ValueSource"; case 9: return "DataValue"; } return IfcConstraint::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcMetric (IfcAbstractEntity* e);
    IfcMetric (std::string v1_Name, boost::optional< std::string > v2_Description, IfcConstraintEnum::IfcConstraintEnum v3_ConstraintGrade, boost::optional< std::string > v4_ConstraintSource, IfcActorSelect* v5_CreatingActor, IfcDateTimeSelect* v6_CreationTime, boost::optional< std::string > v7_UserDefinedGrade, IfcBenchmarkEnum::IfcBenchmarkEnum v8_Benchmark, boost::optional< std::string > v9_ValueSource, IfcMetricValueSelect* v10_DataValue);
    typedef IfcTemplatedEntityList< IfcMetric > list;
};
/// IfcMonetaryUnit is a unit to define currency for money.
/// 
/// HISTORY: New entity in IFC Release 2x.
/// 
/// IFC2x4 CHANGE: Type of the attribute Currency changed.
class IfcMonetaryUnit : public IfcUtil::IfcBaseEntity {
public:
    /// Code or name of the currency.  Permissible values are the three-letter alphabetic currency codes as per ISO 4217, for example CNY, EUR, GBP, JPY, USD.
    IfcCurrencyEnum::IfcCurrencyEnum Currency() const;
    void setCurrency(IfcCurrencyEnum::IfcCurrencyEnum v);
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENUMERATION; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcCurrencyEnum; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Currency"; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcMonetaryUnit (IfcAbstractEntity* e);
    IfcMonetaryUnit (IfcCurrencyEnum::IfcCurrencyEnum v1_Currency);
    typedef IfcTemplatedEntityList< IfcMonetaryUnit > list;
};
/// Definition from ISO/CD 10303-41:1992: A named unit is a unit quantity associated with the word, or group of words, by which the unit is identified.
/// 
/// NOTE Corresponding ISO 10303 name: named_unit, please refer to ISO/IS 10303-41 for the final definition of the formal standard.
/// 
/// HISTORY New type in IFC Release 1.5.1.
class IfcNamedUnit : public IfcUtil::IfcBaseEntity {
public:
    /// The dimensional exponents of the SI base units by which the named unit is defined.
    IfcDimensionalExponents* Dimensions() const;
    void setDimensions(IfcDimensionalExponents* v);
    /// The type of the unit.
    IfcUnitEnum::IfcUnitEnum UnitType() const;
    void setUnitType(IfcUnitEnum::IfcUnitEnum v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_ENUMERATION; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcDimensionalExponents; case 1: return Type::IfcUnitEnum; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Dimensions"; case 1: return "UnitType"; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcNamedUnit (IfcAbstractEntity* e);
    IfcNamedUnit (IfcDimensionalExponents* v1_Dimensions, IfcUnitEnum::IfcUnitEnum v2_UnitType);
    typedef IfcTemplatedEntityList< IfcNamedUnit > list;
};
/// IfcObjectPlacement is an abstract supertype for the special types defining the object coordinate system. The
/// IfcObjectPlacement has to be provided for each product that has a shape representation.
/// The object placement can be given:
/// 
/// absolute: by an axis2 placement, relative to the world coordinate system,
/// relative: by an axis2 placement, relative to the object placement of another product,
/// by grid reference: by the virtual intersection and reference direction given by two axes of a design grid.
/// 
/// In any case the object placement has to unambiguously define the object coordinate system as either two-dimensional axis placement (IfcAxis2Placement2D) or three-dimensional axis placement (IfcAxis2Placement3D). The axis placement may have to be calculated.
/// 
/// HISTORY New entity in IFC Release 2x.
class IfcObjectPlacement : public IfcUtil::IfcBaseEntity {
public:
    virtual unsigned int getArgumentCount() const { return 0; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcProduct >::ptr PlacesObject() const; // INVERSE IfcProduct::ObjectPlacement
    IfcTemplatedEntityList< IfcLocalPlacement >::ptr ReferencedByPlacements() const; // INVERSE IfcLocalPlacement::PlacementRelTo
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcObjectPlacement (IfcAbstractEntity* e);
    IfcObjectPlacement ();
    typedef IfcTemplatedEntityList< IfcObjectPlacement > list;
};
/// An IfcObjective captures qualitative information for an objective-based constraint. 
/// 
/// HISTORY: New Entity in IFC Release 2.0
/// 
/// Use definition 
/// 
/// IfcObjective is a subtype of IfcConstraint and may be associated with any subtype of IfcRoot through the IfcRelAssociatesConstraint relationship in the IfcControlExtension schema, or may be associated with IfcProperty by IfcPropertyConstraintRelationship.
/// 
/// The aim of IfcObjective is to specify the purpose for which the constraint is applied and to capture the values of the constraint. These may be both the benchmark values that are intended to indicate the constraint extent and the resulting values in use that enable performance comparisons to be applied.
class IfcObjective : public IfcConstraint {
public:
    /// Whether the optional attribute BenchmarkValues is defined for this IfcObjective
    bool hasBenchmarkValues() const;
    /// A list of any benchmark values used for comparison purposes.
    IfcMetric* BenchmarkValues() const;
    void setBenchmarkValues(IfcMetric* v);
    /// Whether the optional attribute ResultValues is defined for this IfcObjective
    bool hasResultValues() const;
    /// A list of any resultant values used for comparison purposes.
    IfcMetric* ResultValues() const;
    void setResultValues(IfcMetric* v);
    /// Enumeration that qualifies the type of objective constraint.
    IfcObjectiveEnum::IfcObjectiveEnum ObjectiveQualifier() const;
    void setObjectiveQualifier(IfcObjectiveEnum::IfcObjectiveEnum v);
    /// Whether the optional attribute UserDefinedQualifier is defined for this IfcObjective
    bool hasUserDefinedQualifier() const;
    /// A user defined value that qualifies the type of objective constraint when ObjectiveQualifier attribute of type IfcObjectiveEnum has value USERDEFINED.
    std::string UserDefinedQualifier() const;
    void setUserDefinedQualifier(std::string v);
    virtual unsigned int getArgumentCount() const { return 11; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 7: return IfcUtil::Argument_ENTITY_INSTANCE; case 8: return IfcUtil::Argument_ENTITY_INSTANCE; case 9: return IfcUtil::Argument_ENUMERATION; case 10: return IfcUtil::Argument_STRING; } return IfcConstraint::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 7: return Type::IfcMetric; case 8: return Type::IfcMetric; case 9: return Type::IfcObjectiveEnum; case 10: return Type::IfcLabel; } return IfcConstraint::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 7: return "BenchmarkValues"; case 8: return "ResultValues"; case 9: return "ObjectiveQualifier"; case 10: return "UserDefinedQualifier"; } return IfcConstraint::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcObjective (IfcAbstractEntity* e);
    IfcObjective (std::string v1_Name, boost::optional< std::string > v2_Description, IfcConstraintEnum::IfcConstraintEnum v3_ConstraintGrade, boost::optional< std::string > v4_ConstraintSource, IfcActorSelect* v5_CreatingActor, IfcDateTimeSelect* v6_CreationTime, boost::optional< std::string > v7_UserDefinedGrade, IfcMetric* v8_BenchmarkValues, IfcMetric* v9_ResultValues, IfcObjectiveEnum::IfcObjectiveEnum v10_ObjectiveQualifier, boost::optional< std::string > v11_UserDefinedQualifier);
    typedef IfcTemplatedEntityList< IfcObjective > list;
};

class IfcOpticalMaterialProperties : public IfcMaterialProperties {
public:
    /// Whether the optional attribute VisibleTransmittance is defined for this IfcOpticalMaterialProperties
    bool hasVisibleTransmittance() const;
    double VisibleTransmittance() const;
    void setVisibleTransmittance(double v);
    /// Whether the optional attribute SolarTransmittance is defined for this IfcOpticalMaterialProperties
    bool hasSolarTransmittance() const;
    double SolarTransmittance() const;
    void setSolarTransmittance(double v);
    /// Whether the optional attribute ThermalIrTransmittance is defined for this IfcOpticalMaterialProperties
    bool hasThermalIrTransmittance() const;
    double ThermalIrTransmittance() const;
    void setThermalIrTransmittance(double v);
    /// Whether the optional attribute ThermalIrEmissivityBack is defined for this IfcOpticalMaterialProperties
    bool hasThermalIrEmissivityBack() const;
    double ThermalIrEmissivityBack() const;
    void setThermalIrEmissivityBack(double v);
    /// Whether the optional attribute ThermalIrEmissivityFront is defined for this IfcOpticalMaterialProperties
    bool hasThermalIrEmissivityFront() const;
    double ThermalIrEmissivityFront() const;
    void setThermalIrEmissivityFront(double v);
    /// Whether the optional attribute VisibleReflectanceBack is defined for this IfcOpticalMaterialProperties
    bool hasVisibleReflectanceBack() const;
    double VisibleReflectanceBack() const;
    void setVisibleReflectanceBack(double v);
    /// Whether the optional attribute VisibleReflectanceFront is defined for this IfcOpticalMaterialProperties
    bool hasVisibleReflectanceFront() const;
    double VisibleReflectanceFront() const;
    void setVisibleReflectanceFront(double v);
    /// Whether the optional attribute SolarReflectanceFront is defined for this IfcOpticalMaterialProperties
    bool hasSolarReflectanceFront() const;
    double SolarReflectanceFront() const;
    void setSolarReflectanceFront(double v);
    /// Whether the optional attribute SolarReflectanceBack is defined for this IfcOpticalMaterialProperties
    bool hasSolarReflectanceBack() const;
    double SolarReflectanceBack() const;
    void setSolarReflectanceBack(double v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 1: return IfcUtil::Argument_DOUBLE; case 2: return IfcUtil::Argument_DOUBLE; case 3: return IfcUtil::Argument_DOUBLE; case 4: return IfcUtil::Argument_DOUBLE; case 5: return IfcUtil::Argument_DOUBLE; case 6: return IfcUtil::Argument_DOUBLE; case 7: return IfcUtil::Argument_DOUBLE; case 8: return IfcUtil::Argument_DOUBLE; case 9: return IfcUtil::Argument_DOUBLE; } return IfcMaterialProperties::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 1: return Type::IfcPositiveRatioMeasure; case 2: return Type::IfcPositiveRatioMeasure; case 3: return Type::IfcPositiveRatioMeasure; case 4: return Type::IfcPositiveRatioMeasure; case 5: return Type::IfcPositiveRatioMeasure; case 6: return Type::IfcPositiveRatioMeasure; case 7: return Type::IfcPositiveRatioMeasure; case 8: return Type::IfcPositiveRatioMeasure; case 9: return Type::IfcPositiveRatioMeasure; } return IfcMaterialProperties::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 1: return "VisibleTransmittance"; case 2: return "SolarTransmittance"; case 3: return "ThermalIrTransmittance"; case 4: return "ThermalIrEmissivityBack"; case 5: return "ThermalIrEmissivityFront"; case 6: return "VisibleReflectanceBack"; case 7: return "VisibleReflectanceFront"; case 8: return "SolarReflectanceFront"; case 9: return "SolarReflectanceBack"; } return IfcMaterialProperties::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcOpticalMaterialProperties (IfcAbstractEntity* e);
    IfcOpticalMaterialProperties (IfcMaterial* v1_Material, boost::optional< double > v2_VisibleTransmittance, boost::optional< double > v3_SolarTransmittance, boost::optional< double > v4_ThermalIrTransmittance, boost::optional< double > v5_ThermalIrEmissivityBack, boost::optional< double > v6_ThermalIrEmissivityFront, boost::optional< double > v7_VisibleReflectanceBack, boost::optional< double > v8_VisibleReflectanceFront, boost::optional< double > v9_SolarReflectanceFront, boost::optional< double > v10_SolarReflectanceBack);
    typedef IfcTemplatedEntityList< IfcOpticalMaterialProperties > list;
};
/// A named and structured grouping with a corporate identity.
/// 
/// NOTE: The relationships between IfcOrganizations, like a Department within a Company, can be expressed using IfcOrganizationRelationship.
/// 
/// NOTE Corresponds to the following entity in ISO-10303-41: organization.
/// 
/// HISTORY New entity in IFC Release 1.5.1.
/// IFC 2x4 change: attribute Id renamed to Identification.
class IfcOrganization : public IfcUtil::IfcBaseEntity {
public:
    /// Whether the optional attribute Id is defined for this IfcOrganization
    bool hasId() const;
    std::string Id() const;
    void setId(std::string v);
    /// The word, or group of words, by which the organization is referred to.
    std::string Name() const;
    void setName(std::string v);
    /// Whether the optional attribute Description is defined for this IfcOrganization
    bool hasDescription() const;
    /// Text that relates the nature of the organization.
    std::string Description() const;
    void setDescription(std::string v);
    /// Whether the optional attribute Roles is defined for this IfcOrganization
    bool hasRoles() const;
    /// Roles played by the organization.
    IfcTemplatedEntityList< IfcActorRole >::ptr Roles() const;
    void setRoles(IfcTemplatedEntityList< IfcActorRole >::ptr v);
    /// Whether the optional attribute Addresses is defined for this IfcOrganization
    bool hasAddresses() const;
    /// Postal and telecom addresses of an organization.
    /// NOTE: There may be several addresses related to an organization.
    IfcTemplatedEntityList< IfcAddress >::ptr Addresses() const;
    void setAddresses(IfcTemplatedEntityList< IfcAddress >::ptr v);
    virtual unsigned int getArgumentCount() const { return 5; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_STRING; case 1: return IfcUtil::Argument_STRING; case 2: return IfcUtil::Argument_STRING; case 3: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 4: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcIdentifier; case 1: return Type::IfcLabel; case 2: return Type::IfcText; case 3: return Type::IfcActorRole; case 4: return Type::IfcAddress; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Id"; case 1: return "Name"; case 2: return "Description"; case 3: return "Roles"; case 4: return "Addresses"; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcOrganizationRelationship >::ptr IsRelatedBy() const; // INVERSE IfcOrganizationRelationship::RelatedOrganizations
    IfcTemplatedEntityList< IfcOrganizationRelationship >::ptr Relates() const; // INVERSE IfcOrganizationRelationship::RelatingOrganization
    IfcTemplatedEntityList< IfcPersonAndOrganization >::ptr Engages() const; // INVERSE IfcPersonAndOrganization::TheOrganization
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcOrganization (IfcAbstractEntity* e);
    IfcOrganization (boost::optional< std::string > v1_Id, std::string v2_Name, boost::optional< std::string > v3_Description, boost::optional< IfcTemplatedEntityList< IfcActorRole >::ptr > v4_Roles, boost::optional< IfcTemplatedEntityList< IfcAddress >::ptr > v5_Addresses);
    typedef IfcTemplatedEntityList< IfcOrganization > list;
};
/// Definition: establishes an association between one relating organization and one or more related organizations.
/// 
/// NOTE Corresponds to the following entity in ISO-10303-41: organization_relationship.
/// 
/// HISTORY New entity in IFC Release 2x.
/// IFC 2x4 change: attribute Name made optional.
class IfcOrganizationRelationship : public IfcUtil::IfcBaseEntity {
public:
    /// The word or group of words by which the relationship is referred to.
    std::string Name() const;
    void setName(std::string v);
    /// Whether the optional attribute Description is defined for this IfcOrganizationRelationship
    bool hasDescription() const;
    /// Text that relates the nature of the relationship.
    std::string Description() const;
    void setDescription(std::string v);
    /// Organization which is the relating part of the relationship between organizations.
    IfcOrganization* RelatingOrganization() const;
    void setRelatingOrganization(IfcOrganization* v);
    /// The other, possibly dependent, organizations which are the related parts of the relationship between organizations.
    IfcTemplatedEntityList< IfcOrganization >::ptr RelatedOrganizations() const;
    void setRelatedOrganizations(IfcTemplatedEntityList< IfcOrganization >::ptr v);
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_STRING; case 1: return IfcUtil::Argument_STRING; case 2: return IfcUtil::Argument_ENTITY_INSTANCE; case 3: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcLabel; case 1: return Type::IfcText; case 2: return Type::IfcOrganization; case 3: return Type::IfcOrganization; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Name"; case 1: return "Description"; case 2: return "RelatingOrganization"; case 3: return "RelatedOrganizations"; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcOrganizationRelationship (IfcAbstractEntity* e);
    IfcOrganizationRelationship (std::string v1_Name, boost::optional< std::string > v2_Description, IfcOrganization* v3_RelatingOrganization, IfcTemplatedEntityList< IfcOrganization >::ptr v4_RelatedOrganizations);
    typedef IfcTemplatedEntityList< IfcOrganizationRelationship > list;
};
/// IfcOwnerHistory defines all history and identification related information. In order to provide fast access it is directly attached to all independent objects, relationships and properties.
/// 
/// IfcOwnerHistory is used to identify the creating and owning application and user for the associated object, as well as capture the last modifying application and user.
/// 
/// HISTORY  New entity in IFC R1.0. Modified in IFC R2x4.
/// 
/// Informal propositions
/// 
/// If LastModifiedDate is defined but ChangeAction is not asserted, then the state of ChangeAction is assumed to be UNDEFINED.	  
/// If both LastModifiedDate and ChangeAction are asserted, then the state of ChangeAction applies to the value asserted in LastModifiedDate.
class IfcOwnerHistory : public IfcUtil::IfcBaseEntity {
public:
    /// Direct reference to the end user who currently "owns" this object. Note that IFC includes the concept of ownership transfer from one user to another and therefore distinguishes between the Owning User and Creating User.
    IfcPersonAndOrganization* OwningUser() const;
    void setOwningUser(IfcPersonAndOrganization* v);
    /// Direct reference to the application which currently "Owns" this object on behalf of the owning user, who uses this application. Note that IFC includes the concept of ownership transfer from one application to another and therefore distinguishes between the Owning Application and Creating Application.
    IfcApplication* OwningApplication() const;
    void setOwningApplication(IfcApplication* v);
    /// Whether the optional attribute State is defined for this IfcOwnerHistory
    bool hasState() const;
    /// Enumeration that defines the current access state of the object.
    IfcStateEnum::IfcStateEnum State() const;
    void setState(IfcStateEnum::IfcStateEnum v);
    /// Enumeration that defines the actions associated with changes made to the object.
    IfcChangeActionEnum::IfcChangeActionEnum ChangeAction() const;
    void setChangeAction(IfcChangeActionEnum::IfcChangeActionEnum v);
    /// Whether the optional attribute LastModifiedDate is defined for this IfcOwnerHistory
    bool hasLastModifiedDate() const;
    /// Date and Time expressed in UTC (Universal Time Coordinated, formerly Greenwich Mean Time or GMT) at which the last modification was made by LastModifyingUser and LastModifyingApplication.
    int LastModifiedDate() const;
    void setLastModifiedDate(int v);
    /// Whether the optional attribute LastModifyingUser is defined for this IfcOwnerHistory
    bool hasLastModifyingUser() const;
    /// User who carried out the last modification using LastModifyingApplication.
    IfcPersonAndOrganization* LastModifyingUser() const;
    void setLastModifyingUser(IfcPersonAndOrganization* v);
    /// Whether the optional attribute LastModifyingApplication is defined for this IfcOwnerHistory
    bool hasLastModifyingApplication() const;
    /// Application used to make the last modification.
    IfcApplication* LastModifyingApplication() const;
    void setLastModifyingApplication(IfcApplication* v);
    /// The date and time expressed in UTC (Universal Time Coordinated, formerly Greenwich Mean Time or GMT) when first created by the original OwningApplication. Once defined this value remains unchanged through the lifetime of the entity.
    int CreationDate() const;
    void setCreationDate(int v);
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_ENTITY_INSTANCE; case 2: return IfcUtil::Argument_ENUMERATION; case 3: return IfcUtil::Argument_ENUMERATION; case 4: return IfcUtil::Argument_INT; case 5: return IfcUtil::Argument_ENTITY_INSTANCE; case 6: return IfcUtil::Argument_ENTITY_INSTANCE; case 7: return IfcUtil::Argument_INT; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcPersonAndOrganization; case 1: return Type::IfcApplication; case 2: return Type::IfcStateEnum; case 3: return Type::IfcChangeActionEnum; case 4: return Type::IfcTimeStamp; case 5: return Type::IfcPersonAndOrganization; case 6: return Type::IfcApplication; case 7: return Type::IfcTimeStamp; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "OwningUser"; case 1: return "OwningApplication"; case 2: return "State"; case 3: return "ChangeAction"; case 4: return "LastModifiedDate"; case 5: return "LastModifyingUser"; case 6: return "LastModifyingApplication"; case 7: return "CreationDate"; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcOwnerHistory (IfcAbstractEntity* e);
    IfcOwnerHistory (IfcPersonAndOrganization* v1_OwningUser, IfcApplication* v2_OwningApplication, boost::optional< IfcStateEnum::IfcStateEnum > v3_State, IfcChangeActionEnum::IfcChangeActionEnum v4_ChangeAction, boost::optional< int > v5_LastModifiedDate, IfcPersonAndOrganization* v6_LastModifyingUser, IfcApplication* v7_LastModifyingApplication, int v8_CreationDate);
    typedef IfcTemplatedEntityList< IfcOwnerHistory > list;
};
/// Definition: an individual human being.
/// 
/// NOTE Many countries have legislation concerning the identification of individual persons within databases. Although the intent of the IFC Model is to act as a specification for data exchange 
/// and sharing, an IFC file might in some situations be considered to be a database that enables identification of a particular person under the terms of such legislation. Users should be aware of the constraints of legislation that might apply in the places where IFC files are used.
/// 
/// NOTE Corresponds to the following entity in ISO-10303-41: person.
/// 
/// HISTORY New entity in IFC Release 1.5.1.
/// IFC 2x4 change: attribute Id renamed to Identification.  WHERE rule relaxed to allow omission of names if Identification is provided.
class IfcPerson : public IfcUtil::IfcBaseEntity {
public:
    /// Whether the optional attribute Id is defined for this IfcPerson
    bool hasId() const;
    std::string Id() const;
    void setId(std::string v);
    /// Whether the optional attribute FamilyName is defined for this IfcPerson
    bool hasFamilyName() const;
    /// The name by which the family identity of the person may be recognized.
    /// NOTE: Depending on geographical location and culture, family name may appear either as the first or last component of a name.
    std::string FamilyName() const;
    void setFamilyName(std::string v);
    /// Whether the optional attribute GivenName is defined for this IfcPerson
    bool hasGivenName() const;
    /// The name by which a person is known within a family and by which he or she may be familiarly recognized.
    /// NOTE: Depending on geographical location and culture, given name may appear either as the first or last component of a name.
    std::string GivenName() const;
    void setGivenName(std::string v);
    /// Whether the optional attribute MiddleNames is defined for this IfcPerson
    bool hasMiddleNames() const;
    /// Additional names given to a person that enable their identification apart from others who may have the same or similar family and given names.
    /// NOTE: Middle names are not normally used in familiar communication but may be asserted to provide additional 
    /// identification of a particular person if necessary. They may be particularly useful in situations where the person concerned has a 
    /// family name that occurs commonly in the geographical region.
    std::vector< std::string > /*[1:?]*/ MiddleNames() const;
    void setMiddleNames(std::vector< std::string > /*[1:?]*/ v);
    /// Whether the optional attribute PrefixTitles is defined for this IfcPerson
    bool hasPrefixTitles() const;
    /// The word, or group of words, which specify the person's social and/or professional standing and appear before his/her names.
    std::vector< std::string > /*[1:?]*/ PrefixTitles() const;
    void setPrefixTitles(std::vector< std::string > /*[1:?]*/ v);
    /// Whether the optional attribute SuffixTitles is defined for this IfcPerson
    bool hasSuffixTitles() const;
    /// The word, or group of words, which specify the person's social and/or professional standing and appear after his/her names.
    std::vector< std::string > /*[1:?]*/ SuffixTitles() const;
    void setSuffixTitles(std::vector< std::string > /*[1:?]*/ v);
    /// Whether the optional attribute Roles is defined for this IfcPerson
    bool hasRoles() const;
    /// Roles played by the person.
    IfcTemplatedEntityList< IfcActorRole >::ptr Roles() const;
    void setRoles(IfcTemplatedEntityList< IfcActorRole >::ptr v);
    /// Whether the optional attribute Addresses is defined for this IfcPerson
    bool hasAddresses() const;
    /// Postal and telecommunication addresses of a person.
    /// NOTE - A person may have several addresses.
    IfcTemplatedEntityList< IfcAddress >::ptr Addresses() const;
    void setAddresses(IfcTemplatedEntityList< IfcAddress >::ptr v);
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_STRING; case 1: return IfcUtil::Argument_STRING; case 2: return IfcUtil::Argument_STRING; case 3: return IfcUtil::Argument_AGGREGATE_OF_STRING; case 4: return IfcUtil::Argument_AGGREGATE_OF_STRING; case 5: return IfcUtil::Argument_AGGREGATE_OF_STRING; case 6: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 7: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcIdentifier; case 1: return Type::IfcLabel; case 2: return Type::IfcLabel; case 3: return Type::IfcLabel; case 4: return Type::IfcLabel; case 5: return Type::IfcLabel; case 6: return Type::IfcActorRole; case 7: return Type::IfcAddress; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Id"; case 1: return "FamilyName"; case 2: return "GivenName"; case 3: return "MiddleNames"; case 4: return "PrefixTitles"; case 5: return "SuffixTitles"; case 6: return "Roles"; case 7: return "Addresses"; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcPersonAndOrganization >::ptr EngagedIn() const; // INVERSE IfcPersonAndOrganization::ThePerson
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPerson (IfcAbstractEntity* e);
    IfcPerson (boost::optional< std::string > v1_Id, boost::optional< std::string > v2_FamilyName, boost::optional< std::string > v3_GivenName, boost::optional< std::vector< std::string > /*[1:?]*/ > v4_MiddleNames, boost::optional< std::vector< std::string > /*[1:?]*/ > v5_PrefixTitles, boost::optional< std::vector< std::string > /*[1:?]*/ > v6_SuffixTitles, boost::optional< IfcTemplatedEntityList< IfcActorRole >::ptr > v7_Roles, boost::optional< IfcTemplatedEntityList< IfcAddress >::ptr > v8_Addresses);
    typedef IfcTemplatedEntityList< IfcPerson > list;
};
/// Definition: Identification of a person within an organization.
/// 
/// NOTE Corresponds to the following entity in ISO-10303-41: person_and_organization.
/// 
/// HISTORY New entity in IFC Release 1.5.1
class IfcPersonAndOrganization : public IfcUtil::IfcBaseEntity {
public:
    /// The person who is related to the organization.
    IfcPerson* ThePerson() const;
    void setThePerson(IfcPerson* v);
    /// The organization to which the person is related.
    IfcOrganization* TheOrganization() const;
    void setTheOrganization(IfcOrganization* v);
    /// Whether the optional attribute Roles is defined for this IfcPersonAndOrganization
    bool hasRoles() const;
    /// Roles played by the person within the context of an organization.  These may differ from the roles in ThePerson.Roles which may be asserted without organizational context.
    IfcTemplatedEntityList< IfcActorRole >::ptr Roles() const;
    void setRoles(IfcTemplatedEntityList< IfcActorRole >::ptr v);
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_ENTITY_INSTANCE; case 2: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcPerson; case 1: return Type::IfcOrganization; case 2: return Type::IfcActorRole; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "ThePerson"; case 1: return "TheOrganization"; case 2: return "Roles"; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPersonAndOrganization (IfcAbstractEntity* e);
    IfcPersonAndOrganization (IfcPerson* v1_ThePerson, IfcOrganization* v2_TheOrganization, boost::optional< IfcTemplatedEntityList< IfcActorRole >::ptr > v3_Roles);
    typedef IfcTemplatedEntityList< IfcPersonAndOrganization > list;
};
/// The physical quantity, IfcPhysicalQuantity, is an abstract entity that holds a complex or simple quantity measure together with a semantic definition of the usage for the single or several measure value. 
/// 
/// The Name attribute defines the actual usage or kind of measure. The interpretation of the name label has to be established within the actual exchange context. In addition an informative text may be associated to each quantity by the Description attribute. 
/// 
/// HISTORY  New entity in IFC2x. It replaces the calcXxx attributes used in previous IFC Releases.
class IfcPhysicalQuantity : public IfcUtil::IfcBaseEntity {
public:
    /// Name of the element quantity or measure. The name attribute has to be made recognizable by further agreements.
    std::string Name() const;
    void setName(std::string v);
    /// Whether the optional attribute Description is defined for this IfcPhysicalQuantity
    bool hasDescription() const;
    /// Further explanation that might be given to the quantity.
    std::string Description() const;
    void setDescription(std::string v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_STRING; case 1: return IfcUtil::Argument_STRING; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcLabel; case 1: return Type::IfcText; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Name"; case 1: return "Description"; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcPhysicalComplexQuantity >::ptr PartOfComplex() const; // INVERSE IfcPhysicalComplexQuantity::HasQuantities
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPhysicalQuantity (IfcAbstractEntity* e);
    IfcPhysicalQuantity (std::string v1_Name, boost::optional< std::string > v2_Description);
    typedef IfcTemplatedEntityList< IfcPhysicalQuantity > list;
};
/// The physical quantity, IfcPhysicalSimpleQuantity, is an entity that holds a single quantity measure value (as defined at the subtypes of IfcPhysicalSimpleQuantity) together with a semantic definition of the usage for the measure value. 
/// 
/// EXAMPLE  An element, like a wall, may have several area measures, like footprint area, left wall face area, right wall face area. These areas would be given by three instances of the area quantity subtype, with different Name string values.
/// 
/// A section "Quantity Use Definition" at individual entities as subtypes of IfcBuildingElement gives guidance to the usage of the Name attribute to characterize the individual quantities. If the Unit attribute is given, the value attribute (introduced at the level of subtypes of IfcPhysicalSimpleQuantity) are given as quantities of this unit, otherwise the global unit definitions (given by IfcUnitAssignment) are used.
/// 
/// HISTORY New entity in IFC2x2 Addendum 1.
/// 
/// IFC2x2 ADDENDUM 1 CHANGE  The abstract entity IfcPhysicalSimpleQuantity has been added. Upward compatibility for file based exchange is guaranteed.
class IfcPhysicalSimpleQuantity : public IfcPhysicalQuantity {
public:
    /// Whether the optional attribute Unit is defined for this IfcPhysicalSimpleQuantity
    bool hasUnit() const;
    /// Optional assignment of a unit. If no unit is given, then the global unit assignment, as established at the IfcProject, applies to the quantity measures.
    IfcNamedUnit* Unit() const;
    void setUnit(IfcNamedUnit* v);
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 2: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcPhysicalQuantity::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 2: return Type::IfcNamedUnit; } return IfcPhysicalQuantity::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 2: return "Unit"; } return IfcPhysicalQuantity::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPhysicalSimpleQuantity (IfcAbstractEntity* e);
    IfcPhysicalSimpleQuantity (std::string v1_Name, boost::optional< std::string > v2_Description, IfcNamedUnit* v3_Unit);
    typedef IfcTemplatedEntityList< IfcPhysicalSimpleQuantity > list;
};
/// Definition: The address for delivery of paper based mail.
/// 
/// HISTORY New entity in IFC Release 2x.
class IfcPostalAddress : public IfcAddress {
public:
    /// Whether the optional attribute InternalLocation is defined for this IfcPostalAddress
    bool hasInternalLocation() const;
    /// An organization defined address for internal mail delivery.
    std::string InternalLocation() const;
    void setInternalLocation(std::string v);
    /// Whether the optional attribute AddressLines is defined for this IfcPostalAddress
    bool hasAddressLines() const;
    /// The postal address.
    /// NOTE: A postal address may occupy several lines (or elements) when recorded. 
    /// It is expected that normal usage will incorporate relevant elements of the following address concepts: 
    /// A location within a building (e.g. 3rd Floor) Building name (e.g. Interoperability House) Street number 
    /// (e.g. 6400) Street name (e.g. Alliance Boulevard). Typical content of address lines may vary in different 
    /// countries.
    std::vector< std::string > /*[1:?]*/ AddressLines() const;
    void setAddressLines(std::vector< std::string > /*[1:?]*/ v);
    /// Whether the optional attribute PostalBox is defined for this IfcPostalAddress
    bool hasPostalBox() const;
    /// An address that is implied by an identifiable mail drop.
    std::string PostalBox() const;
    void setPostalBox(std::string v);
    /// Whether the optional attribute Town is defined for this IfcPostalAddress
    bool hasTown() const;
    /// The name of a town.
    std::string Town() const;
    void setTown(std::string v);
    /// Whether the optional attribute Region is defined for this IfcPostalAddress
    bool hasRegion() const;
    /// The name of a region.
    /// NOTE: The counties of the United Kingdom and the states of North America are examples of regions.
    std::string Region() const;
    void setRegion(std::string v);
    /// Whether the optional attribute PostalCode is defined for this IfcPostalAddress
    bool hasPostalCode() const;
    /// The code that is used by the country's postal service.
    std::string PostalCode() const;
    void setPostalCode(std::string v);
    /// Whether the optional attribute Country is defined for this IfcPostalAddress
    bool hasCountry() const;
    /// The name of a country.
    std::string Country() const;
    void setCountry(std::string v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 3: return IfcUtil::Argument_STRING; case 4: return IfcUtil::Argument_AGGREGATE_OF_STRING; case 5: return IfcUtil::Argument_STRING; case 6: return IfcUtil::Argument_STRING; case 7: return IfcUtil::Argument_STRING; case 8: return IfcUtil::Argument_STRING; case 9: return IfcUtil::Argument_STRING; } return IfcAddress::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 3: return Type::IfcLabel; case 4: return Type::IfcLabel; case 5: return Type::IfcLabel; case 6: return Type::IfcLabel; case 7: return Type::IfcLabel; case 8: return Type::IfcLabel; case 9: return Type::IfcLabel; } return IfcAddress::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 3: return "InternalLocation"; case 4: return "AddressLines"; case 5: return "PostalBox"; case 6: return "Town"; case 7: return "Region"; case 8: return "PostalCode"; case 9: return "Country"; } return IfcAddress::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPostalAddress (IfcAbstractEntity* e);
    IfcPostalAddress (boost::optional< IfcAddressTypeEnum::IfcAddressTypeEnum > v1_Purpose, boost::optional< std::string > v2_Description, boost::optional< std::string > v3_UserDefinedPurpose, boost::optional< std::string > v4_InternalLocation, boost::optional< std::vector< std::string > /*[1:?]*/ > v5_AddressLines, boost::optional< std::string > v6_PostalBox, boost::optional< std::string > v7_Town, boost::optional< std::string > v8_Region, boost::optional< std::string > v9_PostalCode, boost::optional< std::string > v10_Country);
    typedef IfcTemplatedEntityList< IfcPostalAddress > list;
};
/// A pre defined item is a qualified name given to a style or font which is determined within the data exchange specification by convention on using the Name attribute value (in contrary to externally defined items, which are agreed by an external source).
/// 
/// NOTE  The convention on using the Name value is defined at the subtypes of IfcPreDefinedItem and is part of the specification.
/// 
/// NOTE  Corresponding ISO 10303 name: pre_defined_item. Please refer to ISO/IS 10303-41:1994, page 137 for the final definition of the formal standard.
/// 
/// HISTORY  New entity in IFC2x2.
class IfcPreDefinedItem : public IfcUtil::IfcBaseEntity {
public:
    /// The string by which the pre defined item is identified. Allowable values for the string are declared at the level of subtypes.
    std::string Name() const;
    void setName(std::string v);
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_STRING; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcLabel; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Name"; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPreDefinedItem (IfcAbstractEntity* e);
    IfcPreDefinedItem (std::string v1_Name);
    typedef IfcTemplatedEntityList< IfcPreDefinedItem > list;
};
/// A predefined symbol is a symbol that gets its shape information by a conforming name that is specified within subtypes of the entity.
/// 
/// NOTE: The IfcPreDefinedSymbol is an entity that had been adopted from ISO 10303, Industrial automation systems and integration&#151;Product data representation and exchange, Part 46: Integrated generic resources: Visual presentation.
/// 
/// NOTE Corresponding ISO 10303 name: pre_defined_symbol. Please refer to ISO/IS 10303-46:1994 for the final definition of the formal standard.
/// 
/// HISTORY New entity in IFC2x2.
class IfcPreDefinedSymbol : public IfcPreDefinedItem {
public:
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcPreDefinedItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcPreDefinedItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcPreDefinedItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPreDefinedSymbol (IfcAbstractEntity* e);
    IfcPreDefinedSymbol (std::string v1_Name);
    typedef IfcTemplatedEntityList< IfcPreDefinedSymbol > list;
};

class IfcPreDefinedTerminatorSymbol : public IfcPreDefinedSymbol {
public:
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcPreDefinedSymbol::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcPreDefinedSymbol::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcPreDefinedSymbol::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPreDefinedTerminatorSymbol (IfcAbstractEntity* e);
    IfcPreDefinedTerminatorSymbol (std::string v1_Name);
    typedef IfcTemplatedEntityList< IfcPreDefinedTerminatorSymbol > list;
};
/// The pre defined text font determines those qualified names which can be used for fonts that are in scope of the current data exchange specification (in contrary to externally defined text fonts). There are two choices:
/// 
/// IfcDraughtingPreDefinedTextFont for definitions from ISO/IS 10303-46:1994 for (old) vector based and monospace text.
/// 
/// IfcTextStyleFontModel for definitions from Cascading Style Sheets, level 1, W3C Recommendation 17 Dec 1996, revised 11 Jan 1999, CSS1, for all true type text. The use of the CSS1 definitions is the preferred way to represent text fonts.
/// 
/// NOTE  Corresponding ISO 10303 name: pre_defined_text_font. Please refer to ISO/IS 10303-46:1994, p. 138 for the final definition of the formal standard.
/// 
/// HISTORY  New entity in IFC2x2.
/// 
/// IFC2x3 CHANGE  The IfcTextStyleFontModel has been added as new subtype.
class IfcPreDefinedTextFont : public IfcPreDefinedItem {
public:
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcPreDefinedItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcPreDefinedItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcPreDefinedItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPreDefinedTextFont (IfcAbstractEntity* e);
    IfcPreDefinedTextFont (std::string v1_Name);
    typedef IfcTemplatedEntityList< IfcPreDefinedTextFont > list;
};
/// The presentation layer assignment provides the layer name (and optionally a description and an identifier) for a collection of geometric representation items. The IfcPresentationLayerAssignment corresponds to the term "CAD Layer" and is used mainly for grouping and visibility control.
/// 
/// NOTE  The use of presentation layer shall be restricted to simple grouping and displaying purposes.
/// 
/// Visibility and access control and layer style assignment (colour, line style, line width) is handled by the subtype IfcPresentationLayerAssignmentWithStyle.
/// 
/// NOTE  Corresponding ISO 10303 name: presentation layer assignment. Please refer to ISO/IS 10303-46:1994, p. 36 for the final definition of the formal standard.
/// 
/// HISTORY  New entity in IFC2x2.
/// 
/// Attribute use definition
/// 
/// Figure 305 illustrates assignment of items by shape representation or representation item. The set of AssignedItems can either include a whole shape representation, or individual geometric representation items. If both, the IfcShapeRepresentation has a layer assignment, and an individual geometric representation item in the set of IfcShapeRepresentation.Items, then the layer assignment of the IfcGeometricRepresentationItem overides the layer assignment of the IfcShapeRepresentation.
/// 
/// Figure 305 — Presentation layer assignment
class IfcPresentationLayerAssignment : public IfcUtil::IfcBaseEntity {
public:
    /// Name of the layer.
    std::string Name() const;
    void setName(std::string v);
    /// Whether the optional attribute Description is defined for this IfcPresentationLayerAssignment
    bool hasDescription() const;
    /// Additional description of the layer.
    std::string Description() const;
    void setDescription(std::string v);
    /// The set of layered items, which are assigned to this layer.
    IfcEntityList::ptr AssignedItems() const;
    void setAssignedItems(IfcEntityList::ptr v);
    /// Whether the optional attribute Identifier is defined for this IfcPresentationLayerAssignment
    bool hasIdentifier() const;
    /// An (internal) identifier assigned to the layer.
    std::string Identifier() const;
    void setIdentifier(std::string v);
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_STRING; case 1: return IfcUtil::Argument_STRING; case 2: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 3: return IfcUtil::Argument_STRING; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcLabel; case 1: return Type::IfcText; case 2: return Type::IfcLayeredItem; case 3: return Type::IfcIdentifier; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Name"; case 1: return "Description"; case 2: return "AssignedItems"; case 3: return "Identifier"; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPresentationLayerAssignment (IfcAbstractEntity* e);
    IfcPresentationLayerAssignment (std::string v1_Name, boost::optional< std::string > v2_Description, IfcEntityList::ptr v3_AssignedItems, boost::optional< std::string > v4_Identifier);
    typedef IfcTemplatedEntityList< IfcPresentationLayerAssignment > list;
};
/// An IfcPresentationLayerAssignmentWithStyle extends the presentation layer assignment with capabilities to define visibility control, access control and common style information.
/// 
/// The visibility control allows to define a layer to be either 'on' or 'off', and/or 'frozen' or 'not frozen'. The access control allows to block graphical entities from manipulations by setting a layer to be either 'blocked' or 'not blocked'. Common style information can be given to the layer.
/// 
/// NOTE  Style information assigned to layers is often restricted to 'layer colour', 'curve font', and/or 'curve width'. These styles are assigned by using the IfcCurveStyle within the LayerStyles.
/// 
/// NOTE: If a styled item is assigned to a layer using the IfcPresentationLayerAssignmentWithStyle, it inherits the style information from the layer. In this case, it should omit its own style information. If the styled item has style information assigned (such as by IfcCurveStyle, IfcFillAreaStyle, IfcTextStyle, IfcSurfaceStyle, IfcSymbolStyle), then it overrides the style provided by the IfcPresentationLayerAssignmentWithStyle.
/// 
/// NOTE  The IfcPresentationLayerAssignmentWithStyle extends the presentation_layer_assignment entity as defined in ISO/IS 10303-46:1994, p. 36.
/// 
/// HISTORY  New entity in IFC2x2.
/// 
/// IFC2x3 CHANGE  The attributes have been modified without upward compatibility.
class IfcPresentationLayerWithStyle : public IfcPresentationLayerAssignment {
public:
    /// A logical setting, TRUE indicates that the layer is set to 'On', FALSE that the layer is set to 'Off', UNKNOWN that such information is not available.
    bool LayerOn() const;
    void setLayerOn(bool v);
    /// A logical setting, TRUE indicates that the layer is set to 'Frozen', FALSE that the layer is set to 'Not frozen', UNKNOWN that such information is not available.
    bool LayerFrozen() const;
    void setLayerFrozen(bool v);
    /// A logical setting, TRUE indicates that the layer is set to 'Blocked', FALSE that the layer is set to 'Not blocked', UNKNOWN that such information is not available.
    bool LayerBlocked() const;
    void setLayerBlocked(bool v);
    /// Assignment of presentation styles to the layer to provide a default style for representation items.
    /// 
    /// NOTE  In most cases the assignment of styles to a layer is restricted to an IfcCurveStyle representing the layer curve colour, layer curve thickness, and layer curve type.
    /// 
    /// IFC2x4 CHANGE  The data type has been changed from IfcPresentationStyleSelect (now deprecated) to IfcPresentationStyle.
    IfcEntityList::ptr LayerStyles() const;
    void setLayerStyles(IfcEntityList::ptr v);
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 4: return IfcUtil::Argument_BOOL; case 5: return IfcUtil::Argument_BOOL; case 6: return IfcUtil::Argument_BOOL; case 7: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } return IfcPresentationLayerAssignment::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 4: return Type::UNDEFINED; case 5: return Type::UNDEFINED; case 6: return Type::UNDEFINED; case 7: return Type::IfcPresentationStyleSelect; } return IfcPresentationLayerAssignment::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 4: return "LayerOn"; case 5: return "LayerFrozen"; case 6: return "LayerBlocked"; case 7: return "LayerStyles"; } return IfcPresentationLayerAssignment::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPresentationLayerWithStyle (IfcAbstractEntity* e);
    IfcPresentationLayerWithStyle (std::string v1_Name, boost::optional< std::string > v2_Description, IfcEntityList::ptr v3_AssignedItems, boost::optional< std::string > v4_Identifier, bool v5_LayerOn, bool v6_LayerFrozen, bool v7_LayerBlocked, IfcEntityList::ptr v8_LayerStyles);
    typedef IfcTemplatedEntityList< IfcPresentationLayerWithStyle > list;
};
/// IfcPresentationStyle is an abstract generalization of style table for presentation information assigned to geometric representation items. It includes styles for curves, areas, surfaces, text and symbols. Style information may include colour, hatching, rendering, and text fonts.
/// 
/// Each subtype of  IfcPresentationStyle can be assigned to IfcGeometricRepresentationItem's via the IfcPresentationStyleAssignment through an intermediate IfcStyledItem or one of its subtypes.
/// 
/// HISTORY  New entity in IFC2x3.
class IfcPresentationStyle : public IfcUtil::IfcBaseEntity {
public:
    /// Whether the optional attribute Name is defined for this IfcPresentationStyle
    bool hasName() const;
    /// Name of the presentation style.
    std::string Name() const;
    void setName(std::string v);
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_STRING; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcLabel; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Name"; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPresentationStyle (IfcAbstractEntity* e);
    IfcPresentationStyle (boost::optional< std::string > v1_Name);
    typedef IfcTemplatedEntityList< IfcPresentationStyle > list;
};
/// Definition from ISO/CD 10303-46:1992: The presentation style assignment is a set of styles which are assigned to styled items for the purpose of presenting these styled items. 
/// 
/// NOTE Corresponding ISO 10303 name: presentation_style_assignment. Please refer to ISO/IS 10303-46:1994 for the final definition of the formal standard.
/// 
/// HISTORY New entity in Release IFC2x2.
class IfcPresentationStyleAssignment : public IfcUtil::IfcBaseEntity {
public:
    /// A set of presentation styles that are assigned to styled items.
    IfcEntityList::ptr Styles() const;
    void setStyles(IfcEntityList::ptr v);
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcPresentationStyleSelect; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Styles"; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPresentationStyleAssignment (IfcAbstractEntity* e);
    IfcPresentationStyleAssignment (IfcEntityList::ptr v1_Styles);
    typedef IfcTemplatedEntityList< IfcPresentationStyleAssignment > list;
};
/// IfcProductRepresentation defines a representation of a
/// product, including its (geometric or topological) representation.
/// A product can have zero, one or many geometric representations,
/// and a single geometric representation can be shared among various
/// products using mapped representations.
/// 
/// NOTE: The definition
/// of this entity relates to the ISO 10303 entity property_definition.
/// The use of the term ‘property’ was avoided since it
/// conflicts with the property, property type, and property set
/// definitions elsewhere in the IFC model.
/// 
/// HISTORY New entity in IFC Release 2.0
/// 
/// IFC2x3 NOTE ÿUsers should not instantiate the entity from IFC2x Edition 3 onwards.
/// 
/// IFC2x4 CHANGE  Entity made abstract.
class IfcProductRepresentation : public IfcUtil::IfcBaseEntity {
public:
    /// Whether the optional attribute Name is defined for this IfcProductRepresentation
    bool hasName() const;
    /// The word or group of words by which the product representation is known.
    std::string Name() const;
    void setName(std::string v);
    /// Whether the optional attribute Description is defined for this IfcProductRepresentation
    bool hasDescription() const;
    /// The word or group of words that characterize the product representation. It can be used to add additional meaning to the name of the product representation.
    std::string Description() const;
    void setDescription(std::string v);
    /// Contained list of representations (including shape representations). Each member defines a valid representation of a particular type within a particular representation context.
    IfcTemplatedEntityList< IfcRepresentation >::ptr Representations() const;
    void setRepresentations(IfcTemplatedEntityList< IfcRepresentation >::ptr v);
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_STRING; case 1: return IfcUtil::Argument_STRING; case 2: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcLabel; case 1: return Type::IfcText; case 2: return Type::IfcRepresentation; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Name"; case 1: return "Description"; case 2: return "Representations"; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcProductRepresentation (IfcAbstractEntity* e);
    IfcProductRepresentation (boost::optional< std::string > v1_Name, boost::optional< std::string > v2_Description, IfcTemplatedEntityList< IfcRepresentation >::ptr v3_Representations);
    typedef IfcTemplatedEntityList< IfcProductRepresentation > list;
};

class IfcProductsOfCombustionProperties : public IfcMaterialProperties {
public:
    /// Whether the optional attribute SpecificHeatCapacity is defined for this IfcProductsOfCombustionProperties
    bool hasSpecificHeatCapacity() const;
    double SpecificHeatCapacity() const;
    void setSpecificHeatCapacity(double v);
    /// Whether the optional attribute N20Content is defined for this IfcProductsOfCombustionProperties
    bool hasN20Content() const;
    double N20Content() const;
    void setN20Content(double v);
    /// Whether the optional attribute COContent is defined for this IfcProductsOfCombustionProperties
    bool hasCOContent() const;
    double COContent() const;
    void setCOContent(double v);
    /// Whether the optional attribute CO2Content is defined for this IfcProductsOfCombustionProperties
    bool hasCO2Content() const;
    double CO2Content() const;
    void setCO2Content(double v);
    virtual unsigned int getArgumentCount() const { return 5; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 1: return IfcUtil::Argument_DOUBLE; case 2: return IfcUtil::Argument_DOUBLE; case 3: return IfcUtil::Argument_DOUBLE; case 4: return IfcUtil::Argument_DOUBLE; } return IfcMaterialProperties::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 1: return Type::IfcSpecificHeatCapacityMeasure; case 2: return Type::IfcPositiveRatioMeasure; case 3: return Type::IfcPositiveRatioMeasure; case 4: return Type::IfcPositiveRatioMeasure; } return IfcMaterialProperties::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 1: return "SpecificHeatCapacity"; case 2: return "N20Content"; case 3: return "COContent"; case 4: return "CO2Content"; } return IfcMaterialProperties::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcProductsOfCombustionProperties (IfcAbstractEntity* e);
    IfcProductsOfCombustionProperties (IfcMaterial* v1_Material, boost::optional< double > v2_SpecificHeatCapacity, boost::optional< double > v3_N20Content, boost::optional< double > v4_COContent, boost::optional< double > v5_CO2Content);
    typedef IfcTemplatedEntityList< IfcProductsOfCombustionProperties > list;
};
/// IfcProfileDef
/// is the supertype of all definitions of standard and arbitrary profiles
/// within IFC. It is used to define a standard set of commonly used
/// section profiles by their parameters or by their explicit curve geometry.
/// 
/// Parameterized profiles are 2D primitives, which are used within the industry to describe cross
///   sections by a description of its parameters.
///   Arbitrary profiles are cross
///   sections defined by an outer boundary as bounded curve, which may also
///   include holes, defined by inner boundaries.
///   Derived profiles, based on a
///   transformation of a parent profile, are also part of the profile
///   definitions available.
///   In addition composite
///   profiles can be defined, which include two or more profile definitions
///   to define the resulting profile.
/// 
/// HISTORY  New class in IFC Release 1.5, the capabilities have been extended in IFC Release 2x.
/// Profiles can now support swept surfaces and swept area solids with
/// inner boundaries. It had been renamed from IfcAttDrivenProfileDef.
/// 
/// IFC2x4 CHANGE  Changed from ABSTRACT to non-abstract for uses which do not
/// require an explicitly defined geometry.  Added inverse attributes HasProperties and HasExternalReference.
/// 
/// Use in material association
/// 
/// Beams, columns, and similarly shaped building elements and their type objects may
/// be associated with a section profile definition, combined with material definition,
/// by means of IfcRelAssociatesMaterial together with IfcMaterialProfileSet
/// and IfcMaterialProfileSetUsage. This way, building elements and element types
/// with same section and material can share a common section profile definition and
/// association.
/// 
/// The profile definition in material association is required to be consistent with
/// shape representations of the respective building elements.
/// 
/// A higher-level description of spatial aligment of the section profile of a member
/// (such as centered, bottom-left, in the geometric centroid, and more) can be provided
/// within IfcMaterialProfileSetUsage by means of a cardinal point reference.
/// This can be used redundant to geometric data in order to convey design intent.
/// 
/// Use in shape models
/// 
/// Profile definitions are used within the geometry and geometric model
/// resource to create either swept surfaces, swept area solids, or
/// sectioned spines.
/// 
/// The purpose of the profile
/// definition within the swept surfaces or swept area solids is to define
/// a uniform cross section being swept:
/// 
/// along a line (extrusion) using IfcSurfaceOfLinearExtrusion or IfcExtrudedAreaSolid
///   along a circular arc (revolution) using IfcSurfaceOfRevolution or IfcRevolvedAreaSolid
///   along a directrix lying on a reference surface using IfcSurfaceCurveSweptAreaSolid
/// 
/// The purpose fo the profile
/// definition within the sectioned spine is to define a varying cross
/// sections at several positions along a spine curve. The subtype IfcDerivedProfileDef
/// is particularly suited to provide the consecutive profiles to be based
/// on transformations of the start profile and thus maintaining the
/// identity of vertices and edges.
/// 
/// NOTE  Subtypes of the IfcProfileDef
/// contain parameterized profiles (as subtypes of IfcParameterizedProfileDef)
/// which establish their own 2D position coordinate system, profiles given
/// by explicit curve geometry (either open or closed profiles) and two
/// special types for composite profiles and derived profiles, based on a
/// 2D Cartesian transformation.
/// 
/// An IfcProfileDef
/// is treated as bounded area if it is used within swept area solids. In
/// this case, the inside of the profile is part of the profile. The
/// attribute ProfileType is set to AREA. An IfcProfileDef
/// is treated as a curve if it is used within swept surfaces. In this
/// case, the inside of the profile (if the curve is closed) is not part of
/// the profile. The attribute ProfileType
/// is set to CURVE.
/// 
/// Figure 320 illustrates use of parameterized profiles within a swept area solid.
/// 
/// Position
/// The IfcProfileDef is defined within the underlying
/// coordinate system which is defined by the swept surface or swept area solid
/// that uses the profile definition. It is the xy plane
/// 
/// of IfcSweptSurface.Position or
///   of IfcSweptAreaSolid.Position or
///   of each list member of IfcSectionedSpine.CrossSectionPositions.
/// 
/// In the figure to the left, the z axis of the position coordinate system points outwards of the drawing plane.
/// 
/// Note: The subtype IfcParameterizedProfileDef optionally provides an additional 2D position coordinate system relative to the underlying coordinate system of the IfcProfileDef.
/// 
/// Sweeping
/// 
/// In the later use of the IfcProfileDef
/// within the swept surface or swept area solid,  e.g. the IfcExtrudedAreaSolid
/// (here used as an example), the profile boundaries (here based on the 2D
/// position coordinate system of IfcParameterizedProfileDef)
/// are placed within the xy plane of the 3D position coordinate system of
/// the swept surface or swept area solid.
/// 
/// The profile is inserted into the underlying coordinate system either:
/// 
/// directly in case of using IfcArbitraryClosedProfileDef
///   and IfcArbitraryOpenProfileDef,
/// 
/// through an intermediate position coordinate system in case of
///   using IfcParameterizedProfileDef.
/// 
/// through an 2D Cartesian transformation operator (applied directly
///   to the curve position when using arbitrary profile definitions,
///   or applied to the position coordinate system when using parameterized
///   profile definitions) in case of using IfcDerivedProfileDef.
/// 
/// when using IfcCompositeProfileDef the insertion depends on
///   the subtype of the included sub-profiles.
/// 
/// Figure 320 — Profile sweeping
/// 
/// Profile types
/// 
/// Results of the different usage of the ProfileType attribute are demonstrated here. The ProfileType defines whether the inside (the bounded area) is part of the profile definition (Area) or not (Curve). Figure 321 illustrates the resulting area or curve depending on ProfileType.
/// 
/// ProfileType = AREA
/// 
/// ProfileType = CURVE
/// 
/// Figure 321 — Profile types
/// 
/// Profile specification by external reference
/// 
/// If the profile is standardized by a norm or a catalogue, a reference
/// to this norm or catalogue should be provided by means of HasExternalReference.
/// This inverse relationship is used to associate an IfcExternalReference (notably
/// IfcClassificationReference or IfcLibraryReference) with the
/// profile.
/// 
/// IfcClassificationReference is used to refer to a profile norm (a common standard or
/// manufacturer's standard).  In this case,
/// 
/// IfcClassificationReference.ItemReference
/// contains the formal profile designation from the norm.
/// (On the other hand, IfcProfileDef.ProfileName contains a displayable name which may
/// not necessarily be the same as the formal designation.)
/// IfcClassificationReference.Name carries the short name of the profile norm.
/// Optionally, the norm can be further described by
/// IfcClassificationReference.ReferencedSource.
/// 
/// IfcLibraryReference is used to refer to a library which contains profile
/// definitions. In this case,
/// 
/// IfcLibraryReference.ItemReference contains the identifier of the
/// profile within the library and is meant to be machine-readable (in contrast to
/// IfcProfileDef.ProfileName which should be human-readable).
/// IfcLibraryReference.Location and .Name or .ReferencedLibrary
/// further describe the library.
/// 
/// If an external reference is provided, sending systems shall ensure that
/// the shape of the profile definition object agrees with the definitions in the
/// referenced classification or library.
/// 
/// Direct instances of IfcProfileDef
/// 
/// Usually, only subtypes of IfcProfileDef should be instantiated.
/// In some special cases, e.g. if the profile object is used for purposes
/// other than geometric models (e.g. for structural analysis models), it may be
/// possible to directly instantiate IfcProfileDef and further specify
/// the profile only by external reference or by profile properties. The latter
/// are tracked by the inverse attribute HasProperties.
class IfcProfileDef : public IfcUtil::IfcBaseEntity {
public:
    /// Defines the type of geometry into which this profile definition shall be resolved, either a curve or a surface area. In case of curve the profile should be referenced by a swept surface, in case of area the profile should be referenced by a swept area solid.
    IfcProfileTypeEnum::IfcProfileTypeEnum ProfileType() const;
    void setProfileType(IfcProfileTypeEnum::IfcProfileTypeEnum v);
    /// Whether the optional attribute ProfileName is defined for this IfcProfileDef
    bool hasProfileName() const;
    /// Human-readable name of the profile, for example according to a standard profile table. As noted above, machine-readable standardized profile designations should be provided in IfcExternalReference.ItemReference.
    std::string ProfileName() const;
    void setProfileName(std::string v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENUMERATION; case 1: return IfcUtil::Argument_STRING; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcProfileTypeEnum; case 1: return Type::IfcLabel; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "ProfileType"; case 1: return "ProfileName"; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcProfileDef (IfcAbstractEntity* e);
    IfcProfileDef (IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< std::string > v2_ProfileName);
    typedef IfcTemplatedEntityList< IfcProfileDef > list;
};
/// This is a collection of properties applicable to section profile definitions.
/// 
/// The following sets of extended profile property definitions are part of this IFC release:
/// 
/// mechanical properties for all classes of profiles
/// properties for precast concrete double-T sections
/// properties for precast concrete hollow core sections
/// 
/// HISTORY  New entity in IFC2x2.
/// 
/// IFC2x4 CHANGE  Entity made non-abstract.  Subtypes IfcGeneralProfileProperties, IfcStructuralProfileProperties, and IfcStructuralSteelProfileProperties deleted. Attribute ProfileName deleted, use ProfileDefinition.ProfileName instead. Attribute ProfileDefinition made mandatory. Attributes Name, Description, and HasProperties added.
class IfcProfileProperties : public IfcUtil::IfcBaseEntity {
public:
    /// Whether the optional attribute ProfileName is defined for this IfcProfileProperties
    bool hasProfileName() const;
    std::string ProfileName() const;
    void setProfileName(std::string v);
    /// Whether the optional attribute ProfileDefinition is defined for this IfcProfileProperties
    bool hasProfileDefinition() const;
    /// Profile definition which is qualified by these properties.
    IfcProfileDef* ProfileDefinition() const;
    void setProfileDefinition(IfcProfileDef* v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_STRING; case 1: return IfcUtil::Argument_ENTITY_INSTANCE; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcLabel; case 1: return Type::IfcProfileDef; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "ProfileName"; case 1: return "ProfileDefinition"; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcProfileProperties (IfcAbstractEntity* e);
    IfcProfileProperties (boost::optional< std::string > v1_ProfileName, IfcProfileDef* v2_ProfileDefinition);
    typedef IfcTemplatedEntityList< IfcProfileProperties > list;
};
/// IfcProperty is an abstract generalization for all types of properties that can be associated with IFC objects through the property set mechanism. 
/// 
/// HISTORY  New entity in IFC Release 1.0.
class IfcProperty : public IfcUtil::IfcBaseEntity {
public:
    /// Name for this property. This label is the significant name string that defines the semantic meaning for the property.
    std::string Name() const;
    void setName(std::string v);
    /// Whether the optional attribute Description is defined for this IfcProperty
    bool hasDescription() const;
    /// Informative text to explain the property.
    std::string Description() const;
    void setDescription(std::string v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_STRING; case 1: return IfcUtil::Argument_STRING; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcIdentifier; case 1: return Type::IfcText; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Name"; case 1: return "Description"; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcPropertyDependencyRelationship >::ptr PropertyForDependance() const; // INVERSE IfcPropertyDependencyRelationship::DependingProperty
    IfcTemplatedEntityList< IfcPropertyDependencyRelationship >::ptr PropertyDependsOn() const; // INVERSE IfcPropertyDependencyRelationship::DependantProperty
    IfcTemplatedEntityList< IfcComplexProperty >::ptr PartOfComplex() const; // INVERSE IfcComplexProperty::HasProperties
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcProperty (IfcAbstractEntity* e);
    IfcProperty (std::string v1_Name, boost::optional< std::string > v2_Description);
    typedef IfcTemplatedEntityList< IfcProperty > list;
};

class IfcPropertyConstraintRelationship : public IfcUtil::IfcBaseEntity {
public:
    IfcConstraint* RelatingConstraint() const;
    void setRelatingConstraint(IfcConstraint* v);
    IfcTemplatedEntityList< IfcProperty >::ptr RelatedProperties() const;
    void setRelatedProperties(IfcTemplatedEntityList< IfcProperty >::ptr v);
    /// Whether the optional attribute Name is defined for this IfcPropertyConstraintRelationship
    bool hasName() const;
    std::string Name() const;
    void setName(std::string v);
    /// Whether the optional attribute Description is defined for this IfcPropertyConstraintRelationship
    bool hasDescription() const;
    std::string Description() const;
    void setDescription(std::string v);
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 2: return IfcUtil::Argument_STRING; case 3: return IfcUtil::Argument_STRING; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcConstraint; case 1: return Type::IfcProperty; case 2: return Type::IfcLabel; case 3: return Type::IfcText; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "RelatingConstraint"; case 1: return "RelatedProperties"; case 2: return "Name"; case 3: return "Description"; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPropertyConstraintRelationship (IfcAbstractEntity* e);
    IfcPropertyConstraintRelationship (IfcConstraint* v1_RelatingConstraint, IfcTemplatedEntityList< IfcProperty >::ptr v2_RelatedProperties, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description);
    typedef IfcTemplatedEntityList< IfcPropertyConstraintRelationship > list;
};
/// An IfcPropertyDependencyRelationship describes an identified dependency between the value of one property and that of another.
/// 
/// HISTORY  New entity in IFC2x2
/// 
/// IFC2x4 CHANGE  Made subtype of IfcResourceLevelRelationship (attribute order changed).
/// 
/// Use Definition
/// Whilst the IfcPropertyDependencyRelationship may be used to describe the dependency, and it may do so in terms of the expression of how the dependency operates, it is not possible through the current IFC model for the value of the related property to be actually derived from the value of the relating property. The determination of value according to the dependency is required to be performed by an application that can then use the Expression attribute to flag the form of the dependency.
class IfcPropertyDependencyRelationship : public IfcUtil::IfcBaseEntity {
public:
    /// The property on which the relationship depends.
    IfcProperty* DependingProperty() const;
    void setDependingProperty(IfcProperty* v);
    /// The dependant property.
    IfcProperty* DependantProperty() const;
    void setDependantProperty(IfcProperty* v);
    /// Whether the optional attribute Name is defined for this IfcPropertyDependencyRelationship
    bool hasName() const;
    std::string Name() const;
    void setName(std::string v);
    /// Whether the optional attribute Description is defined for this IfcPropertyDependencyRelationship
    bool hasDescription() const;
    std::string Description() const;
    void setDescription(std::string v);
    /// Whether the optional attribute Expression is defined for this IfcPropertyDependencyRelationship
    bool hasExpression() const;
    /// Expression that further describes the nature of the dependency relation.
    std::string Expression() const;
    void setExpression(std::string v);
    virtual unsigned int getArgumentCount() const { return 5; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_ENTITY_INSTANCE; case 2: return IfcUtil::Argument_STRING; case 3: return IfcUtil::Argument_STRING; case 4: return IfcUtil::Argument_STRING; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcProperty; case 1: return Type::IfcProperty; case 2: return Type::IfcLabel; case 3: return Type::IfcText; case 4: return Type::IfcText; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "DependingProperty"; case 1: return "DependantProperty"; case 2: return "Name"; case 3: return "Description"; case 4: return "Expression"; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPropertyDependencyRelationship (IfcAbstractEntity* e);
    IfcPropertyDependencyRelationship (IfcProperty* v1_DependingProperty, IfcProperty* v2_DependantProperty, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_Expression);
    typedef IfcTemplatedEntityList< IfcPropertyDependencyRelationship > list;
};
/// IfcPropertyEnumeration is a collection of simple
/// or measure values that define a prescribed set of alternatives from
/// which 'enumeration values' are selected. This enables inclusion of
/// enumeration values in property sets. IfcPropertyEnumeration
/// provides a name for the enumeration as well as a list of unique
/// (numeric or descriptive) values (that may have a measure type
/// assigned). The entity defines the list of potential enumerators to be
/// exchanged together (or separately) with properties of type IfcPropertyEnumeratedValue
/// that selects their actual property values from this enumeration. 
/// The unit is handled by the Unit attribute:
/// 
/// If the Unit attribute is not given,
/// than the unit is already implied by the type of IfcMeasureValue
/// or IfcDerivedMeasureValue. The associated unit can
/// be found at the IfcUnitAssignment globally defined
/// at the project level (IfcProject.UnitsInContext).
///   If the Unit attribute is given, the
/// unit assigned by the unit attribute overrides the globally assigned
/// unit.
/// 
/// Name
///   EnumerationValues
///   Type (through IfcValue)
///   Unit
/// 
/// PEnum_DamperBladeAction
///   Parallel
///   IfcString
///   -
/// 
///  
///   Opposed
///   IfcString
///    
/// 
///  
///   Other
///   IfcString
///    
/// 
///  
///   Unset
///   IfcString
///    
/// 
/// HISTORY  New Entity in IFC Release 2.0, capabilities enhanced in IFC Release 2x. Entity has been renamed from IfcEnumeration in IFC Release 2x.
class IfcPropertyEnumeration : public IfcUtil::IfcBaseEntity {
public:
    /// Name of this enumeration.
    std::string Name() const;
    void setName(std::string v);
    /// List of values that form the enumeration.
    IfcEntityList::ptr EnumerationValues() const;
    void setEnumerationValues(IfcEntityList::ptr v);
    /// Whether the optional attribute Unit is defined for this IfcPropertyEnumeration
    bool hasUnit() const;
    /// Unit for the enumerator values, if not given, the default value for the measure type (given by the TYPE of nominal value) is used as defined by the global unit assignment at IfcProject.
    IfcUnit* Unit() const;
    void setUnit(IfcUnit* v);
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_STRING; case 1: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 2: return IfcUtil::Argument_ENTITY_INSTANCE; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcLabel; case 1: return Type::IfcValue; case 2: return Type::IfcUnit; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Name"; case 1: return "EnumerationValues"; case 2: return "Unit"; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPropertyEnumeration (IfcAbstractEntity* e);
    IfcPropertyEnumeration (std::string v1_Name, IfcEntityList::ptr v2_EnumerationValues, IfcUnit* v3_Unit);
    typedef IfcTemplatedEntityList< IfcPropertyEnumeration > list;
};
/// IfcQuantityArea is a physical quantity that defines a derived area measure to provide an element's physical property. It is normally derived from the physical properties of the element under the specific measure rules given by a method of measurement. 
/// 
/// EXAMPLE  An opening may have an opening area used to deduct it from the wall surface area. The actual size of the area depends on the method of measurement used.
/// 
/// HISTORY  New entity in IFC2x. It replaces the calcXxx attributes used in previous IFC Releases.
class IfcQuantityArea : public IfcPhysicalSimpleQuantity {
public:
    /// Area measure value of this quantity.
    double AreaValue() const;
    void setAreaValue(double v);
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 3: return IfcUtil::Argument_DOUBLE; } return IfcPhysicalSimpleQuantity::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 3: return Type::IfcAreaMeasure; } return IfcPhysicalSimpleQuantity::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 3: return "AreaValue"; } return IfcPhysicalSimpleQuantity::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcQuantityArea (IfcAbstractEntity* e);
    IfcQuantityArea (std::string v1_Name, boost::optional< std::string > v2_Description, IfcNamedUnit* v3_Unit, double v4_AreaValue);
    typedef IfcTemplatedEntityList< IfcQuantityArea > list;
};
/// IfcQuantityCount is a physical quantity that defines a derived count measure to provide an element's physical property. It is normally derived from the physical properties of the element under the specific measure rules given by a method of measurement.
/// 
/// EXAMPLE  An radiator may be measured according to its number of coils. The actual counting method depends on the method of measurement used.
/// 
/// HISTORY  New entity in IFC2x. It replaces the calcXxx attributes used in previous IFC Releases.
class IfcQuantityCount : public IfcPhysicalSimpleQuantity {
public:
    /// Count measure value of this quantity.
    double CountValue() const;
    void setCountValue(double v);
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 3: return IfcUtil::Argument_DOUBLE; } return IfcPhysicalSimpleQuantity::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 3: return Type::IfcCountMeasure; } return IfcPhysicalSimpleQuantity::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 3: return "CountValue"; } return IfcPhysicalSimpleQuantity::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcQuantityCount (IfcAbstractEntity* e);
    IfcQuantityCount (std::string v1_Name, boost::optional< std::string > v2_Description, IfcNamedUnit* v3_Unit, double v4_CountValue);
    typedef IfcTemplatedEntityList< IfcQuantityCount > list;
};
/// IfcQuantityLength is a physical quantity that defines a derived length measure to provide an element's physical property. It is normally derived from the physical properties of the element under the specific measure rules given by a method of measurement.
/// 
/// EXAMPLE  A rafter within a roof construction may be measured according to its length (taking a common cross section into account). The actual size of the length depends on the method of measurement used.
/// 
/// HISTORY  New entity in IFC Release 2.x. It replaces the calcXxx attributes used in previous IFC Releases.
class IfcQuantityLength : public IfcPhysicalSimpleQuantity {
public:
    /// Length measure value of this quantity.
    double LengthValue() const;
    void setLengthValue(double v);
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 3: return IfcUtil::Argument_DOUBLE; } return IfcPhysicalSimpleQuantity::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 3: return Type::IfcLengthMeasure; } return IfcPhysicalSimpleQuantity::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 3: return "LengthValue"; } return IfcPhysicalSimpleQuantity::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcQuantityLength (IfcAbstractEntity* e);
    IfcQuantityLength (std::string v1_Name, boost::optional< std::string > v2_Description, IfcNamedUnit* v3_Unit, double v4_LengthValue);
    typedef IfcTemplatedEntityList< IfcQuantityLength > list;
};
/// IfcQuantityTime is an element quantity that defines a time measure to provide an property of time related to an element. It is normally given by the recipe information of the element under the specific measure rules given by a method of measurement.
/// 
/// EXAMPLE  The amount of time needed to pour concrete for a wall is given as a time quantity for the labor part of the recipe information.
/// 
/// HISTORY  New entity in IFC2x2.
class IfcQuantityTime : public IfcPhysicalSimpleQuantity {
public:
    /// Time measure value of this quantity.
    double TimeValue() const;
    void setTimeValue(double v);
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 3: return IfcUtil::Argument_DOUBLE; } return IfcPhysicalSimpleQuantity::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 3: return Type::IfcTimeMeasure; } return IfcPhysicalSimpleQuantity::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 3: return "TimeValue"; } return IfcPhysicalSimpleQuantity::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcQuantityTime (IfcAbstractEntity* e);
    IfcQuantityTime (std::string v1_Name, boost::optional< std::string > v2_Description, IfcNamedUnit* v3_Unit, double v4_TimeValue);
    typedef IfcTemplatedEntityList< IfcQuantityTime > list;
};
/// IfcQuantityVolume is a physical quantity that defines a derived volume measure to provide an element's physical property. It is normally derived from the physical properties of the element under the specific measure rules given by a method of measurement. 
/// 
/// EXAMPLE  A thick brick wall may be measured according to its volume. The actual size of the volume depends on the method of measurement used.
/// 
/// HISTORY New entity in IFC2x. It replaces the calcXxx attributes used in previous IFC Releases.
class IfcQuantityVolume : public IfcPhysicalSimpleQuantity {
public:
    /// Volume measure value of this quantity.
    double VolumeValue() const;
    void setVolumeValue(double v);
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 3: return IfcUtil::Argument_DOUBLE; } return IfcPhysicalSimpleQuantity::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 3: return Type::IfcVolumeMeasure; } return IfcPhysicalSimpleQuantity::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 3: return "VolumeValue"; } return IfcPhysicalSimpleQuantity::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcQuantityVolume (IfcAbstractEntity* e);
    IfcQuantityVolume (std::string v1_Name, boost::optional< std::string > v2_Description, IfcNamedUnit* v3_Unit, double v4_VolumeValue);
    typedef IfcTemplatedEntityList< IfcQuantityVolume > list;
};
/// IfcQuantityWeight is a physical element quantity that defines a derived weight measure to provide an element's physical property. It is normally derived from the physical properties of the element under the specific measure rules given by a method of measurement. 
/// 
/// EXAMPLE  The amount of reinforcement used within a building element may be measured according to its weight. The actual size of the weight depends on the method of measurement used.
/// 
/// HISTORY  New entity in IFC2x. It replaces the calcXxx attributes used in previous IFC Releases.
class IfcQuantityWeight : public IfcPhysicalSimpleQuantity {
public:
    /// Mass measure value of this quantity.
    double WeightValue() const;
    void setWeightValue(double v);
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 3: return IfcUtil::Argument_DOUBLE; } return IfcPhysicalSimpleQuantity::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 3: return Type::IfcMassMeasure; } return IfcPhysicalSimpleQuantity::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 3: return "WeightValue"; } return IfcPhysicalSimpleQuantity::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcQuantityWeight (IfcAbstractEntity* e);
    IfcQuantityWeight (std::string v1_Name, boost::optional< std::string > v2_Description, IfcNamedUnit* v3_Unit, double v4_WeightValue);
    typedef IfcTemplatedEntityList< IfcQuantityWeight > list;
};

class IfcReferencesValueDocument : public IfcUtil::IfcBaseEntity {
public:
    IfcDocumentSelect* ReferencedDocument() const;
    void setReferencedDocument(IfcDocumentSelect* v);
    IfcTemplatedEntityList< IfcAppliedValue >::ptr ReferencingValues() const;
    void setReferencingValues(IfcTemplatedEntityList< IfcAppliedValue >::ptr v);
    /// Whether the optional attribute Name is defined for this IfcReferencesValueDocument
    bool hasName() const;
    std::string Name() const;
    void setName(std::string v);
    /// Whether the optional attribute Description is defined for this IfcReferencesValueDocument
    bool hasDescription() const;
    std::string Description() const;
    void setDescription(std::string v);
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 2: return IfcUtil::Argument_STRING; case 3: return IfcUtil::Argument_STRING; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcDocumentSelect; case 1: return Type::IfcAppliedValue; case 2: return Type::IfcLabel; case 3: return Type::IfcText; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "ReferencedDocument"; case 1: return "ReferencingValues"; case 2: return "Name"; case 3: return "Description"; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcReferencesValueDocument (IfcAbstractEntity* e);
    IfcReferencesValueDocument (IfcDocumentSelect* v1_ReferencedDocument, IfcTemplatedEntityList< IfcAppliedValue >::ptr v2_ReferencingValues, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description);
    typedef IfcTemplatedEntityList< IfcReferencesValueDocument > list;
};
/// IfcReinforcementProperties defines the set of properties for a specific combination of reinforcement bar steel grade, bar type and effective depth. 
/// 
/// HISTORY  New entity in IFC2x2.
/// 
/// The total cross section area for the specific steel grade is always provided. Additionally also general reinforcing bar configurations as a count of bars may be provided as defined in attribute BarCount. In this case the nominal bar diameter should be identical for all given bars as defined in attribute NominalBarDiameter.
class IfcReinforcementBarProperties : public IfcUtil::IfcBaseEntity {
public:
    /// The total effective cross-section area of the reinforcement of a specific steel grade.
    double TotalCrossSectionArea() const;
    void setTotalCrossSectionArea(double v);
    /// The nominal steel grade defined according to local standards.
    std::string SteelGrade() const;
    void setSteelGrade(std::string v);
    /// Whether the optional attribute BarSurface is defined for this IfcReinforcementBarProperties
    bool hasBarSurface() const;
    /// Indicator for whether the bar surface is plain or textured.
    IfcReinforcingBarSurfaceEnum::IfcReinforcingBarSurfaceEnum BarSurface() const;
    void setBarSurface(IfcReinforcingBarSurfaceEnum::IfcReinforcingBarSurfaceEnum v);
    /// Whether the optional attribute EffectiveDepth is defined for this IfcReinforcementBarProperties
    bool hasEffectiveDepth() const;
    /// The effective depth, i.e. the distance of the specific reinforcement cross section area or reinforcement configuration in a row, counted from a common specific reference point. Usually the reference point is the upper surface (for beams and slabs) or a similar projection in a plane (for columns).
    double EffectiveDepth() const;
    void setEffectiveDepth(double v);
    /// Whether the optional attribute NominalBarDiameter is defined for this IfcReinforcementBarProperties
    bool hasNominalBarDiameter() const;
    /// The nominal diameter defining the cross-section size of the reinforcing bar. The bar diameter should be identical for all bars included in the specific reinforcement configuration.
    double NominalBarDiameter() const;
    void setNominalBarDiameter(double v);
    /// Whether the optional attribute BarCount is defined for this IfcReinforcementBarProperties
    bool hasBarCount() const;
    /// The number of bars with identical nominal diameter and steel grade included in the specific reinforcement configuration.
    double BarCount() const;
    void setBarCount(double v);
    virtual unsigned int getArgumentCount() const { return 6; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_DOUBLE; case 1: return IfcUtil::Argument_STRING; case 2: return IfcUtil::Argument_ENUMERATION; case 3: return IfcUtil::Argument_DOUBLE; case 4: return IfcUtil::Argument_DOUBLE; case 5: return IfcUtil::Argument_DOUBLE; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcAreaMeasure; case 1: return Type::IfcLabel; case 2: return Type::IfcReinforcingBarSurfaceEnum; case 3: return Type::IfcLengthMeasure; case 4: return Type::IfcPositiveLengthMeasure; case 5: return Type::IfcCountMeasure; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "TotalCrossSectionArea"; case 1: return "SteelGrade"; case 2: return "BarSurface"; case 3: return "EffectiveDepth"; case 4: return "NominalBarDiameter"; case 5: return "BarCount"; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcReinforcementBarProperties (IfcAbstractEntity* e);
    IfcReinforcementBarProperties (double v1_TotalCrossSectionArea, std::string v2_SteelGrade, boost::optional< IfcReinforcingBarSurfaceEnum::IfcReinforcingBarSurfaceEnum > v3_BarSurface, boost::optional< double > v4_EffectiveDepth, boost::optional< double > v5_NominalBarDiameter, boost::optional< double > v6_BarCount);
    typedef IfcTemplatedEntityList< IfcReinforcementBarProperties > list;
};

class IfcRelaxation : public IfcUtil::IfcBaseEntity {
public:
    double RelaxationValue() const;
    void setRelaxationValue(double v);
    double InitialStress() const;
    void setInitialStress(double v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_DOUBLE; case 1: return IfcUtil::Argument_DOUBLE; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcNormalisedRatioMeasure; case 1: return Type::IfcNormalisedRatioMeasure; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "RelaxationValue"; case 1: return "InitialStress"; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRelaxation (IfcAbstractEntity* e);
    IfcRelaxation (double v1_RelaxationValue, double v2_InitialStress);
    typedef IfcTemplatedEntityList< IfcRelaxation > list;
};
/// Definition from ISO/CD 10303-43:1992: A
///   representation is one or more representation items that are
///   related in a specified representation context as the
///   representation of some concept.
/// 
/// IfcRepresentation
///   defines the general concept of representing product
///   properties.
/// 
/// Representation Use Definition
/// 
/// Each representation, either IfcShapeRepresentation, or
///   IfcTopologyRepresentation shall have a well defined:
/// 
/// ContextOfItems: Reference to an
///   IfcGeometricRepresentationContext as agreed for 
///   this representation.
/// 
/// RepresentationIdentifier: Name of the
///   representation, for example, 'Body' for 3D shape, 'FootPrint' for
///   2D ground view, 'Axis' for reference axis.
/// 
/// RepresentationType: Name for the geometric, or
///   topological representation type, for example, 'SweptSolid' for 3D
///   swept solids, 'Brep' for boundary representation.
/// 
/// Values and guidelines for these three items are provided in
///   the geometry use definition section at each subtype of
///   IfcElement, or in view definitions / implementer
///   agreements.
/// 
/// NOTE ÿThe definition of this
///   entity relates to the ISO 10303 entity representation. Please
///   refer to ISO/IS 10303-43:1994 for the final definition of
///   the formal standard.
/// 
/// HISTORY  New entity in IFC Release 2.0
/// 
/// IFC2x3 CHANGE  The
///   inverse attributes LayerAssignments
///   andRepresentationMap have been added with upward
///   compatibility.
/// 
/// IFC2x4 CHANGE  Entity
///   IfcRepresentation has been changed into an ABSTRACT
///   supertype.
class IfcRepresentation : public IfcUtil::IfcBaseEntity {
public:
    /// Definition of the representation context for which the different subtypes of representation are valid.
    IfcRepresentationContext* ContextOfItems() const;
    void setContextOfItems(IfcRepresentationContext* v);
    /// Whether the optional attribute RepresentationIdentifier is defined for this IfcRepresentation
    bool hasRepresentationIdentifier() const;
    /// The optional identifier of the representation as used within a project.
    std::string RepresentationIdentifier() const;
    void setRepresentationIdentifier(std::string v);
    /// Whether the optional attribute RepresentationType is defined for this IfcRepresentation
    bool hasRepresentationType() const;
    /// The description of the type of a representation context. The representation type defines the type of geometry or topology used for representing the product representation. More information is given at the subtypes IfcShapeRepresentation and IfcTopologyRepresentation.
    /// The supported values for context type are to be specified by implementers agreements.
    std::string RepresentationType() const;
    void setRepresentationType(std::string v);
    /// Set of geometric representation items that are defined for this representation.
    IfcTemplatedEntityList< IfcRepresentationItem >::ptr Items() const;
    void setItems(IfcTemplatedEntityList< IfcRepresentationItem >::ptr v);
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_STRING; case 2: return IfcUtil::Argument_STRING; case 3: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcRepresentationContext; case 1: return Type::IfcLabel; case 2: return Type::IfcLabel; case 3: return Type::IfcRepresentationItem; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "ContextOfItems"; case 1: return "RepresentationIdentifier"; case 2: return "RepresentationType"; case 3: return "Items"; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcRepresentationMap >::ptr RepresentationMap() const; // INVERSE IfcRepresentationMap::MappedRepresentation
    IfcTemplatedEntityList< IfcPresentationLayerAssignment >::ptr LayerAssignments() const; // INVERSE IfcPresentationLayerAssignment::AssignedItems
    IfcTemplatedEntityList< IfcProductRepresentation >::ptr OfProductRepresentation() const; // INVERSE IfcProductRepresentation::Representations
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRepresentation (IfcAbstractEntity* e);
    IfcRepresentation (IfcRepresentationContext* v1_ContextOfItems, boost::optional< std::string > v2_RepresentationIdentifier, boost::optional< std::string > v3_RepresentationType, IfcTemplatedEntityList< IfcRepresentationItem >::ptr v4_Items);
    typedef IfcTemplatedEntityList< IfcRepresentation > list;
};
/// Definition from ISO/CD 10303-42:1992: A representation context is a context in which a set of representation items are related.
/// 
/// The IfcRepresentationContext defines the context to which the IfcRepresentation of a product is related.
/// 
/// NOTE  The definition of this class relates to the ISO 10303 entity representation_context. Please refer to ISO/IS 10303-43:1994 for the final definition of the formal standard.
/// 
/// HISTORY  New entity in IFC Release 1.5.
/// 
/// IFC2x4 CHANGE Entity made abstract, had been deprecated from instantiation since
/// IFC2x2.
class IfcRepresentationContext : public IfcUtil::IfcBaseEntity {
public:
    /// Whether the optional attribute ContextIdentifier is defined for this IfcRepresentationContext
    bool hasContextIdentifier() const;
    /// The optional identifier of the representation context as used within a project.
    std::string ContextIdentifier() const;
    void setContextIdentifier(std::string v);
    /// Whether the optional attribute ContextType is defined for this IfcRepresentationContext
    bool hasContextType() const;
    /// The description of the type of a representation context. The supported values for context type are to be specified by implementers agreements.
    std::string ContextType() const;
    void setContextType(std::string v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_STRING; case 1: return IfcUtil::Argument_STRING; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcLabel; case 1: return Type::IfcLabel; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "ContextIdentifier"; case 1: return "ContextType"; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcRepresentation >::ptr RepresentationsInContext() const; // INVERSE IfcRepresentation::ContextOfItems
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRepresentationContext (IfcAbstractEntity* e);
    IfcRepresentationContext (boost::optional< std::string > v1_ContextIdentifier, boost::optional< std::string > v2_ContextType);
    typedef IfcTemplatedEntityList< IfcRepresentationContext > list;
};
/// Definition from ISO/CD
/// 10303-43:1992: A representation item is an element of
/// product data that participates in one or more representations or
/// contributes to the definition of another representation item. A
/// representation item contributes to the definition of another
/// representation item when it is referenced by that representation
/// item.
/// 
/// NOTE  Corresponding entity in ISO 10303-43:1994: representation_item. Please refer to ISO/IS 10303-43:1994, for the final definition of the formal standard. The following changes have been made: The attribute 'name' and the WR1 have not been incorporated.
/// 
/// The IfcRepresentationItem is used within an IfcRepresentation (directly or indirectly through other IfcRepresentationItem's) to represent an IfcProductRepresentation. Most commonly these IfcRepresentationItem's are geometric or topological representation items, that can (but not need to) have presentation style infomation assigned.
/// 
/// NOTE  The assignment of a style is only applicable
/// to the subtypes IfcGeometricRepresentationItem, IfcMappedItem and some selected subtypes of IfcTopologicalRepresentationItem (IfcVertexPoint, IfcEdgeCurve, IfcFaceSurface).
/// 
/// In case that presentation style information is applied, it can be either applied by an IfcStyledItem, or by an assignment to an IfcPresentationLayerWithStyle. If both are present, and both style assignments include the same subtype of IfcPresentationStyle, then the style assigned by IfcStyledItem takes priority.
/// 
/// Figure 281 shows an instance diagram explaining the use of IfcStyledItem and IfcPresentationLayerWithStyle to apply presentation styles.
/// 
/// EXAMPLE  The assignment of style information by a styled item and a presentation layer with style. Since the presentation styles are different, IfcCurveStyle and IfcSurfaceStyle, both are applied to the geometric representation item.
/// 
/// Figure 281 — Representation item style
/// 
/// Figure 282 shows in instance diagram explaining the override of IfcPresentationLayerWithStyle by IfcStyledItem to apply presentation styles.
/// 
/// EXAMPLE  The assignment of style information by a styled item and a presentation layer with style. Since the presentation styles for curve style are aprovided by both, the IfcCurveStyle provided by the IfcStyledItem overrides the IfcCurveStyle provided by the IfcPresentationLayerWithStyle
/// 
/// Figure 282 — Representation item style override
/// 
/// HISTORY  New entity in IFC Release 2x.
/// 
/// IFC2x3 CHANGE  The inverse attributes StyledByItem and LayerAssignments have been added. Upward compatibility for file based exchange is guaranteed.
class IfcRepresentationItem : public IfcUtil::IfcBaseEntity {
public:
    virtual unsigned int getArgumentCount() const { return 0; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcPresentationLayerAssignment >::ptr LayerAssignments() const; // INVERSE IfcPresentationLayerAssignment::AssignedItems
    IfcTemplatedEntityList< IfcStyledItem >::ptr StyledByItem() const; // INVERSE IfcStyledItem::Item
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRepresentationItem (IfcAbstractEntity* e);
    IfcRepresentationItem ();
    typedef IfcTemplatedEntityList< IfcRepresentationItem > list;
};
/// Definition from ISO/CD 10303-43:1992: A representation map is the identification of a representation and a representation item in that representation for the purpose of mapping. The representation item defines the origin of the mapping. The representation map is used as the source of a mapping by a mapped item.
/// 
/// NOTE  Corresponding ISO 10303 entity: representation_map. Please refer to ISO/IS 10303-43:1994, for the final definition of the formal standard. The following changes have been made: The mapping_origin (MappingOrigin) is constrained to be of type axis2_placement (IfcAxis2Placement).
/// 
/// An IfcRepresentationMap defines the base definition (also referred to as block, cell or macro) called MappedRepresentation within the MappingOrigin. The MappingOrigin defines the coordinate system in which the MappedRepresentation is defined.
/// 
/// The RepresentationMap is used through an IfcMappeditem in one or several IfcShapeRepresentation's. An Cartesian transformation operator can be applied to transform the MappedRepresentation into the placement coordinate system of the shape representation. The transformation of the representation map is restricted to be a Cartesian transformation mapping (translation, rotation, mirroring and scaling).
/// 
/// NOTE  The definition of a mapping which is used to specify a new representation item comprises a representation map and a mapped item entity. Without both entities, the mapping is not fully defined. Two entities are specified to allow the same source representation to be mapped into multiple new representations.
/// 
/// HISTORY  New entity in IFC Release 2x.
class IfcRepresentationMap : public IfcUtil::IfcBaseEntity {
public:
    /// An axis2 placement that defines the position about which the mapped
    /// representation is mapped.
    IfcAxis2Placement* MappingOrigin() const;
    void setMappingOrigin(IfcAxis2Placement* v);
    /// A representation that is mapped to at least one mapped item.
    IfcRepresentation* MappedRepresentation() const;
    void setMappedRepresentation(IfcRepresentation* v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_ENTITY_INSTANCE; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcAxis2Placement; case 1: return Type::IfcRepresentation; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "MappingOrigin"; case 1: return "MappedRepresentation"; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcMappedItem >::ptr MapUsage() const; // INVERSE IfcMappedItem::MappingSource
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRepresentationMap (IfcAbstractEntity* e);
    IfcRepresentationMap (IfcAxis2Placement* v1_MappingOrigin, IfcRepresentation* v2_MappedRepresentation);
    typedef IfcTemplatedEntityList< IfcRepresentationMap > list;
};

class IfcRibPlateProfileProperties : public IfcProfileProperties {
public:
    /// Whether the optional attribute Thickness is defined for this IfcRibPlateProfileProperties
    bool hasThickness() const;
    double Thickness() const;
    void setThickness(double v);
    /// Whether the optional attribute RibHeight is defined for this IfcRibPlateProfileProperties
    bool hasRibHeight() const;
    double RibHeight() const;
    void setRibHeight(double v);
    /// Whether the optional attribute RibWidth is defined for this IfcRibPlateProfileProperties
    bool hasRibWidth() const;
    double RibWidth() const;
    void setRibWidth(double v);
    /// Whether the optional attribute RibSpacing is defined for this IfcRibPlateProfileProperties
    bool hasRibSpacing() const;
    double RibSpacing() const;
    void setRibSpacing(double v);
    IfcRibPlateDirectionEnum::IfcRibPlateDirectionEnum Direction() const;
    void setDirection(IfcRibPlateDirectionEnum::IfcRibPlateDirectionEnum v);
    virtual unsigned int getArgumentCount() const { return 7; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 2: return IfcUtil::Argument_DOUBLE; case 3: return IfcUtil::Argument_DOUBLE; case 4: return IfcUtil::Argument_DOUBLE; case 5: return IfcUtil::Argument_DOUBLE; case 6: return IfcUtil::Argument_ENUMERATION; } return IfcProfileProperties::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 2: return Type::IfcPositiveLengthMeasure; case 3: return Type::IfcPositiveLengthMeasure; case 4: return Type::IfcPositiveLengthMeasure; case 5: return Type::IfcPositiveLengthMeasure; case 6: return Type::IfcRibPlateDirectionEnum; } return IfcProfileProperties::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 2: return "Thickness"; case 3: return "RibHeight"; case 4: return "RibWidth"; case 5: return "RibSpacing"; case 6: return "Direction"; } return IfcProfileProperties::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRibPlateProfileProperties (IfcAbstractEntity* e);
    IfcRibPlateProfileProperties (boost::optional< std::string > v1_ProfileName, IfcProfileDef* v2_ProfileDefinition, boost::optional< double > v3_Thickness, boost::optional< double > v4_RibHeight, boost::optional< double > v5_RibWidth, boost::optional< double > v6_RibSpacing, IfcRibPlateDirectionEnum::IfcRibPlateDirectionEnum v7_Direction);
    typedef IfcTemplatedEntityList< IfcRibPlateProfileProperties > list;
};
/// IfcRoot is the most abstract and root class for all IFC entity definitions that roots in the kernel or in subsequent layers of the IFC object model. It is therefore the common supertype of all IFC entities, beside those defined in an IFC resource schema. All entities that are subtypes of IfcRoot can be used independently, whereas resource schema entities, that are not subtypes of IfcRoot, are not supposed to be independent entities.
/// 
/// IfcRoot assigns the globally unique ID, and the ownership and history information to the entity. In addition it may provide for a name and a description about the concept.
/// 
/// NOTE View definitions and implementation agreement may impose additional restrictions on the use of the OwnerHistory to handle object versioning.
/// 
/// HISTORY New entity in IFC Release 1.0
/// 
/// IFC2x4 CHANGE The attribute OwnerHistory has been made OPTIONAL.
class IfcRoot : public IfcUtil::IfcBaseEntity {
public:
    /// Assignment of a globally unique identifier within the entire software world.
    std::string GlobalId() const;
    void setGlobalId(std::string v);
    /// Assignment of the information about the current ownership of that object, including owning actor, application, local identification and information captured about the recent changes of the object, 
    /// 
    /// NOTE only the last modification in stored - either as addition, deletion or modification.
    /// 
    /// IFC2x4 CHANGE  The attribute has been changed to be OPTIONAL.
    IfcOwnerHistory* OwnerHistory() const;
    void setOwnerHistory(IfcOwnerHistory* v);
    /// Whether the optional attribute Name is defined for this IfcRoot
    bool hasName() const;
    /// Optional name for use by the participating software systems or users. For some subtypes of IfcRoot the insertion of the Name attribute may be required. This would be enforced by a where rule.
    std::string Name() const;
    void setName(std::string v);
    /// Whether the optional attribute Description is defined for this IfcRoot
    bool hasDescription() const;
    /// Optional description, provided for exchanging informative comments.
    std::string Description() const;
    void setDescription(std::string v);
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_STRING; case 1: return IfcUtil::Argument_ENTITY_INSTANCE; case 2: return IfcUtil::Argument_STRING; case 3: return IfcUtil::Argument_STRING; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcGloballyUniqueId; case 1: return Type::IfcOwnerHistory; case 2: return Type::IfcLabel; case 3: return Type::IfcText; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "GlobalId"; case 1: return "OwnerHistory"; case 2: return "Name"; case 3: return "Description"; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRoot (IfcAbstractEntity* e);
    IfcRoot (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description);
    typedef IfcTemplatedEntityList< IfcRoot > list;
};
/// Definition from ISO/CD 10303-41:1992: An SI unit is the fixed quantity used as a standard in terms of which items are measured as defined by ISO 1000 (clause 2).
/// 
/// IfcSIUnit covers both standard base SI units such as meter and second, and derived SI units such as Pascal, square meter and cubic meter.
/// 
/// NOTE Corresponding ISO 10303 name: si_unit, please refer to ISO/IS 10303-41 for the final definition of the formal standard.
/// 
/// HISTORY New entity in IFC Release 1.5.1.
class IfcSIUnit : public IfcNamedUnit {
public:
    /// Whether the optional attribute Prefix is defined for this IfcSIUnit
    bool hasPrefix() const;
    /// The SI Prefix for defining decimal multiples and submultiples of the unit.
    IfcSIPrefix::IfcSIPrefix Prefix() const;
    void setPrefix(IfcSIPrefix::IfcSIPrefix v);
    /// The word, or group of words, by which the SI unit is referred to.
    /// 
    /// NOTE  Even though the SI system's base unit for mass is kilogram, the IfcSIUnit for mass is gram if no Prefix is asserted.
    IfcSIUnitName::IfcSIUnitName Name() const;
    void setName(IfcSIUnitName::IfcSIUnitName v);
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 2: return IfcUtil::Argument_ENUMERATION; case 3: return IfcUtil::Argument_ENUMERATION; } return IfcNamedUnit::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 2: return Type::IfcSIPrefix; case 3: return Type::IfcSIUnitName; } return IfcNamedUnit::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 2: return "Prefix"; case 3: return "Name"; } return IfcNamedUnit::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcSIUnit (IfcAbstractEntity* e);
    IfcSIUnit (IfcUnitEnum::IfcUnitEnum v2_UnitType, boost::optional< IfcSIPrefix::IfcSIPrefix > v3_Prefix, IfcSIUnitName::IfcSIUnitName v4_Name);
    typedef IfcTemplatedEntityList< IfcSIUnit > list;
};
/// IfcSectionProperties defines the cross section properties for a single longitudinal piece of a cross section.  It is a special-purpose helper class for IfcSectionReinforcementProperties.
/// 
/// HISTORY  New entity in IFC2x2.
/// 
/// The section piece may be either uniform or tapered. In the latter case an end profile should also be provided. The start and end profiles are assumed to be of the same profile type. Generally only rectangular or circular cross section profiles are assumed to be used.
class IfcSectionProperties : public IfcUtil::IfcBaseEntity {
public:
    /// An indicator whether a specific piece of a cross section is uniform or tapered in longitudinal direction.
    IfcSectionTypeEnum::IfcSectionTypeEnum SectionType() const;
    void setSectionType(IfcSectionTypeEnum::IfcSectionTypeEnum v);
    /// The cross section profile at the start point of the longitudinal section.
    IfcProfileDef* StartProfile() const;
    void setStartProfile(IfcProfileDef* v);
    /// Whether the optional attribute EndProfile is defined for this IfcSectionProperties
    bool hasEndProfile() const;
    /// The cross section profile at the end point of the longitudinal section.
    IfcProfileDef* EndProfile() const;
    void setEndProfile(IfcProfileDef* v);
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENUMERATION; case 1: return IfcUtil::Argument_ENTITY_INSTANCE; case 2: return IfcUtil::Argument_ENTITY_INSTANCE; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcSectionTypeEnum; case 1: return Type::IfcProfileDef; case 2: return Type::IfcProfileDef; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "SectionType"; case 1: return "StartProfile"; case 2: return "EndProfile"; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcSectionProperties (IfcAbstractEntity* e);
    IfcSectionProperties (IfcSectionTypeEnum::IfcSectionTypeEnum v1_SectionType, IfcProfileDef* v2_StartProfile, IfcProfileDef* v3_EndProfile);
    typedef IfcTemplatedEntityList< IfcSectionProperties > list;
};
/// IfcSectionReinforcementProperties defines the cross section properties of reinforcement for a single longitudinal piece of a cross section with a specific reinforcement usage type.  
/// 
/// HISTORY  New entity in IFC2x2.
/// 
/// Several sets of cross section reinforcement properties represented by instances of IfcReinforcementProperties may be attached to the section reinforcement properties
/// (IfcReinforcementDefinitionProperties of IfcStructuralElementsDomain schema),
/// one for each combination of steel grades and reinforcement bar types and sizes.
class IfcSectionReinforcementProperties : public IfcUtil::IfcBaseEntity {
public:
    /// The start position in longitudinal direction for the section reinforcement properties.
    double LongitudinalStartPosition() const;
    void setLongitudinalStartPosition(double v);
    /// The end position in longitudinal direction for the section reinforcement properties.
    double LongitudinalEndPosition() const;
    void setLongitudinalEndPosition(double v);
    /// Whether the optional attribute TransversePosition is defined for this IfcSectionReinforcementProperties
    bool hasTransversePosition() const;
    /// The position for the section reinforcement properties in transverse direction.
    double TransversePosition() const;
    void setTransversePosition(double v);
    /// The role, purpose or usage of the reinforcement, i.e. the kind of loads and stresses it is intended to carry, defined for the section reinforcement properties.
    IfcReinforcingBarRoleEnum::IfcReinforcingBarRoleEnum ReinforcementRole() const;
    void setReinforcementRole(IfcReinforcingBarRoleEnum::IfcReinforcingBarRoleEnum v);
    /// Definition of the cross section profile and longitudinal section type.
    IfcSectionProperties* SectionDefinition() const;
    void setSectionDefinition(IfcSectionProperties* v);
    /// The set of reinforcment properties attached to a section reinforcement properties definition.
    IfcTemplatedEntityList< IfcReinforcementBarProperties >::ptr CrossSectionReinforcementDefinitions() const;
    void setCrossSectionReinforcementDefinitions(IfcTemplatedEntityList< IfcReinforcementBarProperties >::ptr v);
    virtual unsigned int getArgumentCount() const { return 6; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_DOUBLE; case 1: return IfcUtil::Argument_DOUBLE; case 2: return IfcUtil::Argument_DOUBLE; case 3: return IfcUtil::Argument_ENUMERATION; case 4: return IfcUtil::Argument_ENTITY_INSTANCE; case 5: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcLengthMeasure; case 1: return Type::IfcLengthMeasure; case 2: return Type::IfcLengthMeasure; case 3: return Type::IfcReinforcingBarRoleEnum; case 4: return Type::IfcSectionProperties; case 5: return Type::IfcReinforcementBarProperties; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "LongitudinalStartPosition"; case 1: return "LongitudinalEndPosition"; case 2: return "TransversePosition"; case 3: return "ReinforcementRole"; case 4: return "SectionDefinition"; case 5: return "CrossSectionReinforcementDefinitions"; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcSectionReinforcementProperties (IfcAbstractEntity* e);
    IfcSectionReinforcementProperties (double v1_LongitudinalStartPosition, double v2_LongitudinalEndPosition, boost::optional< double > v3_TransversePosition, IfcReinforcingBarRoleEnum::IfcReinforcingBarRoleEnum v4_ReinforcementRole, IfcSectionProperties* v5_SectionDefinition, IfcTemplatedEntityList< IfcReinforcementBarProperties >::ptr v6_CrossSectionReinforcementDefinitions);
    typedef IfcTemplatedEntityList< IfcSectionReinforcementProperties > list;
};
/// Definition from ISO/CD 10303-41:1992: The shape
///   aspect is an identifiable element of the shape of a
///   product.
/// 
/// IfcShapeAspect
///   allows for grouping of shape representation items that
///   represent aspects (or components) of the shape of a
///   product. Thereby shape representations of components of the
///   product shape represent a distinctive part to a product
///   that can be explicitly addressed.
/// 
/// NOTE ÿThe definition of
///   this class relates to the ISO 10303 entity shape_aspect. Please
///   refer to ISO/IS 10303-41:1994 for the final definition of
///   the formal standard.
/// 
/// HISTORY  New Entity in IFC Release 2.0
/// 
/// IFC 2x4 CHANGE  Attribute
///   PartOfProductDefinitionShape declared OPTIONAL with 
///   upward compatibility for file based exchange.
/// 
/// Informal propositions:
/// 
/// If ShapeRepresentations points to shape
///   representations that are part of an
///   IfcProductDefinitionShape,
///   PartOfProductDefinitionShape must refer to this
///   instance of IfcProductDefinitionShape.
/// 
/// NOTEÿ PartOfProductDefinitionShape is
///   only to be omitted if the shape representations are
///   attached to an IfcRepresentationMap. ÿThis
///   enables the use of IfcShapeAspect with
///   IfcRepresentationMap's that are used by an
///   IfcTypeProduct through the
///   RepresentationMaps attribute.
class IfcShapeAspect : public IfcUtil::IfcBaseEntity {
public:
    /// List of shape representations. Each member defines a valid representation of a particular type within a particular representation context as being an aspect (or part) of a product definition.
    /// IFC2x Edition 3 CHANGE  The data type has been changed from IfcShapeRepresentation to IfcShapeModel with upward compatibility
    IfcTemplatedEntityList< IfcShapeModel >::ptr ShapeRepresentations() const;
    void setShapeRepresentations(IfcTemplatedEntityList< IfcShapeModel >::ptr v);
    /// Whether the optional attribute Name is defined for this IfcShapeAspect
    bool hasName() const;
    /// The word or group of words by which the shape aspect is known. It is a tag to indicate the particular semantic of a component within the product definition shape, used to provide meaning. Example: use the tag "Glazing" to define which component of a window shape defines the glazing area.
    std::string Name() const;
    void setName(std::string v);
    /// Whether the optional attribute Description is defined for this IfcShapeAspect
    bool hasDescription() const;
    /// The word or group of words that characterize the shape aspect. It can be used to add additional meaning to the name of the aspect.
    std::string Description() const;
    void setDescription(std::string v);
    /// An indication that the shape aspect is on the physical boundary of the product definition shape. If the value of this attribute is TRUE, it shall be asserted that the shape aspect being identified is on such a boundary. If the value is FALSE, it shall be asserted that the shape aspect being identified is not on such a boundary. If the value is UNKNOWN, it shall be asserted that it is not known whether or not the shape aspect being identified is on such a boundary. 
    /// ---
    /// EXAMPLE: Would be FALSE for a center line, identified as shape aspect; would be TRUE for a cantilever.
    /// ---
    bool ProductDefinitional() const;
    void setProductDefinitional(bool v);
    /// Reference to the product definition shape of which this class is an aspect.
    IfcProductDefinitionShape* PartOfProductDefinitionShape() const;
    void setPartOfProductDefinitionShape(IfcProductDefinitionShape* v);
    virtual unsigned int getArgumentCount() const { return 5; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_STRING; case 2: return IfcUtil::Argument_STRING; case 3: return IfcUtil::Argument_BOOL; case 4: return IfcUtil::Argument_ENTITY_INSTANCE; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcShapeModel; case 1: return Type::IfcLabel; case 2: return Type::IfcText; case 3: return Type::UNDEFINED; case 4: return Type::IfcProductDefinitionShape; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "ShapeRepresentations"; case 1: return "Name"; case 2: return "Description"; case 3: return "ProductDefinitional"; case 4: return "PartOfProductDefinitionShape"; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcShapeAspect (IfcAbstractEntity* e);
    IfcShapeAspect (IfcTemplatedEntityList< IfcShapeModel >::ptr v1_ShapeRepresentations, boost::optional< std::string > v2_Name, boost::optional< std::string > v3_Description, bool v4_ProductDefinitional, IfcProductDefinitionShape* v5_PartOfProductDefinitionShape);
    typedef IfcTemplatedEntityList< IfcShapeAspect > list;
};
/// IfcShapeModel represents
/// the concept of a particular geometric and/or topological
/// representation of a product's shape or a product component's shape
/// within a representation context. This representation context has to
/// be a geometric representation context (with the exception of
/// topology representations without associated geometry). The two
/// subtypes are IfcShapeRepresentation to cover geometric
/// models that represent a shape, and IfcTopologyRepresentation
/// to cover the conectivity of a product or product component. The
/// topology may or may not have geometry associated.
/// 
/// The IfcShapeModel can be a shape representation
/// (geometric and/or topologogical) of a product (via
/// IfcProductDefinitionShape), or a shape representation
/// (geometric and/or topologogical)  of a component of a product
/// shape (via IfcShapeAspect).
/// 
/// HISTORY  New entity in IFC2x3.
class IfcShapeModel : public IfcRepresentation {
public:
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcRepresentation::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcRepresentation::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcRepresentation::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcShapeAspect >::ptr OfShapeAspect() const; // INVERSE IfcShapeAspect::ShapeRepresentations
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcShapeModel (IfcAbstractEntity* e);
    IfcShapeModel (IfcRepresentationContext* v1_ContextOfItems, boost::optional< std::string > v2_RepresentationIdentifier, boost::optional< std::string > v3_RepresentationType, IfcTemplatedEntityList< IfcRepresentationItem >::ptr v4_Items);
    typedef IfcTemplatedEntityList< IfcShapeModel > list;
};
/// The IfcShapeRepresentation represents the concept of a
/// particular geometric representation of a product or a product
/// component within a specific geometric representation context. The
/// inherited attribute RepresentationType is used to define
/// the geometric model used for the shape representation (for example, 
/// 'SweptSolid', or 'Brep'), the inherited attribute
/// RepresentationIdentifier is used to denote the part of the
/// representation captured by the IfcShapeRepresentation
/// (for example, 'Axis', 'Body').
/// 
/// Several representation identifiers for shape representation are
/// included as predefined values for RepresentationIdentifier:
/// 
/// Box
/// Bounding box as simplified 3D box
/// geometry of an element
/// 
/// Annotation
/// 2D annotations not representing
/// elements
/// 
/// Axis
/// 2D or 3D Axis, or single line,
/// representation of an element
/// 
/// FootPrint
/// 2D Foot print, or double line,
/// representation of an element, projected to ground view
/// 
/// Surface
/// 3D Surface representation, e.g. of an
/// analytical surface, of an elementplane)
/// 
/// Body
/// 3D Body representation, e.g. as
/// wireframe, surface, or solid model, of an element
/// 
/// Lighting
/// Representation of emitting light as a
/// light source within a shape representation
/// 
/// Several representation types for shape representation are
/// included as predefined values for RepresentationType:
/// 
/// Curve2D
/// 2 dimensional curve
/// 
/// Curve3D
/// 3 dimensional curve
/// 
/// Surface2D
/// 2 dimensional surface (a region on
/// ground view)
/// 
/// Surface3D
/// 3 dimensional surface
/// 
/// GeometricSet
/// points, curves, surfaces (2 or 3
/// dimensional)
/// 
/// GeometricCurveSet
/// points, curves (2 or 3
/// dimensional)
/// 
/// Annotation2D
/// points, curves (2 or 3 dimensional), hatches and text (2
/// dimensional)
/// 
/// SurfaceModel
/// face based and shell based surface
/// model
/// 
/// SolidModel
/// including swept solid, Boolean
/// results and Brep bodies
/// more specific types are:
/// 
/// SweptSolid
/// swept area solids, by extrusion and
/// revolution, excluding tapered sweeps
/// 
/// AdvancedSweptSolid
/// swept area solids created by sweeping
/// a profile along a directrix, and tapered sweeps
/// 
/// Brep
/// faceted Brep's with and without
/// voids
/// 
/// AdvancedBrep
/// Brep's based on advanced faces, with
/// b-spline surface geometry, with and without voids
/// 
/// CSG
/// Boolean results of operations between
/// solid models, half spaces and Boolean results
/// 
/// Clipping
/// Boolean differences between swept
/// area solids, half spaces and Boolean results
/// 
/// additional types
/// 
/// some additional representation types are provided:
/// 
/// BoundingBox
/// simplistic 3D representation by a
/// bounding box
/// 
/// SectionedSpine
/// cross section based representation of
/// a spine curve and planar cross sections. It can represent a surface
/// or a solid and the interpolations of the between the cross sections
/// is not defined
/// 
/// LightSource
/// light source with (depending on type)
/// position, orientation, light colour, intensity and attenuation
/// 
/// MappedRepresentation
/// representation based on mapped
/// item(s), referring to a representation map. Note: it can be seen as
/// an inserted block reference. The shape representation of the mapped
/// item has a representation type declaring the type of its
/// representation items.
/// 
/// Table 1: string values for the inherited attribute
/// 'RepresentationType'.
/// 
/// NOTE  The definition of this entity relates to the ISO 10303 entity shape_representation. Please refer to ISO/IS 10303-41:1994 for the final definition of the formal standard.
/// 
/// HISTORY  New entity in IFC Release 1.5.
/// 
/// IFC2x4 CHANGE  The RepresentationType's 'Curve3D', 'Surface2D', 'Surface3D', 'AdvancedBrep', 'LightSource', and the RepresentationIdentifier 'Lighting' have been added.
class IfcShapeRepresentation : public IfcShapeModel {
public:
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcShapeModel::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcShapeModel::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcShapeModel::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcShapeRepresentation (IfcAbstractEntity* e);
    IfcShapeRepresentation (IfcRepresentationContext* v1_ContextOfItems, boost::optional< std::string > v2_RepresentationIdentifier, boost::optional< std::string > v3_RepresentationType, IfcTemplatedEntityList< IfcRepresentationItem >::ptr v4_Items);
    typedef IfcTemplatedEntityList< IfcShapeRepresentation > list;
};
/// IfcSimpleProperty is a generalization of a single property object. The various subtypes of IfcSimpleProperty establish different ways in which a property value can be set. 
/// 
/// HISTORY  New Entity in IFC Release 1.0, definition changed in IFC Release 2x.
class IfcSimpleProperty : public IfcProperty {
public:
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcProperty::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcProperty::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcProperty::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcSimpleProperty (IfcAbstractEntity* e);
    IfcSimpleProperty (std::string v1_Name, boost::optional< std::string > v2_Description);
    typedef IfcTemplatedEntityList< IfcSimpleProperty > list;
};
/// Definition from IAI: Describe more rarely needed connection properties.
/// 
/// HISTORY: New entity in IFC 2x2.
class IfcStructuralConnectionCondition : public IfcUtil::IfcBaseEntity {
public:
    /// Whether the optional attribute Name is defined for this IfcStructuralConnectionCondition
    bool hasName() const;
    /// Optionally defines a name for this connection condition.
    std::string Name() const;
    void setName(std::string v);
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_STRING; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcLabel; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Name"; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcStructuralConnectionCondition (IfcAbstractEntity* e);
    IfcStructuralConnectionCondition (boost::optional< std::string > v1_Name);
    typedef IfcTemplatedEntityList< IfcStructuralConnectionCondition > list;
};
/// Definition from IAI: The abstract entity IfcStructuralLoadOrResult is the supertype of all loads (actions or reactions) or of certain requirements resulting from structural analysis, or certain provisions which influence structural analysis.
/// 
/// HISTORY: New entity in IFC 2x2.
class IfcStructuralLoad : public IfcUtil::IfcBaseEntity {
public:
    /// Whether the optional attribute Name is defined for this IfcStructuralLoad
    bool hasName() const;
    /// Optionally defines a name for this load.
    std::string Name() const;
    void setName(std::string v);
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_STRING; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcLabel; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Name"; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcStructuralLoad (IfcAbstractEntity* e);
    IfcStructuralLoad (boost::optional< std::string > v1_Name);
    typedef IfcTemplatedEntityList< IfcStructuralLoad > list;
};
/// Definition from IAI: The abstract entity IfcStructuralLoadStatic is the supertype of all static loads (actions or reactions) which can be defined.  Within scope are single i.e. concentrated forces and moments, linear i.e. one-dimensionally distributed forces and moments, planar i.e. two-dimensionally distributed forces, furthermore displacements and temperature loads.
/// 
/// HISTORY: New entity in IFC 2x2.
class IfcStructuralLoadStatic : public IfcStructuralLoad {
public:
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcStructuralLoad::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcStructuralLoad::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcStructuralLoad::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcStructuralLoadStatic (IfcAbstractEntity* e);
    IfcStructuralLoadStatic (boost::optional< std::string > v1_Name);
    typedef IfcTemplatedEntityList< IfcStructuralLoadStatic > list;
};
/// An instance of the entity IfcStructuralLoadTemperature shall be used to define actions which are caused by a temperature change. As shown in Figure 332, the change of temperature is given with a constant value which is applied to the complete section and values for temperature differences between outer fibres of the section.
/// 
/// HISTORY  New entity in IFC2x2. 
/// 
/// Figure 332 — Structural load temperature
class IfcStructuralLoadTemperature : public IfcStructuralLoadStatic {
public:
    /// Whether the optional attribute DeltaT_Constant is defined for this IfcStructuralLoadTemperature
    bool hasDeltaT_Constant() const;
    double DeltaT_Constant() const;
    void setDeltaT_Constant(double v);
    /// Whether the optional attribute DeltaT_Y is defined for this IfcStructuralLoadTemperature
    bool hasDeltaT_Y() const;
    double DeltaT_Y() const;
    void setDeltaT_Y(double v);
    /// Whether the optional attribute DeltaT_Z is defined for this IfcStructuralLoadTemperature
    bool hasDeltaT_Z() const;
    double DeltaT_Z() const;
    void setDeltaT_Z(double v);
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 1: return IfcUtil::Argument_DOUBLE; case 2: return IfcUtil::Argument_DOUBLE; case 3: return IfcUtil::Argument_DOUBLE; } return IfcStructuralLoadStatic::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 1: return Type::IfcThermodynamicTemperatureMeasure; case 2: return Type::IfcThermodynamicTemperatureMeasure; case 3: return Type::IfcThermodynamicTemperatureMeasure; } return IfcStructuralLoadStatic::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 1: return "DeltaT_Constant"; case 2: return "DeltaT_Y"; case 3: return "DeltaT_Z"; } return IfcStructuralLoadStatic::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcStructuralLoadTemperature (IfcAbstractEntity* e);
    IfcStructuralLoadTemperature (boost::optional< std::string > v1_Name, boost::optional< double > v2_DeltaT_Constant, boost::optional< double > v3_DeltaT_Y, boost::optional< double > v4_DeltaT_Z);
    typedef IfcTemplatedEntityList< IfcStructuralLoadTemperature > list;
};
/// IfcStyleModel represents the concept of a particular presentation style defined for a material (or other characteristic) of a product or a product component within a representation context. This representation context may (but has not to be) a geometric representation context.
/// 
/// IfcStyleModel can be a style representation (presentation style) of a material (via IfcMaterialDefinitionRepresentation), potentially differentiated for different representation contexts (for example, different material hatching depending on the scale of the target representation context).
/// 
/// HISTORY  New entity in IFC2x3.
class IfcStyleModel : public IfcRepresentation {
public:
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcRepresentation::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcRepresentation::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcRepresentation::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcStyleModel (IfcAbstractEntity* e);
    IfcStyleModel (IfcRepresentationContext* v1_ContextOfItems, boost::optional< std::string > v2_RepresentationIdentifier, boost::optional< std::string > v3_RepresentationType, IfcTemplatedEntityList< IfcRepresentationItem >::ptr v4_Items);
    typedef IfcTemplatedEntityList< IfcStyleModel > list;
};
/// Definition from ISO/CD 10303-46:1992: The styled item is an assignment of style for presentation to a geometric representation item as it is used in a representation.
/// 
/// NOTE  Corresponding ISO 10303 name: styled_item. Please refer to ISO/IS 10303-46:1994 for the final definition of the formal standard.
/// 
/// The IfcStyledItem holds presentation style information for products, either explicitly for an IfcGeometricRepresentationItem being part of an IfcShapeRepresentation assigned to a product, or by assigning presentation information to IfcMaterial being assigned as other representation for a product.
/// 
/// If the IfcStyledItem is used within a reference from an IfcProductDefinitionShape then one Item shall be provided.
/// If the IfcStyledItem is used within a reference from an IfcMaterialDefinitionRepresentation then no Item shall be provided.
/// 
/// HISTORY  New entity in IFC2x2.
/// 
/// IFC2x2 Addendum 1 CHANGE  The entity IfcStyledItem has been made non abstract and the attribute Name added.
/// 
/// IFC2x3 CHANGE The attribute Item has been made optional, upward compatibility for file
/// based exchange is guaranteed.
/// 
/// IFC2x4 CHANGE The subtype IfcAnnotationOccurrence and its subtypes are deleted. Use IfcStyledItem for all instantiations. The data type of Styles has been changed to IfcStyleAssignmentSelect
/// 
/// Use Definition
/// 
/// Figure 293 illustrates use of IfcStyledItem for the two usage examples:
/// 
/// As a presentation for a geometric representation item
/// As a presentation for a material definition
/// 
/// NOTE  The new IfcStyleAssignmentSelect allows the direct assignment styles, such as IfcCurveStyle, IfcSurfaceStyle without using the intermediate IfcPresentationStyleAssignment
/// 
/// Figure 293 — Styled item
class IfcStyledItem : public IfcRepresentationItem {
public:
    /// Whether the optional attribute Item is defined for this IfcStyledItem
    bool hasItem() const;
    /// A geometric representation item to which the style is assigned.
    /// 
    /// IFC2x Edition 2 Addendum 2 CHANGE The attribute Item has been made optional. Upward compatibility for file based exchange is guaranteed.
    IfcRepresentationItem* Item() const;
    void setItem(IfcRepresentationItem* v);
    /// Representation styles which are assigned, either to an geometric representation item, or to a material definition.
    /// 
    /// IFC2x4 CHANGE  The data type has been changed to IfcStyleAssignmentSelect with upward compatibility 
    /// for file based exchange.
    /// 
    /// NOTE  Only the select item IfcPresentationStyle shall be used from IFC2x4 onwards, the IfcPresentationStyleAssignment has been deprecated.
    IfcTemplatedEntityList< IfcPresentationStyleAssignment >::ptr Styles() const;
    void setStyles(IfcTemplatedEntityList< IfcPresentationStyleAssignment >::ptr v);
    /// Whether the optional attribute Name is defined for this IfcStyledItem
    bool hasName() const;
    /// The word, or group of words, by which the styled item is referred to.
    std::string Name() const;
    void setName(std::string v);
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 2: return IfcUtil::Argument_STRING; } return IfcRepresentationItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcRepresentationItem; case 1: return Type::IfcPresentationStyleAssignment; case 2: return Type::IfcLabel; } return IfcRepresentationItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Item"; case 1: return "Styles"; case 2: return "Name"; } return IfcRepresentationItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcStyledItem (IfcAbstractEntity* e);
    IfcStyledItem (IfcRepresentationItem* v1_Item, IfcTemplatedEntityList< IfcPresentationStyleAssignment >::ptr v2_Styles, boost::optional< std::string > v3_Name);
    typedef IfcTemplatedEntityList< IfcStyledItem > list;
};
/// The IfcStyledRepresentation represents the concept of a styled presentation being a representation of a product or a product component, like material. within a representation context. This representation context does not need to be (but may be) a geometric representation context.
/// 
/// NOTE  Current usage of IfcStyledRepresentation is restricted to the assignment of presentation information to an material. The IfcStyledRepresentation includes only presentation styles (IfcCurveStyle, FillAreaStyle, IfcSurfaceStyle) that define how a material should be presented within a particular (eventually view and scale dependent) representation context. All instances of IfcStyledRepresentation are referenced by IfcMaterialDefinitionRepresentation, and assigned to IfcMaterial by IfcMaterialDefinitionRepresentation.RepresentedMaterial.
/// 
/// A styled representation has to include one or several styled items with the associated style information (curve, symbol, text, fill area, or surface styles). It shall not contain the geometric representation items that are styled.
/// 
/// HISTORY  New entity in IFC2x2.
class IfcStyledRepresentation : public IfcStyleModel {
public:
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcStyleModel::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcStyleModel::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcStyleModel::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcStyledRepresentation (IfcAbstractEntity* e);
    IfcStyledRepresentation (IfcRepresentationContext* v1_ContextOfItems, boost::optional< std::string > v2_RepresentationIdentifier, boost::optional< std::string > v3_RepresentationType, IfcTemplatedEntityList< IfcRepresentationItem >::ptr v4_Items);
    typedef IfcTemplatedEntityList< IfcStyledRepresentation > list;
};
/// IfcSurfaceStyle is an assignment of one or many surface style elements to a surface, defined by subtypes of IfcSurface, IfcFaceBasedSurfaceModel, IfcShellBasedSurfaceModel, or by subtypes of IfcSolidModel. The positive direction of the surface normal relates to the positive side. In case of solids the outside of the solid is to be taken as positive side. 
/// 
/// NOTE: The surface style is often referred to as material definition in rendering applications.
/// 
/// NOTE Corresponding ISO 10303 entity: surface_style_usage and surface_side_style. Please refer to ISO/IS 10303-46:1994 for the final definition of the formal standard. The surface style definition in regard to support of rendering has been greatly expanded beyond the scope of ISO/IS 10303-46.
/// 
/// HISTORY New Entity in IFC 2.x.
class IfcSurfaceStyle : public IfcPresentationStyle {
public:
    /// An indication of which side of the surface to apply the style.
    IfcSurfaceSide::IfcSurfaceSide Side() const;
    void setSide(IfcSurfaceSide::IfcSurfaceSide v);
    /// A collection of different surface styles.
    IfcEntityList::ptr Styles() const;
    void setStyles(IfcEntityList::ptr v);
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 1: return IfcUtil::Argument_ENUMERATION; case 2: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } return IfcPresentationStyle::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 1: return Type::IfcSurfaceSide; case 2: return Type::IfcSurfaceStyleElementSelect; } return IfcPresentationStyle::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 1: return "Side"; case 2: return "Styles"; } return IfcPresentationStyle::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcSurfaceStyle (IfcAbstractEntity* e);
    IfcSurfaceStyle (boost::optional< std::string > v1_Name, IfcSurfaceSide::IfcSurfaceSide v2_Side, IfcEntityList::ptr v3_Styles);
    typedef IfcTemplatedEntityList< IfcSurfaceStyle > list;
};
/// IfcSurfaceStyleLighting is a container class for properties for calculation of physically exact illuminance related to a particular surface style.
/// 
/// Figure 294 shows the reflection and transmission components from an incident ray. The sum of the components for reflection and transmission is a value of 1.0 denoting that the incident ray is completely decomposed into reflection and transmission components. Each value of reflection and transmission is therefore within the range 0.0 to 1.0. 
/// 
/// Figure 294 — Surface style lighting
/// 
/// All these factors can be measured physically and are ratios for the red, green and blue part of the light. These properties are defined in the model as Type IfcColorRGB with a factor for each colour. 
/// 
/// EXAMPLE  A green glass transmits only green light, so its transmission factor is 0.0 for red, between 0.0 and 1.0 for green and 0.0 for blue. A green surface reflects only green light, so the reflectance factor is 0.0 for red, between 0.0 and 1.0 for green and 0.0 for blue.
/// 
/// HISTORY  New entity in IFC 2x2.
class IfcSurfaceStyleLighting : public IfcUtil::IfcBaseEntity {
public:
    /// The degree of diffusion of the transmitted light. In the case of completely transparent materials there is no diffusion. The greater the diffusing power, the smaller the direct component of the transmitted light, up to the point where only diffuse light is produced.A value of 1 means totally diffuse for that colour part of the light.
    /// The factor can be measured physically and has three ratios for the red, green and blue part of the light.
    IfcColourRgb* DiffuseTransmissionColour() const;
    void setDiffuseTransmissionColour(IfcColourRgb* v);
    /// The degree of diffusion of the reflected light. In the case of specular surfaces there is no diffusion. The greater the diffusing power of the reflecting surface, the smaller the specular component of the reflected light, up to the point where only diffuse light is produced. A value of 1 means totally diffuse for that colour part of the light. 
    /// The factor can be measured physically and has three ratios for the red, green and blue part of the light.
    IfcColourRgb* DiffuseReflectionColour() const;
    void setDiffuseReflectionColour(IfcColourRgb* v);
    /// Describes how the light falling on a body is totally or partially transmitted. 
    /// The factor can be measured physically and has three ratios for the red, green and blue part of the light.
    IfcColourRgb* TransmissionColour() const;
    void setTransmissionColour(IfcColourRgb* v);
    /// A coefficient that determines the extent that the light falling onto a surface is fully or partially reflected. 
    /// The factor can be measured physically and has three ratios for the red, green and blue part of the light.
    IfcColourRgb* ReflectanceColour() const;
    void setReflectanceColour(IfcColourRgb* v);
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_ENTITY_INSTANCE; case 2: return IfcUtil::Argument_ENTITY_INSTANCE; case 3: return IfcUtil::Argument_ENTITY_INSTANCE; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcColourRgb; case 1: return Type::IfcColourRgb; case 2: return Type::IfcColourRgb; case 3: return Type::IfcColourRgb; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "DiffuseTransmissionColour"; case 1: return "DiffuseReflectionColour"; case 2: return "TransmissionColour"; case 3: return "ReflectanceColour"; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcSurfaceStyleLighting (IfcAbstractEntity* e);
    IfcSurfaceStyleLighting (IfcColourRgb* v1_DiffuseTransmissionColour, IfcColourRgb* v2_DiffuseReflectionColour, IfcColourRgb* v3_TransmissionColour, IfcColourRgb* v4_ReflectanceColour);
    typedef IfcTemplatedEntityList< IfcSurfaceStyleLighting > list;
};
/// IfcSurfaceStyleRefraction extends the surface style lighting, or the surface style rendering definition for properties for calculation of physically exact illuminance by adding seldomly used properties. Currently this includes the refraction index (by which the light ray refracts when passing through a prism) and the dispersion factor (or Abbe constant) which takes into account the wavelength dependency of the refraction.
/// 
/// NOTE: If such refraction properties are used, the IfcSurfaceStyle should include within its set of Styles (depending on whether rendering or lighting is used) an instance of IfcSurfaceStyleLighting and IfcSurfaceStyleRefraction, or an instance of IfcSurfaceStyleRendering and IfcSurfaceStyleRefraction.
/// 
/// HISTORY: New entity in IFC 2x2.
class IfcSurfaceStyleRefraction : public IfcUtil::IfcBaseEntity {
public:
    /// Whether the optional attribute RefractionIndex is defined for this IfcSurfaceStyleRefraction
    bool hasRefractionIndex() const;
    /// The index of refraction for all wave lengths of light. The refraction index is the ratio between the speed of light in a vacuum and the speed of light in the medium. E.g. glass has a refraction index of 1.5, whereas water has an index of 1.33
    double RefractionIndex() const;
    void setRefractionIndex(double v);
    /// Whether the optional attribute DispersionFactor is defined for this IfcSurfaceStyleRefraction
    bool hasDispersionFactor() const;
    /// The Abbe constant given as a fixed ratio between the refractive indices of the material at different wavelengths. A low Abbe number means a high dispersive power. In general this translates to a greater angular spread of the emergent spectrum.
    double DispersionFactor() const;
    void setDispersionFactor(double v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_DOUBLE; case 1: return IfcUtil::Argument_DOUBLE; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcReal; case 1: return Type::IfcReal; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "RefractionIndex"; case 1: return "DispersionFactor"; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcSurfaceStyleRefraction (IfcAbstractEntity* e);
    IfcSurfaceStyleRefraction (boost::optional< double > v1_RefractionIndex, boost::optional< double > v2_DispersionFactor);
    typedef IfcTemplatedEntityList< IfcSurfaceStyleRefraction > list;
};
/// Definition from ISO/CD 10303-46:1992: The surface style rendering allows the realistic visualization of surfaces referring to rendering techniques based on the laws of physics and mathematics. 
/// 
/// The entity IfcSurfaceStyleShading allows for colour information used for shading, whereas subtypes provide data for more sophisticated rendering techniques. The surface colour is used for colouring or simple shading of the assigned surfaces. 
/// 
/// NOTE Corresponding ISO 10303 entity: surface_style_rendering. Please refer to ISO/IS 10303-46:1994 for the final definition of the formal standard. No rendering method is defined for each surface style (such as constant, colour, dot or normal shading), therefore the attribute rendering_method has been omitted.
/// 
/// HISTORY: New entity in IFC 2x.
class IfcSurfaceStyleShading : public IfcUtil::IfcBaseEntity {
public:
    /// The colour used to render the surface. The surface colour for visualisation is defined by specifying the intensity of red, green and blue.
    IfcColourRgb* SurfaceColour() const;
    void setSurfaceColour(IfcColourRgb* v);
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcColourRgb; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "SurfaceColour"; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcSurfaceStyleShading (IfcAbstractEntity* e);
    IfcSurfaceStyleShading (IfcColourRgb* v1_SurfaceColour);
    typedef IfcTemplatedEntityList< IfcSurfaceStyleShading > list;
};
/// The entity IfcSurfaceStyleWithTextures allows to include image textures in surface styles. These image textures can be applied repeating across the surface or mapped with a particular scale upon the surface.
/// 
/// The entity IfcSurfaceStyleWithTextures is part of the surface style table for presentation information assigned to surfaces for shading, rendering and lighting with textures. The mapping of the texture onto the surface or the solid is determined by the texture coordinates, in absense of an IfcTextureCoordinate assigned to each surface texture, a default mapping of the texture to the geometric face or surface applies.
/// 
/// Surface textures included in the IfcSurfaceStyleWithTextures are two dimensional map formats. They define 2D images that contain an array of colour values describing the texture. Depending on the number of IfcSurfaceTextures being included in the list of Textures the IfcSurfaceStyleWithTextures either describes a single texture, or a multi texture.
/// 
/// single texture: a single surface texture is applied to the styled geometric item (entirely or partly) with optional repetition and texture transformation
/// multi texture: two or more surface textures are applied to the styled geometric item (entirely or partly) with optional repetition, texture transformation or texture coordinate mapping being specific for each texture.
/// 
/// Informal proposition
/// 
/// Only one instance of IfcSurfaceStyleWithTextures shall be referenced by an IfcStyledItem and be assigned to an IfcGeometricRepresentationItem
/// 
/// NOTE  The definitions of texturing within this standard have been developed in dependence on the texture component of X3D. See ISO/IEC 19775-1.2:2008 X3D Architecture and base components Edition 2, Part 1, 18 Texturing component for the definitions in the international standard.
/// 
/// HISTORY  New entity in IFC2x2.
/// 
/// IFC2x3 CHANGE  inverse attribute HasTextureCoordinates deleted.
class IfcSurfaceStyleWithTextures : public IfcUtil::IfcBaseEntity {
public:
    /// The textures applied to the surface. In case of more than one surface texture is included, the IfcSurfaceStyleWithTexture defines a multi texture.
    IfcTemplatedEntityList< IfcSurfaceTexture >::ptr Textures() const;
    void setTextures(IfcTemplatedEntityList< IfcSurfaceTexture >::ptr v);
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcSurfaceTexture; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Textures"; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcSurfaceStyleWithTextures (IfcAbstractEntity* e);
    IfcSurfaceStyleWithTextures (IfcTemplatedEntityList< IfcSurfaceTexture >::ptr v1_Textures);
    typedef IfcTemplatedEntityList< IfcSurfaceStyleWithTextures > list;
};
/// An IfcSurfaceTexture provides a 2-dimensional
/// image-based texture map. It can either be given by referencing an
/// external image file through an URL reference
/// (IfcImageTexture), including the image file as a blob
/// (long binary) into the data set (IfcBlobTexture), or by
/// explicitly including an array of pixels
/// (IfcPixelTexture).
/// The following definitions from ISO/IEC 19775-1 X3D Architecture
/// and base components (X3D Specification)
/// apply:
/// 
/// Texture: An image
/// used in a texture map to create visual appearance effects when
/// applied to geometry nodes.
/// Texture map: A
/// texture plus the general parameters necessary for mapping the
/// texture to geometry.
/// 
/// Texture are defined by 2D images that contain an array of colour
/// values describing the texture. The texture values are interpreted
/// differently depending on the number of components in the texture
/// and the specifics of the image format. In general, texture may be
/// described using one of the following forms:
/// 
/// Intensity textures (one-component)
/// Intensity plus alpha opacity textures (two-component)
/// Full RGB textures (three-component)
/// Full RGB plus alpha opacity textures (four-component)
/// 
/// NOTE  Image formats specify an alpha opacity, not transparency (where alpha = 1 - transparency).
/// 
/// Figure 295 illustrates the texture coordinate system.
/// 
/// Figure 295 — Surface texture coordinates
/// 
/// The following definitions from ISO/IEC 19775-1 X3D Architecture and base components (X3D Specification) on texture coordinates apply:
/// 
/// Texture maps are defined in a 2D coordinate system (s, t) that ranges from [0.0, 1.0] in both directions. The bottom edge of the image corresponds to the S-axis of the texture map, and left edge of the image corresponds to the T-axis of the texture map. The lower-left pixel of the image corresponds to s=0, t=0, and the top-right pixel of the image corresponds to s=1, t=1. Texture maps may be viewed as two dimensional colour functions that, given an (s, t) coordinate, return a colour value colour(s, t).
/// 
/// If multiple surface textures are included in the
/// IfcSurfaceStyleWithTextures applying them to a geometric
/// item, a mode and optional parameters can be included that blending
/// operations.
/// The RepeatS and RepeatT Boolean flags control
/// whether the texture map is repeated outside the [0.0, 1.0] texture
/// coordinate range, when applied to a geometric surface, or clamped
/// to lie within the [0.0, 1.0] range. The TextureTransform
/// applies a 2D non-uniform transformation to the texture before it is
/// applied to a geometric surface.
/// The following definitions from ISO/IEC 19775-1 X3D Architecture
/// and base components (X3D Specification)
/// apply:
/// 
/// These parameters
/// support changes to the size, orientation, and position of textures
/// on shapes. Note that these operations appear reversed when viewed
/// on the surface of geometry. For example, a scale value of (2
/// 2) will scale the texture coordinates and have the net effect of
/// shrinking the texture size by a factor of 2 (texture coordinates
/// are twice as large and thus cause the texture to repeat). A
/// translation of (0.5 0.0) translates the texture coordinates +.5
/// units along the S-axis and has the net effect of translating the
/// texture −0.5 along the S-axis on the geometry's surface. A
/// rotation of π/2 of the texture coordinates results in a
/// −π/2 rotation of the texture on the geometry.
/// The center
/// field specifies a translation offset in texture coordinate space
/// about which the rotation and scale fields are
/// applied. The scale field specifies a scaling factor in S and
/// T of the texture coordinates about the center point.
/// scale values shall be in the range (−∞,∞).
/// The rotation field specifies a rotation in radians of the
/// texture coordinates about the center point after the scale
/// has been applied. A positive rotation value makes the texture
/// coordinates rotate counterclockwise about the centre, thereby
/// rotating the appearance of the texture itself clockwise. The
/// translation field specifies a translation of the texture
/// coordinates.
/// The following conventions
/// apply:
/// 
/// center =
/// TextureTransform.LocalOrigin;
/// rotation = TextureTransform.Axis1
/// scale S = TextureTransform.Scale
/// scale T = TextureTransform.Scale2
/// 
/// NOTE  The definitions of texturing within this standard have been developed in dependence on the texture component of X3D. See ISO/IEC 19775-1.2:2008 X3D Architecture and base components Edition 2, Part 1, 18 Texturing component for the definitions in the international standard.
/// 
/// HISTORY  New entity in IFC 2x2.
/// 
/// IFC2x4 CHANGE  Attribute TextureType replaces by Mode, attributes Parameter and MapsTo aded, new inverse attribute UsedInStyle.
class IfcSurfaceTexture : public IfcUtil::IfcBaseEntity {
public:
    /// The RepeatS field specifies how the texture wraps in the S direction. If RepeatS is TRUE (the default), the texture map is repeated outside the [0.0, 1.0] texture coordinate range in the S direction so that it fills the shape. If RepeatS is FALSE, the texture coordinates are clamped in the S direction to lie within the [0.0, 1.0] range.
    bool RepeatS() const;
    void setRepeatS(bool v);
    /// The RepeatT field specifies how the texture wraps in the T direction. If RepeatT is TRUE (the default), the texture map is repeated outside the [0.0, 1.0] texture coordinate range in the T direction so that it fills the shape. If RepeatT is FALSE, the texture coordinates are clamped in the T direction to lie within the [0.0, 1.0] range.
    bool RepeatT() const;
    void setRepeatT(bool v);
    IfcSurfaceTextureEnum::IfcSurfaceTextureEnum TextureType() const;
    void setTextureType(IfcSurfaceTextureEnum::IfcSurfaceTextureEnum v);
    /// Whether the optional attribute TextureTransform is defined for this IfcSurfaceTexture
    bool hasTextureTransform() const;
    /// The TextureTransform defines a 2D transformation that is applied to the texture coordinates. It affects the way texture coordinates are applied to the surfaces of geometric representation itesm. The 2D transformation supports changes to the size, orientation, and position of textures on shapes. 
    /// 
    /// Mirroring is not allowed to be used in the IfcCarteesianTransformationOperator
    IfcCartesianTransformationOperator2D* TextureTransform() const;
    void setTextureTransform(IfcCartesianTransformationOperator2D* v);
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_BOOL; case 1: return IfcUtil::Argument_BOOL; case 2: return IfcUtil::Argument_ENUMERATION; case 3: return IfcUtil::Argument_ENTITY_INSTANCE; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::UNDEFINED; case 1: return Type::UNDEFINED; case 2: return Type::IfcSurfaceTextureEnum; case 3: return Type::IfcCartesianTransformationOperator2D; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "RepeatS"; case 1: return "RepeatT"; case 2: return "TextureType"; case 3: return "TextureTransform"; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcSurfaceTexture (IfcAbstractEntity* e);
    IfcSurfaceTexture (bool v1_RepeatS, bool v2_RepeatT, IfcSurfaceTextureEnum::IfcSurfaceTextureEnum v3_TextureType, IfcCartesianTransformationOperator2D* v4_TextureTransform);
    typedef IfcTemplatedEntityList< IfcSurfaceTexture > list;
};
/// Definition from ISO/CD 10303-46:1992: The symbol style is the presentation style that indicates the presentation of annotation symbols. 
/// 
/// NOTE: Corresponding ISO 10303 name: symbol_style. Please refer to ISO/IS 10303-46:1994, p. 124 for the final definition of the formal standard.
/// 
/// HISTORY: New entity in Release IFC2x2.
class IfcSymbolStyle : public IfcPresentationStyle {
public:
    /// The style applied to the symbol for its visual appearance.
    IfcSymbolStyleSelect* StyleOfSymbol() const;
    void setStyleOfSymbol(IfcSymbolStyleSelect* v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 1: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcPresentationStyle::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 1: return Type::IfcSymbolStyleSelect; } return IfcPresentationStyle::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 1: return "StyleOfSymbol"; } return IfcPresentationStyle::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcSymbolStyle (IfcAbstractEntity* e);
    IfcSymbolStyle (boost::optional< std::string > v1_Name, IfcSymbolStyleSelect* v2_StyleOfSymbol);
    typedef IfcTemplatedEntityList< IfcSymbolStyle > list;
};
/// An IfcTable is a data structure for the provision of information in the form of rows and columns. Each instance may have IfcTableColumn instances that define the name, description and units for each column. The rows of information are stored as a list of IfcTableRow objects. 
/// 
/// Limitation: For backwards compatibility, the rows of an IfcTable object are constrained to have the same number of cells. The first Row of the table provides the number of cells. All other rows are forced to include the same number of cells. This is enforced by the WR2. 
/// 
/// Figure 335 illustrates table use.
/// 
/// Figure 335 — Table use
/// 
/// Figure 336 depicts how tables were structured prior to IFC2x4.
/// 
/// Figure 336 — Table use alternative
/// 
/// HISTORY  New entity in IFC R1.5.
/// 
/// IFC2x4 CHANGE  Columns attribute added.
class IfcTable : public IfcUtil::IfcBaseEntity {
public:
    /// A unique name which is intended to describe the usage of the Table.
    std::string Name() const;
    void setName(std::string v);
    /// Reference to information content of rows.
    IfcTemplatedEntityList< IfcTableRow >::ptr Rows() const;
    void setRows(IfcTemplatedEntityList< IfcTableRow >::ptr v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_STRING; case 1: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::UNDEFINED; case 1: return Type::IfcTableRow; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Name"; case 1: return "Rows"; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcTable (IfcAbstractEntity* e);
    IfcTable (std::string v1_Name, IfcTemplatedEntityList< IfcTableRow >::ptr v2_Rows);
    typedef IfcTemplatedEntityList< IfcTable > list;
};
/// IfcTableRow contains data for a single row within an IfcTable. 
/// 
/// Limitation: For backward compatibility, all IfcTableRow objects referenced by an IfcTable shall have the same number of Row Cells. The actual number of Cells shall be taken from the number of cells of the first IfcTableRow for that table. The number of Cells is calculated by the derived attribute NumberOfCellsInRow in the associated IfcTable. 
/// 
/// Figure 337 illustrates table row use.
/// 
/// Figure 337 — Table row use
/// 
/// Figure 338 depicts how table rows were structured prior to IFC2x4 with the use of the IsHeading flag. Note that the use of the IfcTableColumn constructs should be used instead of the IsHeading flag (which remains for backward compatibility only): 
/// 
/// Figure 338 — Table row use alternative
/// 
/// HISTORY  New entity in IFC R1.5.
class IfcTableRow : public IfcUtil::IfcBaseEntity {
public:
    /// The data value of the table cell..
    IfcEntityList::ptr RowCells() const;
    void setRowCells(IfcEntityList::ptr v);
    /// Flag which identifies if the row is a heading row or a row which contains row values. NOTE - If the row is a heading, the flag takes the value = TRUE.
    bool IsHeading() const;
    void setIsHeading(bool v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_BOOL; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcValue; case 1: return Type::UNDEFINED; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "RowCells"; case 1: return "IsHeading"; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcTable >::ptr OfTable() const; // INVERSE IfcTable::Rows
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcTableRow (IfcAbstractEntity* e);
    IfcTableRow (IfcEntityList::ptr v1_RowCells, bool v2_IsHeading);
    typedef IfcTemplatedEntityList< IfcTableRow > list;
};
/// Definition: Address to which telephone, electronic mail and other forms of telecommunications should be addressed.
/// 
/// HISTORY New entity in IFC Release 2x.
/// 
/// IFC 2x4 change:  Added attribute MessagingIDs.
/// Type of attribute WWWHomePageURL compatibly changed from IfcLabel to IfcURIReference.
class IfcTelecomAddress : public IfcAddress {
public:
    /// Whether the optional attribute TelephoneNumbers is defined for this IfcTelecomAddress
    bool hasTelephoneNumbers() const;
    /// The list of telephone numbers at which telephone messages may be received.
    std::vector< std::string > /*[1:?]*/ TelephoneNumbers() const;
    void setTelephoneNumbers(std::vector< std::string > /*[1:?]*/ v);
    /// Whether the optional attribute FacsimileNumbers is defined for this IfcTelecomAddress
    bool hasFacsimileNumbers() const;
    /// The list of fax numbers at which fax messages may be received.
    std::vector< std::string > /*[1:?]*/ FacsimileNumbers() const;
    void setFacsimileNumbers(std::vector< std::string > /*[1:?]*/ v);
    /// Whether the optional attribute PagerNumber is defined for this IfcTelecomAddress
    bool hasPagerNumber() const;
    /// The pager number at which paging messages may be received.
    std::string PagerNumber() const;
    void setPagerNumber(std::string v);
    /// Whether the optional attribute ElectronicMailAddresses is defined for this IfcTelecomAddress
    bool hasElectronicMailAddresses() const;
    /// The list of Email addresses at which Email messages may be received.
    std::vector< std::string > /*[1:?]*/ ElectronicMailAddresses() const;
    void setElectronicMailAddresses(std::vector< std::string > /*[1:?]*/ v);
    /// Whether the optional attribute WWWHomePageURL is defined for this IfcTelecomAddress
    bool hasWWWHomePageURL() const;
    /// The world wide web address at which the preliminary page of information for the person or organization can be located.
    /// NOTE: Information on the world wide web for a person or organization may be separated 
    /// into a number of pages and across a number of host sites, all of which may be linked together. It is assumed that 
    /// all such information may be referenced from a single page that is termed the home page for that person or organization.
    std::string WWWHomePageURL() const;
    void setWWWHomePageURL(std::string v);
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 3: return IfcUtil::Argument_AGGREGATE_OF_STRING; case 4: return IfcUtil::Argument_AGGREGATE_OF_STRING; case 5: return IfcUtil::Argument_STRING; case 6: return IfcUtil::Argument_AGGREGATE_OF_STRING; case 7: return IfcUtil::Argument_STRING; } return IfcAddress::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 3: return Type::IfcLabel; case 4: return Type::IfcLabel; case 5: return Type::IfcLabel; case 6: return Type::IfcLabel; case 7: return Type::IfcLabel; } return IfcAddress::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 3: return "TelephoneNumbers"; case 4: return "FacsimileNumbers"; case 5: return "PagerNumber"; case 6: return "ElectronicMailAddresses"; case 7: return "WWWHomePageURL"; } return IfcAddress::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcTelecomAddress (IfcAbstractEntity* e);
    IfcTelecomAddress (boost::optional< IfcAddressTypeEnum::IfcAddressTypeEnum > v1_Purpose, boost::optional< std::string > v2_Description, boost::optional< std::string > v3_UserDefinedPurpose, boost::optional< std::vector< std::string > /*[1:?]*/ > v4_TelephoneNumbers, boost::optional< std::vector< std::string > /*[1:?]*/ > v5_FacsimileNumbers, boost::optional< std::string > v6_PagerNumber, boost::optional< std::vector< std::string > /*[1:?]*/ > v7_ElectronicMailAddresses, boost::optional< std::string > v8_WWWHomePageURL);
    typedef IfcTemplatedEntityList< IfcTelecomAddress > list;
};
/// Definition from ISO/CD 10303-46:1992: The text style is a presentation style for annotation text.
/// 
/// The IfcTextStyle provides the text style table for presentation information assigned to text literals. The style is defined by color, text font characteristics, and text box characteristics. The definitions are based upon:
/// 
/// definitions from ISO/IS 10303-46:1994 for (old) vector based and monospace text.
///   definitions from Cascading Style Sheets, level 1, W3C Recommendation 17 Dec 1996, revised 11 Jan 1999, CSS1, for all true type text. The use of the CSS1 definitions is the preferred way to represent text styles.
/// 
/// An IfcTextStyle, when representing (old) vector based and monospace text, is instantiated with:
/// 
/// TextCharacterAppearance:: IfcTextStyleForDefinedFont (with BackgroundColour = NIL)
///   TextStyle:: IfcTextStyleWithBoxCharacteristics
///   TextFontStyle:: IfcDraughtingPreDefinedTextFont or IfcExternallyDefinedTextFont
/// 
/// An IfcTextStyle, when representing (new) true type text, based on CSS1 definitions, is instantiated with:
/// 
/// TextCharacterAppearance:: IfcTextStyleForDefinedFont
///   TextStyle:: IfcTextStyleTextModel
///   TextFontStyle:: IfcTextStyleFontModel
/// 
/// An IfcTextStyle can be assigned to IfcTextLiteral via the IfcPresentationStyleAssignment through an intermediate IfcAnnotationTextOccurrence.
/// 
/// NOTE  Corresponding ISO 10303 name: text_style. Please refer to ISO/IS 10303-46:1994 for the final definition of the formal standard. In order to avoid ANDOR subtype relationships, the IfcTextBlockStyleSelect has been introduced that allows the combination of a text style as having box characteristic, and/or having spacing, or having none of those additional properties.
/// 
/// NOTE  Corresponding CSS1 definitions are: Font properties (font-family, font-style, font-variant, font-weight, font-size), Color and background properties (color, background-color) and Text properties (word-spacing, letter-spacing, text-decoration, text-transform, text-align, text-indent, line-height).
/// 
/// HISTORY  New entity in IFC2x2.
/// 
/// IFC2x3 CHANGE  The IfcTextStyle has been changed by adding TextFontStyle and different data types for TextStyle and IfcCharacterStyleSelect.
class IfcTextStyle : public IfcPresentationStyle {
public:
    /// Whether the optional attribute TextCharacterAppearance is defined for this IfcTextStyle
    bool hasTextCharacterAppearance() const;
    /// A character style to be used for presented text.
    IfcCharacterStyleSelect* TextCharacterAppearance() const;
    void setTextCharacterAppearance(IfcCharacterStyleSelect* v);
    /// Whether the optional attribute TextStyle is defined for this IfcTextStyle
    bool hasTextStyle() const;
    /// The style applied to the text block for its visual appearance.
    /// It defines the text block characteristics, either for vector based or monospace text fonts (see select item IfcTextStyleWithBoxCharacteristics), or for true type text fonts (see select item IfcTextStyleTextModel.
    /// 
    /// IFC2x Edition 3 CHANGE  The attribute TextBlockStyle has been changed from SET[1:?] to a non-aggregated optional, it has been renamed from TextStyles.
    IfcTextStyleSelect* TextStyle() const;
    void setTextStyle(IfcTextStyleSelect* v);
    /// The style applied to the text font for its visual appearance.
    /// It defines the font family, font style, weight and size.
    /// 
    /// IFC2x Edition 2 Addendum 2 CHANGE The attribute TextFontStyle is a new attribute attached to IfcTextStyle.
    IfcTextFontSelect* TextFontStyle() const;
    void setTextFontStyle(IfcTextFontSelect* v);
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 1: return IfcUtil::Argument_ENTITY_INSTANCE; case 2: return IfcUtil::Argument_ENTITY_INSTANCE; case 3: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcPresentationStyle::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 1: return Type::IfcCharacterStyleSelect; case 2: return Type::IfcTextStyleSelect; case 3: return Type::IfcTextFontSelect; } return IfcPresentationStyle::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 1: return "TextCharacterAppearance"; case 2: return "TextStyle"; case 3: return "TextFontStyle"; } return IfcPresentationStyle::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcTextStyle (IfcAbstractEntity* e);
    IfcTextStyle (boost::optional< std::string > v1_Name, IfcCharacterStyleSelect* v2_TextCharacterAppearance, IfcTextStyleSelect* v3_TextStyle, IfcTextFontSelect* v4_TextFontStyle);
    typedef IfcTemplatedEntityList< IfcTextStyle > list;
};
/// Definition from CSS1 (W3C Recommendation): Setting font properties will be among the most common uses of style sheets. Unfortunately, there exists no well-defined and universally accepted taxonomy for classifying fonts, and terms that apply to one font family may not be appropriate for others. For example, 'italic' is commonly used to label slanted text, but slanted text may also be labeled as being Oblique, Slanted, Incline, Cursive or Kursiv. Therefore it is not a simple problem to map typical font selection properties to a specific font.
/// 
/// Font matching
/// Because there is no accepted, universal taxonomy of font properties, matching of properties to font faces must be done carefully. The properties are matched in a well-defined order to ensure that the results of this matching process are as consistent as possible across user agents (assuming that the same library of font faces is presented to each of them).
/// 
/// The user agent makes (or
/// accesses) a database of relevant CSS1
/// properties of all the fonts of which the UA is aware. The UA may be
/// aware of a font because it has been installed locally or it has been
/// previously downloaded over the web. If there are two fonts with
/// exactly the same properties, one of them is ignored. 
///   At a given element and for
/// each character in that element, the UA
/// assembles the font-properties applicable to that element. Using the
/// complete set of properties, the UA uses the 'font-family' property to
/// choose a tentative font family. The remaining properties are tested
/// against the family according to the matching criteria described with
/// each property. If there are matches for all the remaining properties,
/// then that is the matching font face for the given element. 
///   If there is no matching font
/// face within the 'font-family' being
/// processed by step 2, and if there is a next alternative 'font-family'
/// in the font set, then repeat step 2 with the next alternative
/// 'font-family'. 
///   If there is a matching font
/// face, but it doesn't contain a glyph
/// for the current character, and if there is a next alternative
/// 'font-family' in the font sets, then repeat step 2 with the next
/// alternative 'font-family'.  
///   If there is no font within
/// the family selected in 2, then use a
/// UA-dependent default 'font-family' and repeat step 2, using the best
/// match that can be obtained within the default font. 
/// 
/// (The above algorithm can be
/// optimized to avoid having to revisit
/// the CSS1 properties for each character.)
/// 
/// The per-property matching rules
/// from (2) above are as follows:
/// 
/// 'font-style' is tried first.
/// 'italic'
/// will be satisfied if there is either a face in the UA's font database
/// labeled with the CSS keyword 'italic' (preferred) or 'oblique'.
/// Otherwise the values must be matched exactly or font-style will fail. 
///   'font-variant' is tried
/// next. 'normal'
/// matches a font not labeled as 'small-caps'; 'small-caps' matches (1) a
/// font labeled as 'small-caps', (2) a font in which the small caps are
/// synthesized, or (3) a font where all lowercase letters are replaced by
/// upper case letters. A small-caps font may be synthesized by
/// electronically scaling uppercase letters from a normal font. 
///   'font-weight' is matched next, it will never fail. (See 'font-weight' below.) 
///   'font-size' must be matched within a
/// UA-dependent margin of tolerance. (Typically, sizes for scalable fonts
/// are rounded to the nearest whole pixel, while the tolerance for
/// bitmapped fonts could be as large as 20%.) Further computations, are
/// based on the 'font-size' value that is used, not the one that is specified.
/// 
/// The inherited Name attribute is used to define the font name, particularly in cases, where no (list of) font families are provided. 
/// 
/// NOTE  Corresponding CSS1 definitions are Font properties ('font-family', 'font-style', 'font-variant',  'font-weight').
/// 
/// HISTORY  New entity in IFC2x3.
class IfcTextStyleFontModel : public IfcPreDefinedTextFont {
public:
    /// Whether the optional attribute FontFamily is defined for this IfcTextStyleFontModel
    bool hasFontFamily() const;
    /// The value is a prioritized list of font family names and/or generic family names. The first list entry has the highest priority, if this font fails, the next list item shall be used. The last list item should (if possible) be a generic family.
    std::vector< std::string > /*[1:?]*/ FontFamily() const;
    void setFontFamily(std::vector< std::string > /*[1:?]*/ v);
    /// Whether the optional attribute FontStyle is defined for this IfcTextStyleFontModel
    bool hasFontStyle() const;
    /// The font style property selects between normal (sometimes referred to as "roman" or "upright"), italic and oblique faces within a font family.
    std::string FontStyle() const;
    void setFontStyle(std::string v);
    /// Whether the optional attribute FontVariant is defined for this IfcTextStyleFontModel
    bool hasFontVariant() const;
    /// The font variant property selects between normal and small-caps.
    ///   NOTE  It has been introduced for later compliance to full CSS1 support.
    std::string FontVariant() const;
    void setFontVariant(std::string v);
    /// Whether the optional attribute FontWeight is defined for this IfcTextStyleFontModel
    bool hasFontWeight() const;
    /// The font weight property selects the weight of the font.
    ///   NOTE  Values other then 'normal' and 'bold' have been introduced for later compliance to full CSS1 support.
    std::string FontWeight() const;
    void setFontWeight(std::string v);
    /// The font size provides the size or height of the text font.
    ///   NOTE  The following values are allowed, <IfcLengthMeasure, with positive values, the length unit is globally defined at IfcUnitAssignment.
    IfcSizeSelect* FontSize() const;
    void setFontSize(IfcSizeSelect* v);
    virtual unsigned int getArgumentCount() const { return 6; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 1: return IfcUtil::Argument_AGGREGATE_OF_STRING; case 2: return IfcUtil::Argument_STRING; case 3: return IfcUtil::Argument_STRING; case 4: return IfcUtil::Argument_STRING; case 5: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcPreDefinedTextFont::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 1: return Type::IfcTextFontName; case 2: return Type::IfcFontStyle; case 3: return Type::IfcFontVariant; case 4: return Type::IfcFontWeight; case 5: return Type::IfcSizeSelect; } return IfcPreDefinedTextFont::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 1: return "FontFamily"; case 2: return "FontStyle"; case 3: return "FontVariant"; case 4: return "FontWeight"; case 5: return "FontSize"; } return IfcPreDefinedTextFont::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcTextStyleFontModel (IfcAbstractEntity* e);
    IfcTextStyleFontModel (std::string v1_Name, boost::optional< std::vector< std::string > /*[1:?]*/ > v2_FontFamily, boost::optional< std::string > v3_FontStyle, boost::optional< std::string > v4_FontVariant, boost::optional< std::string > v5_FontWeight, IfcSizeSelect* v6_FontSize);
    typedef IfcTemplatedEntityList< IfcTextStyleFontModel > list;
};
/// Definition from ISO/CD 10303-46:1992: A text style for defined font is a character glyph style for pre-defined or externally defined text fonts.
/// 
/// Definition from CSS1 (W3C Recommendation): These properties describe the color (often called foreground color) and background of an element (i.e. the surface onto which the content is rendered). One can set a background color.
/// 
/// NOTE  The CSS1 definition allows also for a background image. This has not been incorporated into IFC.
/// 
/// The IfcTextStyleForDefinedFont combines the text font color with an optional background color, that fills the text box, defined by the planar extent given to the text literal.
/// 
/// NOTE  Corresponding ISO 10303 name: text_style_for_defined_font. Please refer to ISO/IS
/// 10303-46:1994, p.122 for the final definition of the formal standard. The attribute BackgroundColour
/// has been added.
/// 
/// NOTE  Corresponding CSS1 definitions are Color and background properties (color, background-color).
/// 
/// HISTORY  New entity in IFC2x3.
/// 
/// IFC2x3 CHANGE  The IfcTextStyleForDefinedFont has been added and replaces IfcColour at the IfcCharacterStyleSelect.
class IfcTextStyleForDefinedFont : public IfcUtil::IfcBaseEntity {
public:
    /// This property describes the text color of an element (often referred to as the foreground color).
    IfcColour* Colour() const;
    void setColour(IfcColour* v);
    /// Whether the optional attribute BackgroundColour is defined for this IfcTextStyleForDefinedFont
    bool hasBackgroundColour() const;
    /// This property sets the background color of an element.
    IfcColour* BackgroundColour() const;
    void setBackgroundColour(IfcColour* v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_ENTITY_INSTANCE; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcColour; case 1: return Type::IfcColour; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Colour"; case 1: return "BackgroundColour"; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcTextStyleForDefinedFont (IfcAbstractEntity* e);
    IfcTextStyleForDefinedFont (IfcColour* v1_Colour, IfcColour* v2_BackgroundColour);
    typedef IfcTemplatedEntityList< IfcTextStyleForDefinedFont > list;
};
/// Definition from CSS1 (W3C Recommendation): The properties defined in the text model affect the visual presentation of characters, spaces, words, and paragraphs.
/// 
/// The IfcTextStyleTextModel combines all text style properties, that affect the presentation of a text literal within a given extent. It includes the spacing between characters and words, the horizontal and vertical alignment of the text within the planar box of the extent, decorations (like underline), transformations of the literal (like uppercase), and the height of each text line within a multi-line text block.
/// 
/// NOTE  Corresponding CSS1 definitions are Text properties (word-spacing, letter-spacing, text-decoration, vertical-align, text-transform, text-align, text-indent, line-height).
/// 
/// HISTORY  New entity in IFC2x3.
class IfcTextStyleTextModel : public IfcUtil::IfcBaseEntity {
public:
    /// Whether the optional attribute TextIndent is defined for this IfcTextStyleTextModel
    bool hasTextIndent() const;
    /// The property specifies the indentation that appears before the first formatted line.
    ///   NOTE  It has been introduced for later compliance to full CSS1 support.
    IfcSizeSelect* TextIndent() const;
    void setTextIndent(IfcSizeSelect* v);
    /// Whether the optional attribute TextAlign is defined for this IfcTextStyleTextModel
    bool hasTextAlign() const;
    /// This property describes how text is aligned horizontally within the element. The actual justification algorithm used is dependent on the rendering algorithm.
    std::string TextAlign() const;
    void setTextAlign(std::string v);
    /// Whether the optional attribute TextDecoration is defined for this IfcTextStyleTextModel
    bool hasTextDecoration() const;
    /// This property describes decorations that are added to the text of an element.
    std::string TextDecoration() const;
    void setTextDecoration(std::string v);
    /// Whether the optional attribute LetterSpacing is defined for this IfcTextStyleTextModel
    bool hasLetterSpacing() const;
    /// The length unit indicates an addition to the default space between characters. Values can be negative, but there may be implementation-specific limits. The user agent is free to select the exact spacing algorithm. The letter spacing may also be influenced by justification (which is a value of the 'align' property).
    ///   NOTE  The following values are allowed, IfcDescriptiveMeasure with value='normal', or IfcLengthMeasure, the length unit is globally defined at IfcUnitAssignment.
    IfcSizeSelect* LetterSpacing() const;
    void setLetterSpacing(IfcSizeSelect* v);
    /// Whether the optional attribute WordSpacing is defined for this IfcTextStyleTextModel
    bool hasWordSpacing() const;
    /// The length unit indicates an addition to the default space between words. Values can be negative, but there may be implementation-specific limits. The user agent is free to select the exact spacing algorithm. The word spacing may also be influenced by justification (which is a value of the 'text-align' property).
    ///   NOTE  It has been introduced for later compliance to full CSS1 support.
    IfcSizeSelect* WordSpacing() const;
    void setWordSpacing(IfcSizeSelect* v);
    /// Whether the optional attribute TextTransform is defined for this IfcTextStyleTextModel
    bool hasTextTransform() const;
    /// This property describes how text characters may transform to upper case, lower case, or capitalized case, independent of the character case used in the text literal.
    ///   NOTE  It has been introduced for later compliance to full CSS1 support.
    std::string TextTransform() const;
    void setTextTransform(std::string v);
    /// Whether the optional attribute LineHeight is defined for this IfcTextStyleTextModel
    bool hasLineHeight() const;
    /// The property sets the distance between two adjacent lines' baselines.
    /// When a ratio value is specified, the line height is given by the font size of the current element multiplied with the numerical value. A value of 'normal' sets the line height to a reasonable value for the element's font. It is suggested that user agents set the 'normal' value to be a ratio number in the range of 1.0 to 1.2.
    ///   NOTE  The following values are allowed: IfcDescriptiveMeasure with value='normal', or 
    /// IfcLengthMeasure, with non-negative values, the length unit is globally defined at IfcUnitAssignment, or IfcRatioMeasure.
    IfcSizeSelect* LineHeight() const;
    void setLineHeight(IfcSizeSelect* v);
    virtual unsigned int getArgumentCount() const { return 7; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_STRING; case 2: return IfcUtil::Argument_STRING; case 3: return IfcUtil::Argument_ENTITY_INSTANCE; case 4: return IfcUtil::Argument_ENTITY_INSTANCE; case 5: return IfcUtil::Argument_STRING; case 6: return IfcUtil::Argument_ENTITY_INSTANCE; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcSizeSelect; case 1: return Type::IfcTextAlignment; case 2: return Type::IfcTextDecoration; case 3: return Type::IfcSizeSelect; case 4: return Type::IfcSizeSelect; case 5: return Type::IfcTextTransformation; case 6: return Type::IfcSizeSelect; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "TextIndent"; case 1: return "TextAlign"; case 2: return "TextDecoration"; case 3: return "LetterSpacing"; case 4: return "WordSpacing"; case 5: return "TextTransform"; case 6: return "LineHeight"; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcTextStyleTextModel (IfcAbstractEntity* e);
    IfcTextStyleTextModel (IfcSizeSelect* v1_TextIndent, boost::optional< std::string > v2_TextAlign, boost::optional< std::string > v3_TextDecoration, IfcSizeSelect* v4_LetterSpacing, IfcSizeSelect* v5_WordSpacing, boost::optional< std::string > v6_TextTransform, IfcSizeSelect* v7_LineHeight);
    typedef IfcTemplatedEntityList< IfcTextStyleTextModel > list;
};
/// The text style with box characteristics allows the presentation of annotated text by specifying the characteristics of the character boxes of the text and the spacing between the character boxes.
/// 
/// NOTE  The IfcTextStyleWithBoxCharacteristics is an entity that had been adopted from ISO 10303, Industrial automation systems and integration—Product data representation and exchange, Part 46: Integrated generic resources: Visual presentation.
/// 
/// The IfcTextStyleWithBoxCharacteristics is mainly used to provide some compatibility with ISO10303. Its usage is restricted to monospace text fonts (having uniform character boxes) and simple vector based text fonts. For true text fonts however the use of IfcTextStyleTextModel is required.
/// 
/// Figure 296 (from ISO 10303-46, page 91) illustrates angles.  Figure 297 illustrates attribute use.
/// 
/// Figure 296 — Text style box angles
///   Figure 297 — Text style box attributes
/// 
/// NOTE  Corresponding ISO 10303 name: text_style_with_box_characteristics. Please refer to ISO/IS 10303-46:1994, p. 123 for the final definition of the formal standard. The four optional attributes BoxHeight, BoxWidth, BoxSlantAngle, BoxRotateAngle are included directly at the entity, and are not handled through the box_characteristic_select selecting box_height, box_width, box_slant_angle, box_rotate_angle, each being defined types. 
/// The CharacterSpacing attribute has been added from ISO/IS 10303-46:1994 entity text_style_with_spacing.
/// 
/// HISTORY  New entity in IFC2x2.
/// 
/// IFC2x3 CHANGE  The attribute item CharacterSpacing has been added.
class IfcTextStyleWithBoxCharacteristics : public IfcUtil::IfcBaseEntity {
public:
    /// Whether the optional attribute BoxHeight is defined for this IfcTextStyleWithBoxCharacteristics
    bool hasBoxHeight() const;
    /// It is the height scaling factor in the definition of a character glyph.
    double BoxHeight() const;
    void setBoxHeight(double v);
    /// Whether the optional attribute BoxWidth is defined for this IfcTextStyleWithBoxCharacteristics
    bool hasBoxWidth() const;
    /// It is the width scaling factor in the definition of a character glyph.
    double BoxWidth() const;
    void setBoxWidth(double v);
    /// Whether the optional attribute BoxSlantAngle is defined for this IfcTextStyleWithBoxCharacteristics
    bool hasBoxSlantAngle() const;
    /// It indicated that the box of a character glyph shall be represented as a parallelogram, with the angle being between the character up line and an axis perpendicular to the character base line.
    double BoxSlantAngle() const;
    void setBoxSlantAngle(double v);
    /// Whether the optional attribute BoxRotateAngle is defined for this IfcTextStyleWithBoxCharacteristics
    bool hasBoxRotateAngle() const;
    /// It indicated that the box of a character glyph shall be presented at an angle to the base line of a text string within which the glyph occurs, the angle being that between the base line of the glyph and an axis perpendicular to the baseline of the text string.
    double BoxRotateAngle() const;
    void setBoxRotateAngle(double v);
    /// Whether the optional attribute CharacterSpacing is defined for this IfcTextStyleWithBoxCharacteristics
    bool hasCharacterSpacing() const;
    /// The distance between the character boxes of adjacent characters.
    IfcSizeSelect* CharacterSpacing() const;
    void setCharacterSpacing(IfcSizeSelect* v);
    virtual unsigned int getArgumentCount() const { return 5; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_DOUBLE; case 1: return IfcUtil::Argument_DOUBLE; case 2: return IfcUtil::Argument_DOUBLE; case 3: return IfcUtil::Argument_DOUBLE; case 4: return IfcUtil::Argument_ENTITY_INSTANCE; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcPositiveLengthMeasure; case 1: return Type::IfcPositiveLengthMeasure; case 2: return Type::IfcPlaneAngleMeasure; case 3: return Type::IfcPlaneAngleMeasure; case 4: return Type::IfcSizeSelect; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "BoxHeight"; case 1: return "BoxWidth"; case 2: return "BoxSlantAngle"; case 3: return "BoxRotateAngle"; case 4: return "CharacterSpacing"; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcTextStyleWithBoxCharacteristics (IfcAbstractEntity* e);
    IfcTextStyleWithBoxCharacteristics (boost::optional< double > v1_BoxHeight, boost::optional< double > v2_BoxWidth, boost::optional< double > v3_BoxSlantAngle, boost::optional< double > v4_BoxRotateAngle, IfcSizeSelect* v5_CharacterSpacing);
    typedef IfcTemplatedEntityList< IfcTextStyleWithBoxCharacteristics > list;
};
/// The IfcTextureCoordinate a an abstract supertype of the different kinds to apply texture coordinates to geometries. For vertex based geometries an explicit assignment of 2D texture vertices to the 3D geometry points is supported by the subtype IfcTextureMap, in addition there can be a procedural description of how texture coordinates shall be applied to geometric items. If no IfcTextureCoordinate is provided for the IfcSurfaceTexture, the default mapping shall be used.
/// 
/// See relevant subtypes of IfcGeometricRepresentationItem for default texture mapping description.
/// 
/// NOTE  The definitions of texturing within this standard have been developed in dependence on the texture component of X3D. See ISO/IEC 19775-1.2:2008 X3D Architecture and base components Edition 2, Part 1, 18 Texturing component for the definitions in the international standard.
/// 
/// HISTORY  New entity in IFC2x2.
/// 
/// IFC2x3 CHANGE  The attribute Texture is deleted.
/// 
/// IFC2x4 CHANGE  The inverse attribute AnnotatedSurface is deleted, and the inverse AppliesTextures is added.
class IfcTextureCoordinate : public IfcUtil::IfcBaseEntity {
public:
    virtual unsigned int getArgumentCount() const { return 0; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcAnnotationSurface >::ptr AnnotatedSurface() const; // INVERSE IfcAnnotationSurface::TextureCoordinates
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcTextureCoordinate (IfcAbstractEntity* e);
    IfcTextureCoordinate ();
    typedef IfcTemplatedEntityList< IfcTextureCoordinate > list;
};
/// The IfcTextureCoordinateGenerator describes a procedurally defined mapping function with input parameter to map 2D texture coordinates to 3D geometry vertices. The allowable Mode values and input Parameter need to be agreed upon in view definitions and implementer agreements.
/// 
/// It is recommended to use the texture coordinate generation modes as defined in X3D.
/// 
/// The following definitions from ISO/IEC 19775-1 X3D Architecture and base components (X3D Specification) apply:
/// 
/// The TextureCoordinateGenerator supports the automatic generation of texture coordinates for geometric shapes.
/// The mode field describes the algorithm used to compute texture coordinates.
/// 
/// SPHERE,
/// CAMERASPACENORMAL,
/// CAMERASPACEPOSITION,
/// CAMERASPACEREFLECTIONVECTOR,
/// SPHERE-LOCAL,
/// COORD,
/// COORD-EYE,
/// NOISE,
/// NOISE-EYE,
/// SPHERE-REFLECT,
/// SPHERE-REFLECT-LOCAL
/// 
/// NOTE  The definitions of texturing within this standard have been developed in dependence on the texture component of X3D. See ISO/IEC 19775-1.2:2008 X3D Architecture and base components Edition 2, Part 1, 18 Texturing component for the definitions in the international standard.
/// 
/// HISTORY New entity in IFC2x2.
/// 
/// IFC2x2 Addendum 2 CHANGE  The attribute Texturehas been deleted.
class IfcTextureCoordinateGenerator : public IfcTextureCoordinate {
public:
    /// The Mode attribute describes the algorithm used to compute texture coordinates.
    /// 
    /// NOTE  The applicable values for the Mode attribute are determined by view definitions or implementer agreements. It is recommended to use the modes described in ISO/IES 19775-1.2:2008 X3D Architecture and base components Edition 2, Part 1. See 18.4.8 TextureCoordinateGenerator for recommended values.
    std::string Mode() const;
    void setMode(std::string v);
    /// The parameters used as arguments by the function as specified by Mode.
    /// 
    /// IFC2x4 CHANGE  Made optional data type restricted to REAL.
    IfcEntityList::ptr Parameter() const;
    void setParameter(IfcEntityList::ptr v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_STRING; case 1: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } return IfcTextureCoordinate::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcLabel; case 1: return Type::IfcSimpleValue; } return IfcTextureCoordinate::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Mode"; case 1: return "Parameter"; } return IfcTextureCoordinate::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcTextureCoordinateGenerator (IfcAbstractEntity* e);
    IfcTextureCoordinateGenerator (std::string v1_Mode, IfcEntityList::ptr v2_Parameter);
    typedef IfcTemplatedEntityList< IfcTextureCoordinateGenerator > list;
};
/// An IfcTextureMap provides the mapping of the
/// 2-dimensional texture coordinates to the surface onto which it is
/// mapped. It is used for mapping the texture to surfaces of vertex
/// based geometry models, such as
/// 
/// IfcFacetedBrep
/// IfcFacetedBrepWithVoids
/// IfcFaceBasedSurfaceModel
/// IfcShellBasedSurfaceModel
/// 
/// The IfcTextureMap has a list of TextureVertex,
/// that corresponds to the points of the face bound of the vertex
/// based geometry item. The corresponding pair of lists is:
/// 
/// the list of Polygon of type IfcCartesianPoint,
/// and
/// the list of Vertices of type
/// IfcTextureVertex.
/// 
/// Each IfcTextureVertex (given as S, T coordinates of the
/// 2-dimension texture coordinate system) corresponds to the geometric
/// coordinates of the IfcCartesianPoint (given as 3-dimension
/// X, Y, and Z coordinates within the object coordinate system of the
/// geometric item).
/// The following definitions from ISO/IEC 19775-1 X3D Architecture
/// and base components (X3D Specification)
/// apply:
/// 
/// The TextureCoordinate node is a geometry property node that
/// specifies a set of 2D texture coordinates used by vertex-based
/// geometry nodes to map textures to vertices.
/// 
/// NOTE  In contrary to the
/// X3D vertext based geometry, for example IndexedFaceSet and
/// ElevationGrid, the vertext based geometry in IFC may include inner
/// loops. The areas of inner loops have to be cut-out from the texture
/// applied to the outer loop.
/// 
/// Figure 301 illustrates applying a texture map to a vertex based geometry.
/// 
/// Figure 301 — Texture map
/// 
/// HISTORY  New entity in IFC2x2.
/// 
/// IFC2x3 CHANGE  The attribute Texture is deleted, and the attribute TextureMaps is added.
/// 
/// IFC2x4 CHANGE  The attribute TextureMap is replaced by Vertices, and the attribute AppliedTo is added.
/// 
/// Informal propositions:
/// 
/// The FaceBound referenced in AppliedTo shall be used by the vertex based geometry, to which this texture map is assigned to by through the IfcStyledItem.
class IfcTextureMap : public IfcTextureCoordinate {
public:
    IfcTemplatedEntityList< IfcVertexBasedTextureMap >::ptr TextureMaps() const;
    void setTextureMaps(IfcTemplatedEntityList< IfcVertexBasedTextureMap >::ptr v);
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } return IfcTextureCoordinate::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcVertexBasedTextureMap; } return IfcTextureCoordinate::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "TextureMaps"; } return IfcTextureCoordinate::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcTextureMap (IfcAbstractEntity* e);
    IfcTextureMap (IfcTemplatedEntityList< IfcVertexBasedTextureMap >::ptr v1_TextureMaps);
    typedef IfcTemplatedEntityList< IfcTextureMap > list;
};
/// An IfcTextureVertex is a list of 2 (S, T) texture coordinates. 
/// 
/// The following additional definitions from ISO 19775 apply:
/// 
/// Each vertex-based geometry node uses a set of 2D texture
/// coordinates that map textures to vertices. Texture map values (
/// ImageTexture, PixelTexture) range from [0.0, 1.0] along the S-axis and
/// T-axis. However, texture coordinate values may be in the range
/// (-∞,∞). Texture coordinates identify a location
/// (and thus a
/// colour value) in the texture map. The horizontal coordinate S is
/// specified first, followed by the vertical coordinate T. If the texture
/// map is repeated in a given direction (S-axis or T-axis), a texture
/// coordinate C (s or t) is mapped into a texture map that has N pixels in
/// the given direction as follows: 
/// 
/// Texture map location = (C - floor(C)) × N			 
/// 
/// If the texture map is not
/// repeated, the texture coordinates are
/// clamped to the 0.0 to 1.0 range as follows: 
/// 
/// Texture map location = N,     if C > 1.0,                     = 0.0,   if C < 0.0,                     = C × N, if 0.0 ≤ C ≤ 1.0.
/// 
/// Texture coordinates may be transformed (scaled, rotated, translated) by supplying a TextureTransform as a component of the texture's definition. 
/// 
/// HISTORY: New entity in IFC 2x2.
class IfcTextureVertex : public IfcUtil::IfcBaseEntity {
public:
    /// The first coordinate[1] is the S, the second coordinate[2] is the T parameter value.
    std::vector< double > /*[2:2]*/ Coordinates() const;
    void setCoordinates(std::vector< double > /*[2:2]*/ v);
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_AGGREGATE_OF_DOUBLE; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcParameterValue; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Coordinates"; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcTextureVertex (IfcAbstractEntity* e);
    IfcTextureVertex (std::vector< double > /*[2:2]*/ v1_Coordinates);
    typedef IfcTemplatedEntityList< IfcTextureVertex > list;
};

class IfcThermalMaterialProperties : public IfcMaterialProperties {
public:
    /// Whether the optional attribute SpecificHeatCapacity is defined for this IfcThermalMaterialProperties
    bool hasSpecificHeatCapacity() const;
    double SpecificHeatCapacity() const;
    void setSpecificHeatCapacity(double v);
    /// Whether the optional attribute BoilingPoint is defined for this IfcThermalMaterialProperties
    bool hasBoilingPoint() const;
    double BoilingPoint() const;
    void setBoilingPoint(double v);
    /// Whether the optional attribute FreezingPoint is defined for this IfcThermalMaterialProperties
    bool hasFreezingPoint() const;
    double FreezingPoint() const;
    void setFreezingPoint(double v);
    /// Whether the optional attribute ThermalConductivity is defined for this IfcThermalMaterialProperties
    bool hasThermalConductivity() const;
    double ThermalConductivity() const;
    void setThermalConductivity(double v);
    virtual unsigned int getArgumentCount() const { return 5; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 1: return IfcUtil::Argument_DOUBLE; case 2: return IfcUtil::Argument_DOUBLE; case 3: return IfcUtil::Argument_DOUBLE; case 4: return IfcUtil::Argument_DOUBLE; } return IfcMaterialProperties::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 1: return Type::IfcSpecificHeatCapacityMeasure; case 2: return Type::IfcThermodynamicTemperatureMeasure; case 3: return Type::IfcThermodynamicTemperatureMeasure; case 4: return Type::IfcThermalConductivityMeasure; } return IfcMaterialProperties::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 1: return "SpecificHeatCapacity"; case 2: return "BoilingPoint"; case 3: return "FreezingPoint"; case 4: return "ThermalConductivity"; } return IfcMaterialProperties::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcThermalMaterialProperties (IfcAbstractEntity* e);
    IfcThermalMaterialProperties (IfcMaterial* v1_Material, boost::optional< double > v2_SpecificHeatCapacity, boost::optional< double > v3_BoilingPoint, boost::optional< double > v4_FreezingPoint, boost::optional< double > v5_ThermalConductivity);
    typedef IfcTemplatedEntityList< IfcThermalMaterialProperties > list;
};
/// A time series is a set of a time-stamped data entries. It allows a natural association of data collected over intervals of time. Time series can be regular or irregular. In regular time series data arrive predictably at predefined intervals.  In irregular time series  some or all time stamps do not follow a repetitive pattern and unpredictable bursts of data may arrive at unspecified points in time.
/// 
/// The modeling of buildings and their performance involves data that are generated and recorded over a period of time.  Such data cover a large spectrum, from weather data to schedules of all kinds to status measurements to reporting to everything else that has a time related aspect. Their correct placement in time is essential for their proper understanding and use, and the IfcTimeSeries subtypes provide the appropriate data structures to accommodate these types of data.
/// 
/// HISTORY: New entity in IFC 2x2.
class IfcTimeSeries : public IfcUtil::IfcBaseEntity {
public:
    /// An unique name for the time series.
    std::string Name() const;
    void setName(std::string v);
    /// Whether the optional attribute Description is defined for this IfcTimeSeries
    bool hasDescription() const;
    /// A text description of the data that the series represents.
    std::string Description() const;
    void setDescription(std::string v);
    /// The start time of a time series.
    IfcDateTimeSelect* StartTime() const;
    void setStartTime(IfcDateTimeSelect* v);
    /// The end time of a time series.
    IfcDateTimeSelect* EndTime() const;
    void setEndTime(IfcDateTimeSelect* v);
    /// The time series data type.
    IfcTimeSeriesDataTypeEnum::IfcTimeSeriesDataTypeEnum TimeSeriesDataType() const;
    void setTimeSeriesDataType(IfcTimeSeriesDataTypeEnum::IfcTimeSeriesDataTypeEnum v);
    /// The orgin of a time series data.
    IfcDataOriginEnum::IfcDataOriginEnum DataOrigin() const;
    void setDataOrigin(IfcDataOriginEnum::IfcDataOriginEnum v);
    /// Whether the optional attribute UserDefinedDataOrigin is defined for this IfcTimeSeries
    bool hasUserDefinedDataOrigin() const;
    /// Value of the data origin if DataOrigin attribute is USERDEFINED.
    std::string UserDefinedDataOrigin() const;
    void setUserDefinedDataOrigin(std::string v);
    /// Whether the optional attribute Unit is defined for this IfcTimeSeries
    bool hasUnit() const;
    /// The unit to be assigned to all values within the time series. Note that mixing units is not allowed. If the value is not given, the global unit for the type of IfcValue, as defined at IfcProject.UnitsInContext is used.
    IfcUnit* Unit() const;
    void setUnit(IfcUnit* v);
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_STRING; case 1: return IfcUtil::Argument_STRING; case 2: return IfcUtil::Argument_ENTITY_INSTANCE; case 3: return IfcUtil::Argument_ENTITY_INSTANCE; case 4: return IfcUtil::Argument_ENUMERATION; case 5: return IfcUtil::Argument_ENUMERATION; case 6: return IfcUtil::Argument_STRING; case 7: return IfcUtil::Argument_ENTITY_INSTANCE; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcLabel; case 1: return Type::IfcText; case 2: return Type::IfcDateTimeSelect; case 3: return Type::IfcDateTimeSelect; case 4: return Type::IfcTimeSeriesDataTypeEnum; case 5: return Type::IfcDataOriginEnum; case 6: return Type::IfcLabel; case 7: return Type::IfcUnit; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Name"; case 1: return "Description"; case 2: return "StartTime"; case 3: return "EndTime"; case 4: return "TimeSeriesDataType"; case 5: return "DataOrigin"; case 6: return "UserDefinedDataOrigin"; case 7: return "Unit"; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcTimeSeriesReferenceRelationship >::ptr DocumentedBy() const; // INVERSE IfcTimeSeriesReferenceRelationship::ReferencedTimeSeries
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcTimeSeries (IfcAbstractEntity* e);
    IfcTimeSeries (std::string v1_Name, boost::optional< std::string > v2_Description, IfcDateTimeSelect* v3_StartTime, IfcDateTimeSelect* v4_EndTime, IfcTimeSeriesDataTypeEnum::IfcTimeSeriesDataTypeEnum v5_TimeSeriesDataType, IfcDataOriginEnum::IfcDataOriginEnum v6_DataOrigin, boost::optional< std::string > v7_UserDefinedDataOrigin, IfcUnit* v8_Unit);
    typedef IfcTemplatedEntityList< IfcTimeSeries > list;
};

class IfcTimeSeriesReferenceRelationship : public IfcUtil::IfcBaseEntity {
public:
    IfcTimeSeries* ReferencedTimeSeries() const;
    void setReferencedTimeSeries(IfcTimeSeries* v);
    IfcEntityList::ptr TimeSeriesReferences() const;
    void setTimeSeriesReferences(IfcEntityList::ptr v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcTimeSeries; case 1: return Type::IfcDocumentSelect; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "ReferencedTimeSeries"; case 1: return "TimeSeriesReferences"; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcTimeSeriesReferenceRelationship (IfcAbstractEntity* e);
    IfcTimeSeriesReferenceRelationship (IfcTimeSeries* v1_ReferencedTimeSeries, IfcEntityList::ptr v2_TimeSeriesReferences);
    typedef IfcTemplatedEntityList< IfcTimeSeriesReferenceRelationship > list;
};
/// A time series value is a list of values that comprise the time series. At least one value must be supplied. Applications are expected to normalize values by applying the following three rules:
/// 
/// All time (universal, local, daylight savings, and solar) is normalized against the ISO 8601 standard GMT/UTC (Universal Coordinated Time).
/// Any rollover is handled by the application providing the data.  Rollover occurs, for example, when the measurement device resets itself while measuring and the recording data do not include the data measured before the reset.
/// The normalized data refer to the preceding time unit.  The time series example shown in Figure 241 below contains four time points: Time "a" indicates the beginning of the time series and the associated datum has no relevance.  Data at time points "b," "c" and "d" are associated with values 1, 2 and 3, respectively.
/// 
/// Figure 241 — Time series value 
/// 
/// HISTORY  New entity in IFC2x2.
class IfcTimeSeriesValue : public IfcUtil::IfcBaseEntity {
public:
    /// A list of time-series values. At least one value is required.
    IfcEntityList::ptr ListValues() const;
    void setListValues(IfcEntityList::ptr v);
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcValue; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "ListValues"; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcTimeSeriesValue (IfcAbstractEntity* e);
    IfcTimeSeriesValue (IfcEntityList::ptr v1_ListValues);
    typedef IfcTemplatedEntityList< IfcTimeSeriesValue > list;
};
/// Definition from ISO/CD 10303-42:1992: The topological representation item is the supertype for all the topological representation items in the geometry resource. 
/// 
/// NOTE  Corresponding ISO 10303 entity: topological_representation_item. Please refer to ISO/IS 10303-42:1994, p.129 for the final definition of the formal standard.
/// 
/// HISTORY: New entity in IFC Release 1.5
class IfcTopologicalRepresentationItem : public IfcRepresentationItem {
public:
    virtual unsigned int getArgumentCount() const { return 0; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcRepresentationItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcRepresentationItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcRepresentationItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcTopologicalRepresentationItem (IfcAbstractEntity* e);
    IfcTopologicalRepresentationItem ();
    typedef IfcTemplatedEntityList< IfcTopologicalRepresentationItem > list;
};
/// IfcTopologyRepresentation
/// represents the concept of a particular topological representation of a
/// product or a product component within a representation context. This
/// representation context does not need to be (but may be) a geometric
/// representation context. Several representation types for shape
/// representation are included as predefined types: 
/// 
/// Vertex
///   topological vertex
/// representation (with or without assigned geometry)
/// 
/// Edge
///   topological edge
/// representation (with or without assigned geometry)
/// 
/// Path
///   topological path
/// representation (with or without assigned geometry)
/// 
/// Face
///   topological face
/// representation (with or without assigned geometry)
/// 
/// Shell
///   topological shell
/// representation (with or without assigned geometry)
/// 
/// Undefined
///   no constraints imposed
/// 
/// The representation type is
/// given as a string value at the inherited attribute 'RepresentationType'.
/// 
/// HISTORY: New entity in IFC 2x2.
class IfcTopologyRepresentation : public IfcShapeModel {
public:
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcShapeModel::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcShapeModel::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcShapeModel::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcTopologyRepresentation (IfcAbstractEntity* e);
    IfcTopologyRepresentation (IfcRepresentationContext* v1_ContextOfItems, boost::optional< std::string > v2_RepresentationIdentifier, boost::optional< std::string > v3_RepresentationType, IfcTemplatedEntityList< IfcRepresentationItem >::ptr v4_Items);
    typedef IfcTemplatedEntityList< IfcTopologyRepresentation > list;
};
/// IfcUnitAssignment indicates a set of units which may be assigned. Within an IfcUnitAssigment each unit definition shall be unique; that is, there shall be no redundant unit definitions for the same unit type such as length unit or area unit. For currencies, there shall be only a single IfcMonetaryUnit within an IfcUnitAssignment.
/// 
/// NOTE  A project (IfcProject) has a unit assignment which establishes a set of units which will be used globally within the project, if not otherwise defined. Other objects may have local unit assignments if there is a requirement for them to make use of units which do not fall within the project unit assignment.
/// 
/// HISTORY  New entity in IFC Release 1.5.1.
class IfcUnitAssignment : public IfcUtil::IfcBaseEntity {
public:
    /// Units to be included within a unit assignment.
    IfcEntityList::ptr Units() const;
    void setUnits(IfcEntityList::ptr v);
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcUnit; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Units"; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcUnitAssignment (IfcAbstractEntity* e);
    IfcUnitAssignment (IfcEntityList::ptr v1_Units);
    typedef IfcTemplatedEntityList< IfcUnitAssignment > list;
};
/// Definition from ISO/CD 10303-42:1992: A vertex is the topological construct corresponding to a point. It has dimensionality 0 and extent 0. The domain of a vertex, if present, is a point in m dimensional real space RM; this is represented by the vertex point subtype. 
/// 
/// NOTE  Corresponding ISO 10303 entity: vertex. Please refer to ISO/IS 10303-42:1994, p. 129 for the final definition of the formal standard.
/// 
/// HISTORY  New Entity in IFC Release 2.0
/// 
/// Informal proposition:
/// 
/// The vertex has dimensionality 0. This is a fundamental property of the vertex.
/// The extent of a vertex is defined to be zero.
class IfcVertex : public IfcTopologicalRepresentationItem {
public:
    virtual unsigned int getArgumentCount() const { return 0; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcTopologicalRepresentationItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcTopologicalRepresentationItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcTopologicalRepresentationItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcVertex (IfcAbstractEntity* e);
    IfcVertex ();
    typedef IfcTemplatedEntityList< IfcVertex > list;
};

class IfcVertexBasedTextureMap : public IfcUtil::IfcBaseEntity {
public:
    IfcTemplatedEntityList< IfcTextureVertex >::ptr TextureVertices() const;
    void setTextureVertices(IfcTemplatedEntityList< IfcTextureVertex >::ptr v);
    IfcTemplatedEntityList< IfcCartesianPoint >::ptr TexturePoints() const;
    void setTexturePoints(IfcTemplatedEntityList< IfcCartesianPoint >::ptr v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcTextureVertex; case 1: return Type::IfcCartesianPoint; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "TextureVertices"; case 1: return "TexturePoints"; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcVertexBasedTextureMap (IfcAbstractEntity* e);
    IfcVertexBasedTextureMap (IfcTemplatedEntityList< IfcTextureVertex >::ptr v1_TextureVertices, IfcTemplatedEntityList< IfcCartesianPoint >::ptr v2_TexturePoints);
    typedef IfcTemplatedEntityList< IfcVertexBasedTextureMap > list;
};
/// Definition from ISO/CD 10303-42:1992: A vertex point is a vertex which has its geometry defined as a point.  
/// 
/// NOTE  Corresponding ISO 10303 entity: vertex_point. Please refer to ISO/IS 10303-42:1994, p. 130 for the final definition of the formal standard. Due to the general IFC model specification rule not to use multiple inheritance, the subtype relationship to geometric_representation_item is not included.
/// 
/// HISTORY  New Entity in IFC2x.
/// 
/// Informal proposition: 
/// 
/// The domain of the vertex is formally defined to be the domain of its vertex point.
class IfcVertexPoint : public IfcVertex {
public:
    /// The geometric point, which defines the position in geometric space of the vertex.
    IfcPoint* VertexGeometry() const;
    void setVertexGeometry(IfcPoint* v);
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcVertex::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcPoint; } return IfcVertex::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "VertexGeometry"; } return IfcVertex::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcVertexPoint (IfcAbstractEntity* e);
    IfcVertexPoint (IfcPoint* v1_VertexGeometry);
    typedef IfcTemplatedEntityList< IfcVertexPoint > list;
};
/// IfcVirtualGridIntersection defines the derived location of the intersection between two grid axes. Offset values may be given to set an offset distance to the grid axis for the calculation of the virtual grid intersection.
/// 
/// The two intersecting axes (IntersectingAxes) define the intersection point, which exact location (in terms of the Cartesian point representing the intersection) has to be calculated from the geometric representation of the two participating curves.
/// 
/// NOTE The IfcGrid local placement, that can be provided relative to the local placement of another spatial structure element, has to be taken into account for calculating the absolute placement of the IfcVirtualGridIntersection. Where rules and informal rules ensure, that the IntersectingAxes belong to the same IfcGrid
/// 
/// Offset values may be given (OffsetDistances). If given, the position within the list of OffsetDistances
/// corresponds with the position within the list of IntersectingAxes. Therefore:
/// 
/// OffsetDistances[1] sets the offset to IntersectingAxes[1],
/// OffsetDistances[2] sets the offset to IntersectingAxes[2], and
/// OffsetDistances[3] sets the offset to the virtual intersection in direction of the orientation of the cross product
/// of IntersectingAxes[1] and the orthogonal complement of the IntersectingAxes[1] (which is the positive or negative
/// direction of the z axis of the design grid position).
/// 
/// HISTORY  New entity in IFC Release 1.5. The entity name was changed from IfcConstraintRelIntersection in IFC Release 2x.
/// 
/// Informal Propositions:
/// 
/// Both, IntersectingAxes[1] and
/// IntersectingAxes[2] shall be two IfcGridAxis
/// defined by the same IfcGrid.
/// IntersectingAxes[1] and IntersectingAxes[2]
/// shall not be part of the same row of grid axes, i.e. both shall
/// not be within the same set of IfcGrid.UAxes or
/// IfcGrid.VAxes of the corresponding IfcGrid.
/// 
/// Geometry use definitions:
/// The following figures explain the usage of the OffsetDistances and IntersectingAxes attributes.
/// 
/// Figure 246 illustrates two offset distances given where the virtual intersection is defined in the xy plane of the grid axis placement.
/// 
/// Figure 246 — Virtual grid intersection with two offsets
/// 
/// Figure 247 illustrates three offset distances given where the virtual intersection is defined by an offset (in direction of the
/// z-axis of the design grid placement) to the virtual intersection in the xy plane of the grid axis placement.
/// 
/// Figure 247 — Virtual grid intersection with three offsets
/// 
/// The distance of the offset curve (OffsetDistances[n])
/// is measured from the basis curve. The distance may be positive,
/// negative or zero. A positive value of distance defines an offset
/// in the direction which is normal to the curve in the sense of an
/// anti-clockwise rotation through 90 degrees from the tangent
/// vector T at the given point. (This is in the direction of
/// orthogonal complement(T).) This can be reverted by the
/// SameSense attribute at IfcGridAxis which may switch
/// the sense of the AxisCurve.
/// Illustration
/// 
/// Figure 248 illustrates an example of a negative offset where the figure shows the side of the offset.
/// 
/// IntersectingAxes[1].AxisCurve is an
/// IfcTrimmedCurve with an IfcCircle as
/// BasisCurve and SenseAgreement = TRUE.
/// IntersectingAxes[1].SameSense = TRUE.
/// OffsetDistances[1] is a negative length measure
/// 
/// Figure 248 — Virtual grid intersection negative offset
class IfcVirtualGridIntersection : public IfcUtil::IfcBaseEntity {
public:
    /// Two grid axes which intersects at exactly one intersection (see also informal proposition at IfcGrid). If attribute OffsetDistances is omitted, the intersection defines the placement or ref direction of a grid placement directly. If OffsetDistances are given, the intersection is defined by the offset curves to the grid axes.
    IfcTemplatedEntityList< IfcGridAxis >::ptr IntersectingAxes() const;
    void setIntersectingAxes(IfcTemplatedEntityList< IfcGridAxis >::ptr v);
    /// Offset distances to the grid axes. If given, it defines virtual offset curves to the grid axes. The intersection of the offset curves specify the virtual grid intersection.
    std::vector< double > /*[2:3]*/ OffsetDistances() const;
    void setOffsetDistances(std::vector< double > /*[2:3]*/ v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_AGGREGATE_OF_DOUBLE; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcGridAxis; case 1: return Type::IfcLengthMeasure; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "IntersectingAxes"; case 1: return "OffsetDistances"; } throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcVirtualGridIntersection (IfcAbstractEntity* e);
    IfcVirtualGridIntersection (IfcTemplatedEntityList< IfcGridAxis >::ptr v1_IntersectingAxes, std::vector< double > /*[2:3]*/ v2_OffsetDistances);
    typedef IfcTemplatedEntityList< IfcVirtualGridIntersection > list;
};

class IfcWaterProperties : public IfcMaterialProperties {
public:
    /// Whether the optional attribute IsPotable is defined for this IfcWaterProperties
    bool hasIsPotable() const;
    bool IsPotable() const;
    void setIsPotable(bool v);
    /// Whether the optional attribute Hardness is defined for this IfcWaterProperties
    bool hasHardness() const;
    double Hardness() const;
    void setHardness(double v);
    /// Whether the optional attribute AlkalinityConcentration is defined for this IfcWaterProperties
    bool hasAlkalinityConcentration() const;
    double AlkalinityConcentration() const;
    void setAlkalinityConcentration(double v);
    /// Whether the optional attribute AcidityConcentration is defined for this IfcWaterProperties
    bool hasAcidityConcentration() const;
    double AcidityConcentration() const;
    void setAcidityConcentration(double v);
    /// Whether the optional attribute ImpuritiesContent is defined for this IfcWaterProperties
    bool hasImpuritiesContent() const;
    double ImpuritiesContent() const;
    void setImpuritiesContent(double v);
    /// Whether the optional attribute PHLevel is defined for this IfcWaterProperties
    bool hasPHLevel() const;
    double PHLevel() const;
    void setPHLevel(double v);
    /// Whether the optional attribute DissolvedSolidsContent is defined for this IfcWaterProperties
    bool hasDissolvedSolidsContent() const;
    double DissolvedSolidsContent() const;
    void setDissolvedSolidsContent(double v);
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 1: return IfcUtil::Argument_BOOL; case 2: return IfcUtil::Argument_DOUBLE; case 3: return IfcUtil::Argument_DOUBLE; case 4: return IfcUtil::Argument_DOUBLE; case 5: return IfcUtil::Argument_DOUBLE; case 6: return IfcUtil::Argument_DOUBLE; case 7: return IfcUtil::Argument_DOUBLE; } return IfcMaterialProperties::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 1: return Type::UNDEFINED; case 2: return Type::IfcIonConcentrationMeasure; case 3: return Type::IfcIonConcentrationMeasure; case 4: return Type::IfcIonConcentrationMeasure; case 5: return Type::IfcNormalisedRatioMeasure; case 6: return Type::IfcPHMeasure; case 7: return Type::IfcNormalisedRatioMeasure; } return IfcMaterialProperties::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 1: return "IsPotable"; case 2: return "Hardness"; case 3: return "AlkalinityConcentration"; case 4: return "AcidityConcentration"; case 5: return "ImpuritiesContent"; case 6: return "PHLevel"; case 7: return "DissolvedSolidsContent"; } return IfcMaterialProperties::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcWaterProperties (IfcAbstractEntity* e);
    IfcWaterProperties (IfcMaterial* v1_Material, boost::optional< bool > v2_IsPotable, boost::optional< double > v3_Hardness, boost::optional< double > v4_AlkalinityConcentration, boost::optional< double > v5_AcidityConcentration, boost::optional< double > v6_ImpuritiesContent, boost::optional< double > v7_PHLevel, boost::optional< double > v8_DissolvedSolidsContent);
    typedef IfcTemplatedEntityList< IfcWaterProperties > list;
};

class IfcAnnotationOccurrence : public IfcStyledItem {
public:
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcStyledItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcStyledItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcStyledItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcAnnotationOccurrence (IfcAbstractEntity* e);
    IfcAnnotationOccurrence (IfcRepresentationItem* v1_Item, IfcTemplatedEntityList< IfcPresentationStyleAssignment >::ptr v2_Styles, boost::optional< std::string > v3_Name);
    typedef IfcTemplatedEntityList< IfcAnnotationOccurrence > list;
};

class IfcAnnotationSurfaceOccurrence : public IfcAnnotationOccurrence {
public:
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcAnnotationOccurrence::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcAnnotationOccurrence::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcAnnotationOccurrence::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcAnnotationSurfaceOccurrence (IfcAbstractEntity* e);
    IfcAnnotationSurfaceOccurrence (IfcRepresentationItem* v1_Item, IfcTemplatedEntityList< IfcPresentationStyleAssignment >::ptr v2_Styles, boost::optional< std::string > v3_Name);
    typedef IfcTemplatedEntityList< IfcAnnotationSurfaceOccurrence > list;
};

class IfcAnnotationSymbolOccurrence : public IfcAnnotationOccurrence {
public:
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcAnnotationOccurrence::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcAnnotationOccurrence::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcAnnotationOccurrence::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcAnnotationSymbolOccurrence (IfcAbstractEntity* e);
    IfcAnnotationSymbolOccurrence (IfcRepresentationItem* v1_Item, IfcTemplatedEntityList< IfcPresentationStyleAssignment >::ptr v2_Styles, boost::optional< std::string > v3_Name);
    typedef IfcTemplatedEntityList< IfcAnnotationSymbolOccurrence > list;
};

class IfcAnnotationTextOccurrence : public IfcAnnotationOccurrence {
public:
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcAnnotationOccurrence::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcAnnotationOccurrence::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcAnnotationOccurrence::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcAnnotationTextOccurrence (IfcAbstractEntity* e);
    IfcAnnotationTextOccurrence (IfcRepresentationItem* v1_Item, IfcTemplatedEntityList< IfcPresentationStyleAssignment >::ptr v2_Styles, boost::optional< std::string > v3_Name);
    typedef IfcTemplatedEntityList< IfcAnnotationTextOccurrence > list;
};
/// The closed profile IfcArbitraryClosedProfileDef defines an arbitrary two-dimensional profile for the use within the swept surface geometry, the swept area solid or a sectioned spine. It is given by an outer boundary from which the surface or solid can be constructed. 
/// 
/// HISTORY: New entity in IFC 1.5. Entity has been renamed from IfcArbitraryProfileDef in IFC Release 2x.
/// 
/// Informal proposition: 
/// 
/// The OuterCurve has to be a closed curve.
///   The OuterCurve shall not intersect.
/// 
/// Figure 307 illustrates the arbitrary closed profile definition. The OuterCurve is defined in the underlying coordinate system. The underlying coordinate system is defined by the swept surface or swept area solid that uses the profile definition. It is the xy plane of either:
/// 
/// IfcSweptSurface.Position
///   IfcSweptAreaSolid.Position
/// 
/// or in case of sectioned spines the xy plane of each list member of IfcSectionedSpine.CrossSectionPositions. The OuterCurve
/// attribute defines a two dimensional closed bounded curve.
/// 
/// Figure 307 — Arbitrary closed profile
class IfcArbitraryClosedProfileDef : public IfcProfileDef {
public:
    /// Bounded curve, defining the outer boundaries of the arbitrary profile.
    IfcCurve* OuterCurve() const;
    void setOuterCurve(IfcCurve* v);
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 2: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcProfileDef::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 2: return Type::IfcCurve; } return IfcProfileDef::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 2: return "OuterCurve"; } return IfcProfileDef::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcArbitraryClosedProfileDef (IfcAbstractEntity* e);
    IfcArbitraryClosedProfileDef (IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< std::string > v2_ProfileName, IfcCurve* v3_OuterCurve);
    typedef IfcTemplatedEntityList< IfcArbitraryClosedProfileDef > list;
};
/// The open profile IfcArbitraryOpenProfileDef defines an arbitrary two-dimensional open profile for the use within the swept surface geometry. It is given by an open boundary from with the surface can be constructed. 
/// 
/// HISTORY  New entity in IFC2x.
/// 
/// Informal proposition:
/// 
/// The Curve has to be an open curve.
/// 
/// Figure 308 illustrates the arbitrary open profile definition. The Curve is defined in the underlying coordinate system. The underlying coordinate system is defined by the swept surface that uses the profile definition. It is the xy plane of: 
/// 
/// IfcSweptSurface.Position
/// 
/// The Curve attribute defines a two dimensional open bounded curve.
/// 
/// Figure 308 — Arbitrary open profile
class IfcArbitraryOpenProfileDef : public IfcProfileDef {
public:
    /// Open bounded curve defining the profile.
    IfcBoundedCurve* Curve() const;
    void setCurve(IfcBoundedCurve* v);
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 2: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcProfileDef::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 2: return Type::IfcBoundedCurve; } return IfcProfileDef::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 2: return "Curve"; } return IfcProfileDef::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcArbitraryOpenProfileDef (IfcAbstractEntity* e);
    IfcArbitraryOpenProfileDef (IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< std::string > v2_ProfileName, IfcBoundedCurve* v3_Curve);
    typedef IfcTemplatedEntityList< IfcArbitraryOpenProfileDef > list;
};
/// The IfcArbitraryProfileDefWithVoids defines an arbitrary closed two-dimensional profile with holes defined for the use for the swept area solid or a sectioned spine. It is given by an outer boundary and inner boundaries from with the solid the can be constructed.
/// 
/// HISTORY  New entity in IFC2x.
/// 
/// Informal propositions:
/// 
/// The outer curve and all inner curves shall be closed curves.
///   The outer curve shall enclose all inner curves.
///   No inner curve shall intersect with the outer curve or any other inner curve.
///   No inner curve may enclose another inner curve.
/// 
/// Figure 309 illustrates the arbitrary closed profile definition with voids. The OuterCurve, defined at the supertype IfcArbitraryClosedProfileDef
/// and the inner curves are defined in the same underlying coordinate system. The common underlying coordinate system is defined by the swept area solid that uses the profile definition. It is the xy plane of:
/// 
/// IfcSweptAreaSolid.Position
/// 
/// or in case of sectioned spines the xy plane of each list member of IfcSectionedSpine.CrossSectionPositions.  The OuterCurve attribute defines a two dimensional closed bounded curve, the InnerCurves define a set of two dimensional closed bounded curves.
/// 
/// Figure 309 — Arbitrary profile with voids
class IfcArbitraryProfileDefWithVoids : public IfcArbitraryClosedProfileDef {
public:
    /// Set of bounded curves, defining the inner boundaries of the arbitrary profile.
    IfcTemplatedEntityList< IfcCurve >::ptr InnerCurves() const;
    void setInnerCurves(IfcTemplatedEntityList< IfcCurve >::ptr v);
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 3: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } return IfcArbitraryClosedProfileDef::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 3: return Type::IfcCurve; } return IfcArbitraryClosedProfileDef::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 3: return "InnerCurves"; } return IfcArbitraryClosedProfileDef::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcArbitraryProfileDefWithVoids (IfcAbstractEntity* e);
    IfcArbitraryProfileDefWithVoids (IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< std::string > v2_ProfileName, IfcCurve* v3_OuterCurve, IfcTemplatedEntityList< IfcCurve >::ptr v4_InnerCurves);
    typedef IfcTemplatedEntityList< IfcArbitraryProfileDefWithVoids > list;
};
/// An IfcBlobTexture provides a 2-dimensional distribution of the lighting parameters of a surface onto which it is mapped. The texture itself is given as a single binary blob, representing the content of a pixel format file. The file format of the pixel file is given by the RasterFormat attribute and allowable formats are guided by where rule SupportedRasterFormat.
/// 
/// NOTE  Toolbox specific implementations of the binary datatype may restrict the maximum length of the binary blob to capture the raster file content.
/// 
/// For interpretation of the texture nodes see IfcImageTexture definition.
/// 
/// HISTORY  New class in IFC2x3.
/// 
/// IFC2x4 CHANGE  Data type of RasterCode has been corrected to BINARY.
class IfcBlobTexture : public IfcSurfaceTexture {
public:
    /// The format of the RasterCode often using a compression.
    std::string RasterFormat() const;
    void setRasterFormat(std::string v);
    /// Blob, given as a single binary, to capture the texture within one popular file (compression) format. The file format is provided by the RasterFormat attribute.
    bool RasterCode() const;
    void setRasterCode(bool v);
    virtual unsigned int getArgumentCount() const { return 6; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 4: return IfcUtil::Argument_STRING; case 5: return IfcUtil::Argument_BOOL; } return IfcSurfaceTexture::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 4: return Type::IfcIdentifier; case 5: return Type::UNDEFINED; } return IfcSurfaceTexture::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 4: return "RasterFormat"; case 5: return "RasterCode"; } return IfcSurfaceTexture::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcBlobTexture (IfcAbstractEntity* e);
    IfcBlobTexture (bool v1_RepeatS, bool v2_RepeatT, IfcSurfaceTextureEnum::IfcSurfaceTextureEnum v3_TextureType, IfcCartesianTransformationOperator2D* v4_TextureTransform, std::string v5_RasterFormat, bool v6_RasterCode);
    typedef IfcTemplatedEntityList< IfcBlobTexture > list;
};
/// The profile IfcCenterLineProfileDef defines an arbitrary two-dimensional open, not self intersecting profile for the use within the swept solid geometry. It is given by an area defined by applying a constant thickness to a centerline, generating an area from which the solid can be constructed.
/// 
/// Among else, IfcCenterLineProfileDef is used to model cold-formed
/// steel or aluminium sections (Sigma, Zeta, Omega, and similar sections
/// which are not covered by subtypes of IfcParameterizedProfileDef).
/// However, since IfcCenterLineProfileDef does not provide shape parameters
/// except for the thickness, there is generally a need to further specify the
/// profile definition by means of
/// 
/// the name,
///   external reference to a document or library,
///   profile properties,
/// 
/// or a combination of them.  See IfcProfileDef for guidance on external references for profiles.
/// 
/// HISTORY  New entity in IFC2x3.
/// 
/// Informal proposition: 
/// 
/// The Curve has to be an open curve.
///   The Curve has to be a non-intersecting curve.
/// 
/// Figure 311 illustrates the center line profile definition. The Curve is defined in the underlying coordinate system. The underlying coordinate system is defined by the swept surface that uses the profile  definition. It is the xy plane of: 
/// 
/// IfcSweptSurface.Position
/// 
/// The Curve attribute defines a two dimensional open bounded curve. The Thickness attribute defines a constant thickness along the curve.
/// 
/// Figure 311 — Centerline profile
class IfcCenterLineProfileDef : public IfcArbitraryOpenProfileDef {
public:
    /// Constant thickness applied along the center line.
    double Thickness() const;
    void setThickness(double v);
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 3: return IfcUtil::Argument_DOUBLE; } return IfcArbitraryOpenProfileDef::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 3: return Type::IfcPositiveLengthMeasure; } return IfcArbitraryOpenProfileDef::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 3: return "Thickness"; } return IfcArbitraryOpenProfileDef::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCenterLineProfileDef (IfcAbstractEntity* e);
    IfcCenterLineProfileDef (IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< std::string > v2_ProfileName, IfcBoundedCurve* v3_Curve, double v4_Thickness);
    typedef IfcTemplatedEntityList< IfcCenterLineProfileDef > list;
};
/// An IfcClassificationReference is a reference into a classification system or source (see IfcClassification) for a specific classification key (or notation).
/// 
/// The inherited attributes have the following meaning:
/// 
/// Identification: holds the key provided for a specific references to classification items (or tables).
/// Name: allows for a human interpretable designation of a classification notation.
/// Location: optionally holds a direct URI link into the classification system (or source) to hyperlink the classification key.
/// 
/// The IfcClassificationReference can either be assigned directly to the IfcClassification, such as if no classification hierarchy has to be included, or it references the parent classification notation, if the fully classification hierarchy is included in the data set. The attribute ReferencedSource then holds the following information (choice by IfcClassificationReferenceSelect):
/// 
/// being of type IfcClassification: direct reference to the classification system (with meta information provided), used for highest level of classification notations, or if the classification notation hierarchy is not relevant,
/// being of type IfcClassificationReference: reference to the parent classification notation within the classification hierarchy.
/// 
/// HISTORY New entity in IFC 2x.
/// 
/// IFC2x4 CHANGE The attribute Description and inverse attribute HasReferences are added.  The attribute Identification has been renamed from ItemReference.
/// 
/// Use definitions
/// The IfcClassificationReference can be used to only assign classification keys to objects, or to hold a fully classification hierarchy. The first is refered to as "lightweight classification", and the second as "full classification"
/// 
/// The IfcClassificationReference can be used as a form of 'lightweight' classification through the 'Identification' attribute inherited from the abstract IfcExternalReference class. In this case, the 'Identification' could take (for instance) the Uniclass notation "L6814" which, if the classification was well understood by all parties and was known to be taken from a particular classification source, would be sufficient. The Name attribute could be the title "Tanking". This would remove the need for the overhead of the more complete classification structure of the model.
class IfcClassificationReference : public IfcExternalReference {
public:
    /// Whether the optional attribute ReferencedSource is defined for this IfcClassificationReference
    bool hasReferencedSource() const;
    /// The classification system or source that is referenced.
    IfcClassification* ReferencedSource() const;
    void setReferencedSource(IfcClassification* v);
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 3: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcExternalReference::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 3: return Type::IfcClassification; } return IfcExternalReference::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 3: return "ReferencedSource"; } return IfcExternalReference::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcClassificationReference (IfcAbstractEntity* e);
    IfcClassificationReference (boost::optional< std::string > v1_Location, boost::optional< std::string > v2_ItemReference, boost::optional< std::string > v3_Name, IfcClassification* v4_ReferencedSource);
    typedef IfcTemplatedEntityList< IfcClassificationReference > list;
};
/// Definition from ISO/CD 10303-46:1992: A colour rgb as a subtype of colour specifications is defined by three colour component values for red, green, and blue in the RGB colour model.
/// 
/// NOTE  In contrary to the usual value range of colour components being integer from 0...255, the definition from ISO10303-46 defines the colour components as real from 0.0 ... 1.0. Applications need to execute this conversion before populating the colour RGB values.
/// 
/// NOTE  Corresponding STEP name: colour_rgb. The name attribute has been omitted, the data type for the reg, green and blue parts is IfcNormalizedRatioMeasure, that already includes the range restrictions for the values. Please
/// refer to ISO/IS 10303-46:1994, p. 138 for the final definition of the formal standard.
/// 
/// HISTORY  New entity in IFC2x2.
class IfcColourRgb : public IfcColourSpecification {
public:
    /// The intensity of the red colour component.
    /// 
    /// NOTE  The colour component value is given within the range of 0..1, and not within the range of 0..255 as otherwise usual.
    double Red() const;
    void setRed(double v);
    /// The intensity of the green colour component.
    /// 
    /// NOTE  The colour component value is given within the range of 0..1, and not within the range of 0..255 as otherwise usual.
    double Green() const;
    void setGreen(double v);
    /// The intensity of the blue colour component.
    /// 
    /// NOTE  The colour component value is given within the range of 0..1, and not within the range of 0..255 as otherwise usual.
    double Blue() const;
    void setBlue(double v);
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 1: return IfcUtil::Argument_DOUBLE; case 2: return IfcUtil::Argument_DOUBLE; case 3: return IfcUtil::Argument_DOUBLE; } return IfcColourSpecification::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 1: return Type::IfcNormalisedRatioMeasure; case 2: return Type::IfcNormalisedRatioMeasure; case 3: return Type::IfcNormalisedRatioMeasure; } return IfcColourSpecification::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 1: return "Red"; case 2: return "Green"; case 3: return "Blue"; } return IfcColourSpecification::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcColourRgb (IfcAbstractEntity* e);
    IfcColourRgb (boost::optional< std::string > v1_Name, double v2_Red, double v3_Green, double v4_Blue);
    typedef IfcTemplatedEntityList< IfcColourRgb > list;
};
/// IfcComplexProperty is used to define complex properties to be handled completely within a property set. The included set of properties may be a mixed or consistent collection of IfcProperty subtypes. This enables the definition of a set of properties to be included as a single 'property' entry in an IfcPropertySet. The definition of such an IfcComplexProperty can be reused in many different IfcPropertySet's.
/// 
/// NOTE  Since an IfcComplexProperty may contain other complex properties, sets of properties can be nested. This nesting may be restricted by view definitions and implementer agreements.
/// 
/// HISTORY New Entity in IFC Release 2.0, capabilities enhanced in IFC Release 2x.
class IfcComplexProperty : public IfcProperty {
public:
    /// Usage description of the IfcComplexProperty within the property set which references the IfcComplexProperty.
    ///   NOTE: Consider a complex property for glazing properties. The Name attribute of the IfcComplexProperty could be Pset_GlazingProperties, and the UsageName attribute could be OuterGlazingPane.
    std::string UsageName() const;
    void setUsageName(std::string v);
    /// Set of properties that can be used within this complex property (may include other complex properties).
    IfcTemplatedEntityList< IfcProperty >::ptr HasProperties() const;
    void setHasProperties(IfcTemplatedEntityList< IfcProperty >::ptr v);
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 2: return IfcUtil::Argument_STRING; case 3: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } return IfcProperty::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 2: return Type::IfcIdentifier; case 3: return Type::IfcProperty; } return IfcProperty::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 2: return "UsageName"; case 3: return "HasProperties"; } return IfcProperty::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcComplexProperty (IfcAbstractEntity* e);
    IfcComplexProperty (std::string v1_Name, boost::optional< std::string > v2_Description, std::string v3_UsageName, IfcTemplatedEntityList< IfcProperty >::ptr v4_HasProperties);
    typedef IfcTemplatedEntityList< IfcComplexProperty > list;
};
/// The IfcCompositeProfileDef
/// defines the profile by composition of other profiles. The composition
/// is given by a set of at least two other profile definitions. Any
/// profile definition (except for another composite profile) can be used
/// to construct the composite. 
/// 
/// HISTORY  New entity in IFC2x.
/// 
/// Figure 314 illustrates the composite profile definition. The IfcCompositeProfileDef does not define an own position coordinate system, it is directly defined in the underlying coordinate system. The underlying coordinate system is defined by the swept surface or swept area solid that uses the profile definition. It is the xy plane of either:
/// 
/// IfcSweptSurface.Position
///   IfcSweptAreaSolid.Position
/// 
/// Or in case of sectioned spines it is the xy plane of each list member of IfcSectionedSpine.CrossSectionPositions. The IfcCompositeProfileDef is defined using other profile definitions. Those other profile definitions are directly inserted into the underlying coordinate system.
/// 
/// In case of parameterized profile definitions, the Position attribute of those standard profiles is used to place the profiles relatively to each other.
///   In case of arbitrary profile definitions, each Cartesian coordinate is given directly within the underlying coordinate system.
/// 
/// NOTE  The black coordinate axes show the underlying coordinate system of the swept surface or swept area solid.
/// 
/// Figure 314
/// 
/// Twin profiles special case
/// 
/// If twin profiles are modeled by profile composition, the base profile should
/// only be specified once. It is then included into the composite profile directly
/// and additionally indirectly via IfcMirroredProfileDef. For example, a
/// double angle made of two L100x10 with 10mm air gap between them, i.e. a
/// _| |_ shape, can be modeled as
/// 
/// single_L : IfcLShapeProfileDef := IfcLShapeProfileDef(AREA, 'L100X100X10',
///     IfcAxis2Placement2D(IfcCartesianPoint(((.100+.010)/2., .0)), ?),
///     .100, .100, .010, .012, ?, 0., ?, ?);
///  
/// double_L : IfcCompositeProfileDef := IfcCompositeProfileDef(AREA, 'double angle',
///     (single_L, IfcMirroredProfileDef(AREA, ?, single_L, ?)), 'twin profile');
class IfcCompositeProfileDef : public IfcProfileDef {
public:
    /// The profiles which are used to define the composite profile.
    IfcTemplatedEntityList< IfcProfileDef >::ptr Profiles() const;
    void setProfiles(IfcTemplatedEntityList< IfcProfileDef >::ptr v);
    /// Whether the optional attribute Label is defined for this IfcCompositeProfileDef
    bool hasLabel() const;
    /// The name by which the composition may be referred to. The actual meaning of the name has to be defined in the context of applications.
    std::string Label() const;
    void setLabel(std::string v);
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 2: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 3: return IfcUtil::Argument_STRING; } return IfcProfileDef::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 2: return Type::IfcProfileDef; case 3: return Type::IfcLabel; } return IfcProfileDef::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 2: return "Profiles"; case 3: return "Label"; } return IfcProfileDef::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCompositeProfileDef (IfcAbstractEntity* e);
    IfcCompositeProfileDef (IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< std::string > v2_ProfileName, IfcTemplatedEntityList< IfcProfileDef >::ptr v3_Profiles, boost::optional< std::string > v4_Label);
    typedef IfcTemplatedEntityList< IfcCompositeProfileDef > list;
};
/// Definition from ISO/CD 10303-42:1992: A connected_face_set is a set of faces such that the domain of faces together with their bounding edges and vertices is connected.  
/// 
/// NOTE  Corresponding ISO 10303 entity: connected_face_set, the subtype closed_shell is included as IfcClosedShell and the subtype open_shell is included as IfcOpenShell. Please refer to ISO/IS 10303-42:1994, p. 144 for the final definition of the formal standard.
/// 
/// HISTORY  New class in IFC Release 1.0
/// 
/// Informal proposition: 
/// 
/// The union of the domains of the faces and their bounding loops shall be arcwise connected.
class IfcConnectedFaceSet : public IfcTopologicalRepresentationItem {
public:
    /// The set of faces arcwise connected along common edges or vertices.
    IfcTemplatedEntityList< IfcFace >::ptr CfsFaces() const;
    void setCfsFaces(IfcTemplatedEntityList< IfcFace >::ptr v);
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } return IfcTopologicalRepresentationItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcFace; } return IfcTopologicalRepresentationItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "CfsFaces"; } return IfcTopologicalRepresentationItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcConnectedFaceSet (IfcAbstractEntity* e);
    IfcConnectedFaceSet (IfcTemplatedEntityList< IfcFace >::ptr v1_CfsFaces);
    typedef IfcTemplatedEntityList< IfcConnectedFaceSet > list;
};
/// IfcConnectionCurveGeometry is used to describe the geometric constraints that facilitate the physical connection of two objects at a curve or at an edge with curve geometry associated. It is envisioned as a control that applies to the element connection relationships. 
/// 
/// EXAMPLE  The connection relationship between two walls has a geometric constraint which describes the end caps (or cut-off of the wall ends) by a CurveOnRelatingElement for the first wall and a CurveOnRelatedElement for the second wall. The exact usage of the IfcConnectionCurveGeometry is further defined in the geometry use sections of the elements that use it.
/// 
/// The available geometry for the connection constraint may be further restricted to only allow straight segments by applying IfcPolyline
/// only. Such an usage constraint is provided at the object definition of the IfcElement subtype, utilizing the element connection by referring to the subtype of IfcRelConnects with the associated IfcConnectionCurveGeometry.
/// 
/// HISTORY  New entity in IFC Release 1.5, has been renamed from IfcLineConnectionGeometry in IFC Release 2x.
/// 
/// IFC2x Edition 3 CHANGE  The provision of topology with associated geometry, IfcEdgeCurve, is enabled by using the IfcCurveOrEdgeCurve.
/// 
/// Geometry use definitions
/// The IfcCurve (or the IfcEdgeCurve with an associated IfcCurve) at the CurveOnRelatingElement attribute defines the curve where the basic geometry items of the connected elements connects. The curve geometry and coordinates are provided within the local coordinate system of the RelatingElement, as specified at the IfcRelConnects Subtype that utilizes the IfcConnectionCurveGeometry. Optionally, the same curve geometry and coordinates can also be provided within the local coordinate system of the RelatedElement by using the CurveOnRelatedElement attribute.
class IfcConnectionCurveGeometry : public IfcConnectionGeometry {
public:
    /// The bounded curve at which the connected objects are aligned at the relating element, given in the LCS of the relating element.
    IfcCurveOrEdgeCurve* CurveOnRelatingElement() const;
    void setCurveOnRelatingElement(IfcCurveOrEdgeCurve* v);
    /// Whether the optional attribute CurveOnRelatedElement is defined for this IfcConnectionCurveGeometry
    bool hasCurveOnRelatedElement() const;
    /// The bounded curve at which the connected objects are aligned at the related element, given in the LCS of the related element. If the information is omitted, then the origin of the related element is used.
    IfcCurveOrEdgeCurve* CurveOnRelatedElement() const;
    void setCurveOnRelatedElement(IfcCurveOrEdgeCurve* v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcConnectionGeometry::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcCurveOrEdgeCurve; case 1: return Type::IfcCurveOrEdgeCurve; } return IfcConnectionGeometry::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "CurveOnRelatingElement"; case 1: return "CurveOnRelatedElement"; } return IfcConnectionGeometry::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcConnectionCurveGeometry (IfcAbstractEntity* e);
    IfcConnectionCurveGeometry (IfcCurveOrEdgeCurve* v1_CurveOnRelatingElement, IfcCurveOrEdgeCurve* v2_CurveOnRelatedElement);
    typedef IfcTemplatedEntityList< IfcConnectionCurveGeometry > list;
};
/// IfcConnectionPointEccentricity is used to describe the geometric constraints that facilitate the physical connection of two objects at a point or vertex point with associated point coordinates. There is a physical distance, or eccentricity, etween the connection points of both object. The eccentricity can be either given by:
/// 
/// providing the PointOnRelatingElement and the PointOnRelatedElement, where bothÿpoint coordinates are not identical within a common parent coordinate system (latestly within the world coordinate system),
/// providing the PointOnRelatingElement and the three distance measures, EccentricityInX, EccentricityInY, and EccentricityInZ (or only EccentricityInX, and EccentricityInY if the
/// underlying coordinate system is two-dimensional), or
/// providing both.
/// 
/// NOTEÿ If both, PointOnRelatedElement, and EccentricityInX, EccentricityInY, (EccentricityInZ) are provided, the values should be consistent. In case of any non-consistency, the calculated distance between PointOnRelatingElement and PointOnRelatedElement takes precedence.
/// 
/// The explicit values for EccentricityInX, EccentricityInY, and EccentricityInZ are always
/// measured in the following direction and coordinate system (defining when the value is positive or negative):
/// 
/// from the PointOnRelatedElement to PointOnRelatingElement within the coordinate system of the RelatingElement.
/// in addition: when used to specify connections in structural analysis models, the IfcStructuralMember is to be used as the RelatingElement of the relationship object utilizing IfcConnectionPointEccentricity, and the IfcStructuralConnection is the RelatedElement.
/// 
/// HISTORYÿ New entity in IFC 2x Edition 3.
/// 
/// Geometry use definitions
/// The IfcPoint (or the IfcVertexPoint with an associated IfcPoint) at the PointOnRelatingElement attribute defines the point where the basic geometry items of the connected elements connects. The point coordinates are provided within the local coordinate system of the RelatingElement, as specified at the IfcRelConnects subtype that utilizes the IfcConnectionPointGeometry. Optionally, the same point coordinates can also be provided within the local coordinate system of the RelatedElement by using the PointOnRelatedElement attribute, otherwise the distance to the point at the RelatedElement has to be given by the three eccentricity values.
class IfcConnectionPointEccentricity : public IfcConnectionPointGeometry {
public:
    /// Whether the optional attribute EccentricityInX is defined for this IfcConnectionPointEccentricity
    bool hasEccentricityInX() const;
    /// Distance in x direction between the two points (or vertex points) engaged in the point connection.
    double EccentricityInX() const;
    void setEccentricityInX(double v);
    /// Whether the optional attribute EccentricityInY is defined for this IfcConnectionPointEccentricity
    bool hasEccentricityInY() const;
    /// Distance in y direction between the two points (or vertex points) engaged in the point connection.
    double EccentricityInY() const;
    void setEccentricityInY(double v);
    /// Whether the optional attribute EccentricityInZ is defined for this IfcConnectionPointEccentricity
    bool hasEccentricityInZ() const;
    /// Distance in z direction between the two points (or vertex points) engaged in the point connection.
    double EccentricityInZ() const;
    void setEccentricityInZ(double v);
    virtual unsigned int getArgumentCount() const { return 5; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 2: return IfcUtil::Argument_DOUBLE; case 3: return IfcUtil::Argument_DOUBLE; case 4: return IfcUtil::Argument_DOUBLE; } return IfcConnectionPointGeometry::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 2: return Type::IfcLengthMeasure; case 3: return Type::IfcLengthMeasure; case 4: return Type::IfcLengthMeasure; } return IfcConnectionPointGeometry::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 2: return "EccentricityInX"; case 3: return "EccentricityInY"; case 4: return "EccentricityInZ"; } return IfcConnectionPointGeometry::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcConnectionPointEccentricity (IfcAbstractEntity* e);
    IfcConnectionPointEccentricity (IfcPointOrVertexPoint* v1_PointOnRelatingElement, IfcPointOrVertexPoint* v2_PointOnRelatedElement, boost::optional< double > v3_EccentricityInX, boost::optional< double > v4_EccentricityInY, boost::optional< double > v5_EccentricityInZ);
    typedef IfcTemplatedEntityList< IfcConnectionPointEccentricity > list;
};
/// Definition from ISO/CD 10303-41:1992: A context dependent unit is a unit which is not related to the SI system.
/// 
/// NOTE The number of parts in an assembly is a physical quantity measured in units that may be called "parts" but which cannot be related to an SI unit.
/// 
/// NOTE Corresponding ISO 10303 name: context_dependent_unit, please refer to ISO/IS 10303-41 for the final definition of the formal standard.
/// 
/// HISTORY New entity in IFC Release 1.5.1.
class IfcContextDependentUnit : public IfcNamedUnit {
public:
    /// The word, or group of words, by which the context dependent unit is referred to.
    std::string Name() const;
    void setName(std::string v);
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 2: return IfcUtil::Argument_STRING; } return IfcNamedUnit::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 2: return Type::IfcLabel; } return IfcNamedUnit::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 2: return "Name"; } return IfcNamedUnit::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcContextDependentUnit (IfcAbstractEntity* e);
    IfcContextDependentUnit (IfcDimensionalExponents* v1_Dimensions, IfcUnitEnum::IfcUnitEnum v2_UnitType, std::string v3_Name);
    typedef IfcTemplatedEntityList< IfcContextDependentUnit > list;
};
/// Definition from ISO/CD 10303-41:1992: A conversion based unit is a unit that is defined based on a measure with unit.
/// 
/// NOTE Corresponding ISO 10303 name: conversion_based_unit, please refer to ISO/IS 10303-41 for the final definition of the formal standard.
/// 
/// HISTORY New entity in IFC Release 1.5.1.
/// 
/// IFC 2x3 change: standard names of typical units added.
/// 
/// IFC 2x4 change: further names added: square inch, square foot, square mile, square yard, cubic inch, cubic foot, cubic yard, fluid ounce UK/US, ton UK/US, degree.
/// 
/// Example: An inch is a converted unit. It is from the Imperial system, its name is "inch" and it can be related to the si unit, millimetre, through a measure with unit whose value is 25.4 millimetre. A foot is also a converted unit. It is from the Imperial system, its name is "foot" and it can be related to an IfcSIUnit, millimetre, either directly or through the unit called "inch". Note that several US customary units differ from Imperial units (nonmetric English units) of the same name.
/// 
/// To identify some commonly used conversion based units, the standard designations (case insensitive) for the Name attribute include the following:
/// 
/// Name	Description
///   'inch'		Length measure equal to 25.4 mm
///   'foot'		Length measure equal to 304.8 mm
///   'yard'		Length measure equal to 914 mm
///   'mile'		Length measure equal to 1609 m
///   'square inch'	Area measure equal to 0.0006452 square meters
///   'square foot'	Area measure equal to 0.09290 square meters
///   'square yard'	Area measure equal to 0.83612736 square meters
///   'acre'		Area measure equal to 4046.86 square meters
///   'square mile'	Area measure equal to 2 588 881 square meters
///   'cubic inch'	Volume measure equal to 0.00001639 cubic meters
///   'cubic foot'	Volume measure equal to 0.02832 cubic meters
///   'cubic yard'	Volume measure equal to 0.7636 cubic meters
///   'litre'		Volume measure equal to 0.001 cubic meters
///   'fluid ounce UK'	Volume measure equal to 0.0000284130625 cubic meters
///   'fluid ounce US'	Volume measure equal to 0.00002957353 cubic meters
///   'pint UK'		Volume measure equal to 0.000568 cubic meters
///   'pint US'		Volume measure equal to 0.000473 cubic meters
///   'gallon UK'	Volume measure equal to 0.004546 cubic meters
///   'gallon US'	Volume measure equal to 0.003785 cubic meters
///   'degree'		Angle measure equal to π/180 rad
///   'ounce'		Mass measure equal to 28.35 g
///   'pound'		Mass measure equal to 0.454 kg
///   'ton UK'		Mass measure equal to 1016.0469088 kg, also known as long ton, gross ton, shipper's ton
///   'ton US'		Mass measure equal to 907.18474 kg, also known as short ton, net ton
///   'lbf'		Force measure equal to 4.4482216153 N, pound-force
///   'kip'		Force measure equal to 4448.2216153 N, kilopound-force
///   'psi'		Pressure measure equal to 6894.7572932 Pa, pound-force per square inch
///   'ksi'		Pressure measure equal to 6894757.2932 Pa, kilopound-force per square inch
///   'minute'		Time measure equal to 60 s
///   'hour'		Time measure equal to 3600 s
///   'day'		Time measure equal to 86400 s
///   'btu'		Energy measure equal to 1055.056 J, British Thermal Unit
class IfcConversionBasedUnit : public IfcNamedUnit {
public:
    /// The word, or group of words, by which the conversion based unit is referred to.
    std::string Name() const;
    void setName(std::string v);
    /// The physical quantity from which the converted unit is derived.
    IfcMeasureWithUnit* ConversionFactor() const;
    void setConversionFactor(IfcMeasureWithUnit* v);
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 2: return IfcUtil::Argument_STRING; case 3: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcNamedUnit::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 2: return Type::IfcLabel; case 3: return Type::IfcMeasureWithUnit; } return IfcNamedUnit::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 2: return "Name"; case 3: return "ConversionFactor"; } return IfcNamedUnit::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcConversionBasedUnit (IfcAbstractEntity* e);
    IfcConversionBasedUnit (IfcDimensionalExponents* v1_Dimensions, IfcUnitEnum::IfcUnitEnum v2_UnitType, std::string v3_Name, IfcMeasureWithUnit* v4_ConversionFactor);
    typedef IfcTemplatedEntityList< IfcConversionBasedUnit > list;
};
/// Definition from ISO/CD 10303-46:1992: A curve style specifies the visual appearance of curves.
/// 
/// An IfcCurveStyle provides the style table for presentation information assigned to geometric curves. The style is defined by a color, a font and a width. The IfcCurveStyle defines curve patterns as model patterns, that is, the distance between visible and invisible segments of curve patterns are given in model space dimensions (that have to be scaled using the target plot scale).
/// 
/// Styles are intended to be shared by multiple IfcStyledItem's, assigning the style to occurrences of (subtypes of) IfcGeometricRepresentationItem's. Measures given to a font pattern or a curve width are given in global drawing length units.
/// 
/// NOTE  global units are defined at the single IfcProject instance, given by UnitsInContext:IfcUnitAssignment, the same units are used for the geometric representation items and for the style definitions.
/// 
/// The measure values for font pattern and curve width apply to the model space with a target plot scale provided for the correct appearance in the default plot scale.. For different scale and projection dependent curve styles a different instance of IfcCurveStyle needs to be used by IfcPresentationStyleAssignment for different IfcGeometricRepresentationSubContext dependent representations.
/// 
/// NOTE  the target plot scale is given by IfcGeometricRepresentationSubContext.TargetScale.
/// 
/// An IfcCurveStyle can be assigned to IfcGeometricRepresentationItem's via the IfcPresentationStyleAssignment through an intermediate IfcStyledItem or IfcAnnotationCurveOccurrence.
/// 
/// NOTE  Corresponding ISO 10303 name: curve_style. Please refer to ISO/IS 10303-46:1994 for the final definition of the formal standard.
/// 
/// HISTORY  New entity in IFC2x2.
class IfcCurveStyle : public IfcPresentationStyle {
public:
    /// Whether the optional attribute CurveFont is defined for this IfcCurveStyle
    bool hasCurveFont() const;
    /// A curve style font which is used to present a curve. It can either be a predefined curve font, or an explicitly defined curve font. Both may be scaled. If not given, then the curve font should be taken from the layer assignment with style, if that is not given either, then the default curve font applies.
    IfcCurveFontOrScaledCurveFontSelect* CurveFont() const;
    void setCurveFont(IfcCurveFontOrScaledCurveFontSelect* v);
    /// Whether the optional attribute CurveWidth is defined for this IfcCurveStyle
    bool hasCurveWidth() const;
    /// A positive length measure in units of the presentation area for the width of a presented curve. If not given, then the style should be taken from the layer assignment with style, if that is not given either, then the default style applies.
    IfcSizeSelect* CurveWidth() const;
    void setCurveWidth(IfcSizeSelect* v);
    /// Whether the optional attribute CurveColour is defined for this IfcCurveStyle
    bool hasCurveColour() const;
    /// The colour of the visible part of the curve. If not given, then the colour should be taken from the layer assignment with style, if that is not given either, then the default colour applies.
    IfcColour* CurveColour() const;
    void setCurveColour(IfcColour* v);
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 1: return IfcUtil::Argument_ENTITY_INSTANCE; case 2: return IfcUtil::Argument_ENTITY_INSTANCE; case 3: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcPresentationStyle::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 1: return Type::IfcCurveFontOrScaledCurveFontSelect; case 2: return Type::IfcSizeSelect; case 3: return Type::IfcColour; } return IfcPresentationStyle::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 1: return "CurveFont"; case 2: return "CurveWidth"; case 3: return "CurveColour"; } return IfcPresentationStyle::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCurveStyle (IfcAbstractEntity* e);
    IfcCurveStyle (boost::optional< std::string > v1_Name, IfcCurveFontOrScaledCurveFontSelect* v2_CurveFont, IfcSizeSelect* v3_CurveWidth, IfcColour* v4_CurveColour);
    typedef IfcTemplatedEntityList< IfcCurveStyle > list;
};
/// IfcDerivedProfileDef defines the profile by transformation from the parent profile. The transformation is given by a two dimensional transformation operator. Transformation includes translation, rotation, mirror and scaling. The latter can be uniform or non uniform. The derived profiles may be used to define swept surfaces, swept area solids or sectioned spines.
/// 
/// The transformation effects the position, rotation, mirroring or scale of the profile at the underlying coordinate system, i.e. the coordinate system defined by the swept surface or swept area solid that uses the profile definition. It is the xy plane of either: 
/// 
/// IfcSweptSurface.Position
///   IfcSweptAreaSolid.Position
/// 
/// or in case of sectioned spines the xy plane of each list member of IfcSectionedSpine.CrossSectionPositions. The position and potential rotation of the ParentProfile within the underlying coordinate system is taken into consideration before applying the Cartesian transformation operator.
/// 
/// Note, if only mirroring is required, IfcMirroredProfileDef should be used instead.
/// 
/// HISTORY: New entity in IFC Release 2x.
/// 
/// Figure 316 illustrates examples of derived profiles.
/// 
/// Parameter
/// The IfcDerivedProfileDef
/// is defined using the IfcCartesianTransformationOperator2D
/// (CTO), which is applied to the parent profile definition. 
/// 
/// Example
/// The example shows an uniform scaling and a transformation
/// of an IfcRectangleProfileDef
/// to match the lower-left cardinal point. The attributes of the CTO are:
/// 
/// Axis1 = NIL (defaults to 1.,0.)
///   Axis2 = NIL (defaults to 0.,1.)
///   LocalOrigin = IfcCartesianPoint(,)
///   Scale = 2.
/// 
/// Note: The ParentProfile has a Position
/// = IfcCartesianPoint(,) already.
/// 
/// Parameter
/// The IfcDerivedProfileDef is defined using
/// non uniform transformationsby applying the IfcCartesianTransformationOperator2DnonUniform
/// as a subtype of the 2D CTO.
/// 
/// Example
/// The example shows a non-uniform scaling and a translation of an IfcRectangleProfileDef
/// to match the lower-left cardinal point. The attributes of the CTO are:
/// 
/// Axis1 = NIL (defaults to 1.,0.)
///   Axis2 = NIL (defaults to 0.,1.)
///   LocalOrigin = IfcCartesianPoint(0.,<1/2 YDim)
///   Scale  = 1.
///   Scale2 = 2.
/// 
/// Note: The ParentProfile has a Position
/// = IfcCartesianPoint(,) already.
/// 
/// Parameter
/// The IfcDerivedProfileDef
/// is defined using mirroring by applying the IfcCartesianTransformationOperator2D
/// (CTO) to the parent profile.
/// 
/// Example
/// The example shows a mirroring of an IfcLShapeProfileDef
/// to match the centre cardinal point. The attributes of the CTO are:
/// 
/// Axis1 = (-1.,0.)
///   Axis2 = NIL (defaults to 0.,1.)
///   LocalOrigin = IfcCartesianPoint(0.,0.)
///   Scale = NIL (defaults to 1.)
/// 
/// Note: The ParentProfile has a Position = IfcCartesianPoint(0.,0.).
/// 
/// This example is for illustration only.
/// If the transformation results only in mirroring like shown in the example, then
/// IfcMirroredProfileDef should be used instead of IfcDerivedProfileDef.
/// 
/// Note: The following color map applies:
/// 
/// black coordinate axes show the
///   underlying coordinate system of the swept surface, swept area solid, or
///   sectioned spine
/// 
/// red coordinate axes
///   show the position coordinate system of the parent profile
/// 
/// brown coordinate axes
///   show the position coordinate system of the derived profile
/// 
/// Figure 316 — Derived profile
class IfcDerivedProfileDef : public IfcProfileDef {
public:
    /// The parent profile provides the origin of the transformation.
    IfcProfileDef* ParentProfile() const;
    void setParentProfile(IfcProfileDef* v);
    /// Transformation operator applied to the parent profile.
    IfcCartesianTransformationOperator2D* Operator() const;
    void setOperator(IfcCartesianTransformationOperator2D* v);
    /// Whether the optional attribute Label is defined for this IfcDerivedProfileDef
    bool hasLabel() const;
    /// The name by which the transformation may be referred to. The actual meaning of the name has to be defined in the context of applications.
    std::string Label() const;
    void setLabel(std::string v);
    virtual unsigned int getArgumentCount() const { return 5; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 2: return IfcUtil::Argument_ENTITY_INSTANCE; case 3: return IfcUtil::Argument_ENTITY_INSTANCE; case 4: return IfcUtil::Argument_STRING; } return IfcProfileDef::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 2: return Type::IfcProfileDef; case 3: return Type::IfcCartesianTransformationOperator2D; case 4: return Type::IfcLabel; } return IfcProfileDef::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 2: return "ParentProfile"; case 3: return "Operator"; case 4: return "Label"; } return IfcProfileDef::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcDerivedProfileDef (IfcAbstractEntity* e);
    IfcDerivedProfileDef (IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< std::string > v2_ProfileName, IfcProfileDef* v3_ParentProfile, IfcCartesianTransformationOperator2D* v4_Operator, boost::optional< std::string > v5_Label);
    typedef IfcTemplatedEntityList< IfcDerivedProfileDef > list;
};

class IfcDimensionCalloutRelationship : public IfcDraughtingCalloutRelationship {
public:
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcDraughtingCalloutRelationship::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcDraughtingCalloutRelationship::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcDraughtingCalloutRelationship::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcDimensionCalloutRelationship (IfcAbstractEntity* e);
    IfcDimensionCalloutRelationship (boost::optional< std::string > v1_Name, boost::optional< std::string > v2_Description, IfcDraughtingCallout* v3_RelatingDraughtingCallout, IfcDraughtingCallout* v4_RelatedDraughtingCallout);
    typedef IfcTemplatedEntityList< IfcDimensionCalloutRelationship > list;
};

class IfcDimensionPair : public IfcDraughtingCalloutRelationship {
public:
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcDraughtingCalloutRelationship::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcDraughtingCalloutRelationship::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcDraughtingCalloutRelationship::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcDimensionPair (IfcAbstractEntity* e);
    IfcDimensionPair (boost::optional< std::string > v1_Name, boost::optional< std::string > v2_Description, IfcDraughtingCallout* v3_RelatingDraughtingCallout, IfcDraughtingCallout* v4_RelatedDraughtingCallout);
    typedef IfcTemplatedEntityList< IfcDimensionPair > list;
};
/// An IfcDocumentReference is a reference 
/// to the location of a document. The reference is given by a system 
/// interpretable Location attribute (a URL string) where the document can be found, and an optional inherited
///   internal reference Identification, which refers to a system
///   interpretable position within the document. The optional inherited
/// Name attribute is meant to have meaning for human readers. Optional 
/// document metadata can also be captured through reference to 
/// IfcDocumentInformation.
/// 
/// HISTORY: New Entity in IFC Release 2.0.
///   Modified in IFC 2x.
class IfcDocumentReference : public IfcExternalReference {
public:
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcExternalReference::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcExternalReference::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcExternalReference::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcDocumentInformation >::ptr ReferenceToDocument() const; // INVERSE IfcDocumentInformation::DocumentReferences
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcDocumentReference (IfcAbstractEntity* e);
    IfcDocumentReference (boost::optional< std::string > v1_Location, boost::optional< std::string > v2_ItemReference, boost::optional< std::string > v3_Name);
    typedef IfcTemplatedEntityList< IfcDocumentReference > list;
};
/// The draughting pre defined text font is a pre defined text font for the purpose to identify a font by name. Allowable names are:
/// 
/// 'ISO 3098-1 font A',
///   'ISO 3098-1 font B',
/// 
/// The ISO 3098-1 font A is the text font as denoted as Letterng A in clause 3 of ISO 3098-1, the ISO 3098-1 font B is the text font as denoted as Letterng B in clause 3 of ISO 3098-1.
/// 
/// NOTE  The IfcDraughtingPreDefinedTextFont is an entity that had been adopted from ISO 10303, Industrial automation systems and integration—Product data representation and exchange, Part 202: Application protocol: Associative draughting. Corresponding ISO 10303 name: draughting_pre_defined_text_font. Please refer to ISO/IS 10303-202:1994 page 196 for the final definition of the formal standard.
/// 
/// HISTORY  New entity in IFC2x2.
class IfcDraughtingPreDefinedTextFont : public IfcPreDefinedTextFont {
public:
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcPreDefinedTextFont::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcPreDefinedTextFont::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcPreDefinedTextFont::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcDraughtingPreDefinedTextFont (IfcAbstractEntity* e);
    IfcDraughtingPreDefinedTextFont (std::string v1_Name);
    typedef IfcTemplatedEntityList< IfcDraughtingPreDefinedTextFont > list;
};
/// Definition from ISO/CD 10303-42:1992: An edge is the
/// topological construct corresponding to the connection of two
/// vertices. More abstractly, it may stand for a logical
/// relationship between two vertices. The domain of an edge, if
/// present, is a finite, non-self-intersecting open curve in
/// RM, that is, a connected 1-dimensional
/// manifold. The bounds of an edge are two vertices, which need not
/// be distinct. The edge is oriented by choosing its traversal
/// direction to run from the first to the second vertex. If the two
/// vertices are the same, the edge is a self loop. The domain of the
/// edge does not include its bounds, and 0 ≤ Ξ ≤ ∞.
/// Associated with an edge may be a geometric curve to locate the
/// edge in a coordinate space; this is represented by the edge curve
/// (IfcEdgeCurve) subtype. The curve shall be finite and
/// non-self-intersecting within the domain of the edge. An edge is a
/// graph, so its multiplicity M and graph genus Ge
/// may be determined by the graph traversal algorithm. Since
/// M = E = 1, the Euler equation (1) reduces in the
/// case to
/// 
/// where V = 1 or 2, and Ge = 1 or 0.
/// Specifically, the topological edge defining data shall
/// satisfy:
/// 
/// - an edge has two vertices
/// 
/// - the vertices need not be distinct
/// 
/// - Equation (2) shall hold.
/// 
/// The geometry between the two
/// vertices defaults to a straight line if no curve geometry is
/// assigned using the subtype IfcEdgeCurve. The
/// IfcEdge can therefore be used to exchange straight edges
/// without an associated geometry provided by IfcLine or
/// IfcPolyline thought IfcEdgeCurve.EdgeGeometry.
/// 
/// Figure 333 illustrates an example where the bounds of the IfcEdge are given by the EdgeStart and EdgeEnd; this also determines the direction of the edge. The location within a coordinate space is determined by the IfcVertexPoint type for EdgeStart and EdgeEnd. Since no edge geometry is assigned, it defaults to a straight line agreeing to the direction sense.
/// 
/// Figure 333 — Edge representation
/// 
/// NOTE  Corresponding ISO 10303 entity: edge. Please refer to ISO/IS 10303-42:1994, p. 130 for the final definition of the formal standard.
/// 
/// HISTORY  New Entity in IFC Release 2.0
/// 
/// Informal propositions:
/// 
/// The edge has dimensionality 1.
/// The extend of an edge shall be finite and nonzero.
class IfcEdge : public IfcTopologicalRepresentationItem {
public:
    /// Start point (vertex) of the edge.
    IfcVertex* EdgeStart() const;
    void setEdgeStart(IfcVertex* v);
    /// End point (vertex) of the edge. The same vertex can be used for both EdgeStart and EdgeEnd.
    IfcVertex* EdgeEnd() const;
    void setEdgeEnd(IfcVertex* v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcTopologicalRepresentationItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcVertex; case 1: return Type::IfcVertex; } return IfcTopologicalRepresentationItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "EdgeStart"; case 1: return "EdgeEnd"; } return IfcTopologicalRepresentationItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcEdge (IfcAbstractEntity* e);
    IfcEdge (IfcVertex* v1_EdgeStart, IfcVertex* v2_EdgeEnd);
    typedef IfcTemplatedEntityList< IfcEdge > list;
};
/// Definition from ISO/CD 10303-42:1992: An edge curve is
/// a special subtype of edge which has its geometry fully defined.
/// The geometry is defined by associating the edge with a curve
/// which may be unbounded. As the topological and geometric
/// directions may be opposed, an indicator (same sense) is used to
/// identify whether the edge and curve directions agree or are
/// opposed. The Boolean value indicates whether the curve direction
/// agrees with (TRUE) or is in the opposite direction (FALSE) to the
/// edge direction. Any geometry associated with the vertices of the
/// edge shall be consistent with the edge geometry. Multiple edges
/// can reference the same curve.
/// 
/// Figure 334 illustrates an example where the edge geometry is given by an unbounded curve, here IfcCircle. The bounds are provided by the EdgeStart and EdgeEnd, the topological direction of the IfcEdgeCurve opposes the direction of the IfcCircle by SameSense = FALSE.
/// 
/// Figure 334 — Edge curve
/// 
/// NOTE  Corresponding ISO 10303 entity: edge_curve. Please refer to ISO/IS 10303-42:1994, p. 132
/// for the final definition of the formal standard. Due to the general IFC model specification rule not to use multiple inheritance, the subtype relationship to geometric_representation_item is not included.
/// 
/// <blockquote class="history"
/// HISTORY  New Entity in IFC2x.
/// 
/// Informal propositions:
/// 
/// The domain of the edge curve is formally defined to be the
/// domain of its edge geometry as trimmed by the vertices. This
/// domain does not include the vertices.
/// An edge curve has non-zero finite extent.
/// An edge curve is a manifold.
/// An edge curve is arcwise connected.
/// The edge start is not a part of the edge domain.
/// The edge end is not a part of the edge domain.
/// Vertex geometry shall be consistent with edge geometry.
class IfcEdgeCurve : public IfcEdge {
public:
    /// The curve which defines the shape and spatial location of the edge. This curve may be unbounded and is implicitly trimmed by the vertices of the edge; this defines the edge domain. Multiple edges can reference the same curve.
    IfcCurve* EdgeGeometry() const;
    void setEdgeGeometry(IfcCurve* v);
    /// This logical flag indicates whether (TRUE), or not (FALSE) the senses of the edge and the curve defining the edge geometry are the same. The sense of an edge is from the edge start vertex to the edge end vertex; the sense of a curve is in the direction of increasing parameter.
    bool SameSense() const;
    void setSameSense(bool v);
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 2: return IfcUtil::Argument_ENTITY_INSTANCE; case 3: return IfcUtil::Argument_BOOL; } return IfcEdge::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 2: return Type::IfcCurve; case 3: return Type::UNDEFINED; } return IfcEdge::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 2: return "EdgeGeometry"; case 3: return "SameSense"; } return IfcEdge::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcEdgeCurve (IfcAbstractEntity* e);
    IfcEdgeCurve (IfcVertex* v1_EdgeStart, IfcVertex* v2_EdgeEnd, IfcCurve* v3_EdgeGeometry, bool v4_SameSense);
    typedef IfcTemplatedEntityList< IfcEdgeCurve > list;
};
/// The IfcExtendedMaterialProperties assign a set of
/// defined material properties to associated material definitions.
/// This provides a mechanism to assign any material properties to
/// material. Those material properties that are defined as part of the
/// IFC specification are provided within the use definitions
/// below.
/// NOTE The usage of this entity has changed in
/// IFC2x4, it is now used to express all material
/// properties.
/// The IfcProperty (instantiable subtypes) is used to
/// express the individual material properties.
/// 
/// HISTORY  New entity in Release IFC2x.
/// 
/// IFC2x4 CHANGE  The attributes Name and Description are promoted to supertype,
/// attribute ExtendedProperties has been renamed to Properties.
/// 
/// Extended property use definitions
/// The following sets of material property definitions are part of
/// this IFC release:
/// 
/// General Material Properties
/// General Mechanical Properties
/// 
/// Steel Mechanical Properties
/// Concrete Mechanical Properties
/// Timber and Wood-based Mechanical Properties
/// 
/// General Thermal Properties
/// General Hygroscopic Properties
/// General Optical Properties
/// General Water Properties
/// General Fuel Properties
/// General Products of Combustion Properties
/// General Energy Calculation Properties
class IfcExtendedMaterialProperties : public IfcMaterialProperties {
public:
    IfcTemplatedEntityList< IfcProperty >::ptr ExtendedProperties() const;
    void setExtendedProperties(IfcTemplatedEntityList< IfcProperty >::ptr v);
    /// Whether the optional attribute Description is defined for this IfcExtendedMaterialProperties
    bool hasDescription() const;
    std::string Description() const;
    void setDescription(std::string v);
    std::string Name() const;
    void setName(std::string v);
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 1: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 2: return IfcUtil::Argument_STRING; case 3: return IfcUtil::Argument_STRING; } return IfcMaterialProperties::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 1: return Type::IfcProperty; case 2: return Type::IfcText; case 3: return Type::IfcLabel; } return IfcMaterialProperties::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 1: return "ExtendedProperties"; case 2: return "Description"; case 3: return "Name"; } return IfcMaterialProperties::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcExtendedMaterialProperties (IfcAbstractEntity* e);
    IfcExtendedMaterialProperties (IfcMaterial* v1_Material, IfcTemplatedEntityList< IfcProperty >::ptr v2_ExtendedProperties, boost::optional< std::string > v3_Description, std::string v4_Name);
    typedef IfcTemplatedEntityList< IfcExtendedMaterialProperties > list;
};
/// Definition from ISO/CD 10303-42:1992: A face is a topological
///   entity of dimensionality 2 corresponding to the intuitive notion of a piece of
///   surface bounded by loops. Its domain, if present, is an oriented, connected,
///   finite 2-manifold in Rm. A face domain shall not have handles
///   but it may have holes, each hole bounded by a loop. The domain of the
///   underlying geometry of the face, if present, does not contain its bounds, and 0
///   < Ξ < ∞. 
///   A face is represented by its bounding loops, which are defined as face
///   bounds. A face has a topological normal n and the tangent to a loop is t. For a
///   loop bounding a face with defined geometry, the cross product n x t points
///   toward the interior of the face. That is, each loop runs counter-clockwise
///   around the face when viewed from above, if we consider the normal n to point
///   up. With each loop is associated a BOOLEAN flag to signify whether the loop
///   direction is oriented with respect to the face normal (TRUE) or should be
///   reversed (FALSE).  
///   A face shall have at least one bound, and the loops shall not intersect.
///   One loop is optionally distinguished as the outer loop of the face. If so, it
///   establishes a preferred way of embedding the face domain in the plane, in which
///   the other bounding loops of the face are inside the outer bound. Because the
///   face domain is arcwise connected, no inner loop will contain any other loop.
///   This is true regardless of which embedding in the plane is chosen.  
///   The edges and vertices referenced by the loops of a face form a graph,
///   of which the individual loops are the connected components. The Euler equation
///   (1) for this graph becomes: 
/// 
/// where Gli is the graph genus of the
///   i th loop. 
/// 
/// NOTE  Corresponding ISO 10303 entity: face. No subtypes of face have been incorporated
///   into this IFC Release. Please refer to ISO/IS 10303-42:1994, p. 140 for the
///   final definition of the formal standard. The WR1 has not been incorporated,
///   since it is always satisfied, due to the fact that only poly loops exist for
///   face bounds.
/// 
/// HISTORY  New class in IFC Release 1.0
/// 
/// Informal propositions: 
/// 
/// No edge shall be referenced by the face more than twice.  
///   Distinct face bounds of the face shall have no common vertices. 
///   If geometry is present, distinct loops of the same face shall not
///   intersect.  
///   The face shall satisfy the Euler Equation: (number of vertices) -
///   (number of edges) - (number of loops) + (sum of genus for loops) = 0.
class IfcFace : public IfcTopologicalRepresentationItem {
public:
    /// Boundaries of the face.
    IfcTemplatedEntityList< IfcFaceBound >::ptr Bounds() const;
    void setBounds(IfcTemplatedEntityList< IfcFaceBound >::ptr v);
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } return IfcTopologicalRepresentationItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcFaceBound; } return IfcTopologicalRepresentationItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Bounds"; } return IfcTopologicalRepresentationItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcFace (IfcAbstractEntity* e);
    IfcFace (IfcTemplatedEntityList< IfcFaceBound >::ptr v1_Bounds);
    typedef IfcTemplatedEntityList< IfcFace > list;
};
/// Definition from ISO/CD 10303-42:1992: A face bound is a loop which is intended to be used for bounding a face.  
/// 
/// NOTE  Corresponding ISO 10303 entity: face_bound. Please refer to ISO/IS 10303-42:1994, p. 139 for the final definition of the formal standard.
/// 
/// HISTORY  New class in IFC Release 1.0
class IfcFaceBound : public IfcTopologicalRepresentationItem {
public:
    /// The loop which will be used as a face boundary.
    IfcLoop* Bound() const;
    void setBound(IfcLoop* v);
    /// This indicated whether (TRUE) or not (FALSE) the loop has the same sense when used to bound the face as when first defined. If sense is FALSE the senses of all its component oriented edges are implicitly reversed when used in the face.
    bool Orientation() const;
    void setOrientation(bool v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_BOOL; } return IfcTopologicalRepresentationItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcLoop; case 1: return Type::UNDEFINED; } return IfcTopologicalRepresentationItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Bound"; case 1: return "Orientation"; } return IfcTopologicalRepresentationItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcFaceBound (IfcAbstractEntity* e);
    IfcFaceBound (IfcLoop* v1_Bound, bool v2_Orientation);
    typedef IfcTemplatedEntityList< IfcFaceBound > list;
};
/// Definition from ISO/CD 10303-42:1992: A face outer bound is a special subtype of face bound which carries the additional semantics of defining an outer boundary on the face. No more than one boundary of a face shall be of this type.  
/// 
/// NOTE Corresponding ISO 10303 entity: face_outer_bound. Please refer to ISO/IS 10303-42:1994, p. 139 for the final definition of the formal standard.
/// 
/// HISTORY New class in IFC Release 1.0
class IfcFaceOuterBound : public IfcFaceBound {
public:
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcFaceBound::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcFaceBound::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcFaceBound::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcFaceOuterBound (IfcAbstractEntity* e);
    IfcFaceOuterBound (IfcLoop* v1_Bound, bool v2_Orientation);
    typedef IfcTemplatedEntityList< IfcFaceOuterBound > list;
};
/// Definition from ISO/CD 10303-42:1992: A face surface
///   (IfcFaceSurface) is a subtype of face in which the geometry is defined by an
///   associated surface. The portion of the surface used by the face shall be
///   embeddable in the plane as an open disk, possibly with holes. However, the
///   union of the face with the edges and vertices of its bounding loops need not be
///   embeddable in the plane. It may, for example, cover an entire sphere or torus.
///   As both a face and a geometric surface have defined normal directions, a
///   BOOLEAN flag (the orientation attribute) is used to indicate whether the
///   surface normal agrees with (TRUE) or is opposed to (FALSE) the face normal
///   direction. The geometry associated with any component of the loops of the face
///   shall be consistent with the surface geometry, in the sense that the domains of
///   all the vertex points and edge curves are contained in the face geometry
///   surface. A surface may be referenced by more than one face surface. 
/// 
/// NOTE  Corresponding ISO 10303 entity:
///   face_surface. Please refer to ISO/IS 10303-42:1994, p. 204 for the final
///   definition of the formal standard. Due to the general IFC model specification
///   rule not to use multiple inheritance, the subtype relationship to
///   geometric_representation_item is not included.
/// 
/// HISTORY  New class in IFC2x
/// 
/// Informal propositions: 
/// 
/// The domain of the face surface is formally defined to be the domain
///   of its face geometry as trimmed by the loops, this domain does not include the
///   bounding loops. 
///   A face surface has non zero finite extent. 
///   A face surface is a manifold. 
///   A face surface is arcwise connected. 
///   A face surface has surface genus 0.
///   The loops are not part of the face domain.
///   Loop geometry shall be consistent with face geometry. This implies
///   that any edge - curves or vertex points used in defining the loops bounding the
///   face surface shall lie on the face geometry.
///   The loops of the face shall not intersect.
class IfcFaceSurface : public IfcFace {
public:
    /// The surface which defines the internal shape of the face. This surface may be unbounded. The domain of the face is defined by this surface and the bounding loops in the inherited attribute SELF\FaceBounds.
    IfcSurface* FaceSurface() const;
    void setFaceSurface(IfcSurface* v);
    /// This flag indicates whether the sense of the surface normal agrees with (TRUE), or opposes (FALSE), the sense of the topological normal to the face.
    bool SameSense() const;
    void setSameSense(bool v);
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 1: return IfcUtil::Argument_ENTITY_INSTANCE; case 2: return IfcUtil::Argument_BOOL; } return IfcFace::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 1: return Type::IfcSurface; case 2: return Type::UNDEFINED; } return IfcFace::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 1: return "FaceSurface"; case 2: return "SameSense"; } return IfcFace::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcFaceSurface (IfcAbstractEntity* e);
    IfcFaceSurface (IfcTemplatedEntityList< IfcFaceBound >::ptr v1_Bounds, IfcSurface* v2_FaceSurface, bool v3_SameSense);
    typedef IfcTemplatedEntityList< IfcFaceSurface > list;
};
/// Definition from IAI: Defines forces at which a support or connection fails.
/// 
/// Applicability:
/// 
/// Point supports and connections.
/// 
/// HISTORY: New entity in IFC 2x2.
class IfcFailureConnectionCondition : public IfcStructuralConnectionCondition {
public:
    /// Whether the optional attribute TensionFailureX is defined for this IfcFailureConnectionCondition
    bool hasTensionFailureX() const;
    /// Tension force in x-direction leading to failure of the connection.
    double TensionFailureX() const;
    void setTensionFailureX(double v);
    /// Whether the optional attribute TensionFailureY is defined for this IfcFailureConnectionCondition
    bool hasTensionFailureY() const;
    /// Tension force in y-direction leading to failure of the connection.
    double TensionFailureY() const;
    void setTensionFailureY(double v);
    /// Whether the optional attribute TensionFailureZ is defined for this IfcFailureConnectionCondition
    bool hasTensionFailureZ() const;
    /// Tension force in z-direction leading to failure of the connection.
    double TensionFailureZ() const;
    void setTensionFailureZ(double v);
    /// Whether the optional attribute CompressionFailureX is defined for this IfcFailureConnectionCondition
    bool hasCompressionFailureX() const;
    /// Compression force in x-direction leading to failure of the connection.
    double CompressionFailureX() const;
    void setCompressionFailureX(double v);
    /// Whether the optional attribute CompressionFailureY is defined for this IfcFailureConnectionCondition
    bool hasCompressionFailureY() const;
    /// Compression force in y-direction leading to failure of the connection.
    double CompressionFailureY() const;
    void setCompressionFailureY(double v);
    /// Whether the optional attribute CompressionFailureZ is defined for this IfcFailureConnectionCondition
    bool hasCompressionFailureZ() const;
    /// Compression force in z-direction leading to failure of the connection.
    double CompressionFailureZ() const;
    void setCompressionFailureZ(double v);
    virtual unsigned int getArgumentCount() const { return 7; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 1: return IfcUtil::Argument_DOUBLE; case 2: return IfcUtil::Argument_DOUBLE; case 3: return IfcUtil::Argument_DOUBLE; case 4: return IfcUtil::Argument_DOUBLE; case 5: return IfcUtil::Argument_DOUBLE; case 6: return IfcUtil::Argument_DOUBLE; } return IfcStructuralConnectionCondition::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 1: return Type::IfcForceMeasure; case 2: return Type::IfcForceMeasure; case 3: return Type::IfcForceMeasure; case 4: return Type::IfcForceMeasure; case 5: return Type::IfcForceMeasure; case 6: return Type::IfcForceMeasure; } return IfcStructuralConnectionCondition::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 1: return "TensionFailureX"; case 2: return "TensionFailureY"; case 3: return "TensionFailureZ"; case 4: return "CompressionFailureX"; case 5: return "CompressionFailureY"; case 6: return "CompressionFailureZ"; } return IfcStructuralConnectionCondition::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcFailureConnectionCondition (IfcAbstractEntity* e);
    IfcFailureConnectionCondition (boost::optional< std::string > v1_Name, boost::optional< double > v2_TensionFailureX, boost::optional< double > v3_TensionFailureY, boost::optional< double > v4_TensionFailureZ, boost::optional< double > v5_CompressionFailureX, boost::optional< double > v6_CompressionFailureY, boost::optional< double > v7_CompressionFailureZ);
    typedef IfcTemplatedEntityList< IfcFailureConnectionCondition > list;
};
/// Definition from ISO/CD 10303-46:1992: The style for filling visible curve segments, annotation fill areas or surfaces with tiles or hatches.
/// 
/// An IfcFillAreaStyle provides the style table for presentation information assigned to annotation fill areas or surfaces for hatching and tiling. The IfcFillAreaStyle defines hatches as model hatches, that is, the distance between hatch lines, or the curve patterns of hatch lines are given in model space dimensions (that have to be scaled using the target plot scale). The IfcFillAreaStyle allows for the following combinations of defining the style of hatching and tiling:
/// 
/// Solid fill for areas and surfaces by only assigning IfcColour to the set of FillStyles. It then provides the background colour for the filled area or surface.
/// 
/// NOTE  Color information of surfaces for rendering is assigned by using IfcSurfaceStyle, not by using IfcFillAreaStyle.
/// 
/// Vector based hatching for areas and surfaces based on a single row of hatch lines by assigning a single instance of IfcFillAreaStyleHatching to the set of FillStyles.  If an instance of IfcColour is assigned in addition to the set of FillStyles, it provides the background colour for the hatching.  Vector based hatching for areas and surfaces based on two (potentially crossing) rows of hatch lines by assigning two instances of IfcFillAreaStyleHatching to the set of FillStyles. 
/// 
/// If an instance of IfcColour is assigned in addition to the set of FillStyles, it provides the background colour for the hatching. 
/// 
/// NOTE  Assigning more then two instances of IfcFillAreaStyleHatching to define three or more rows of hatch lines is not encouraged.
/// 
/// Tiling for areas and surfaces by assigning a single instance of IfcFillAreaStyleTiles to the set of FillStyles.  If an instance of IfcColour is assigned in addition to the set of FillStyles, it provides the background colour for the tiling. 
/// 
/// IFC2x3 NOTE  The use of IfcFillAreaStyleTiles is discouraged., as its definition might change is future releases.
/// 
/// Externally defined hatch style by assigning a single instance of IfcExternallyDefinedHatchStyle to the set of FillStyles. 
///   If an instance of IfcColour is assigned in addition to the set of FillStyles, it provides the background colour for the hatching.
/// 
/// Measures given to a hatch or tile pattern are given in global drawing length units.
/// 
/// NOTE  Global units are defined at the single IfcProject instance, given by UnitsInContext:IfcUnitAssignment, the same units are used for the geometric representation items and for the style definitions.
/// 
/// The measure values for hatch or tile pattern apply to the model space with a target plot scale provided for the correct appearance in the default plot scale. For different scale and projection dependent fill area styles a different instance of IfcFillAreaStyle needs to be used by IfcPresentationStyleAssignment for different IfcGeometricRepresentationSubContext dependent representations.
/// 
/// NOTE  the target plot scale is given by IfcGeometricRepresentationSubContext.TargetScale.
/// 
/// An IfcFillAreaStyle can be assigned to IfcFillArea via the IfcPresentationStyleAssignment through an intermediate IfcStyledItem or subtype IfcAnnotationFillAreaOccurrence.
/// 
/// NOTE  Corresponding ISO 10303 name: fill_area_style. Please refer to ISO/IS 10303-46:1994 for the final definition of the formal standard.
/// 
/// HISTORY  New entity in IFC2x2.
class IfcFillAreaStyle : public IfcPresentationStyle {
public:
    /// The set of fill area styles to use in presenting visible curve segments, annotation fill areas or surfaces.
    IfcEntityList::ptr FillStyles() const;
    void setFillStyles(IfcEntityList::ptr v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 1: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } return IfcPresentationStyle::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 1: return Type::IfcFillStyleSelect; } return IfcPresentationStyle::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 1: return "FillStyles"; } return IfcPresentationStyle::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcFillAreaStyle (IfcAbstractEntity* e);
    IfcFillAreaStyle (boost::optional< std::string > v1_Name, IfcEntityList::ptr v2_FillStyles);
    typedef IfcTemplatedEntityList< IfcFillAreaStyle > list;
};

class IfcFuelProperties : public IfcMaterialProperties {
public:
    /// Whether the optional attribute CombustionTemperature is defined for this IfcFuelProperties
    bool hasCombustionTemperature() const;
    double CombustionTemperature() const;
    void setCombustionTemperature(double v);
    /// Whether the optional attribute CarbonContent is defined for this IfcFuelProperties
    bool hasCarbonContent() const;
    double CarbonContent() const;
    void setCarbonContent(double v);
    /// Whether the optional attribute LowerHeatingValue is defined for this IfcFuelProperties
    bool hasLowerHeatingValue() const;
    double LowerHeatingValue() const;
    void setLowerHeatingValue(double v);
    /// Whether the optional attribute HigherHeatingValue is defined for this IfcFuelProperties
    bool hasHigherHeatingValue() const;
    double HigherHeatingValue() const;
    void setHigherHeatingValue(double v);
    virtual unsigned int getArgumentCount() const { return 5; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 1: return IfcUtil::Argument_DOUBLE; case 2: return IfcUtil::Argument_DOUBLE; case 3: return IfcUtil::Argument_DOUBLE; case 4: return IfcUtil::Argument_DOUBLE; } return IfcMaterialProperties::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 1: return Type::IfcThermodynamicTemperatureMeasure; case 2: return Type::IfcPositiveRatioMeasure; case 3: return Type::IfcHeatingValueMeasure; case 4: return Type::IfcHeatingValueMeasure; } return IfcMaterialProperties::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 1: return "CombustionTemperature"; case 2: return "CarbonContent"; case 3: return "LowerHeatingValue"; case 4: return "HigherHeatingValue"; } return IfcMaterialProperties::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcFuelProperties (IfcAbstractEntity* e);
    IfcFuelProperties (IfcMaterial* v1_Material, boost::optional< double > v2_CombustionTemperature, boost::optional< double > v3_CarbonContent, boost::optional< double > v4_LowerHeatingValue, boost::optional< double > v5_HigherHeatingValue);
    typedef IfcTemplatedEntityList< IfcFuelProperties > list;
};

class IfcGeneralMaterialProperties : public IfcMaterialProperties {
public:
    /// Whether the optional attribute MolecularWeight is defined for this IfcGeneralMaterialProperties
    bool hasMolecularWeight() const;
    double MolecularWeight() const;
    void setMolecularWeight(double v);
    /// Whether the optional attribute Porosity is defined for this IfcGeneralMaterialProperties
    bool hasPorosity() const;
    double Porosity() const;
    void setPorosity(double v);
    /// Whether the optional attribute MassDensity is defined for this IfcGeneralMaterialProperties
    bool hasMassDensity() const;
    double MassDensity() const;
    void setMassDensity(double v);
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 1: return IfcUtil::Argument_DOUBLE; case 2: return IfcUtil::Argument_DOUBLE; case 3: return IfcUtil::Argument_DOUBLE; } return IfcMaterialProperties::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 1: return Type::IfcMolecularWeightMeasure; case 2: return Type::IfcNormalisedRatioMeasure; case 3: return Type::IfcMassDensityMeasure; } return IfcMaterialProperties::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 1: return "MolecularWeight"; case 2: return "Porosity"; case 3: return "MassDensity"; } return IfcMaterialProperties::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcGeneralMaterialProperties (IfcAbstractEntity* e);
    IfcGeneralMaterialProperties (IfcMaterial* v1_Material, boost::optional< double > v2_MolecularWeight, boost::optional< double > v3_Porosity, boost::optional< double > v4_MassDensity);
    typedef IfcTemplatedEntityList< IfcGeneralMaterialProperties > list;
};

class IfcGeneralProfileProperties : public IfcProfileProperties {
public:
    /// Whether the optional attribute PhysicalWeight is defined for this IfcGeneralProfileProperties
    bool hasPhysicalWeight() const;
    double PhysicalWeight() const;
    void setPhysicalWeight(double v);
    /// Whether the optional attribute Perimeter is defined for this IfcGeneralProfileProperties
    bool hasPerimeter() const;
    double Perimeter() const;
    void setPerimeter(double v);
    /// Whether the optional attribute MinimumPlateThickness is defined for this IfcGeneralProfileProperties
    bool hasMinimumPlateThickness() const;
    double MinimumPlateThickness() const;
    void setMinimumPlateThickness(double v);
    /// Whether the optional attribute MaximumPlateThickness is defined for this IfcGeneralProfileProperties
    bool hasMaximumPlateThickness() const;
    double MaximumPlateThickness() const;
    void setMaximumPlateThickness(double v);
    /// Whether the optional attribute CrossSectionArea is defined for this IfcGeneralProfileProperties
    bool hasCrossSectionArea() const;
    double CrossSectionArea() const;
    void setCrossSectionArea(double v);
    virtual unsigned int getArgumentCount() const { return 7; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 2: return IfcUtil::Argument_DOUBLE; case 3: return IfcUtil::Argument_DOUBLE; case 4: return IfcUtil::Argument_DOUBLE; case 5: return IfcUtil::Argument_DOUBLE; case 6: return IfcUtil::Argument_DOUBLE; } return IfcProfileProperties::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 2: return Type::IfcMassPerLengthMeasure; case 3: return Type::IfcPositiveLengthMeasure; case 4: return Type::IfcPositiveLengthMeasure; case 5: return Type::IfcPositiveLengthMeasure; case 6: return Type::IfcAreaMeasure; } return IfcProfileProperties::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 2: return "PhysicalWeight"; case 3: return "Perimeter"; case 4: return "MinimumPlateThickness"; case 5: return "MaximumPlateThickness"; case 6: return "CrossSectionArea"; } return IfcProfileProperties::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcGeneralProfileProperties (IfcAbstractEntity* e);
    IfcGeneralProfileProperties (boost::optional< std::string > v1_ProfileName, IfcProfileDef* v2_ProfileDefinition, boost::optional< double > v3_PhysicalWeight, boost::optional< double > v4_Perimeter, boost::optional< double > v5_MinimumPlateThickness, boost::optional< double > v6_MaximumPlateThickness, boost::optional< double > v7_CrossSectionArea);
    typedef IfcTemplatedEntityList< IfcGeneralProfileProperties > list;
};
/// Definition from ISO/CD 10303-42:1992: A geometric
/// representation context is a representation context in which the
/// geometric representation items are geometrically founded. A
/// geometric representation context is a distinct coordinate space,
/// spatially unrelated to other coordinate spaces.
/// 
/// IfcGeometricRepresentationContext defines the context that
/// applies to several shape representations of products within a
/// project. It defines the type of the context in which the shape
/// representation is defined, and the numeric precision applicable
/// to the geometric representation items defined in this context. In
/// addition it can be used to offset the project coordinate system
/// from a global point of origin, using the
/// WorldCoordinateSystem attribute.
/// 
/// As shown in Figure 329, the TrueNorth attribute should be provided if the y axis of the WorldCoordinateSystem does not point to the global northing. Direction of the true north, or geographic northing direction, relative to the underlying project coordinate
/// system as established by the attribute WorldCoordinateSystem. It is given by a 2 dimensional direction within the xy-plane of the project coordinate system. If not resent, it defaults to [0.,1.] - i.e. the positive Y axis of the project coordinate system equals the geographic northing direction. The direction is provided within project coordinate system and identifies the true north direction (see
/// figure).
/// 
/// Figure 329 — Geometric representation context true north
/// 
/// NOTE ÿThe inherited attribute
/// ContextType shall have one of the following recognized
/// values: 'Sketch', 'Outline', 'Design', 'Detail',
/// 'Model', 'Plan',
/// 'NotDefined'.
/// 
/// The use of one instance of
/// IfcGeometricRepresentationContext to represent the model
/// (3D) view is mandatory, the use of a second instance of
/// IfcGeometricRepresentationContext to represent the plan
/// (2D) view is optional (but needs to be given, if there are scale
/// dependent plan views), the additional scale or view dependent
/// contexts need to be handled by using the subtype
/// IfcGeometricRepresentationSubContext pointing to the model
/// view (or the plan view) as the ParentContext.
/// 
/// Figure 330 illustrates use of representation contexts defined at IfcProject for 3D model and 2D plan context, including sub
/// context definitions for different target scales.
/// 
/// Figure 330 — Geometric representation context use
/// 
/// NOTE  The definition of this class relates to the ISO 10303 entity geometric_representation_context. Please refer to ISO/IS 10303-42:1994 for the final definition of the formal standard.
/// 
/// HISTORY ÿNew Entity in IFC Release 2.0
/// 
/// IFC2x3 CHANGE ÿApplicable values for ContextType are only 'Model',ÿ 'Plan', andÿ'NotDefined'. All other sub contexts are now handled by the new subtype in IFC2x Edition 2 IfcGeometricRepresentationSubContext. Upward compatibility for file based exchange is guaranteed.
class IfcGeometricRepresentationContext : public IfcRepresentationContext {
public:
    /// The integer dimension count of the coordinate space modeled in a geometric representation context.
    int CoordinateSpaceDimension() const;
    void setCoordinateSpaceDimension(int v);
    /// Whether the optional attribute Precision is defined for this IfcGeometricRepresentationContext
    bool hasPrecision() const;
    /// Value of the model precision for geometric models. It is a double value (REAL), typically in 1E-5 to 1E-8 range, that indicates the tolerance under which two given points are still assumed to be identical. The value can be used e.g. to sets the maximum distance from an edge curve to the underlying face surface in brep models.
    double Precision() const;
    void setPrecision(double v);
    /// Establishment of the engineering coordinate system (often referred to as the world coordinate system in CAD) for all representation contexts used by the project. 
    /// 
    /// Note  it can be used to provide better numeric stability if the placement of the building(s) is far away from the origin. In most cases however it would be set to origin: (0.,0.,0.) and directions x(1.,0.,0.), y(0.,1.,0.), z(0.,0.,1.).
    IfcAxis2Placement* WorldCoordinateSystem() const;
    void setWorldCoordinateSystem(IfcAxis2Placement* v);
    /// Whether the optional attribute TrueNorth is defined for this IfcGeometricRepresentationContext
    bool hasTrueNorth() const;
    /// Direction of the true north, or geographic northing direction, relative to the underlying project coordinate system. It is given by a 2 dimensional direction within the xy-plane of the project coordinate system. If not resent, it defaults to 0. 1. - i.e. the positive Y axis of the project coordinate system equals the geographic northing direction.
    IfcDirection* TrueNorth() const;
    void setTrueNorth(IfcDirection* v);
    virtual unsigned int getArgumentCount() const { return 6; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 2: return IfcUtil::Argument_INT; case 3: return IfcUtil::Argument_DOUBLE; case 4: return IfcUtil::Argument_ENTITY_INSTANCE; case 5: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcRepresentationContext::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 2: return Type::IfcDimensionCount; case 3: return Type::UNDEFINED; case 4: return Type::IfcAxis2Placement; case 5: return Type::IfcDirection; } return IfcRepresentationContext::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 2: return "CoordinateSpaceDimension"; case 3: return "Precision"; case 4: return "WorldCoordinateSystem"; case 5: return "TrueNorth"; } return IfcRepresentationContext::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcGeometricRepresentationSubContext >::ptr HasSubContexts() const; // INVERSE IfcGeometricRepresentationSubContext::ParentContext
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcGeometricRepresentationContext (IfcAbstractEntity* e);
    IfcGeometricRepresentationContext (boost::optional< std::string > v1_ContextIdentifier, boost::optional< std::string > v2_ContextType, int v3_CoordinateSpaceDimension, boost::optional< double > v4_Precision, IfcAxis2Placement* v5_WorldCoordinateSystem, IfcDirection* v6_TrueNorth);
    typedef IfcTemplatedEntityList< IfcGeometricRepresentationContext > list;
};
/// Definition from ISO/CD 10303-43:1992: An geometric representation item is a representation item that has the additional meaning of having geometric position or orientation or both. This meaning is present by virtue of:  
/// 
/// being a Cartesian point or a direction  
///   referencing directly a Cartesian point or direction  
///   referencing indirectly a Cartesian point or direction  
/// 
/// An indirect reference to a Cartesian point or direction means that a given geometric item references the Cartesian point or direction through one or more intervening geometry or topology items.  
/// 
/// EXAMPLE: Consider a circle. It gains its geometric position and orientation by virtue of a reference to axis2_placement (IfcAxis2Placement) that is turn references a cartesian_point (IfcCartesianPoint) and several directions (IfcDirection). 
/// 
/// EXAMPLE: Consider a manifold brep. A manifold_solid_brep (IfcManifoldSolidBrep) is a geometric_representation_item (IfcGeometricRepresentationItem) that through several layers of topological_representation_item's (IfcTopologicalRepresentationItem) references poly loops (IfcPolyLoop). Through additional intervening entities poly loops reference cartesian_point's (IfcCartesianPoint).
/// 
/// The derivation of the dimensionality of the IfcGeometricRepresentationItem is different to ISO 10303; there is a specific derived attribute at each class that defines the dimensionality, whereas ISO 10303 does it for the representation_context and requires all geometric_representation_item's to have the same dimensionality therein.  
/// 
/// The definition of swept area solids as geometric representation items is different to ISO 10303; it is based on a set of predefined profiles (or cross sections), that is, a set of parameterized geometric primitives widely supported in the industry. Those profiles are used to create volumes through extrusion, revolution and cross section based sweep operations.
/// 
/// NOTE: Corresponding ISO 10303 entity: geometric_representation_item. Please refer to ISO/IS 10303-42:1994, p. 22 for the final definition of the formal standard. The following changes have been made: It does not inherit from ISO/IS 10303-43:1994 entity representation_item. The derived attribute Dim is demoted to the appropriate subtypes. The WR1 has not been incorporated. Not all subtypes that are in ISO/IS 10303-42:1994 have been added to the current IFC Release.
/// 
/// HISTORY: New entity in IFC Release 1.5
class IfcGeometricRepresentationItem : public IfcRepresentationItem {
public:
    virtual unsigned int getArgumentCount() const { return 0; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcRepresentationItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcRepresentationItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcRepresentationItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcGeometricRepresentationItem (IfcAbstractEntity* e);
    IfcGeometricRepresentationItem ();
    typedef IfcTemplatedEntityList< IfcGeometricRepresentationItem > list;
};
/// IfcGeometricRepresentationSubContext defines the context that applies to several shape representations of a product being a sub context, sharing the WorldCoordinateSystem, CoordinateSpaceDimension, Precision and TrueNorth attributes with the parent IfcGeometricRepresentationContext.
/// 
/// The IfcGeometricRepresentationSubContext is used to define semantically distinguished representation types for different information content, dependent on the representation view and the target scale. It can be used to control the level of detail of the shape representation that is most applicable to this geometric representation context. addition the sub context is used to control the later appearance of the IfcShapeRepresentation within a plot view.
/// 
/// NOTE  If the IfcShapeRepresentation using this sub context has IfcStyledItem's assigned to the Items, the presentation style information (e.g. IfcCurveStyle, IfcTextStyle) associated with the IfcStyledItem is given in target plot dimensions. For example, a line thickness (IfcCurveStyle.CurveWidth) is given by a thickness measure relating to the thickness for a plot within the (range of) target scale.
/// 
/// Each IfcProduct can then have several instances of subtypes of IfcRepresentation, each being assigned to a different geometric representation context (IfcGeometricRepresentationContext or IfcGeometricRepresentationSubContext). The application can then choose the most appropriate representation for showing the geometric shape of the product, depending on the target view and scale.
/// 
/// NOTE  The provision of a model view (IfcGeometricRepresentationContext.ContextType = 'Model') is mandatory. Instances of IfcGeometricRepresentationSubContext relate to it as its ParentContext.
/// 
/// EXAMPLE  Instances of IfcGeometricRepresentationSubContext can be used to handle the multi-view blocks or macros, which are used in CAD programs to store several scale and/or view dependent geometric representations of the same object.
/// 
/// HISTORY  New entity in Release IFC 2x2.
class IfcGeometricRepresentationSubContext : public IfcGeometricRepresentationContext {
public:
    /// Parent context from which the sub context derives its world coordinate system, precision, space coordinate dimension and true north.
    IfcGeometricRepresentationContext* ParentContext() const;
    void setParentContext(IfcGeometricRepresentationContext* v);
    /// Whether the optional attribute TargetScale is defined for this IfcGeometricRepresentationSubContext
    bool hasTargetScale() const;
    /// The target plot scale of the representation 
    /// to which this representation context applies.
    ///   Scale indicates the target plot scale for
    /// the representation sub context, all annotation styles are given in plot
    /// dimensions according to this target plot scale.
    /// If multiple instances of IfcGeometricRepresentationSubContext
    /// are given having the same TargetView value, the target plot scale 
    /// applies up to the next smaller scale, or up to unlimited small scale.
    /// 
    /// Note: Scale 1:100 (given as 0.01 within TargetScale)
    /// is bigger then 1:200 (given as 0.005 within TargetScale).
    double TargetScale() const;
    void setTargetScale(double v);
    /// Target view of the representation to which this representation context applies.
    IfcGeometricProjectionEnum::IfcGeometricProjectionEnum TargetView() const;
    void setTargetView(IfcGeometricProjectionEnum::IfcGeometricProjectionEnum v);
    /// Whether the optional attribute UserDefinedTargetView is defined for this IfcGeometricRepresentationSubContext
    bool hasUserDefinedTargetView() const;
    /// User defined target view, this attribute value shall be given, if the TargetView attribute is set to USERDEFINED.
    std::string UserDefinedTargetView() const;
    void setUserDefinedTargetView(std::string v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 6: return IfcUtil::Argument_ENTITY_INSTANCE; case 7: return IfcUtil::Argument_DOUBLE; case 8: return IfcUtil::Argument_ENUMERATION; case 9: return IfcUtil::Argument_STRING; } return IfcGeometricRepresentationContext::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 6: return Type::IfcGeometricRepresentationContext; case 7: return Type::IfcPositiveRatioMeasure; case 8: return Type::IfcGeometricProjectionEnum; case 9: return Type::IfcLabel; } return IfcGeometricRepresentationContext::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 6: return "ParentContext"; case 7: return "TargetScale"; case 8: return "TargetView"; case 9: return "UserDefinedTargetView"; } return IfcGeometricRepresentationContext::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcGeometricRepresentationSubContext (IfcAbstractEntity* e);
    IfcGeometricRepresentationSubContext (boost::optional< std::string > v1_ContextIdentifier, boost::optional< std::string > v2_ContextType, IfcGeometricRepresentationContext* v7_ParentContext, boost::optional< double > v8_TargetScale, IfcGeometricProjectionEnum::IfcGeometricProjectionEnum v9_TargetView, boost::optional< std::string > v10_UserDefinedTargetView);
    typedef IfcTemplatedEntityList< IfcGeometricRepresentationSubContext > list;
};
/// Definition from ISO/CD 10303-42:1992: This entity is intended for the transfer of models when a topological structure is not available. 
/// 
/// The IfcGeometricSet is used for the exchange of shape representations consisting of (2D or 3D) points, curves, and/or surfaces, which do not have a topological structure (such as connected face sets or shells) and are not solid models (such as swept solids, CSG or Brep) 
/// 
/// NOTE: Corresponding ISO 10303-42 entity: geometric_set. The derived attribute Dim has been added at this level and was therefore demoted from the geometric_representation_item. Please refer to ISO/IS 10303-42:1994, p. 190 for the final definition of the formal standard.
/// 
/// HISTORY: New entity in IFC Release 2x.
class IfcGeometricSet : public IfcGeometricRepresentationItem {
public:
    /// The geometric elements which make up the geometric set, these may be points, curves or surfaces; but are required to be of the same coordinate space dimensionality.
    IfcEntityList::ptr Elements() const;
    void setElements(IfcEntityList::ptr v);
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } return IfcGeometricRepresentationItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcGeometricSetSelect; } return IfcGeometricRepresentationItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Elements"; } return IfcGeometricRepresentationItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcGeometricSet (IfcAbstractEntity* e);
    IfcGeometricSet (IfcEntityList::ptr v1_Elements);
    typedef IfcTemplatedEntityList< IfcGeometricSet > list;
};
/// IfcGridPlacement provides a specialization of IfcObjectPlacement in which
/// the placement and axis direction of the object coordinate system is defined by a reference to the design grid as defined in IfcGrid.
/// The location of the object coordinate system is given by the attribute PlacementLocation. It is defined as an
/// IfcVirtualGridIntersection, that is, an intersection between two grid axes with optional offsets.
/// The axis direction of the x-axis of the object coordinate
/// system is given either:
/// 
/// PlacementRefDirection = NIL: by the tangent of the first grid axis (PlacementLocation.IntersectingAxes[1]) at the virtual intersection (maybe using the offset curve, if PlacementLocation.OffsetDistances is given);
/// PlacementRefDirection = IfcDirection: by the explicitly provided direction information;
/// PlacementRefDirection = IfcVirtualGridIntersection: by the tangent between the virtual grid intersection of PlacementLocation and the virtual grid intersection of PlacementRefDirection. Offsets as potentially provided in the IfcVirtualGridIntersection's of PlacementLocation and PlacementRefDirection have to be taken into account.
/// 
/// The direction of the y-axis of the IfcGridPlacement is the orthogonal complement to the x-axis. The plane defined by the x and y axis shall be co-planar to the xy plane of the local placement of the IfcGrid.ÿ 
/// The direction of the z-axis is the orientation of the cross product of the x-axis and the y-axis, i.e. the z-axis of the IfcGridPlacement shall be co-linear to the z-axis of the local placement of the IfcGrid.
/// 
/// NOTE The IfcGrid local placement, that can be provided relative to the local placement of another spatial structure element, has to be taken into account for calculating the absolute placement of the virtual grid intersection.
/// 
/// NOTE The PlacementLocation.OffsetDistances[3] and the PlacementRefDirection.OffsetDistances[3] shall either not be assigned or should have the same z offset value.
/// 
/// HISTORY ÿNew entity in IFC Release 1.5. The entity name was changed from IfcConstrainedPlacement in IFC Release 2x.
/// 
/// IFC2x4 CHANGE Attribute data type of PlacementRefDirection has been changed to IfcGridPlacementDirectionSelect.
/// 
/// Geometry use definitions
/// The following examples show the usage of placement location and direction for an IfcGridPlacement.
/// 
/// Figure 243 illustrates the case where PlacementRefDirection is not given - the object coordinate system is defined by:
/// 
/// its location: given by the virtual grid intersection of PlacementLocation
/// its x-axis direction: given by the tangent of the first intersecting axis in the offset location of the virtual grid intersection
/// 
/// Figure 243 — Grid placement
/// 
/// Figure 244 illustrates the case where PlacementRefDirection is given as an IfcDirection- the object coordinate system is defined by:
/// 
/// its location: given by the virtual grid intersection of PlacementLocation
/// its x-axis direction: given by the DirectionRatios of the IfcDirection, only the ratios for x and y are taken into account,
/// 
/// Figure 244 — Grid placement with direction
/// 
/// Figure 245 illustrates the case where PlacementRefDirection is given as an IfcVirtualGridIntersection- the object coordinate system is defined by:
/// 
/// its location: given by the virtual grid intersection of PlacementLocation
/// its x-axis direction: given by the tangent of the line between the virtual grid intersection of the PlacementLocation and the virtual grid intersection of the PlacementRefDirection.
/// 
/// Figure 245 — Grid placement with intersection
class IfcGridPlacement : public IfcObjectPlacement {
public:
    /// Placement of the object coordinate system defined by the intersection of two grid axes.
    IfcVirtualGridIntersection* PlacementLocation() const;
    void setPlacementLocation(IfcVirtualGridIntersection* v);
    /// Whether the optional attribute PlacementRefDirection is defined for this IfcGridPlacement
    bool hasPlacementRefDirection() const;
    /// Reference to either an explicit direction, or a second grid axis intersection, which defines the orientation of the grid placement.
    /// 
    /// IFC2x4 CHANGE  The select of an explict direction has been added.
    IfcVirtualGridIntersection* PlacementRefDirection() const;
    void setPlacementRefDirection(IfcVirtualGridIntersection* v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcObjectPlacement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcVirtualGridIntersection; case 1: return Type::IfcVirtualGridIntersection; } return IfcObjectPlacement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "PlacementLocation"; case 1: return "PlacementRefDirection"; } return IfcObjectPlacement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcGridPlacement (IfcAbstractEntity* e);
    IfcGridPlacement (IfcVirtualGridIntersection* v1_PlacementLocation, IfcVirtualGridIntersection* v2_PlacementRefDirection);
    typedef IfcTemplatedEntityList< IfcGridPlacement > list;
};
/// Definition from ISO/CD 10303-42:1992: A half space solid is defined by the half space which is the regular subset of the domain which lies on one side of an unbounded surface. The side of the surface which is in the half space is determined by the surface normal and the agreement flag. If the agreement flag is TRUE, then the subset is the one the normal points away from. If the agreement flag is FALSE, then the subset is the one the normal points into. For a valid half space solid the surface shall divide the domain into exactly two subsets. Also, within the domain the surface shall be manifold and all surface normals shall point into the same subset.  
/// 
/// NOTE A half space is not a subtype of solid model (IfcSolidModel), half space solids are only useful as operands in Boolean expressions.
/// 
/// NOTE Corresponding STEP entity: half_space_solid. Please refer to ISO/IS 10303-42:1994, p. 185 for the final definition of the formal standard. The derived attribute Dim has been added at this level and was therefore demoted from the geometric_representation_item.
/// 
/// HISTORY New class in IFC Release 1.5
/// 
/// Informal propositions: 
/// 
/// The base surface shall divide the domain into exactly two subsets. If the half space solid is of subtype boxed half space (IfcBoxedHalfSpace), the domain in question is that of the attribute enclosure. In all other cases the domain is all of space and the base surface shall be unbounded.  The base surface shall be an unbounded surface (subtype of IfcElementarySurface). 
/// 
/// Figure 258 illustrates the definition of the IfcHalfSpaceSolid within a given coordinate system. The base surface is given by an unbounded plane, the red boundary is shown for visualization purposes only. 
/// 
/// Figure 258 — Half space solid geometry
class IfcHalfSpaceSolid : public IfcGeometricRepresentationItem {
public:
    /// Surface defining side of half space.
    IfcSurface* BaseSurface() const;
    void setBaseSurface(IfcSurface* v);
    /// The agreement flag is TRUE if the normal to the BaseSurface points away from the material of the IfcHalfSpaceSolid. Otherwise it is FALSE.
    bool AgreementFlag() const;
    void setAgreementFlag(bool v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_BOOL; } return IfcGeometricRepresentationItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcSurface; case 1: return Type::UNDEFINED; } return IfcGeometricRepresentationItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "BaseSurface"; case 1: return "AgreementFlag"; } return IfcGeometricRepresentationItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcHalfSpaceSolid (IfcAbstractEntity* e);
    IfcHalfSpaceSolid (IfcSurface* v1_BaseSurface, bool v2_AgreementFlag);
    typedef IfcTemplatedEntityList< IfcHalfSpaceSolid > list;
};

class IfcHygroscopicMaterialProperties : public IfcMaterialProperties {
public:
    /// Whether the optional attribute UpperVaporResistanceFactor is defined for this IfcHygroscopicMaterialProperties
    bool hasUpperVaporResistanceFactor() const;
    double UpperVaporResistanceFactor() const;
    void setUpperVaporResistanceFactor(double v);
    /// Whether the optional attribute LowerVaporResistanceFactor is defined for this IfcHygroscopicMaterialProperties
    bool hasLowerVaporResistanceFactor() const;
    double LowerVaporResistanceFactor() const;
    void setLowerVaporResistanceFactor(double v);
    /// Whether the optional attribute IsothermalMoistureCapacity is defined for this IfcHygroscopicMaterialProperties
    bool hasIsothermalMoistureCapacity() const;
    double IsothermalMoistureCapacity() const;
    void setIsothermalMoistureCapacity(double v);
    /// Whether the optional attribute VaporPermeability is defined for this IfcHygroscopicMaterialProperties
    bool hasVaporPermeability() const;
    double VaporPermeability() const;
    void setVaporPermeability(double v);
    /// Whether the optional attribute MoistureDiffusivity is defined for this IfcHygroscopicMaterialProperties
    bool hasMoistureDiffusivity() const;
    double MoistureDiffusivity() const;
    void setMoistureDiffusivity(double v);
    virtual unsigned int getArgumentCount() const { return 6; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 1: return IfcUtil::Argument_DOUBLE; case 2: return IfcUtil::Argument_DOUBLE; case 3: return IfcUtil::Argument_DOUBLE; case 4: return IfcUtil::Argument_DOUBLE; case 5: return IfcUtil::Argument_DOUBLE; } return IfcMaterialProperties::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 1: return Type::IfcPositiveRatioMeasure; case 2: return Type::IfcPositiveRatioMeasure; case 3: return Type::IfcIsothermalMoistureCapacityMeasure; case 4: return Type::IfcVaporPermeabilityMeasure; case 5: return Type::IfcMoistureDiffusivityMeasure; } return IfcMaterialProperties::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 1: return "UpperVaporResistanceFactor"; case 2: return "LowerVaporResistanceFactor"; case 3: return "IsothermalMoistureCapacity"; case 4: return "VaporPermeability"; case 5: return "MoistureDiffusivity"; } return IfcMaterialProperties::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcHygroscopicMaterialProperties (IfcAbstractEntity* e);
    IfcHygroscopicMaterialProperties (IfcMaterial* v1_Material, boost::optional< double > v2_UpperVaporResistanceFactor, boost::optional< double > v3_LowerVaporResistanceFactor, boost::optional< double > v4_IsothermalMoistureCapacity, boost::optional< double > v5_VaporPermeability, boost::optional< double > v6_MoistureDiffusivity);
    typedef IfcTemplatedEntityList< IfcHygroscopicMaterialProperties > list;
};
/// An IfcImageTexture provides a 2-dimensional texture that can be applied to a surface of an geometric item and that provides lighting parameters of a surface onto which it is mapped. The texture is provided as an image file at an external location for which an URL is provided.
/// 
/// The following definitions from ISO/IEC 19775-1 X3D Architecture and base components (X3D Specification) apply:
/// 
/// The ImageTexture node defines a texture map by specifying an image file and general parameters for mapping to geometry. 
/// The texture is read from the URL specified by the url field. When the url field contains no [resolvable] values, texturing is disabled. Browsers shall support the JPEG and PNG (see ISO/IEC 15948) image file formats.
/// Texture nodes that require support for the PNG image format shall interpret the PNG pixel formats in the following way:
/// 
/// Greyscale pixels without alpha or simple transparency are treated as intensity textures.
/// >Greyscale pixels with alpha or simple transparency are treated as intensity plus alpha textures.
/// RGB pixels without alpha channel or simple transparency are treated as full RGB textures.
/// RGB pixels with alpha channel or simple transparency are treated as full RGB plus alpha textures.
/// 
/// If the image specifies colours as indexed-colour (that is, palettes or colourmaps), the following semantics should be used (note that `greyscale' refers to a palette entry with equal red, green, and blue values):
/// 
/// If all the colours in the palette are greyscale and there is no transparency chunk, it is treated as an intensity texture.
/// If all the colours in the palette are greyscale and there is a transparency chunk, it is treated as an intensity plus opacity texture.
/// >If any colour in the palette is not grey and there is no transparency chunk, it is treated as a full RGB texture.
/// If any colour in the palette is not grey and there is a transparency chunk, it is treated as a full RGB plus alpha texture.
/// 
/// Texture nodes that require support for JPEG files shall interpret JPEG files as follows:
/// 
/// Greyscale files (number of components equals 1) are treated as intensity textures.
/// YCbCr files are treated as full RGB textures.
/// No other JPEG file types are required. It is recommended that other JPEG files are treated as a full RGB textures.
/// 
/// Texture nodes that recommend support for GIF files shall follow the applicable semantics described above for the PNG format.
/// 
/// The Uniform Resource Locator (URL) is a form of an URI and specified in RFC1738 by IETF. It supports resources located on a particular server being accessed by a particular protocol (usually http), and resources located at a local machine.
/// 
/// NOTE  Exchange files following the ifcZIP convention may include a sub directory structure for image resources to be stored together with the product data set.
/// 
/// NOTE  The definitions of texturing within this standard have been developed in dependence on the texture component of X3D. See ISO/IEC 19775-1.2:2008 X3D Architecture and base components Edition 2, Part 1, 18 Texturing component for the definitions in the international standard.
/// 
/// HISTORY  New entity in Release IFC2x2.
class IfcImageTexture : public IfcSurfaceTexture {
public:
    std::string UrlReference() const;
    void setUrlReference(std::string v);
    virtual unsigned int getArgumentCount() const { return 5; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 4: return IfcUtil::Argument_STRING; } return IfcSurfaceTexture::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 4: return Type::IfcIdentifier; } return IfcSurfaceTexture::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 4: return "UrlReference"; } return IfcSurfaceTexture::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcImageTexture (IfcAbstractEntity* e);
    IfcImageTexture (bool v1_RepeatS, bool v2_RepeatT, IfcSurfaceTextureEnum::IfcSurfaceTextureEnum v3_TextureType, IfcCartesianTransformationOperator2D* v4_TextureTransform, std::string v5_UrlReference);
    typedef IfcTemplatedEntityList< IfcImageTexture > list;
};
/// In an irregular time series, unpredictable bursts of data arrive at unspecified points in time, or most time stamps cannot be characterized by a repeating pattern.
/// 
/// EXAMPLE: A circulating pump cycles on and off at unpredictable times as dictated by the demands on the piping system; the amount of light in a classroom varies depending on when the lights are manually switched on and off and and how many lamps are controlled by each switch.
/// 
/// HISTORY: New entity in IFC 2x2.
class IfcIrregularTimeSeries : public IfcTimeSeries {
public:
    /// The collection of time series values.
    IfcTemplatedEntityList< IfcIrregularTimeSeriesValue >::ptr Values() const;
    void setValues(IfcTemplatedEntityList< IfcIrregularTimeSeriesValue >::ptr v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } return IfcTimeSeries::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcIrregularTimeSeriesValue; } return IfcTimeSeries::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "Values"; } return IfcTimeSeries::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcIrregularTimeSeries (IfcAbstractEntity* e);
    IfcIrregularTimeSeries (std::string v1_Name, boost::optional< std::string > v2_Description, IfcDateTimeSelect* v3_StartTime, IfcDateTimeSelect* v4_EndTime, IfcTimeSeriesDataTypeEnum::IfcTimeSeriesDataTypeEnum v5_TimeSeriesDataType, IfcDataOriginEnum::IfcDataOriginEnum v6_DataOrigin, boost::optional< std::string > v7_UserDefinedDataOrigin, IfcUnit* v8_Unit, IfcTemplatedEntityList< IfcIrregularTimeSeriesValue >::ptr v9_Values);
    typedef IfcTemplatedEntityList< IfcIrregularTimeSeries > list;
};
/// Definition from ISO/CD 10303-46:1992: The light source entity is determined by the reflectance specified in the surface style rendering. Lighting is applied on a surface by surface basis: no interactions between surfaces such as shadows or reflections are defined. 
/// 
/// NOTE: Corresponding STEP entity: light_source. Please refer to ISO/IS 10303-46:1994, p. 31 for the final definition of the formal standard. 
/// 
/// NOTE: In addition to the attributes as defined in ISO10303-46 the following additional properties from ISO/IEC 14772-1:1997 (VRML) are added: ambientIntensity and Intensity. The attribute Name has been added as well (as it is not inherited via representation_item).
/// 
/// HISTORY: This is a new Entity in IFC 2x, renamed and enhanced in IFC2x2.
class IfcLightSource : public IfcGeometricRepresentationItem {
public:
    /// Whether the optional attribute Name is defined for this IfcLightSource
    bool hasName() const;
    /// The name given to the light source in presentation.
    std::string Name() const;
    void setName(std::string v);
    /// Definition from ISO/CD 10303-46:1992: Based on the current lighting model, the colour of the light to be used for shading.
    /// Definition from VRML97 - ISO/IEC 14772-1:1997: The color field specifies the spectral color properties of both the direct and ambient light emission as an RGB value.
    IfcColourRgb* LightColour() const;
    void setLightColour(IfcColourRgb* v);
    /// Whether the optional attribute AmbientIntensity is defined for this IfcLightSource
    bool hasAmbientIntensity() const;
    /// Definition from VRML97 - ISO/IEC 14772-1:1997: The ambientIntensity specifies the intensity of the ambient emission from the light. Light intensity may range from 0.0 (no light emission) to 1.0 (full intensity).
    double AmbientIntensity() const;
    void setAmbientIntensity(double v);
    /// Whether the optional attribute Intensity is defined for this IfcLightSource
    bool hasIntensity() const;
    /// Definition from VRML97 - ISO/IEC 14772-1:1997: The intensity field specifies the brightness of the direct emission from the ligth. Light intensity may range from 0.0 (no light emission) to 1.0 (full intensity).
    double Intensity() const;
    void setIntensity(double v);
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_STRING; case 1: return IfcUtil::Argument_ENTITY_INSTANCE; case 2: return IfcUtil::Argument_DOUBLE; case 3: return IfcUtil::Argument_DOUBLE; } return IfcGeometricRepresentationItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcLabel; case 1: return Type::IfcColourRgb; case 2: return Type::IfcNormalisedRatioMeasure; case 3: return Type::IfcNormalisedRatioMeasure; } return IfcGeometricRepresentationItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Name"; case 1: return "LightColour"; case 2: return "AmbientIntensity"; case 3: return "Intensity"; } return IfcGeometricRepresentationItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcLightSource (IfcAbstractEntity* e);
    IfcLightSource (boost::optional< std::string > v1_Name, IfcColourRgb* v2_LightColour, boost::optional< double > v3_AmbientIntensity, boost::optional< double > v4_Intensity);
    typedef IfcTemplatedEntityList< IfcLightSource > list;
};
/// Definition from ISO/CD 10303-46:1992: The light source ambient entity is a subtype of light source. It lights a surface independent of the surface's orientation and position. 
/// 
/// NOTE: Corresponding ISO 10303 entity: light_source_ambient. Please refer to ISO/IS 10303-46:1994, p. 31 for the final definition of the formal standard.
/// 
/// NOTE: In addition to the attributes as defined in ISO 10303-46 the additional property from ISO/IEC 14772-1:1997 (VRML) AmbientIntensity is inherited from the supertype.
/// 
/// HISTORY: This is a new entity in IFC 2x, renamed and enhanced in IFC2x2.
class IfcLightSourceAmbient : public IfcLightSource {
public:
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcLightSource::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcLightSource::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcLightSource::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcLightSourceAmbient (IfcAbstractEntity* e);
    IfcLightSourceAmbient (boost::optional< std::string > v1_Name, IfcColourRgb* v2_LightColour, boost::optional< double > v3_AmbientIntensity, boost::optional< double > v4_Intensity);
    typedef IfcTemplatedEntityList< IfcLightSourceAmbient > list;
};
/// Definition from ISO/CD 10303-46:1992: The light source directional is a subtype of light source. This entity has a light source direction. With a conceptual origin at infinity, all the rays of the light are parallel to this direction. This kind of light source lights a surface based on the surface's orientation, but not position. 
/// 
/// Definition from ISO/IEC 14772-1:1997: The directional light node defines a directional light source that illuminates along rays parallel to a given 3-dimensional vector. Directional light nodes do not attenuate with distance. Directional light nodes are specified in the local coordinate system and are affected by ancestor transformations. 
/// 
/// NOTE: Corresponding ISO 10303 entity: light_source_directional. Please refer to ISO/IS 10303-46:1994, p. 32 for the final definition of the formal standard.
/// 
/// NOTE: In addition to the attributes as defined in ISO 10303-46 the additional property from ISO/IEC 14772-1:1997 (VRML) AmbientIntensity and Intensity are inherited from the supertype.
/// 
/// HISTORY: This is a new entity in IFC 2x, renamed and enhanced in IFC2x2.
class IfcLightSourceDirectional : public IfcLightSource {
public:
    /// Definition from ISO/CD 10303-46:1992: This direction is the direction of the light source.
    /// Definition from VRML97 - ISO/IEC 14772-1:1997: The direction field specifies the direction vector of the illumination emanating from the light source in the local coordinate system. Light is emitted along parallel rays from an infinite distance away.
    IfcDirection* Orientation() const;
    void setOrientation(IfcDirection* v);
    virtual unsigned int getArgumentCount() const { return 5; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 4: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcLightSource::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 4: return Type::IfcDirection; } return IfcLightSource::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 4: return "Orientation"; } return IfcLightSource::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcLightSourceDirectional (IfcAbstractEntity* e);
    IfcLightSourceDirectional (boost::optional< std::string > v1_Name, IfcColourRgb* v2_LightColour, boost::optional< double > v3_AmbientIntensity, boost::optional< double > v4_Intensity, IfcDirection* v5_Orientation);
    typedef IfcTemplatedEntityList< IfcLightSourceDirectional > list;
};
/// IfcLightSourceGoniometric defines a light source for which exact lighting data is available. It specifies the type of a light emitter, defines the position and orientation of a light distribution curve and the data concerning lamp and photometric information. 
/// 
/// Figure 303 shows an example of a light emitter having two light sources (of type IfcLightSourceGoniometric). 
/// 
/// Figure 303 — Light source goniometric
/// 
/// HISTORY: New entity in IFC2x2.
class IfcLightSourceGoniometric : public IfcLightSource {
public:
    /// The position of the light source. It is used to orientate the light distribution curves.
    IfcAxis2Placement3D* Position() const;
    void setPosition(IfcAxis2Placement3D* v);
    /// Whether the optional attribute ColourAppearance is defined for this IfcLightSourceGoniometric
    bool hasColourAppearance() const;
    /// Artificial light sources are classified in terms of their color appearance. To the human eye they all appear to be white; the difference can only be detected by direct comparison. Visual performance is not directly affected by differences in color appearance.
    IfcColourRgb* ColourAppearance() const;
    void setColourAppearance(IfcColourRgb* v);
    /// The color temperature of any source of radiation is defined as the temperature (in Kelvin) of a black-body or Planckian radiator whose radiation has the same chromaticity as the source of radiation. Often the values are only approximate color temperatures as the black-body radiator cannot emit radiation of every chromaticity value. The color temperatures of the commonest artificial light sources range from less than 3000K (warm white) to 4000K (intermediate) and over 5000K (daylight).
    double ColourTemperature() const;
    void setColourTemperature(double v);
    /// Luminous flux is a photometric measure of radiant flux, i.e. the volume of light emitted from a light source. Luminous flux is measured either for the interior as a whole or for a part of the interior (partial luminous flux for a solid angle). All other photometric parameters are derivatives of luminous flux. Luminous flux is measured in lumens (lm). The luminous flux is given as a nominal value for each lamp.
    double LuminousFlux() const;
    void setLuminousFlux(double v);
    /// Identifies the types of light emitter from which the type required may be set.
    IfcLightEmissionSourceEnum::IfcLightEmissionSourceEnum LightEmissionSource() const;
    void setLightEmissionSource(IfcLightEmissionSourceEnum::IfcLightEmissionSourceEnum v);
    /// The data source from which light distribution data is obtained.
    IfcLightDistributionDataSourceSelect* LightDistributionDataSource() const;
    void setLightDistributionDataSource(IfcLightDistributionDataSourceSelect* v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 4: return IfcUtil::Argument_ENTITY_INSTANCE; case 5: return IfcUtil::Argument_ENTITY_INSTANCE; case 6: return IfcUtil::Argument_DOUBLE; case 7: return IfcUtil::Argument_DOUBLE; case 8: return IfcUtil::Argument_ENUMERATION; case 9: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcLightSource::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 4: return Type::IfcAxis2Placement3D; case 5: return Type::IfcColourRgb; case 6: return Type::IfcThermodynamicTemperatureMeasure; case 7: return Type::IfcLuminousFluxMeasure; case 8: return Type::IfcLightEmissionSourceEnum; case 9: return Type::IfcLightDistributionDataSourceSelect; } return IfcLightSource::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 4: return "Position"; case 5: return "ColourAppearance"; case 6: return "ColourTemperature"; case 7: return "LuminousFlux"; case 8: return "LightEmissionSource"; case 9: return "LightDistributionDataSource"; } return IfcLightSource::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcLightSourceGoniometric (IfcAbstractEntity* e);
    IfcLightSourceGoniometric (boost::optional< std::string > v1_Name, IfcColourRgb* v2_LightColour, boost::optional< double > v3_AmbientIntensity, boost::optional< double > v4_Intensity, IfcAxis2Placement3D* v5_Position, IfcColourRgb* v6_ColourAppearance, double v7_ColourTemperature, double v8_LuminousFlux, IfcLightEmissionSourceEnum::IfcLightEmissionSourceEnum v9_LightEmissionSource, IfcLightDistributionDataSourceSelect* v10_LightDistributionDataSource);
    typedef IfcTemplatedEntityList< IfcLightSourceGoniometric > list;
};
/// Definition from ISO/CD 10303-46:1992: The light source positional entity is a subtype of light source. This entity has a light source position and attenuation coefficients. A positional light source affects a surface based on the surface's orientation and position. 
/// 
/// Definition from ISO/IEC 14772-1:1997: The Point light node specifies a point light source at a 3D location in the local coordinate system. A point light source emits light equally in all directions; that is, it is omnidirectional. Point light nodes are specified in the local coordinate system and are affected by ancestor transformations.  
/// 
/// Point light node's illumination falls off with distance as specified by three attenuation coefficients. The attenuation factor is  
/// 
/// 1/max(attenuation[0] + attenuation[1] × r + attenuation[2] × r 2 , 1), 
/// 
/// where r is the distance from the light to the surface being illuminated. The default is no attenuation. An attenuation value of (0, 0, 0) is identical to (1, 0, 0). Attenuation values shall be greater than or equal to zero.  
/// 
/// NOTE: Corresponding ISO 10303 entity: light_source_positional. Please refer to ISO/IS 10303-46:1994, p. 32 for the final definition of the formal standard.
/// 
/// NOTE: In addition to the attributes as defined in ISO10303-46 the additional property from ISO/IEC 14772-1:1997 (VRML) Radius and QuadricAttenuation are added to this subtype and the AmbientIntensity and Intensity are inherited from the supertype.
/// 
/// HISTORY: This is a new entity in IFC 2x, renamed and enhanced in IFC2x2.
class IfcLightSourcePositional : public IfcLightSource {
public:
    /// Definition from ISO/CD 10303-46:1992: The Cartesian point indicates the position of the light source.
    /// Definition from VRML97 - ISO/IEC 14772-1:1997: A Point light node illuminates geometry within radius of its location.
    IfcCartesianPoint* Position() const;
    void setPosition(IfcCartesianPoint* v);
    /// Definition from IAI: The maximum distance from the light source for a surface still to be illuminated.
    /// Definition from VRML97 - ISO/IEC 14772-1:1997: A Point light node illuminates geometry within radius of its location.
    double Radius() const;
    void setRadius(double v);
    /// Definition from ISO/CD 10303-46:1992: This real indicates the value of the attenuation in the lighting equation that is constant.
    double ConstantAttenuation() const;
    void setConstantAttenuation(double v);
    /// Definition from ISO/CD 10303-46:1992: This real indicates the value of the attenuation in the lighting equation that proportional to the distance from the light source.
    double DistanceAttenuation() const;
    void setDistanceAttenuation(double v);
    /// Definition from the IAI: This real indicates the value of the attenuation in the lighting equation that proportional to the square value of the distance from the light source.
    double QuadricAttenuation() const;
    void setQuadricAttenuation(double v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 4: return IfcUtil::Argument_ENTITY_INSTANCE; case 5: return IfcUtil::Argument_DOUBLE; case 6: return IfcUtil::Argument_DOUBLE; case 7: return IfcUtil::Argument_DOUBLE; case 8: return IfcUtil::Argument_DOUBLE; } return IfcLightSource::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 4: return Type::IfcCartesianPoint; case 5: return Type::IfcPositiveLengthMeasure; case 6: return Type::IfcReal; case 7: return Type::IfcReal; case 8: return Type::IfcReal; } return IfcLightSource::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 4: return "Position"; case 5: return "Radius"; case 6: return "ConstantAttenuation"; case 7: return "DistanceAttenuation"; case 8: return "QuadricAttenuation"; } return IfcLightSource::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcLightSourcePositional (IfcAbstractEntity* e);
    IfcLightSourcePositional (boost::optional< std::string > v1_Name, IfcColourRgb* v2_LightColour, boost::optional< double > v3_AmbientIntensity, boost::optional< double > v4_Intensity, IfcCartesianPoint* v5_Position, double v6_Radius, double v7_ConstantAttenuation, double v8_DistanceAttenuation, double v9_QuadricAttenuation);
    typedef IfcTemplatedEntityList< IfcLightSourcePositional > list;
};
/// Definition from ISO/CD 10303-46:1992: The light source spot entity is a subtype of light source. Spot light source entities have a light source colour, position, direction, attenuation coefficients, concentration exponent, and spread angle. If a point lies outside the cone of influence of a light source of this type as determined by the light source position, direction and spread angle its colour is not affected by that light source. 
/// 
/// NOTE  The IfcLightSourceSpot adds the BeamWidthAngle which defines the inner cone in which the light source emits light at uniform full intensity. The light source's emission intensity drops off from the inner solid angle (BeamWidthAngle) to the outer solid angle (SpreadAngle).
/// 
/// Definition from ISO/IEC 14772-1:1997: The Spot light node defines a light source that emits light from a specific point along a specific direction vector and constrained within a solid angle. Spot lights may illuminate geometry nodes that respond to light sources and intersect the solid angle defined by the Spot light. Spot light nodes are specified in the local coordinate system and are affected by ancestors' transformations. 
/// 
/// Figure 304 (from VRML97) shows the definition of spot light. 
/// 
/// Figure 304 — Light source spot
/// 
/// NOTE  Corresponding ISO 10303 entity: light_source_spot. Please refer to ISO/IS 10303-46:1994, p. 33 for the final definition of the formal standard.
/// 
/// NOTE  In addition to the attributes as defined in ISO10303-46 the additional property from ISO/IEC 14772-1:1997 (VRML) Radius, BeamWidth, and QuadricAttenuation are added to this subtype and the AmbientIntensity and Intensity are inherited from the supertype.
/// 
/// HISTORY  This is a new entity in IFC 2x, renamed and enhanced in IFC2x2.
class IfcLightSourceSpot : public IfcLightSourcePositional {
public:
    /// Definition from ISO/CD 10303-46:1992: This is the direction of the axis of the cone of the light source specified in the coordinate space of the representation being projected..
    /// Definition from VRML97 - ISO/IEC 14772-1:1997: The direction field specifies the direction vector of the light's central axis defined in the local coordinate system.
    IfcDirection* Orientation() const;
    void setOrientation(IfcDirection* v);
    /// Whether the optional attribute ConcentrationExponent is defined for this IfcLightSourceSpot
    bool hasConcentrationExponent() const;
    /// Definition from ISO/CD 10303-46:1992: This real is the exponent on the cosine of the angle between the line that starts at the position of the spot light source and is in the direction of the orientation of the spot light source and a line that starts at the position of the spot light source and goes through a point on the surface being shaded.
    /// NOTE: This attribute does not exists in ISO/IEC 14772-1:1997.
    double ConcentrationExponent() const;
    void setConcentrationExponent(double v);
    /// Definition from ISO/CD 10303-46:1992: This planar angle measure is the angle between the line that starts at the position of the spot light source and is in the direction of the spot light source and any line on the boundary of the cone of influence.
    /// Definition from VRML97 - ISO/IEC 14772-1:1997: The cutOffAngle (name of spread angle in VRML) field specifies the outer bound of the solid angle. The light source does not emit light outside of this solid angle.
    double SpreadAngle() const;
    void setSpreadAngle(double v);
    /// Definition from VRML97 - ISO/IEC 14772-1:1997: The beamWidth field specifies an inner solid angle in which the light source emits light at uniform full intensity. The light source's emission intensity drops off from the inner solid angle (beamWidthAngle) to the outer solid angle (spreadAngle).
    double BeamWidthAngle() const;
    void setBeamWidthAngle(double v);
    virtual unsigned int getArgumentCount() const { return 13; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENTITY_INSTANCE; case 10: return IfcUtil::Argument_DOUBLE; case 11: return IfcUtil::Argument_DOUBLE; case 12: return IfcUtil::Argument_DOUBLE; } return IfcLightSourcePositional::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcDirection; case 10: return Type::IfcReal; case 11: return Type::IfcPositivePlaneAngleMeasure; case 12: return Type::IfcPositivePlaneAngleMeasure; } return IfcLightSourcePositional::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "Orientation"; case 10: return "ConcentrationExponent"; case 11: return "SpreadAngle"; case 12: return "BeamWidthAngle"; } return IfcLightSourcePositional::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcLightSourceSpot (IfcAbstractEntity* e);
    IfcLightSourceSpot (boost::optional< std::string > v1_Name, IfcColourRgb* v2_LightColour, boost::optional< double > v3_AmbientIntensity, boost::optional< double > v4_Intensity, IfcCartesianPoint* v5_Position, double v6_Radius, double v7_ConstantAttenuation, double v8_DistanceAttenuation, double v9_QuadricAttenuation, IfcDirection* v10_Orientation, boost::optional< double > v11_ConcentrationExponent, double v12_SpreadAngle, double v13_BeamWidthAngle);
    typedef IfcTemplatedEntityList< IfcLightSourceSpot > list;
};
/// IfcLocalPlacement defines the relative placement of a product in relation to the
/// placement of another product or the absolute placement of a product within the geometric representation context of the project. 
/// IfcLocalPlacement allows that an IfcProduct can be placed by this IfcLocalPlacement (through
/// the attributeObjectPlacement) within the local coordinate system of the object placement of another IfcProduct,
/// which is referenced by the PlacementRelTo. Rules to prevent cyclic relative placements have to be introduced on the
/// application level.
/// If the PlacementRelTo is not given, then
/// the IfcProduct is placed absolutely within the
/// world coordinate system.
/// 
/// HISTORY: New entity in IFC Release 1.0.
/// 
/// Geometry use definitions
/// The following conventions shall apply as default relative positions if the relative placement is used. The conventions are given for all five direct subtypes of IfcProduct, the IfcSpatialStructureElement, IfcElement, IfcAnnotation, IfcGrid, IfcPort. More detailed placement information is given at the level of subtypes of those five types mentioned.
/// 
/// For the subtypes of IfcSpatialStructureElement the following conventions apply
/// 
/// IfcSite shall be placed absolutely within the world coordinate system established by the geometric
/// representation context of the IfcProject 
///   IfcBuilding shall be placed relative to the local placement of IfcSite 
///   IfcBuildingStorey shall be placed relative to the local placement of IfcBuilding 
/// 
/// For IfcGrid and IfcAnnotation the convention applies that it shall be placed relative
/// 
/// to the local placement of its container (IfcSite, IfcBuilding, IfcBuildingStorey)
/// 
/// it should be the same container element that is referenced by the IfcRelContainedInSpatialStructure
/// containment relationship,
/// 
/// For IfcPort the convention applies that it shall be placed relative
/// 
/// to the local placement of the element it belongs to (IfcElement)
/// 
/// it should be the same element that is referenced by the IfcRelConnectsPortToElement connection
/// relationship,
/// 
/// For IfcElement the convention applies that it shall be placed relative:
/// 
/// to the local placement of its container (IfcSite, IfcBuilding, IfcBuildingStorey)
/// 
/// it should be the same container element that is referenced by the IfcRelContainedInSpatialStructure
/// containment relationship,
/// 
/// to the local placement of the IfcElement to which it is tied by an element composition relationship
/// 
/// for features that are located relative to the main component (such as openings), as expressed by IfcRelVoidsElement and IfcRelProjectsElement,
///   for elements that fill an opening (such as doors or windows), as expressed byIfcRelFillsElement,
///   for coverings that cover the element, as expressed byIfcRelCoversBldgElements,
///   for sub components that are aggregated to the main component, as expressed by  IIfcRelAggregates and IfcRelNests)
/// 
/// If the PlacementRelTo relationship is not given, then it defaults to an absolute placement within the world
/// coordinate system established by the referenced geometric representation context within the project.
class IfcLocalPlacement : public IfcObjectPlacement {
public:
    /// Whether the optional attribute PlacementRelTo is defined for this IfcLocalPlacement
    bool hasPlacementRelTo() const;
    /// Reference to Object that provides the relative placement by its local coordinate system. If it is omitted, then the local placement is given to the WCS, established by the geometric representation context.
    IfcObjectPlacement* PlacementRelTo() const;
    void setPlacementRelTo(IfcObjectPlacement* v);
    /// Geometric placement that defines the transformation from the related coordinate system into the relating. The placement can be either 2D or 3D, depending on the dimension count of the coordinate system.
    IfcAxis2Placement* RelativePlacement() const;
    void setRelativePlacement(IfcAxis2Placement* v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcObjectPlacement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcObjectPlacement; case 1: return Type::IfcAxis2Placement; } return IfcObjectPlacement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "PlacementRelTo"; case 1: return "RelativePlacement"; } return IfcObjectPlacement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcLocalPlacement (IfcAbstractEntity* e);
    IfcLocalPlacement (IfcObjectPlacement* v1_PlacementRelTo, IfcAxis2Placement* v2_RelativePlacement);
    typedef IfcTemplatedEntityList< IfcLocalPlacement > list;
};
/// Definition from ISO/CD 10303-42:1992: A loop is a topological
///   entity constructed from a single vertex, or by stringing together connected
///   (oriented) edges, or linear segments beginning and ending at the same vertex.
///   It is typically used to bound a face lying on a surface. A loop has
///   dimensionality of 0 or 1. The domain of a 0-dimensional loop is a single point.
///   The domain of a 1-dimensional loop is a connected, oriented curve, but need not
///   to be manifold. As the loop is a circle, the location of its beginning/ending
///   point is arbitrary. The domain of the loop includes its bounds, an 0 ≤ Ξ
///   < ∞.  
///   A loop is represented by a single vertex, or by an ordered collection of
///   oriented edges, or by an ordered collection of points. A loop is a graph, so
///   M and the graph genus Gl may be determined by the
///   graph traversal algorithm. Since M = 1, the Euler equation (1) reduces
///   in this case to  
/// 
/// where V and El are the number of unique
///   vertices and oriented edges in the loop and Gl is the genus
///   of the loop.  
///   NOTE  Corresponding ISO 10303 entity: loop, the following subtypes have been incorporated into IFC: poly_loop as IfcPolyLoop, vertex_loop as IfcVertexLoop, edge_loop as IfcEdgeLoop. Please refer to ISO/IS 10303-42:1994, p. 136 for the final definition of the formal standard. 
/// 
/// HISTORY  New Entity in IFC2x. 
///   Informal propositions: 
/// 
/// A loop has a finite extent. 
///   A loop describes a closed (topological) curve with coincident start
///   and end vertices.
class IfcLoop : public IfcTopologicalRepresentationItem {
public:
    virtual unsigned int getArgumentCount() const { return 0; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcTopologicalRepresentationItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcTopologicalRepresentationItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcTopologicalRepresentationItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcLoop (IfcAbstractEntity* e);
    IfcLoop ();
    typedef IfcTemplatedEntityList< IfcLoop > list;
};
/// Definition from ISO/CD 10303-43:1992: A mapped item is the use of an existing representation (the mapping source - mapped representation) as a representation item in a second representation. 
/// 
/// NOTE: A mapped item is a subtype of representation item. It enables a representation to be used as a representation item in one or more other representations. The mapped item allows for the definition of a representation using other representations. 
/// 
/// The IfcMappedItem is the inserted instance of a source definition (to be compared with a
/// block / shared cell / macro definition). The instance is inserted by applying a Cartesian transformation operator as the MappingTarget.
/// 
/// EXAMPLE  An IfcMappedItem can reuse other mapped items (ako nested blocks), doing so the IfcRepresentationMap is based on an IfcShapeRepresentation including one or more IfcMappedItem's.
/// 
/// NOTE   Corresponding ISO 10303 entity: mapped_item. Please refer to ISO/IS
/// 10303-43:1994, for the final definition of the formal standard. The definition of mapping_target (MappingTarget) has been restricted to be of the type cartesian_transformation_operator
/// (IfcCartesianTransformationOperator).
/// 
/// HISTORY  New entity in IFC Release 2x.
/// 
/// Informal Propositions
/// 
/// A mapped item shall not be self-defining by participating in the definition of the representation being mapped.
///   The dimensionality of the mapping source and the mapping target has to be the same, if the mapping source is a geometric representation item.
class IfcMappedItem : public IfcRepresentationItem {
public:
    /// A representation map that is the source of the mapped item. It can be seen as a block (or cell or marco) definition.
    IfcRepresentationMap* MappingSource() const;
    void setMappingSource(IfcRepresentationMap* v);
    /// A representation item that is the target onto which the mapping source is mapped. It is constraint to be a Cartesian transformation operator.
    IfcCartesianTransformationOperator* MappingTarget() const;
    void setMappingTarget(IfcCartesianTransformationOperator* v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcRepresentationItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcRepresentationMap; case 1: return Type::IfcCartesianTransformationOperator; } return IfcRepresentationItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "MappingSource"; case 1: return "MappingTarget"; } return IfcRepresentationItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcMappedItem (IfcAbstractEntity* e);
    IfcMappedItem (IfcRepresentationMap* v1_MappingSource, IfcCartesianTransformationOperator* v2_MappingTarget);
    typedef IfcTemplatedEntityList< IfcMappedItem > list;
};
/// IfcMaterialDefinitionRepresentation defines presentation information relating to IfcMaterial. It allows for multiple presentations of the same material for different geometric representation contexts.
/// 
/// NOTE  The IfcMaterialDefinitionRepresentation is currently only used
/// to define presentation information to material used at element
/// occurrences, defined as subtypes of IfcElement, or at
/// element types, defined as subtypes of IfcElementType. The
/// IfcMaterial is assigned to the subtype of
/// IfcElement, or IfcElementType using the
/// IfcRelAssociatesMaterial relationship (eventually via
/// other material related entities IfcMaterialLayerSetUsage,
/// IfcMaterialLayerSet, IfcMaterialLayer, or
/// IfcMaterialProfileSetUsage, IfcMaterialProfileSet,
/// IfcMaterialProfile).
/// 
/// The IfcMaterialDefinitionRepresentation can apply
/// 
/// different presentation styles for different representation contexts, for example, a different style for sketch view, model view or plan view, or for different target scales,
/// for each representation context is can apply curve style, fill area style (hatching), symbol, text and surface style.
/// 
/// HISTORY  New entity in IFC2x3.
/// 
/// IFC2x3 CHANGE  The entity IfcMaterialDefinitionRepresentation has been added. Upward compatibility for file based exchange is guaranteed.
/// 
/// IFC2x4 CHANGE  The assignment of curve, surface and other styles to an IfcStyledItem has been simplified by IfcStyleAssignmentSelect. The use of intermediate IfcPresentationStyleAssignment is deprecated.
/// 
/// Use definition
/// 
/// As shown in Figure 331, the presentation assignment can be specific to a representation context by adding one and more IfcStyledRepresentation's. Each of them includes a single IfcStyledItem with exactly zero or one style for either curve, fill area, surface, text or symbol style that is applicable.
/// 
/// Figure 331 — Material definition representation
class IfcMaterialDefinitionRepresentation : public IfcProductRepresentation {
public:
    /// Reference to the material to which the representation applies.
    IfcMaterial* RepresentedMaterial() const;
    void setRepresentedMaterial(IfcMaterial* v);
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 3: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcProductRepresentation::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 3: return Type::IfcMaterial; } return IfcProductRepresentation::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 3: return "RepresentedMaterial"; } return IfcProductRepresentation::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcMaterialDefinitionRepresentation (IfcAbstractEntity* e);
    IfcMaterialDefinitionRepresentation (boost::optional< std::string > v1_Name, boost::optional< std::string > v2_Description, IfcTemplatedEntityList< IfcRepresentation >::ptr v3_Representations, IfcMaterial* v4_RepresentedMaterial);
    typedef IfcTemplatedEntityList< IfcMaterialDefinitionRepresentation > list;
};

class IfcMechanicalConcreteMaterialProperties : public IfcMechanicalMaterialProperties {
public:
    /// Whether the optional attribute CompressiveStrength is defined for this IfcMechanicalConcreteMaterialProperties
    bool hasCompressiveStrength() const;
    double CompressiveStrength() const;
    void setCompressiveStrength(double v);
    /// Whether the optional attribute MaxAggregateSize is defined for this IfcMechanicalConcreteMaterialProperties
    bool hasMaxAggregateSize() const;
    double MaxAggregateSize() const;
    void setMaxAggregateSize(double v);
    /// Whether the optional attribute AdmixturesDescription is defined for this IfcMechanicalConcreteMaterialProperties
    bool hasAdmixturesDescription() const;
    std::string AdmixturesDescription() const;
    void setAdmixturesDescription(std::string v);
    /// Whether the optional attribute Workability is defined for this IfcMechanicalConcreteMaterialProperties
    bool hasWorkability() const;
    std::string Workability() const;
    void setWorkability(std::string v);
    /// Whether the optional attribute ProtectivePoreRatio is defined for this IfcMechanicalConcreteMaterialProperties
    bool hasProtectivePoreRatio() const;
    double ProtectivePoreRatio() const;
    void setProtectivePoreRatio(double v);
    /// Whether the optional attribute WaterImpermeability is defined for this IfcMechanicalConcreteMaterialProperties
    bool hasWaterImpermeability() const;
    std::string WaterImpermeability() const;
    void setWaterImpermeability(std::string v);
    virtual unsigned int getArgumentCount() const { return 12; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 6: return IfcUtil::Argument_DOUBLE; case 7: return IfcUtil::Argument_DOUBLE; case 8: return IfcUtil::Argument_STRING; case 9: return IfcUtil::Argument_STRING; case 10: return IfcUtil::Argument_DOUBLE; case 11: return IfcUtil::Argument_STRING; } return IfcMechanicalMaterialProperties::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 6: return Type::IfcPressureMeasure; case 7: return Type::IfcPositiveLengthMeasure; case 8: return Type::IfcText; case 9: return Type::IfcText; case 10: return Type::IfcNormalisedRatioMeasure; case 11: return Type::IfcText; } return IfcMechanicalMaterialProperties::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 6: return "CompressiveStrength"; case 7: return "MaxAggregateSize"; case 8: return "AdmixturesDescription"; case 9: return "Workability"; case 10: return "ProtectivePoreRatio"; case 11: return "WaterImpermeability"; } return IfcMechanicalMaterialProperties::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcMechanicalConcreteMaterialProperties (IfcAbstractEntity* e);
    IfcMechanicalConcreteMaterialProperties (IfcMaterial* v1_Material, boost::optional< double > v2_DynamicViscosity, boost::optional< double > v3_YoungModulus, boost::optional< double > v4_ShearModulus, boost::optional< double > v5_PoissonRatio, boost::optional< double > v6_ThermalExpansionCoefficient, boost::optional< double > v7_CompressiveStrength, boost::optional< double > v8_MaxAggregateSize, boost::optional< std::string > v9_AdmixturesDescription, boost::optional< std::string > v10_Workability, boost::optional< double > v11_ProtectivePoreRatio, boost::optional< std::string > v12_WaterImpermeability);
    typedef IfcTemplatedEntityList< IfcMechanicalConcreteMaterialProperties > list;
};
/// An IfcObjectDefinition is the generalization of any
/// semantically treated thing or process, either being a type or an
/// occurrences. Object defintions can be named, using the inherited
/// Name attribute, which should be a user recognizable label
/// for the object occurrance. Further explanations to the object can
/// be given using the inherited Description attribute. A
/// context is a specific kind of object definition as it provides the
/// project or library context in which object types and object
/// occurrences are defined.
/// Objects are independent pieces of information that might contain
/// or reference other pieces of information. There are four essential
/// kinds of relationships in which object definitons (by their
/// instantiable subtypes) can be involved:
/// 
/// Assignment of other objects - an assignment relationship
/// (IfcRelAssigns) that refers to other types of objects and
/// creates a bi-directional association. The semantic of the
/// assignment is established at the level of the subtypes of the
/// general IfcRelAssigns relationship. There is no dependency
/// implied a priori by the assignment.
/// Association to external resources - an association
/// relationship (IfcRelAssociates) that refers to external
/// sources of information (most notably a classification or document)
/// and creates a uni-directional association. There is no dependency
/// implied by the association.
/// Aggregation of other objects - an aggregation
/// relationship (IfcRelAggregates) that establishes an
/// unordered, spatial whole/part relation and creates a bi-directional
/// relation. There is an implied dependency established.
/// Nesting of other objects - a nesting relationship
/// (IfcRelNests) that establishes an ordered, non-spatial
/// whole/part relation and creates a bi-directional relation. There is
/// an implied dependency established.
/// Declaration within a context - a relationship
/// (IfcRelDeclares) of the uppermost object definition within
/// the object definition tree (e.g. the summary object within an
/// object nesting tree) to the context (a project or project library).
/// It applies the units, representation context and other context
/// information to this object definition and all dependent ones.
/// 
/// EXCEPTION  The link
/// between the uppermost object in the spatial structure tree, that is
/// IfcSite or ifcBuilding, and the context provided
/// by IfcProject is created using the
/// IfcRelAggregates relationship. See IfcProject for
/// more information.
/// 
/// HISTORY New abstract entity in IFC2x3.
/// 
/// IFC2x4 CHANGE The new subtype IfcContext and the relationship to context HasContext has been added . The decomposition relationship is split into ordered nesting (Nests, IsNestedBy) and un-ordered aggregating (Decomposes, IsDecomposedBy).
class IfcObjectDefinition : public IfcRoot {
public:
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcRoot::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcRoot::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcRoot::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcRelAssigns >::ptr HasAssignments() const; // INVERSE IfcRelAssigns::RelatedObjects
    IfcTemplatedEntityList< IfcRelDecomposes >::ptr IsDecomposedBy() const; // INVERSE IfcRelDecomposes::RelatingObject
    IfcTemplatedEntityList< IfcRelDecomposes >::ptr Decomposes() const; // INVERSE IfcRelDecomposes::RelatedObjects
    IfcTemplatedEntityList< IfcRelAssociates >::ptr HasAssociations() const; // INVERSE IfcRelAssociates::RelatedObjects
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcObjectDefinition (IfcAbstractEntity* e);
    IfcObjectDefinition (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description);
    typedef IfcTemplatedEntityList< IfcObjectDefinition > list;
};
/// Definition from ISO/CD 10303-46:1992: A one time repeat factor is a vector used in the fill area style hatching and fill area style tiles entities for determining the origin of the repeated hatch line relative to the origin of the previous hatch line, Given the initial position of any hatch line, the one direction repeat factor determines two new positions according to the equation: 
/// 
/// I + k * R    k X{-1,1}
/// 
/// NOTE: Corresponding ISO 10303 name: one_direction_repeat_factor. Please refer to ISO/IS 10303-46:1994, p. 112 for the final definition of the formal standard.
/// 
/// HISTORY: New entity in IFC2x2.
class IfcOneDirectionRepeatFactor : public IfcGeometricRepresentationItem {
public:
    /// A vector which specifies the relative positioning of hatch lines.
    IfcVector* RepeatFactor() const;
    void setRepeatFactor(IfcVector* v);
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcGeometricRepresentationItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcVector; } return IfcGeometricRepresentationItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "RepeatFactor"; } return IfcGeometricRepresentationItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcOneDirectionRepeatFactor (IfcAbstractEntity* e);
    IfcOneDirectionRepeatFactor (IfcVector* v1_RepeatFactor);
    typedef IfcTemplatedEntityList< IfcOneDirectionRepeatFactor > list;
};
/// Definition from ISO/CD 10303-42:1992: An open shell is a shell of
///   the dimensionality 2. Its domain, if present, is a finite, connected, oriented,
///   2-manifold with boundary, but is not a closed surface. It can be thought of as
///   a closed shell with one or more holes punched in it. The domain of an open
///   shell satisfies 0
///   < Ξ < 1. An open shell is
///   functionally more general than a face because its domain can have handles. 
///   The shell is defined by a collection of faces, which may be oriented
///   faces. The sense of each face, after taking account of the orientation, shall
///   agree with the shell normal as defined below. The orientation can be supplied
///   directly as a BOOLEAN attribute of an oriented face, or be defaulted to TRUE if
///   the shell member is a face without the orientation attribute. 
///   The following combinatorial restrictions on open shells and geometrical
///   restrictions on their domains are designed, together with the informal
///   propositions, to ensure that any domain associated with an open shell is an
///   orientable manifold. 
/// 
/// Each face reference shall be unique.  
///   An open shell shall have at least one face.  
///   A given face may exist in more than one open shell. 
/// 
/// The boundary of an open shell consists of the edges that are referenced
///   only once by the face - bounds (loops) of its faces, together with all of their
///   vertices. The domain of an open shell, if present, contains all edges and
///   vertices of its faces. 
/// 
/// NOTE  Note that this is slightly different from the
///   definition of a face domain, which includes none of its bounds. For example, a
///   face domain may exclude an isolated point or line segment. An open shell domain
///   may not. (See the algorithm for computing below.) 
///   In the current IFC Release only poly loops
///   (IfcPolyLoop) are defined for bounds of face bound
///   (IfcFaceBound.Bound). This will allow for faceted B-rep only. For
///   further specification, including the Euler formulas to be satisfied, please
///   refer to ISO 10303-42:1994. 
/// 
/// NOTE  Corresponding ISO 10303 entity:
///   open_shell, please refer to ISO/IS 10303-42:1994, p.148 for the final
///   definition of the formal standard.
/// 
/// HISTORY  New class in IFC2x.
/// 
/// Informal propositions: 
/// 
/// Every edge shall be referenced exactly twice by the face bounds of
///   the face.  
///   Each oriented edge shall be unique.  
///   No edge shall be referenced by more than two faces.  
///   Distinct faces of the shell do not intersect, but may share edges or
///   vertices.  
///   Distinct edges do not intersect but may share vertices.  
///   Each face reference shall be unique.  
///   The loops of the shell shall not be a mixture of poly loop and other
///   loop types. Note: this is given, since only poly loop is defined as face bound
///   definition.  
///   The closed shell shall be an oriented arcwise connected 2-manifold.
/// 
/// The Euler equation shall be satisfied. Note: Please refer to ISO/IS
///   10303-42:1994, p.148 for the equation.
class IfcOpenShell : public IfcConnectedFaceSet {
public:
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcConnectedFaceSet::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcConnectedFaceSet::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcConnectedFaceSet::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcOpenShell (IfcAbstractEntity* e);
    IfcOpenShell (IfcTemplatedEntityList< IfcFace >::ptr v1_CfsFaces);
    typedef IfcTemplatedEntityList< IfcOpenShell > list;
};
/// Definition from ISO/CD 10303-42:1992: An oriented edge is an edge constructed from another edge and contains a BOOLEAN direction flag to indicate whether or not the orientation of the constructed edge agrees with the orientation of the original edge. Except for perhaps orientation, the oriented edge is equivalent to the original edge.  
/// 
/// NOTE  A common practice is solid modelling systems is to have an entity that represents the "use" or "traversal" of an edge. This "use" entity explicitly represents the requirement in a manifold solid that each edge must be traversed exactly twice, once in each direction. The "use" functionality is provided by the edge subtype oriented edge.
/// 
/// NOTE  Corresponding ISO 10303 entity: oriented_edge. Please refer to ISO/IS 10303-42:1994, p. 133 for the final definition of the formal standard.
/// 
/// HISTORY  New Entity in IFC Release 2.0.
class IfcOrientedEdge : public IfcEdge {
public:
    /// Edge entity used to construct this oriented edge.
    IfcEdge* EdgeElement() const;
    void setEdgeElement(IfcEdge* v);
    /// BOOLEAN, If TRUE the topological orientation as used coincides with the orientation from start vertex to end vertex of the edge element. If FALSE otherwise.
    bool Orientation() const;
    void setOrientation(bool v);
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 2: return IfcUtil::Argument_ENTITY_INSTANCE; case 3: return IfcUtil::Argument_BOOL; } return IfcEdge::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 2: return Type::IfcEdge; case 3: return Type::UNDEFINED; } return IfcEdge::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 2: return "EdgeElement"; case 3: return "Orientation"; } return IfcEdge::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcOrientedEdge (IfcAbstractEntity* e);
    IfcOrientedEdge (IfcEdge* v3_EdgeElement, bool v4_Orientation);
    typedef IfcTemplatedEntityList< IfcOrientedEdge > list;
};
/// The parameterized profile definition
/// defines a 2D position coordinate system to which the parameters of the
/// different profiles relate to. All profiles are defined centric to the
/// origin of the position coordinate system, or more specific, the origin
/// [0.,0.] shall be in the center of the bounding box of the profile.
/// 
/// The Position attribute of IfcParameterizedProfileDef
/// is used to position the profile within the XY plane of the underlying
/// coordinate system of the swept surface geometry, the swept area
/// solid or the sectioned spine. It can be used to position the profile at
/// any point which becomes the origin [0.,0.,0.] of the extruded
/// or rotated surface or solid.
/// 
/// The Position attribute should not be used if the transformation
/// can be specified in a containing object instead.  In particular, this
/// applies if the IfcParameterizedProfileDef is referenced as
/// SweptArea in subtypes of IfcSweptAreaSolid or as
/// CrossSections in IfcSectionedSpine.
/// 
/// Several subtypes of IfcParameterizedProfileDef provide
/// shape parameters which are optional. Sending systems should always
/// provide values for these parameters if possible. If these parameters
/// are left unspecified, receiving systems may retrieve values for them
/// by external reference (if a reference to an external document or library
/// is given; see guidance at IfcProfileDef), or estimate them, or
/// simply assume zero values.
/// 
/// HISTORY  New entity in IFC2x2.
/// 
/// IFC2x Platform CHANGE  The IfcParameterizedProfileDef
/// is introduced as an intermediate new abstract entity that unifies the
/// definition and usage of the position coordinate system for all
/// parameterized profiles. The Position attribute has been removed at all
/// subtypes (like IfcRectangleProfileDef, IfcCircleProfileDef,
/// etc.).
/// 
/// IFC2x3 CHANGE  All profile origins are now in the center
/// of the bounding box.
/// 
/// IFC2x4 CHANGE  Position attribute made optional (default: identity transformation).
/// Several radius parameters in subtypes have been changed from optional IfcPositiveLengthMeasure (assumed default: 0.) to optional IfcNonNegativeLengthMeasure (default: unspecified).  This change allows to explicitly specify zero radius.  Sending systems shall export 0. values if parameters are known to be 0.
/// Subtypes IfcCraneRailAShapeProfileDef and IfcCraneRailFShapeProfileDef deleted.  Rail profiles shall be modeled as IfcArbitraryClosedProfileDef or as IfcAsymmetricIShapeProfileDef together with appropriate external reference.
class IfcParameterizedProfileDef : public IfcProfileDef {
public:
    /// Position coordinate system of the parameterized profile definition. If unspecified, no translation and no rotation is applied.
    IfcAxis2Placement2D* Position() const;
    void setPosition(IfcAxis2Placement2D* v);
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 2: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcProfileDef::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 2: return Type::IfcAxis2Placement2D; } return IfcProfileDef::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 2: return "Position"; } return IfcProfileDef::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcParameterizedProfileDef (IfcAbstractEntity* e);
    IfcParameterizedProfileDef (IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< std::string > v2_ProfileName, IfcAxis2Placement2D* v3_Position);
    typedef IfcTemplatedEntityList< IfcParameterizedProfileDef > list;
};
/// Definition from ISO/CD 10303-42:1992: A path is a topological entity consisting of an ordered collection of oriented edges, such that the edge start vertex of each edge coincides with the edge end of its predecessor. The path is ordered from the edge start of the first oriented edge to the edge end of the last edge. The BOOLEAN value sense in the oriented edge indicates whether the edge direction agrees with the direction of the path (TRUE) or is the opposite direction (FALSE).  
/// 
/// An individual edge can only be referenced once by an individual path. An edge can be referenced by multiple paths. An edge can exist independently of a path.  
/// 
/// NOTE  Corresponding ISO 10303 entity: path. Please refer to ISO/IS 10303-42:1994, p. 133 for the final definition of the formal standard.
/// 
/// HISTORY  New Entity in IFC Release 2.0
/// 
/// Informal proposition:
/// 
/// A path has dimensionality 1.
/// A path is arcwise connected.
/// The edges of the path do not intersect except at common vertices.
/// A path has a finite, non-zero extent.
class IfcPath : public IfcTopologicalRepresentationItem {
public:
    /// The list of oriented edges which are concatenated together to form this path.
    IfcTemplatedEntityList< IfcOrientedEdge >::ptr EdgeList() const;
    void setEdgeList(IfcTemplatedEntityList< IfcOrientedEdge >::ptr v);
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } return IfcTopologicalRepresentationItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcOrientedEdge; } return IfcTopologicalRepresentationItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "EdgeList"; } return IfcTopologicalRepresentationItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPath (IfcAbstractEntity* e);
    IfcPath (IfcTemplatedEntityList< IfcOrientedEdge >::ptr v1_EdgeList);
    typedef IfcTemplatedEntityList< IfcPath > list;
};
/// The complex physical quantity, IfcPhysicalComplexQuantity, is an entity that holds a set of single quantity measure value (as defined at the subtypes of IfcPhysicalSimpleQuantity), that all apply to a given component or aspect of the element. 
/// 
/// EXAMPLE: A layered element, like a wall, may have several material layers, each having individual quantities, like footprint area, side area and volume. An instance of IfcPhysicalComplexQuantity would group these individual quantities (given by a subtype of IfcPhysicalSimpleQuantity) and name them according to the material layer name by using the Name attribute. The Discrimination attribute would then be 'layer'.
/// 
/// A section "Quantity Use Definition" at individual entities as subtypes of IfcBuildingElement gives guidance to the usage of the Name and Discrimination attribute to characterize the complex quantities.
/// 
/// HISTORY  New entity in IFC2x2 Addendum 1.
/// 
/// IFC2x2 ADDENDUM 1 CHANGE  The entity IfcPhysicalComplexQuantity has been added. Upward compatibility for file based exchange is guaranteed.
class IfcPhysicalComplexQuantity : public IfcPhysicalQuantity {
public:
    /// Set of physical quantities that are grouped by this complex physical quantity according to a given discrimination.
    IfcTemplatedEntityList< IfcPhysicalQuantity >::ptr HasQuantities() const;
    void setHasQuantities(IfcTemplatedEntityList< IfcPhysicalQuantity >::ptr v);
    /// Identification of the discrimination by which this physical complex property is distinguished. Examples of discriminations are 'layer', 'steel bar diameter', etc.
    std::string Discrimination() const;
    void setDiscrimination(std::string v);
    /// Whether the optional attribute Quality is defined for this IfcPhysicalComplexQuantity
    bool hasQuality() const;
    /// Additional indication of a quality of the quantities that are grouped under this physical complex quantity.
    std::string Quality() const;
    void setQuality(std::string v);
    /// Whether the optional attribute Usage is defined for this IfcPhysicalComplexQuantity
    bool hasUsage() const;
    /// Additional indication of a usage type of the quantities that are grouped under this physical complex quantity.
    std::string Usage() const;
    void setUsage(std::string v);
    virtual unsigned int getArgumentCount() const { return 6; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 2: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 3: return IfcUtil::Argument_STRING; case 4: return IfcUtil::Argument_STRING; case 5: return IfcUtil::Argument_STRING; } return IfcPhysicalQuantity::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 2: return Type::IfcPhysicalQuantity; case 3: return Type::IfcLabel; case 4: return Type::IfcLabel; case 5: return Type::IfcLabel; } return IfcPhysicalQuantity::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 2: return "HasQuantities"; case 3: return "Discrimination"; case 4: return "Quality"; case 5: return "Usage"; } return IfcPhysicalQuantity::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPhysicalComplexQuantity (IfcAbstractEntity* e);
    IfcPhysicalComplexQuantity (std::string v1_Name, boost::optional< std::string > v2_Description, IfcTemplatedEntityList< IfcPhysicalQuantity >::ptr v3_HasQuantities, std::string v4_Discrimination, boost::optional< std::string > v5_Quality, boost::optional< std::string > v6_Usage);
    typedef IfcTemplatedEntityList< IfcPhysicalComplexQuantity > list;
};
/// An IfcPixelTexture provides a 2D image-based texture map as an explicit array of pixel values (list of Pixel binary attributes). In contrary to the IfcImageTexture the IfcPixelTexture holds a 2 dimensional list of pixel color
/// (and opacity) directly, instead of referencing to an URL.
/// 
/// The following definitions from ISO/IEC 19775-1 X3D Architecture and base components (X3D Specification) apply:
/// 
/// The PixelTexture node defines a 2D image-based texture map as an explicit array of pixel values (image field) and parameters controlling tiling repetition of the texture onto geometry.
/// Texture maps are defined in a 2D coordinate system (s, t) that ranges from 0.0 to 1.0 in both directions. The bottom edge of the pixel image corresponds to the S-axis of the texture map, and left edge of the pixel image corresponds to the T-axis of the texture map. The lower-left pixel of the pixel image corresponds to s=0.0, t=0.0, and the top-right pixel of the image corresponds to s = 1.0, t = 1.0.
/// The Image field specifies a single uncompressed 2-dimensional pixel image. Image fields contain three integers representing the width, height and number of components in the image, followed by width×height hexadecimal values representing the pixels in the image. Pixel values are limited to 256 levels of intensity (that is, 0x00-0xFF hexadecimal).
/// 
/// A one-component image specifies one-byte hexadecimal value representing the intensity of the image. For example, 0xFF is full intensity in hexadecimal (255 in decimal), 0x00 is no intensity (0 in decimal).
/// A two-component image specifies the intensity in the first
/// (high) byte and the alpha opacity in the second (low) byte.
/// Pixels in a three-component image specify the red component in the first (high) byte, followed by the green and blue components (for example, 0xFF0000 is red, 0x00FF00 is green, 0x0000FF is blue).
/// Four-component images specify the alpha opacity byte after red/green/blue (e.g., 0x0000FF80 is semi-transparent blue). A value of 00 is completely transparent, FF is completely opaque, 80 is semi-transparent.
/// 
/// Note that alpha equals (1.0 -transparency), if alpha and transparency each range from 0.0 to 1.0.
/// 
/// HISTORY: New class in IFC2x2.
class IfcPixelTexture : public IfcSurfaceTexture {
public:
    /// The number of pixels in width (S) direction.
    int Width() const;
    void setWidth(int v);
    /// The number of pixels in height (T) direction.
    int Height() const;
    void setHeight(int v);
    /// Indication whether the pixel values contain a 1, 2, 3, or 4 colour component.
    int ColourComponents() const;
    void setColourComponents(int v);
    /// Flat list of hexadecimal values, each describing one pixel by 1, 2, 3, or 4 components.
    /// 
    /// IFC2x Edition 3 CHANGE  The data type has been changed from STRING to BINARY.
    std::vector< boost::dynamic_bitset<> > /*[1:?]*/ Pixel() const;
    void setPixel(std::vector< boost::dynamic_bitset<> > /*[1:?]*/ v);
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 4: return IfcUtil::Argument_INT; case 5: return IfcUtil::Argument_INT; case 6: return IfcUtil::Argument_INT; case 7: return IfcUtil::Argument_AGGREGATE_OF_BINARY; } return IfcSurfaceTexture::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 4: return Type::IfcInteger; case 5: return Type::IfcInteger; case 6: return Type::IfcInteger; case 7: return Type::UNDEFINED; } return IfcSurfaceTexture::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 4: return "Width"; case 5: return "Height"; case 6: return "ColourComponents"; case 7: return "Pixel"; } return IfcSurfaceTexture::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPixelTexture (IfcAbstractEntity* e);
    IfcPixelTexture (bool v1_RepeatS, bool v2_RepeatT, IfcSurfaceTextureEnum::IfcSurfaceTextureEnum v3_TextureType, IfcCartesianTransformationOperator2D* v4_TextureTransform, int v5_Width, int v6_Height, int v7_ColourComponents, std::vector< boost::dynamic_bitset<> > /*[1:?]*/ v8_Pixel);
    typedef IfcTemplatedEntityList< IfcPixelTexture > list;
};
/// Definition from ISO/CD 10303-42:1992: A placement entity defines the local environment for the definition of a geometry item. It locates the item to be defined and, in the case of the axis placement subtypes, gives its orientation. 
/// 
/// Additional definition from ISO/WD SC4/WG12/N071 Part42.2 geometry_schema: A placement locates a geometric item with respect to the coordinate system of its geometric context. 
/// 
/// IfcPlacement is an abstract supertype not to be directly instantiated, whereas the ISO 10303-42 entity placement can be instantiated to define a placement without orientation. The derived attribute Dim has been added, see also note at IfcGeometricRepresentationItem.  
/// 
/// NOTE: Corresponding ISO 10303 entity: placement. Please refer to ISO/IS 10303-42:1994, p. 27 for the final definition of the formal standard.
/// 
/// HISTORY: New entity in IFC Release 1.0
class IfcPlacement : public IfcGeometricRepresentationItem {
public:
    /// The geometric position of a reference point, such as the center of a circle, of the item to be located.
    IfcCartesianPoint* Location() const;
    void setLocation(IfcCartesianPoint* v);
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcGeometricRepresentationItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcCartesianPoint; } return IfcGeometricRepresentationItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Location"; } return IfcGeometricRepresentationItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPlacement (IfcAbstractEntity* e);
    IfcPlacement (IfcCartesianPoint* v1_Location);
    typedef IfcTemplatedEntityList< IfcPlacement > list;
};
/// The planar extent defines the extent along the two axes of the two-dimensional coordinate system, independently of its position.
/// 
/// NOTE  Corresponding ISO 10303 name: planar_extent. Please refer to ISO/IS 10303-46:1994, p. 141 for the final definition of the formal standard.
/// 
/// HISTORY  New entity in IFC2x2.
class IfcPlanarExtent : public IfcGeometricRepresentationItem {
public:
    /// The extent in the direction of the x-axis.
    double SizeInX() const;
    void setSizeInX(double v);
    /// The extent in the direction of the y-axis.
    double SizeInY() const;
    void setSizeInY(double v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_DOUBLE; case 1: return IfcUtil::Argument_DOUBLE; } return IfcGeometricRepresentationItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcLengthMeasure; case 1: return Type::IfcLengthMeasure; } return IfcGeometricRepresentationItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "SizeInX"; case 1: return "SizeInY"; } return IfcGeometricRepresentationItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPlanarExtent (IfcAbstractEntity* e);
    IfcPlanarExtent (double v1_SizeInX, double v2_SizeInY);
    typedef IfcTemplatedEntityList< IfcPlanarExtent > list;
};
/// Definition from ISO/CD 10303-42:1992: A point is a location in some real Cartesian coordinate space Rm, for m = 1, 2 or 3.  
/// 
/// NOTE: Corresponding ISO 10303 entity: point. Only the subtypes cartesian_point, point_on_curve, point_on_surface have been incorporated in the current release of IFC. Please refer to ISO/IS 10303-42:1994, p. 22 for the final definition of the formal standard.
/// 
/// HISTORY: New entity in IFC Release 1.5
class IfcPoint : public IfcGeometricRepresentationItem {
public:
    virtual unsigned int getArgumentCount() const { return 0; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcGeometricRepresentationItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcGeometricRepresentationItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcGeometricRepresentationItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPoint (IfcAbstractEntity* e);
    IfcPoint ();
    typedef IfcTemplatedEntityList< IfcPoint > list;
};
/// Definition from ISO/CD 10303-42:1992: A point on curve is a point which lies on a curve. The point is determined by evaluating the curve at a specific parameter value. The coordinate space dimensionality of the point is that of the basis curve. 
/// 
/// NOTE: Corresponding STEP entity: point_on_curve. Please refer to ISO/IS 10303-42:1994, p. 23 for the final definition of the formal standard.
/// 
/// HISTORY: New entity in Release IFC2x Edition 2.
/// 
/// Informal Propositions: 
/// 
/// The value of the point parameter shall not be outside the parametric range of the curve.
class IfcPointOnCurve : public IfcPoint {
public:
    /// The curve to which point parameter relates.
    IfcCurve* BasisCurve() const;
    void setBasisCurve(IfcCurve* v);
    /// The parameter value of the point location.
    double PointParameter() const;
    void setPointParameter(double v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_DOUBLE; } return IfcPoint::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcCurve; case 1: return Type::IfcParameterValue; } return IfcPoint::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "BasisCurve"; case 1: return "PointParameter"; } return IfcPoint::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPointOnCurve (IfcAbstractEntity* e);
    IfcPointOnCurve (IfcCurve* v1_BasisCurve, double v2_PointParameter);
    typedef IfcTemplatedEntityList< IfcPointOnCurve > list;
};
/// Definition from ISO/CD 10303-42:1992: A point on surface is a point which lies on a parametric surface. The point is determined by evaluating the surface at a particular pair of parameter values. 
/// 
/// NOTE: Corresponding ISO 10303 entity: point_on_surface. Please refer to ISO/IS 10303-42:1994, p. 24 for the final definition of the formal standard.  
/// 
/// HISTORY: New entity in Release IFC2x Edition 2.
/// 
/// Informal Propositions: 
/// 
/// The parametric values specified for u and v shall not be outside the parametric range of the basis surface.
class IfcPointOnSurface : public IfcPoint {
public:
    /// The surface to which the parameter values relate.
    IfcSurface* BasisSurface() const;
    void setBasisSurface(IfcSurface* v);
    /// The first parameter value of the point location.
    double PointParameterU() const;
    void setPointParameterU(double v);
    /// The second parameter value of the point location.
    double PointParameterV() const;
    void setPointParameterV(double v);
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_DOUBLE; case 2: return IfcUtil::Argument_DOUBLE; } return IfcPoint::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcSurface; case 1: return Type::IfcParameterValue; case 2: return Type::IfcParameterValue; } return IfcPoint::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "BasisSurface"; case 1: return "PointParameterU"; case 2: return "PointParameterV"; } return IfcPoint::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPointOnSurface (IfcAbstractEntity* e);
    IfcPointOnSurface (IfcSurface* v1_BasisSurface, double v2_PointParameterU, double v3_PointParameterV);
    typedef IfcTemplatedEntityList< IfcPointOnSurface > list;
};
/// Definition from ISO/CD 10303-42:1992: A
/// poly loop is a loop with straight edges bounding a planar region in
/// space. A poly loop is a loop of genus 1 where the loop is represented
/// by an ordered coplanar collection of points forming the vertices of the
/// loop. The loop is composed of straight line segments joining a point in
/// the collection to the succeeding point in the collection. The closing
/// segment is from the last to the first point in the collection. 
/// The direction of the loop is in the direction of the line
/// segments. 
/// 
/// NOTE  This entity exists primarily to facilitate the efficient communication of faceted B-rep models.
/// 
/// A poly loop shall conform to the following topological
/// constraints:
/// 
/// - the loop has the genus of one.
///   - the following equation shall be satisfied
/// 
/// The IfcPolyLoop
/// is always closed and the last segment is from the last IfcCartesianPoint
/// in the list of Polygon's to the first IfcCartesianPoint.
/// Therefore the first point shall not be repeated at the end of the list,
/// neither by referencing the same instance, nor by using an additional
/// instance of IfcCartesianPoint having the
/// coordinates as the first point.
/// 
/// NOTE  Corresponding ISO 10303 entity: poly_loop. Please refer to ISO/IS
/// 10303-42:1994, p. 138 for the final definition of the formal standard.
/// Due to the general IFC model specification rule not to use multiple
/// inheritance, the subtype relationship to geometric_representation_item
/// is not included. The derived attribute Dim has been
/// added at this level.
/// 
/// HISTORY   New class in IFC Release 1.0
/// 
/// Informal propositions: 
/// 
/// All the points in the polygon defining the poly loop shall be coplanar.
///   The first and the last Polygon shall be different by value.
class IfcPolyLoop : public IfcLoop {
public:
    /// List of points defining the loop. There are no repeated points in the list.
    IfcTemplatedEntityList< IfcCartesianPoint >::ptr Polygon() const;
    void setPolygon(IfcTemplatedEntityList< IfcCartesianPoint >::ptr v);
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } return IfcLoop::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcCartesianPoint; } return IfcLoop::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Polygon"; } return IfcLoop::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPolyLoop (IfcAbstractEntity* e);
    IfcPolyLoop (IfcTemplatedEntityList< IfcCartesianPoint >::ptr v1_Polygon);
    typedef IfcTemplatedEntityList< IfcPolyLoop > list;
};
/// The polygonal bounded
/// half space is a special subtype of a half space solid, where the
/// material of the half space used in Boolean expressions is bounded by a
/// polygonal boundary. The base
/// surface of the half space is positioned by its normal relativeto the
/// object coordinate system
/// (as defined at the supertype IfcHalfSpaceSolid), and
/// its polygonal (with or without arc segments) boundary is defined in the
/// XY plane of the position
/// coordinate system established by the Position
/// attribute, the subtraction body is extruded perpendicular to the XY
/// plane of the position coordinate system, that is, into the direction of the
/// positive Z axis defined by the Position attribute.
/// The boundary is defined by a 2 dimensional polyline (or 2 dimensional composite curve,
/// consisting of straight segments and circular arc segments)
/// within the
/// XY plane of the position coordinate system. The side of the surface
/// which is in the half space is determined by the surface normal and the
/// agreement flag. If the agreement flag is TRUE, then the subset is the
/// one the normal points away from. If the agreement flag is FALSE, then
/// the subset is the one the normal points into. 
/// 
/// NOTE  A polygonal bounded half space is not a subtype of IfcSolidModel, half space solids are only useful as operands in Boolean expressions.
/// 
/// HISTORY  New class in IFC Release 2x.
/// 
/// Informal propositions:
/// 
/// The IfcPolyline or the IfcCompositeCurve
/// providing the PolygonalBoundary
/// shall be closed.
///   If the PolygonalBoundary
/// is given by an IfcCompositeCurve, it shall only
/// have IfcCompositeCurveSegment's of type IfcPolyline,
/// or IfcTrimmedCurve (having a BasisCurve
/// of type IfcLine, or IfcCircle)
/// 
/// Figure 259 illustrates a polygonal bounded half space.
/// 
/// Black coordinates indicate the object coordinate system (usually provided by IfcLocalPlacement).
/// Green coordinates indicate the position coordinate system; the PolygonalBoundary is given within this coordinate system. It is provided by IfcPolygonalBoundedHalfSpace.Position. This coordinate system is relative to the object coordinate system. The extrusion direction of the subtraction body is the positive Z axis.
/// Red coordinates indicate the normal of the plane. It is provided by the BaseSurface (IfcSurface.Position). This normal is also relative to the object coordinate system.
/// 
/// Figure 259 — Polygonal half space geometry
/// 
/// Purpose
/// The polygonal bounded half space is used to limit the volume of the
/// half space in Boolean difference expressions. Only the part that is
/// defined by a theoretical intersection between the half space solid and
/// an extruded area solid, defined by extruding the polygonal boundary, is
/// used for Boolean expressions.
///   Parameter
/// The PolygonalBoundary defines the 2D polyline which
/// bounds the effectiveness of the half space in Boolean expressions. The BaseSurface
/// is defined by a plane, and the normal of the plane together with the AgreementFlag
/// defines the side of the material of the half space.
class IfcPolygonalBoundedHalfSpace : public IfcHalfSpaceSolid {
public:
    /// Definition of the position coordinate system for the bounding polyline and the base surface.
    IfcAxis2Placement3D* Position() const;
    void setPosition(IfcAxis2Placement3D* v);
    /// Two-dimensional polyline bounded curve, defined in the xy plane of the position coordinate system.
    /// 
    /// IFC2x Edition 3 CHANGE  The attribute type has been changed from IfcPolyline to its supertype IfcBoundedCurve with upward compatibility for file based exchange.
    IfcBoundedCurve* PolygonalBoundary() const;
    void setPolygonalBoundary(IfcBoundedCurve* v);
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 2: return IfcUtil::Argument_ENTITY_INSTANCE; case 3: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcHalfSpaceSolid::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 2: return Type::IfcAxis2Placement3D; case 3: return Type::IfcBoundedCurve; } return IfcHalfSpaceSolid::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 2: return "Position"; case 3: return "PolygonalBoundary"; } return IfcHalfSpaceSolid::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPolygonalBoundedHalfSpace (IfcAbstractEntity* e);
    IfcPolygonalBoundedHalfSpace (IfcSurface* v1_BaseSurface, bool v2_AgreementFlag, IfcAxis2Placement3D* v3_Position, IfcBoundedCurve* v4_PolygonalBoundary);
    typedef IfcTemplatedEntityList< IfcPolygonalBoundedHalfSpace > list;
};
/// The pre defined colour determines those qualified names which can be used to identify a colour that is in scope of the current data exchange specification (in contrary to colour specification which defines the colour directly by its colour components).
/// 
/// NOTE  Corresponding ISO 10303 name: pre_defined_colour. It has been made into an abstract entity in IFC. Please refer to ISO/IS 10303-46:1994, p. 141 for the final definition of the formal standard.
/// 
/// HISTORY  New entity in IFC2x2.
class IfcPreDefinedColour : public IfcPreDefinedItem {
public:
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcPreDefinedItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcPreDefinedItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcPreDefinedItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPreDefinedColour (IfcAbstractEntity* e);
    IfcPreDefinedColour (std::string v1_Name);
    typedef IfcTemplatedEntityList< IfcPreDefinedColour > list;
};
/// Definition from ISO/CD 10303-46:1992: The predefined curve font type is an abstract supertype provided to define an application specific curve font. The name label shall be constrained in the application protocol to values that are given specific meaning for curve fonts in that application protocol.
/// 
/// NOTE: The IfcPreDefinedCurveFont is an abstract entity, subtypes of it provide the predefined curve font by agreement of the values of the inherited Name attribute. Currently the only subtype provided is IfcDraughtingPreDefinedCurveFont.
/// 
/// NOTE: Corresponding ISO 10303 name: pre_defined_curve_font. Please refer to ISO/IS 10303-46:1994, p. 103 for the final definition of the formal standard.
/// 
/// HISTORY: New entity in IFC2x2.
class IfcPreDefinedCurveFont : public IfcPreDefinedItem {
public:
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcPreDefinedItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcPreDefinedItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcPreDefinedItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPreDefinedCurveFont (IfcAbstractEntity* e);
    IfcPreDefinedCurveFont (std::string v1_Name);
    typedef IfcTemplatedEntityList< IfcPreDefinedCurveFont > list;
};

class IfcPreDefinedDimensionSymbol : public IfcPreDefinedSymbol {
public:
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcPreDefinedSymbol::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcPreDefinedSymbol::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcPreDefinedSymbol::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPreDefinedDimensionSymbol (IfcAbstractEntity* e);
    IfcPreDefinedDimensionSymbol (std::string v1_Name);
    typedef IfcTemplatedEntityList< IfcPreDefinedDimensionSymbol > list;
};

class IfcPreDefinedPointMarkerSymbol : public IfcPreDefinedSymbol {
public:
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcPreDefinedSymbol::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcPreDefinedSymbol::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcPreDefinedSymbol::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPreDefinedPointMarkerSymbol (IfcAbstractEntity* e);
    IfcPreDefinedPointMarkerSymbol (std::string v1_Name);
    typedef IfcTemplatedEntityList< IfcPreDefinedPointMarkerSymbol > list;
};
/// The IfcProductDefinitionShape defines all shape relevant information about an IfcProduct. It allows for multiple geometric shape representations of the same product. The shape relevant information includes:
/// 
/// the shape representation including geometric representation items (for 3D solids, 2D annotations, etc.) and:
/// 
/// associated presentation information (line color, line type, surface rendering properties)
/// assignment to presentation layers (CAD layers for visibility control)
/// 
/// or the topological representation items for connectivity systems (vertex, edge, face representations) that may include geometric representation items (vertex points, edge curves, face surfaces)
/// 
/// NOTE  The definition of this entity relates to the ISO 10303 entity product_definition_shape. Please refer to ISO/IS 10303-41:1994 for the final definition of the formal standard.
/// 
/// HISTORY  New Entity in IFC Release 1.5
class IfcProductDefinitionShape : public IfcProductRepresentation {
public:
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcProductRepresentation::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcProductRepresentation::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcProductRepresentation::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcProduct >::ptr ShapeOfProduct() const; // INVERSE IfcProduct::Representation
    IfcTemplatedEntityList< IfcShapeAspect >::ptr HasShapeAspects() const; // INVERSE IfcShapeAspect::PartOfProductDefinitionShape
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcProductDefinitionShape (IfcAbstractEntity* e);
    IfcProductDefinitionShape (boost::optional< std::string > v1_Name, boost::optional< std::string > v2_Description, IfcTemplatedEntityList< IfcRepresentation >::ptr v3_Representations);
    typedef IfcTemplatedEntityList< IfcProductDefinitionShape > list;
};
/// A property with a bounded
///   value, IfcPropertyBoundedValue, defines a property
///   object which has a maximum of two (numeric or descriptive)
///   values assigned, the first value specifying the upper bound
///   and the second value specifying the lower bound. It defines
///   a property - value bound (min-max) combination for which
///   the property Name, an optional
///   Description,ÿthe optional UpperBoundValue
///   with measure type, the optional LowerBoundValue with
///   measure type, and the optional Unit is given.
/// 
/// A set point value can be provided in addition to the upper and lower bound values for operational value setting.
/// 
/// The unit is handled by the Unit attribute:
/// 
/// If the Unit attribute is not given, then the
///   unit is already implied by the type of
///   IfcMeasureValue or IfcDerivedMeasureValue.
///   The associated unit can be found at the
///   IfcUnitAssignment globally defined at the project
///   level (IfcProject.UnitsInContext).
/// 
/// If the Unit attribute is given, then the unit
///   assigned by the Unit attribute overrides the
///   globally assigned unit.
/// 
/// The IfcPropertyBoundedValue allows for the
///   specification of an interval for the value component of the
///   property description. If either the
///   LowerBoundValue or the UpperBoundValue is not
///   given, then it indicates an open bound (either a minimum
///   value or a maximum value). The interval is by definition
///   inclusive, that is, the value given for the
///   LowerBoundValue or the UpperBoundValue is
///   included in the interval.
/// 
/// NOTE  An IfcPropertyBoundedValue may be
///   exchanged with no values assigned yet. In this case the
///   LowerBoundValue and the UpperBoundValue are
///   set to NIL.
/// 
/// Examples of a property with bounded value are:
/// 
/// Name
/// 
/// UpperBoundValue
/// 
/// LowerBoundValue
/// 
/// SetPointValue
/// 
/// Type (through
///   IfcValue, WR1 ensures same type for both
///   values)
/// 
/// Unit
/// 
/// OverallHeight
/// 
/// 1930
/// 
/// 2300
/// 
/// IfcPositiveLengthMeasure
/// 
/// -
/// 
/// OverallWidth
/// 
/// 0.9
/// 
/// 1.25
/// 
/// IfcPositiveLengthMeasure
/// 
/// m
/// 
/// MaxHeight
/// 
/// 20.0
/// 
/// IfcPositiveLengthMeasure
/// 
/// -
/// 
/// MinWeight
/// 
/// 20
/// 
/// IfcMassMeasure
/// 
/// kg
/// 
/// HISTORY ÿNew entity in IFC Release 2x.
/// 
/// IFC2x2 CHANGE  The attribute type of the attribute UpperBoundValue and LowerBoundValue has been changed from mandatory to optional with upward compatibility for file based exchange.
/// 
/// IFC2x4 CHANGE  The attribute SetPointValue has been added.
/// 
/// Informal proposition:
/// 
/// If the measure type for the upper and lover bound value
///   is a numeric measure, then the following shall be true: 
///   UpperBoundValue > LowerBoundValue.
class IfcPropertyBoundedValue : public IfcSimpleProperty {
public:
    /// Whether the optional attribute UpperBoundValue is defined for this IfcPropertyBoundedValue
    bool hasUpperBoundValue() const;
    /// Upper bound value for the interval defining the property value. If the value is not given, it indicates an open bound (all values to be greater than or equal to LowerBoundValue).
    IfcValue* UpperBoundValue() const;
    void setUpperBoundValue(IfcValue* v);
    /// Whether the optional attribute LowerBoundValue is defined for this IfcPropertyBoundedValue
    bool hasLowerBoundValue() const;
    /// Lower bound value for the interval defining the property value. If the value is not given, it indicates an open bound (all values to be lower than or equal to UpperBoundValue).
    IfcValue* LowerBoundValue() const;
    void setLowerBoundValue(IfcValue* v);
    /// Whether the optional attribute Unit is defined for this IfcPropertyBoundedValue
    bool hasUnit() const;
    /// Unit for the upper and lower bound values, if not given, the default value for the measure type is used as defined by the global unit assignment at IfcProject.UnitInContext. The applicable unit is then selected by the underlying TYPE of the UpperBoundValue, LowerBoundValue, and SetPointValue)
    IfcUnit* Unit() const;
    void setUnit(IfcUnit* v);
    virtual unsigned int getArgumentCount() const { return 5; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 2: return IfcUtil::Argument_ENTITY_INSTANCE; case 3: return IfcUtil::Argument_ENTITY_INSTANCE; case 4: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcSimpleProperty::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 2: return Type::IfcValue; case 3: return Type::IfcValue; case 4: return Type::IfcUnit; } return IfcSimpleProperty::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 2: return "UpperBoundValue"; case 3: return "LowerBoundValue"; case 4: return "Unit"; } return IfcSimpleProperty::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPropertyBoundedValue (IfcAbstractEntity* e);
    IfcPropertyBoundedValue (std::string v1_Name, boost::optional< std::string > v2_Description, IfcValue* v3_UpperBoundValue, IfcValue* v4_LowerBoundValue, IfcUnit* v5_Unit);
    typedef IfcTemplatedEntityList< IfcPropertyBoundedValue > list;
};
/// IfcPropertyDefinition defines the generalization of
/// all characteristics (i.e. a grouping of individual properties),
/// that may be assigned to objects. Currently, subtypes of
/// IfcPropertyDefinition include property set occurrences,
/// property set templates, and property templates.
/// 
/// Property set template -
/// IfcPropertySetTemplate, a collection of property templates
/// that determine the definition of properties used within a project
/// context.
/// Property template -
/// IfcPropertyTemplate, a single template that determines the
/// definition of a particular property used in the same project
/// context. The template may determine the name, description, data
/// type, the unit, or a standard expression for each property that is
/// based on that template.
/// Property set occurrence -
/// IfcPropertySet, a set of individual properties (that may
/// or may not be determined by a property template) holding individual
/// values, measure types and units, and are associated to an object
/// occurrence or object type.
/// 
/// NOTE 1  The subtype hierarchy of IfcPropertyDefinition also includes statically defined property sets as IfcPreDefinedPropertySet. Those are rarely used collections of fixed attributes combined in an entity definition. The IfcPreDefinedPropertySet can not be determined by an IfcPropertySetTemplate.
/// 
/// NOTE 2  Individual properties, (subtypes of IfcProperty), are currently not included in the subtype hierarchy of IfcPropertyDefinition. This anomaly is due to upward compatibility reasons with earlier releases of this
/// standard.
/// 
/// HISTORY  New Entity in IFC2.0
/// 
/// Relationship use definition
/// Property definitions define information that is shared among
/// multiple instances of objects, either object occurrences or object
/// types. IfcPropertyDefinition's (by their instantiable
/// subtypes) can participated within the following relationships:
/// 
/// Assignment to a project context - an
/// HasContext relationship to IfcRelDeclares that
/// establishes the project context in which this property definition
/// is declared. This relationship is predominately applicable to
/// subtypes of IfcPropertyTemplateDefinition.
/// Association to external resources - an
/// HasAssociation relationship to IfcRelAssociates
/// that refers to external sources of information (most notably a
/// classification or document) and creates a uni-directional
/// association. There is no dependency implied by the
/// association.
/// 
/// Subtypes are included in more specific relationships, see
/// IfcPropertySetDefinition and
/// IfcPropertyTemplateDefinition for details.
class IfcPropertyDefinition : public IfcRoot {
public:
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcRoot::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcRoot::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcRoot::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcRelAssociates >::ptr HasAssociations() const; // INVERSE IfcRelAssociates::RelatedObjects
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPropertyDefinition (IfcAbstractEntity* e);
    IfcPropertyDefinition (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description);
    typedef IfcTemplatedEntityList< IfcPropertyDefinition > list;
};
/// A property with an enumerated
/// value, IfcPropertyEnumeratedValue, defines a property
/// object which has a value assigned that is chosen from an
/// enumeration. It defines a property - value combination for which
/// theÿproperty Name, an optional Description,ÿthe
/// optional EnumerationValues
/// with measure type and optionally an Unit is given.
/// 
/// NOTE  Multiple choices from the property enumeration are supported.
/// 
/// The unit is handled by the Unit attribute of the
/// IfcPropertyEnumeration:
/// 
/// If the Unit attribute is not given, then the unit is
/// already implied by the type of IfcMeasureValue or
/// IfcDerivedMeasureValue. The associated unit can be found
/// at the IfcUnitAssignment globally defined at the project
/// level (IfcProject.UnitsInContext).
/// If the Unit attribute is given, then the unit assigned
/// by the unit attribute overrides the globally assigned unit.
/// 
/// More precisely: The IfcPropertyEnumeratedValue defines
/// a property, which value is selected from a defined list of
/// enumerators. The enumerators are stored in a dynamic enumeration
/// of values including the type information from IfcValue
/// (see IfcPropertyEnumeration). This enables applications to
/// use an enumeration value as a property within a property set
/// (IfcPropertySet) including the allowed list of
/// values.ÿ
/// 
/// NOTE  An IfcPropertyEnumeratedValue may be exchanged with no values assigned yet. In this case the EnumerationValues are set to NIL.
/// 
/// Examples of a property with enumerated value are:
/// 
/// Nameÿ
/// Value (EnumerationValue)
/// Type (through
/// IfcValue)
/// ref.IfcPropertyEnumeration
/// (Name)ÿ
/// 
/// BladeAction
/// Opposed
/// IfcString
/// DamperBladeActionEnum
/// 
/// BladeAction
/// Parallel
/// IfcString
/// DamperBladeActionEnum
/// 
/// The IfcPropertyEnumeratedValue refers to an
/// IfcPropertyEnumeration, e.g. for the above:
/// 
/// Name
/// EnumerationValues
/// Type (through
/// IfcValue)
/// Unit
/// 
/// DamperBladeActionEnum
/// (Parallel, Opposed, Other, Unset)
/// IfcString
/// -
/// 
/// It is not mandatory to use an instance of
/// IfcPropertyEnumeration to hold the applicable values for
/// IfcPropertyEnumeratedValue, however this is the preferred
/// way. A single instance of IfcPropertyEnumeration can be
/// referenced by multiple instances of
/// IfcPropertyEnumeratedValue.
/// 
/// HISTORY ÿNew Entity in IFC Release 2.0, capabilities enhanced in IFC2x. The entity has
/// been renamed from IfcEnumeratedProperty in IFC2x.
/// 
/// IFC2x4 CHANGE Attribute EnumerationValues has been made OPTIONAL with upward
/// compatibility for file based exchange.
class IfcPropertyEnumeratedValue : public IfcSimpleProperty {
public:
    /// Enumeration values, which shall be listed in the referenced IfcPropertyEnumeration, if such a reference is provided.
    /// 
    /// IFC2x4 CHANGE  The attribute has been made optional with upward compatibility for file based exchange.
    IfcEntityList::ptr EnumerationValues() const;
    void setEnumerationValues(IfcEntityList::ptr v);
    /// Whether the optional attribute EnumerationReference is defined for this IfcPropertyEnumeratedValue
    bool hasEnumerationReference() const;
    /// Enumeration from which a enumeration value has been selected. The referenced enumeration also establishes the unit of the enumeration value.
    IfcPropertyEnumeration* EnumerationReference() const;
    void setEnumerationReference(IfcPropertyEnumeration* v);
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 2: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 3: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcSimpleProperty::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 2: return Type::IfcValue; case 3: return Type::IfcPropertyEnumeration; } return IfcSimpleProperty::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 2: return "EnumerationValues"; case 3: return "EnumerationReference"; } return IfcSimpleProperty::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPropertyEnumeratedValue (IfcAbstractEntity* e);
    IfcPropertyEnumeratedValue (std::string v1_Name, boost::optional< std::string > v2_Description, IfcEntityList::ptr v3_EnumerationValues, IfcPropertyEnumeration* v4_EnumerationReference);
    typedef IfcTemplatedEntityList< IfcPropertyEnumeratedValue > list;
};
/// An IfcPropertyListValue
///   defines a property that has several (numeric or
///   descriptive) values assigned, these values are given by an
///   ordered list.ÿIt defines a property - list value
///   combination for which the property Name, an optional
///   Description,ÿthe optional ListValues with measure
///   type and optionally an Unit is given.
/// 
/// An IfcPropertyListValue is a list of values. The
///   order in which values appear is significant. Each value in
///   the list is unique i.e. no duplicate values are allowed.
///   All list members shall be of the same type.
/// 
/// The unit applicable to all values is handled by the
///   Unit attribute:
/// 
/// If the Unit attribute is not given, then the
///   unit is already implied by the type of
///   IfcMeasureValue or IfcDerivedMeasureValue.
///   The associated unit can be found at the
///   IfcUnitAssignment globally defined at the project
///   level (IfcProject.UnitsInContext).
/// 
/// If the Unit attribute is given, then the unit
///   assigned by the Unit attribute overrides the
///   globally assigned unit.
/// 
/// Example of a property with list value is:
/// 
/// Name
/// 
/// ListValues
/// 
/// Type (through
///   IfcValue)
/// 
/// Unit
/// 
/// ApplicableSizes
/// 
/// 1200
/// 
/// IfcPositiveLengthMeasure
/// 
/// -
/// 
/// -
/// 
/// 1600
/// 
/// IfcPositiveLengthMeasure
/// 
/// -
/// 
/// -
/// 
/// 2400
/// 
/// IfcPositiveLengthMeasure
/// 
/// -
/// 
/// HISTORY  New Entity in Release IFC 2x Edition 2.
/// 
/// IFC2x4 CHANGE  Attribute ListValues has been made OPTIONAL with upward compatibility for file based exchange.
class IfcPropertyListValue : public IfcSimpleProperty {
public:
    /// List of property values.
    /// 
    /// IFC2x4 CHANGE  The attribute has been made optional with upward compatibility for file based exchange.
    IfcEntityList::ptr ListValues() const;
    void setListValues(IfcEntityList::ptr v);
    /// Whether the optional attribute Unit is defined for this IfcPropertyListValue
    bool hasUnit() const;
    /// Unit for the list values, if not given, the default value for the measure type (given by the TYPE of nominal value) is used as defined by the global unit assignment at IfcProject.
    IfcUnit* Unit() const;
    void setUnit(IfcUnit* v);
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 2: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 3: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcSimpleProperty::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 2: return Type::IfcValue; case 3: return Type::IfcUnit; } return IfcSimpleProperty::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 2: return "ListValues"; case 3: return "Unit"; } return IfcSimpleProperty::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPropertyListValue (IfcAbstractEntity* e);
    IfcPropertyListValue (std::string v1_Name, boost::optional< std::string > v2_Description, IfcEntityList::ptr v3_ListValues, IfcUnit* v4_Unit);
    typedef IfcTemplatedEntityList< IfcPropertyListValue > list;
};
/// IfcPropertyReferenceValue allows a property value to
///   be given by referencing other entities within the resource
///   definitions of IFC. Those other entities are regarded as
///   predefined complex properties and can be aggregated within
///   a property set (IfcPropertySet). The allowable
///   entities to be used as value references are given by the
///   IfcObjectReferenceSelect.
/// 
/// HISTORY  New entity in IFC
///   Release 1.5. Entity has been renamed from
///   IfcObjectReference in IFC Release 2x.
/// 
/// IFC2x4 CHANGE  Attribute
///   PropertyReference has been made OPTIONAL with upward
///   compatibility for file based exchange.
class IfcPropertyReferenceValue : public IfcSimpleProperty {
public:
    /// Whether the optional attribute UsageName is defined for this IfcPropertyReferenceValue
    bool hasUsageName() const;
    /// Description of the use of the referenced value within the property.
    std::string UsageName() const;
    void setUsageName(std::string v);
    /// Reference to another property entity through one of the select types in the IfcObjectReferenceSelect.
    /// 
    /// IFC2x4 CHANGE  The attribute has been made optional with upward compatibility for file based exchange.
    IfcObjectReferenceSelect* PropertyReference() const;
    void setPropertyReference(IfcObjectReferenceSelect* v);
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 2: return IfcUtil::Argument_STRING; case 3: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcSimpleProperty::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 2: return Type::IfcLabel; case 3: return Type::IfcObjectReferenceSelect; } return IfcSimpleProperty::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 2: return "UsageName"; case 3: return "PropertyReference"; } return IfcSimpleProperty::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPropertyReferenceValue (IfcAbstractEntity* e);
    IfcPropertyReferenceValue (std::string v1_Name, boost::optional< std::string > v2_Description, boost::optional< std::string > v3_UsageName, IfcObjectReferenceSelect* v4_PropertyReference);
    typedef IfcTemplatedEntityList< IfcPropertyReferenceValue > list;
};
/// IfcPropertySetDefinition is a generalization of all
/// individual property sets that can be assigned to an object or type
/// object. The property set definition can be either:
/// 
/// Dynamically extendable property sets -
/// IfcPropertySet, a set of properties for which the IFC
/// model only provides a kind of "meta model", to be further declared
/// by agreement. This means no entity definition of the properties
/// exists within the IFC model. The declaration is done by assigning a
/// significant string value to the Name attribute of the
/// entity as defined in the entity IfcPropertySet and at each
/// subtype of IfcProperty, referenced by the property set.
/// Dynamically defined property sets may have an underlying template
/// provided by IfcPropertySetTemplate.
/// Statically defined property sets -
/// IfcPreDefinedPropertySet, a property set entity that
/// exists within the IFC specification. The semantic meaning of each
/// statically defined property set is declared by its entity type and
/// the meaning of the properties is defined by the name and data type
/// of the explicit attribute representing it.
/// 
/// HISTORY  New Entity in IFC Release 2x
/// 
/// IFC2x4 CHANGE  The subtype IfcPreDefinedPropertySet has been added.
/// 
/// Relationship use definition
/// Property set definitions define information that is shared among
/// multiple instances of objects, either object occurrences or object
/// types. IfcPropertySetDefinition's (by their instantiable
/// subtypes) can participated within the following relationships:
/// 
/// Assignment to object types - an
/// DefinesType direct relationship to IfcTypeObject
/// that applies the property set, with all included properties, to the
/// object type. Those properties apply to all object occurrences
/// having the same object type.
/// Assignment to object occurrences - an
/// DefinesOccurrence relationship to
/// IfcRelDefinesByProperties that applies the property set,
/// with all included properties, to the object occurrence.
/// 
/// NOTE  Properties assigned to object occurrences may override properties assigned to the object type. See IfcRelDefinesByType for further information.
class IfcPropertySetDefinition : public IfcPropertyDefinition {
public:
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcPropertyDefinition::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcPropertyDefinition::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcPropertyDefinition::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcRelDefinesByProperties >::ptr PropertyDefinitionOf() const; // INVERSE IfcRelDefinesByProperties::RelatingPropertyDefinition
    IfcTemplatedEntityList< IfcTypeObject >::ptr DefinesType() const; // INVERSE IfcTypeObject::HasPropertySets
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPropertySetDefinition (IfcAbstractEntity* e);
    IfcPropertySetDefinition (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description);
    typedef IfcTemplatedEntityList< IfcPropertySetDefinition > list;
};
/// The property with a single value
/// IfcPropertySingleValue defines a property object which has
/// a single (numeric or descriptive) value assigned. It defines a
/// property - single value combination for which the property
/// Name, an optional Description,ÿand an optional
/// NominalValue with measure type is provided. In addition,
/// the default unit as specified within the project unit context can
/// be overriden by assigning an Unit.
/// The unit is handled by the Unit attribute:
/// 
/// If the Unit attribute is not given, then the unit is
/// already implied by the type of IfcMeasureValue or
/// IfcDerivedMeasureValue. The associated unit can be found
/// at the IfcUnitAssignment globally defined at the project
/// level (IfcProject.UnitsInContext).
/// If the Unit attribute is given, then the unit assigned
/// by the Unit attribute overrides the globally assigned
/// unit.
/// 
/// Examples of a property with single value are:
/// 
/// Name
/// NominalValue
/// Type (through IfcValue)
/// Unit
/// 
/// Description
/// Manufacturer "A" door
/// IfcLabel
/// -
/// 
/// PanelThickness
/// 0.12
/// IfcPositiveLengthMeasure
/// -
/// 
/// ThermalTransmittance
/// 2.6
/// IfcThermalTransmittanceMeasure
/// W/(m2K)
/// 
/// HISTORY ÿNew entity in IFC Release 1.0. The entity has been renamed from IfcSimpleProperty in IFC Release 2x.
/// 
/// IFC2x3 CHANGE ÿAttribute NominalValue has been made OPTIONAL with upward compatibility for file based exchange.
class IfcPropertySingleValue : public IfcSimpleProperty {
public:
    /// Whether the optional attribute NominalValue is defined for this IfcPropertySingleValue
    bool hasNominalValue() const;
    /// Value and measure type of this property. 
    /// 
    /// NOTE  By virtue of the defined data type, that is selected from the SELECT IfcValue, the appropriate unit can be found within the IfcUnitAssignment, defined for the project if no value for the unit attribute is given.
    /// 
    /// IFC2x3 CHANGE  The attribute has been made optional with upward compatibility for file based exchange.
    IfcValue* NominalValue() const;
    void setNominalValue(IfcValue* v);
    /// Whether the optional attribute Unit is defined for this IfcPropertySingleValue
    bool hasUnit() const;
    /// Unit for the nominal value, if not given, the default value for the measure type (given by the TYPE of nominal value) is used as defined by the global unit assignment at IfcProject.
    IfcUnit* Unit() const;
    void setUnit(IfcUnit* v);
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 2: return IfcUtil::Argument_ENTITY_INSTANCE; case 3: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcSimpleProperty::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 2: return Type::IfcValue; case 3: return Type::IfcUnit; } return IfcSimpleProperty::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 2: return "NominalValue"; case 3: return "Unit"; } return IfcSimpleProperty::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPropertySingleValue (IfcAbstractEntity* e);
    IfcPropertySingleValue (std::string v1_Name, boost::optional< std::string > v2_Description, IfcValue* v3_NominalValue, IfcUnit* v4_Unit);
    typedef IfcTemplatedEntityList< IfcPropertySingleValue > list;
};
/// A property with a range value
///   (IfcPropertyTableValue) defines a property object
///   which has two lists of (numeric or descriptive) values
///   assigned, the values specifying a table with two columns.
///   The defining values provide the first column and establish
///   the scope for the defined values (the second column).
///   Interpolations are out of scope of the
///   IfcPropertyTableValue. An optional Expression
///   attribute may give the equation used for deriving the range
///   value, which is for information purposes only.
/// 
/// The IfcPropertyTableValue defines a defining/defined
///   property value combination for which the property name, the
///   table with defining and defined values with measure type
///   (and optional the units for defining and defined values)
///   are given.
/// 
/// The units are handled by the DefiningUnit and
///   DefinedUnit attributes:
/// 
/// If the DefiningUnit or DefinedUnit
///   attribute is not given, then the unit is already implied by
///   the type of IfcMeasureValue or
///   IfcDerivedMeasureValue. The associated unit can be
///   found at the IfcUnitAssignment globally defined at
///   the project level (IfcProject.UnitsInContext).
/// 
/// If the DefiningUnit or DefinedUnit
///   attribute is given, then the unit assigned by the unit
///   attribute overrides the globally assigned unit.
/// 
/// The IfcPropertyTableValue allows for the
///   specification of a table of defining/defined value pairs of
///   the property description. The optional 
///   attribute CurveInterpolation allows to determine the 
///   interval between two given values.
/// 
/// Examples of a property with range value are:
/// 
/// Name
/// 
/// DefiningValues
/// 
/// DefiningValue Type (through IfcValue)
/// 
/// DefinedValues
/// 
/// DefinedValue Type (through
///   IfcValue)
/// 
/// DefingUnit
/// 
/// DefinedUnit
/// 
/// SoundTransmissionLoss
/// 
/// 100
/// 
/// IfcFrequencyMeasure
/// 
/// 20
/// 
/// IfcNumericMeasure
/// 
/// -
/// 
/// dB
/// 
/// ÿ
/// 
/// 200
/// 
/// IfcFrequencyMeasure
/// 
/// 42
/// 
/// IfcNumericMeasure
/// 
/// ÿ
/// 
/// ÿ
/// 
/// ÿ
/// 
/// 400
/// 
/// IfcFrequencyMeasure
/// 
/// 46
/// 
/// IfcNumericMeasure
/// 
/// ÿ
/// 
/// ÿ
/// 
/// ÿ
/// 
/// 800
/// 
/// IfcFrequencyMeasure
/// 
/// 56
/// 
/// IfcNumericMeasure
/// 
/// ÿ
/// 
/// ÿ
/// 
/// ÿ
/// 
/// 1600
/// 
/// IfcFrequencyMeasure
/// 
/// 60
/// 
/// IfcNumericMeasure
/// 
/// ÿ
/// 
/// ÿ
/// 
/// ÿ
/// 
/// 3200
/// 
/// IfcFrequencyMeasure
/// 
/// 65
/// 
/// IfcNumericMeasure
/// 
/// ÿ
/// 
/// ÿ
/// 
/// HISTORY: New entity in IFC2x.
/// 
/// IFC2x4 CHANGE  Attributes DefiningValues and DefinedValues have been made OPTIONAL with upward compatibility for file based exchange. The attribute CurveInterpolation has been added..
/// 
/// Informal propositions:
/// 
/// The list of DefinedValues and the list of
///   DefiningValues are corresponding lists.
class IfcPropertyTableValue : public IfcSimpleProperty {
public:
    /// List of defining values, which determine the defined values. This list shall have unique values only.
    /// 
    /// IFC2x4 CHANGE  The attribute has been made optional with upward compatibility for file based exchange.
    IfcEntityList::ptr DefiningValues() const;
    void setDefiningValues(IfcEntityList::ptr v);
    /// Defined values which are applicable for the scope as defined by the defining values.
    /// 
    /// IFC2x4 CHANGE  The attribute has been made optional with upward compatibility for file based exchange.
    IfcEntityList::ptr DefinedValues() const;
    void setDefinedValues(IfcEntityList::ptr v);
    /// Whether the optional attribute Expression is defined for this IfcPropertyTableValue
    bool hasExpression() const;
    /// Expression for the derivation of defined values from the defining values, the expression is given for information only, i.e. no automatic processing can be expected from the expression.
    std::string Expression() const;
    void setExpression(std::string v);
    /// Whether the optional attribute DefiningUnit is defined for this IfcPropertyTableValue
    bool hasDefiningUnit() const;
    /// Unit for the defining values, if not given, the default value for the measure type (given by the TYPE of the defining values) is used as defined by the global unit assignment at IfcProject.
    IfcUnit* DefiningUnit() const;
    void setDefiningUnit(IfcUnit* v);
    /// Whether the optional attribute DefinedUnit is defined for this IfcPropertyTableValue
    bool hasDefinedUnit() const;
    /// Unit for the defined values, if not given, the default value for the measure type (given by the TYPE of the defined values) is used as defined by the global unit assignment at IfcProject.
    IfcUnit* DefinedUnit() const;
    void setDefinedUnit(IfcUnit* v);
    virtual unsigned int getArgumentCount() const { return 7; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 2: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 3: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 4: return IfcUtil::Argument_STRING; case 5: return IfcUtil::Argument_ENTITY_INSTANCE; case 6: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcSimpleProperty::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 2: return Type::IfcValue; case 3: return Type::IfcValue; case 4: return Type::IfcText; case 5: return Type::IfcUnit; case 6: return Type::IfcUnit; } return IfcSimpleProperty::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 2: return "DefiningValues"; case 3: return "DefinedValues"; case 4: return "Expression"; case 5: return "DefiningUnit"; case 6: return "DefinedUnit"; } return IfcSimpleProperty::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPropertyTableValue (IfcAbstractEntity* e);
    IfcPropertyTableValue (std::string v1_Name, boost::optional< std::string > v2_Description, IfcEntityList::ptr v3_DefiningValues, IfcEntityList::ptr v4_DefinedValues, boost::optional< std::string > v5_Expression, IfcUnit* v6_DefiningUnit, IfcUnit* v7_DefinedUnit);
    typedef IfcTemplatedEntityList< IfcPropertyTableValue > list;
};
/// IfcRectangleProfileDef defines a rectangle as the profile definition used by the swept surface geometry or the swept area solid. It is given by its X extent and its Y extent, and placed within the 2D position coordinate system, established by the Position attribute. It is placed centric within the position coordinate system. 
/// 
/// HISTORY: New class in IFC 1.5. The use definition has changed in IFC Release 2x.
/// 
/// Figure 323 illustrates parameters of the rectangle profile definition.
/// 
/// Position
/// 
/// The parameterized profile defines its own position coordinate system.
/// The underlying
/// coordinate system is defined by the swept surface or swept area solid
/// that uses the profile definition. It is the xy plane of either: 
/// 
/// IfcSweptSurface.Position
///   IfcSweptAreaSolid.Position
/// 
/// or in case of sectioned spines the xy plane of each list member of IfcSectionedSpine.CrossSectionPositions.
/// 
/// By using offsets of the position location, the parameterized profile
/// can be positioned centric (using x,y offsets = 0.), or at any position
/// relative to the profile. Explicit coordinate offsets are used to define
/// cardinal points (for example, upper-left bound).
///   Parameter
/// 
/// The IfcRectangleProfileDef
/// is defined within the position
/// coordinate system, where the XDim
/// defines the length measure
/// for the length of the rectangle (half along the positive x-axis) and
/// the YDim
/// defines the length measure for the width of the
/// rectangle (half along the positive y-axis).
/// 
/// Figure 323 — Rectangle profile
class IfcRectangleProfileDef : public IfcParameterizedProfileDef {
public:
    /// The extent of the rectangle in the direction of the x-axis.
    double XDim() const;
    void setXDim(double v);
    /// The extent of the rectangle in the direction of the y-axis.
    double YDim() const;
    void setYDim(double v);
    virtual unsigned int getArgumentCount() const { return 5; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 3: return IfcUtil::Argument_DOUBLE; case 4: return IfcUtil::Argument_DOUBLE; } return IfcParameterizedProfileDef::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 3: return Type::IfcPositiveLengthMeasure; case 4: return Type::IfcPositiveLengthMeasure; } return IfcParameterizedProfileDef::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 3: return "XDim"; case 4: return "YDim"; } return IfcParameterizedProfileDef::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRectangleProfileDef (IfcAbstractEntity* e);
    IfcRectangleProfileDef (IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< std::string > v2_ProfileName, IfcAxis2Placement2D* v3_Position, double v4_XDim, double v5_YDim);
    typedef IfcTemplatedEntityList< IfcRectangleProfileDef > list;
};
/// In a regular time series, the data arrives predictably at predefined intervals. In a regular time series there is no need to store multiple time stamps and the algorithms for analyzing the time series are therefore significantly simpler.  Using the start time provided in the supertype, the time step is used to identify the frequency of the occurrences of the list of values.
/// 
/// EXAMPLE: A smoke detector samples the concentration of particulates in a space at a fixed rate (for example, every six seconds); a control system measures the outside air temperature every hour.
/// 
/// HISTORY: New entity in IFC 2x2.
class IfcRegularTimeSeries : public IfcTimeSeries {
public:
    /// A duration of time intervals between values.
    double TimeStep() const;
    void setTimeStep(double v);
    /// The collection of time series values.
    IfcTemplatedEntityList< IfcTimeSeriesValue >::ptr Values() const;
    void setValues(IfcTemplatedEntityList< IfcTimeSeriesValue >::ptr v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_DOUBLE; case 9: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } return IfcTimeSeries::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcTimeMeasure; case 9: return Type::IfcTimeSeriesValue; } return IfcTimeSeries::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "TimeStep"; case 9: return "Values"; } return IfcTimeSeries::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRegularTimeSeries (IfcAbstractEntity* e);
    IfcRegularTimeSeries (std::string v1_Name, boost::optional< std::string > v2_Description, IfcDateTimeSelect* v3_StartTime, IfcDateTimeSelect* v4_EndTime, IfcTimeSeriesDataTypeEnum::IfcTimeSeriesDataTypeEnum v5_TimeSeriesDataType, IfcDataOriginEnum::IfcDataOriginEnum v6_DataOrigin, boost::optional< std::string > v7_UserDefinedDataOrigin, IfcUnit* v8_Unit, double v9_TimeStep, IfcTemplatedEntityList< IfcTimeSeriesValue >::ptr v10_Values);
    typedef IfcTemplatedEntityList< IfcRegularTimeSeries > list;
};
/// Definition from IAI: An
///   IfcReinforcementDefinitionProperties defines the cross section
///   properties of reinforcement included in reinforced concrete building elements.
///   The property set definition may be used both in conjunction with insitu and
///   precast structures.  
/// 
/// HISTORY New entity in IFC Release 2x2
/// IFC 2x4 change: Supertype changed from IfcPropertySetDefinition to IfcPreDefinedPropertySet
/// 
/// General usage: 
///   This subtype of IfcPropertySetDefinition is used to define the
///   reinforcement properties in early design stages, such as in requirement
///   definition or scheme design. In later design stages explicit instances of
///   subtypes of IfcReinforcingElement are used. The intended usage may be
///   indicated using the DefinitionType attribute value as a designator:
///   recommended values are 'Reinforcement area requirement' or 'Reinforcement
///   configuration requirement'. Other values may be used according to local
///   standards.  
///   Only one property set definition of this kind is used for each concrete
///   building element in each intended usage indicated by the DefinitionType
///   attribute value. This set then defines a list of cross section properties in a
///   discrete number of longitudinal sections as instances of
///   IfcSectionReinforcementProperties (one for each structural reinforcement
///   bar role), which in turn have a section cross section property defined as a
///   profile and a number of reinforcement properties, one for each steel grade /
///   bar type.
class IfcReinforcementDefinitionProperties : public IfcPropertySetDefinition {
public:
    /// Whether the optional attribute DefinitionType is defined for this IfcReinforcementDefinitionProperties
    bool hasDefinitionType() const;
    /// Descriptive type name applied to reinforcement definition properties.
    std::string DefinitionType() const;
    void setDefinitionType(std::string v);
    /// The list of section reinforcement properties attached to the reinforcement definition properties.
    IfcTemplatedEntityList< IfcSectionReinforcementProperties >::ptr ReinforcementSectionDefinitions() const;
    void setReinforcementSectionDefinitions(IfcTemplatedEntityList< IfcSectionReinforcementProperties >::ptr v);
    virtual unsigned int getArgumentCount() const { return 6; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 4: return IfcUtil::Argument_STRING; case 5: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } return IfcPropertySetDefinition::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 4: return Type::IfcLabel; case 5: return Type::IfcSectionReinforcementProperties; } return IfcPropertySetDefinition::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 4: return "DefinitionType"; case 5: return "ReinforcementSectionDefinitions"; } return IfcPropertySetDefinition::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcReinforcementDefinitionProperties (IfcAbstractEntity* e);
    IfcReinforcementDefinitionProperties (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_DefinitionType, IfcTemplatedEntityList< IfcSectionReinforcementProperties >::ptr v6_ReinforcementSectionDefinitions);
    typedef IfcTemplatedEntityList< IfcReinforcementDefinitionProperties > list;
};
/// IfcRelationship is the abstract generalization of all objectified relationships in IFC. Objectified relationships are the preferred way to handle relationships among objects. This allows to keep relationship specific properties directly at the relationship and opens the possibility to later handle relationship specific behavior.  
/// 
/// There are two different types of relationships, 1-to-1 relationships and 1-to-many relationship. used within the subtypes of IfcRelationship. The following convention applies to all subtypes: 
/// 
/// The two sides of the objectified relationship are named - Relating+ and - Related+ 
/// In case of the 1-to-many relationship, the related side of the relationship shall be an aggregate SET 1:N 
/// 
/// HISTORY: New entity in IFC Release 1.0.
class IfcRelationship : public IfcRoot {
public:
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcRoot::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcRoot::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcRoot::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRelationship (IfcAbstractEntity* e);
    IfcRelationship (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description);
    typedef IfcTemplatedEntityList< IfcRelationship > list;
};
/// IfcRoundedRectangleProfileDef defines a rectangle with equally rounded corners as the profile definition used by the swept surface geometry or the swept area solid. It is given by the X extent, the Y extent, and the radius for the rounded corners, and placed within the 2D position coordinate system, established by the Position attribute. It is placed centric within the position coordinate system, that is, in the center of the bounding box.
/// 
/// HISTORY  New class in IFC2x.
/// 
/// IFC2x PLATFORM CHANGE  The IfcRoundedRectangleProfileDef is now subtyped from IfcRectangleProfileDef. The XDim and YDim attributes have been removed (now inherited from supertype).
/// 
/// Figure 324 illustrates parameters of the rounded rectangle profile definition.
/// 
/// Position
/// 
/// The parameterized profile defines its own position coordinate system.
/// The underlying
/// coordinate system is defined by the swept surface or swept area solid
/// that uses the profile definition. It is the xy plane of either: 
/// 
/// IfcSweptSurface.Position
///   IfcSweptAreaSolid.Position
/// 
/// or in case of sectioned spines the xy plane of each list member of IfcSectionedSpine.CrossSectionPositions.
/// 
/// By using offsets of the position location, the parameterized profile
/// can be positioned centric (using x,y offsets = 0.), or at any position
/// relative to the profile. Explicit coordinate offsets are used to define
/// cardinal points (e.g. upper-left bound).
///   Parameter
/// 
/// The IfcRoundedRectangleProfileDef
/// is defined within the
/// position coordinate system, where the XDim
/// defines the measure
/// for the length of the rectangle (half along the positive x-axis), the YDim
/// defines the length measure for the width of the rectangle (half along
/// the positive y-axis) and the RoundingRadius
/// defines the radius
/// of curvature in all four corners of the rectangle.
/// 
/// Figure 324 — Rounded rectangle profile
class IfcRoundedRectangleProfileDef : public IfcRectangleProfileDef {
public:
    /// Radius of the circular arcs by which all four corners of the rectangle are equally rounded.
    double RoundingRadius() const;
    void setRoundingRadius(double v);
    virtual unsigned int getArgumentCount() const { return 6; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 5: return IfcUtil::Argument_DOUBLE; } return IfcRectangleProfileDef::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 5: return Type::IfcPositiveLengthMeasure; } return IfcRectangleProfileDef::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 5: return "RoundingRadius"; } return IfcRectangleProfileDef::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRoundedRectangleProfileDef (IfcAbstractEntity* e);
    IfcRoundedRectangleProfileDef (IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< std::string > v2_ProfileName, IfcAxis2Placement2D* v3_Position, double v4_XDim, double v5_YDim, double v6_RoundingRadius);
    typedef IfcTemplatedEntityList< IfcRoundedRectangleProfileDef > list;
};
/// Definition from ISO 10303-42:1999: A sectioned
/// spine is a representation of the shape of a three dimensional
/// object composed of a spine curve and a number of planar cross
/// sections. The shape is defined between the first element of cross
/// sections and the last element of this set.
/// 
/// NOTE A sectioned spine may be used to represent a surface or a
/// solid but the interpolation of the shape between the
/// cross-sections is not defined. For the representation of a solid
/// all cross-sections are closed curves.
/// 
/// A sectioned spine
/// (IfcSectionedSpine) is a representation of the shape of a
/// three dimensional object composed by a number of planar cross
/// sections, and a spine curve. The shape is defined between the
/// first element of cross sections and the last element of the cross
/// sections. A sectioned spine may be used to represent a surface or
/// a solid but the interpolation of the shape between the cross
/// sections is not defined.
/// For the representation of a solid all cross sections are
/// areas. For representation of a surface all cross sections are
/// curves. The cross sections are defined as profiles, whereas the
/// consecutive profiles may be derived by a transformation of the
/// start profile or the previous consecutive profile.
/// The spine curve shall be of type IfcCompositeCurve,
/// each of its segments (IfcCompositeCurveSegment) shall
/// correspond to the part between exactly two consecutive
/// cross-sections.
/// 
/// NOTE: Corresponding ISO 10303 entity: sectioned spine. Please refer to ISO/DIS 10303-42-ed2:1999, p. 282 for the definition of the formal standard. The cross sections are defined in IFC as IfcProfileDef. The position coordinate systems are added.
/// 
/// HISTORY New entity in IFC Release 2x.
/// 
/// Figure 268 illustrates an example of an IfcSectionedSpine.
/// 
/// The SpineCurve is given by an IfcCompositeCurve with two Segments. The Segments[1] has a ParentCurve of type IfcPolyline and a Transition = CONTSAMEGRADIENT. The Segments[2] has a ParentCurve of type
/// IfcTrimmedCurve and a Transition = DISCONTINUOUS.
/// Each CrossSectionPosition lies at a start or end point of the Segments.
/// Each CrossSections are inserted by the CrossSectionPositions. The first two cross sections are of
/// type IfcRectangleProfileDef, the third is of type IfcDerivedProfileDef.
/// 
/// Figure 268 — Sectioned spine geometry
/// 
/// Figure 269 illustrates the final result of the IfcSectionedSpine. The body (shown transparently) is not fully defined by the
/// exchange definition.
/// 
/// Figure 269 — Sectioned spine result
/// 
/// Informal propositions
/// 
/// none of the cross sections, after being placed by the cross section positions, shall intersect
/// none of the cross sections, after being placed by the cross section positions, shall lie in the same plane
/// the local origin of each cross section position shall lie at the beginning or end of a composite curve segment.
class IfcSectionedSpine : public IfcGeometricRepresentationItem {
public:
    /// A single composite curve, that defines the spine curve. Each of the composite curve segments correspond to the part between two cross-sections.
    IfcCompositeCurve* SpineCurve() const;
    void setSpineCurve(IfcCompositeCurve* v);
    /// A list of at least two cross sections, each defined within the xy plane of the position coordinate system of the cross section. The position coordinate system is given by the corresponding list CrossSectionPositions.
    IfcTemplatedEntityList< IfcProfileDef >::ptr CrossSections() const;
    void setCrossSections(IfcTemplatedEntityList< IfcProfileDef >::ptr v);
    /// Position coordinate systems for the cross sections that form the sectioned spine. The profiles defining the cross sections are positioned within the xy plane of the corresponding position coordinate system.
    IfcTemplatedEntityList< IfcAxis2Placement3D >::ptr CrossSectionPositions() const;
    void setCrossSectionPositions(IfcTemplatedEntityList< IfcAxis2Placement3D >::ptr v);
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 2: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } return IfcGeometricRepresentationItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcCompositeCurve; case 1: return Type::IfcProfileDef; case 2: return Type::IfcAxis2Placement3D; } return IfcGeometricRepresentationItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "SpineCurve"; case 1: return "CrossSections"; case 2: return "CrossSectionPositions"; } return IfcGeometricRepresentationItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcSectionedSpine (IfcAbstractEntity* e);
    IfcSectionedSpine (IfcCompositeCurve* v1_SpineCurve, IfcTemplatedEntityList< IfcProfileDef >::ptr v2_CrossSections, IfcTemplatedEntityList< IfcAxis2Placement3D >::ptr v3_CrossSectionPositions);
    typedef IfcTemplatedEntityList< IfcSectionedSpine > list;
};

class IfcServiceLifeFactor : public IfcPropertySetDefinition {
public:
    IfcServiceLifeFactorTypeEnum::IfcServiceLifeFactorTypeEnum PredefinedType() const;
    void setPredefinedType(IfcServiceLifeFactorTypeEnum::IfcServiceLifeFactorTypeEnum v);
    /// Whether the optional attribute UpperValue is defined for this IfcServiceLifeFactor
    bool hasUpperValue() const;
    IfcMeasureValue* UpperValue() const;
    void setUpperValue(IfcMeasureValue* v);
    IfcMeasureValue* MostUsedValue() const;
    void setMostUsedValue(IfcMeasureValue* v);
    /// Whether the optional attribute LowerValue is defined for this IfcServiceLifeFactor
    bool hasLowerValue() const;
    IfcMeasureValue* LowerValue() const;
    void setLowerValue(IfcMeasureValue* v);
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 4: return IfcUtil::Argument_ENUMERATION; case 5: return IfcUtil::Argument_ENTITY_INSTANCE; case 6: return IfcUtil::Argument_ENTITY_INSTANCE; case 7: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcPropertySetDefinition::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 4: return Type::IfcServiceLifeFactorTypeEnum; case 5: return Type::IfcMeasureValue; case 6: return Type::IfcMeasureValue; case 7: return Type::IfcMeasureValue; } return IfcPropertySetDefinition::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 4: return "PredefinedType"; case 5: return "UpperValue"; case 6: return "MostUsedValue"; case 7: return "LowerValue"; } return IfcPropertySetDefinition::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcServiceLifeFactor (IfcAbstractEntity* e);
    IfcServiceLifeFactor (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcServiceLifeFactorTypeEnum::IfcServiceLifeFactorTypeEnum v5_PredefinedType, IfcMeasureValue* v6_UpperValue, IfcMeasureValue* v7_MostUsedValue, IfcMeasureValue* v8_LowerValue);
    typedef IfcTemplatedEntityList< IfcServiceLifeFactor > list;
};
/// Definition from ISO/CD 10303-42:1992: A shell based surface model is described by a set of open or closed shells of dimensionality 2. The shells shall not intersect except at edges and vertices. In particular, distinct faces may not intersect. A complete face of one shell may be shared with another shell. Coincident portions of shells shall both reference the same faces, edges and vertices defining the coincident region. There shall be at least one shell. 
/// 
/// A shell may exist independently of a surface model. 
/// 
/// NOTE Corresponding ISO 10303-42 entity: shell_based_surface_model. Please refer to ISO/IS 10303-42:1994, p. 187 for the final definition of the formal standard.
/// 
/// HISTORY: New entity in IFC Release 2x.
/// 
/// Informal propositions 
/// 
/// The dimensionality of the shell based surface model is 2.  
/// The shells shall not overlap or intersect except at common faces, edges or vertices.
class IfcShellBasedSurfaceModel : public IfcGeometricRepresentationItem {
public:
    IfcEntityList::ptr SbsmBoundary() const;
    void setSbsmBoundary(IfcEntityList::ptr v);
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } return IfcGeometricRepresentationItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcShell; } return IfcGeometricRepresentationItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "SbsmBoundary"; } return IfcGeometricRepresentationItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcShellBasedSurfaceModel (IfcAbstractEntity* e);
    IfcShellBasedSurfaceModel (IfcEntityList::ptr v1_SbsmBoundary);
    typedef IfcTemplatedEntityList< IfcShellBasedSurfaceModel > list;
};
/// Definition from IAI: Describes slippage in support conditions or connection conditions.  Slippage means that a relative displacement may occur in a support or connection before support or connection reactions are awoken.
/// 
/// Applicability:
/// 
/// Point supports and connections,
///   curve supports and connections,
///   surface supports and connections.
/// 
/// HISTORY: New entity in IFC 2x2.
class IfcSlippageConnectionCondition : public IfcStructuralConnectionCondition {
public:
    /// Whether the optional attribute SlippageX is defined for this IfcSlippageConnectionCondition
    bool hasSlippageX() const;
    /// Slippage in x-direction of the coordinate system defined by the instance which uses this resource object.
    double SlippageX() const;
    void setSlippageX(double v);
    /// Whether the optional attribute SlippageY is defined for this IfcSlippageConnectionCondition
    bool hasSlippageY() const;
    /// Slippage in y-direction of the coordinate system defined by the instance which uses this resource object.
    double SlippageY() const;
    void setSlippageY(double v);
    /// Whether the optional attribute SlippageZ is defined for this IfcSlippageConnectionCondition
    bool hasSlippageZ() const;
    /// Slippage in z-direction of the coordinate system defined by the instance which uses this resource object.
    double SlippageZ() const;
    void setSlippageZ(double v);
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 1: return IfcUtil::Argument_DOUBLE; case 2: return IfcUtil::Argument_DOUBLE; case 3: return IfcUtil::Argument_DOUBLE; } return IfcStructuralConnectionCondition::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 1: return Type::IfcLengthMeasure; case 2: return Type::IfcLengthMeasure; case 3: return Type::IfcLengthMeasure; } return IfcStructuralConnectionCondition::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 1: return "SlippageX"; case 2: return "SlippageY"; case 3: return "SlippageZ"; } return IfcStructuralConnectionCondition::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcSlippageConnectionCondition (IfcAbstractEntity* e);
    IfcSlippageConnectionCondition (boost::optional< std::string > v1_Name, boost::optional< double > v2_SlippageX, boost::optional< double > v3_SlippageY, boost::optional< double > v4_SlippageZ);
    typedef IfcTemplatedEntityList< IfcSlippageConnectionCondition > list;
};
/// Definition from ISO/CD 10303-42:1992: A solid model is a complete representation of the nominal shape of a product such that all points in the interior are connected. Any point can be classified as being inside, outside, or on the boundary of a solid. There are several different types of solid model representations. 
/// 
/// NOTE: Corresponding ISO 10303-42 entity: solid_model, only three subtypes have been incorporated into the current IFC Release - subset of manifold_solid_brep (IfcManifoldSolidBrep, constraint to faceted B-rep), swept_area_solid (IfcSweptAreaSolid), the swept_disk_solid (IfcSweptDiskSolid) and subset of csg_solid (IfcCsgSolid). The derived attribute Dim has been added at this level and was therefore demoted from the geometric_representation_item. Please refer to ISO/IS 10303-42:1994, p. 170 for the final definition of the formal standard.
/// 
/// HISTORY: New entity in IFC Release 1.5
class IfcSolidModel : public IfcGeometricRepresentationItem {
public:
    virtual unsigned int getArgumentCount() const { return 0; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcGeometricRepresentationItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcGeometricRepresentationItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcGeometricRepresentationItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcSolidModel (IfcAbstractEntity* e);
    IfcSolidModel ();
    typedef IfcTemplatedEntityList< IfcSolidModel > list;
};

class IfcSoundProperties : public IfcPropertySetDefinition {
public:
    bool IsAttenuating() const;
    void setIsAttenuating(bool v);
    /// Whether the optional attribute SoundScale is defined for this IfcSoundProperties
    bool hasSoundScale() const;
    IfcSoundScaleEnum::IfcSoundScaleEnum SoundScale() const;
    void setSoundScale(IfcSoundScaleEnum::IfcSoundScaleEnum v);
    IfcTemplatedEntityList< IfcSoundValue >::ptr SoundValues() const;
    void setSoundValues(IfcTemplatedEntityList< IfcSoundValue >::ptr v);
    virtual unsigned int getArgumentCount() const { return 7; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 4: return IfcUtil::Argument_BOOL; case 5: return IfcUtil::Argument_ENUMERATION; case 6: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } return IfcPropertySetDefinition::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 4: return Type::IfcBoolean; case 5: return Type::IfcSoundScaleEnum; case 6: return Type::IfcSoundValue; } return IfcPropertySetDefinition::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 4: return "IsAttenuating"; case 5: return "SoundScale"; case 6: return "SoundValues"; } return IfcPropertySetDefinition::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcSoundProperties (IfcAbstractEntity* e);
    IfcSoundProperties (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, bool v5_IsAttenuating, boost::optional< IfcSoundScaleEnum::IfcSoundScaleEnum > v6_SoundScale, IfcTemplatedEntityList< IfcSoundValue >::ptr v7_SoundValues);
    typedef IfcTemplatedEntityList< IfcSoundProperties > list;
};

class IfcSoundValue : public IfcPropertySetDefinition {
public:
    /// Whether the optional attribute SoundLevelTimeSeries is defined for this IfcSoundValue
    bool hasSoundLevelTimeSeries() const;
    IfcTimeSeries* SoundLevelTimeSeries() const;
    void setSoundLevelTimeSeries(IfcTimeSeries* v);
    double Frequency() const;
    void setFrequency(double v);
    /// Whether the optional attribute SoundLevelSingleValue is defined for this IfcSoundValue
    bool hasSoundLevelSingleValue() const;
    IfcDerivedMeasureValue* SoundLevelSingleValue() const;
    void setSoundLevelSingleValue(IfcDerivedMeasureValue* v);
    virtual unsigned int getArgumentCount() const { return 7; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 4: return IfcUtil::Argument_ENTITY_INSTANCE; case 5: return IfcUtil::Argument_DOUBLE; case 6: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcPropertySetDefinition::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 4: return Type::IfcTimeSeries; case 5: return Type::IfcFrequencyMeasure; case 6: return Type::IfcDerivedMeasureValue; } return IfcPropertySetDefinition::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 4: return "SoundLevelTimeSeries"; case 5: return "Frequency"; case 6: return "SoundLevelSingleValue"; } return IfcPropertySetDefinition::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcSoundValue (IfcAbstractEntity* e);
    IfcSoundValue (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcTimeSeries* v5_SoundLevelTimeSeries, double v6_Frequency, IfcDerivedMeasureValue* v7_SoundLevelSingleValue);
    typedef IfcTemplatedEntityList< IfcSoundValue > list;
};

class IfcSpaceThermalLoadProperties : public IfcPropertySetDefinition {
public:
    /// Whether the optional attribute ApplicableValueRatio is defined for this IfcSpaceThermalLoadProperties
    bool hasApplicableValueRatio() const;
    double ApplicableValueRatio() const;
    void setApplicableValueRatio(double v);
    IfcThermalLoadSourceEnum::IfcThermalLoadSourceEnum ThermalLoadSource() const;
    void setThermalLoadSource(IfcThermalLoadSourceEnum::IfcThermalLoadSourceEnum v);
    IfcPropertySourceEnum::IfcPropertySourceEnum PropertySource() const;
    void setPropertySource(IfcPropertySourceEnum::IfcPropertySourceEnum v);
    /// Whether the optional attribute SourceDescription is defined for this IfcSpaceThermalLoadProperties
    bool hasSourceDescription() const;
    std::string SourceDescription() const;
    void setSourceDescription(std::string v);
    double MaximumValue() const;
    void setMaximumValue(double v);
    /// Whether the optional attribute MinimumValue is defined for this IfcSpaceThermalLoadProperties
    bool hasMinimumValue() const;
    double MinimumValue() const;
    void setMinimumValue(double v);
    /// Whether the optional attribute ThermalLoadTimeSeriesValues is defined for this IfcSpaceThermalLoadProperties
    bool hasThermalLoadTimeSeriesValues() const;
    IfcTimeSeries* ThermalLoadTimeSeriesValues() const;
    void setThermalLoadTimeSeriesValues(IfcTimeSeries* v);
    /// Whether the optional attribute UserDefinedThermalLoadSource is defined for this IfcSpaceThermalLoadProperties
    bool hasUserDefinedThermalLoadSource() const;
    std::string UserDefinedThermalLoadSource() const;
    void setUserDefinedThermalLoadSource(std::string v);
    /// Whether the optional attribute UserDefinedPropertySource is defined for this IfcSpaceThermalLoadProperties
    bool hasUserDefinedPropertySource() const;
    std::string UserDefinedPropertySource() const;
    void setUserDefinedPropertySource(std::string v);
    IfcThermalLoadTypeEnum::IfcThermalLoadTypeEnum ThermalLoadType() const;
    void setThermalLoadType(IfcThermalLoadTypeEnum::IfcThermalLoadTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 14; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 4: return IfcUtil::Argument_DOUBLE; case 5: return IfcUtil::Argument_ENUMERATION; case 6: return IfcUtil::Argument_ENUMERATION; case 7: return IfcUtil::Argument_STRING; case 8: return IfcUtil::Argument_DOUBLE; case 9: return IfcUtil::Argument_DOUBLE; case 10: return IfcUtil::Argument_ENTITY_INSTANCE; case 11: return IfcUtil::Argument_STRING; case 12: return IfcUtil::Argument_STRING; case 13: return IfcUtil::Argument_ENUMERATION; } return IfcPropertySetDefinition::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 4: return Type::IfcPositiveRatioMeasure; case 5: return Type::IfcThermalLoadSourceEnum; case 6: return Type::IfcPropertySourceEnum; case 7: return Type::IfcText; case 8: return Type::IfcPowerMeasure; case 9: return Type::IfcPowerMeasure; case 10: return Type::IfcTimeSeries; case 11: return Type::IfcLabel; case 12: return Type::IfcLabel; case 13: return Type::IfcThermalLoadTypeEnum; } return IfcPropertySetDefinition::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 4: return "ApplicableValueRatio"; case 5: return "ThermalLoadSource"; case 6: return "PropertySource"; case 7: return "SourceDescription"; case 8: return "MaximumValue"; case 9: return "MinimumValue"; case 10: return "ThermalLoadTimeSeriesValues"; case 11: return "UserDefinedThermalLoadSource"; case 12: return "UserDefinedPropertySource"; case 13: return "ThermalLoadType"; } return IfcPropertySetDefinition::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcSpaceThermalLoadProperties (IfcAbstractEntity* e);
    IfcSpaceThermalLoadProperties (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< double > v5_ApplicableValueRatio, IfcThermalLoadSourceEnum::IfcThermalLoadSourceEnum v6_ThermalLoadSource, IfcPropertySourceEnum::IfcPropertySourceEnum v7_PropertySource, boost::optional< std::string > v8_SourceDescription, double v9_MaximumValue, boost::optional< double > v10_MinimumValue, IfcTimeSeries* v11_ThermalLoadTimeSeriesValues, boost::optional< std::string > v12_UserDefinedThermalLoadSource, boost::optional< std::string > v13_UserDefinedPropertySource, IfcThermalLoadTypeEnum::IfcThermalLoadTypeEnum v14_ThermalLoadType);
    typedef IfcTemplatedEntityList< IfcSpaceThermalLoadProperties > list;
};
/// Definition from IAI: An instance of the entity
///   IfcStructuralLoadLinearForce shall be used to define actions on curves.
/// 
/// HISTORY: New entity in Release IFC2x
///   edition 2.
class IfcStructuralLoadLinearForce : public IfcStructuralLoadStatic {
public:
    /// Whether the optional attribute LinearForceX is defined for this IfcStructuralLoadLinearForce
    bool hasLinearForceX() const;
    /// Linear force value in x-direction.
    double LinearForceX() const;
    void setLinearForceX(double v);
    /// Whether the optional attribute LinearForceY is defined for this IfcStructuralLoadLinearForce
    bool hasLinearForceY() const;
    /// Linear force value in y-direction.
    double LinearForceY() const;
    void setLinearForceY(double v);
    /// Whether the optional attribute LinearForceZ is defined for this IfcStructuralLoadLinearForce
    bool hasLinearForceZ() const;
    /// Linear force value in z-direction.
    double LinearForceZ() const;
    void setLinearForceZ(double v);
    /// Whether the optional attribute LinearMomentX is defined for this IfcStructuralLoadLinearForce
    bool hasLinearMomentX() const;
    /// Linear moment about the x-axis.
    double LinearMomentX() const;
    void setLinearMomentX(double v);
    /// Whether the optional attribute LinearMomentY is defined for this IfcStructuralLoadLinearForce
    bool hasLinearMomentY() const;
    /// Linear moment about the y-axis.
    double LinearMomentY() const;
    void setLinearMomentY(double v);
    /// Whether the optional attribute LinearMomentZ is defined for this IfcStructuralLoadLinearForce
    bool hasLinearMomentZ() const;
    /// Linear moment about the z-axis.
    double LinearMomentZ() const;
    void setLinearMomentZ(double v);
    virtual unsigned int getArgumentCount() const { return 7; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 1: return IfcUtil::Argument_DOUBLE; case 2: return IfcUtil::Argument_DOUBLE; case 3: return IfcUtil::Argument_DOUBLE; case 4: return IfcUtil::Argument_DOUBLE; case 5: return IfcUtil::Argument_DOUBLE; case 6: return IfcUtil::Argument_DOUBLE; } return IfcStructuralLoadStatic::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 1: return Type::IfcLinearForceMeasure; case 2: return Type::IfcLinearForceMeasure; case 3: return Type::IfcLinearForceMeasure; case 4: return Type::IfcLinearMomentMeasure; case 5: return Type::IfcLinearMomentMeasure; case 6: return Type::IfcLinearMomentMeasure; } return IfcStructuralLoadStatic::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 1: return "LinearForceX"; case 2: return "LinearForceY"; case 3: return "LinearForceZ"; case 4: return "LinearMomentX"; case 5: return "LinearMomentY"; case 6: return "LinearMomentZ"; } return IfcStructuralLoadStatic::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcStructuralLoadLinearForce (IfcAbstractEntity* e);
    IfcStructuralLoadLinearForce (boost::optional< std::string > v1_Name, boost::optional< double > v2_LinearForceX, boost::optional< double > v3_LinearForceY, boost::optional< double > v4_LinearForceZ, boost::optional< double > v5_LinearMomentX, boost::optional< double > v6_LinearMomentY, boost::optional< double > v7_LinearMomentZ);
    typedef IfcTemplatedEntityList< IfcStructuralLoadLinearForce > list;
};
/// Definition from IAI: An instance of the entity
///   IfcStructuralLoadPlanarForce shall be used to define actions on faces.
/// 
/// HISTORY: New entity in Release IFC2x
///   edition 2.
class IfcStructuralLoadPlanarForce : public IfcStructuralLoadStatic {
public:
    /// Whether the optional attribute PlanarForceX is defined for this IfcStructuralLoadPlanarForce
    bool hasPlanarForceX() const;
    /// Planar force value in x-direction.
    double PlanarForceX() const;
    void setPlanarForceX(double v);
    /// Whether the optional attribute PlanarForceY is defined for this IfcStructuralLoadPlanarForce
    bool hasPlanarForceY() const;
    /// Planar force value in y-direction.
    double PlanarForceY() const;
    void setPlanarForceY(double v);
    /// Whether the optional attribute PlanarForceZ is defined for this IfcStructuralLoadPlanarForce
    bool hasPlanarForceZ() const;
    /// Planar force value in z-direction.
    double PlanarForceZ() const;
    void setPlanarForceZ(double v);
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 1: return IfcUtil::Argument_DOUBLE; case 2: return IfcUtil::Argument_DOUBLE; case 3: return IfcUtil::Argument_DOUBLE; } return IfcStructuralLoadStatic::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 1: return Type::IfcPlanarForceMeasure; case 2: return Type::IfcPlanarForceMeasure; case 3: return Type::IfcPlanarForceMeasure; } return IfcStructuralLoadStatic::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 1: return "PlanarForceX"; case 2: return "PlanarForceY"; case 3: return "PlanarForceZ"; } return IfcStructuralLoadStatic::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcStructuralLoadPlanarForce (IfcAbstractEntity* e);
    IfcStructuralLoadPlanarForce (boost::optional< std::string > v1_Name, boost::optional< double > v2_PlanarForceX, boost::optional< double > v3_PlanarForceY, boost::optional< double > v4_PlanarForceZ);
    typedef IfcTemplatedEntityList< IfcStructuralLoadPlanarForce > list;
};
/// Definition from IAI: Instances of the entity
///   IfcStructuralLoadSingleDisplacement shall be used to define displacements.
/// 
/// HISTORY: New entity in Release IFC2x
///   edition 2.
class IfcStructuralLoadSingleDisplacement : public IfcStructuralLoadStatic {
public:
    /// Whether the optional attribute DisplacementX is defined for this IfcStructuralLoadSingleDisplacement
    bool hasDisplacementX() const;
    /// Displacement in x-direction.
    double DisplacementX() const;
    void setDisplacementX(double v);
    /// Whether the optional attribute DisplacementY is defined for this IfcStructuralLoadSingleDisplacement
    bool hasDisplacementY() const;
    /// Displacement in y-direction.
    double DisplacementY() const;
    void setDisplacementY(double v);
    /// Whether the optional attribute DisplacementZ is defined for this IfcStructuralLoadSingleDisplacement
    bool hasDisplacementZ() const;
    /// Displacement in z-direction.
    double DisplacementZ() const;
    void setDisplacementZ(double v);
    /// Whether the optional attribute RotationalDisplacementRX is defined for this IfcStructuralLoadSingleDisplacement
    bool hasRotationalDisplacementRX() const;
    /// Rotation about the x-axis.
    double RotationalDisplacementRX() const;
    void setRotationalDisplacementRX(double v);
    /// Whether the optional attribute RotationalDisplacementRY is defined for this IfcStructuralLoadSingleDisplacement
    bool hasRotationalDisplacementRY() const;
    /// Rotation about the y-axis.
    double RotationalDisplacementRY() const;
    void setRotationalDisplacementRY(double v);
    /// Whether the optional attribute RotationalDisplacementRZ is defined for this IfcStructuralLoadSingleDisplacement
    bool hasRotationalDisplacementRZ() const;
    /// Rotation about the z-axis.
    double RotationalDisplacementRZ() const;
    void setRotationalDisplacementRZ(double v);
    virtual unsigned int getArgumentCount() const { return 7; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 1: return IfcUtil::Argument_DOUBLE; case 2: return IfcUtil::Argument_DOUBLE; case 3: return IfcUtil::Argument_DOUBLE; case 4: return IfcUtil::Argument_DOUBLE; case 5: return IfcUtil::Argument_DOUBLE; case 6: return IfcUtil::Argument_DOUBLE; } return IfcStructuralLoadStatic::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 1: return Type::IfcLengthMeasure; case 2: return Type::IfcLengthMeasure; case 3: return Type::IfcLengthMeasure; case 4: return Type::IfcPlaneAngleMeasure; case 5: return Type::IfcPlaneAngleMeasure; case 6: return Type::IfcPlaneAngleMeasure; } return IfcStructuralLoadStatic::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 1: return "DisplacementX"; case 2: return "DisplacementY"; case 3: return "DisplacementZ"; case 4: return "RotationalDisplacementRX"; case 5: return "RotationalDisplacementRY"; case 6: return "RotationalDisplacementRZ"; } return IfcStructuralLoadStatic::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcStructuralLoadSingleDisplacement (IfcAbstractEntity* e);
    IfcStructuralLoadSingleDisplacement (boost::optional< std::string > v1_Name, boost::optional< double > v2_DisplacementX, boost::optional< double > v3_DisplacementY, boost::optional< double > v4_DisplacementZ, boost::optional< double > v5_RotationalDisplacementRX, boost::optional< double > v6_RotationalDisplacementRY, boost::optional< double > v7_RotationalDisplacementRZ);
    typedef IfcTemplatedEntityList< IfcStructuralLoadSingleDisplacement > list;
};
/// Definition from IAI: Defines a displacement with warping.
/// 
/// HISTORY: New entity in IFC 2x2.
class IfcStructuralLoadSingleDisplacementDistortion : public IfcStructuralLoadSingleDisplacement {
public:
    /// Whether the optional attribute Distortion is defined for this IfcStructuralLoadSingleDisplacementDistortion
    bool hasDistortion() const;
    /// The distortion curvature (warping, i.e. a cross-sectional deplanation) given to the displacement load.
    double Distortion() const;
    void setDistortion(double v);
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 7: return IfcUtil::Argument_DOUBLE; } return IfcStructuralLoadSingleDisplacement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 7: return Type::IfcCurvatureMeasure; } return IfcStructuralLoadSingleDisplacement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 7: return "Distortion"; } return IfcStructuralLoadSingleDisplacement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcStructuralLoadSingleDisplacementDistortion (IfcAbstractEntity* e);
    IfcStructuralLoadSingleDisplacementDistortion (boost::optional< std::string > v1_Name, boost::optional< double > v2_DisplacementX, boost::optional< double > v3_DisplacementY, boost::optional< double > v4_DisplacementZ, boost::optional< double > v5_RotationalDisplacementRX, boost::optional< double > v6_RotationalDisplacementRY, boost::optional< double > v7_RotationalDisplacementRZ, boost::optional< double > v8_Distortion);
    typedef IfcTemplatedEntityList< IfcStructuralLoadSingleDisplacementDistortion > list;
};
/// Definition from IAI: Instances of the entity
///   IfcStructuralLoadSingleForce shall be used to define the forces and
///   moments of an action operating on a single point. 
/// 
/// HISTORY: New entity in Release IFC2x
///   edition 2.
class IfcStructuralLoadSingleForce : public IfcStructuralLoadStatic {
public:
    /// Whether the optional attribute ForceX is defined for this IfcStructuralLoadSingleForce
    bool hasForceX() const;
    /// Force value in x-direction.
    double ForceX() const;
    void setForceX(double v);
    /// Whether the optional attribute ForceY is defined for this IfcStructuralLoadSingleForce
    bool hasForceY() const;
    /// Force value in y-direction.
    double ForceY() const;
    void setForceY(double v);
    /// Whether the optional attribute ForceZ is defined for this IfcStructuralLoadSingleForce
    bool hasForceZ() const;
    /// Force value in z-direction.
    double ForceZ() const;
    void setForceZ(double v);
    /// Whether the optional attribute MomentX is defined for this IfcStructuralLoadSingleForce
    bool hasMomentX() const;
    /// Moment about the x-axis.
    double MomentX() const;
    void setMomentX(double v);
    /// Whether the optional attribute MomentY is defined for this IfcStructuralLoadSingleForce
    bool hasMomentY() const;
    /// Moment about the y-axis.
    double MomentY() const;
    void setMomentY(double v);
    /// Whether the optional attribute MomentZ is defined for this IfcStructuralLoadSingleForce
    bool hasMomentZ() const;
    /// Moment about the z-axis.
    double MomentZ() const;
    void setMomentZ(double v);
    virtual unsigned int getArgumentCount() const { return 7; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 1: return IfcUtil::Argument_DOUBLE; case 2: return IfcUtil::Argument_DOUBLE; case 3: return IfcUtil::Argument_DOUBLE; case 4: return IfcUtil::Argument_DOUBLE; case 5: return IfcUtil::Argument_DOUBLE; case 6: return IfcUtil::Argument_DOUBLE; } return IfcStructuralLoadStatic::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 1: return Type::IfcForceMeasure; case 2: return Type::IfcForceMeasure; case 3: return Type::IfcForceMeasure; case 4: return Type::IfcTorqueMeasure; case 5: return Type::IfcTorqueMeasure; case 6: return Type::IfcTorqueMeasure; } return IfcStructuralLoadStatic::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 1: return "ForceX"; case 2: return "ForceY"; case 3: return "ForceZ"; case 4: return "MomentX"; case 5: return "MomentY"; case 6: return "MomentZ"; } return IfcStructuralLoadStatic::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcStructuralLoadSingleForce (IfcAbstractEntity* e);
    IfcStructuralLoadSingleForce (boost::optional< std::string > v1_Name, boost::optional< double > v2_ForceX, boost::optional< double > v3_ForceY, boost::optional< double > v4_ForceZ, boost::optional< double > v5_MomentX, boost::optional< double > v6_MomentY, boost::optional< double > v7_MomentZ);
    typedef IfcTemplatedEntityList< IfcStructuralLoadSingleForce > list;
};
/// Definition from IAI: Instances of the entity
///   IfcStructuralLoadSingleForceWarping, as a subtype of
///   IfcStructuralLoadSingleForce, shall be used to define an action operation
///   on a single point. In addition to forces and moments defined by its supertype a
///   warping moment can be defined.  
/// 
/// HISTORY: New entity in Release IFC2x
///   edition 2.
class IfcStructuralLoadSingleForceWarping : public IfcStructuralLoadSingleForce {
public:
    /// Whether the optional attribute WarpingMoment is defined for this IfcStructuralLoadSingleForceWarping
    bool hasWarpingMoment() const;
    /// The warping moment at the point load.
    double WarpingMoment() const;
    void setWarpingMoment(double v);
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 7: return IfcUtil::Argument_DOUBLE; } return IfcStructuralLoadSingleForce::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 7: return Type::IfcWarpingMomentMeasure; } return IfcStructuralLoadSingleForce::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 7: return "WarpingMoment"; } return IfcStructuralLoadSingleForce::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcStructuralLoadSingleForceWarping (IfcAbstractEntity* e);
    IfcStructuralLoadSingleForceWarping (boost::optional< std::string > v1_Name, boost::optional< double > v2_ForceX, boost::optional< double > v3_ForceY, boost::optional< double > v4_ForceZ, boost::optional< double > v5_MomentX, boost::optional< double > v6_MomentY, boost::optional< double > v7_MomentZ, boost::optional< double > v8_WarpingMoment);
    typedef IfcTemplatedEntityList< IfcStructuralLoadSingleForceWarping > list;
};

class IfcStructuralProfileProperties : public IfcGeneralProfileProperties {
public:
    /// Whether the optional attribute TorsionalConstantX is defined for this IfcStructuralProfileProperties
    bool hasTorsionalConstantX() const;
    double TorsionalConstantX() const;
    void setTorsionalConstantX(double v);
    /// Whether the optional attribute MomentOfInertiaYZ is defined for this IfcStructuralProfileProperties
    bool hasMomentOfInertiaYZ() const;
    double MomentOfInertiaYZ() const;
    void setMomentOfInertiaYZ(double v);
    /// Whether the optional attribute MomentOfInertiaY is defined for this IfcStructuralProfileProperties
    bool hasMomentOfInertiaY() const;
    double MomentOfInertiaY() const;
    void setMomentOfInertiaY(double v);
    /// Whether the optional attribute MomentOfInertiaZ is defined for this IfcStructuralProfileProperties
    bool hasMomentOfInertiaZ() const;
    double MomentOfInertiaZ() const;
    void setMomentOfInertiaZ(double v);
    /// Whether the optional attribute WarpingConstant is defined for this IfcStructuralProfileProperties
    bool hasWarpingConstant() const;
    double WarpingConstant() const;
    void setWarpingConstant(double v);
    /// Whether the optional attribute ShearCentreZ is defined for this IfcStructuralProfileProperties
    bool hasShearCentreZ() const;
    double ShearCentreZ() const;
    void setShearCentreZ(double v);
    /// Whether the optional attribute ShearCentreY is defined for this IfcStructuralProfileProperties
    bool hasShearCentreY() const;
    double ShearCentreY() const;
    void setShearCentreY(double v);
    /// Whether the optional attribute ShearDeformationAreaZ is defined for this IfcStructuralProfileProperties
    bool hasShearDeformationAreaZ() const;
    double ShearDeformationAreaZ() const;
    void setShearDeformationAreaZ(double v);
    /// Whether the optional attribute ShearDeformationAreaY is defined for this IfcStructuralProfileProperties
    bool hasShearDeformationAreaY() const;
    double ShearDeformationAreaY() const;
    void setShearDeformationAreaY(double v);
    /// Whether the optional attribute MaximumSectionModulusY is defined for this IfcStructuralProfileProperties
    bool hasMaximumSectionModulusY() const;
    double MaximumSectionModulusY() const;
    void setMaximumSectionModulusY(double v);
    /// Whether the optional attribute MinimumSectionModulusY is defined for this IfcStructuralProfileProperties
    bool hasMinimumSectionModulusY() const;
    double MinimumSectionModulusY() const;
    void setMinimumSectionModulusY(double v);
    /// Whether the optional attribute MaximumSectionModulusZ is defined for this IfcStructuralProfileProperties
    bool hasMaximumSectionModulusZ() const;
    double MaximumSectionModulusZ() const;
    void setMaximumSectionModulusZ(double v);
    /// Whether the optional attribute MinimumSectionModulusZ is defined for this IfcStructuralProfileProperties
    bool hasMinimumSectionModulusZ() const;
    double MinimumSectionModulusZ() const;
    void setMinimumSectionModulusZ(double v);
    /// Whether the optional attribute TorsionalSectionModulus is defined for this IfcStructuralProfileProperties
    bool hasTorsionalSectionModulus() const;
    double TorsionalSectionModulus() const;
    void setTorsionalSectionModulus(double v);
    /// Whether the optional attribute CentreOfGravityInX is defined for this IfcStructuralProfileProperties
    bool hasCentreOfGravityInX() const;
    double CentreOfGravityInX() const;
    void setCentreOfGravityInX(double v);
    /// Whether the optional attribute CentreOfGravityInY is defined for this IfcStructuralProfileProperties
    bool hasCentreOfGravityInY() const;
    double CentreOfGravityInY() const;
    void setCentreOfGravityInY(double v);
    virtual unsigned int getArgumentCount() const { return 23; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 7: return IfcUtil::Argument_DOUBLE; case 8: return IfcUtil::Argument_DOUBLE; case 9: return IfcUtil::Argument_DOUBLE; case 10: return IfcUtil::Argument_DOUBLE; case 11: return IfcUtil::Argument_DOUBLE; case 12: return IfcUtil::Argument_DOUBLE; case 13: return IfcUtil::Argument_DOUBLE; case 14: return IfcUtil::Argument_DOUBLE; case 15: return IfcUtil::Argument_DOUBLE; case 16: return IfcUtil::Argument_DOUBLE; case 17: return IfcUtil::Argument_DOUBLE; case 18: return IfcUtil::Argument_DOUBLE; case 19: return IfcUtil::Argument_DOUBLE; case 20: return IfcUtil::Argument_DOUBLE; case 21: return IfcUtil::Argument_DOUBLE; case 22: return IfcUtil::Argument_DOUBLE; } return IfcGeneralProfileProperties::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 7: return Type::IfcMomentOfInertiaMeasure; case 8: return Type::IfcMomentOfInertiaMeasure; case 9: return Type::IfcMomentOfInertiaMeasure; case 10: return Type::IfcMomentOfInertiaMeasure; case 11: return Type::IfcWarpingConstantMeasure; case 12: return Type::IfcLengthMeasure; case 13: return Type::IfcLengthMeasure; case 14: return Type::IfcAreaMeasure; case 15: return Type::IfcAreaMeasure; case 16: return Type::IfcSectionModulusMeasure; case 17: return Type::IfcSectionModulusMeasure; case 18: return Type::IfcSectionModulusMeasure; case 19: return Type::IfcSectionModulusMeasure; case 20: return Type::IfcSectionModulusMeasure; case 21: return Type::IfcLengthMeasure; case 22: return Type::IfcLengthMeasure; } return IfcGeneralProfileProperties::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 7: return "TorsionalConstantX"; case 8: return "MomentOfInertiaYZ"; case 9: return "MomentOfInertiaY"; case 10: return "MomentOfInertiaZ"; case 11: return "WarpingConstant"; case 12: return "ShearCentreZ"; case 13: return "ShearCentreY"; case 14: return "ShearDeformationAreaZ"; case 15: return "ShearDeformationAreaY"; case 16: return "MaximumSectionModulusY"; case 17: return "MinimumSectionModulusY"; case 18: return "MaximumSectionModulusZ"; case 19: return "MinimumSectionModulusZ"; case 20: return "TorsionalSectionModulus"; case 21: return "CentreOfGravityInX"; case 22: return "CentreOfGravityInY"; } return IfcGeneralProfileProperties::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcStructuralProfileProperties (IfcAbstractEntity* e);
    IfcStructuralProfileProperties (boost::optional< std::string > v1_ProfileName, IfcProfileDef* v2_ProfileDefinition, boost::optional< double > v3_PhysicalWeight, boost::optional< double > v4_Perimeter, boost::optional< double > v5_MinimumPlateThickness, boost::optional< double > v6_MaximumPlateThickness, boost::optional< double > v7_CrossSectionArea, boost::optional< double > v8_TorsionalConstantX, boost::optional< double > v9_MomentOfInertiaYZ, boost::optional< double > v10_MomentOfInertiaY, boost::optional< double > v11_MomentOfInertiaZ, boost::optional< double > v12_WarpingConstant, boost::optional< double > v13_ShearCentreZ, boost::optional< double > v14_ShearCentreY, boost::optional< double > v15_ShearDeformationAreaZ, boost::optional< double > v16_ShearDeformationAreaY, boost::optional< double > v17_MaximumSectionModulusY, boost::optional< double > v18_MinimumSectionModulusY, boost::optional< double > v19_MaximumSectionModulusZ, boost::optional< double > v20_MinimumSectionModulusZ, boost::optional< double > v21_TorsionalSectionModulus, boost::optional< double > v22_CentreOfGravityInX, boost::optional< double > v23_CentreOfGravityInY);
    typedef IfcTemplatedEntityList< IfcStructuralProfileProperties > list;
};

class IfcStructuralSteelProfileProperties : public IfcStructuralProfileProperties {
public:
    /// Whether the optional attribute ShearAreaZ is defined for this IfcStructuralSteelProfileProperties
    bool hasShearAreaZ() const;
    double ShearAreaZ() const;
    void setShearAreaZ(double v);
    /// Whether the optional attribute ShearAreaY is defined for this IfcStructuralSteelProfileProperties
    bool hasShearAreaY() const;
    double ShearAreaY() const;
    void setShearAreaY(double v);
    /// Whether the optional attribute PlasticShapeFactorY is defined for this IfcStructuralSteelProfileProperties
    bool hasPlasticShapeFactorY() const;
    double PlasticShapeFactorY() const;
    void setPlasticShapeFactorY(double v);
    /// Whether the optional attribute PlasticShapeFactorZ is defined for this IfcStructuralSteelProfileProperties
    bool hasPlasticShapeFactorZ() const;
    double PlasticShapeFactorZ() const;
    void setPlasticShapeFactorZ(double v);
    virtual unsigned int getArgumentCount() const { return 27; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 23: return IfcUtil::Argument_DOUBLE; case 24: return IfcUtil::Argument_DOUBLE; case 25: return IfcUtil::Argument_DOUBLE; case 26: return IfcUtil::Argument_DOUBLE; } return IfcStructuralProfileProperties::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 23: return Type::IfcAreaMeasure; case 24: return Type::IfcAreaMeasure; case 25: return Type::IfcPositiveRatioMeasure; case 26: return Type::IfcPositiveRatioMeasure; } return IfcStructuralProfileProperties::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 23: return "ShearAreaZ"; case 24: return "ShearAreaY"; case 25: return "PlasticShapeFactorY"; case 26: return "PlasticShapeFactorZ"; } return IfcStructuralProfileProperties::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcStructuralSteelProfileProperties (IfcAbstractEntity* e);
    IfcStructuralSteelProfileProperties (boost::optional< std::string > v1_ProfileName, IfcProfileDef* v2_ProfileDefinition, boost::optional< double > v3_PhysicalWeight, boost::optional< double > v4_Perimeter, boost::optional< double > v5_MinimumPlateThickness, boost::optional< double > v6_MaximumPlateThickness, boost::optional< double > v7_CrossSectionArea, boost::optional< double > v8_TorsionalConstantX, boost::optional< double > v9_MomentOfInertiaYZ, boost::optional< double > v10_MomentOfInertiaY, boost::optional< double > v11_MomentOfInertiaZ, boost::optional< double > v12_WarpingConstant, boost::optional< double > v13_ShearCentreZ, boost::optional< double > v14_ShearCentreY, boost::optional< double > v15_ShearDeformationAreaZ, boost::optional< double > v16_ShearDeformationAreaY, boost::optional< double > v17_MaximumSectionModulusY, boost::optional< double > v18_MinimumSectionModulusY, boost::optional< double > v19_MaximumSectionModulusZ, boost::optional< double > v20_MinimumSectionModulusZ, boost::optional< double > v21_TorsionalSectionModulus, boost::optional< double > v22_CentreOfGravityInX, boost::optional< double > v23_CentreOfGravityInY, boost::optional< double > v24_ShearAreaZ, boost::optional< double > v25_ShearAreaY, boost::optional< double > v26_PlasticShapeFactorY, boost::optional< double > v27_PlasticShapeFactorZ);
    typedef IfcTemplatedEntityList< IfcStructuralSteelProfileProperties > list;
};
/// Definition from ISO/DIS 10303-42:1999(E): A subedge is an edge whose domain is a connected portion of the domain of an existing edge. The topological constraints on a subedge are the same as those on an edge. 
/// 
/// Informal propositions: 
/// 
/// The domain of the subedge is formally defined to be the domain of the parent edge, as trimmed by the subedge start vertex and subedge end vertex. 
/// The start vertex and end vertex shall be within the union of the domains of the vertices of the parent edge and the domain of the parent edge. 
/// 
/// NOTE  Corresponding ISO 10303 entity: subedge. Please refer to ISO/DIS 10303-42:1999(E), p. 194 for the final definition of the formal standard.
/// 
/// HISTORY  New entity in IFC2x2.
class IfcSubedge : public IfcEdge {
public:
    /// The Edge, or Subedge, which contains the Subedge.
    IfcEdge* ParentEdge() const;
    void setParentEdge(IfcEdge* v);
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 2: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcEdge::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 2: return Type::IfcEdge; } return IfcEdge::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 2: return "ParentEdge"; } return IfcEdge::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcSubedge (IfcAbstractEntity* e);
    IfcSubedge (IfcVertex* v1_EdgeStart, IfcVertex* v2_EdgeEnd, IfcEdge* v3_ParentEdge);
    typedef IfcTemplatedEntityList< IfcSubedge > list;
};
/// Definition from ISO/CD 10303-42:1992: A surface can be envisioned as a set of connected points in 3-dimensional space which is always locally 2-dimensional, but need not be a manifold.  
/// 
/// NOTE Corresponding ISO 10303 entity: surface, the following subtypes have been incorporated into IFC - elementary_surface (as IfcElementarySurface), swept_surface (as IfcSweptSurface) and bounded_surface (as IfcBoundedSurface). Please refer to ISO/IS 10303-42:1994, p. 68 for the final definition of the formal standard. 
/// 
/// HISTORY New class in IFC Release 1.5
/// 
/// Informal proposition: 
/// 
/// A surface has non zero area. 
/// A surface is arcwise connected.
class IfcSurface : public IfcGeometricRepresentationItem {
public:
    virtual unsigned int getArgumentCount() const { return 0; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcGeometricRepresentationItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcGeometricRepresentationItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcGeometricRepresentationItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcSurface (IfcAbstractEntity* e);
    IfcSurface ();
    typedef IfcTemplatedEntityList< IfcSurface > list;
};
/// IfcSurfaceStyleRendering holds the properties for visualization related to a particular surface side style.  
/// 
/// It allows rendering properties to be defined by: 
/// 
/// a transparency component (Transparency attribute) 
///   a colour component (SurfaceColour attribute inherited from IfcSurfaceStyleShading) 
///   a reflectance component, given either by 
/// 
/// applying reflectance factors to the surface colour: 
/// 
/// diffuse component (SurfaceColour * DiffuseFactor)				  
///   transmission component (SurfaceColour * TransmissionFactor) 
///   diffuse transmission component (SurfaceColour * DiffuseTransmissionFactor) 
///   reflection component (SurfaceColour * ReflectionFactor) 
///   specular component (SurfaceColour * SpecularFactor attribute together with SpecularHighlight) 
/// 
/// explicitly defining such factors as colours (DiffuseColour, TransmissionColour, DiffuseTransmissionColour, ReflectionColour and SpecularColour) 
/// 
/// a displacement component, currently only given by a texture map with the TextureType = bump 
///   a coverage component, currently only given by the alpha component of the texture map (2 or 4 component colour texture) 
/// 
/// NOTE: The inherited attribute SurfaceColour is treated as the ambient colour and specifies how much ambient light from light sources this surface shall reflect. Ambient light is omnidirectional and depends only on the number of light sources, not their positions with respect to the surface.
/// 
/// NOTE: If the reflectance method, as given by the IfcReflectanceMethodEnum is "GLASS", the transmission factor controls the level of transparency in the glass, In this case the transparency factor is interpreted as transmission factor.
/// 
/// NOTE: Both Transparency and TransmissionColour (or factor) are included, the following definitions apply:
/// 
/// Transparency is the ratio of the transmitted flux in a solid angle of 2 * PI sr (one hemisphere). It is a simple colour filtration that does not account for refraction. 
///   Transmission factor of a material is the ratio of transmitted flux in a given solid angle to the transmitted flux of a completely diffuse material with 100% transmission in the same solid angle. It is the portion of light that goes through the material and may be refracted. 
/// 
/// NOTE: IFC 2x2 adds additional capability for presentation of physically accurate illuminance on surfaces. VRML type rendering and rendering based on ISO 10303-46 continues to be supported by a subset of the information. For reflectance equations and further information about the surface style properties and its processing, see:
/// 
/// ISO/IEC 14772-1: 1997: The Virtual Reality Modeling Language 
/// 
/// NOTE: The definition of IfcSurfaceStyleRenderingProperties includes the definitions as found in ISO 10303-46:1994, in particular of:
/// 
/// surface_style_rendering_with_properties
///   surface_style_rendering_ambient
///   surface_style_rendering_ambient_diffuse
///   surface_style_rendering_ambient_diffuse_specular
///   surface_style_transparent
/// 
/// In addition to the attributes as defined in ISO 10303-46, (ambient_reflectance, diffuse_reflectance, specular_reflectance, specular_exponent, and specular_colour), the current IFC definition adds other colours, reflectance factors and specular roughness.
/// 
/// HISTORY: New Entity in IFC 2x.
class IfcSurfaceStyleRendering : public IfcSurfaceStyleShading {
public:
    /// Whether the optional attribute Transparency is defined for this IfcSurfaceStyleRendering
    bool hasTransparency() const;
    /// Definition from ISO/CD 10303-46: The degree of transparency is indicated by the percentage of light traversing the surface.
    /// Definition from VRML97 - ISO/IEC 14772-1:1997: The transparency field specifies how "clear" an object is, with 1.0 being completely transparent, and 0.0 completely opaque. If not given, the value 0.0 (opaque) is assumed.
    double Transparency() const;
    void setTransparency(double v);
    /// Whether the optional attribute DiffuseColour is defined for this IfcSurfaceStyleRendering
    bool hasDiffuseColour() const;
    /// The diffuse part of the reflectance equation can be given as either a colour or a scalar factor.
    /// The diffuse colour field reflects all light sources depending on the angle of the surface with respect to the light source. The more directly the surface faces the light, the more diffuse light reflects.
    /// The diffuse factor field specifies how much diffuse light from light sources this surface shall reflect. Diffuse light depends on the angle of the surface with respect to the light source. The more directly the surface faces the light, the more diffuse light reflects. The diffuse colour is then defined by surface colour * diffuse factor.
    IfcColourOrFactor* DiffuseColour() const;
    void setDiffuseColour(IfcColourOrFactor* v);
    /// Whether the optional attribute TransmissionColour is defined for this IfcSurfaceStyleRendering
    bool hasTransmissionColour() const;
    /// The transmissive part of the reflectance equation can be given as either a colour or a scalar factor. It only applies to materials which Transparency field is greater than zero.
    /// The transmissive colour field specifies the colour that passes through a transparant material (like the colour that shines through a glass).
    /// The transmissive factor defines the transmissive part, the transmissive colour is then defined by surface colour * transmissive factor.
    IfcColourOrFactor* TransmissionColour() const;
    void setTransmissionColour(IfcColourOrFactor* v);
    /// Whether the optional attribute DiffuseTransmissionColour is defined for this IfcSurfaceStyleRendering
    bool hasDiffuseTransmissionColour() const;
    /// The diffuse transmission part of the reflectance equation can be given as either a colour or a scalar factor. It only applies to materials whose Transparency field is greater than zero.
    /// The diffuse transmission colour specifies how much diffuse light is reflected at the opposite side of the material surface.
    /// The diffuse transmission factor field specifies how much diffuse light from light sources this surface shall reflect on the opposite side of the material surface. The diffuse transmissive colour is then defined by surface colour * diffuse transmissive factor.
    IfcColourOrFactor* DiffuseTransmissionColour() const;
    void setDiffuseTransmissionColour(IfcColourOrFactor* v);
    /// Whether the optional attribute ReflectionColour is defined for this IfcSurfaceStyleRendering
    bool hasReflectionColour() const;
    /// The reflection (or mirror) part of the reflectance equation can be given as either a colour or a scalar factor. Applies to "glass" and "mirror" reflection models.
    /// The reflection colour specifies the contribution made by light from the mirror direction, i.e. light being reflected from the surface.
    /// The reflection factor specifies the amount of contribution made by light from the mirror direction. The reflection colour is then defined by surface colour * reflection factor.
    IfcColourOrFactor* ReflectionColour() const;
    void setReflectionColour(IfcColourOrFactor* v);
    /// Whether the optional attribute SpecularColour is defined for this IfcSurfaceStyleRendering
    bool hasSpecularColour() const;
    /// The specular part of the reflectance equation can be given as either a colour or a scalar factor.
    /// The specular colour determine the specular highlights (e.g., the shiny spots on an apple). When the angle from the light to the surface is close to the angle from the surface to the viewer, the specular colour is added to the diffuse and ambient colour calculations.
    /// The specular factor defines the specular part, the specular colour is then defined by surface colour * specular factor.
    IfcColourOrFactor* SpecularColour() const;
    void setSpecularColour(IfcColourOrFactor* v);
    /// Whether the optional attribute SpecularHighlight is defined for this IfcSurfaceStyleRendering
    bool hasSpecularHighlight() const;
    /// The exponent or roughness part of the specular reflectance.
    IfcSpecularHighlightSelect* SpecularHighlight() const;
    void setSpecularHighlight(IfcSpecularHighlightSelect* v);
    /// Identifies the predefined types of reflectance method from which the method required may be set.
    IfcReflectanceMethodEnum::IfcReflectanceMethodEnum ReflectanceMethod() const;
    void setReflectanceMethod(IfcReflectanceMethodEnum::IfcReflectanceMethodEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 1: return IfcUtil::Argument_DOUBLE; case 2: return IfcUtil::Argument_ENTITY_INSTANCE; case 3: return IfcUtil::Argument_ENTITY_INSTANCE; case 4: return IfcUtil::Argument_ENTITY_INSTANCE; case 5: return IfcUtil::Argument_ENTITY_INSTANCE; case 6: return IfcUtil::Argument_ENTITY_INSTANCE; case 7: return IfcUtil::Argument_ENTITY_INSTANCE; case 8: return IfcUtil::Argument_ENUMERATION; } return IfcSurfaceStyleShading::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 1: return Type::IfcNormalisedRatioMeasure; case 2: return Type::IfcColourOrFactor; case 3: return Type::IfcColourOrFactor; case 4: return Type::IfcColourOrFactor; case 5: return Type::IfcColourOrFactor; case 6: return Type::IfcColourOrFactor; case 7: return Type::IfcSpecularHighlightSelect; case 8: return Type::IfcReflectanceMethodEnum; } return IfcSurfaceStyleShading::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 1: return "Transparency"; case 2: return "DiffuseColour"; case 3: return "TransmissionColour"; case 4: return "DiffuseTransmissionColour"; case 5: return "ReflectionColour"; case 6: return "SpecularColour"; case 7: return "SpecularHighlight"; case 8: return "ReflectanceMethod"; } return IfcSurfaceStyleShading::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcSurfaceStyleRendering (IfcAbstractEntity* e);
    IfcSurfaceStyleRendering (IfcColourRgb* v1_SurfaceColour, boost::optional< double > v2_Transparency, IfcColourOrFactor* v3_DiffuseColour, IfcColourOrFactor* v4_TransmissionColour, IfcColourOrFactor* v5_DiffuseTransmissionColour, IfcColourOrFactor* v6_ReflectionColour, IfcColourOrFactor* v7_SpecularColour, IfcSpecularHighlightSelect* v8_SpecularHighlight, IfcReflectanceMethodEnum::IfcReflectanceMethodEnum v9_ReflectanceMethod);
    typedef IfcTemplatedEntityList< IfcSurfaceStyleRendering > list;
};
/// Definition from ISO/CD 10303-42:1992: The swept area
///   solid entity collects the entities which are defined
///   procedurally by sweeping action on planar bounded surfaces.
///   The position is space of the swept solid will be dependent
///   upon the position of the swept area. The swept area will be
///   a face of the resulting swept area solid, except for the
///   case of a revolved area solid with angle equal to 2π
///   (or 360 degrees).
/// 
/// The swept area is defined by a
///   cross section (also referred to as profile), which is given
///   as a closed two-dimensional boundary on an implicit plane.
///   The swept area is defined in the xy plane of the position
///   coordinate system, which is given for the swept area solid.
/// 
/// NOTE Corresponding ISO 10303-42 entity: swept_area_solid, The data type of SweptArea is modified and given by a profile definition (IfcProfileDef). A position coordinate system is defined by the Position attribute has been added. Please refer to ISO/IS 10303-42:1994, p. 183 for the final definition of the formal standard.
/// 
/// HISTORY New entity in IFC Release 1.5, the capabilities have been enhanced in IFC Release 2x.
class IfcSweptAreaSolid : public IfcSolidModel {
public:
    /// The surface defining the area to be swept. It is given as a profile definition within the xy plane of the position coordinate system.
    IfcProfileDef* SweptArea() const;
    void setSweptArea(IfcProfileDef* v);
    /// Position coordinate system for the swept area, provided by a profile definition within the XY plane of the Position.
    IfcAxis2Placement3D* Position() const;
    void setPosition(IfcAxis2Placement3D* v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcSolidModel::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcProfileDef; case 1: return Type::IfcAxis2Placement3D; } return IfcSolidModel::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "SweptArea"; case 1: return "Position"; } return IfcSolidModel::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcSweptAreaSolid (IfcAbstractEntity* e);
    IfcSweptAreaSolid (IfcProfileDef* v1_SweptArea, IfcAxis2Placement3D* v2_Position);
    typedef IfcTemplatedEntityList< IfcSweptAreaSolid > list;
};
/// Definition from ISO 10303-42:2002: A swept
/// disk solid is the solid produced by sweeping a circular disk
/// along a three dimensional curve. During the sweeping operation
/// the normal to the plane of the circular disk is in the direction
/// of the tangent to the directrix curve and the center of the disk
/// lies on the directrix. The circular disk may, optionally, have a
/// central hole, in this case the resulting solid has a through
/// hole, or, an internal void when the directrix forms a close
/// curve.
/// The StartParam and
/// EndParam parameter are optional, if not provided they
/// default to the start and end of the Directrix. Only if the
/// Directrix is given by a bounded or by a closed curve, it
/// is permissible to omit the values of StartParam and
/// EndParam.
/// If the transitions between consecutive segments of the
/// Directrix are not tangent continuous, the resulting solid
/// is created by a miter at half angle between the two segments.
/// Informal proposition restricts the permissible angle between two
/// non-tangent continuous segments.
/// 
/// Figure 272 illustrates an example.
/// 
/// Directrix given as IfcCompositeCurve being
/// tangent continuous between its segments
/// Directrix being a bounded and open curve
/// No StartParam and EndParam are provided, start
/// and end default to start and end of the bounded curve of the
/// Directrix
/// 
/// NOTE  Although the example shows a Directrix as a composite curve on a planar reference surface, the definition of IfcSweptDiskSolid is not restricted to be based on planer curves. However view definitions or implementer agreements may provide restrictions.
/// 
/// Figure 272 — Swept disk solid geometry
/// 
/// NOTE  Corresponding ISO 10303-42 entity: swept_disk_solid. Please refer to ISO/FDIS 10303-42:2002, p. 282 for the definition of the formal standard.
/// 
/// HISTORY  New entity in IFC Release 2x2.
/// 
/// IFC2x4 CHANGE  The attribute StartParam and EndParam have been made optional.
/// 
/// Informal proposition
/// 
/// If the Directrix curve definition is not tangent
/// continuous, the transition between the segments has to be within
/// an acceptable limit of tangent discontinuity. Very sharp edges
/// may result in nearly impossible miter. Implementer agreements may
/// define acceptable limits for tangent discontinuity.
/// The segments of the Directrix shall be long enough to
/// apply the Radius. In case of an arc segment forming part
/// of the Directrix ,its radius shall be greater then the
/// disk Radius
/// The Directrix shall not be based on an intersecting
/// curve.
class IfcSweptDiskSolid : public IfcSolidModel {
public:
    /// The curve used to define the sweeping operation. The solid is generated by sweeping a circular disk along the Directrix.
    IfcCurve* Directrix() const;
    void setDirectrix(IfcCurve* v);
    /// The Radius of the circular disk to be swept along the directrix. Denotes the outer radius, if an InnerRadius is applied.
    double Radius() const;
    void setRadius(double v);
    /// Whether the optional attribute InnerRadius is defined for this IfcSweptDiskSolid
    bool hasInnerRadius() const;
    /// This attribute is optional, if present it defines the radius of a circular hole in the centre of the disk.
    double InnerRadius() const;
    void setInnerRadius(double v);
    /// The parameter value on the Directrix at which the sweeping operation commences. If no value is provided the start of the sweeping operation is at the start of the Directrix..
    /// 
    /// IFC2x4 CHANGE  The attribute has been changed to OPTIONAL with upward compatibility for file-based exchange.
    double StartParam() const;
    void setStartParam(double v);
    /// The parameter value on the Directrix at which the sweeping operation ends. If no value is provided the end of the sweeping operation is at the end of the Directrix..
    /// 
    /// IFC2x4 CHANGE  The attribute has been changed to OPTIONAL with upward compatibility for file-based exchange.
    double EndParam() const;
    void setEndParam(double v);
    virtual unsigned int getArgumentCount() const { return 5; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_DOUBLE; case 2: return IfcUtil::Argument_DOUBLE; case 3: return IfcUtil::Argument_DOUBLE; case 4: return IfcUtil::Argument_DOUBLE; } return IfcSolidModel::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcCurve; case 1: return Type::IfcPositiveLengthMeasure; case 2: return Type::IfcPositiveLengthMeasure; case 3: return Type::IfcParameterValue; case 4: return Type::IfcParameterValue; } return IfcSolidModel::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Directrix"; case 1: return "Radius"; case 2: return "InnerRadius"; case 3: return "StartParam"; case 4: return "EndParam"; } return IfcSolidModel::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcSweptDiskSolid (IfcAbstractEntity* e);
    IfcSweptDiskSolid (IfcCurve* v1_Directrix, double v2_Radius, boost::optional< double > v3_InnerRadius, double v4_StartParam, double v5_EndParam);
    typedef IfcTemplatedEntityList< IfcSweptDiskSolid > list;
};
/// Definition from ISO/CD 10303-42:1992: A swept surface is one that is constructed by sweeping a curve along another curve.  
/// 
/// NOTE: Corresponding ISO 10303 entity: swept_surface. Please refer to ISO/IS 10303-42:1994, p.76 for the final definition of the formal standard.
/// 
/// HISTORY: New entity in IFC Release 2x.
class IfcSweptSurface : public IfcSurface {
public:
    /// The curve to be swept in defining the surface. The curve is defined as a profile within the position coordinate system.
    IfcProfileDef* SweptCurve() const;
    void setSweptCurve(IfcProfileDef* v);
    /// Position coordinate system for the placement of the profile within the xy plane of the axis placement.
    IfcAxis2Placement3D* Position() const;
    void setPosition(IfcAxis2Placement3D* v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcSurface::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcProfileDef; case 1: return Type::IfcAxis2Placement3D; } return IfcSurface::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "SweptCurve"; case 1: return "Position"; } return IfcSurface::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcSweptSurface (IfcAbstractEntity* e);
    IfcSweptSurface (IfcProfileDef* v1_SweptCurve, IfcAxis2Placement3D* v2_Position);
    typedef IfcTemplatedEntityList< IfcSweptSurface > list;
};
/// IfcTShapeProfileDef defines
/// a section profile that provides the defining parameters of a T-shaped
/// section to be used by the swept area solid. Its parameters and
/// orientation relative to the position coordinate system are according to
/// the following illustration. The centre of the position coordinate
/// system is in the profile's centre of the bounding box.
/// 
/// HISTORY  New entity in IFC2x2.
/// 
/// IFC2x3 CHANGE  All profile origins are now in the center of the bounding box.
/// 
/// IFC2x4 CHANGE  Type of FilletRadius, FlangeEdgeRadius, and WebEdgeRadius relaxed to allow for zero radius. Trailing attribute CentreOfGravityInY deleted, use respective property in IfcExtendedProfileProperties instead.
/// 
/// Figure 326 illustrates parameters of the T-shape profile definition.
/// 
/// Position 
/// The parameterized profile defines its own position coordinate system.
/// The underlying
/// coordinate system is defined by the swept area solid
/// that uses the profile definition. It is the xy plane of:
/// 
/// IfcSweptAreaSolid.Position
/// 
/// by using offsets of the position location, the parameterized profile
/// can be positioned centric (using x,y offsets = 0.), or at any position
/// relative to the profile.
/// 
/// Figure 326 — T-shape profile
class IfcTShapeProfileDef : public IfcParameterizedProfileDef {
public:
    /// Web lengths, see illustration above (= h).
    double Depth() const;
    void setDepth(double v);
    /// Flange lengths, see illustration above (= b).
    double FlangeWidth() const;
    void setFlangeWidth(double v);
    /// Constant wall thickness of web (= ts).
    double WebThickness() const;
    void setWebThickness(double v);
    /// Constant wall thickness of flange (= tg).
    double FlangeThickness() const;
    void setFlangeThickness(double v);
    /// Whether the optional attribute FilletRadius is defined for this IfcTShapeProfileDef
    bool hasFilletRadius() const;
    /// Fillet radius according the above illustration (= r1).
    double FilletRadius() const;
    void setFilletRadius(double v);
    /// Whether the optional attribute FlangeEdgeRadius is defined for this IfcTShapeProfileDef
    bool hasFlangeEdgeRadius() const;
    /// Edge radius according the above illustration (= r2).
    double FlangeEdgeRadius() const;
    void setFlangeEdgeRadius(double v);
    /// Whether the optional attribute WebEdgeRadius is defined for this IfcTShapeProfileDef
    bool hasWebEdgeRadius() const;
    /// Edge radius according the above illustration (= r3).
    double WebEdgeRadius() const;
    void setWebEdgeRadius(double v);
    /// Whether the optional attribute WebSlope is defined for this IfcTShapeProfileDef
    bool hasWebSlope() const;
    /// Slope of flange of the profile.
    double WebSlope() const;
    void setWebSlope(double v);
    /// Whether the optional attribute FlangeSlope is defined for this IfcTShapeProfileDef
    bool hasFlangeSlope() const;
    /// Slope of web of the profile.
    double FlangeSlope() const;
    void setFlangeSlope(double v);
    /// Whether the optional attribute CentreOfGravityInY is defined for this IfcTShapeProfileDef
    bool hasCentreOfGravityInY() const;
    double CentreOfGravityInY() const;
    void setCentreOfGravityInY(double v);
    virtual unsigned int getArgumentCount() const { return 13; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 3: return IfcUtil::Argument_DOUBLE; case 4: return IfcUtil::Argument_DOUBLE; case 5: return IfcUtil::Argument_DOUBLE; case 6: return IfcUtil::Argument_DOUBLE; case 7: return IfcUtil::Argument_DOUBLE; case 8: return IfcUtil::Argument_DOUBLE; case 9: return IfcUtil::Argument_DOUBLE; case 10: return IfcUtil::Argument_DOUBLE; case 11: return IfcUtil::Argument_DOUBLE; case 12: return IfcUtil::Argument_DOUBLE; } return IfcParameterizedProfileDef::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 3: return Type::IfcPositiveLengthMeasure; case 4: return Type::IfcPositiveLengthMeasure; case 5: return Type::IfcPositiveLengthMeasure; case 6: return Type::IfcPositiveLengthMeasure; case 7: return Type::IfcPositiveLengthMeasure; case 8: return Type::IfcPositiveLengthMeasure; case 9: return Type::IfcPositiveLengthMeasure; case 10: return Type::IfcPlaneAngleMeasure; case 11: return Type::IfcPlaneAngleMeasure; case 12: return Type::IfcPositiveLengthMeasure; } return IfcParameterizedProfileDef::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 3: return "Depth"; case 4: return "FlangeWidth"; case 5: return "WebThickness"; case 6: return "FlangeThickness"; case 7: return "FilletRadius"; case 8: return "FlangeEdgeRadius"; case 9: return "WebEdgeRadius"; case 10: return "WebSlope"; case 11: return "FlangeSlope"; case 12: return "CentreOfGravityInY"; } return IfcParameterizedProfileDef::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcTShapeProfileDef (IfcAbstractEntity* e);
    IfcTShapeProfileDef (IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< std::string > v2_ProfileName, IfcAxis2Placement2D* v3_Position, double v4_Depth, double v5_FlangeWidth, double v6_WebThickness, double v7_FlangeThickness, boost::optional< double > v8_FilletRadius, boost::optional< double > v9_FlangeEdgeRadius, boost::optional< double > v10_WebEdgeRadius, boost::optional< double > v11_WebSlope, boost::optional< double > v12_FlangeSlope, boost::optional< double > v13_CentreOfGravityInY);
    typedef IfcTemplatedEntityList< IfcTShapeProfileDef > list;
};

class IfcTerminatorSymbol : public IfcAnnotationSymbolOccurrence {
public:
    IfcAnnotationCurveOccurrence* AnnotatedCurve() const;
    void setAnnotatedCurve(IfcAnnotationCurveOccurrence* v);
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 3: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcAnnotationSymbolOccurrence::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 3: return Type::IfcAnnotationCurveOccurrence; } return IfcAnnotationSymbolOccurrence::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 3: return "AnnotatedCurve"; } return IfcAnnotationSymbolOccurrence::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcTerminatorSymbol (IfcAbstractEntity* e);
    IfcTerminatorSymbol (IfcRepresentationItem* v1_Item, IfcTemplatedEntityList< IfcPresentationStyleAssignment >::ptr v2_Styles, boost::optional< std::string > v3_Name, IfcAnnotationCurveOccurrence* v4_AnnotatedCurve);
    typedef IfcTemplatedEntityList< IfcTerminatorSymbol > list;
};
/// The text literal is a geometric representation item which describes a text string using a string literal and additional position and path information.
/// 
/// NOTE  The IfcTextLiteral is an entity that had been adopted from ISO 10303, Industrial automation systems and integration—Product data representation and exchange.
/// 
/// NOTE  Corresponding ISO 10303 name: text_literal. Please refer to ISO/IS 10303-46:1994 for the
/// final definition of the formal standard. The attributes font and alignment have been removed as those should be handled by the text style.
/// 
/// HISTORY  New entity in IFC2x2.
/// 
/// IFC2x3 CHANGE  The IfcTextLiteral has been changed by removing Font and Alignment.
class IfcTextLiteral : public IfcGeometricRepresentationItem {
public:
    /// The text literal to be presented.
    std::string Literal() const;
    void setLiteral(std::string v);
    /// An IfcAxis2Placement that determines the placement and orientation of the presented string.
    /// When used with a text style based on IfcTextStyleWithBoxCharacteristics then the y-axis is taken as the reference direction for the box rotation angle and the box slant angle.
    IfcAxis2Placement* Placement() const;
    void setPlacement(IfcAxis2Placement* v);
    /// The writing direction of the text literal.
    IfcTextPath::IfcTextPath Path() const;
    void setPath(IfcTextPath::IfcTextPath v);
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_STRING; case 1: return IfcUtil::Argument_ENTITY_INSTANCE; case 2: return IfcUtil::Argument_ENUMERATION; } return IfcGeometricRepresentationItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcPresentableText; case 1: return Type::IfcAxis2Placement; case 2: return Type::IfcTextPath; } return IfcGeometricRepresentationItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Literal"; case 1: return "Placement"; case 2: return "Path"; } return IfcGeometricRepresentationItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcTextLiteral (IfcAbstractEntity* e);
    IfcTextLiteral (std::string v1_Literal, IfcAxis2Placement* v2_Placement, IfcTextPath::IfcTextPath v3_Path);
    typedef IfcTemplatedEntityList< IfcTextLiteral > list;
};
/// The text literal with extent is a text literal with the additional explicit information of the planar extent (or surrounding text box). An alignment attribute defines, how the text box is aligned to the placement and how it may expand.
/// 
/// NOTE  The IfcTextLiteralWithExtent is an entity that had been adopted from ISO 10303, Industrial automation systems and integration—Product data representation and exchange, Part 46: Integrated generic resources: Visual presentation. 
/// 
/// NOTE  Corresponding ISO 10303 name: text_literal_with_extent. Please refer to ISO/IS 10303-46:1994 for the final definition of the formal standard.
/// 
/// HISTORY  New entity in IFC2x2.
/// 
/// IFC2x3 CHANGE  The IfcTextLiteralWithExtent has been changed by adding BoxAlignment.
class IfcTextLiteralWithExtent : public IfcTextLiteral {
public:
    /// The extent in the x and y direction of the text literal.
    IfcPlanarExtent* Extent() const;
    void setExtent(IfcPlanarExtent* v);
    /// The alignment of the text literal relative to its position.
    std::string BoxAlignment() const;
    void setBoxAlignment(std::string v);
    virtual unsigned int getArgumentCount() const { return 5; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 3: return IfcUtil::Argument_ENTITY_INSTANCE; case 4: return IfcUtil::Argument_STRING; } return IfcTextLiteral::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 3: return Type::IfcPlanarExtent; case 4: return Type::IfcBoxAlignment; } return IfcTextLiteral::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 3: return "Extent"; case 4: return "BoxAlignment"; } return IfcTextLiteral::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcTextLiteralWithExtent (IfcAbstractEntity* e);
    IfcTextLiteralWithExtent (std::string v1_Literal, IfcAxis2Placement* v2_Placement, IfcTextPath::IfcTextPath v3_Path, IfcPlanarExtent* v4_Extent, std::string v5_BoxAlignment);
    typedef IfcTemplatedEntityList< IfcTextLiteralWithExtent > list;
};
/// IfcTrapeziumProfileDef defines a trapezium as the profile definition used by the swept surface geometry or the swept area solid. It is given by its Top X and Bottom X extent and its Y extent as well as by the offset of the Top X extend, and placed within the 2D position coordinate system, established by the Position attribute. It is placed centric within the position coordinate system, that is, in the center of the bounding box. 
/// 
/// HISTORY  New class in IFC 1.5. The use definition has changed in IFC2x.
/// 
/// Figure 325 illustrates parameters of the trapezium profile definition.
/// 
/// Position
/// 
/// The parameterized profile defines its own position coordinate system.
/// The underlying
/// coordinate system is defined by the swept surface or swept area solid
/// that uses the profile definition. It is the xy plane of either:
/// 
/// IfcSweptSurface.Position
///   IfcSweptAreaSolid.Position
/// 
/// or in case of sectioned spines the xy plane of each list member of IfcSectionedSpine.CrossSectionPositions.
/// 
/// By using offsets of the position location, the parameterized profile
/// can be positioned centric (using x,y offsets = 0.), or at any position
/// relative to the profile. Explicit coordinate offsets are used to define
/// cardinal points (e.g. upper-left bound).
///   Parameter
/// 
/// The IfcTrapeziumProfileDef
/// is defined within the position
/// coordinate system, where the BottomDim
/// defines the length
/// measure for the bottom line (half along the positive x-axis) and the YDim
/// defines the length measure for the parallel distance of bottom and top
/// line (half along the positive y-axis). The top line starts with a
/// distance of TopXOffset
/// from [-BottomLine/2,YDim] (which can be
/// negative, zero, or positive) and has a length of TopXDim
/// along
/// the positive x-axis.
/// 
/// Figure 325 — Trapezium profile
class IfcTrapeziumProfileDef : public IfcParameterizedProfileDef {
public:
    /// The extent of the bottom line measured along the implicit x-axis.
    double BottomXDim() const;
    void setBottomXDim(double v);
    /// The extent of the top line measured along the implicit x-axis.
    double TopXDim() const;
    void setTopXDim(double v);
    /// The extent of the distance between the parallel bottom and top lines measured along the implicit y-axis.
    double YDim() const;
    void setYDim(double v);
    /// Offset from the beginning of the top line to the bottom line, measured along the implicit x-axis.
    double TopXOffset() const;
    void setTopXOffset(double v);
    virtual unsigned int getArgumentCount() const { return 7; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 3: return IfcUtil::Argument_DOUBLE; case 4: return IfcUtil::Argument_DOUBLE; case 5: return IfcUtil::Argument_DOUBLE; case 6: return IfcUtil::Argument_DOUBLE; } return IfcParameterizedProfileDef::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 3: return Type::IfcPositiveLengthMeasure; case 4: return Type::IfcPositiveLengthMeasure; case 5: return Type::IfcPositiveLengthMeasure; case 6: return Type::IfcLengthMeasure; } return IfcParameterizedProfileDef::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 3: return "BottomXDim"; case 4: return "TopXDim"; case 5: return "YDim"; case 6: return "TopXOffset"; } return IfcParameterizedProfileDef::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcTrapeziumProfileDef (IfcAbstractEntity* e);
    IfcTrapeziumProfileDef (IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< std::string > v2_ProfileName, IfcAxis2Placement2D* v3_Position, double v4_BottomXDim, double v5_TopXDim, double v6_YDim, double v7_TopXOffset);
    typedef IfcTemplatedEntityList< IfcTrapeziumProfileDef > list;
};
/// Definition from ISO/CD 10303-46:1992: A two direction repeat factor combines two vectors which are used in the fill area style tiles entity for determining the shape and relative location of tiles. Given the initial position of any tile, the two direction repeat factor determines eight new positions according to the equation:
/// 
/// k1* R1 + k2* R2
///        k X{-1,1} 
/// 
/// NOTE Corresponding ISO 10303 name: two_direction_repeat_factor. Please refer to ISO/IS 10303-46:1994 for the final definition of the formal standard.
/// 
/// HISTORY New entity in IFC2x2.
class IfcTwoDirectionRepeatFactor : public IfcOneDirectionRepeatFactor {
public:
    /// A vector which specifies the relative positioning of tiles in the second direction.
    IfcVector* SecondRepeatFactor() const;
    void setSecondRepeatFactor(IfcVector* v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 1: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcOneDirectionRepeatFactor::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 1: return Type::IfcVector; } return IfcOneDirectionRepeatFactor::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 1: return "SecondRepeatFactor"; } return IfcOneDirectionRepeatFactor::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcTwoDirectionRepeatFactor (IfcAbstractEntity* e);
    IfcTwoDirectionRepeatFactor (IfcVector* v1_RepeatFactor, IfcVector* v2_SecondRepeatFactor);
    typedef IfcTemplatedEntityList< IfcTwoDirectionRepeatFactor > list;
};
/// The object type defines the
/// specific information about a type, being common to all
/// occurrences of this type. It refers to the specific level of the
/// well recognized generic - specific - occurrance modeling
/// paradigm. The IfcTypeObject gets assigned to the
/// individual object instances (the occurrences) via the
/// IfcRelDefinesByType relationship.
/// NOTE The terms 'Type' and 'Style' are often
/// used interchangeably.
/// The object type is represented by a set of property set
/// definitions. The attached property sets describe the available
/// alpha-numeric information about the object type. and are used to
/// define all common properties that apply to all object occurrences
/// of that type.
/// NOTE If a property having having the same name
/// is used within the IfcPropertySet assigned to an
/// IfcTypeObject (and subtypes) and to an occurrence of that
/// type, then the occurrence property overrides the type property.
/// See IfcRelDefinesByType for an explanatory
/// figure.
/// Object types may be exchanged without being already assigned
/// to objects. An object type may have an indication of the library
/// (or catalogue) from which its definition originates. This
/// association is handled by the inherited HasAssociations
/// relationship pointing to IfcRelAssociatesLibrary.
/// 
/// HISTORY New entity in IFC Release 2x
/// 
/// IFC2x3 CHANGE The IfcTypeObject is now subtyped from the new supertype IfcObjectDefinition, and the attribute HasPropertySets has been changed from a LIST into a SET.
/// 
/// IFC2x4 CHANGE (1) The entity IfcTypeObject shall not be instantiated from IFC2x4 onwards. It will be changed into an ABSTRACT supertype in future releases of IFC. (2) The inverse attribute Types has been renamed from ObjectTypeOf.
class IfcTypeObject : public IfcObjectDefinition {
public:
    /// Whether the optional attribute ApplicableOccurrence is defined for this IfcTypeObject
    bool hasApplicableOccurrence() const;
    /// The attribute optionally defines the data type of the occurrence object, to which the assigned type object can relate. If not present, no instruction is given to which occurrence object the type object is applicable. The following conventions are used:
    /// 
    /// The IFC entity name of the applicable occurrence using the IFC naming convention, CamelCase with IFC prefix
    ///   It can be optionally followed by the predefined type after the separator "/" (forward slash), using Uupper case
    ///   If one type object is applicable to many occurrence objects, then those occurrence object names should be separate by comma "," forming a comma separated string.
    /// 
    /// EXAMPLE  Refering to a furniture as applicable occurrence entity would be expressed as 'IfcFurnishingElement', refering to a brace as applicable entity would be expressed as 'IfcMember/BRACE', refering to a wall and wall standard case would be expressed as 'IfcWall, IfcWallStandardCase'.
    std::string ApplicableOccurrence() const;
    void setApplicableOccurrence(std::string v);
    /// Whether the optional attribute HasPropertySets is defined for this IfcTypeObject
    bool hasHasPropertySets() const;
    /// Set list of unique property sets, that are associated with the object type and are common to all object occurrences referring to this object type.
    /// 
    /// IFC2x3 CHANGE  The attribute aggregate type has been changed from LIST to SET.
    IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr HasPropertySets() const;
    void setHasPropertySets(IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr v);
    virtual unsigned int getArgumentCount() const { return 6; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 4: return IfcUtil::Argument_STRING; case 5: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } return IfcObjectDefinition::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 4: return Type::IfcLabel; case 5: return Type::IfcPropertySetDefinition; } return IfcObjectDefinition::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 4: return "ApplicableOccurrence"; case 5: return "HasPropertySets"; } return IfcObjectDefinition::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcRelDefinesByType >::ptr ObjectTypeOf() const; // INVERSE IfcRelDefinesByType::RelatingType
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcTypeObject (IfcAbstractEntity* e);
    IfcTypeObject (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets);
    typedef IfcTemplatedEntityList< IfcTypeObject > list;
};
/// IfcTypeProduct defines a type
/// definition of a product without being already inserted into a
/// project structure (without having a placement), and not being
/// included into the geometric representation context of the
/// project.ÿIt is used to define a product specification, that is, the
/// specific product information that is common to all occurrences
/// of that product type.
/// 
/// An IfcTypeProduct may have a list of property set
/// attached and an optional set of product representations. Values
/// of these properties and the representation maps are common to all
/// occurrencesÿof that product type.ÿThe type occurrence
/// relationship is realized using the objectified relationship
/// IfcRelDefinesByType.
/// 
/// NOTE 1ÿ The product representations are
/// defined as representation maps, which gets assigned by a product
/// instance through the representation item(s) being an
/// IfcShapeRepresentation and having Items of
/// typeÿIfcMappedItem.
/// NOTE 2 ÿThe representations at the occurrence
/// level (represented by subtypes of IfcProduct) can override
/// the specific representations at the type level, ÿ
/// 
/// for geometric representations: a Cartesian
/// transformation operator can be applied at the occurrence level,
/// andÿ
/// for property sets: A property within an occurrence
/// property set, assigned at the product occurrence, overrides the
/// same property assigned to the product type.
/// 
/// An IfcTypeProduct may be exchanged without being
/// already assigned to subtypes of IfcProduct.
/// 
/// HISTORY New entity in IFC Release 2x.
/// 
/// IFC2x4 CHANGE The entity IfcTypeProduct shall not be instantiated from IFC2x4 onwards. It will be changed into an ABSTRACT supertype in future releases of IFC.
/// 
/// Geometry use definition
/// The RepresentationMaps define the type product shape
/// and multiple geometric representations can be assigned. If a
/// product occurrence is assigned to the type by using the
/// IfcRelDefinesByType relationship, then these occurrences
/// have to reference the representation maps. The reference is
/// created by one or multiple IfcShapeRepresentation's having
/// an IfcMappedItem as Items, that places the
/// IfcRepresentationMap of the type product into the spatial
/// contexts, i.e. by using an Cartesian transformation operator to
/// transform the IfcRepresentationMap into the object
/// coordinate system of the product occurrence.
/// 
/// Figure 10 illustrates an example of referencing a representation map by
/// the shape representation of a product occurrence. Here the
/// Cartesian transformation operator only uses translation, but no
/// rotation, mirroring, or scaling.
/// 
/// Figure 10 — Product type geometry with single placement
/// 
/// Figure 11 illustrates an example of referencing a representation
/// multiple times map by the shape representation of a product
/// occurrence. Here the Cartesian transformation operator only uses
/// translation, but no rotation, mirroring, or scaling. The
/// different translation values determine the pattern of the
/// multiple placement.
/// 
/// Figure 11 — Product type geometry with multiple placement
class IfcTypeProduct : public IfcTypeObject {
public:
    /// Whether the optional attribute RepresentationMaps is defined for this IfcTypeProduct
    bool hasRepresentationMaps() const;
    /// List of unique representation maps. Each representation map describes a block definition of the shape of the product style. By providing more than one representation map, a multi-view block definition can be given.
    IfcTemplatedEntityList< IfcRepresentationMap >::ptr RepresentationMaps() const;
    void setRepresentationMaps(IfcTemplatedEntityList< IfcRepresentationMap >::ptr v);
    /// Whether the optional attribute Tag is defined for this IfcTypeProduct
    bool hasTag() const;
    /// The tag (or label) identifier at the particular type of a product, e.g. the article number (like the EAN). It is the identifier at the specific level.
    std::string Tag() const;
    void setTag(std::string v);
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 6: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 7: return IfcUtil::Argument_STRING; } return IfcTypeObject::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 6: return Type::IfcRepresentationMap; case 7: return Type::IfcLabel; } return IfcTypeObject::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 6: return "RepresentationMaps"; case 7: return "Tag"; } return IfcTypeObject::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcTypeProduct (IfcAbstractEntity* e);
    IfcTypeProduct (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag);
    typedef IfcTemplatedEntityList< IfcTypeProduct > list;
};
/// IfcUShapeProfileDef defines
/// a section profile that provides the defining parameters of a U-shape
/// (channel) section to be used by the swept area solid. Its parameters
/// and orientation relative to the position coordinate system are
/// according to the following illustration. The centre of the position
/// coordinate system is in the profile's centre of the bounding box.
/// 
/// HISTORY  New entity in IFC2x2.
/// 
/// IFC2x3 CHANGE  All profile origins are now in the center of the bounding box.
/// 
/// IFC2x4 CHANGE  Type of FilletRadius and EdgeRadius relaxed to allow for zero radius.
/// Trailing attribute CentreOfGravityInX deleted, use respective property in IfcExtendedProfileProperties instead.
/// 
/// Figure 327 illustrates parameters of the U-shape profile definition.
/// 
/// Position 
/// The parameterized profile defines its own position coordinate system.
/// The underlying coordinate system is defined by the swept area solid
/// that uses the profile definition. It is the xy plane of:
/// 
/// IfcSweptAreaSolid.Position
/// 
/// By using offsets of the position location, the parameterized profile
/// can be positioned centric (using x,y offsets = 0.), or at any position
/// relative to the profile.
/// 
/// Figure 327 — U-shape profile
class IfcUShapeProfileDef : public IfcParameterizedProfileDef {
public:
    /// Web lengths, see illustration above (= h).
    double Depth() const;
    void setDepth(double v);
    /// Flange lengths, see illustration above (= b).
    double FlangeWidth() const;
    void setFlangeWidth(double v);
    /// Constant wall thickness of web (= ts).
    double WebThickness() const;
    void setWebThickness(double v);
    /// Constant wall thickness of flange (= tg).
    double FlangeThickness() const;
    void setFlangeThickness(double v);
    /// Whether the optional attribute FilletRadius is defined for this IfcUShapeProfileDef
    bool hasFilletRadius() const;
    /// Fillet radius according the above illustration (= r1).
    double FilletRadius() const;
    void setFilletRadius(double v);
    /// Whether the optional attribute EdgeRadius is defined for this IfcUShapeProfileDef
    bool hasEdgeRadius() const;
    /// Edge radius according the above illustration (= r2).
    double EdgeRadius() const;
    void setEdgeRadius(double v);
    /// Whether the optional attribute FlangeSlope is defined for this IfcUShapeProfileDef
    bool hasFlangeSlope() const;
    /// Slope of flange of the profile.
    double FlangeSlope() const;
    void setFlangeSlope(double v);
    /// Whether the optional attribute CentreOfGravityInX is defined for this IfcUShapeProfileDef
    bool hasCentreOfGravityInX() const;
    double CentreOfGravityInX() const;
    void setCentreOfGravityInX(double v);
    virtual unsigned int getArgumentCount() const { return 11; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 3: return IfcUtil::Argument_DOUBLE; case 4: return IfcUtil::Argument_DOUBLE; case 5: return IfcUtil::Argument_DOUBLE; case 6: return IfcUtil::Argument_DOUBLE; case 7: return IfcUtil::Argument_DOUBLE; case 8: return IfcUtil::Argument_DOUBLE; case 9: return IfcUtil::Argument_DOUBLE; case 10: return IfcUtil::Argument_DOUBLE; } return IfcParameterizedProfileDef::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 3: return Type::IfcPositiveLengthMeasure; case 4: return Type::IfcPositiveLengthMeasure; case 5: return Type::IfcPositiveLengthMeasure; case 6: return Type::IfcPositiveLengthMeasure; case 7: return Type::IfcPositiveLengthMeasure; case 8: return Type::IfcPositiveLengthMeasure; case 9: return Type::IfcPlaneAngleMeasure; case 10: return Type::IfcPositiveLengthMeasure; } return IfcParameterizedProfileDef::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 3: return "Depth"; case 4: return "FlangeWidth"; case 5: return "WebThickness"; case 6: return "FlangeThickness"; case 7: return "FilletRadius"; case 8: return "EdgeRadius"; case 9: return "FlangeSlope"; case 10: return "CentreOfGravityInX"; } return IfcParameterizedProfileDef::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcUShapeProfileDef (IfcAbstractEntity* e);
    IfcUShapeProfileDef (IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< std::string > v2_ProfileName, IfcAxis2Placement2D* v3_Position, double v4_Depth, double v5_FlangeWidth, double v6_WebThickness, double v7_FlangeThickness, boost::optional< double > v8_FilletRadius, boost::optional< double > v9_EdgeRadius, boost::optional< double > v10_FlangeSlope, boost::optional< double > v11_CentreOfGravityInX);
    typedef IfcTemplatedEntityList< IfcUShapeProfileDef > list;
};
/// Definition from ISO/CD 10303-42:1992: The vector is defined in terms of the direction and magnitude of the vector. The value of the magnitude attribute defines the magnitude of the vector. 
/// 
/// NOTE: The magnitude of the vector can not be reliable calculated from the components of the Orientation attribute. This form of representation was selected to reduce problems with numerical instability. For example a vector of magnitude 2.0 mm and equally inclined to the coordinate axes could be represented with Orientation attribute of (1.0,1.0,1.0).
/// 
/// NOTE: Corresponding ISO 10303 entity: vector. Please refer to ISO/IS 10303-42:1994, p.27 for the final definition of the formal standard. The derived attribute Dim has been added (see also note at IfcGeometricRepresentationItem).
/// 
/// HISTORY: New entity in IFC Release 1.0
class IfcVector : public IfcGeometricRepresentationItem {
public:
    /// The direction of the vector.
    IfcDirection* Orientation() const;
    void setOrientation(IfcDirection* v);
    /// The magnitude of the vector. All vectors of Magnitude 0.0 are regarded as equal in value regardless of the orientation attribute.
    double Magnitude() const;
    void setMagnitude(double v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_DOUBLE; } return IfcGeometricRepresentationItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcDirection; case 1: return Type::IfcLengthMeasure; } return IfcGeometricRepresentationItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Orientation"; case 1: return "Magnitude"; } return IfcGeometricRepresentationItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcVector (IfcAbstractEntity* e);
    IfcVector (IfcDirection* v1_Orientation, double v2_Magnitude);
    typedef IfcTemplatedEntityList< IfcVector > list;
};
/// Definition from ISO/CD 10303-42:1992: A vertex_loop is a loop of
///   zero genus consisting of a single vertex. A vertex can exist independently of a
///   vertex loop. The topological data shall satisfy the following constraint:  
/// 
/// Informal propositions: 
/// 
/// A vertex loop has zero extent and dimensionality. 
///   The vertex loop has genus 0. 
/// 
/// NOTE  Corresponding ISO 10303 entity: vertex_loop. Please refer to ISO/IS 10303-42:1994, p. 121 for the final definition of the formal standard.
/// 
/// HISTORY  New Entity in IFC2x2.
class IfcVertexLoop : public IfcLoop {
public:
    /// The vertex which defines the entire loop.
    IfcVertex* LoopVertex() const;
    void setLoopVertex(IfcVertex* v);
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcLoop::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcVertex; } return IfcLoop::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "LoopVertex"; } return IfcLoop::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcVertexLoop (IfcAbstractEntity* e);
    IfcVertexLoop (IfcVertex* v1_LoopVertex);
    typedef IfcTemplatedEntityList< IfcVertexLoop > list;
};
/// The window lining is the outer
/// frame which enables the window to be fixed in position. The
/// window lining is used to hold the window panels or other
/// casements. The parameter of the IfcWindowLiningProperties
/// define the geometrically relevant parameter of the lining.
/// 
/// NOTEÿ The IfcWindowLiningProperties
/// shall only be applied to construct the 3D shape of a window, if
/// the attribute IfcWindowStyle.ParameterTakesPrecedence is
/// set TRUE.
/// 
/// The IfcWindowLiningProperties are included in the set
/// of properties of IfcWindowStyle.HasPropertySets. More
/// information about the window lining can be included in the same
/// set of the IfcWindowStyle using another
/// IfcPropertySet for dynamic extensions.
/// 
/// HISTORY New Entity in IFC Release 2.0. Has been renamed from IfcWindowLining in
/// IFC Release 2x.
/// 
/// IFC2x4 CHANGEÿ The following attributes have been added LiningOffset,
/// LiningToPanelOffsetX, LiningToPanelOffsetY. The
/// attribute ShapeAspectStyle is deprecated and shall no
/// longer be used. Supertype changed to new
/// IfcPreDefinedPropertySet.
/// 
/// Geometry use definitions
/// The IfcWindowLiningProperties does not hold a geometric representation. However it defines parameters which can be used to create the shape of the window style (which is inserted by the IfcWindow into the spatial context of the project) as shown in Figure 175.
/// The parameters at the IfcWindowLiningProperties define a standard window lining, including (if given) a mullion and a transom (for horizontal and vertical splits). The outer boundary of the lining is determined by the occurrence parameter assigned to the IfcWindow, which inserts the IfcWindowStyle.
/// 
/// The lining is applied to all faces
/// of the opening reveal. The parameter are:
/// 
/// LiningDepth
/// LiningThickness
/// LiningOffset
/// LiningToPanelOffsetX
/// LiningToPanelOffsetY
/// 
/// NOTE Parameters added in
/// IFC2x4.
/// 
/// Inner side is defined as the direction of the window panel
/// opening operation.
/// 
/// If the OperationType of the
/// window style is
/// 
/// DoublePanelVertical (shown)
/// TriplePanelBottom
/// TriplePanelTop
/// TriplePanelLeft
/// TriplePanelRight
/// 
/// the following additional parameter apply:
/// 
/// MullionThickness
/// FirstMullionOffset - measured as offset to the Z axis
/// (in XZ plane)
/// 
/// If the OperationType of the
/// window style is
/// 
/// DoublePanelHorizontal
/// TriplePanelBottom
/// TriplePanelTop
/// TriplePanelLeft
/// TriplePanelRight
/// 
/// the following additional parameter apply
/// 
/// TransomThickness
/// FirstTransomOffset measured as offset to the X axis
/// (in XZ plane)
/// 
/// If the OperationType of the
/// window style is
/// 
/// TriplePanelVertical
/// 
/// the following additional parameter apply
/// 
/// SecondMullionOffset
/// 
/// If the OperationType of the
/// window style is
/// 
/// TriplePanelHorizontal
/// 
/// the following additional parameter apply
/// 
/// SecondTransomOffset
/// 
/// Figure 175 — Window lining properties
/// 
/// NOTE
/// 
/// All offsets are given as a normalized ratio measure.
class IfcWindowLiningProperties : public IfcPropertySetDefinition {
public:
    /// Whether the optional attribute LiningDepth is defined for this IfcWindowLiningProperties
    bool hasLiningDepth() const;
    /// Depth of the window lining (dimension measured perpendicular to window elevation plane).
    double LiningDepth() const;
    void setLiningDepth(double v);
    /// Whether the optional attribute LiningThickness is defined for this IfcWindowLiningProperties
    bool hasLiningThickness() const;
    /// Thickness of the window lining (measured parallel to the window elevation plane).
    double LiningThickness() const;
    void setLiningThickness(double v);
    /// Whether the optional attribute TransomThickness is defined for this IfcWindowLiningProperties
    bool hasTransomThickness() const;
    /// Thickness of the transom (horizontal separator of window panels within a window), measured parallel to the window elevation plane. The transom is part of the lining and the transom depth is assumed to be identical to the lining depth.
    double TransomThickness() const;
    void setTransomThickness(double v);
    /// Whether the optional attribute MullionThickness is defined for this IfcWindowLiningProperties
    bool hasMullionThickness() const;
    /// Thickness of the mullion (vertical separator of window panels within a window), measured parallel to the window elevation plane. The mullion is part of the lining and the mullion depth is assumed to be identical to the lining depth.
    double MullionThickness() const;
    void setMullionThickness(double v);
    /// Whether the optional attribute FirstTransomOffset is defined for this IfcWindowLiningProperties
    bool hasFirstTransomOffset() const;
    /// Offset of the transom centerline, measured along the z-axis of the window placement co-ordinate system. An offset value = 0.5 indicates that the transom is positioned in the middle of the window.
    double FirstTransomOffset() const;
    void setFirstTransomOffset(double v);
    /// Whether the optional attribute SecondTransomOffset is defined for this IfcWindowLiningProperties
    bool hasSecondTransomOffset() const;
    /// Offset of the transom centerline for the second transom, measured along the x-axis of the window placement co-ordinate system. An offset value = 0.666 indicates that the second transom is positioned at two/third of the window.
    double SecondTransomOffset() const;
    void setSecondTransomOffset(double v);
    /// Whether the optional attribute FirstMullionOffset is defined for this IfcWindowLiningProperties
    bool hasFirstMullionOffset() const;
    /// Offset of the mullion centerline, measured along the x-axis of the window placement co-ordinate system. An offset value = 0.5 indicates that the mullion is positioned in the middle of the window.
    double FirstMullionOffset() const;
    void setFirstMullionOffset(double v);
    /// Whether the optional attribute SecondMullionOffset is defined for this IfcWindowLiningProperties
    bool hasSecondMullionOffset() const;
    /// Offset of the mullion centerline for the second mullion, measured along the x-axis of the window placement co-ordinate system. An offset value = 0.666 indicates that the second mullion is positioned at two/third of the window.
    double SecondMullionOffset() const;
    void setSecondMullionOffset(double v);
    /// Whether the optional attribute ShapeAspectStyle is defined for this IfcWindowLiningProperties
    bool hasShapeAspectStyle() const;
    /// Optional link to a shape aspect definition, which points to the part of the geometric representation of the window style, which is used to represent the lining.
    /// 
    /// IFC2x4 CHANGE The attribute is deprecated and shall no longer be used, i.e. the value shall be NIL ($).
    IfcShapeAspect* ShapeAspectStyle() const;
    void setShapeAspectStyle(IfcShapeAspect* v);
    virtual unsigned int getArgumentCount() const { return 13; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 4: return IfcUtil::Argument_DOUBLE; case 5: return IfcUtil::Argument_DOUBLE; case 6: return IfcUtil::Argument_DOUBLE; case 7: return IfcUtil::Argument_DOUBLE; case 8: return IfcUtil::Argument_DOUBLE; case 9: return IfcUtil::Argument_DOUBLE; case 10: return IfcUtil::Argument_DOUBLE; case 11: return IfcUtil::Argument_DOUBLE; case 12: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcPropertySetDefinition::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 4: return Type::IfcPositiveLengthMeasure; case 5: return Type::IfcPositiveLengthMeasure; case 6: return Type::IfcPositiveLengthMeasure; case 7: return Type::IfcPositiveLengthMeasure; case 8: return Type::IfcNormalisedRatioMeasure; case 9: return Type::IfcNormalisedRatioMeasure; case 10: return Type::IfcNormalisedRatioMeasure; case 11: return Type::IfcNormalisedRatioMeasure; case 12: return Type::IfcShapeAspect; } return IfcPropertySetDefinition::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 4: return "LiningDepth"; case 5: return "LiningThickness"; case 6: return "TransomThickness"; case 7: return "MullionThickness"; case 8: return "FirstTransomOffset"; case 9: return "SecondTransomOffset"; case 10: return "FirstMullionOffset"; case 11: return "SecondMullionOffset"; case 12: return "ShapeAspectStyle"; } return IfcPropertySetDefinition::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcWindowLiningProperties (IfcAbstractEntity* e);
    IfcWindowLiningProperties (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< double > v5_LiningDepth, boost::optional< double > v6_LiningThickness, boost::optional< double > v7_TransomThickness, boost::optional< double > v8_MullionThickness, boost::optional< double > v9_FirstTransomOffset, boost::optional< double > v10_SecondTransomOffset, boost::optional< double > v11_FirstMullionOffset, boost::optional< double > v12_SecondMullionOffset, IfcShapeAspect* v13_ShapeAspectStyle);
    typedef IfcTemplatedEntityList< IfcWindowLiningProperties > list;
};
/// A window panel is a casement, that is, a component, fixed or opening,
/// consisting essentially of a frame and the infilling. The
/// infilling of a window panel is normally glazing. The way of
/// operation is defined in the operation type.
/// The IfcWindowPanelProperties are used to parametrically
/// describe the shape and operation of window panels. The parametric
/// definition can be added solely or additionally to the explicit
/// shape representation of the window.
/// The IfcWindowStyle can define windows consisting of
/// more then one panel. In this case, one instance of
/// IfcWindowPanelProperties has to be included for each
/// window panel. The PanelPosition attribute, in conjunction
/// with the IfcWindowStyle.OperationType attribute,
/// determines to which panel the IfcWindowPanelProperties
/// apply.
/// The IfcWindowPanelProperties are included in the list
/// of properties (HasPropertySets) of the
/// IfcWindowStyle. More information about the window panel
/// can be included in the same list of the IfcWindowStyle
/// using the IfcPropertySet for dynamic extensions.
/// 
/// HISTORY New entity in
/// IFC Release 2.0, it had been renamed from IfcWindowPanel in IFC
/// Release 2x.
/// 
/// IFC2x4 CHANGE Supertype changed to
/// new IfcPreDefinedPropertySet.
/// 
/// Geometry use definitions
/// The IfcWindowPanelProperties does not hold an own
/// geometric representation. However it defines parameter, which can
/// be used to create the shape of the IfcWindowStyle (which
/// is inserted by the IfcWindow into the spatial context of
/// the project).
/// The parameters at the IfcWindowPanelProperties define a
/// standard window panel. The outer boundary of the panel is
/// determined by the occurrence parameter assigned to the IfcWindow,
/// which inserts the IfcWindowStyle. It has to take the lining
/// parameter into account as well. The position of the window panel
/// within the overall window is determined by the
/// PanelPosition attribute.
/// 
/// As shown in Figure 176, the panel is applied to the position within the lining as defined by the panel position attribute. The following parameter apply to that panel: FrameDepth, FrameThickness.
/// 
/// Figure 176 — Window panel properties
class IfcWindowPanelProperties : public IfcPropertySetDefinition {
public:
    /// Types of window panel operations. Also used to assign standard symbolic presentations according to national building standards.
    IfcWindowPanelOperationEnum::IfcWindowPanelOperationEnum OperationType() const;
    void setOperationType(IfcWindowPanelOperationEnum::IfcWindowPanelOperationEnum v);
    /// Position of this panel within the overall window style.
    IfcWindowPanelPositionEnum::IfcWindowPanelPositionEnum PanelPosition() const;
    void setPanelPosition(IfcWindowPanelPositionEnum::IfcWindowPanelPositionEnum v);
    /// Whether the optional attribute FrameDepth is defined for this IfcWindowPanelProperties
    bool hasFrameDepth() const;
    /// Depth of panel frame, measured from front face to back face horizontally (i.e. perpendicular to the window (elevation) plane.
    double FrameDepth() const;
    void setFrameDepth(double v);
    /// Whether the optional attribute FrameThickness is defined for this IfcWindowPanelProperties
    bool hasFrameThickness() const;
    /// Width of panel frame, measured from inside of panel (at glazing) to outside of panel (at lining), i.e. parallel to the window (elevation) plane.
    double FrameThickness() const;
    void setFrameThickness(double v);
    /// Whether the optional attribute ShapeAspectStyle is defined for this IfcWindowPanelProperties
    bool hasShapeAspectStyle() const;
    /// Optional link to a shape aspect definition, which points to the part of the geometric representation of the window style, which is used to represent the panel.
    /// 
    /// IFC2x4 CHANGE The attribute is deprecated and shall no longer be used, i.e. the value shall be NIL ($).
    IfcShapeAspect* ShapeAspectStyle() const;
    void setShapeAspectStyle(IfcShapeAspect* v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 4: return IfcUtil::Argument_ENUMERATION; case 5: return IfcUtil::Argument_ENUMERATION; case 6: return IfcUtil::Argument_DOUBLE; case 7: return IfcUtil::Argument_DOUBLE; case 8: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcPropertySetDefinition::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 4: return Type::IfcWindowPanelOperationEnum; case 5: return Type::IfcWindowPanelPositionEnum; case 6: return Type::IfcPositiveLengthMeasure; case 7: return Type::IfcPositiveLengthMeasure; case 8: return Type::IfcShapeAspect; } return IfcPropertySetDefinition::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 4: return "OperationType"; case 5: return "PanelPosition"; case 6: return "FrameDepth"; case 7: return "FrameThickness"; case 8: return "ShapeAspectStyle"; } return IfcPropertySetDefinition::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcWindowPanelProperties (IfcAbstractEntity* e);
    IfcWindowPanelProperties (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcWindowPanelOperationEnum::IfcWindowPanelOperationEnum v5_OperationType, IfcWindowPanelPositionEnum::IfcWindowPanelPositionEnum v6_PanelPosition, boost::optional< double > v7_FrameDepth, boost::optional< double > v8_FrameThickness, IfcShapeAspect* v9_ShapeAspectStyle);
    typedef IfcTemplatedEntityList< IfcWindowPanelProperties > list;
};
/// Definition: The window style defines a particular style of windows, which may be included into the spatial context of the building model through instances of IfcWindow. A window style defines the overall parameter of the window style and refers to the particular parameter of the lining and one (or several) panels through IfcWindowLiningProperties and IfcWindowPanelProperties.
/// 
/// The window entity (IfcWindow) defines a particular occurrence of a window inserted in the spatial context of a project. The actual parameter of the window and/or its shape is defined at the IfcWindowStyle, to which the IfcWindow related by the inverse relationship IsDefinedBy pointing to IfcRelDefinesByType. The IfcWindowStyle also defines the particular attributes for the lining (IfcWindowLiningProperties) and panels (IfcWindowPanelProperties).
/// 
/// HISTORY New entity in IFC Release 2x.
/// 
/// IFC2x4 CHANGE The entity has been deprecated and shall not be used. The new entity IfcWindowType shall be used instead.
/// 
/// Geometry use definitions
/// The IfcWindowStyle defines the baseline geometry, or the representation map, for all occurrences of the window style,
/// given by the IfcWindow, pointing to this style. The representation of the window style may be given by the agreed set
/// of minimal parameters, defined for the window lining and the window panel(s), or it may be given by a geometric representation
/// used by the IfcRepresentationMap. The attribute ParameterTakesPrecedence decides, whether the set of
/// parameters can be used to exactly represent the shape of the window style (TRUE), or whether the attached IfcRepresentationMap holds the exact representation (FALSE).
/// 
/// The IfcWindowStyleOperationTypeEnum defines the general layout of the window style. Depending on the enumerator, the
/// appropriate instances of IfcWindowLiningProperties and IfcWindowPanelProperties are attached in the list of
/// HasPropertySets. See geometry use definitions there.
class IfcWindowStyle : public IfcTypeProduct {
public:
    /// Type defining the basic construction and material type of the window.
    IfcWindowStyleConstructionEnum::IfcWindowStyleConstructionEnum ConstructionType() const;
    void setConstructionType(IfcWindowStyleConstructionEnum::IfcWindowStyleConstructionEnum v);
    /// Type defining the general layout and operation of the window style.
    IfcWindowStyleOperationEnum::IfcWindowStyleOperationEnum OperationType() const;
    void setOperationType(IfcWindowStyleOperationEnum::IfcWindowStyleOperationEnum v);
    /// The Boolean value reflects, whether the parameter given in the attached lining and panel properties exactly define the geometry (TRUE), or whether the attached style shape take precedence (FALSE). In the last case the parameter have only informative value.
    bool ParameterTakesPrecedence() const;
    void setParameterTakesPrecedence(bool v);
    /// The Boolean indicates, whether the attached ShapeStyle can be sized (using scale factor of transformation), or not (FALSE). If not, the ShapeStyle should be inserted by the IfcWindow (using IfcMappedItem) with the scale factor = 1.
    bool Sizeable() const;
    void setSizeable(bool v);
    virtual unsigned int getArgumentCount() const { return 12; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; case 9: return IfcUtil::Argument_ENUMERATION; case 10: return IfcUtil::Argument_BOOL; case 11: return IfcUtil::Argument_BOOL; } return IfcTypeProduct::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcWindowStyleConstructionEnum; case 9: return Type::IfcWindowStyleOperationEnum; case 10: return Type::UNDEFINED; case 11: return Type::UNDEFINED; } return IfcTypeProduct::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "ConstructionType"; case 9: return "OperationType"; case 10: return "ParameterTakesPrecedence"; case 11: return "Sizeable"; } return IfcTypeProduct::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcWindowStyle (IfcAbstractEntity* e);
    IfcWindowStyle (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, IfcWindowStyleConstructionEnum::IfcWindowStyleConstructionEnum v9_ConstructionType, IfcWindowStyleOperationEnum::IfcWindowStyleOperationEnum v10_OperationType, bool v11_ParameterTakesPrecedence, bool v12_Sizeable);
    typedef IfcTemplatedEntityList< IfcWindowStyle > list;
};
/// IfcZShapeProfileDef defines
/// a section profile that provides the defining parameters of a Z-shape
/// section to be used by the swept area solid. Its parameters and
/// orientation relative to the position coordinate system are according to
/// the following illustration. The centre of the position coordinate
/// system is in the profile's centre of the bounding box.
/// 
/// HISTORY  New entity in IFC2x2.
/// 
/// IFC2x Edition 4 CHANGE  Type of FilletRadius and EdgeRadius relaxed to allow for zero radius.
/// 
/// Figure 328 illustrates parameters of the Z-shape profile definition.
/// 
/// Position
/// The parameterized profile defines its own position coordinate system.
/// The underlying coordinate system is defined by the swept area solid
/// that uses the profile definition. It is the xy plane of:
/// 
/// IfcSweptAreaSolid.Position
/// 
/// By using offsets of the position location, the parameterized profile
/// can be positioned centric (using x,y offsets = 0.), or at any position
/// relative to the profile.
/// 
/// Figure 328 — Z-shape profile
class IfcZShapeProfileDef : public IfcParameterizedProfileDef {
public:
    /// Web length, see illustration above (= h).
    double Depth() const;
    void setDepth(double v);
    /// Flange length, see illustration above (= b).
    double FlangeWidth() const;
    void setFlangeWidth(double v);
    /// Constant wall thickness of web, see illustration above (= ts).
    double WebThickness() const;
    void setWebThickness(double v);
    /// Constant wall thickness of flange, see illustration above (= tg).
    double FlangeThickness() const;
    void setFlangeThickness(double v);
    /// Whether the optional attribute FilletRadius is defined for this IfcZShapeProfileDef
    bool hasFilletRadius() const;
    /// Fillet radius according the above illustration (= r1).
    double FilletRadius() const;
    void setFilletRadius(double v);
    /// Whether the optional attribute EdgeRadius is defined for this IfcZShapeProfileDef
    bool hasEdgeRadius() const;
    /// Edge radius according the above illustration (= r2).
    double EdgeRadius() const;
    void setEdgeRadius(double v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 3: return IfcUtil::Argument_DOUBLE; case 4: return IfcUtil::Argument_DOUBLE; case 5: return IfcUtil::Argument_DOUBLE; case 6: return IfcUtil::Argument_DOUBLE; case 7: return IfcUtil::Argument_DOUBLE; case 8: return IfcUtil::Argument_DOUBLE; } return IfcParameterizedProfileDef::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 3: return Type::IfcPositiveLengthMeasure; case 4: return Type::IfcPositiveLengthMeasure; case 5: return Type::IfcPositiveLengthMeasure; case 6: return Type::IfcPositiveLengthMeasure; case 7: return Type::IfcPositiveLengthMeasure; case 8: return Type::IfcPositiveLengthMeasure; } return IfcParameterizedProfileDef::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 3: return "Depth"; case 4: return "FlangeWidth"; case 5: return "WebThickness"; case 6: return "FlangeThickness"; case 7: return "FilletRadius"; case 8: return "EdgeRadius"; } return IfcParameterizedProfileDef::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcZShapeProfileDef (IfcAbstractEntity* e);
    IfcZShapeProfileDef (IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< std::string > v2_ProfileName, IfcAxis2Placement2D* v3_Position, double v4_Depth, double v5_FlangeWidth, double v6_WebThickness, double v7_FlangeThickness, boost::optional< double > v8_FilletRadius, boost::optional< double > v9_EdgeRadius);
    typedef IfcTemplatedEntityList< IfcZShapeProfileDef > list;
};

class IfcAnnotationCurveOccurrence : public IfcAnnotationOccurrence {
public:
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcAnnotationOccurrence::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcAnnotationOccurrence::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcAnnotationOccurrence::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcAnnotationCurveOccurrence (IfcAbstractEntity* e);
    IfcAnnotationCurveOccurrence (IfcRepresentationItem* v1_Item, IfcTemplatedEntityList< IfcPresentationStyleAssignment >::ptr v2_Styles, boost::optional< std::string > v3_Name);
    typedef IfcTemplatedEntityList< IfcAnnotationCurveOccurrence > list;
};
/// Definition from ISO/CD 10303-46:1992: An annotation fill area is a set of curves that may be filled with hatching, colour or tiling. The annotation fill are is described by boundaries which consist of non-intersecting, non-self-intersecting closed curves. These curves form the boundary of planar areas to be filled according to the style for the annotation fill area.
/// 
/// NOTE: A curve that is not surrounded by any other curve is a border between an unfilled area on the outside and a filled area on the inside. Another curve may surround an unfilled area if it is surrounded by another curve whose inside is a filled area.
/// 
/// Figure 300 (from ISO 10303-46) illustrates annotation fill area.
/// 
/// Figure 300 — Annotation fill area
/// 
/// NOTE  Corresponding ISO 10303 name: annotation_fill_area. Please refer to ISO/IS 10303-46:1994 for the final definition of the formal standard.
/// 
/// The IfcAnnotationFillArea defines an area by a definite OuterBoundary, that might include InnerBoundaries. The areas defined by the InnerBoundaries are excluded from applying the fill area style.
/// 
/// Informal Proposition:
/// 
/// Any curve that describes an inner boundary shall not intersect with, nor include, another curve defining an inner boundary.
///   The curve defining the outer boundary shall not intersect with any curve defining an inner boundary, nor shall it be surrounded by a curve defining an inner boundary.
/// 
/// HISTORY  New entity in IFC2x2.
/// 
/// IFC2x3 CHANGE  The two attributes OuterBoundary and InnerBoundaries are added and replace the previous single boundary.
class IfcAnnotationFillArea : public IfcGeometricRepresentationItem {
public:
    /// A closed curve that defines the outer boundary of the fill area. The areas defined by the outer boundary (minus potentially defined inner boundaries) is filled by the fill area style.
    /// 
    /// IFC2x Edition 3 CHANGE  The two new attributes OuterBoundary and InnerBoundaries replace the old single attribute Boundaries.
    IfcCurve* OuterBoundary() const;
    void setOuterBoundary(IfcCurve* v);
    /// Whether the optional attribute InnerBoundaries is defined for this IfcAnnotationFillArea
    bool hasInnerBoundaries() const;
    /// A set of inner curves that define the inner boundaries of the fill area. The areas defined by the inner boundaries are excluded from applying the fill area style.
    /// 
    /// IFC2x Edition 3 CHANGE  The two new attributes OuterBoundary and InnerBoundaries replace the old single attribute Boundaries.
    IfcTemplatedEntityList< IfcCurve >::ptr InnerBoundaries() const;
    void setInnerBoundaries(IfcTemplatedEntityList< IfcCurve >::ptr v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } return IfcGeometricRepresentationItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcCurve; case 1: return Type::IfcCurve; } return IfcGeometricRepresentationItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "OuterBoundary"; case 1: return "InnerBoundaries"; } return IfcGeometricRepresentationItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcAnnotationFillArea (IfcAbstractEntity* e);
    IfcAnnotationFillArea (IfcCurve* v1_OuterBoundary, boost::optional< IfcTemplatedEntityList< IfcCurve >::ptr > v2_InnerBoundaries);
    typedef IfcTemplatedEntityList< IfcAnnotationFillArea > list;
};

class IfcAnnotationFillAreaOccurrence : public IfcAnnotationOccurrence {
public:
    /// Whether the optional attribute FillStyleTarget is defined for this IfcAnnotationFillAreaOccurrence
    bool hasFillStyleTarget() const;
    IfcPoint* FillStyleTarget() const;
    void setFillStyleTarget(IfcPoint* v);
    /// Whether the optional attribute GlobalOrLocal is defined for this IfcAnnotationFillAreaOccurrence
    bool hasGlobalOrLocal() const;
    IfcGlobalOrLocalEnum::IfcGlobalOrLocalEnum GlobalOrLocal() const;
    void setGlobalOrLocal(IfcGlobalOrLocalEnum::IfcGlobalOrLocalEnum v);
    virtual unsigned int getArgumentCount() const { return 5; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 3: return IfcUtil::Argument_ENTITY_INSTANCE; case 4: return IfcUtil::Argument_ENUMERATION; } return IfcAnnotationOccurrence::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 3: return Type::IfcPoint; case 4: return Type::IfcGlobalOrLocalEnum; } return IfcAnnotationOccurrence::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 3: return "FillStyleTarget"; case 4: return "GlobalOrLocal"; } return IfcAnnotationOccurrence::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcAnnotationFillAreaOccurrence (IfcAbstractEntity* e);
    IfcAnnotationFillAreaOccurrence (IfcRepresentationItem* v1_Item, IfcTemplatedEntityList< IfcPresentationStyleAssignment >::ptr v2_Styles, boost::optional< std::string > v3_Name, IfcPoint* v4_FillStyleTarget, boost::optional< IfcGlobalOrLocalEnum::IfcGlobalOrLocalEnum > v5_GlobalOrLocal);
    typedef IfcTemplatedEntityList< IfcAnnotationFillAreaOccurrence > list;
};

class IfcAnnotationSurface : public IfcGeometricRepresentationItem {
public:
    IfcGeometricRepresentationItem* Item() const;
    void setItem(IfcGeometricRepresentationItem* v);
    /// Whether the optional attribute TextureCoordinates is defined for this IfcAnnotationSurface
    bool hasTextureCoordinates() const;
    IfcTextureCoordinate* TextureCoordinates() const;
    void setTextureCoordinates(IfcTextureCoordinate* v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcGeometricRepresentationItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcGeometricRepresentationItem; case 1: return Type::IfcTextureCoordinate; } return IfcGeometricRepresentationItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Item"; case 1: return "TextureCoordinates"; } return IfcGeometricRepresentationItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcAnnotationSurface (IfcAbstractEntity* e);
    IfcAnnotationSurface (IfcGeometricRepresentationItem* v1_Item, IfcTextureCoordinate* v2_TextureCoordinates);
    typedef IfcTemplatedEntityList< IfcAnnotationSurface > list;
};
/// Definition from ISO/CD 10303-42:1992: The direction and location in three dimensional space of a single axis. An axis1_placement is defined in terms of a locating point (inherited from placement supertype) and an axis direction: this is either the direction of axis or defaults to (0.0,0.0,1.0). The actual direction for the axis placement is given by the derived attribute z (Z).  
/// 
/// NOTE  Corresponding ISO 10303 name: axis1_placement, please refer to ISO/IS 10303-42:1994, p. 28 for the final definition of the formal standard.
/// 
/// HISTORY  New entity in IFC Release 1.5
/// 
/// Figure 274 illustrates the definition of the IfcAxis1Placement within the three-dimensional coordinate system.
/// 
/// Figure 274 — Axis1 placement
class IfcAxis1Placement : public IfcPlacement {
public:
    /// Whether the optional attribute Axis is defined for this IfcAxis1Placement
    bool hasAxis() const;
    /// The direction of the local Z axis.
    IfcDirection* Axis() const;
    void setAxis(IfcDirection* v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 1: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcPlacement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 1: return Type::IfcDirection; } return IfcPlacement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 1: return "Axis"; } return IfcPlacement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcAxis1Placement (IfcAbstractEntity* e);
    IfcAxis1Placement (IfcCartesianPoint* v1_Location, IfcDirection* v2_Axis);
    typedef IfcTemplatedEntityList< IfcAxis1Placement > list;
};
/// Definition from ISO/CD 10303-42:1992: The location and orientation in two dimensional space of two mutually perpendicular axes. An axis2_placement_2d is defined in terms of a point, (inherited from the placement supertype), and an axis. It can be used to locate and originate an object in two dimensional space and to define a placement coordinate system. The class includes a point which forms the origin of the placement coordinate system. A direction vector is required to complete the definition of the placement coordinate system. The reference direction defines the placement X axis direction, the placement Y axis is derived from this.  
/// 
/// If the RefDirection attribute is not given, the placement defaults to P[1] (x-axis) as [1.,0.] and P[2] (y-axis) as [0.,1.].  
/// 
/// NOTE  Corresponding ISO 10303 name: axis2_placement_2d, please refer to ISO/IS 10303-42:1994, p. 28 for the final definition of the formal standard.
/// 
/// HISTORY  New entity in IFC Release 1.5.
/// 
/// Figure 275 illustrates the definition of the IfcAxis2Placement2D within the two-dimensional coordinate system. 
/// 
/// Figure 275 — Axis2 placement 2D
class IfcAxis2Placement2D : public IfcPlacement {
public:
    /// Whether the optional attribute RefDirection is defined for this IfcAxis2Placement2D
    bool hasRefDirection() const;
    /// The direction used to determine the direction of the local X axis. If a value is omited that it defaults to [1.0, 0.0.].
    IfcDirection* RefDirection() const;
    void setRefDirection(IfcDirection* v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 1: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcPlacement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 1: return Type::IfcDirection; } return IfcPlacement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 1: return "RefDirection"; } return IfcPlacement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcAxis2Placement2D (IfcAbstractEntity* e);
    IfcAxis2Placement2D (IfcCartesianPoint* v1_Location, IfcDirection* v2_RefDirection);
    typedef IfcTemplatedEntityList< IfcAxis2Placement2D > list;
};
/// Definition from ISO/CD 10303-42:1992: The location and orientation in three dimensional space of three mutually perpendicular axes. An axis2_placement_3D is defined in terms of a point (inherited from placement supertype) and two (ideally orthogonal) axes. It can be used to locate and originate an object in three dimensional space and to define a placement coordinate system. The entity includes a point which forms the origin of the placement coordinate system. Two direction vectors are required to complete the definition of the placement coordinate system. The axis is the placement Z axis direction and the ref_direction is an approximation to the placement X axis direction.
/// 
/// If the attribute values for Axis and RefDirection
/// are not given, the placement defaults to P[1] (x-axis) as [1.,0.,0.],
/// P[2] (y-axis) as [0.,1.,0.] and P[3] (z-axis) as [0.,0.,1.].
/// 
/// NOTE  Corresponding ISO 10303 name: axis2_placement_3d, please refer to ISO/IS 10303-42:1994 for the final definition of the formal standard. The WR5 is added to ensure that either both attributes Axis and RefDirection are given, or both are omitted.
/// 
/// HISTORY  New entity in IFC Release 1.5.
/// 
/// Figure 276 illustrates the definition of the IfcAxis2Placement3D within the three-dimensional coordinate system.
/// 
/// Figure 276 — Axis2 placement 3D
class IfcAxis2Placement3D : public IfcPlacement {
public:
    /// Whether the optional attribute Axis is defined for this IfcAxis2Placement3D
    bool hasAxis() const;
    /// The exact direction of the local Z Axis.
    IfcDirection* Axis() const;
    void setAxis(IfcDirection* v);
    /// Whether the optional attribute RefDirection is defined for this IfcAxis2Placement3D
    bool hasRefDirection() const;
    /// The direction used to determine the direction of the local X Axis. If necessary an adjustment is made to maintain orthogonality to the Axis direction. If Axis and/or RefDirection is omitted, these directions are taken from the geometric coordinate system.
    IfcDirection* RefDirection() const;
    void setRefDirection(IfcDirection* v);
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 1: return IfcUtil::Argument_ENTITY_INSTANCE; case 2: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcPlacement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 1: return Type::IfcDirection; case 2: return Type::IfcDirection; } return IfcPlacement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 1: return "Axis"; case 2: return "RefDirection"; } return IfcPlacement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcAxis2Placement3D (IfcAbstractEntity* e);
    IfcAxis2Placement3D (IfcCartesianPoint* v1_Location, IfcDirection* v2_Axis, IfcDirection* v3_RefDirection);
    typedef IfcTemplatedEntityList< IfcAxis2Placement3D > list;
};
/// Definition from ISO/CD 10303-42:1992: A Boolean result
/// is the result of a regularized operation on two solids to create
/// a new solid. Valid operations are regularized union, regularized
/// intersection, and regularized difference. For purpose of Boolean
/// operations, a solid is considered to be a regularized set of
/// points. The final Boolean result depends upon the operation and
/// the two operands. In the case of the difference operator the
/// order of the operands is also significant. The operator can be
/// either union, intersection or difference. The effect of these
/// operators is described below:
/// 
/// Union on two solids is the new solid that is the
/// regularization of the set of all points that are in either the
/// first operand or the second operand or in both.
/// Intersection on two solids is the new solid that is the
/// regularization of the set of all points that are in both the
/// first operand and the second operand.
/// The result of the difference operation on two solids is the
/// regularization of the set of all points which are in the first
/// operand, but not in the second operand.
/// 
/// NOTE For example if the first operand is a block and the second operand is a solid cylinder of suitable dimensions and location, the boolean result produced with the difference operator would be a block with a circular hole.
/// 
/// NOTE Corresponding ISO 10303-42 entity: boolean_result. The derived attribute Dim has been added at this level and was therefore demoted from the geometric_representation_item. Please refer to ISO/IS 10303-42:1994, p.175 for the final definition of the formal standard.
/// 
/// HISTORY: New class in IFC Release 1.5.1.
class IfcBooleanResult : public IfcGeometricRepresentationItem {
public:
    /// The Boolean operator used in the operation to create the result.
    IfcBooleanOperator::IfcBooleanOperator Operator() const;
    void setOperator(IfcBooleanOperator::IfcBooleanOperator v);
    /// The first operand to be operated upon by the Boolean operation.
    IfcBooleanOperand* FirstOperand() const;
    void setFirstOperand(IfcBooleanOperand* v);
    /// The second operand specified for the operation.
    IfcBooleanOperand* SecondOperand() const;
    void setSecondOperand(IfcBooleanOperand* v);
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENUMERATION; case 1: return IfcUtil::Argument_ENTITY_INSTANCE; case 2: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcGeometricRepresentationItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcBooleanOperator; case 1: return Type::IfcBooleanOperand; case 2: return Type::IfcBooleanOperand; } return IfcGeometricRepresentationItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Operator"; case 1: return "FirstOperand"; case 2: return "SecondOperand"; } return IfcGeometricRepresentationItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcBooleanResult (IfcAbstractEntity* e);
    IfcBooleanResult (IfcBooleanOperator::IfcBooleanOperator v1_Operator, IfcBooleanOperand* v2_FirstOperand, IfcBooleanOperand* v3_SecondOperand);
    typedef IfcTemplatedEntityList< IfcBooleanResult > list;
};
/// Definition from ISO/CD 10303-42:1992: A bounded surface is a surface of finite area with identifiable boundaries.
/// 
/// NOTE Corresponding ISO 10303 name: bounded_surface. Please refer to ISO/IS 10303-42:1994, p.78 for the final definition of the formal standard.
/// 
/// HISTORY New entity in IFC Release 2x
/// 
/// IFC2x4 CHANGE Entity made abstract.
/// 
/// Informal propositions:
/// 
/// A bounded surface has finite non-zero surface area.
/// A bounded surface has boundary curves.
class IfcBoundedSurface : public IfcSurface {
public:
    virtual unsigned int getArgumentCount() const { return 0; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcSurface::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcSurface::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcSurface::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcBoundedSurface (IfcAbstractEntity* e);
    IfcBoundedSurface ();
    typedef IfcTemplatedEntityList< IfcBoundedSurface > list;
};
/// Definition from ISO/CD 10303-42:1992: A box domain
///   is an orthogonal box parallel to the axes of the geometric
///   coordinate system which may be used to limit the domain of
///   a half space solid. A box domain is specified by the
///   coordinates of the bottom left corner, and the lengths of
///   the sides measured in the directions of the coordinate
///   axes.
/// 
/// Every semantic object having a
///   physical extent might have a minimum default representation
///   of a bounding box. The bounding box is therefore also used
///   as minimal geometric representation for any geometrically
///   represented object. Therefore the IfcBoundingBox is
///   subtyped from IfcGeometricRepresentationItem.
/// 
/// NOTE Corresponding ISO 10303-42 entity: box_domain, please refer to ISO/IS 10303-42:1994, p. 186 for the final definition of the formal standard. In IFC the bounding box can also be used outside of the context of an IfcBoxedHalfSpace.
/// 
/// HISTORY New entity in IFC Release 1.0.
/// 
/// As shown in Figure 252, the IfcBoundingBox is defined with its own location which can be used to place the IfcBoundingBox relative to the geometric coordinate system. The IfcBoundingBox is defined by the lower left corner (Corner) and the upper right corner (XDim, YDim, ZDim measured within the parent co-ordinate system).
/// 
/// Figure 252 — Bounding box
class IfcBoundingBox : public IfcGeometricRepresentationItem {
public:
    /// Location of the bottom left corner (having the minimum values).
    IfcCartesianPoint* Corner() const;
    void setCorner(IfcCartesianPoint* v);
    /// Length attribute (measured along the edge parallel to the X Axis)
    double XDim() const;
    void setXDim(double v);
    /// Width attribute (measured along the edge parallel to the Y Axis)
    double YDim() const;
    void setYDim(double v);
    /// Height attribute (measured along the edge parallel to the Z Axis).
    double ZDim() const;
    void setZDim(double v);
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_DOUBLE; case 2: return IfcUtil::Argument_DOUBLE; case 3: return IfcUtil::Argument_DOUBLE; } return IfcGeometricRepresentationItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcCartesianPoint; case 1: return Type::IfcPositiveLengthMeasure; case 2: return Type::IfcPositiveLengthMeasure; case 3: return Type::IfcPositiveLengthMeasure; } return IfcGeometricRepresentationItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Corner"; case 1: return "XDim"; case 2: return "YDim"; case 3: return "ZDim"; } return IfcGeometricRepresentationItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcBoundingBox (IfcAbstractEntity* e);
    IfcBoundingBox (IfcCartesianPoint* v1_Corner, double v2_XDim, double v3_YDim, double v4_ZDim);
    typedef IfcTemplatedEntityList< IfcBoundingBox > list;
};
/// Definition from ISO/CD 10303-42:1992: This entity is a subtype of the half space solid which is trimmed by a surrounding rectangular box. The box has its edges parallel to the coordinate axes of the geometric coordinate system.
/// 
/// NOTE  The purpose of the box is to facilitate CSG computations by producing a solid of finite size.
/// 
/// The IfcBoxedHalfSpace is
/// used (as its supertype IfcHalfSpaceSolid) only within
/// Boolean operations. It divides the domain into exactly two
/// subsets, where the domain in question is that of the attribute
/// Enclosure.
/// The purpose of the attribute Enclosure is to provide a
/// search box for the other operand in the Boolean operation. It
/// shall be sufficiently large to fully enclose the resulting solid
/// after the Boolean operation with the half space. It however does
/// not alter the final result. The result of the Boolean operation
/// would be the same, as if executed by the supertype
/// IfcHalfSpaceSolid. See Figure 253 below.
/// 
/// Figure 253 — Boxed half space operands
/// 
/// NOTE Corresponding ISO 10303-42 entity: boxed_half_space, please refer to ISO/IS 10303-42:1994, p. 185 for the final definition of the formal standard. The IFC class IfcBoundingBox is used for the definition of the enclosure, providing the same definition as box_domain.
/// 
/// HISTORY  New entity in IFC Release 1.5.1, improved documentation available in IFC Release 2x.
/// 
/// IFC2x4 CHANGE  Usage correct, position coordinate system for Enclosure is the object coordinate system.
/// 
/// The IfcBoundingBox (relating to ISO 10303-42:1994 box_domain) that provides the enclosure is given for the convenience of the receiving application to enable the use of size box comparison for efficiency (for example, to check first whether size boxes intersect, if not no calculations has to be done to check whether the solids of the entities intersect).
/// 
/// The Enclosure therefore helps to prevent dealing with infinite-size related issues. The enclosure box is positioned within the object coordinate system, established by the ObjectPlacement of the element represented (for example, by IfcLocalPlacement).  Figure 254 shows the Enclosure box being sufficiently large to fully enclose the Boolean result.
/// 
/// Figure 254 — Boxed half space geometry
class IfcBoxedHalfSpace : public IfcHalfSpaceSolid {
public:
    /// The box which bounds the resulting solid of the Boolean operation involving the half space solid for computational purposes only.
    IfcBoundingBox* Enclosure() const;
    void setEnclosure(IfcBoundingBox* v);
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 2: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcHalfSpaceSolid::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 2: return Type::IfcBoundingBox; } return IfcHalfSpaceSolid::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 2: return "Enclosure"; } return IfcHalfSpaceSolid::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcBoxedHalfSpace (IfcAbstractEntity* e);
    IfcBoxedHalfSpace (IfcSurface* v1_BaseSurface, bool v2_AgreementFlag, IfcBoundingBox* v3_Enclosure);
    typedef IfcTemplatedEntityList< IfcBoxedHalfSpace > list;
};
/// IfcCShapeProfileDef defines
/// a section profile that provides the defining parameters of a C-shaped
/// section to be used by the swept area solid. This section is typically
/// produced by cold forming steel. Its parameters and orientation relative
/// to the position coordinate system are according to the following
/// illustration. The centre of the position coordinate system is in the
/// profile's centre of the bounding box.
/// 
/// HISTORY  New entity in IFC2x2.
/// 
/// IFC2x3 CHANGE  All profile origins are now in the center of the bounding box.
/// 
/// IFC2x4 CHANGE  Type of InternalFilletRadius relaxed to allow for zero radius.
/// Trailing attribute CentreOfGravityInX deleted, use respective property in IfcExtendedProfileProperties instead.
/// 
/// Figure 315 illustrates parameters of the C-shape profile definition. The parameterized profile defines its own position coordinate system. The underlying coordinate system is defined by the swept area solid that uses the profile definition. It is the xy plane of:
/// 
/// IfcSweptAreaSolid.Position
/// 
/// By using offsets of the position location, the parameterized profile can be positioned centric (using x,y offsets = 0.), or at any position relative to the profile. The parameterized profile is defined by a set of parameter attributes. In the illustrated example, the 'CentreOfGravityInX' property in IfcExtendedProfileProperties, if provided, is negative.
/// 
/// Figure 315 — C-shape profile
class IfcCShapeProfileDef : public IfcParameterizedProfileDef {
public:
    /// Profile depth, see illustration above (= h).
    double Depth() const;
    void setDepth(double v);
    /// Profile width, see illustration above (= b).
    double Width() const;
    void setWidth(double v);
    /// Constant wall thickness of profile (= ts).
    double WallThickness() const;
    void setWallThickness(double v);
    /// Lengths of girth, see illustration above (= c).
    double Girth() const;
    void setGirth(double v);
    /// Whether the optional attribute InternalFilletRadius is defined for this IfcCShapeProfileDef
    bool hasInternalFilletRadius() const;
    /// Internal fillet radius according the above illustration (= r1).
    double InternalFilletRadius() const;
    void setInternalFilletRadius(double v);
    /// Whether the optional attribute CentreOfGravityInX is defined for this IfcCShapeProfileDef
    bool hasCentreOfGravityInX() const;
    double CentreOfGravityInX() const;
    void setCentreOfGravityInX(double v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 3: return IfcUtil::Argument_DOUBLE; case 4: return IfcUtil::Argument_DOUBLE; case 5: return IfcUtil::Argument_DOUBLE; case 6: return IfcUtil::Argument_DOUBLE; case 7: return IfcUtil::Argument_DOUBLE; case 8: return IfcUtil::Argument_DOUBLE; } return IfcParameterizedProfileDef::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 3: return Type::IfcPositiveLengthMeasure; case 4: return Type::IfcPositiveLengthMeasure; case 5: return Type::IfcPositiveLengthMeasure; case 6: return Type::IfcPositiveLengthMeasure; case 7: return Type::IfcPositiveLengthMeasure; case 8: return Type::IfcPositiveLengthMeasure; } return IfcParameterizedProfileDef::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 3: return "Depth"; case 4: return "Width"; case 5: return "WallThickness"; case 6: return "Girth"; case 7: return "InternalFilletRadius"; case 8: return "CentreOfGravityInX"; } return IfcParameterizedProfileDef::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCShapeProfileDef (IfcAbstractEntity* e);
    IfcCShapeProfileDef (IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< std::string > v2_ProfileName, IfcAxis2Placement2D* v3_Position, double v4_Depth, double v5_Width, double v6_WallThickness, double v7_Girth, boost::optional< double > v8_InternalFilletRadius, boost::optional< double > v9_CentreOfGravityInX);
    typedef IfcTemplatedEntityList< IfcCShapeProfileDef > list;
};
/// Definition from ISO/CD 10303-42:1992: A point defined by its coordinates in a two or three dimensional rectangular Cartesian coordinate system, or in a two dimensional parameter space. The entity is defined in a two or three dimensional space.  
/// 
/// The derived attribute Dim has been added (see also note at IfcGeometricRepresentationItem). The WR1 was added to constrain the usage of IfcCartesianPoint in the context of IFC geometry. For the purpose of defining geometry in IFC only two and three dimensional Cartesian points are used.  
/// 
/// NOTE: Corresponding STEP entity: cartesian_point, please refer to ISO/IS 10303-42:1994, p. 23 for the final definition of the formal standard.
/// 
/// HISTORY: New entity in IFC Release 1.0
class IfcCartesianPoint : public IfcPoint {
public:
    /// The first, second, and third coordinate of the point location. If placed in a two or three dimensional rectangular Cartesian coordinate system, Coordinates[1] is the X coordinate, Coordinates[2] is the Y coordinate, and Coordinates[3] is the Z coordinate.
    std::vector< double > /*[1:3]*/ Coordinates() const;
    void setCoordinates(std::vector< double > /*[1:3]*/ v);
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_AGGREGATE_OF_DOUBLE; } return IfcPoint::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcLengthMeasure; } return IfcPoint::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Coordinates"; } return IfcPoint::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCartesianPoint (IfcAbstractEntity* e);
    IfcCartesianPoint (std::vector< double > /*[1:3]*/ v1_Coordinates);
    typedef IfcTemplatedEntityList< IfcCartesianPoint > list;
};
/// Definition from ISO/CD 10303-42:1992: A Cartesian transformation operator defines a geometric transformation composed of translation, rotation, mirroring and uniform scaling. The list of normalized vectors u defines the columns of an orthogonal matrix T. These vectors are computed, by the base axis function, from the direction attributes axis1, axis2 and, in Cartesian transformation operator 3d, axis3. If |T|= -1, the transformation includes mirroring. The local origin point A, the scale value S and the matrix T together define a transformation.  
/// 
/// The transformation for a point with position vector P is defined by 
/// 
/// P -> A + STP  
///   The transformation for a direction d is defined by  
/// 
/// d -> Td  
///   The transformation for a vector with orientation d and magnitude k is
///   defined by 
/// 
/// d -> Td, and  
///   k -> Sk  
///   For those entities whose attributes include an axis2 placement, the
///   transformation is applied, after the derivation, to the derived attributes p
///   defining the placement coordinate directions. For a transformed surface, the
///   direction of the surface normal at any point is obtained by transforming the
///   normal, at the corresponding point, to the original surface. For geometric
///   entities with attributes (such as the radius of a circle) which have the
///   dimensionality of length, the values will be multiplied by S.  
///   For curves on surface the p curve.reference to curve will be unaffected
///   by any transformation. The Cartesian transformation operator shall only be
///   applied to geometry defined in a consistent system of units with the same units
///   on each axis. With all optional attributes omitted, the transformation defaults
///   to the identity transformation. The Cartesian transformation operator shall
///   only be instantiated as one of its subtypes.  
/// 
/// NOTE: Corresponding ISO 10303 entity: cartesian_transformation_operator, please refer to ISO/IS 10303-42:1994, p. 32 for the final definition of the formal standard.
/// 
/// HISTORY: New entity in IFC Release 2x.
class IfcCartesianTransformationOperator : public IfcGeometricRepresentationItem {
public:
    /// Whether the optional attribute Axis1 is defined for this IfcCartesianTransformationOperator
    bool hasAxis1() const;
    /// The direction used to determine U[1], the derived X axis direction.
    IfcDirection* Axis1() const;
    void setAxis1(IfcDirection* v);
    /// Whether the optional attribute Axis2 is defined for this IfcCartesianTransformationOperator
    bool hasAxis2() const;
    /// The direction used to determine U[2], the derived Y axis direction.
    IfcDirection* Axis2() const;
    void setAxis2(IfcDirection* v);
    /// The required translation, specified as a cartesian point. The actual translation included in the transformation is from the geometric origin to the local origin.
    IfcCartesianPoint* LocalOrigin() const;
    void setLocalOrigin(IfcCartesianPoint* v);
    /// Whether the optional attribute Scale is defined for this IfcCartesianTransformationOperator
    bool hasScale() const;
    /// The scaling value specified for the transformation.
    double Scale() const;
    void setScale(double v);
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_ENTITY_INSTANCE; case 2: return IfcUtil::Argument_ENTITY_INSTANCE; case 3: return IfcUtil::Argument_DOUBLE; } return IfcGeometricRepresentationItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcDirection; case 1: return Type::IfcDirection; case 2: return Type::IfcCartesianPoint; case 3: return Type::UNDEFINED; } return IfcGeometricRepresentationItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Axis1"; case 1: return "Axis2"; case 2: return "LocalOrigin"; case 3: return "Scale"; } return IfcGeometricRepresentationItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCartesianTransformationOperator (IfcAbstractEntity* e);
    IfcCartesianTransformationOperator (IfcDirection* v1_Axis1, IfcDirection* v2_Axis2, IfcCartesianPoint* v3_LocalOrigin, boost::optional< double > v4_Scale);
    typedef IfcTemplatedEntityList< IfcCartesianTransformationOperator > list;
};
/// Definition from ISO/CD 10303-42:1992: A Cartesian transformation operator 2d defines a geometric transformation in two-dimensional space composed of translation, rotation, mirroring and uniform scaling. The list of normalized vectors u defines the columns of an orthogonal matrix T. These vectors are computed from the direction attributes axis1 and axis2 by the base axis function. If |T|= -1, the transformation includes mirroring.  
/// 
/// NOTE: Corresponding ISO 10303 entity : cartesian_transformation_operator_2d, please refer to ISO/IS 10303-42:1994, p. 36 for the final definition of the formal standard.
/// 
/// HISTORY: New entity in IFC Release 2x.
class IfcCartesianTransformationOperator2D : public IfcCartesianTransformationOperator {
public:
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcCartesianTransformationOperator::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcCartesianTransformationOperator::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcCartesianTransformationOperator::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCartesianTransformationOperator2D (IfcAbstractEntity* e);
    IfcCartesianTransformationOperator2D (IfcDirection* v1_Axis1, IfcDirection* v2_Axis2, IfcCartesianPoint* v3_LocalOrigin, boost::optional< double > v4_Scale);
    typedef IfcTemplatedEntityList< IfcCartesianTransformationOperator2D > list;
};
/// A Cartesian transformation operator 2d non uniform defines a geometric transformation in two-dimensional space composed of translation, rotation, mirroring and non uniform scaling. Non uniform scaling is given by two different scaling factors: 
/// 
/// SELF\IfcCartesianTransformationOperator.Scale: the x axis scale factor 
/// Scale2: the y axis scale factor 
/// 
/// If the Scale factor (at supertype IfcCartesianTransformationOperator) is omitted, it defaults to 1.0. If the Scale2 factor is omitted, it defaults to the value of Scale (the x axis scale factor). 
/// 
/// NOTE: The scale factor (Scl) defined at the supertype IfcCartesianTransformationOperator is used to express the calculated Scale factor (normally x axis scale factor).
/// 
/// HISTORY: New entity in IFC Release 2x.
class IfcCartesianTransformationOperator2DnonUniform : public IfcCartesianTransformationOperator2D {
public:
    /// Whether the optional attribute Scale2 is defined for this IfcCartesianTransformationOperator2DnonUniform
    bool hasScale2() const;
    /// The scaling value specified for the transformation along the axis 2. This is normally the y scale factor.
    double Scale2() const;
    void setScale2(double v);
    virtual unsigned int getArgumentCount() const { return 5; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 4: return IfcUtil::Argument_DOUBLE; } return IfcCartesianTransformationOperator2D::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 4: return Type::UNDEFINED; } return IfcCartesianTransformationOperator2D::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 4: return "Scale2"; } return IfcCartesianTransformationOperator2D::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCartesianTransformationOperator2DnonUniform (IfcAbstractEntity* e);
    IfcCartesianTransformationOperator2DnonUniform (IfcDirection* v1_Axis1, IfcDirection* v2_Axis2, IfcCartesianPoint* v3_LocalOrigin, boost::optional< double > v4_Scale, boost::optional< double > v5_Scale2);
    typedef IfcTemplatedEntityList< IfcCartesianTransformationOperator2DnonUniform > list;
};
/// Definition from ISO/CD 10303-42:1992: A Cartesian transformation operator 3d defines a geometric transformation in three-dimensional space composed of translation, rotation, mirroring and uniform scaling. The list of normalized vectors u defines the columns of an orthogonal matrix T. These vectors are computed from the direction attributes axis1, axis2 and axis3 by the base axis function. If |T|= -1, the transformation includes mirroring.  
/// 
/// NOTE: Corresponding ISO 10303 entity: cartesian_transformation_operator_3d, please refer to ISO/IS 10303-42:1994, p. 33 for the final definition of the formal standard.
/// 
/// HISTORY: New entity in IFC Release 2x.
class IfcCartesianTransformationOperator3D : public IfcCartesianTransformationOperator {
public:
    /// Whether the optional attribute Axis3 is defined for this IfcCartesianTransformationOperator3D
    bool hasAxis3() const;
    /// The exact direction of U[3], the derived Z axis direction.
    IfcDirection* Axis3() const;
    void setAxis3(IfcDirection* v);
    virtual unsigned int getArgumentCount() const { return 5; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 4: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcCartesianTransformationOperator::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 4: return Type::IfcDirection; } return IfcCartesianTransformationOperator::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 4: return "Axis3"; } return IfcCartesianTransformationOperator::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCartesianTransformationOperator3D (IfcAbstractEntity* e);
    IfcCartesianTransformationOperator3D (IfcDirection* v1_Axis1, IfcDirection* v2_Axis2, IfcCartesianPoint* v3_LocalOrigin, boost::optional< double > v4_Scale, IfcDirection* v5_Axis3);
    typedef IfcTemplatedEntityList< IfcCartesianTransformationOperator3D > list;
};
/// A Cartesian transformation operator 3d non uniform defines a geometric transformation in three-dimensional space composed of translation, rotation, mirroring and non uniform scaling. Non uniform scaling is given by three different scaling factors:
/// 
/// SELF\IfcCartesianTransformationOperator.Scale: the x axis scale factor
/// Scale2: the y axis scale factor
/// Scale3: the z axis scale factor
/// 
/// If the Scale factor (at supertype IfcCartesianTransformationOperator) is omitted, it defaults to 1.0. If the Scale2 or the Scale3 factor is omitted, it defaults to the value of Scale (the x axis scale factor). 
/// 
/// NOTE: The scale factor (Scl) defined at the supertype IfcCartesianTransformationOperator is used to express the calculated Scale factor (normally x axis scale factor).
/// 
/// HISTORY: New entity in IFC Release 2x.
class IfcCartesianTransformationOperator3DnonUniform : public IfcCartesianTransformationOperator3D {
public:
    /// Whether the optional attribute Scale2 is defined for this IfcCartesianTransformationOperator3DnonUniform
    bool hasScale2() const;
    /// The scaling value specified for the transformation along the axis 2. This is normally the y scale factor.
    double Scale2() const;
    void setScale2(double v);
    /// Whether the optional attribute Scale3 is defined for this IfcCartesianTransformationOperator3DnonUniform
    bool hasScale3() const;
    /// The scaling value specified for the transformation along the axis 3. This is normally the z scale factor.
    double Scale3() const;
    void setScale3(double v);
    virtual unsigned int getArgumentCount() const { return 7; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 5: return IfcUtil::Argument_DOUBLE; case 6: return IfcUtil::Argument_DOUBLE; } return IfcCartesianTransformationOperator3D::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 5: return Type::UNDEFINED; case 6: return Type::UNDEFINED; } return IfcCartesianTransformationOperator3D::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 5: return "Scale2"; case 6: return "Scale3"; } return IfcCartesianTransformationOperator3D::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCartesianTransformationOperator3DnonUniform (IfcAbstractEntity* e);
    IfcCartesianTransformationOperator3DnonUniform (IfcDirection* v1_Axis1, IfcDirection* v2_Axis2, IfcCartesianPoint* v3_LocalOrigin, boost::optional< double > v4_Scale, IfcDirection* v5_Axis3, boost::optional< double > v6_Scale2, boost::optional< double > v7_Scale3);
    typedef IfcTemplatedEntityList< IfcCartesianTransformationOperator3DnonUniform > list;
};
/// IfcCircleProfileDef defines a circle as the profile definition used by the swept surface geometry or by the swept area solid. It is given by its Radius attribute and placed within the 2D position coordinate system, established by the Position attribute. 
/// 
/// HISTORY  New class in IFC 1.5.
/// 
/// Figure 313 illustrates parameters for the circle profile definition. The parameterized profile defines its own position coordinate system. The underlying coordinate system is defined by the swept surface or swept area solid that uses the profile definition. It is the xy plane of either: 
/// 
/// IfcSweptSurface.Position
///   IfcSweptAreaSolid.Position
/// 
/// Or in case of sectioned spines, it is the xy plane of each list member of IfcSectionedSpine.CrossSectionPositions. By using offsets of the position location, the parameterized profile can be positioned centric (using x,y offsets = 0.), or at any position relative to the profile. Explicit coordinate offsets are used to define cardinal points (e.g. upper-left bound). The Position attribute defines the 2D position coordinate system of the circle. The Radius attribute defines the radius of the circle.
/// 
/// Figure 313 — Circle profile
class IfcCircleProfileDef : public IfcParameterizedProfileDef {
public:
    /// The radius of the circle.
    double Radius() const;
    void setRadius(double v);
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 3: return IfcUtil::Argument_DOUBLE; } return IfcParameterizedProfileDef::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 3: return Type::IfcPositiveLengthMeasure; } return IfcParameterizedProfileDef::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 3: return "Radius"; } return IfcParameterizedProfileDef::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCircleProfileDef (IfcAbstractEntity* e);
    IfcCircleProfileDef (IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< std::string > v2_ProfileName, IfcAxis2Placement2D* v3_Position, double v4_Radius);
    typedef IfcTemplatedEntityList< IfcCircleProfileDef > list;
};
/// Definition from ISO/CD 10303-42:1992: A closed shell is a shell
///   of the dimensionality 2 which typically serves as a bound for a region in R3. A
///   closed shell has no boundary, and has non-zero finite extent. If the shell has
///   a domain with coordinate space R3, it divides that space into two connected
///   regions, one finite and the other infinite. In this case, the topological
///   normal of the shell is defined as being directed from the finite to the
///   infinite region.  
///   The shell is represented by a collection of faces. The domain of the
///   shell, if present, contains all those faces, together with their bounds.
///   Associated with each face in the shell is a logical value which indicates
///   whether the face normal agrees with (TRUE) or is opposed to (FALSE) the shell
///   normal. The logical value can be applied directly as a BOOLEAN attribute of an
///   oriented face, or be defaulted to TRUE if the shell boundary attribute member
///   is a face without the orientation attribute.  
///   The combinatorial restrictions on closed shells and geometrical
///   restrictions on their domains are designed to ensure that any domain associated
///   with a closed shell is a closed, orientable manifold. The domain of a closed
///   shell, if present, is a connected, closed, oriented 2-manifold. It is always
///   topologically equivalent to an H-fold torus for some H
///   ³ 0. The number H is referred to as the
///   surface genus of the shell. If a shell of genus H has a domain within
///   coordinate space R3, then the finite region of space inside
///   it is topologically equivalent to a solid ball with H tunnels drilled
///   through it. 
///   The Euler equation (7) applies with B=0, because in this case
///   there are no holes. As in the case of open shells, the surface genus H
///   may not be known a priori, but shall be an integer ³ 0. Thus a necessary, but not sufficient, condition
///   for a well-formed closed shell is the following: 
/// 
/// In the current IFC Release only poly loops
///   (IfcPolyLoop) are defined for bounds of face bound
///   (IfcFaceBound). This will allow for faceted B-rep only. 
/// 
/// NOTE: Corresponding ISO 10303 entity: closed_shell, please refer to ISO/IS 10303-42:1994, p.149 for the final definition of the formal standard.
/// 
/// HISTORY  New class in IFC Release 1.0
/// 
/// Informal propositions: 
/// 
/// Every edge shall be referenced exactly twice by the loops of the face.  
///   Each oriented edge shall be unique.  
///   No edge shall be referenced by more than two faces.  
///   Distinct faces of the shell do not intersect, but may share edges or vertices.  
///   Distinct edges do not intersect but may share vertices.  
///   Each face reference shall be unique.  
///   The loops of the shell shall not be a mixture of poly loop and other loop types. Note: this is given, since only poly loop is defined as face bound definition. 
///   The closed shell shall be an oriented arcwise connected 2-manifold. 
///   The Euler equation shall be satisfied. Note: Please refer to ISO/IS
///   10303-42:1994, p.149 for the equation.
class IfcClosedShell : public IfcConnectedFaceSet {
public:
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcConnectedFaceSet::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcConnectedFaceSet::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcConnectedFaceSet::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcClosedShell (IfcAbstractEntity* e);
    IfcClosedShell (IfcTemplatedEntityList< IfcFace >::ptr v1_CfsFaces);
    typedef IfcTemplatedEntityList< IfcClosedShell > list;
};
/// Definition from ISO/CD 10303-42:1992: A composite curve segment is a bounded curve together with transition information which is used to construct a composite curve (IfcCompositeCurve).
/// 
/// The derived attribute Dim has been added (see also note at IfcGeometricRepresentationItem). The IfcCompositeCurveSegment is a subtype of IfcGeometricRepresentationItem (whereas in ISO 10303-42 composite_curve_segment is not a subtype of geometric_representation_item, the proposed 2nd edition of ISO 10303-42 however proposes the subtype relationship).
/// 
/// NOTE Corresponding ISO 10303 entity: composite_curve_segment. Please refer to ISO/IS 10303-42:1994, p.57 for the final definition of the formal standard.
/// 
/// HISTORY New class in IFC Release 1.0
class IfcCompositeCurveSegment : public IfcGeometricRepresentationItem {
public:
    /// The state of transition (i.e., geometric continuity from the last point of this segment to the first point of the next segment) in a composite curve.
    IfcTransitionCode::IfcTransitionCode Transition() const;
    void setTransition(IfcTransitionCode::IfcTransitionCode v);
    /// An indicator of whether or not the sense of the segment agrees with, or opposes, that of the parent curve. If SameSense is false, the point with highest parameter value is taken as the first point of the segment.
    /// 
    /// NOTE  If the datatype of ParentCurve is IfcTrimmedCurve, the value of SameSense overrides the value of IfcTrimmedCurve.SenseAgreement
    bool SameSense() const;
    void setSameSense(bool v);
    /// The bounded curve which defines the geometry of the segment.
    IfcCurve* ParentCurve() const;
    void setParentCurve(IfcCurve* v);
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENUMERATION; case 1: return IfcUtil::Argument_BOOL; case 2: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcGeometricRepresentationItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcTransitionCode; case 1: return Type::UNDEFINED; case 2: return Type::IfcCurve; } return IfcGeometricRepresentationItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Transition"; case 1: return "SameSense"; case 2: return "ParentCurve"; } return IfcGeometricRepresentationItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcCompositeCurve >::ptr UsingCurves() const; // INVERSE IfcCompositeCurve::Segments
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCompositeCurveSegment (IfcAbstractEntity* e);
    IfcCompositeCurveSegment (IfcTransitionCode::IfcTransitionCode v1_Transition, bool v2_SameSense, IfcCurve* v3_ParentCurve);
    typedef IfcTemplatedEntityList< IfcCompositeCurveSegment > list;
};

class IfcCraneRailAShapeProfileDef : public IfcParameterizedProfileDef {
public:
    double OverallHeight() const;
    void setOverallHeight(double v);
    double BaseWidth2() const;
    void setBaseWidth2(double v);
    /// Whether the optional attribute Radius is defined for this IfcCraneRailAShapeProfileDef
    bool hasRadius() const;
    double Radius() const;
    void setRadius(double v);
    double HeadWidth() const;
    void setHeadWidth(double v);
    double HeadDepth2() const;
    void setHeadDepth2(double v);
    double HeadDepth3() const;
    void setHeadDepth3(double v);
    double WebThickness() const;
    void setWebThickness(double v);
    double BaseWidth4() const;
    void setBaseWidth4(double v);
    double BaseDepth1() const;
    void setBaseDepth1(double v);
    double BaseDepth2() const;
    void setBaseDepth2(double v);
    double BaseDepth3() const;
    void setBaseDepth3(double v);
    /// Whether the optional attribute CentreOfGravityInY is defined for this IfcCraneRailAShapeProfileDef
    bool hasCentreOfGravityInY() const;
    double CentreOfGravityInY() const;
    void setCentreOfGravityInY(double v);
    virtual unsigned int getArgumentCount() const { return 15; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 3: return IfcUtil::Argument_DOUBLE; case 4: return IfcUtil::Argument_DOUBLE; case 5: return IfcUtil::Argument_DOUBLE; case 6: return IfcUtil::Argument_DOUBLE; case 7: return IfcUtil::Argument_DOUBLE; case 8: return IfcUtil::Argument_DOUBLE; case 9: return IfcUtil::Argument_DOUBLE; case 10: return IfcUtil::Argument_DOUBLE; case 11: return IfcUtil::Argument_DOUBLE; case 12: return IfcUtil::Argument_DOUBLE; case 13: return IfcUtil::Argument_DOUBLE; case 14: return IfcUtil::Argument_DOUBLE; } return IfcParameterizedProfileDef::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 3: return Type::IfcPositiveLengthMeasure; case 4: return Type::IfcPositiveLengthMeasure; case 5: return Type::IfcPositiveLengthMeasure; case 6: return Type::IfcPositiveLengthMeasure; case 7: return Type::IfcPositiveLengthMeasure; case 8: return Type::IfcPositiveLengthMeasure; case 9: return Type::IfcPositiveLengthMeasure; case 10: return Type::IfcPositiveLengthMeasure; case 11: return Type::IfcPositiveLengthMeasure; case 12: return Type::IfcPositiveLengthMeasure; case 13: return Type::IfcPositiveLengthMeasure; case 14: return Type::IfcPositiveLengthMeasure; } return IfcParameterizedProfileDef::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 3: return "OverallHeight"; case 4: return "BaseWidth2"; case 5: return "Radius"; case 6: return "HeadWidth"; case 7: return "HeadDepth2"; case 8: return "HeadDepth3"; case 9: return "WebThickness"; case 10: return "BaseWidth4"; case 11: return "BaseDepth1"; case 12: return "BaseDepth2"; case 13: return "BaseDepth3"; case 14: return "CentreOfGravityInY"; } return IfcParameterizedProfileDef::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCraneRailAShapeProfileDef (IfcAbstractEntity* e);
    IfcCraneRailAShapeProfileDef (IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< std::string > v2_ProfileName, IfcAxis2Placement2D* v3_Position, double v4_OverallHeight, double v5_BaseWidth2, boost::optional< double > v6_Radius, double v7_HeadWidth, double v8_HeadDepth2, double v9_HeadDepth3, double v10_WebThickness, double v11_BaseWidth4, double v12_BaseDepth1, double v13_BaseDepth2, double v14_BaseDepth3, boost::optional< double > v15_CentreOfGravityInY);
    typedef IfcTemplatedEntityList< IfcCraneRailAShapeProfileDef > list;
};

class IfcCraneRailFShapeProfileDef : public IfcParameterizedProfileDef {
public:
    double OverallHeight() const;
    void setOverallHeight(double v);
    double HeadWidth() const;
    void setHeadWidth(double v);
    /// Whether the optional attribute Radius is defined for this IfcCraneRailFShapeProfileDef
    bool hasRadius() const;
    double Radius() const;
    void setRadius(double v);
    double HeadDepth2() const;
    void setHeadDepth2(double v);
    double HeadDepth3() const;
    void setHeadDepth3(double v);
    double WebThickness() const;
    void setWebThickness(double v);
    double BaseDepth1() const;
    void setBaseDepth1(double v);
    double BaseDepth2() const;
    void setBaseDepth2(double v);
    /// Whether the optional attribute CentreOfGravityInY is defined for this IfcCraneRailFShapeProfileDef
    bool hasCentreOfGravityInY() const;
    double CentreOfGravityInY() const;
    void setCentreOfGravityInY(double v);
    virtual unsigned int getArgumentCount() const { return 12; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 3: return IfcUtil::Argument_DOUBLE; case 4: return IfcUtil::Argument_DOUBLE; case 5: return IfcUtil::Argument_DOUBLE; case 6: return IfcUtil::Argument_DOUBLE; case 7: return IfcUtil::Argument_DOUBLE; case 8: return IfcUtil::Argument_DOUBLE; case 9: return IfcUtil::Argument_DOUBLE; case 10: return IfcUtil::Argument_DOUBLE; case 11: return IfcUtil::Argument_DOUBLE; } return IfcParameterizedProfileDef::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 3: return Type::IfcPositiveLengthMeasure; case 4: return Type::IfcPositiveLengthMeasure; case 5: return Type::IfcPositiveLengthMeasure; case 6: return Type::IfcPositiveLengthMeasure; case 7: return Type::IfcPositiveLengthMeasure; case 8: return Type::IfcPositiveLengthMeasure; case 9: return Type::IfcPositiveLengthMeasure; case 10: return Type::IfcPositiveLengthMeasure; case 11: return Type::IfcPositiveLengthMeasure; } return IfcParameterizedProfileDef::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 3: return "OverallHeight"; case 4: return "HeadWidth"; case 5: return "Radius"; case 6: return "HeadDepth2"; case 7: return "HeadDepth3"; case 8: return "WebThickness"; case 9: return "BaseDepth1"; case 10: return "BaseDepth2"; case 11: return "CentreOfGravityInY"; } return IfcParameterizedProfileDef::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCraneRailFShapeProfileDef (IfcAbstractEntity* e);
    IfcCraneRailFShapeProfileDef (IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< std::string > v2_ProfileName, IfcAxis2Placement2D* v3_Position, double v4_OverallHeight, double v5_HeadWidth, boost::optional< double > v6_Radius, double v7_HeadDepth2, double v8_HeadDepth3, double v9_WebThickness, double v10_BaseDepth1, double v11_BaseDepth2, boost::optional< double > v12_CentreOfGravityInY);
    typedef IfcTemplatedEntityList< IfcCraneRailFShapeProfileDef > list;
};
/// IfcCsgPrimitive3D is an abstract supertype of all three dimensional primitives used as either tree root item, or as Boolean results within a CSG solid model. All 3D CSG primitives are defined within a three-dimensional placement coordinate system.
/// 
/// NOTEÿ No directly corresponding ISO 10303-42 entity, the select type primitive_3d covers the same individual 3D CSG primitives, the position attribute has been added to apply equally to all subtypes. Please refer to ISO/IS 10303-42:1994, p. 234 for the final definition of the formal standard.
/// 
/// HISTORYÿ New entity in IFC2x3.
class IfcCsgPrimitive3D : public IfcGeometricRepresentationItem {
public:
    /// The placement coordinate system to which the parameters of each individual CSG primitive apply.
    IfcAxis2Placement3D* Position() const;
    void setPosition(IfcAxis2Placement3D* v);
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcGeometricRepresentationItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcAxis2Placement3D; } return IfcGeometricRepresentationItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Position"; } return IfcGeometricRepresentationItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCsgPrimitive3D (IfcAbstractEntity* e);
    IfcCsgPrimitive3D (IfcAxis2Placement3D* v1_Position);
    typedef IfcTemplatedEntityList< IfcCsgPrimitive3D > list;
};
/// Definition from ISO/CD 10303-42:1992: A solid
///   represented as a CSG model is defined by a collection of
///   so-called primitive solids, combined using regularized
///   Boolean operations. The allowed operations are
///   intersection, union, and difference. As a special case a
///   CSG solid can also consists of a single CSG primitive.
/// 
/// A CSG solid requires two kinds of information for its
///   complete definition: geometric and structural.
/// 
/// The geometric information is conveyed by solid models.
///   These typically primitive volumes such as cylinders, wedges
///   and extrusions, but can include general B-Rep models. Solid
///   models can also be half space solids.
/// 
/// The structural information is in a tree (strictly an
///   acyclic directed graph) of Boolean result and CSG solids,
///   which represent a &#8216;recipe&#8217; for building the
///   solid. The terminal nodes are the geometric primitives and
///   other solids. Every CSG solid has precisely one Boolean
///   result associated with it which is the root of the tree
///   that defines the solid. (There may be further Boolean
///   results within the tree as operands). The significance of a
///   CSG solid entity is that the solid defined by the
///   associated tree is thus identified as a significant object
///   itself, and in this way it is distinguished from other
///   Boolean result entities representing intermediate results
///   during the construction process.
/// 
/// Definition from IAI: The following primitive volumes
///   can be parts of the CSG tree: solid models, i.e. faceted
///   B-Rep (IfcFacetedBrep, IfcFacetedBrepWithVoids),
///   swept area solid (IfcExtrudedAreaSolid,
///   IfcRevolvedAreaSolid, IfcSurfaceCurveSweptAreaSolid),
///   swept disk solids (IfcSweptDiskSolid), half space
///   solids (IfcHalfSpaceSolid and subtypes), and CSG
///   primitives (subtypes of IfcCsgPrimitive3D).
/// 
/// NOTE Corresponding ISO 10303-42 entity: csg_solid, please refer to ISO/IS 10303-42:1994, p.174 for the final definition of the formal standard.
/// 
/// HISTORY New class in IFC Release 1.5.1
class IfcCsgSolid : public IfcSolidModel {
public:
    /// Boolean expression of primitives and regularized operators describing the solid. The root of the tree of Boolean expressions is given explicitly as an IfcBooleanResult entitiy or as a primitive (subtypes of IfcCsgPrimitive3D).
    IfcCsgSelect* TreeRootExpression() const;
    void setTreeRootExpression(IfcCsgSelect* v);
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcSolidModel::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcCsgSelect; } return IfcSolidModel::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "TreeRootExpression"; } return IfcSolidModel::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCsgSolid (IfcAbstractEntity* e);
    IfcCsgSolid (IfcCsgSelect* v1_TreeRootExpression);
    typedef IfcTemplatedEntityList< IfcCsgSolid > list;
};
/// Definition from ISO/CD 10303-42:1992: A curve can be envisioned as the path of a point moving in its coordinate space.  
/// 
/// NOTE: Corresponding ISO 10303 entity: curve, only the following subtypes have been incorporated into IFC: line as IfcLine, conic as IfcConic, bounded_curve as IfcBoundedCurve. Please refer to ISO/IS 10303-42:1994, p.37 for the final definition of the formal standard. The derived attribute Dim has been added (see also note at IfcGeometricRepresentationItem).
/// 
/// HISTORY: New entity in IFC Release 1.0
/// 
/// Informal proposition: 
/// 
/// A curve shall be arcwise connected 
/// A curve shall have an arc length greater than zero.
class IfcCurve : public IfcGeometricRepresentationItem {
public:
    virtual unsigned int getArgumentCount() const { return 0; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcGeometricRepresentationItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcGeometricRepresentationItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcGeometricRepresentationItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCurve (IfcAbstractEntity* e);
    IfcCurve ();
    typedef IfcTemplatedEntityList< IfcCurve > list;
};
/// Definition from ISO/CD 10303-42:1992: The curve bounded surface is a parametric surface with curved boundaries defined by one or more boundary curves. The bounded surface is defined to be the portion of the basis surface in the direction of N x T from any point on the boundary, where N is the surface normal and T the boundary curve tangent vector at this point. The region so defined shall be arcwise connected. 
/// 
/// The IfcCurveBoundedPlane is a specialized bounded surface class that deals only with bounding basis plane surfaces. The definition varies from STEP as outer and inner boundaries are separated attributes and refer to IfcCurve. The only basis surface that is allowed is of type IfcPlane, and the implicit_outer attribute has not been incorporated, since only unbounded surfaces are used as basis surface.
/// 
/// The BasisSurface is an IfcPlane that establishes the position coordinate system by SELF\IfcElementarySurface.Position. The OuterBoundary and the InnerBoundaries (if provided) shall lie on the surface of IfcPlane. Therefore the IfcCurve's establishing the outer and inner boundaries shall be:
/// 
/// either a 2D curve within the XY plane of the position coordinate sytem of IfcPlane or a 3D curve with all coordinates having a z value = 0.
/// 
/// NOTE Corresponding ISO 10303 entity curve_bounded_surface has been changed to meet the specific requirements of an easy representation of curve bounded planes.
/// 
/// HISTORY  New entity in IFC Release 1.5
/// 
/// IFC2x PLATFORM CHANGE: The data type of the attribute OuterBoundary and InnerBoundaries has been changed from Ifc2DCompositeCurve to its supertype IfcCurve with upward compatibility for file based exchange.
class IfcCurveBoundedPlane : public IfcBoundedSurface {
public:
    /// The surface to be bound.
    IfcPlane* BasisSurface() const;
    void setBasisSurface(IfcPlane* v);
    /// The outer boundary of the surface.
    IfcCurve* OuterBoundary() const;
    void setOuterBoundary(IfcCurve* v);
    /// An optional set of inner boundaries. They shall not intersect each other or the outer boundary.
    IfcTemplatedEntityList< IfcCurve >::ptr InnerBoundaries() const;
    void setInnerBoundaries(IfcTemplatedEntityList< IfcCurve >::ptr v);
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_ENTITY_INSTANCE; case 2: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } return IfcBoundedSurface::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcPlane; case 1: return Type::IfcCurve; case 2: return Type::IfcCurve; } return IfcBoundedSurface::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "BasisSurface"; case 1: return "OuterBoundary"; case 2: return "InnerBoundaries"; } return IfcBoundedSurface::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCurveBoundedPlane (IfcAbstractEntity* e);
    IfcCurveBoundedPlane (IfcPlane* v1_BasisSurface, IfcCurve* v2_OuterBoundary, IfcTemplatedEntityList< IfcCurve >::ptr v3_InnerBoundaries);
    typedef IfcTemplatedEntityList< IfcCurveBoundedPlane > list;
};
/// A defined symbol is a symbolic representation that gets its shape information by an established convention, either through a predefined symbol, or an externally defined symbol.
/// 
/// NOTE: The IfcDefinedSymbol is an entity that had been adopted from ISO 10303, Industrial automation systems and integration&#151;Product data representation and exchange, Part 46: Integrated generic resources: Visual presentation.
/// 
/// NOTE Corresponding ISO 10303 name: defined_symbol. The target attribute used the 2d Cartesian transformation operator, including the non-uniform subtype, which is available in IFC (instead of the symbol_target). Please refer to ISO/IS 10303-46:1994 for the final definition of the formal standard.
/// 
/// HISTORY New entity in IFC2x2.
class IfcDefinedSymbol : public IfcGeometricRepresentationItem {
public:
    /// An implicit description of the symbol, either predefined or externally defined.
    IfcDefinedSymbolSelect* Definition() const;
    void setDefinition(IfcDefinedSymbolSelect* v);
    /// A description of the placement, orientation and (uniform or non-uniform) scaling of the defined symbol.
    IfcCartesianTransformationOperator2D* Target() const;
    void setTarget(IfcCartesianTransformationOperator2D* v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcGeometricRepresentationItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcDefinedSymbolSelect; case 1: return Type::IfcCartesianTransformationOperator2D; } return IfcGeometricRepresentationItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Definition"; case 1: return "Target"; } return IfcGeometricRepresentationItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcDefinedSymbol (IfcAbstractEntity* e);
    IfcDefinedSymbol (IfcDefinedSymbolSelect* v1_Definition, IfcCartesianTransformationOperator2D* v2_Target);
    typedef IfcTemplatedEntityList< IfcDefinedSymbol > list;
};

class IfcDimensionCurve : public IfcAnnotationCurveOccurrence {
public:
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcAnnotationCurveOccurrence::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcAnnotationCurveOccurrence::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcAnnotationCurveOccurrence::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcTerminatorSymbol >::ptr AnnotatedBySymbols() const; // INVERSE IfcTerminatorSymbol::AnnotatedCurve
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcDimensionCurve (IfcAbstractEntity* e);
    IfcDimensionCurve (IfcRepresentationItem* v1_Item, IfcTemplatedEntityList< IfcPresentationStyleAssignment >::ptr v2_Styles, boost::optional< std::string > v3_Name);
    typedef IfcTemplatedEntityList< IfcDimensionCurve > list;
};

class IfcDimensionCurveTerminator : public IfcTerminatorSymbol {
public:
    IfcDimensionExtentUsage::IfcDimensionExtentUsage Role() const;
    void setRole(IfcDimensionExtentUsage::IfcDimensionExtentUsage v);
    virtual unsigned int getArgumentCount() const { return 5; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 4: return IfcUtil::Argument_ENUMERATION; } return IfcTerminatorSymbol::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 4: return Type::IfcDimensionExtentUsage; } return IfcTerminatorSymbol::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 4: return "Role"; } return IfcTerminatorSymbol::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcDimensionCurveTerminator (IfcAbstractEntity* e);
    IfcDimensionCurveTerminator (IfcRepresentationItem* v1_Item, IfcTemplatedEntityList< IfcPresentationStyleAssignment >::ptr v2_Styles, boost::optional< std::string > v3_Name, IfcAnnotationCurveOccurrence* v4_AnnotatedCurve, IfcDimensionExtentUsage::IfcDimensionExtentUsage v5_Role);
    typedef IfcTemplatedEntityList< IfcDimensionCurveTerminator > list;
};
/// Definition from ISO/CD 10303-42:1992: This entity defines a general direction vector in two or three dimensional space. The actual magnitudes of the components have no effect upon the direction being defined, only the ratios X:Y:Z or X:Y are significant.  
/// 
/// NOTE: The components of this entity are not normalized. If a unit vector is required it should be normalized before use.
/// 
/// NOTE: Corresponding ISO 10303 entity: direction. Please refer to ISO/IS 10303-42:1994, p.26 for the final definition of the formal standard. The derived attribute Dim has been added (see also note at IfcGeometricRepresentationItem).
/// 
/// HISTORY: New entity in IFC Release 1.0
class IfcDirection : public IfcGeometricRepresentationItem {
public:
    /// The components in the direction of X axis (DirectionRatios[1]), of Y axis (DirectionRatios[2]), and of Z axis (DirectionRatios[3])
    std::vector< double > /*[2:3]*/ DirectionRatios() const;
    void setDirectionRatios(std::vector< double > /*[2:3]*/ v);
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_AGGREGATE_OF_DOUBLE; } return IfcGeometricRepresentationItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::UNDEFINED; } return IfcGeometricRepresentationItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "DirectionRatios"; } return IfcGeometricRepresentationItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcDirection (IfcAbstractEntity* e);
    IfcDirection (std::vector< double > /*[2:3]*/ v1_DirectionRatios);
    typedef IfcTemplatedEntityList< IfcDirection > list;
};
/// The door lining is the frame which
/// enables the door leaf to be fixed in position. The door lining is
/// used to hang the door leaf. The parameters of the door lining
/// (IfcDoorLiningProperties) define the geometrically
/// relevant parameter of the lining.
/// 
/// NOTEÿ The IfcDoorLiningProperties
/// shall only be applied to construct the 3D shape of a door, if the
/// attribute IfcDoorStyle.ParameterTakesPrecedence is set
/// TRUE.
/// 
/// The IfcDoorLiningProperties are included in the list of
/// properties of IfcDoorStyle.HasPropertySets. More
/// information about the door lining can be included in the same
/// list of the IfcDoorStyle using another
/// IfcPropertySet for dynamic extensions.
/// 
/// HISTORY New entity in IFC Release 2.0. Has been renamed from IfcDoorLining in IFC Release 2x.
/// 
/// IFC2x4 CHANGEÿ The following attributes have been added LiningToPanelOffsetX, LiningToPanelOffsetY. The attribute ShapeAspectStyle is deprecated and shall no longer be used. Supertype changed to new IfcPreDefinedPropertySet.
/// 
/// Geometry use definitions
/// The IfcDoorLiningProperties does not hold its own
/// geometric representation. However it defines parameters which can
/// be used to create the shape of the door style (which is inserted
/// by the IfcDoor into the spatial context of the
/// project) as shown in Figure 172.
/// The parameters of the IfcDoorLiningProperties define a
/// standard door lining, including (if given) a threshold and a
/// transom. The outer boundary of the lining is determined by the
/// occurrence parameter assigned to the IfcDoor, which
/// inserts the IfcDoorStyle.
/// 
/// The lining is applied to the left,
/// right and upper side of the opening reveal. The parameters are:
/// 
/// LiningDepth, if omited, equal to
/// wall thickness - this only takes effect if a value for
/// LiningThickness is given. If both parameters are not
/// given, then there is no lining.
/// LiningThickness
/// LiningToPanelOffsetX
/// LiningToPanelOffsetY
/// 
/// NOTE Parameters added in
/// IFC2x4.
/// 
/// The lining can only cover part of
/// the opening reveal.
/// 
/// LiningOffset : given if lining edge has an offset to
/// the x axis of the local placement.
/// 
/// NOTE ÿIn addition to theÿLiningOffset,
/// the local placement of the IfcDoor can already have an
/// offset to the wall edge and thereby shift the lining along the y
/// axis. The actual position of the lining is calculated from the
/// origin of the local placement along the positive y axis with the
/// distance given by LiningOffset.
/// 
/// The lining may include a casing,
/// which covers part of the wall faces around the opening. The
/// casing covers the left, right and upper side of the lining on
/// both sides of the wall. The parameters are:
/// 
/// CasingDepth
/// CasingThickness
/// 
/// The lining may include a threshold,
/// which covers the bottom side of the opening. The parameters are:
/// 
/// ThresholdDepth
/// if omited, equal to wall thickness - this
/// only takes effect if a value for ThresholdThickness is
/// given. If both parameters are not given, then there is no
/// threshold.
/// ThresholdThickness
/// ThresholdOffset (not shown in figure): given, if the
/// threshold edge has an offset to the x axis of the local
/// placement.
/// 
/// The lining may have a transom which
/// separates the door panel from a window panel. The transom, if
/// given, is defined by:
/// 
/// TransomOffset : a parallel edge to the x axis of the
/// local placement
/// TransomThickness
/// 
/// The depth of the transom is identical to the depth of the
/// lining and not given as separate parameter.
/// 
/// Figure 172 — Door lining properties
/// 
/// NOTE LiningDepth describes the length of the lining along the reveal of the door opening. It can be given by an absolute value if the door lining has a specific depth depending on the door style. However often it is equal to the wall thickness. If the same door style is used (like the same type of single swing door), but inserted into different walls with different thicknesses, it would be necessary to create a special door style for each wall thickness. Therefore several CAD systems allow to set the value to "automatically aligned" to wall thickness. This should be exchanged by leaving the optional attribute LiningDepth unassigned. The same agreement applies to ThresholdDepth.
class IfcDoorLiningProperties : public IfcPropertySetDefinition {
public:
    /// Whether the optional attribute LiningDepth is defined for this IfcDoorLiningProperties
    bool hasLiningDepth() const;
    /// Depth of the door lining, measured perpendicular to the plane of the door lining. If omitted (and with a given value to lining thickness) it indicates an adjustable depth (i.e. a depth that adjusts to the thickness of the wall into which the occurrence of this door style is inserted).
    double LiningDepth() const;
    void setLiningDepth(double v);
    /// Whether the optional attribute LiningThickness is defined for this IfcDoorLiningProperties
    bool hasLiningThickness() const;
    /// Thickness (width in plane parallel to door leaf) of the door lining.
    double LiningThickness() const;
    void setLiningThickness(double v);
    /// Whether the optional attribute ThresholdDepth is defined for this IfcDoorLiningProperties
    bool hasThresholdDepth() const;
    /// Depth (dimension in plane perpendicular to door leaf) of the door threshold. Only given if the door lining includes a threshold. If omitted (and with a given value to threshold thickness) it indicates an adjustable depth (i.e. a depth that adjusts to the thickness of the wall into which the occurrence of this door style is inserted).
    double ThresholdDepth() const;
    void setThresholdDepth(double v);
    /// Whether the optional attribute ThresholdThickness is defined for this IfcDoorLiningProperties
    bool hasThresholdThickness() const;
    /// Thickness (width in plane parallel to door leaf) of the door threshold. Only given if the door lining includes a threshold and the parameter is known.
    double ThresholdThickness() const;
    void setThresholdThickness(double v);
    /// Whether the optional attribute TransomThickness is defined for this IfcDoorLiningProperties
    bool hasTransomThickness() const;
    /// Thickness (width in plane parallel to door leaf) of the transom (if given) which divides the door leaf from a glazing (or window) above.
    double TransomThickness() const;
    void setTransomThickness(double v);
    /// Whether the optional attribute TransomOffset is defined for this IfcDoorLiningProperties
    bool hasTransomOffset() const;
    /// Offset of the transom (if given) which divides the door leaf from a glazing (or window) above. The offset is given from the bottom of the door opening.
    double TransomOffset() const;
    void setTransomOffset(double v);
    /// Whether the optional attribute LiningOffset is defined for this IfcDoorLiningProperties
    bool hasLiningOffset() const;
    /// Offset (dimension in plane perpendicular to door leaf) of the door lining. The offset is given as distance to the x axis of the local placement.
    double LiningOffset() const;
    void setLiningOffset(double v);
    /// Whether the optional attribute ThresholdOffset is defined for this IfcDoorLiningProperties
    bool hasThresholdOffset() const;
    /// Offset (dimension in plane perpendicular to door leaf) of the door threshold. The offset is given as distance to the x axis of the local placement. Only given if the door lining includes a threshold and the parameter is known.
    double ThresholdOffset() const;
    void setThresholdOffset(double v);
    /// Whether the optional attribute CasingThickness is defined for this IfcDoorLiningProperties
    bool hasCasingThickness() const;
    /// Thickness of the casing (dimension in plane of the door leaf). If given it is applied equally to all four sides of the adjacent wall.
    double CasingThickness() const;
    void setCasingThickness(double v);
    /// Whether the optional attribute CasingDepth is defined for this IfcDoorLiningProperties
    bool hasCasingDepth() const;
    /// Depth of the casing (dimension in plane perpendicular to door leaf). If given it is applied equally to all four sides of the adjacent wall.
    double CasingDepth() const;
    void setCasingDepth(double v);
    /// Whether the optional attribute ShapeAspectStyle is defined for this IfcDoorLiningProperties
    bool hasShapeAspectStyle() const;
    /// Pointer to the shape aspect, if given. The shape aspect reflects the part of the door shape, which represents the door lining.
    /// 
    /// IFC2x4 CHANGE The attribute is deprecated and shall no longer be used, i.e. the value shall be NIL ($).
    IfcShapeAspect* ShapeAspectStyle() const;
    void setShapeAspectStyle(IfcShapeAspect* v);
    virtual unsigned int getArgumentCount() const { return 15; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 4: return IfcUtil::Argument_DOUBLE; case 5: return IfcUtil::Argument_DOUBLE; case 6: return IfcUtil::Argument_DOUBLE; case 7: return IfcUtil::Argument_DOUBLE; case 8: return IfcUtil::Argument_DOUBLE; case 9: return IfcUtil::Argument_DOUBLE; case 10: return IfcUtil::Argument_DOUBLE; case 11: return IfcUtil::Argument_DOUBLE; case 12: return IfcUtil::Argument_DOUBLE; case 13: return IfcUtil::Argument_DOUBLE; case 14: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcPropertySetDefinition::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 4: return Type::IfcPositiveLengthMeasure; case 5: return Type::IfcPositiveLengthMeasure; case 6: return Type::IfcPositiveLengthMeasure; case 7: return Type::IfcPositiveLengthMeasure; case 8: return Type::IfcPositiveLengthMeasure; case 9: return Type::IfcLengthMeasure; case 10: return Type::IfcLengthMeasure; case 11: return Type::IfcLengthMeasure; case 12: return Type::IfcPositiveLengthMeasure; case 13: return Type::IfcPositiveLengthMeasure; case 14: return Type::IfcShapeAspect; } return IfcPropertySetDefinition::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 4: return "LiningDepth"; case 5: return "LiningThickness"; case 6: return "ThresholdDepth"; case 7: return "ThresholdThickness"; case 8: return "TransomThickness"; case 9: return "TransomOffset"; case 10: return "LiningOffset"; case 11: return "ThresholdOffset"; case 12: return "CasingThickness"; case 13: return "CasingDepth"; case 14: return "ShapeAspectStyle"; } return IfcPropertySetDefinition::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcDoorLiningProperties (IfcAbstractEntity* e);
    IfcDoorLiningProperties (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< double > v5_LiningDepth, boost::optional< double > v6_LiningThickness, boost::optional< double > v7_ThresholdDepth, boost::optional< double > v8_ThresholdThickness, boost::optional< double > v9_TransomThickness, boost::optional< double > v10_TransomOffset, boost::optional< double > v11_LiningOffset, boost::optional< double > v12_ThresholdOffset, boost::optional< double > v13_CasingThickness, boost::optional< double > v14_CasingDepth, IfcShapeAspect* v15_ShapeAspectStyle);
    typedef IfcTemplatedEntityList< IfcDoorLiningProperties > list;
};
/// A door panel is normally a door leaf that opens to allow people or
/// goods to pass. The parameters of the door panel define the
/// geometrically relevant parameter of the panel,
/// 
/// The IfcDoorPanelProperties are used to parametrically
/// describe the shape and operation of door panels. The parametric
/// definition can be added solely or additionally to the explicit
/// shape representation of the door.
/// 
/// The IfcDoorStyle can define doors consisting of more
/// then one panel. In this case, one instance of
/// IfcDoorPanelProperties has to be included for each door
/// panel. The PanelPosition attribute, in conjunction with
/// the IfcDoorStyle.OperationType attribute, determines to
/// which panel the IfcDoorPanelProperties apply.
/// The IfcDoorPanelProperties are included in the list of
/// properties , given by attribute HasPropertySets of the
/// IfcDoorStyle. More information about the door panel can be
/// included in the same list of the IfcDoorStyle using the
/// IfcPropertySet for dynamic extensions.
/// 
/// HISTORYÿ New Entity in IFC Release 2.0.
/// 
/// IFC2x4 CHANGE Supertype changed to new IfcPreDefinedPropertySet.
/// 
/// Geometry use definitions
/// 
/// The IfcDoorPanelProperties does not hold a geometric representation. However it defines parameters which can be used to create the shape of the door style (which is inserted by the IfcDoor into the spatial context of the project) as shown in Figure 173.
/// The parameters of the IfcDoorPanelProperties define a standard door panel, including (if given) a proportional width to define non-uniform double swing (or sliding, or folding) doors. The outer boundary of the panel is determined by the occurrence parameter assigned to the IfcDoor, which inserts the IfcDoorStyle. It has to take the lining parameter into account as well.
/// 
/// The depth of the panel (swinging,
/// double-acting, and sliding panels) is defined by the
/// PanelDepth parameter.
/// 
/// PanelDepth
/// 
/// For door operation types that
/// include more than one panel, the width of (at least) one panel is
/// given by a normalised ratio measure. It determines the width of
/// that panel, which is defined as a ratio of the overall width of
/// the door opening.
/// 
/// PanelWidth
/// 
/// Figure 173 — Door panel properties
class IfcDoorPanelProperties : public IfcPropertySetDefinition {
public:
    /// Whether the optional attribute PanelDepth is defined for this IfcDoorPanelProperties
    bool hasPanelDepth() const;
    /// Depth of the door panel, measured perpendicular to the plane of the door leaf.
    double PanelDepth() const;
    void setPanelDepth(double v);
    /// The PanelOperation defines the way of operation of that panel. The PanelOperation of the door panel has to correspond with the OperationType of the IfcDoorStyle by which it is referenced.
    IfcDoorPanelOperationEnum::IfcDoorPanelOperationEnum PanelOperation() const;
    void setPanelOperation(IfcDoorPanelOperationEnum::IfcDoorPanelOperationEnum v);
    /// Whether the optional attribute PanelWidth is defined for this IfcDoorPanelProperties
    bool hasPanelWidth() const;
    /// Width of this panel, given as ratio relative to the total clear opening width of the door. If omited, it defaults to 1. A value has to be provided for all doors with OperationType's at IfcDoorStyle defining a door with more then one panel.
    double PanelWidth() const;
    void setPanelWidth(double v);
    /// Position of this panel within the door. The PanelPosition of the door panel has to correspond with the OperationType of the IfcDoorStyle by which it is referenced.
    IfcDoorPanelPositionEnum::IfcDoorPanelPositionEnum PanelPosition() const;
    void setPanelPosition(IfcDoorPanelPositionEnum::IfcDoorPanelPositionEnum v);
    /// Whether the optional attribute ShapeAspectStyle is defined for this IfcDoorPanelProperties
    bool hasShapeAspectStyle() const;
    /// Pointer to the shape aspect, if given. The shape aspect reflects the part of the door shape, which represents the door panel.
    /// 
    /// IFC2x4 CHANGE The attribute is deprecated and shall no longer be used, i.e. the value shall be NIL ($).
    IfcShapeAspect* ShapeAspectStyle() const;
    void setShapeAspectStyle(IfcShapeAspect* v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 4: return IfcUtil::Argument_DOUBLE; case 5: return IfcUtil::Argument_ENUMERATION; case 6: return IfcUtil::Argument_DOUBLE; case 7: return IfcUtil::Argument_ENUMERATION; case 8: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcPropertySetDefinition::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 4: return Type::IfcPositiveLengthMeasure; case 5: return Type::IfcDoorPanelOperationEnum; case 6: return Type::IfcNormalisedRatioMeasure; case 7: return Type::IfcDoorPanelPositionEnum; case 8: return Type::IfcShapeAspect; } return IfcPropertySetDefinition::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 4: return "PanelDepth"; case 5: return "PanelOperation"; case 6: return "PanelWidth"; case 7: return "PanelPosition"; case 8: return "ShapeAspectStyle"; } return IfcPropertySetDefinition::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcDoorPanelProperties (IfcAbstractEntity* e);
    IfcDoorPanelProperties (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< double > v5_PanelDepth, IfcDoorPanelOperationEnum::IfcDoorPanelOperationEnum v6_PanelOperation, boost::optional< double > v7_PanelWidth, IfcDoorPanelPositionEnum::IfcDoorPanelPositionEnum v8_PanelPosition, IfcShapeAspect* v9_ShapeAspectStyle);
    typedef IfcTemplatedEntityList< IfcDoorPanelProperties > list;
};
/// Definition: The door style, IfcDoorStyle, defines a particular style of doors, which may be included into the spatial context of the building model through instances of IfcDoor. A door style defines the overall parameter of the door style and refers to the particular parameter of the lining and one (or several) panels through the IfcDoorLiningProperties and the IfcDoorPanelProperties.
/// 
/// The door entity, IfcDoor, defines a particular occurrence of a door inserted in the spatial context of a
/// project. The actual parameter of the door and/or its shape is defined at the IfcDoorStyle, to which the IfcDoor
/// is related by the inverse relationship IsDefinedBy pointing to IfcRelDefinedByType. The IfcDoorStyle
/// also defines the particular attributes for the lining, IfcDoorLiningProperties, and panels, IfcDoorPanelProperties.
/// 
/// HISTORYÿNew entity in IFC Release 2x.
/// 
/// IFC2x4 CHANGE The entity is deprecated and shall not be used. The new entity
/// IfcDoorType shall be used instead.
/// 
/// Geometry use definitions
/// 
/// The IfcDoorStyle defines the baseline geometry, or the representation map, for all occurrences of the door style, given
/// by the IfcDoor, pointing to this style. The representation of the door style may be given by the agreed set of minimal
/// parameters, defined for the door lining and the door panel(s), or it may be given by a geometric representation used by the
/// IfcRepresentationMap. The attribute ParameterTakesPrecedence decides, whether the set of parameters can be used to exactly represent the shape of the door style (TRUE), or whether the attached IfcRepresentationMap
/// holds the exact representation (FALSE).
/// 
/// The IfcDoorStyleOperationTypeEnum defines the general layout of the door style. Depending on the enumerator, the
/// appropriate instances of IfcDoorLiningProperties and IfcDoorPanelProperties are attached in the list of
/// HasPropertySets. The IfcDoorStyleOperationTypeEnum mainly determines the hinge side (left hung, or right hung), the
/// operation (swinging, sliding, folding, etc.)ÿand the number of panels.
/// 
/// See geometry use definitions at IfcDoorStyleOperationTypeEnum for the correct usage of opening symbols for different operation types.
class IfcDoorStyle : public IfcTypeProduct {
public:
    /// Type defining the general layout and operation of the door style.
    IfcDoorStyleOperationEnum::IfcDoorStyleOperationEnum OperationType() const;
    void setOperationType(IfcDoorStyleOperationEnum::IfcDoorStyleOperationEnum v);
    /// Type defining the basic construction and material type of the door.
    IfcDoorStyleConstructionEnum::IfcDoorStyleConstructionEnum ConstructionType() const;
    void setConstructionType(IfcDoorStyleConstructionEnum::IfcDoorStyleConstructionEnum v);
    /// The Boolean value reflects, whether the parameter given in the attached lining and panel properties exactly define the geometry (TRUE), or whether the attached style shape take precedence (FALSE). In the last case the parameter have only informative value.
    bool ParameterTakesPrecedence() const;
    void setParameterTakesPrecedence(bool v);
    /// The Boolean indicates, whether the attached IfcMappedRepresentation (if given) can be sized (using scale factor of transformation), or not (FALSE). If not, the IfcMappedRepresentation should be IfcShapeRepresentation of the IfcDoor (using IfcMappedItem as the Item) with the scale factor = 1.
    bool Sizeable() const;
    void setSizeable(bool v);
    virtual unsigned int getArgumentCount() const { return 12; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; case 9: return IfcUtil::Argument_ENUMERATION; case 10: return IfcUtil::Argument_BOOL; case 11: return IfcUtil::Argument_BOOL; } return IfcTypeProduct::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcDoorStyleOperationEnum; case 9: return Type::IfcDoorStyleConstructionEnum; case 10: return Type::UNDEFINED; case 11: return Type::UNDEFINED; } return IfcTypeProduct::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "OperationType"; case 9: return "ConstructionType"; case 10: return "ParameterTakesPrecedence"; case 11: return "Sizeable"; } return IfcTypeProduct::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcDoorStyle (IfcAbstractEntity* e);
    IfcDoorStyle (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, IfcDoorStyleOperationEnum::IfcDoorStyleOperationEnum v9_OperationType, IfcDoorStyleConstructionEnum::IfcDoorStyleConstructionEnum v10_ConstructionType, bool v11_ParameterTakesPrecedence, bool v12_Sizeable);
    typedef IfcTemplatedEntityList< IfcDoorStyle > list;
};

class IfcDraughtingCallout : public IfcGeometricRepresentationItem {
public:
    IfcEntityList::ptr Contents() const;
    void setContents(IfcEntityList::ptr v);
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } return IfcGeometricRepresentationItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcDraughtingCalloutElement; } return IfcGeometricRepresentationItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Contents"; } return IfcGeometricRepresentationItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcDraughtingCalloutRelationship >::ptr IsRelatedFromCallout() const; // INVERSE IfcDraughtingCalloutRelationship::RelatedDraughtingCallout
    IfcTemplatedEntityList< IfcDraughtingCalloutRelationship >::ptr IsRelatedToCallout() const; // INVERSE IfcDraughtingCalloutRelationship::RelatingDraughtingCallout
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcDraughtingCallout (IfcAbstractEntity* e);
    IfcDraughtingCallout (IfcEntityList::ptr v1_Contents);
    typedef IfcTemplatedEntityList< IfcDraughtingCallout > list;
};
/// The draughting pre defined colour is a pre defined colour for the purpose to identify a colour by name. Allowable names are:
/// 
/// 'black',
/// 'red',
/// 'green',
/// 'blue',
/// 'yellow',
/// 'magenta',
/// 'cyan',
/// 'white',
/// 'by layer'
/// 
/// NOTE ÿThe IfcDraughtingPreDefinedColour is an entity that had been adopted from ISO 10303-202, Industrial automation systems and integration—Product data representation and exchange, Part 202: Application protocol: Associative draughting.
/// 
/// The following table states the RGB values associated with the names given by the IfcDraughtingPreDefinedColour.
/// 
/// Colour name
/// Red
/// Green
/// Blue
/// 
/// black
/// 0
/// 0
/// 0
/// 
/// red
/// 1.0
/// 0
/// 0
/// 
/// green
/// 0
/// 1.0
/// 0
/// 
/// blue
/// 0
/// 0
/// 1.0
/// 
/// yellow
/// 1.0
/// 1.0
/// 0
/// 
/// magenta
/// 1.0
/// 0
/// 1.0
/// 
/// cyan
/// 0
/// 1.0
/// 1.0
/// 
/// white
/// 1.0
/// 1.0
/// 1.0
/// 
/// by layer
/// colour values obtained from
/// IfcPresentationLayerWithStyle.
/// 
/// NOTE ÿCorresponding ISO 10303 name: draughting_pre_defined_colour. Please refer to ISO/IS 10303-202:1994 page 194 for the final definition of the formal standard.
/// 
/// HISTORY ÿNew entity in IFC2x2.
/// 
/// Informal proposition
/// 
/// The value 'by layer' shall only be inserted, if the geometric representation item using the colour definition has an association to IfcPresentationLayerWithStyle, and if that instance of IfcPresentationLayerWithStyle has a valid colour definition for IfcCurveStyle, IfcSymbolStyle, or IfcSurfaceStyle (depending on what is applicable).
class IfcDraughtingPreDefinedColour : public IfcPreDefinedColour {
public:
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcPreDefinedColour::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcPreDefinedColour::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcPreDefinedColour::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcDraughtingPreDefinedColour (IfcAbstractEntity* e);
    IfcDraughtingPreDefinedColour (std::string v1_Name);
    typedef IfcTemplatedEntityList< IfcDraughtingPreDefinedColour > list;
};
/// The draughting predefined curve font type defines a selection of widely used curve fonts for draughting purposes by name. 
/// 
/// NOTE  The IfcDraughtingPreDefinedCurveFont is an entity that had been adopted from ISO 10303, Industrial automation systems and integration&#151;Product data representation and exchange, Part 46 Technical Corrigendum 2: Integrated generic resources: Visual presentation.
/// 
/// Figure 291 (from ISO 10303-46 TC2) illustrates predefined curve fonts.
/// 
/// Figure 291 — Draughting predefined curve font
/// 
/// NOTE  If the IfcDraughtingPreDefinedCurveFont is used within an IfcCurveStyleFontAndScaling then the segment and space lengths that are given in the table are as such for the scale factor 1.0
/// 
/// NOTE  Corresponding ISO 10303 name: pre_defined_curve_font. Please refer to ISO/IS 10303-46:1994 TC2, page 12 for the final definition of the formal standard.
/// 
/// HISTORY  New entity in IFC2x2.
class IfcDraughtingPreDefinedCurveFont : public IfcPreDefinedCurveFont {
public:
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcPreDefinedCurveFont::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcPreDefinedCurveFont::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcPreDefinedCurveFont::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcDraughtingPreDefinedCurveFont (IfcAbstractEntity* e);
    IfcDraughtingPreDefinedCurveFont (std::string v1_Name);
    typedef IfcTemplatedEntityList< IfcDraughtingPreDefinedCurveFont > list;
};
/// Definition from ISO/CD 10303-42:1992: An edge_loop is a loop with nonzero extent. It is a path in which the start and end vertices are the same. Its domain, if present, is a closed curve. An edge_loop may overlap itself.
/// 
/// Informal propositions: 
/// 
/// The genus of the IfcEdgeLoop shall be 1 or greater. 
/// The Euler formula shall be satisfied:(number of vertices) + genus - (number of edges) = 1; 
/// No edge may be referenced more than once by the same IfcEdgeLoop with the same sense. For this purpose, an edge which is not an oriented edge is considered to be referenced with the sense TRUE. 
/// 
/// NOTE  Corresponding ISO 10303 entity: edge_loop. Please refer to ISO/IS 10303-42:1994, p. 122 for the final definition of the formal standard.
/// 
/// HISTORY  New Entity in IFC2x2.
class IfcEdgeLoop : public IfcLoop {
public:
    /// A list of oriented edge entities which are concatenated together to form this path.
    IfcTemplatedEntityList< IfcOrientedEdge >::ptr EdgeList() const;
    void setEdgeList(IfcTemplatedEntityList< IfcOrientedEdge >::ptr v);
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } return IfcLoop::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcOrientedEdge; } return IfcLoop::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "EdgeList"; } return IfcLoop::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcEdgeLoop (IfcAbstractEntity* e);
    IfcEdgeLoop (IfcTemplatedEntityList< IfcOrientedEdge >::ptr v1_EdgeList);
    typedef IfcTemplatedEntityList< IfcEdgeLoop > list;
};
/// Definition from IAI: An IfcElementQuantity
/// defines a set of derived measures of an element's physical
/// property. Elements could be spatial structure elements (like
/// buildings, storeys, or spaces) or building elements (like walls,
/// slabs, finishes). The IfcElementQuantity gets assigned to
/// the element by using the IfcRelDefinesByProperties
/// relationship.
/// The optional MethodOfMeasurement attribute defines the
/// code, e.g. from a standard method of measurement, which had been
/// used to calculate the element quantity.
/// 
/// NOTE The recognizable values for the name and the
/// method of measurement attributes have to be agreed upon in
/// further agreement documents, such as implementers agreements.
/// Some of these agreements might be limited to a certain region, to
/// which the method of measurement applies.
/// 
/// The name attribute, given at the individual Quantities
/// provides a recognizable semantic meaning of the element quantity.
/// Both information is needed to establish a precise meaning for the
/// measure value. An optional description may be assigned to each of
/// the Quantities. All quantities assigned by a single
/// instance of IfcElementQuantity are deemed to have been
/// generated according to the same method of measurement. However
/// several instances of IfcElementQuantity are assignable to
/// an element, thus allowing for an element having quantities
/// generated according to several methods of measurement.
/// 
/// EXAMPLE1 To exchange the net floor area of spaces in
/// the German region (as IfcSpace), the name might be
/// 'Netto-Grundfläche' (net floor area), and the method of
/// measurement might be accordingly 'DIN277-2' (German industry norm
/// no. 277 edition 2)
/// 
/// EXAMPLE2 The same instance of IfcSpace may have
/// a different area measure assigned in the German region according
/// to a housing regulation, the name would be 'Wohnfläche' and
/// the method of measurement would be '2.BV'. It would be attached
/// to the IfcSpace by a separate
/// IfcRelDefinesByProperties relationship.
/// 
/// The IfcElementQuantity can have the following subtypes
/// of IfcPhysicalQuantity within its SET of
/// Quantities, which count for the basis measure types
/// used:
/// 
/// count measure
/// weight measure
/// length measure
/// area measure
/// volume measure
/// time measure
/// 
/// HISTORY New entity in IFC Release
/// 2x. NOTE: It replaces the calcXxx attributes used in previous IFC
/// Releases.
/// IFC2x4 CHANGE Subtyped from new
/// intermediate IfcPreDefinedPropertySet
/// supertype.
/// 
/// Quantity Use Defintion
/// Base quantities are quantity definitions that are independent
/// of a particular method of measurement and therefore
/// internationally applicable. Base quantities are defined as gross
/// and net values and provided by measurement of the correct
/// geometric shape representation of the element. The IFC
/// specification includes a set of base quantity definition. See
/// each subtype of IfcElement for applicable base
/// quantities.
/// The following general agreements apply for each base quantity
/// set
/// 
/// IfcElementQuantity.Name = 'BaseQuantities'
/// IfcElementQuantity.MethodOfMeasurement = NIL
/// IfcElementQuantity.Quantities = SET of subtypes of
/// IfcPhysicalSimpleQuantity with values for the Name
/// attribute as published as part of the IFC specifciation.
class IfcElementQuantity : public IfcPropertySetDefinition {
public:
    /// Whether the optional attribute MethodOfMeasurement is defined for this IfcElementQuantity
    bool hasMethodOfMeasurement() const;
    /// Name of the method of measurement used to calculate the element quantity. The method of measurement attribute has to be made recognizable by further agreements.
    /// 
    /// IFC2x2 Addendum 1 change: The attribute has been changed to be optional
    std::string MethodOfMeasurement() const;
    void setMethodOfMeasurement(std::string v);
    /// The individual quantities for the element, can be a set of length, area, volume, weight or count based quantities.
    IfcTemplatedEntityList< IfcPhysicalQuantity >::ptr Quantities() const;
    void setQuantities(IfcTemplatedEntityList< IfcPhysicalQuantity >::ptr v);
    virtual unsigned int getArgumentCount() const { return 6; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 4: return IfcUtil::Argument_STRING; case 5: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } return IfcPropertySetDefinition::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 4: return Type::IfcLabel; case 5: return Type::IfcPhysicalQuantity; } return IfcPropertySetDefinition::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 4: return "MethodOfMeasurement"; case 5: return "Quantities"; } return IfcPropertySetDefinition::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcElementQuantity (IfcAbstractEntity* e);
    IfcElementQuantity (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_MethodOfMeasurement, IfcTemplatedEntityList< IfcPhysicalQuantity >::ptr v6_Quantities);
    typedef IfcTemplatedEntityList< IfcElementQuantity > list;
};
/// Definition from IAI: The IfcElementType
///   defines a list of commonly shared property set definitions
///   of an element and an optional set of product
///   representations. It is used to define an element
///   specification (i.e. the specific product information, that
///   is common to all occurrences of that product type).
/// 
/// NOTE The product representations are defined as
///   representation maps (at the level of the supertype
///   IfcTypeProduct, which gets assigned by an element
///   instance through the
///   IfcShapeRepresentation.Item[1] being an
///   IfcMappedItem.
/// 
/// An element type is used to define the common properties of
///   a certain type or style of an element that may be applied
///   to instances of that element type to assign a specific
///   style. Element types (the instantiable subtypes) may be
///   exchanged without being already assigned to occurrences.
/// 
/// HISTORY New entity in
///   Release IFC2x Edition 2
class IfcElementType : public IfcTypeProduct {
public:
    /// Whether the optional attribute ElementType is defined for this IfcElementType
    bool hasElementType() const;
    /// The type denotes a particular type that indicates the object further. The use has to be established at the level of instantiable subtypes. In particular it holds the user defined type, if the enumeration of the attribute 'PredefinedType' is set to USERDEFINED.
    std::string ElementType() const;
    void setElementType(std::string v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_STRING; } return IfcTypeProduct::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcLabel; } return IfcTypeProduct::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "ElementType"; } return IfcTypeProduct::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcElementType (IfcAbstractEntity* e);
    IfcElementType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType);
    typedef IfcTemplatedEntityList< IfcElementType > list;
};
/// Definition from ISO/CD 10303-42:1992: An elementary surface (IfcElementarySurface) is a simple analytic surface with defined parametric representation. 
/// 
/// NOTE Corresponding ISO 10303 entity: elementary_surface. Only the subtype plane is incorporated as IfcPlane. The derived attribute Dim has been added (see also note at IfcGeometricRepresentationItem). Please refer to ISO/IS 10303-42:1994, p. 69 for the final definition of the formal standard.
/// 
/// HISTORY New class in IFC Release 1.5
class IfcElementarySurface : public IfcSurface {
public:
    /// The position and orientation of the surface. This attribute is used in the definition of the parameterization of the surface.
    IfcAxis2Placement3D* Position() const;
    void setPosition(IfcAxis2Placement3D* v);
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcSurface::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcAxis2Placement3D; } return IfcSurface::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Position"; } return IfcSurface::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcElementarySurface (IfcAbstractEntity* e);
    IfcElementarySurface (IfcAxis2Placement3D* v1_Position);
    typedef IfcTemplatedEntityList< IfcElementarySurface > list;
};
/// IfcEllipseProfileDef defines an ellipse as the profile definition used by the swept surface geometry
/// or the swept area solid. It is given by its semi axis attributes and placed within the 2D position coordinate system, established by the Position attribute. 
/// 
/// HISTORY  New entity in IFC2x
/// 
/// Figure 317 illustrates parameters for the ellipse profile definition. The parameterized profile defines its own position coordinate system.
/// The underlying coordinate system is defined by the swept surface or swept area solid that uses the profile definition. It is the xy plane of either: 
/// 
/// IfcSweptSurface.Position
///   IfcSweptAreaSolid.Position
/// 
/// Or in case of sectioned spines it is the xy plane of each list member of IfcSectionedSpine.CrossSectionPositions. By using offsets of the position location, the parameterized profile can be positioned centric (using x,y offsets = 0.), or at any position relative to the profile. Explicit coordinate offsets are used to define cardinal points (for example, upper-left bound). The location of the position coordinate system defines the center of the ellipse. The SemiAxis1 attribute defines the first radius of the ellipse in the direction of the X axis, the SemiAxis2 attribute defines the second radius of the ellipse in the direction of the Y axis.
/// 
/// NOTE  The semi axes of the ellipse are rectangular to each other by definition.
/// 
/// Figure 317 — Ellipse profile
class IfcEllipseProfileDef : public IfcParameterizedProfileDef {
public:
    /// The first radius of the ellipse. It is measured along the direction of Position.P[1].
    double SemiAxis1() const;
    void setSemiAxis1(double v);
    /// The second radius of the ellipse. It is measured along the direction of Position.P[2].
    double SemiAxis2() const;
    void setSemiAxis2(double v);
    virtual unsigned int getArgumentCount() const { return 5; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 3: return IfcUtil::Argument_DOUBLE; case 4: return IfcUtil::Argument_DOUBLE; } return IfcParameterizedProfileDef::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 3: return Type::IfcPositiveLengthMeasure; case 4: return Type::IfcPositiveLengthMeasure; } return IfcParameterizedProfileDef::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 3: return "SemiAxis1"; case 4: return "SemiAxis2"; } return IfcParameterizedProfileDef::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcEllipseProfileDef (IfcAbstractEntity* e);
    IfcEllipseProfileDef (IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< std::string > v2_ProfileName, IfcAxis2Placement2D* v3_Position, double v4_SemiAxis1, double v5_SemiAxis2);
    typedef IfcTemplatedEntityList< IfcEllipseProfileDef > list;
};

class IfcEnergyProperties : public IfcPropertySetDefinition {
public:
    /// Whether the optional attribute EnergySequence is defined for this IfcEnergyProperties
    bool hasEnergySequence() const;
    IfcEnergySequenceEnum::IfcEnergySequenceEnum EnergySequence() const;
    void setEnergySequence(IfcEnergySequenceEnum::IfcEnergySequenceEnum v);
    /// Whether the optional attribute UserDefinedEnergySequence is defined for this IfcEnergyProperties
    bool hasUserDefinedEnergySequence() const;
    std::string UserDefinedEnergySequence() const;
    void setUserDefinedEnergySequence(std::string v);
    virtual unsigned int getArgumentCount() const { return 6; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 4: return IfcUtil::Argument_ENUMERATION; case 5: return IfcUtil::Argument_STRING; } return IfcPropertySetDefinition::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 4: return Type::IfcEnergySequenceEnum; case 5: return Type::IfcLabel; } return IfcPropertySetDefinition::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 4: return "EnergySequence"; case 5: return "UserDefinedEnergySequence"; } return IfcPropertySetDefinition::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcEnergyProperties (IfcAbstractEntity* e);
    IfcEnergyProperties (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< IfcEnergySequenceEnum::IfcEnergySequenceEnum > v5_EnergySequence, boost::optional< std::string > v6_UserDefinedEnergySequence);
    typedef IfcTemplatedEntityList< IfcEnergyProperties > list;
};
/// The IfcExtrudedAreaSolid is defined by sweeping a cross
/// section provided by a profile definition. The direction of the
/// extrusion is given by the ExtrudedDirection attribute and
/// the length of the extrusion is given by the Depth
/// attribute. If the planar area has inner boundaries (holes
/// defined), then those holes shall be swept into holes of the solid.
/// The extruded direction can be any direction which is not
/// perpendicular to the z axis of the position coordinate system of
/// the profile.
/// The following definitions from ISO 10303-42 apply:
/// 
/// An extruded area
/// solid is a solid defined by sweeping a bounded planar surface. The
/// direction of translation is defined by a direction vector, and the
/// length of the translation is defined by a distance depth. The
/// planar area may have holes which will sweep into holes in the
/// solid.
/// 
/// The ExtrudedDirection is given within the position
/// coordinate system as defined by
/// IfcSweptAreaSolid.Position. Extrusions are not restricted
/// to be perpendicular to the extruded surface of the profile.
/// 
/// Figure 255 illustrates geometric parameters of the extruded area solid.  The extruded area solid defines the extrusion of a 2D area (given by a profile definition) by an direction and depth. The result is a
/// solid. The swept area is given by a profile definition. This profile is defined:
/// 
/// as a 2D bounded curve within the xy plane of the position coordinate system,
/// as a 2D bounded curve with holes within the xy plane of the position coordinate system,
/// or as a 2D primitive, defined within a 2D position coordinate system, that is placed relative to the xy plane of the position coordinate system
/// 
/// Figure 255 — Extruded area solid geometry
/// 
/// NOTE  Corresponding ISO 10303-42 entity: extruded_area_solid. Please refer to ISO/IS 10303-42:1994, p. 183 for the final definition of the formal standard. The data type of the inherited SweptArea attribute is different, i.e. of type IfcProfileDef. The Position attribute has been added to position the cross section used for the linear extrusion.
/// 
/// HISTORY  New entity in IFC Release 1.5, capabilities of this entity have been enhanced in IFC Release 2x.
/// 
/// Texture use definition
/// For side faces, textures are aligned facing upright continuously
/// along the sides with origin at the first point of an arbitrary
/// profile, and following the outer bound of the profile
/// counter-clockwise (as seen from above). For parameterized profiles,
/// the origin is defined at the +Y extent for rounded profiles (having
/// no sharp edge) and the first sharp edge counter-clockwise from the
/// +Y extent for all other profiles. Textures are stretched or
/// repeated on each side along the outer boundary of the profile
/// according to RepeatS. Textures are stretched or repeated
/// on each side along the extrusion axis according to
/// RepeatT.
/// For top and bottom caps, textures are aligned facing
/// front-to-back, with the origin at the minimum X and Y extent.
/// Textures are stretched or repeated on the top and bottom to the
/// extent of each face according to RepeatS and
/// RepeatT.
/// For profiles with voids, textures are aligned facing upright
/// along the inner side with origin at the first point of an arbitrary
/// profile, and following the inner bound of the profile clockwise (as
/// seen from above). For parameterized profiles, the origin of inner
/// sides is defined at the +Y extent for rounded profiles (having no
/// sharp edge such as hollow ellipses or rounded rectangles) and the
/// first sharp edge clockwise from the +Y extent for all other
/// profiles.
/// 
/// Figure 256 illustrates default texture mapping with a repeated texture (RepeatS=True and RepeatT=True). The image on the left shows the texture where the S axis points to the right and the T axis points up. The image on the right shows the texture applied to the geometry where the X axis points back to the right, the Y axis points back to the left, and the Z axis points up. For an IfcExtrudedAreaSolid having a profile of IfcIShapeProfileDef, the side texture coordinate origin is the first corner counter-clockwise from the +Y axis, which equals
/// (-0.5*IfcIShapeProfileDef.OverallWidth, +0.5*IfcIShapeProfileDef.OverallDepth), while the top (end cap)
/// texture coordinates start at (-0.5*IfcIShapeProfileDef.OverallWidth,
/// -0.5*IfcIShapeProfileDef.OverallDepth).
/// 
/// Figure 256 — Extruded area solid textures
class IfcExtrudedAreaSolid : public IfcSweptAreaSolid {
public:
    /// The direction in which the surface, provided by SweptArea is to be swept.
    IfcDirection* ExtrudedDirection() const;
    void setExtrudedDirection(IfcDirection* v);
    /// The distance the surface is to be swept along the ExtrudedDirection
    /// .
    double Depth() const;
    void setDepth(double v);
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 2: return IfcUtil::Argument_ENTITY_INSTANCE; case 3: return IfcUtil::Argument_DOUBLE; } return IfcSweptAreaSolid::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 2: return Type::IfcDirection; case 3: return Type::IfcPositiveLengthMeasure; } return IfcSweptAreaSolid::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 2: return "ExtrudedDirection"; case 3: return "Depth"; } return IfcSweptAreaSolid::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcExtrudedAreaSolid (IfcAbstractEntity* e);
    IfcExtrudedAreaSolid (IfcProfileDef* v1_SweptArea, IfcAxis2Placement3D* v2_Position, IfcDirection* v3_ExtrudedDirection, double v4_Depth);
    typedef IfcTemplatedEntityList< IfcExtrudedAreaSolid > list;
};
/// Definition from ISO/CD 10303-42:1992: A face based surface model is described by a set of connected face sets of dimensionality 2. The connected face sets shall not intersect except at edges and vertices, except that a face in one connected face set may overlap a face in another connected face set, provided the face boundaries are identical. There shall be at least one connected face set.  
/// 
/// A connected face set may exist independently of a surface model.
/// 
/// NOTE Corresponding STEP entity: face_based_surface_model. Please refer to ISO/IS 10303-42:1994, p. 188 for the final definition of the formal standard.
/// 
/// HISTORY: New entity in IFC Release 2x.
/// 
/// Informal propositions:
/// 
/// The connected face sets shall not overlap or intersect except at common faces, edges or vertices.
/// The fbsm faces have dimensionality 2.
class IfcFaceBasedSurfaceModel : public IfcGeometricRepresentationItem {
public:
    /// The set of connected face sets comprising the face based surface model.
    IfcTemplatedEntityList< IfcConnectedFaceSet >::ptr FbsmFaces() const;
    void setFbsmFaces(IfcTemplatedEntityList< IfcConnectedFaceSet >::ptr v);
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } return IfcGeometricRepresentationItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcConnectedFaceSet; } return IfcGeometricRepresentationItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "FbsmFaces"; } return IfcGeometricRepresentationItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcFaceBasedSurfaceModel (IfcAbstractEntity* e);
    IfcFaceBasedSurfaceModel (IfcTemplatedEntityList< IfcConnectedFaceSet >::ptr v1_FbsmFaces);
    typedef IfcTemplatedEntityList< IfcFaceBasedSurfaceModel > list;
};
/// Definition from ISO/CD 10303-46:1992: The fill area style hatching defines a styled pattern of curves for hatching an annotation fill area or a surface.
/// 
/// The IfcFillAreaStyleHatching is used to define simple, vector-based hatching patterns, based on styled straight lines. The curve font, color and thickness is given by the HatchLineAppearance, the angle by the HatchLineAngle and the distance to the next hatch line by StartOfNextHatchLine, being either an offset distance or a vector.
/// 
/// NOTE  If the hatch pattern involves two (potentially crossing) rows of hatch lines, then two instances of IfcFillAreaStyleHatching should be assigned to the IfcFillAreaStyle. Both share the same (virtual) point of origin of the hatching that is used by the reference hatch line (or the PointOfReferenceHatchLine if there is an offset).
/// 
/// For better control of the hatching appearance, when using hatch lines with other fonts then continuous, the PatternStart allows to offset the start of the curve font pattern along the reference hatch line (if not given, the PatternStart is at zero distance from the virtual point of origin). If the reference hatch line does not go through the origin (of the virtual hatching coordinate system), it can be offset by using the PatternStart PointOfReferenceHatchLine.
/// 
/// NOTE  The coordinates of the PatternStart and the PointOfReferenceHatchLine are given relative to the assumed 0., 0. virtual point of origin at which the hatch pattern is later positioned by the FillStyleTarget point at IfcAnnotationFillAreaOccurrence. The measure values are given in global drawing length units and apply to the target plot scale for the scale depended representation subcontext.
/// 
/// NOTE  The use of PointOfReferenceHatchLine is deprecated.
/// 
/// Figure 292 illustrates hatch attributes.
/// 
/// Example 1
/// This example shows simple hatching given by using a curve font "continuous" at HatchLineAppearance.
/// 
/// The distance of hatch lines is given by a positive length measure. The
/// angle (here 45' if measures in degree) is provided by HatchLineAngle.
/// 
/// The PatternStart is
/// set to NIL ($) in this example.  Example 2
/// This shows hatching from example 1 with using a different curve font at HatchLineAppearance.
///   The distance of hatch lines is given by a positive
/// length measure, therefore the font pattern start is at a point at the
/// next hatch line given by a vector being perpendicular to the point of
/// origin at the reference hatch line.  The
/// PatternStart is set to NIL ($) in this example.
///   Example 3
/// This example uses hatching from example 2 with a vector to determine the pattern start of the next hatch lines. 
/// The pattern start is the beginning of the first visual curve font pattern segment at IfcCurveFont.CurveFont.  The PatternStart is set to NIL ($) in this example.
///   Example 4
/// This example uses hatching from example 3 where the pattern start is offset from the point of origin at the reference hatch line. That is, the first visible curve font pattern segment now does not start at the point of origin at the reference hatch line.
/// 
/// Example 5
/// This example uses hatching from example 4 where the hatch pattern is shifted against the underlying coordinate system. 
/// The point that is mapped to the insertion point of the IfcAnnotationFillAreaOccurrence now has an X and Y offset from the start of the reference hatch line. That is, the reference hatch line now does not go through the insertion point of the hatching.    
///   Example 6
/// This example shows use of IfcFillAreaStyleHatching attributes for two IfcFillAreaStyleHatching's within one IfcFillAreaStyle. Note that the PatternStart now displaces both the reference hatch line from the point of origin and the start of the curve pattern. This can be used in cases when more than one IfcFillAreaStyleHatching is used in an IfcFillAreaStyle in order to place rows of hatch lines with an offset from each other.
/// 
/// Figure 292 — Fill area style hatching
/// 
/// NOTE  Corresponding ISO 10303 name: fill_area_style_hatching. Please refer to ISO/IS 10303-46:1994, p. 108 for the final definition of the formal standard.
/// 
/// HISTORY  New entity in IFC2x2.
/// 
/// IFC2x3 CHANGE  The IfcFillAreaStyleHatching has been changed by making the attributes PatternStart and PointOfReferenceHatchLine OPTIONAL. The attribute StartOfNextHatchLine has changed to a SELECT with the additional choice of IfcPositiveLengthMeasure. Upward compatibility for file based exchange is guaranteed.
class IfcFillAreaStyleHatching : public IfcGeometricRepresentationItem {
public:
    /// The curve style of the hatching lines. Any curve style pattern shall start at the origin of each hatch line.
    IfcCurveStyle* HatchLineAppearance() const;
    void setHatchLineAppearance(IfcCurveStyle* v);
    /// A repetition factor that determines the distance between adjacent hatch lines.
    /// 
    /// IFC2x Edition 3 CHANGE  The attribute type of StartOfNextHatchLine has changed to a SELECT of IfcPositiveLengthMeasure (new) and IfcOneDirectionRepeatFactor.
    IfcHatchLineDistanceSelect* StartOfNextHatchLine() const;
    void setStartOfNextHatchLine(IfcHatchLineDistanceSelect* v);
    /// Whether the optional attribute PointOfReferenceHatchLine is defined for this IfcFillAreaStyleHatching
    bool hasPointOfReferenceHatchLine() const;
    /// A Cartesian point which defines the offset of the reference hatch line from the origin of the (virtual) hatching coordinate system. The origin is used for mapping the fill area style hatching onto an annotation fill area or surface. The reference hatch line would then appear with this offset from the fill style target point.
    /// If not given the reference hatch lines goes through the origin of the (virtual) hatching coordinate system.
    /// 
    /// IFC2x Edition 3 CHANGE  The usage of the attribute PointOfReferenceHatchLine has changed to not provide the Cartesian point which is the origin for mapping, but to provide an offset to the origin for the mapping. The attribute has been made OPTIONAL.
    IfcCartesianPoint* PointOfReferenceHatchLine() const;
    void setPointOfReferenceHatchLine(IfcCartesianPoint* v);
    /// Whether the optional attribute PatternStart is defined for this IfcFillAreaStyleHatching
    bool hasPatternStart() const;
    /// A distance along the reference hatch line which is the start point for the curve style font pattern of the reference hatch line.
    /// If not given, the start point of the curve style font pattern is at the (virtual) hatching coordinate system.
    /// 
    /// IFC2x Edition 2 Addendum 2 CHANGE The attribute PatternStart has been made OPTIONAL.
    IfcCartesianPoint* PatternStart() const;
    void setPatternStart(IfcCartesianPoint* v);
    /// A plane angle measure determining the direction of the parallel hatching lines.
    double HatchLineAngle() const;
    void setHatchLineAngle(double v);
    virtual unsigned int getArgumentCount() const { return 5; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_ENTITY_INSTANCE; case 2: return IfcUtil::Argument_ENTITY_INSTANCE; case 3: return IfcUtil::Argument_ENTITY_INSTANCE; case 4: return IfcUtil::Argument_DOUBLE; } return IfcGeometricRepresentationItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcCurveStyle; case 1: return Type::IfcHatchLineDistanceSelect; case 2: return Type::IfcCartesianPoint; case 3: return Type::IfcCartesianPoint; case 4: return Type::IfcPlaneAngleMeasure; } return IfcGeometricRepresentationItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "HatchLineAppearance"; case 1: return "StartOfNextHatchLine"; case 2: return "PointOfReferenceHatchLine"; case 3: return "PatternStart"; case 4: return "HatchLineAngle"; } return IfcGeometricRepresentationItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcFillAreaStyleHatching (IfcAbstractEntity* e);
    IfcFillAreaStyleHatching (IfcCurveStyle* v1_HatchLineAppearance, IfcHatchLineDistanceSelect* v2_StartOfNextHatchLine, IfcCartesianPoint* v3_PointOfReferenceHatchLine, IfcCartesianPoint* v4_PatternStart, double v5_HatchLineAngle);
    typedef IfcTemplatedEntityList< IfcFillAreaStyleHatching > list;
};
/// The fill area style tile symbol with style is a symbol that is used as a tile within an annotated tiling. 
/// 
/// NOTE: The IfcFillAreaStyleTileSymbolWithStyle is an entity that had been adopted from ISO 10303, Industrial automation systems and integration&#151;Product data representation and exchange, Part 46: Integrated generic resources: Visual presentation.
/// 
/// NOTE: Corresponding ISO 10303 name: fill_area_style_tile_symbol_with_style. Please refer to ISO/IS 10303-46:1994 for the final definition of the formal standard.
/// 
/// HISTORY: New entity in IFC2x2.
class IfcFillAreaStyleTileSymbolWithStyle : public IfcGeometricRepresentationItem {
public:
    /// A styled item that is used as the annotation symbol for tiling the filled area.
    /// 
    /// IFC2x4 CHANGE  The data type has been changed to IfcStyleItem.
    /// 
    /// NOTE  Only IfcStyleItem's that refer to a compatible geometric representation item and presentation style shall be used.
    IfcAnnotationSymbolOccurrence* Symbol() const;
    void setSymbol(IfcAnnotationSymbolOccurrence* v);
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcGeometricRepresentationItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcAnnotationSymbolOccurrence; } return IfcGeometricRepresentationItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Symbol"; } return IfcGeometricRepresentationItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcFillAreaStyleTileSymbolWithStyle (IfcAbstractEntity* e);
    IfcFillAreaStyleTileSymbolWithStyle (IfcAnnotationSymbolOccurrence* v1_Symbol);
    typedef IfcTemplatedEntityList< IfcFillAreaStyleTileSymbolWithStyle > list;
};
/// Definition from ISO/CD 10303-46:1992: The fill area style tiles defines a two dimensional tile to be used for the filling of annotation fill areas or other closed regions. The content of a tile is defined by the tile set, and the placement of each tile determined by the filling pattern which indicates how to place tiles next to each other. Tiles or parts of tiles outside of the annotation fill area or closed region shall be clipped at the of the area or region. 
/// 
/// NOTE Corresponding ISO 10303 name: fill_area_style_tiles. Please refer to ISO/IS 10303-46:1994 for the final definition of the formal standard.
/// 
/// HISTORY New entity in IFC2x2.
class IfcFillAreaStyleTiles : public IfcGeometricRepresentationItem {
public:
    /// A two direction repeat factor defining the shape and relative positioning of the tiles.
    IfcOneDirectionRepeatFactor* TilingPattern() const;
    void setTilingPattern(IfcOneDirectionRepeatFactor* v);
    /// A set of constituents of the tile.
    IfcEntityList::ptr Tiles() const;
    void setTiles(IfcEntityList::ptr v);
    /// The scale factor applied to each tile as it is placed in the annotation fill area.
    double TilingScale() const;
    void setTilingScale(double v);
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 2: return IfcUtil::Argument_DOUBLE; } return IfcGeometricRepresentationItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcOneDirectionRepeatFactor; case 1: return Type::IfcFillAreaStyleTileShapeSelect; case 2: return Type::IfcPositiveRatioMeasure; } return IfcGeometricRepresentationItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "TilingPattern"; case 1: return "Tiles"; case 2: return "TilingScale"; } return IfcGeometricRepresentationItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcFillAreaStyleTiles (IfcAbstractEntity* e);
    IfcFillAreaStyleTiles (IfcOneDirectionRepeatFactor* v1_TilingPattern, IfcEntityList::ptr v2_Tiles, double v3_TilingScale);
    typedef IfcTemplatedEntityList< IfcFillAreaStyleTiles > list;
};

class IfcFluidFlowProperties : public IfcPropertySetDefinition {
public:
    IfcPropertySourceEnum::IfcPropertySourceEnum PropertySource() const;
    void setPropertySource(IfcPropertySourceEnum::IfcPropertySourceEnum v);
    /// Whether the optional attribute FlowConditionTimeSeries is defined for this IfcFluidFlowProperties
    bool hasFlowConditionTimeSeries() const;
    IfcTimeSeries* FlowConditionTimeSeries() const;
    void setFlowConditionTimeSeries(IfcTimeSeries* v);
    /// Whether the optional attribute VelocityTimeSeries is defined for this IfcFluidFlowProperties
    bool hasVelocityTimeSeries() const;
    IfcTimeSeries* VelocityTimeSeries() const;
    void setVelocityTimeSeries(IfcTimeSeries* v);
    /// Whether the optional attribute FlowrateTimeSeries is defined for this IfcFluidFlowProperties
    bool hasFlowrateTimeSeries() const;
    IfcTimeSeries* FlowrateTimeSeries() const;
    void setFlowrateTimeSeries(IfcTimeSeries* v);
    IfcMaterial* Fluid() const;
    void setFluid(IfcMaterial* v);
    /// Whether the optional attribute PressureTimeSeries is defined for this IfcFluidFlowProperties
    bool hasPressureTimeSeries() const;
    IfcTimeSeries* PressureTimeSeries() const;
    void setPressureTimeSeries(IfcTimeSeries* v);
    /// Whether the optional attribute UserDefinedPropertySource is defined for this IfcFluidFlowProperties
    bool hasUserDefinedPropertySource() const;
    std::string UserDefinedPropertySource() const;
    void setUserDefinedPropertySource(std::string v);
    /// Whether the optional attribute TemperatureSingleValue is defined for this IfcFluidFlowProperties
    bool hasTemperatureSingleValue() const;
    double TemperatureSingleValue() const;
    void setTemperatureSingleValue(double v);
    /// Whether the optional attribute WetBulbTemperatureSingleValue is defined for this IfcFluidFlowProperties
    bool hasWetBulbTemperatureSingleValue() const;
    double WetBulbTemperatureSingleValue() const;
    void setWetBulbTemperatureSingleValue(double v);
    /// Whether the optional attribute WetBulbTemperatureTimeSeries is defined for this IfcFluidFlowProperties
    bool hasWetBulbTemperatureTimeSeries() const;
    IfcTimeSeries* WetBulbTemperatureTimeSeries() const;
    void setWetBulbTemperatureTimeSeries(IfcTimeSeries* v);
    /// Whether the optional attribute TemperatureTimeSeries is defined for this IfcFluidFlowProperties
    bool hasTemperatureTimeSeries() const;
    IfcTimeSeries* TemperatureTimeSeries() const;
    void setTemperatureTimeSeries(IfcTimeSeries* v);
    /// Whether the optional attribute FlowrateSingleValue is defined for this IfcFluidFlowProperties
    bool hasFlowrateSingleValue() const;
    IfcDerivedMeasureValue* FlowrateSingleValue() const;
    void setFlowrateSingleValue(IfcDerivedMeasureValue* v);
    /// Whether the optional attribute FlowConditionSingleValue is defined for this IfcFluidFlowProperties
    bool hasFlowConditionSingleValue() const;
    double FlowConditionSingleValue() const;
    void setFlowConditionSingleValue(double v);
    /// Whether the optional attribute VelocitySingleValue is defined for this IfcFluidFlowProperties
    bool hasVelocitySingleValue() const;
    double VelocitySingleValue() const;
    void setVelocitySingleValue(double v);
    /// Whether the optional attribute PressureSingleValue is defined for this IfcFluidFlowProperties
    bool hasPressureSingleValue() const;
    double PressureSingleValue() const;
    void setPressureSingleValue(double v);
    virtual unsigned int getArgumentCount() const { return 19; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 4: return IfcUtil::Argument_ENUMERATION; case 5: return IfcUtil::Argument_ENTITY_INSTANCE; case 6: return IfcUtil::Argument_ENTITY_INSTANCE; case 7: return IfcUtil::Argument_ENTITY_INSTANCE; case 8: return IfcUtil::Argument_ENTITY_INSTANCE; case 9: return IfcUtil::Argument_ENTITY_INSTANCE; case 10: return IfcUtil::Argument_STRING; case 11: return IfcUtil::Argument_DOUBLE; case 12: return IfcUtil::Argument_DOUBLE; case 13: return IfcUtil::Argument_ENTITY_INSTANCE; case 14: return IfcUtil::Argument_ENTITY_INSTANCE; case 15: return IfcUtil::Argument_ENTITY_INSTANCE; case 16: return IfcUtil::Argument_DOUBLE; case 17: return IfcUtil::Argument_DOUBLE; case 18: return IfcUtil::Argument_DOUBLE; } return IfcPropertySetDefinition::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 4: return Type::IfcPropertySourceEnum; case 5: return Type::IfcTimeSeries; case 6: return Type::IfcTimeSeries; case 7: return Type::IfcTimeSeries; case 8: return Type::IfcMaterial; case 9: return Type::IfcTimeSeries; case 10: return Type::IfcLabel; case 11: return Type::IfcThermodynamicTemperatureMeasure; case 12: return Type::IfcThermodynamicTemperatureMeasure; case 13: return Type::IfcTimeSeries; case 14: return Type::IfcTimeSeries; case 15: return Type::IfcDerivedMeasureValue; case 16: return Type::IfcPositiveRatioMeasure; case 17: return Type::IfcLinearVelocityMeasure; case 18: return Type::IfcPressureMeasure; } return IfcPropertySetDefinition::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 4: return "PropertySource"; case 5: return "FlowConditionTimeSeries"; case 6: return "VelocityTimeSeries"; case 7: return "FlowrateTimeSeries"; case 8: return "Fluid"; case 9: return "PressureTimeSeries"; case 10: return "UserDefinedPropertySource"; case 11: return "TemperatureSingleValue"; case 12: return "WetBulbTemperatureSingleValue"; case 13: return "WetBulbTemperatureTimeSeries"; case 14: return "TemperatureTimeSeries"; case 15: return "FlowrateSingleValue"; case 16: return "FlowConditionSingleValue"; case 17: return "VelocitySingleValue"; case 18: return "PressureSingleValue"; } return IfcPropertySetDefinition::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcFluidFlowProperties (IfcAbstractEntity* e);
    IfcFluidFlowProperties (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcPropertySourceEnum::IfcPropertySourceEnum v5_PropertySource, IfcTimeSeries* v6_FlowConditionTimeSeries, IfcTimeSeries* v7_VelocityTimeSeries, IfcTimeSeries* v8_FlowrateTimeSeries, IfcMaterial* v9_Fluid, IfcTimeSeries* v10_PressureTimeSeries, boost::optional< std::string > v11_UserDefinedPropertySource, boost::optional< double > v12_TemperatureSingleValue, boost::optional< double > v13_WetBulbTemperatureSingleValue, IfcTimeSeries* v14_WetBulbTemperatureTimeSeries, IfcTimeSeries* v15_TemperatureTimeSeries, IfcDerivedMeasureValue* v16_FlowrateSingleValue, boost::optional< double > v17_FlowConditionSingleValue, boost::optional< double > v18_VelocitySingleValue, boost::optional< double > v19_PressureSingleValue);
    typedef IfcTemplatedEntityList< IfcFluidFlowProperties > list;
};
/// Definition from IAI: The
/// IfcFurnishingElementType defines a list of commonly shared
/// property set definitions of an element and an optional set of
/// product representations. It is used to define an element
/// specification (i.e. the specific product information, that is
/// common to all occurrences of that product type).
/// NOTEÿ The product representations are defined
/// as representation maps (at the level of the supertype
/// IfcTypeProduct, which gets assigned by an element
/// occurrence instance through the
/// IfcShapeRepresentation.Item[1] being an
/// IfcMappedItem.
/// A furnishing element type is used to define the common
/// properties of a certain type of a furnishing element that may be
/// applied to many instances of that feature type to assign a
/// specific style. Furnishing element types (or the instantiable
/// subtypes) may be exchanged without being already assigned to
/// occurrences.
/// The occurrences of the IfcFurnishingElementType are
/// represented by instances of IfcFurnishingElement (or its
/// subtypes).
/// HISTORYÿNew entity in
/// Release IFC2x Edition 2.
/// IFC2x3 CHANGE The entity has been
/// made non-abstract
/// IFC2x4 CHANGE The entity is marked
/// as deprecated for instantiation - will be made ABSTRACT after
/// IFC2x4.
class IfcFurnishingElementType : public IfcElementType {
public:
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcElementType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcElementType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcElementType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcFurnishingElementType (IfcAbstractEntity* e);
    IfcFurnishingElementType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType);
    typedef IfcTemplatedEntityList< IfcFurnishingElementType > list;
};
/// The furnishing element type IfcFurnitureType defines commonly shared information for occurrences of furnitures.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// applicable assignment of process types 
/// 
/// It is used to define a furniture specification (i.e. the specific product information, that is common to all occurrences of that product type).  Furniture types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcFurnitureType are represented by instances of IfcFurniture. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcFurnishingElementType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_FurnitureTypeCommon 
/// 
/// The following property set definitions are applicable to this entity according to the PredefinedType attribute:  
/// Pset_FurnitureTypeChair (CHAIR) 
/// Pset_FurnitureTypeDesk (DESK) 
/// Pset_FurnitureTypeFileCabinet (FILECABINET) 
/// Pset_FurnitureTypeTable (TABLE) 
/// 
/// Material Use Definition 
/// The material of the IfcFurnitureType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Finish': The finish, typically at visible aspects of the furniture. 
/// 'Frame': The frame from which the object is constructed. 
/// 'Hardware': Finish hardware such as knobs or handles. 
/// 'Padding': Padding such as cushions. 
/// 'Panel': Panels such as glass. 
/// 
/// Composition Use Definition 
/// The IfcFurnitureType may be decomposed into components using IfcRelAggregates where RelatingObject refers to the enclosing IfcFurnitureType and RelatedObjects contains one or more components.  Components are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Composition use is defined for the following predefined types:
/// 
/// (All Types): May contain IfcSystemFurnitureElement components.  Modular furniture may be aggregated into components.
class IfcFurnitureType : public IfcFurnishingElementType {
public:
    /// A designation of where the assembly is intended to take place. A selection of alternatives s provided in an enumerated list.
    IfcAssemblyPlaceEnum::IfcAssemblyPlaceEnum AssemblyPlace() const;
    void setAssemblyPlace(IfcAssemblyPlaceEnum::IfcAssemblyPlaceEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcFurnishingElementType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcAssemblyPlaceEnum; } return IfcFurnishingElementType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "AssemblyPlace"; } return IfcFurnishingElementType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcFurnitureType (IfcAbstractEntity* e);
    IfcFurnitureType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcAssemblyPlaceEnum::IfcAssemblyPlaceEnum v10_AssemblyPlace);
    typedef IfcTemplatedEntityList< IfcFurnitureType > list;
};
/// Definition from ISO/CD 10303-42:1992: A geometric curve set is a collection of two or three dimensional points and curves.
/// 
/// The IfcGeometricCurveSet is used for the exchange of shape representations consisting of (2D or 3D) points and curves only. 
/// 
/// NOTE: Corresponding ISO 10303-42 entity: geometric_set. Please refer to ISO/IS 10303-42:1994, p. 190 for the final definition of the formal standard.
/// 
/// HISTORY: New entity in IFC2x2.
class IfcGeometricCurveSet : public IfcGeometricSet {
public:
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcGeometricSet::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcGeometricSet::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcGeometricSet::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcGeometricCurveSet (IfcAbstractEntity* e);
    IfcGeometricCurveSet (IfcEntityList::ptr v1_Elements);
    typedef IfcTemplatedEntityList< IfcGeometricCurveSet > list;
};
/// IfcIShapeProfileDef
/// defines a section profile that provides the defining parameters of a
/// symmetrical 'I' section to be used by the swept surface geometry or the
/// swept area solid. The I-shape profile has values for its overall depth,
/// width and its web and flange thickness. Additionally a fillet radius
/// may be given. It represents a I-section that is symmetrical about its
/// major and minor axes; and that has both top and bottom flanges being
/// equal and centred on the web.
/// 
/// IfcIShapeProfileDef can also be used to model I sections with
/// sloped or rounded flanges. The slope and radius cannot be expressed in
/// explicit attributes, but they may be retrieved by reference to an
/// external document or library.  See IfcProfileDef for guidance on
/// external references for profile definitions.
/// 
/// HISTORY  New entity in IFC2x.
/// 
/// IFC2x4 CHANGE  Type of FilletRadius relaxed to allow for zero radius.
/// 
/// Figure 318 illustrates parameters of the I-shape profile definition.
/// 
/// Position
/// 
/// The parameterized
/// profile defines its own position coordinate system.
/// The underlying
/// coordinate system is defined by the swept area solid
/// that uses the profile definition. It is the xy plane of: 
/// 
/// IfcSweptAreaSolid.Position
/// 
/// by using offsets of the position location, the parameterized profile
/// can be positioned centric (using x,y offsets = 0.), or at any position
/// relative to the profile. Explicit coordinate offsets are used to define
/// cardinal points (e.g. upper-left bound).
///   Parameter
/// 
/// The parameterized profile
/// is defined by a set of parameter attributes, see attribute definition
/// below.
/// 
/// Note:
/// The black coordinate axes show the
/// underlying coordinate system of the swept surface or swept area solid
/// 
/// Position
/// 
/// The profile is inserted into the underlying
/// coordinate system of the swept area solid by using the Position
/// attribute. In this example (cardinal point of lower left corner) the
/// attribute values of IfcAxis2Placement2D
/// are:
/// 
/// Location
/// = IfcCartesianPoint(,)
/// RefDirection = NIL (defaults to 1.,0.)
/// 
/// Parameter
/// If the FilletRadius
/// is given, it is equally applied to all four corners created by the web
/// and flanges.
/// 
/// Figure 318 — I-shape profile
class IfcIShapeProfileDef : public IfcParameterizedProfileDef {
public:
    /// Total extent of the width, defined parallel to the x axis of the position coordinate system.
    double OverallWidth() const;
    void setOverallWidth(double v);
    /// Total extent of the depth, defined parallel to the y axis of the position coordinate system.
    double OverallDepth() const;
    void setOverallDepth(double v);
    /// Thickness of the web of the I-shape. The web is centred on the x-axis and the y-axis of the position coordinate system.
    double WebThickness() const;
    void setWebThickness(double v);
    /// Flange thickness of the I-shape. Both, the upper and the lower flanges have the same thickness and they are centred on the y-axis of the position coordinate system.
    double FlangeThickness() const;
    void setFlangeThickness(double v);
    /// Whether the optional attribute FilletRadius is defined for this IfcIShapeProfileDef
    bool hasFilletRadius() const;
    /// The fillet between the web and the flange.
    double FilletRadius() const;
    void setFilletRadius(double v);
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 3: return IfcUtil::Argument_DOUBLE; case 4: return IfcUtil::Argument_DOUBLE; case 5: return IfcUtil::Argument_DOUBLE; case 6: return IfcUtil::Argument_DOUBLE; case 7: return IfcUtil::Argument_DOUBLE; } return IfcParameterizedProfileDef::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 3: return Type::IfcPositiveLengthMeasure; case 4: return Type::IfcPositiveLengthMeasure; case 5: return Type::IfcPositiveLengthMeasure; case 6: return Type::IfcPositiveLengthMeasure; case 7: return Type::IfcPositiveLengthMeasure; } return IfcParameterizedProfileDef::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 3: return "OverallWidth"; case 4: return "OverallDepth"; case 5: return "WebThickness"; case 6: return "FlangeThickness"; case 7: return "FilletRadius"; } return IfcParameterizedProfileDef::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcIShapeProfileDef (IfcAbstractEntity* e);
    IfcIShapeProfileDef (IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< std::string > v2_ProfileName, IfcAxis2Placement2D* v3_Position, double v4_OverallWidth, double v5_OverallDepth, double v6_WebThickness, double v7_FlangeThickness, boost::optional< double > v8_FilletRadius);
    typedef IfcTemplatedEntityList< IfcIShapeProfileDef > list;
};
/// IfcLShapeProfileDef
/// defines a section profile that provides the defining parameters of an
/// L-shaped section (equilateral L profiles are also covered by this
/// entity) to be used by the swept area
/// solid. Its parameters and orientation relative to the position
/// coordinate system are according to the following illustration. The
/// shorter leg has the same direction as the positive Position.P[1]-axis, the longer
/// or equal leg the same as the positive Position.P[2]-axis. The centre of the
/// position coordinate system is in the profiles centre
/// of the bounding box.
/// 
/// HISTORY  New entity in IFC2x2.
/// 
/// IFC2x3 CHANGE  All profile origins are now in the center of the bounding box.
/// 
/// IFC2x4 CHANGE  Width changed from OPTIONAL to mandatory.  The previously informal rule that the longer leg is the Depth has been formalized.  Types of FilletRadius and EdgeRadius were relaxed to allow for zero values.  Trailing attributes CentreOfGravityInX and CentreOfGravityInY deleted, use respective properties in IfcExtendedProfileProperties instead.  WHERE rule which required Width <= Depth removed.
/// 
/// Figure 319 illustrates parameters of equal-sided and non-equal sided L-shaped section definitions.
/// 
/// Position 
/// The parameterized profile defines its own position coordinate system.
/// The underlying coordinate system is defined by the swept area solid
/// that uses the profile definition. It is the xy plane of:
/// 
/// IfcSweptAreaSolid.Position
/// 
/// by using offsets of the position location, the parameterized profile
/// can be positioned centric (using x,y offsets = 0.), or at any position
/// relative to the profile.
/// 
/// In the illustrated example, the 'CentreOfGravityInX' and 'CentreOfGravityInY' properties in IfcExtendedProfileProperties, if provided, are both negative.
/// 
/// Note:
/// The black coordinate axes show the
/// underlying coordinate system of the swept surface or swept area solid
/// 
/// Position 
/// The profile is inserted into the underlying
/// coordinate system of the swept area solid by using the Position
/// attribute. In this example (cardinal point of gravity) the
/// attribute values of IfcAxis2Placement2D
/// are:
/// 
/// Location = IfcCartesianPoint(
///               +|CentreOfGravityInX|,
///               +|CentreOfGravityInY|)
/// RefDirection = NIL (defaults to 1.,0.)
/// 
/// In the illustrated example, the x and y value of Position.Location, i.e. the measures |CentreOfGravityInX| and |CentreOfGravityInY| are both positive.  On the other hand, the properties named 'CentreOfGravityInX' and 'CentreOfGravityInY' in IfcExtendedProfileProperties, if provided, must both be set to 0 now because the centre of gravity of the resulting profile definition is located in the coordinate origin.
/// 
/// Figure 319 — L-shape profile
class IfcLShapeProfileDef : public IfcParameterizedProfileDef {
public:
    /// Leg length, see illustration above (= h). Same as the overall depth.
    double Depth() const;
    void setDepth(double v);
    /// Whether the optional attribute Width is defined for this IfcLShapeProfileDef
    bool hasWidth() const;
    /// Leg length, see illustration above (= b). Same as the overall width.
    double Width() const;
    void setWidth(double v);
    /// Constant wall thickness of profile, see illustration above (= ts).
    double Thickness() const;
    void setThickness(double v);
    /// Whether the optional attribute FilletRadius is defined for this IfcLShapeProfileDef
    bool hasFilletRadius() const;
    /// Fillet radius according the above illustration (= r1).
    double FilletRadius() const;
    void setFilletRadius(double v);
    /// Whether the optional attribute EdgeRadius is defined for this IfcLShapeProfileDef
    bool hasEdgeRadius() const;
    /// Edge radius according the above illustration (= r2).
    double EdgeRadius() const;
    void setEdgeRadius(double v);
    /// Whether the optional attribute LegSlope is defined for this IfcLShapeProfileDef
    bool hasLegSlope() const;
    /// Slope of the inner face of each leg of the profile.
    double LegSlope() const;
    void setLegSlope(double v);
    /// Whether the optional attribute CentreOfGravityInX is defined for this IfcLShapeProfileDef
    bool hasCentreOfGravityInX() const;
    double CentreOfGravityInX() const;
    void setCentreOfGravityInX(double v);
    /// Whether the optional attribute CentreOfGravityInY is defined for this IfcLShapeProfileDef
    bool hasCentreOfGravityInY() const;
    double CentreOfGravityInY() const;
    void setCentreOfGravityInY(double v);
    virtual unsigned int getArgumentCount() const { return 11; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 3: return IfcUtil::Argument_DOUBLE; case 4: return IfcUtil::Argument_DOUBLE; case 5: return IfcUtil::Argument_DOUBLE; case 6: return IfcUtil::Argument_DOUBLE; case 7: return IfcUtil::Argument_DOUBLE; case 8: return IfcUtil::Argument_DOUBLE; case 9: return IfcUtil::Argument_DOUBLE; case 10: return IfcUtil::Argument_DOUBLE; } return IfcParameterizedProfileDef::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 3: return Type::IfcPositiveLengthMeasure; case 4: return Type::IfcPositiveLengthMeasure; case 5: return Type::IfcPositiveLengthMeasure; case 6: return Type::IfcPositiveLengthMeasure; case 7: return Type::IfcPositiveLengthMeasure; case 8: return Type::IfcPlaneAngleMeasure; case 9: return Type::IfcPositiveLengthMeasure; case 10: return Type::IfcPositiveLengthMeasure; } return IfcParameterizedProfileDef::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 3: return "Depth"; case 4: return "Width"; case 5: return "Thickness"; case 6: return "FilletRadius"; case 7: return "EdgeRadius"; case 8: return "LegSlope"; case 9: return "CentreOfGravityInX"; case 10: return "CentreOfGravityInY"; } return IfcParameterizedProfileDef::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcLShapeProfileDef (IfcAbstractEntity* e);
    IfcLShapeProfileDef (IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< std::string > v2_ProfileName, IfcAxis2Placement2D* v3_Position, double v4_Depth, boost::optional< double > v5_Width, double v6_Thickness, boost::optional< double > v7_FilletRadius, boost::optional< double > v8_EdgeRadius, boost::optional< double > v9_LegSlope, boost::optional< double > v10_CentreOfGravityInX, boost::optional< double > v11_CentreOfGravityInY);
    typedef IfcTemplatedEntityList< IfcLShapeProfileDef > list;
};
/// Definition from ISO/CD 10303-42:1992: A line is an unbounded curve with constant tangent direction. A line is defined by a point and a direction. The positive direction of the line is in the direction of the Dir vector. The line is parameterized as follows:
/// 
/// P = Pnt
///   V = Dir
///   λ(u) = P + uV
/// 
/// and the parametric range is:
/// 
/// ∞ < u < ∞
/// 
/// NOTE Corresponding ISO 10303 entity: line. Please refer to ISO/IS 10303-42:1994, p.37 for the final definition of the formal standard. The derived attribute Dim has been added at this level and was therefore demoted from the geometric_representation_item.
/// 
/// HISTORY New class in IFC Release 1.0
class IfcLine : public IfcCurve {
public:
    /// The location of the line.
    IfcCartesianPoint* Pnt() const;
    void setPnt(IfcCartesianPoint* v);
    /// The direction of the line, the magnitude and units of Dir affect the parameterization of the line.
    IfcVector* Dir() const;
    void setDir(IfcVector* v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcCurve::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcCartesianPoint; case 1: return Type::IfcVector; } return IfcCurve::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Pnt"; case 1: return "Dir"; } return IfcCurve::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcLine (IfcAbstractEntity* e);
    IfcLine (IfcCartesianPoint* v1_Pnt, IfcVector* v2_Dir);
    typedef IfcTemplatedEntityList< IfcLine > list;
};
/// Definition from ISO/CD 10303-42:1992: A manifold solid
/// B-rep is a finite, arcwise connected volume bounded by one or
/// more surfaces, each of which is a connected, oriented, finite,
/// closed 2-manifold. There is no restriction on the genus of the
/// volume, nor on the number of voids within the volume.
/// The Boundary Representation (B-rep) of a manifold solid
/// utilizes a graph of edges and vertices embedded in a connected,
/// oriented, finite, closed two manifold surface. The embedded graph
/// divides the surface into arcwise connected areas known as faces.
/// The edges and vertices, therefore, form the boundaries of the
/// face and the domain of a face does not include its boundaries.
/// The embedded graph may be disconnected and may be a pseudo graph.
/// The graph is labeled; that is, each entity in the graph has a
/// unique identity. The geometric surface definition used to specify
/// the geometry of a face shall be 2-manifold embeddable in the
/// plane within the domain of the face. In other words, it shall be
/// connected, oriented, finite, non-self-intersecting, and of
/// surface genus 0.
/// Faces do not intersect except along their boundaries. Each
/// edge along the boundary of a face is shared by at most one other
/// face in the assemblage. The assemblage of edges in the B-rep do
/// not intersect except at their boundaries (i.e., vertices). The
/// geometry curve definition used to specify the geometry of an edge
/// shall be arcwise connected and shall not self intersect or
/// overlap within the domain of the edge. The geometry of an edge
/// shall be consistent with the geometry of the faces of which it
/// forms a partial bound. The geometry used to define a vertex shall
/// be consistent with the geometry of the faces and edges of which
/// it forms a partial bound.
/// A B-rep is represented by one or more closed shells which
/// shall be disjoint. One shell, the outer, shall completely enclose
/// all the other shells and no other shell may enclose a shell. The
/// facility to define a B-rep with one or more internal voids is
/// provided by a subtype. The following version of the Euler formula
/// shall be satisfied, where V, E, F, Ll and S are the
/// numbers of unique vertices, edges, faces, loop uses and shells in
/// the model and Gs is the sum of the genus of the
/// shells.
/// 
/// Instances of type IfcManifoldSolidBrep shall be of type
/// IfcFacetedBrep, using only IfcPolyLoop for the
/// bounds of IfcFaceBound, or of type IfcAdvancedBrep,
/// using only IfcAdvancedFace for the face geometry, and
/// IfcEdgeCurve for the edges.
/// 
/// NOTE: Corresponding ISO 10303-42 entity: manifold_solid_brep. Please refer to ISO/IS 10303-42:1994, p. 170 for the final definition of the formal standard. IfcManifoldSolidBrep is defined as ABSTRACT supertype to prevent it from direct instantiation.
/// 
/// HISTORY: New entity in IFC Release 1.0
/// 
/// Informal proposition:
/// 
/// The dimensionality of a manifold solid brep shall be 3.
/// The extent of the manifold solid brep shall be finite and
/// non-zero.
/// All elements of the manifold solid brep shall have defined
/// associated geometry.
/// The shell normals shall agree with the B-rep normal and point
/// away from the solid represented by the B-rep.
/// Each face shall be referenced only once by the shells of the
/// manifold solid brep.
/// The Euler equation shall be satisfied for the boundary
/// representation, where the genus term "shell term" us the sum of
/// the genus values for the shells of the brep.
class IfcManifoldSolidBrep : public IfcSolidModel {
public:
    /// A closed shell defining the exterior boundary of the solid. The shell normal shall point away from the interior of the solid.
    IfcClosedShell* Outer() const;
    void setOuter(IfcClosedShell* v);
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcSolidModel::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcClosedShell; } return IfcSolidModel::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Outer"; } return IfcSolidModel::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcManifoldSolidBrep (IfcAbstractEntity* e);
    IfcManifoldSolidBrep (IfcClosedShell* v1_Outer);
    typedef IfcTemplatedEntityList< IfcManifoldSolidBrep > list;
};
/// An IfcObject is the
/// generalization of any semantically treated thing or process.
/// Objects are things as they appear - i.e. occurrences.
/// NOTE Examples of IfcObject include
/// physically tangible items, such as wall, beam or covering,
/// physically existing items, such as spaces, or conceptual items,
/// such as grids or virtual boundaries. It also stands for
/// processes, such as work tasks, for controls, such as cost items,
/// for actors, such as persons involved in the design process,
/// etc.
/// Objects can be named, using the inherited Name
/// attribute, which should be a user recognizable label for the
/// object occurrance. Further explanations to the object can be
/// given using the inherited Description attribute. The
/// ObjectType attribute is used:
/// 
/// to store the user defined value for all subtypes of
/// IfcObject, where a PredefinedType attribute is
/// given, and its value is set to USERDEFINED.
/// to provide a type information (could be seen as a very
/// lightweight classifier) of the subtype of IfcObject, if no
/// PredefinedType attribute is given. This is often the case,
/// if no comprehensive list of predefined types is available.
/// 
/// Objects are independent pieces of information that might
/// contain or reference other pieces of information. There are
/// several relationships in which objects can be involved:
/// 
/// Association to external/internal resource information
/// - an association relationship that refers to external/internal
/// sources of information. See supertype IfcObjectDefinition
/// for more information.
/// Assignment of other objects - an assignment
/// relationship that refers to other types of objects. See supertype
/// IfcObjectDefinition for more information.
/// Aggregation of other objects - an aggregation
/// relationship that establishes a whole/part relation. Objects can
/// either be a whole, or a part, or both. See supertype
/// IfcObjectDefinition for more information.
/// 
/// Assignment of a type : IsTypedBy - a definition
/// relationship IfcRelDefinesByType that uses a type
/// definition to define the common characteristics of this
/// occurrences, potentially including the common shape
/// representation and common properties of all object occurrences
/// assigned to this type. It is a specific - occurrence relationship
/// with implied dependencies (as the occurrence properties depend on
/// the properties of the type, but may override them).
/// 
/// NOTE See IfcRelDefinesByType for an
/// explanatory figure. Also see for how to override type properties
/// by occurrence properties
/// 
/// Assignment of a partial type : IsDeclaredBy,
/// Declares - a definition relationship
/// IfcRelDefinesByObject that uses a component of a type
/// definition (a part of a type, called the "declaring part") to
/// define a component of an occurence (part of occurrence, called
/// the "reflected part"). This is also refered to as a "deep copy".
/// The common characteristics of all parts in the occurrence are
/// defined by parts in the type. It is a specific - occurrence
/// relationship with implied dependencies (as the occurrence
/// properties depend on the properties of the type, but may override
/// them).
/// 
/// NOTE See IfcRelDefinesByObject for an
/// explanatory figure.
/// 
/// Assignment of property sets : IsDefinedBy - a
/// definition relationship IfcRelDefinesByProperties that
/// assignes property set definitions to the object occurrence.
/// 
/// HISTORY New Entity in IFC Release 1.0
/// 
/// IFC2x4 CHANGE The inverse relationships Declares, IsDeclaredBy, and IsTypedBy have been added, types are not longer included in the IsDefinesBy relationship. IfcProject has been promoted to be a subtype of IfcObjectDefinition -> IfcContext.
/// 
/// Informal Proposition
/// 
/// A partial type assignment, i.e. the inverse attribute
/// IsDeclaredBy, or Declares shall only be used, if
/// the object is part of a decomposition, i.e. if either
/// IsDecomposedBy, or Decomposes is exerted.
class IfcObject : public IfcObjectDefinition {
public:
    /// Whether the optional attribute ObjectType is defined for this IfcObject
    bool hasObjectType() const;
    /// The type denotes a particular type that indicates the object further. The use has to be established at the level of instantiable subtypes. In particular it holds the user defined type, if the enumeration of the attribute PredefinedType is set to USERDEFINED.
    std::string ObjectType() const;
    void setObjectType(std::string v);
    virtual unsigned int getArgumentCount() const { return 5; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 4: return IfcUtil::Argument_STRING; } return IfcObjectDefinition::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 4: return Type::IfcLabel; } return IfcObjectDefinition::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 4: return "ObjectType"; } return IfcObjectDefinition::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcRelDefines >::ptr IsDefinedBy() const; // INVERSE IfcRelDefines::RelatedObjects
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcObject (IfcAbstractEntity* e);
    IfcObject (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType);
    typedef IfcTemplatedEntityList< IfcObject > list;
};
/// Definition from ISO/CD 10303-42:1992: An offset curve 2d (IfcOffsetCurve2d) is a curve at a constant distance from a basis curve in two-dimensional space. This entity defines a simple plane-offset curve by offsetting by distance along the normal to basis curve in the plane of basis curve. The underlying curve shall have a well-defined tangent direction at every point. In the case of a composite curve, the transition code between each segment shall be cont same gradient or cont same gradient same curvature. 
/// 
/// NOTE: The offset curve 2d may differ in nature from the basis curve; the offset of a non self- intersecting curve can be self-intersecting. Care should be taken to ensure that the offset to a continuous curve does not become discontinuous.
/// 
/// The offset curve 2d takes its parameterization from the basis curve. The offset curve 2d is parameterized as  
/// 
/// where T is the unit tangent vector to the basis curve C(u) at parameter value u, and d is distance. The underlying curve shall be two-dimensional. 
/// 
/// NOTE Corresponding ISO 10303 entity: offset_curve_2d, Please refer to ISO/IS 10303-42:1994, p.65 for the final definition of the formal standard.
/// 
/// HISTORY New entity in IFC Release 2.x
class IfcOffsetCurve2D : public IfcCurve {
public:
    /// The curve that is being offset.
    IfcCurve* BasisCurve() const;
    void setBasisCurve(IfcCurve* v);
    /// The distance of the offset curve from the basis curve. distance may be positive, negative or zero. A positive value of distance defines an offset in the direction which is normal to the curve in the sense of an anti-clockwise rotation through 90 degrees from the tangent vector T at the given point. (This is in the direction of orthogonal complement(T).)
    double Distance() const;
    void setDistance(double v);
    /// An indication of whether the offset curve self-intersects; this is for information only.
    bool SelfIntersect() const;
    void setSelfIntersect(bool v);
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_DOUBLE; case 2: return IfcUtil::Argument_BOOL; } return IfcCurve::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcCurve; case 1: return Type::IfcLengthMeasure; case 2: return Type::UNDEFINED; } return IfcCurve::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "BasisCurve"; case 1: return "Distance"; case 2: return "SelfIntersect"; } return IfcCurve::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcOffsetCurve2D (IfcAbstractEntity* e);
    IfcOffsetCurve2D (IfcCurve* v1_BasisCurve, double v2_Distance, bool v3_SelfIntersect);
    typedef IfcTemplatedEntityList< IfcOffsetCurve2D > list;
};
/// Definition from ISO/CD 10303-42:1992: An offset curve 3d is a curve at a constant distance from a basis curve in three-dimensional space. The underlying curve shall have a well-defined tangent direction at every point. In the case of a composite curve the transition code between each segment shall be cont same gradient or cont same gradient same curvature. The offset curve at any point (parameter) on the basis curve is in the direction V x T where V is the fixed reference direction and T is the unit tangent to the basis curve. For the offset direction to be well defined, T shall not at any point of the curve be in the same, or opposite, direction as V. 
/// 
/// NOTE: The offset curve 3d may differ in nature from the basis curve; the offset of a non self- intersecting curve can be self-intersecting. Care should be taken to ensure that the offset to a continuous curve does not become discontinuous.
/// 
/// The offset curve 3d takes its parameterization from the basis curve. The offset curve 3d is parameterized as  
/// 
/// where T is the unit tangent vector to the basis curve C(u) at parameter value u, and d is distance. The underlying curve shall be three-dimensional.
/// 
/// NOTE Corresponding ISO 10303 entity: offset_curve_3d, Please refer to ISO/IS 10303-42:1994, p.66 for the final definition of the formal standard.
/// 
/// HISTORY New entity in IFC Release 2.x
/// 
/// Informal propositions: 
/// 
/// At no point on the curve shall ref direction be parallel, or opposite to, the direction of the tangent vector.
class IfcOffsetCurve3D : public IfcCurve {
public:
    /// The curve that is being offset.
    IfcCurve* BasisCurve() const;
    void setBasisCurve(IfcCurve* v);
    /// The distance of the offset curve from the basis curve. The distance may be positive, negative or zero.
    double Distance() const;
    void setDistance(double v);
    /// An indication of whether the offset curve self-intersects, this is for information only.
    bool SelfIntersect() const;
    void setSelfIntersect(bool v);
    /// The direction used to define the direction of the offset curve 3d from the basis curve.
    IfcDirection* RefDirection() const;
    void setRefDirection(IfcDirection* v);
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_DOUBLE; case 2: return IfcUtil::Argument_BOOL; case 3: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcCurve::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcCurve; case 1: return Type::IfcLengthMeasure; case 2: return Type::UNDEFINED; case 3: return Type::IfcDirection; } return IfcCurve::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "BasisCurve"; case 1: return "Distance"; case 2: return "SelfIntersect"; case 3: return "RefDirection"; } return IfcCurve::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcOffsetCurve3D (IfcAbstractEntity* e);
    IfcOffsetCurve3D (IfcCurve* v1_BasisCurve, double v2_Distance, bool v3_SelfIntersect, IfcDirection* v4_RefDirection);
    typedef IfcTemplatedEntityList< IfcOffsetCurve3D > list;
};
/// This entity is a description of a panel within a
/// door or window (as fillers for opening) which allows for air
/// flow. It is given by its properties
/// (IfcPermeableCoveringProperties). A permeable covering is
/// a casement, such as a component, fixed or opening, consisting
/// essentially of a frame and the infilling. The infilling is
/// normally a grill, a louver or a screen. The way of operation is
/// defined in the operation type.
/// The IfcPermeableCoveringProperties are included in the
/// list of properties (HasPropertySets) of the
/// IfcWindowStyle or the IfcDoorStyle. More
/// information about the permeable covering can be included in the
/// same list of the window or door style using the
/// IfcPropertySet for dynamic extensions. This particularly
/// applies for additional properties for the various operation
/// types
/// 
/// HISTORY New entity in IFC Release 2.0, it had been renamed from
/// IfcPermeableCovering in IFC Release 2x.
/// 
/// IFC2x4 CHANGE Supertype changed to new IfcPreDefinedPropertySet.
/// 
/// Geometry use definitions
/// The IfcPermeableCoveringProperties does not hold a geometric representation. However it defines parameters which can be used to create the shape of the IfcWindowStyle (which is inserted by the IfcWindow into the spatial context of the project), or of the IfcDoorStyle (which is inserted by the IfcDoor).
/// The parameters at the IfcPermeableCoveringProperties define a standard permeable covering. The outer boundary of the panel is determined by the occurrence parameter assigned to the
/// IfcWindow or IfcDoor. It has to take the lining parameter into account as well. The position of the permeable covering within the overall window or door is determined by the
/// PanelPosition attribute.
/// 
/// As shown in Figure 174, the panel is applied to the position within the lining, as defined by the panel position attribute. The following parameters apply to that panel: FrameDepth, FrameThickness.
/// 
/// Figure 174 — Permeable covering properties
class IfcPermeableCoveringProperties : public IfcPropertySetDefinition {
public:
    /// Types of permeable covering operations. Also used to assign standard symbolic presentations according to national building standards.
    IfcPermeableCoveringOperationEnum::IfcPermeableCoveringOperationEnum OperationType() const;
    void setOperationType(IfcPermeableCoveringOperationEnum::IfcPermeableCoveringOperationEnum v);
    /// Position of this permeable covering panel within the overall window or door type.
    IfcWindowPanelPositionEnum::IfcWindowPanelPositionEnum PanelPosition() const;
    void setPanelPosition(IfcWindowPanelPositionEnum::IfcWindowPanelPositionEnum v);
    /// Whether the optional attribute FrameDepth is defined for this IfcPermeableCoveringProperties
    bool hasFrameDepth() const;
    /// Depth of panel frame (used to include the permeable covering), measured from front face to back face horizontally (i.e. perpendicular to the window or door (elevation) plane.
    double FrameDepth() const;
    void setFrameDepth(double v);
    /// Whether the optional attribute FrameThickness is defined for this IfcPermeableCoveringProperties
    bool hasFrameThickness() const;
    /// Width of panel frame (used to include the permeable covering), measured from inside of panel (at permeable covering) to outside of panel (at lining), i.e. parallel to the window or door (elevation) plane.
    double FrameThickness() const;
    void setFrameThickness(double v);
    /// Whether the optional attribute ShapeAspectStyle is defined for this IfcPermeableCoveringProperties
    bool hasShapeAspectStyle() const;
    /// Optional link to a shape aspect definition, which points to the part of the geometric representation of the window style, which is used to represent the permeable covering.
    IfcShapeAspect* ShapeAspectStyle() const;
    void setShapeAspectStyle(IfcShapeAspect* v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 4: return IfcUtil::Argument_ENUMERATION; case 5: return IfcUtil::Argument_ENUMERATION; case 6: return IfcUtil::Argument_DOUBLE; case 7: return IfcUtil::Argument_DOUBLE; case 8: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcPropertySetDefinition::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 4: return Type::IfcPermeableCoveringOperationEnum; case 5: return Type::IfcWindowPanelPositionEnum; case 6: return Type::IfcPositiveLengthMeasure; case 7: return Type::IfcPositiveLengthMeasure; case 8: return Type::IfcShapeAspect; } return IfcPropertySetDefinition::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 4: return "OperationType"; case 5: return "PanelPosition"; case 6: return "FrameDepth"; case 7: return "FrameThickness"; case 8: return "ShapeAspectStyle"; } return IfcPropertySetDefinition::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPermeableCoveringProperties (IfcAbstractEntity* e);
    IfcPermeableCoveringProperties (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcPermeableCoveringOperationEnum::IfcPermeableCoveringOperationEnum v5_OperationType, IfcWindowPanelPositionEnum::IfcWindowPanelPositionEnum v6_PanelPosition, boost::optional< double > v7_FrameDepth, boost::optional< double > v8_FrameThickness, IfcShapeAspect* v9_ShapeAspectStyle);
    typedef IfcTemplatedEntityList< IfcPermeableCoveringProperties > list;
};
/// Definition from ISO/CD 10303-46:1992: A planar box specifies an arbitrary rectangular box and its location in a two dimensional Cartesian coordinate system.
/// 
/// NOTE  Corresponding ISO 10303 name: planar_box. Please refer to
/// ISO/IS 10303-46:1994, p. 141 for the final definition of the formal standard.
/// 
/// HISTORY  New entity in IFC2x2.
class IfcPlanarBox : public IfcPlanarExtent {
public:
    /// The IfcAxis2Placement positions a local coordinate system for the definition of the rectangle. The origin of this local coordinate system serves as the lower left corner of the rectangular box.
    ///   NOTE  In case of a 3D placement by IfcAxisPlacement3D the IfcPlanarBox is defined within the xy plane of the definition coordinate system.
    IfcAxis2Placement* Placement() const;
    void setPlacement(IfcAxis2Placement* v);
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 2: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcPlanarExtent::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 2: return Type::IfcAxis2Placement; } return IfcPlanarExtent::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 2: return "Placement"; } return IfcPlanarExtent::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPlanarBox (IfcAbstractEntity* e);
    IfcPlanarBox (double v1_SizeInX, double v2_SizeInY, IfcAxis2Placement* v3_Placement);
    typedef IfcTemplatedEntityList< IfcPlanarBox > list;
};
/// Definition from ISO/CD 10303-42:1992: A plane is an unbounded surface with a constant normal. A plane is defined by a point on the plane and the normal direction to the plane. The data is to be interpreted as follows:
/// 
/// C = Position.Location
/// x = Position.P[1]
/// y = Position.P[2]
/// z = Position.P[3] => normal to plane
/// 
/// and the surface is parameterized as:
/// 
/// where the parametric range is -∞ < u,v <
/// ∞. In the above parameterization the length unit for the
/// unit vectors x and y is derived from the context of
/// the plane.
/// 
/// The planar surface is an unbounded surface in the direction of x and y. Bounded planar surfaces are defined by using a subtype of IfcBoundedSurface with BasisSurface being a plane.
/// 
/// NOTE A rectangular bounded planar surface can
/// be defined by an IfcRectangularTrimmedSurface with
/// BasisSurface being the plane and U1 = left bound in
/// x, U2 = right bound in x, V1 = lower
/// bound in y, V2 = upper bound in y if viewed
/// into the direction of the negative normal. (assuming the
/// Usense and Vsense agree to the sense of the basis
/// surface).
/// The inherited attributes are interpreted as
/// 
/// SELF\IfcElementarySurface.Position defines the
/// location and orientation of the planar surface.
/// SELF\IfcElementarySurface.Position.Location defines a
/// point on the planar surface.
/// SELF\IfcElementarySurface.Position.P[3] defines the
/// normal of the planar surface.
/// 
/// NOTE Corresponding ISO 10303 entity: plane. Please refer to ISO/IS 10303-42:1994, p.69 for the final definition of the formal standard.
/// 
/// HISTORY New class in IFC Release 1.5
class IfcPlane : public IfcElementarySurface {
public:
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcElementarySurface::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcElementarySurface::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcElementarySurface::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPlane (IfcAbstractEntity* e);
    IfcPlane (IfcAxis2Placement3D* v1_Position);
    typedef IfcTemplatedEntityList< IfcPlane > list;
};
/// Definition from ISO9000: A process is a set of
/// activities that are interrelated or that interact with one
/// another. Processes use resources to transform inputs into
/// outputs. Processes are interconnected because the output from one
/// process becomes the input for another process. In effect,
/// processes are "glued" together by means of such input output
/// relationships.
/// 
/// IfcProcess is defined as
/// one individual activity or event, that is ordered in time, that
/// has sequence relationships with other processes, which transforms
/// input in output, and may connect to other other processes through
/// input output relationships. An IfcProcess can be an
/// activity (or task), or an event. It takes usually place in
/// building construction with the intent of designing, costing,
/// acquiring, constructing, or maintaining products or other and
/// similar tasks or procedures.
/// 
/// Figure 2 — Process relationships and the ICON process diagram.
/// 
/// HISTORY New entity in IFC Release 1.0.
/// 
/// IFC2x PLATFORM CHANGE The attribute Productivity has been removed.
/// 
/// IFC2x4 CHANGE The attribute Identification has been promoted from subtypes IfcTask and others.
/// 
/// Relationship use definition
/// Process information relates to other objects by establishing the following relationships:
/// 
/// Nesting of processes : IfcRelNests - A process can contain sub processes and thereby be nested.
/// Sequencing of processes : IfcRelSequence - Processes can be placed in sequence (including overlapping for parallel tasks), and have predecessors and successors.
/// Assigning process to schedules : IfcRelAssignsToControl - Activities such as tasks, and predominately summary tasks, are assigned to a work schedule.
/// Having a product assigned to the process as input :
/// IfcRelAssignsToProcess - Products can be assigned as input to a process, such as for construction process planning.
/// Having a product assigned to the process as output :
/// IfcRelAssignsToProduct - Products can be assigned as output to a process, such as for construction process planning.
/// Having a control assigned to the process as process control : IfcRelAssignsToProcess - Items that act as a
/// control onto the process can be assigned to a process, such as for cost management (a cost item assigned to a work task).
/// Having a resource assigned to the process as consumed by the process : IfcRelAssignsToProcess - Items that act
/// as a mechanism to a process, such as labor, material and equipment in cost calculations.
class IfcProcess : public IfcObject {
public:
    virtual unsigned int getArgumentCount() const { return 5; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcObject::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcObject::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcObject::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcRelAssignsToProcess >::ptr OperatesOn() const; // INVERSE IfcRelAssignsToProcess::RelatingProcess
    IfcTemplatedEntityList< IfcRelSequence >::ptr IsSuccessorFrom() const; // INVERSE IfcRelSequence::RelatedProcess
    IfcTemplatedEntityList< IfcRelSequence >::ptr IsPredecessorTo() const; // INVERSE IfcRelSequence::RelatingProcess
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcProcess (IfcAbstractEntity* e);
    IfcProcess (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType);
    typedef IfcTemplatedEntityList< IfcProcess > list;
};
/// Any object that relates to a
/// geometric or spatial context. Subtypes of IfcProduct
/// usually hold a shape representation and a object placement within
/// the project structure.
/// This includes manufactured, supplied or created objects
/// (referred to as elements) for incorporation into an AEC/FM
/// project. This also includes objects that are created indirectly
/// by other products, as spaces are defined by bounding elements.
/// Products can be designated for permanent use or temporary use, an
/// example for the latter is formwork. Products are defined by their
/// properties and representations.
/// In addition to physical products (covered by the subtype
/// IfcElement) and spatial items (covered by the subtype
/// IfcSpatialElement) the IfcProduct also includes
/// non-physical items, that relate to a geometric or spatial
/// contexts, such as grid, port, annotation, structural actions,
/// etc.
/// The inherited ObjectType attribute can be used to
/// designate a particular type of the product instance. If subtypes
/// of IfcProduct have a PredefinedType defined, the
/// ObjectType is used to provide the user defined, particular
/// type of the product instance, if the PredefinedType is set
/// to USERDEFINED.
/// 
/// HISTORY New Entity in IFC Release 1.0
/// 
/// Relationship use definition
/// On a generic level products can be assigned to processes,
/// controls, resources, project by using the relationship objects
/// that refer to the corresponding object:
/// 
/// Having a control applied: assigned using
/// IfcRelAssignsToControl linking the IfcProduct to an
/// IfcControl
/// 
/// An example of this
/// relationship is the assignment of a performance history to a
/// distribution element.
/// 
/// Being assigned to a process: assigned using
/// IfcRelAssignsToProcess linking the IfcProduct to an
/// IfcProcess
/// 
/// An example of this
/// relationship is the assignment of products like wall, slab,
/// column to a contruction task for construction
/// planning.
/// 
/// Being assigned to a resource: assigned using
/// IfcRelAssignsToResource linking the IfcProduct to
/// an IfcResource
/// 
/// An example of this
/// relationship is the assignment of products to a construction
/// resource that consumes the product.
/// 
/// Type use definition
/// Any instance of IfcProduct defines a particular
/// occurrence of a product, the common type information, that
/// relates to many similar (or identical) occurrences of
/// IfcProduct, is handled by the IfcTypeProduct (and
/// its subtypes), assigned to one or many occurrences of
/// IfcProduct by using the objectified relationship
/// IfcRelDefinesByType. The IfcTypeProduct may
/// provide, in addition to common properties, also a common
/// geometric representation for all occurrences.
/// See IfcTypeProduct for how to use a
/// common geometric representation and IfcRelDefinesByType
/// for using and overriding common properties.
/// 
/// Representation use definition
/// An IfcProduct occurs at a specific location in space if
/// it has a geometric representation assigned. It can be placed
/// relatively to other products, but ultimately relative to the
/// world coordinate system defined for this project. The
/// ObjectPlacement attribute establishes the coordinate
/// system in which all points and directions used by the geometric
/// representation items under Representation are
/// founded. The placement can either be:
/// 
/// a relative placement: by IfcLocalPlacement with
/// PlacementRelTo pointing to a parent placement
/// an absolute placement: by IfcLocalPlacement
/// with PlacementRelTo being NIL
/// a placement relative to a grid: by
/// IfcGridPlacement
/// 
/// The Representation is provided by an
/// IfcProductDefinitionShape being either a geometric shape
/// representation, or a topology representation (with or without
/// underlying geometry of the topological items).
class IfcProduct : public IfcObject {
public:
    /// Whether the optional attribute ObjectPlacement is defined for this IfcProduct
    bool hasObjectPlacement() const;
    /// Placement of the product in space, the placement can either be absolute (relative to the world coordinate system), relative (relative to the object placement of another product), or constraint (e.g. relative to grid axes). It is determined by the various subtypes of IfcObjectPlacement, which includes the axis placement information to determine the  transformation for the object coordinate system.
    IfcObjectPlacement* ObjectPlacement() const;
    void setObjectPlacement(IfcObjectPlacement* v);
    /// Whether the optional attribute Representation is defined for this IfcProduct
    bool hasRepresentation() const;
    /// Reference to the representations of the product, being either a representation (IfcProductRepresentation) or as a special case a shape representations (IfcProductDefinitionShape). The product definition shape provides for multiple geometric representations of the shape property of the object within the same object coordinate system, defined by the object placement.
    IfcProductRepresentation* Representation() const;
    void setRepresentation(IfcProductRepresentation* v);
    virtual unsigned int getArgumentCount() const { return 7; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 5: return IfcUtil::Argument_ENTITY_INSTANCE; case 6: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcObject::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 5: return Type::IfcObjectPlacement; case 6: return Type::IfcProductRepresentation; } return IfcObject::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 5: return "ObjectPlacement"; case 6: return "Representation"; } return IfcObject::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcRelAssignsToProduct >::ptr ReferencedBy() const; // INVERSE IfcRelAssignsToProduct::RelatingProduct
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcProduct (IfcAbstractEntity* e);
    IfcProduct (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation);
    typedef IfcTemplatedEntityList< IfcProduct > list;
};
/// IfcProject indicates the undertaking of some design, engineering, construction, or
/// maintenance activities leading towards a product. The project establishes the context for information to be exchanged or shared, and it may represent a construction project but does not have to.  The IfcProject's main purpose in an exchange structure is to provide the root instance and the context for all other information items included.
/// The context provided by the IfcProject includes:
/// 
/// the default units
/// the geometric representation context for exchange structures including shape representations
/// 
/// the world coordinate system
/// the coordinate space dimension
/// the precision used within the geometric representations, and
/// optionally the indication of the true north relative to the world coordinate system
/// 
/// HISTORY  New Entity in IFC Release 1.0
/// 
/// IFC2x4 CHANGE  The attributes RepresentationContexts and UnitsInContext are made optional and are promoted to supertype IfcContext.
/// 
/// Relationship use definition
/// The IfcProject is used to reference the root of the spatial structure of a building (that serves as the primary project breakdown and is required to be hierarchical). The spatial structure elements are linked together, and to the IfcProject, by using the objectified relationship IfcRelAggregates. The IfcProject references them by its inverse relationship:
/// 
/// IfcProject.Decomposes -- it shall be NIL, i.e. the
/// IfcProject shall not be decomposed into any parts.
/// IfcProject.IsDecomposedBy -- referencing
/// (IfcSite || IfcBuilding) by
/// IfcRelAggregates.RelatingObject. The IfcSite or
/// IfcBuilding referenced shall be the root of the spatial
/// structure.
/// 
/// The IfcProject is also the context for other information about the construction project such as a work plan. Non-product structures are assigned by their first level object to IfcProject using the IfcRelDeclares relationship.
/// 
/// The IfcProject provides the context for spatial elements and the associated products, and for work plans (or other non-product based) descriptions of the construction project. It is handled by two distinct relationship objects as shown in Figure 3.
/// NOTE   The spatial structure and the schedule structure can be decomposed. For example the IfcBuilding can be decomposed into IfcBuildingStorey's, and the IfcWorkPlan can be decomposed into IfcWorkSchedule's.
/// NOTE   The products and tasks can be decomposed further. For example the IfcCurtainWall can be decomposed into IfcMember and IfcPlate, the IfcTask can be decomposed into other IfcTask's.
/// NOTE   The products and tasks can have direct linking relationships. For example the IfcCurtainWall can be assigned to a IfcTask as an input or output for a construction schedule.
/// NOTE   The anomaly to use the composition structure through IfcRelAggregates for assigning the uppermost spatial container to IfcProject is due to upward compatibility reasons with earlier releases of this standard.
/// 
/// Figure 3 — Project spatial and work plan structure
/// 
/// As shown in Figure 4, the IfcProject provides the context for project libraries that in return provide a context to the library items assigned to it. Product types are an example for items that can be included in a project library.
/// 
/// Figure 4 — Project spatial structure, products and product type library
/// 
/// Informal propositions:
/// 
/// There shall only be one project within the exchange context. This is enforced by the global rule IfcSingleProjectInstance.
class IfcProject : public IfcObject {
public:
    /// Whether the optional attribute LongName is defined for this IfcProject
    bool hasLongName() const;
    std::string LongName() const;
    void setLongName(std::string v);
    /// Whether the optional attribute Phase is defined for this IfcProject
    bool hasPhase() const;
    std::string Phase() const;
    void setPhase(std::string v);
    IfcTemplatedEntityList< IfcRepresentationContext >::ptr RepresentationContexts() const;
    void setRepresentationContexts(IfcTemplatedEntityList< IfcRepresentationContext >::ptr v);
    IfcUnitAssignment* UnitsInContext() const;
    void setUnitsInContext(IfcUnitAssignment* v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 5: return IfcUtil::Argument_STRING; case 6: return IfcUtil::Argument_STRING; case 7: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 8: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcObject::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 5: return Type::IfcLabel; case 6: return Type::IfcLabel; case 7: return Type::IfcRepresentationContext; case 8: return Type::IfcUnitAssignment; } return IfcObject::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 5: return "LongName"; case 6: return "Phase"; case 7: return "RepresentationContexts"; case 8: return "UnitsInContext"; } return IfcObject::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcProject (IfcAbstractEntity* e);
    IfcProject (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, boost::optional< std::string > v6_LongName, boost::optional< std::string > v7_Phase, IfcTemplatedEntityList< IfcRepresentationContext >::ptr v8_RepresentationContexts, IfcUnitAssignment* v9_UnitsInContext);
    typedef IfcTemplatedEntityList< IfcProject > list;
};

class IfcProjectionCurve : public IfcAnnotationCurveOccurrence {
public:
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcAnnotationCurveOccurrence::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcAnnotationCurveOccurrence::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcAnnotationCurveOccurrence::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcProjectionCurve (IfcAbstractEntity* e);
    IfcProjectionCurve (IfcRepresentationItem* v1_Item, IfcTemplatedEntityList< IfcPresentationStyleAssignment >::ptr v2_Styles, boost::optional< std::string > v3_Name);
    typedef IfcTemplatedEntityList< IfcProjectionCurve > list;
};
/// IfcPropertySet defines all dynamically extensible
/// properties. The property set is a container class that holds
/// properties within a property tree. These properties are interpreted
/// according to their name attribute.
/// The same IfcPropertySet can be assignd to multiple
/// object occurrences, it should then be assigned by a single instance
/// of IfcRelDefinedByProperties to a set of related objects.
/// Those property sets are referred to as shared property sets. It can
/// also be assigned to an object type.
/// The underlying structure, i.e. the required name, the applicable
/// object or object types to which the property set can be attached
/// and the individual properties that maybe included can be assigned
/// using the property set template.
/// 
/// NOTE  See IfcRelDefinesByType for how to override property sets assigned to an object type within the object occurrence.
/// 
/// HISTORY  New Entity in IFC Release 1.0
/// 
/// IFC2x4 CHANGE  All statically defined property set entities are no longer subtypes of
/// IfcPropertySet.
/// 
/// Relationship use definition
/// Property sets are related to other objects by using the
/// relationship object that refers to the corresponding object:
/// 
/// Occurrence Object: IfcRelDefinesByProperties
/// using the inverse attribute DefinesOccurrence.
/// Type Object: using a direct link by inverse attribute
/// DefinesType.
/// External reference: subtypes of
/// IfcRelAssociates are used to provide a link to a
/// classification system, or external library providing further
/// reference to the property set. Accessible by inverse attribute
/// HasAssociations.
/// Underlying template: IfcRelDefinesByTemplate
/// using the inverse attribute IsDefinedBy.
/// 
/// Attribute use definition
/// Instances of IfcPropertySet are used to assign named
/// sets of individual properties (complex or single properties). Each
/// individual property has a significant name string. Some property
/// sets are included in the IFC specification and have a
/// predefined set of properties indicated by assigning a significant
/// name. These property sets are listed under "property sets" main
/// menu item within this specification and from the object
/// documentation sheet for those object to which they are applicable.
/// The naming convention "Pset_Xxx" applies to all those property sets
/// that are defined as part of the IFC specification and it shall be
/// used as the value of the Name attribute.
/// In addition any user defined property set can be captured.
/// Property sets that are not declared as part of the IFC
/// specification shall have a Name value not including the
/// "Pset_" prefix.
class IfcPropertySet : public IfcPropertySetDefinition {
public:
    /// Contained set of properties. For property sets defined as part of the IFC Object model, the property objects within a property set are defined as part of the standard. If a property is not contained within the set of predefined properties, its value has not been set at this time.
    IfcTemplatedEntityList< IfcProperty >::ptr HasProperties() const;
    void setHasProperties(IfcTemplatedEntityList< IfcProperty >::ptr v);
    virtual unsigned int getArgumentCount() const { return 5; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 4: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } return IfcPropertySetDefinition::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 4: return Type::IfcProperty; } return IfcPropertySetDefinition::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 4: return "HasProperties"; } return IfcPropertySetDefinition::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPropertySet (IfcAbstractEntity* e);
    IfcPropertySet (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcTemplatedEntityList< IfcProperty >::ptr v5_HasProperties);
    typedef IfcTemplatedEntityList< IfcPropertySet > list;
};
/// IfcProxy is intended to be a kind of a container for wrapping objects which are defined by associated properties, which may or may not have a geometric representation and placement in space. A proxy may have a semantic meaning, defined by the Name attribute, and property definitions, attached through the property assignment relationship, which definition may be outside of the definitions given by the current release of IFC.
/// 
/// The ProxyType may give an indication to which high level semantic breakdown of object the semantic definition of the proxy relates to. the Tag attribute may be used to assign a human or system interpretable identifier (such as a serial number or bar code).
/// 
/// NOTE 1  Given that only a
/// limited number of semantic constructs can be formally defined within
/// IFC (and it will never be possible to define all), there has to be a
/// mechanism for capturing those constructs that are not (yet) defined by
/// IFC. 
/// 
/// NOTE 2  Product proxies are a
/// mechanism that allows to exchange data that is part of the project but
/// not necessarily part of the IFC model. Those proxies may have geometric
/// representations assigned.
/// 
/// HISTORY  New entity in IFC Release 1.5.
class IfcProxy : public IfcProduct {
public:
    /// High level (and only) semantic meaning attached to the IfcProxy, defining the basic construct type behind the Proxy, e.g. Product or Process.
    IfcObjectTypeEnum::IfcObjectTypeEnum ProxyType() const;
    void setProxyType(IfcObjectTypeEnum::IfcObjectTypeEnum v);
    /// Whether the optional attribute Tag is defined for this IfcProxy
    bool hasTag() const;
    /// The tag (or label) identifier at the particular instance of a product, e.g. the serial number, or the position number. It is the identifier at the occurrence level.
    std::string Tag() const;
    void setTag(std::string v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 7: return IfcUtil::Argument_ENUMERATION; case 8: return IfcUtil::Argument_STRING; } return IfcProduct::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 7: return Type::IfcObjectTypeEnum; case 8: return Type::IfcLabel; } return IfcProduct::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 7: return "ProxyType"; case 8: return "Tag"; } return IfcProduct::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcProxy (IfcAbstractEntity* e);
    IfcProxy (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, IfcObjectTypeEnum::IfcObjectTypeEnum v8_ProxyType, boost::optional< std::string > v9_Tag);
    typedef IfcTemplatedEntityList< IfcProxy > list;
};
/// IfcRectangleHollowProfileDef defines a section profile that provides the defining parameters of a rectangular (or square) hollow section to be used by the swept surface geometry or the swept area solid. Its parameters and orientation relative to the position coordinate system are according to the following illustration. A square hollow section can be defined by equal values for h and b. The centre of the position coordinate system is in the profiles centre of the bounding box (for symmetric profiles identical with the centre of gravity). Normally, the longer sides are parallel to the y-axis, the shorter sides parallel to the x-axis.
/// 
/// HISTORY  New entity in IFC2x2.
/// 
/// IFC2x4 CHANGE  Types of InnerFilletRadius and OuterFilletRadius relaxed to allow for zero values.
/// 
/// Figure 322 illustrates parameters of a rectangular or square hollow profile definition.
/// 
/// Position
/// The parameterized profile defines its own position coordinate system.
/// The underlying coordinate system is defined by the swept area solid
/// that uses the profile definition. It is the xy plane of:
/// 
/// IfcSweptAreaSolid.Position
/// 
/// by using offsets of the position location, the parameterized profile
/// can be positioned centric (using x,y offsets = 0.), or at any position
/// relative to the profile.
/// 
/// Figure 322 — Rectangle hollow profile
class IfcRectangleHollowProfileDef : public IfcRectangleProfileDef {
public:
    /// Thickness of the material.
    double WallThickness() const;
    void setWallThickness(double v);
    /// Whether the optional attribute InnerFilletRadius is defined for this IfcRectangleHollowProfileDef
    bool hasInnerFilletRadius() const;
    /// Inner corner radius.
    double InnerFilletRadius() const;
    void setInnerFilletRadius(double v);
    /// Whether the optional attribute OuterFilletRadius is defined for this IfcRectangleHollowProfileDef
    bool hasOuterFilletRadius() const;
    /// Outer corner radius.
    double OuterFilletRadius() const;
    void setOuterFilletRadius(double v);
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 5: return IfcUtil::Argument_DOUBLE; case 6: return IfcUtil::Argument_DOUBLE; case 7: return IfcUtil::Argument_DOUBLE; } return IfcRectangleProfileDef::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 5: return Type::IfcPositiveLengthMeasure; case 6: return Type::IfcPositiveLengthMeasure; case 7: return Type::IfcPositiveLengthMeasure; } return IfcRectangleProfileDef::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 5: return "WallThickness"; case 6: return "InnerFilletRadius"; case 7: return "OuterFilletRadius"; } return IfcRectangleProfileDef::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRectangleHollowProfileDef (IfcAbstractEntity* e);
    IfcRectangleHollowProfileDef (IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< std::string > v2_ProfileName, IfcAxis2Placement2D* v3_Position, double v4_XDim, double v5_YDim, double v6_WallThickness, boost::optional< double > v7_InnerFilletRadius, boost::optional< double > v8_OuterFilletRadius);
    typedef IfcTemplatedEntityList< IfcRectangleHollowProfileDef > list;
};
/// The IfcRectangularPyramid is a Construction Solid
/// Geometry (CSG) 3D primitive. It is a solid with a rectangular base and
/// a point called apex as the top. The tapers from the base to the
/// top. The axis from the center of the base to the apex is
/// perpendicular to the base. The inherited Position
/// attribute defines the IfcAxisPlacement3D and provides the
/// location and orientation of the pyramid:
/// 
/// SELF\IfcCsgPrimitive3D.Position: The location and
/// orientation of the axis system for the primitive. 
/// SELF\IfcCsgPrimitive3D.Position.Location: The center
/// of the circular area being the bottom face of the cone.
/// SELF\IfcCsgPrimitive3D.Position.Position[3]: The
/// z-axis of the inherited placement coordinate system provides the
/// center axis of the IfcRightCircularCone, and the apex is
/// at the Height value applied to the positive direction of
/// the z-axis. The BottomRadius defines the circular base at
/// the xy-plane of the placement coordinate system.
/// 
/// As shown in Figure 260, the pyramid is positioned within its own placement coordinate system. The origin is the center of the bottom rectangle, that lies in the XY plane. The apex lies on the positive z axis at [0, 0, Height].
/// 
/// Figure 260 — Rectangular pyramid geometry
/// 
/// NOTE  Corresponding ISO 10303 entity: right_circular_cone, the position attribute has been promoted to the immediate supertype IfcCsgPrimitive3D. No semi_angle attribute, and the radius defines the bottom radius, since only a non-truncated cone is in scope. Please refer to ISO/IS 10303-42:1994, p. 176 for the final definition of the formal standard.
/// 
/// HISTORY  New entity in IFC2x3
/// 
/// Texture use definition
/// 
/// On each triangular side face, textures are aligned facing upright. 
/// Textures are stretched or repeated to the extent of the base of each face according to RepeatS. 
/// Textures are stretched or repeated towards the top point according to Repeat T, 
/// where the top point has coordinates of (0.5,1.0) if RepeatT is False. 
/// 
/// On the bottom face, textures are aligned facing front-to-back.
/// 
/// Figure 261 illustrates default texture mapping with a clamped texture (RepeatS=False and RepeatT=False). The image on the left shows the texture where the S axis points to the right and the T axis points up. The image on the right shows the texture applied to the geometry where the X axis points back to the right, the Y axis
/// points back to the left, and the Z axis points up.
/// 
/// Side
/// Normal
/// Origin X
/// Origin Y
/// Origin Z
/// S Axis
/// T Axis
/// 
/// Left
/// -X
/// 0
/// +YLength
/// 0
/// -Y
/// (towards top point)
/// 
/// Right
/// +X
/// 0
/// +YLength
/// 0
/// +Y
/// (towards top point)
/// 
/// Front
/// +X
/// 0
/// 0
/// 0
/// +X
/// (towards top point)
/// 
/// Back
/// +Y
/// +XLength
/// +YLength
/// 0
/// -X
/// (towards top point)
/// 
/// Bottom
/// -Z
/// +XLength
/// 0
/// 0
/// -X
/// +Y
/// 
/// Figure 261 — Right circular cone textures
class IfcRectangularPyramid : public IfcCsgPrimitive3D {
public:
    /// The length of the base measured along the placement X axis. It is provided by the inherited axis placement through SELF\IfcCsgPrimitive3D.Position.P[1].
    double XLength() const;
    void setXLength(double v);
    /// The length of the base measured along the placement Y axis. It is provided by the inherited axis placement through SELF\IfcCsgPrimitive3D.Position.P[2].
    double YLength() const;
    void setYLength(double v);
    /// The height of the apex above the plane of the base, measured in the direction of the placement Z axis, the SELF\IfcCsgPrimitive3D.Position.P[2].
    double Height() const;
    void setHeight(double v);
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 1: return IfcUtil::Argument_DOUBLE; case 2: return IfcUtil::Argument_DOUBLE; case 3: return IfcUtil::Argument_DOUBLE; } return IfcCsgPrimitive3D::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 1: return Type::IfcPositiveLengthMeasure; case 2: return Type::IfcPositiveLengthMeasure; case 3: return Type::IfcPositiveLengthMeasure; } return IfcCsgPrimitive3D::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 1: return "XLength"; case 2: return "YLength"; case 3: return "Height"; } return IfcCsgPrimitive3D::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRectangularPyramid (IfcAbstractEntity* e);
    IfcRectangularPyramid (IfcAxis2Placement3D* v1_Position, double v2_XLength, double v3_YLength, double v4_Height);
    typedef IfcTemplatedEntityList< IfcRectangularPyramid > list;
};
/// Definition from ISO/CD 10303-42:1992: The trimmed surface is a simple bounded surface in which the boundaries are the constant parametric lines u1 = u1, u2 = u2, v1 = v1 and v2 = v2. All these values shall be within the parametric range of the referenced surface. Cyclic properties of the parameter range are assumed.
/// 
/// NOTE 1 For example, 370 degrees is equivalent to 10 degrees, for those surfaces whose parametric form is defined using circular functions (sine and cosine).
/// 
/// The rectangular trimmed surface inherits its parameterization directly from the basis surface and has parameter ranges from 0 to |u2 - u1| and 0 to|v2-v1|.
/// 
/// NOTE 2 If the surface is closed in a given parametric direction, the values of u2 or v2 may require to be increased by the cyclic range.
/// 
/// NOTE Corresponding ISO 10303 name: rectangular_trimmed_surface. Please refer to ISO/IS 10303-42:1994, p.86 for the final definition of the formal standard.
/// 
/// HISTORY New class in IFC Release 2x.
/// 
/// Informal propositions: 
/// 
/// The domain of the trimmed surface shall be within the domain of the surface being trimmed.
class IfcRectangularTrimmedSurface : public IfcBoundedSurface {
public:
    /// Surface being trimmed.
    IfcSurface* BasisSurface() const;
    void setBasisSurface(IfcSurface* v);
    /// First u parametric value.
    double U1() const;
    void setU1(double v);
    /// First v parametric value.
    double V1() const;
    void setV1(double v);
    /// Second u parametric value.
    double U2() const;
    void setU2(double v);
    /// Second v parametric value.
    double V2() const;
    void setV2(double v);
    /// Flag to indicate whether the direction of the first parameter of the trimmed surface agrees with or opposes the sense of u in the basis surface.
    bool Usense() const;
    void setUsense(bool v);
    /// Flag to indicate whether the direction of the second parameter of the trimmed surface agrees with or opposes the sense of v in the basis surface.
    bool Vsense() const;
    void setVsense(bool v);
    virtual unsigned int getArgumentCount() const { return 7; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_DOUBLE; case 2: return IfcUtil::Argument_DOUBLE; case 3: return IfcUtil::Argument_DOUBLE; case 4: return IfcUtil::Argument_DOUBLE; case 5: return IfcUtil::Argument_BOOL; case 6: return IfcUtil::Argument_BOOL; } return IfcBoundedSurface::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcSurface; case 1: return Type::IfcParameterValue; case 2: return Type::IfcParameterValue; case 3: return Type::IfcParameterValue; case 4: return Type::IfcParameterValue; case 5: return Type::UNDEFINED; case 6: return Type::UNDEFINED; } return IfcBoundedSurface::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "BasisSurface"; case 1: return "U1"; case 2: return "V1"; case 3: return "U2"; case 4: return "V2"; case 5: return "Usense"; case 6: return "Vsense"; } return IfcBoundedSurface::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRectangularTrimmedSurface (IfcAbstractEntity* e);
    IfcRectangularTrimmedSurface (IfcSurface* v1_BasisSurface, double v2_U1, double v3_V1, double v4_U2, double v5_V2, bool v6_Usense, bool v7_Vsense);
    typedef IfcTemplatedEntityList< IfcRectangularTrimmedSurface > list;
};
/// The assignment relationship, IfcRelAssigns, is a generalization of "link" relationships among instances of IfcObject and its various 1st level subtypes. A link denotes the specific association through which one object (the client) applies the services of other objects (the suppliers), or through which one object may navigate to other objects.
/// 
/// The client is denoted as the relating object and is established at the level of the specific, instantiable subtypes of IfcRelAssigns. The suppliers are denoted as the related objects and they are established by the RelatedObjects attribute. 
/// 
/// NOTE: The terms "client" and "supplier" are used in a general concept and do not imply any meaning for implementations of systems (like client-server).
/// 
/// EXAMPLE: A resource may receive information about its nature of representing real building products by establishing a link between IfcResource and IfcBuildingElement (subtype of IfcProduct) through the assignment relationship IfcRelAssignsToResource. The resource is then the client that applies the services of other objects (here building elements) to express the particular view of elements to be consumed as a resource in a process.
/// 
/// The assignment relationship establishs a bi-directional relationship among the participating objects and does not imply any dependency. The subtypes of IfcRelAssigns establishes the particular semantic meaning of the assignment relationship.
/// 
/// HISTORY: New entity in IFC Release 2x.
class IfcRelAssigns : public IfcRelationship {
public:
    /// Related objects, which are assigned to a single object. The type of the single (or relating) object is defined in the subtypes of IfcRelAssigns.
    IfcTemplatedEntityList< IfcObjectDefinition >::ptr RelatedObjects() const;
    void setRelatedObjects(IfcTemplatedEntityList< IfcObjectDefinition >::ptr v);
    /// Whether the optional attribute RelatedObjectsType is defined for this IfcRelAssigns
    bool hasRelatedObjectsType() const;
    /// Particular type of the assignment relationship. It can constrain the applicable object types, used within the role of RelatedObjects.
    /// IFC2x4 CHANGE  The attribute is deprecated and shall no longer be used. A NIL value should always be assigned.
    IfcObjectTypeEnum::IfcObjectTypeEnum RelatedObjectsType() const;
    void setRelatedObjectsType(IfcObjectTypeEnum::IfcObjectTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 6; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 4: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 5: return IfcUtil::Argument_ENUMERATION; } return IfcRelationship::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 4: return Type::IfcObjectDefinition; case 5: return Type::IfcObjectTypeEnum; } return IfcRelationship::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 4: return "RelatedObjects"; case 5: return "RelatedObjectsType"; } return IfcRelationship::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRelAssigns (IfcAbstractEntity* e);
    IfcRelAssigns (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcTemplatedEntityList< IfcObjectDefinition >::ptr v5_RelatedObjects, boost::optional< IfcObjectTypeEnum::IfcObjectTypeEnum > v6_RelatedObjectsType);
    typedef IfcTemplatedEntityList< IfcRelAssigns > list;
};
/// The objectified relationship IfcRelAssignsToActor handles the assignment of objects (subtypes of IfcObject) to an actor (subtypes of IfcActor).
/// 
/// The IfcRelAssignsToActor objectified relationship defines a relationship between an IfcActor and one or many objects. A particular role of the actor played in that relationship can be associated. If specified, it takes priority over the role that may be directly assigned to the person or organization.
/// 
/// EXAMPLE: An occupant (as an actor) may rent a flat (as a collection of spaces or a zone). This would be an application of this generic relationship.
/// 
/// Reference to the objects (or single object) on which the actor acts upon in a certain role (if given) is specified in the inherited RelatedObjects attribute.  
/// 
/// HISTORY New Entity in IFC Release 2.0. Has been renamed from IfcRelActsUpon in IFC Release 2x.
class IfcRelAssignsToActor : public IfcRelAssigns {
public:
    /// Reference to the information about the actor. It comprises the information about the person or organization and its addresses.
    IfcActor* RelatingActor() const;
    void setRelatingActor(IfcActor* v);
    /// Whether the optional attribute ActingRole is defined for this IfcRelAssignsToActor
    bool hasActingRole() const;
    /// Role of the actor played within the context of the assignment to the object(s).
    IfcActorRole* ActingRole() const;
    void setActingRole(IfcActorRole* v);
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 6: return IfcUtil::Argument_ENTITY_INSTANCE; case 7: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcRelAssigns::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 6: return Type::IfcActor; case 7: return Type::IfcActorRole; } return IfcRelAssigns::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 6: return "RelatingActor"; case 7: return "ActingRole"; } return IfcRelAssigns::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRelAssignsToActor (IfcAbstractEntity* e);
    IfcRelAssignsToActor (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcTemplatedEntityList< IfcObjectDefinition >::ptr v5_RelatedObjects, boost::optional< IfcObjectTypeEnum::IfcObjectTypeEnum > v6_RelatedObjectsType, IfcActor* v7_RelatingActor, IfcActorRole* v8_ActingRole);
    typedef IfcTemplatedEntityList< IfcRelAssignsToActor > list;
};
/// The objectified relationship IfcRelAssignsToControl handles the assignment of a control (represented by subtypes of IfcControl) to other objects (represented by subtypes of IfcObject, with the exception of controls).
/// 
/// EXAMPLEÿ The assignment of a performance history (as subtype of IfcControl) for a building service element (as subtype of IfcObject) is an application of this generic relationship.
/// 
/// HISTORYÿ New Entity in IFC Release 2.0. Has been renamed from IfcRelControls in IFC Release 2x.
class IfcRelAssignsToControl : public IfcRelAssigns {
public:
    /// Reference to the IfcControl that applies a control upon objects.
    IfcControl* RelatingControl() const;
    void setRelatingControl(IfcControl* v);
    virtual unsigned int getArgumentCount() const { return 7; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 6: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcRelAssigns::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 6: return Type::IfcControl; } return IfcRelAssigns::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 6: return "RelatingControl"; } return IfcRelAssigns::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRelAssignsToControl (IfcAbstractEntity* e);
    IfcRelAssignsToControl (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcTemplatedEntityList< IfcObjectDefinition >::ptr v5_RelatedObjects, boost::optional< IfcObjectTypeEnum::IfcObjectTypeEnum > v6_RelatedObjectsType, IfcControl* v7_RelatingControl);
    typedef IfcTemplatedEntityList< IfcRelAssignsToControl > list;
};
/// The objectified relationship IfcRelAssignsToGroup handles the assignment of object definitions (individual object occurrences as subtypes of IfcObject, and object types as subtypes of IfcTypeObject) to a group (subtypes of IfcGroup).
/// 
/// The relationship handles the assignment of group members to the group object. It allows for grouping arbitrary objects within a group, including other groups. The grouping relationship can be applied in a recursive manner. The resulting group is of type IfcGroup.
/// 
/// NOTE Examples of groups include zones as a grouping of spaces, distribution systems as a grouping of building service components, or structural analysis models as a grouping of structural items.
/// 
/// The inherited attribute RelatedObjects gives the references to the objects, which are the elements within the group. The RelatingGroup is the group that comprises all elements. The same object or object type can be included in zero, one or many groups. Grouping relationships are not hierarchical.
/// 
/// Informal proposition:
/// 
/// The group assignment relationship shall be acyclic, that is, a group shall not participate in its own grouping relationship.
/// 
/// HISTORY New entity in IFC Release 1.0. It has been renamed from IfcRelGroups in IFC Release 2x.
class IfcRelAssignsToGroup : public IfcRelAssigns {
public:
    /// Reference to group that contains all assigned group members.
    IfcGroup* RelatingGroup() const;
    void setRelatingGroup(IfcGroup* v);
    virtual unsigned int getArgumentCount() const { return 7; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 6: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcRelAssigns::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 6: return Type::IfcGroup; } return IfcRelAssigns::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 6: return "RelatingGroup"; } return IfcRelAssigns::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRelAssignsToGroup (IfcAbstractEntity* e);
    IfcRelAssignsToGroup (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcTemplatedEntityList< IfcObjectDefinition >::ptr v5_RelatedObjects, boost::optional< IfcObjectTypeEnum::IfcObjectTypeEnum > v6_RelatedObjectsType, IfcGroup* v7_RelatingGroup);
    typedef IfcTemplatedEntityList< IfcRelAssignsToGroup > list;
};
/// The objectified relationship IfcRelAssignsToProcess handles the assignment of one or many objects to a process or activity. An object can be a product that is the item the process operates on. Processes and activities can operate on things other than products, and can operate in ways other than input and output.
/// 
/// EXAMPLE It may be common to define processes
/// during estimating or scheduling that describe design tasks
/// (resulting in documents), procurement tasks (resulting in
/// construction materials), planning tasks (resulting in processes),
/// etc. Furthermore, the ways in which process can operate on
/// something might include "installs", "finishes", "transports",
/// "removes", etc. The ways are described as operation
/// types.
/// The inherited attribute RelatedObjects gives the
/// references to the objects, or object type, which the process
/// operates on. The RelatingProcess is the process or process
/// type, that operates on the object. The operation types are
/// captured in the inherited attribute Name.
/// NOTE The agreement on valid and recognizable
/// values for the Name attribute is part of view definitions
/// and implementer agreements.
/// 
/// HISTORY New entity in IFC Release 1.5. Has been renamed from IfcRelProcessOperatesOn in IFC Release 2x.
/// 
/// IFC2x4 CHANGE The data type RelatingProcess has been extended to cover also IfcTypeProcess
class IfcRelAssignsToProcess : public IfcRelAssigns {
public:
    /// Reference to the process to which the objects are assigned to.
    /// 
    /// IFC2x4 CHANGE Datatype expanded to include IfcProcess and IfcTypeProcess.
    IfcProcess* RelatingProcess() const;
    void setRelatingProcess(IfcProcess* v);
    /// Whether the optional attribute QuantityInProcess is defined for this IfcRelAssignsToProcess
    bool hasQuantityInProcess() const;
    /// Quantity of the object specific for the operation by this process.
    IfcMeasureWithUnit* QuantityInProcess() const;
    void setQuantityInProcess(IfcMeasureWithUnit* v);
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 6: return IfcUtil::Argument_ENTITY_INSTANCE; case 7: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcRelAssigns::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 6: return Type::IfcProcess; case 7: return Type::IfcMeasureWithUnit; } return IfcRelAssigns::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 6: return "RelatingProcess"; case 7: return "QuantityInProcess"; } return IfcRelAssigns::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRelAssignsToProcess (IfcAbstractEntity* e);
    IfcRelAssignsToProcess (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcTemplatedEntityList< IfcObjectDefinition >::ptr v5_RelatedObjects, boost::optional< IfcObjectTypeEnum::IfcObjectTypeEnum > v6_RelatedObjectsType, IfcProcess* v7_RelatingProcess, IfcMeasureWithUnit* v8_QuantityInProcess);
    typedef IfcTemplatedEntityList< IfcRelAssignsToProcess > list;
};
/// The objectified relationshipÿIfcRelAssignsToProduct handles the assignment of objects (subtypes of IfcObject) to a product (subtypes of IfcProduct). The Name attribute should be used to classify the usage of the IfcRelAssignsToProduct objectified relationship. The following Name values are proposed:
/// 
/// 'Context' : Assignment of a context specific representation, such as of structural members to a different context representation (with potentially different decomposition breakdown) such as of building elementsÿfor a specificÿcontext specific representation.ÿ
/// 'View' : Assignment of a product (via RelatingProduct) that is decomposed according to a discipline view, to another product (via RelatedObjects) that is decomposed according to a different discipline view. An example is the assignment of the architectural slab to a different decomposition of the pre manufactured sections of a slab (under a precast concrete discipline view).
/// 
/// HISTORY New Entity in IFC Release 2x
/// 
/// IFC2x3 CHANGE ÿThe reference of a product within a spatial structure is now handled by a new relationship object IfcRelReferencedInSpatialStructure. The IfcRelAssignsToProduct shall not be used to represent this relation from IFC2x3 onwards.
class IfcRelAssignsToProduct : public IfcRelAssigns {
public:
    /// Reference to the product or product type to which the objects are assigned to.
    /// 
    /// IFC2x4 CHANGE Datatype expanded to include IfcProduct and IfcTypeProduct.
    IfcProduct* RelatingProduct() const;
    void setRelatingProduct(IfcProduct* v);
    virtual unsigned int getArgumentCount() const { return 7; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 6: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcRelAssigns::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 6: return Type::IfcProduct; } return IfcRelAssigns::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 6: return "RelatingProduct"; } return IfcRelAssigns::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRelAssignsToProduct (IfcAbstractEntity* e);
    IfcRelAssignsToProduct (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcTemplatedEntityList< IfcObjectDefinition >::ptr v5_RelatedObjects, boost::optional< IfcObjectTypeEnum::IfcObjectTypeEnum > v6_RelatedObjectsType, IfcProduct* v7_RelatingProduct);
    typedef IfcTemplatedEntityList< IfcRelAssignsToProduct > list;
};

class IfcRelAssignsToProjectOrder : public IfcRelAssignsToControl {
public:
    virtual unsigned int getArgumentCount() const { return 7; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcRelAssignsToControl::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcRelAssignsToControl::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcRelAssignsToControl::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRelAssignsToProjectOrder (IfcAbstractEntity* e);
    IfcRelAssignsToProjectOrder (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcTemplatedEntityList< IfcObjectDefinition >::ptr v5_RelatedObjects, boost::optional< IfcObjectTypeEnum::IfcObjectTypeEnum > v6_RelatedObjectsType, IfcControl* v7_RelatingControl);
    typedef IfcTemplatedEntityList< IfcRelAssignsToProjectOrder > list;
};
/// The objectified relationship IfcRelAssignsToResource handles the assignment of objects
/// (as subtypes of IfcObject), acting as a resource usage or consumption, to a resource (as subtypes of IfcResource).
/// 
/// EXAMPLE The assignment of a resource usage to a construction resource is an application of this generic relationship. It could be an actor, as person or organization assigned to a labor resource, or a raw product assigned to a construction product or material resource).
/// 
/// HISTORY New Entity in IFC Release 2x.
class IfcRelAssignsToResource : public IfcRelAssigns {
public:
    /// Reference to the resource to which the objects are assigned to.
    /// 
    /// IFC2x4 CHANGE Datatype expanded to include IfcResource and IfcTypeResource.
    IfcResource* RelatingResource() const;
    void setRelatingResource(IfcResource* v);
    virtual unsigned int getArgumentCount() const { return 7; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 6: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcRelAssigns::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 6: return Type::IfcResource; } return IfcRelAssigns::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 6: return "RelatingResource"; } return IfcRelAssigns::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRelAssignsToResource (IfcAbstractEntity* e);
    IfcRelAssignsToResource (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcTemplatedEntityList< IfcObjectDefinition >::ptr v5_RelatedObjects, boost::optional< IfcObjectTypeEnum::IfcObjectTypeEnum > v6_RelatedObjectsType, IfcResource* v7_RelatingResource);
    typedef IfcTemplatedEntityList< IfcRelAssignsToResource > list;
};
/// The association relationship
///   IfcRelAssociates refers to external sources of
///   information (most notably a classification, library or
///   document). There is no dependency implied by the
///   association.
/// 
/// EXAMPLE Further information may be given
///   to the tank equipment (as subtype of IfcProduct) in
///   terms of its classification and instruction documents, the
///   source of the additional information is held external to
///   the IFC project model.
/// 
/// Association relationships can be established to objects
///   (occurrences as subtypes of IfcObject) or to types 
///   (as subtypes of IfcTypeObject).
/// 
/// EXAMPLE 1  The classification information
///   for the storage tank equipment may be associated to the
///   IfcTankType (subtype of IfcTypeObject),
///   defining the specific information for all occurencies of
///   that tank in the project. Therefore the association of the
///   (e.g.) Uniclass notation 'L6814' may be associated by a
///   subtype of IfcRelAssociates to the type
///   information.
/// 
/// EXAMPLE 2  The classification information
///   for a particular space within a building may the associated
///   to the IfcSpace object (subtype of
///   IfcObject), defining a particular occurrence of
///   space. Therefore the association of the (e.g.) DIN notation
///   'HNF 1.5' may be associated by a subtype of
///   IfcRelAssociates to the object.
/// 
/// The association relationship establishs a uni-directional
///   association. The subtypes of IfcRelAssociates
///   establishes the particular semantic meaning of the
///   association relationship.
/// 
/// HISTORY New entity in IFC Release 2x.
/// 
/// IFC2x4 CHANGE Entity has been changed into an ABSTRACT supertype
class IfcRelAssociates : public IfcRelationship {
public:
    /// Set of object or property definitions to which the external references or information is associated. It includes object and type objects, property set templates, property templates and property sets and contexts.
    /// 
    /// IFC2x4 CHANGE  The attribute datatype has been changed from IfcRoot to IfcDefinitionSelect.
    IfcTemplatedEntityList< IfcRoot >::ptr RelatedObjects() const;
    void setRelatedObjects(IfcTemplatedEntityList< IfcRoot >::ptr v);
    virtual unsigned int getArgumentCount() const { return 5; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 4: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } return IfcRelationship::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 4: return Type::IfcRoot; } return IfcRelationship::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 4: return "RelatedObjects"; } return IfcRelationship::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRelAssociates (IfcAbstractEntity* e);
    IfcRelAssociates (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcTemplatedEntityList< IfcRoot >::ptr v5_RelatedObjects);
    typedef IfcTemplatedEntityList< IfcRelAssociates > list;
};

class IfcRelAssociatesAppliedValue : public IfcRelAssociates {
public:
    IfcAppliedValue* RelatingAppliedValue() const;
    void setRelatingAppliedValue(IfcAppliedValue* v);
    virtual unsigned int getArgumentCount() const { return 6; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 5: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcRelAssociates::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 5: return Type::IfcAppliedValue; } return IfcRelAssociates::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 5: return "RelatingAppliedValue"; } return IfcRelAssociates::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRelAssociatesAppliedValue (IfcAbstractEntity* e);
    IfcRelAssociatesAppliedValue (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcTemplatedEntityList< IfcRoot >::ptr v5_RelatedObjects, IfcAppliedValue* v6_RelatingAppliedValue);
    typedef IfcTemplatedEntityList< IfcRelAssociatesAppliedValue > list;
};
/// The entity IfcRelAssociatesApproval is used to apply approval information defined by IfcApproval, in IfcApprovalResource schema, to subtypes of IfcRoot.
/// 
/// HISTORY: New entity in IFC2x2.
class IfcRelAssociatesApproval : public IfcRelAssociates {
public:
    /// Reference to approval that is being applied using this relationship.
    IfcApproval* RelatingApproval() const;
    void setRelatingApproval(IfcApproval* v);
    virtual unsigned int getArgumentCount() const { return 6; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 5: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcRelAssociates::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 5: return Type::IfcApproval; } return IfcRelAssociates::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 5: return "RelatingApproval"; } return IfcRelAssociates::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRelAssociatesApproval (IfcAbstractEntity* e);
    IfcRelAssociatesApproval (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcTemplatedEntityList< IfcRoot >::ptr v5_RelatedObjects, IfcApproval* v6_RelatingApproval);
    typedef IfcTemplatedEntityList< IfcRelAssociatesApproval > list;
};
/// The objectified relationship
/// IfcRelAssociatesClassification handles the assignment of a
/// classification item (items of the select
/// IfcClassificationSelect) to objects occurrences (subtypes of
/// IfcObject) or object types (subtypes of
/// IfcTypeObject).
/// The relationship is used to assign a classification item, or a
/// classification system itself to objects. Depending on the type of
/// the RelatingClassification it is either:
/// 
/// a reference to an classification item within an external
/// classification system, or
/// a reference to the classification system itself
/// 
/// NOTE  The reference to a classification item
/// includes a link to the classification system within which the item
/// is declared. It assigns the meaning of the classification item to
/// the object (ocurrence or type). The reference to the classification
/// system provides the information that the object (occurrence or
/// type) is governed by the classification system but no assignment of
/// a particular items has been done yet.
/// 
/// The inherited attribute RelatedObjects define the objects
/// or object types to which the classification is applied. The
/// attribute RelatingClassification is the reference to a
/// classification, applied to the object(s). A single
/// RelatingClassification can thereby be applied to one or
/// multiple objects.
/// 
/// HISTORY New entity in IFC Release 2x.
class IfcRelAssociatesClassification : public IfcRelAssociates {
public:
    /// Classification applied to the objects.
    IfcClassificationNotationSelect* RelatingClassification() const;
    void setRelatingClassification(IfcClassificationNotationSelect* v);
    virtual unsigned int getArgumentCount() const { return 6; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 5: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcRelAssociates::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 5: return Type::IfcClassificationNotationSelect; } return IfcRelAssociates::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 5: return "RelatingClassification"; } return IfcRelAssociates::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRelAssociatesClassification (IfcAbstractEntity* e);
    IfcRelAssociatesClassification (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcTemplatedEntityList< IfcRoot >::ptr v5_RelatedObjects, IfcClassificationNotationSelect* v6_RelatingClassification);
    typedef IfcTemplatedEntityList< IfcRelAssociatesClassification > list;
};
/// The entity IfcRelAssociatesConstraint is used to apply constraint information defined by IfcConstraint, in the IfcConstraintResource schema, to subtypes of IfcRoot.
/// 
/// HISTORY: New entity in IFC2x2.
class IfcRelAssociatesConstraint : public IfcRelAssociates {
public:
    /// The intent of the constraint usage with regard to its related IfcConstraint and IfcObjects, IfcPropertyDefinitions or IfcRelationships. Typical values can be e.g. RATIONALE or EXPECTED PERFORMANCE.
    std::string Intent() const;
    void setIntent(std::string v);
    /// Reference to constraint that is being applied using this relationship.
    IfcConstraint* RelatingConstraint() const;
    void setRelatingConstraint(IfcConstraint* v);
    virtual unsigned int getArgumentCount() const { return 7; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 5: return IfcUtil::Argument_STRING; case 6: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcRelAssociates::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 5: return Type::IfcLabel; case 6: return Type::IfcConstraint; } return IfcRelAssociates::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 5: return "Intent"; case 6: return "RelatingConstraint"; } return IfcRelAssociates::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRelAssociatesConstraint (IfcAbstractEntity* e);
    IfcRelAssociatesConstraint (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcTemplatedEntityList< IfcRoot >::ptr v5_RelatedObjects, std::string v6_Intent, IfcConstraint* v7_RelatingConstraint);
    typedef IfcTemplatedEntityList< IfcRelAssociatesConstraint > list;
};
/// The objectified relationship (IfcRelAssociatesDocument) handles the assignment of a document information (items of the select IfcDocumentSelect) to objects occurrences (subtypes of IfcObject) or object types (subtypes of IfcTypeObject).
/// 
/// The relationship is used to assign a document reference or a more detailed document information to objects. A single document reference can be applied to multiple objects.
/// 
/// The inherited attribute RelatedObjects define the objects to which the document association is applied. The attribute RelatingDocument is the reference to a document reference, applied to the object(s). 
/// 
/// HISTORY: New entity in IFC Release 2x.
class IfcRelAssociatesDocument : public IfcRelAssociates {
public:
    /// Document information or reference which is applied to the objects.
    IfcDocumentSelect* RelatingDocument() const;
    void setRelatingDocument(IfcDocumentSelect* v);
    virtual unsigned int getArgumentCount() const { return 6; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 5: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcRelAssociates::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 5: return Type::IfcDocumentSelect; } return IfcRelAssociates::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 5: return "RelatingDocument"; } return IfcRelAssociates::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRelAssociatesDocument (IfcAbstractEntity* e);
    IfcRelAssociatesDocument (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcTemplatedEntityList< IfcRoot >::ptr v5_RelatedObjects, IfcDocumentSelect* v6_RelatingDocument);
    typedef IfcTemplatedEntityList< IfcRelAssociatesDocument > list;
};
/// The objectified relationship (IfcRelAssociatesLibrary) handles the assignment of a library item (items of the select IfcLibrarySelect) to subtypes of IfcObjectDefinition or IfcPropertyDefinition. 
/// 
/// The relationship is used to assign a library reference or a more detailed link to a library information to objects, property sets or types. A single library reference can be applied to multiple items. 
/// 
/// The inherited attribute RelatedObjects define the items to which the library association is applied. The attribute RelatingLibrary is the reference to a library reference, applied to the item(s). 
/// 
/// HISTORY: New entity in IFC Release 2x.
class IfcRelAssociatesLibrary : public IfcRelAssociates {
public:
    /// Reference to a library, from which the definition of the property set is taken.
    IfcLibrarySelect* RelatingLibrary() const;
    void setRelatingLibrary(IfcLibrarySelect* v);
    virtual unsigned int getArgumentCount() const { return 6; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 5: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcRelAssociates::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 5: return Type::IfcLibrarySelect; } return IfcRelAssociates::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 5: return "RelatingLibrary"; } return IfcRelAssociates::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRelAssociatesLibrary (IfcAbstractEntity* e);
    IfcRelAssociatesLibrary (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcTemplatedEntityList< IfcRoot >::ptr v5_RelatedObjects, IfcLibrarySelect* v6_RelatingLibrary);
    typedef IfcTemplatedEntityList< IfcRelAssociatesLibrary > list;
};
/// Definition from IAI: Objectified relationship between a
/// material definition and elements or element types to which this
/// material definition applies.
/// The material definition can be:
/// 
/// assigned to an element occurrence as a specific usage of a
/// layer set or profile set
/// assigned to an element occurrence or element type as a layer
/// set, profile set, constituent set or a single material
/// 
/// Materials can be arranged by layers and applied to layered
/// elements. Typical elements are walls and slabs.
/// 
/// An IfcMaterialLayerSet, for layered elements with an
/// indication of the layering direction and individual layer
/// thicknesses
/// An IfcMaterialLayerSetUsage, i.e. a material layer set
/// with positioning information along the reference axis or surface
/// of the element.
/// NOTE As a material layer set usage is an
/// occurrence based information, that applies to each individual
/// element, it cannot be assigned to an element
/// type.
/// 
/// Material can be applied to profiles. Typical elements using
/// profile material are beam, column, member
/// 
/// An IfcMaterialProfileSet, i.e. a set of material
/// assigned to a set of profiles, with a single material assigned to
/// a single profile as the default.
/// An IfcMaterialProfileSetUsage, i.e. a material profile
/// set with positioning information relative to the element axis,
/// also refered to as cardinal point.
/// NOTE As a material profile set usage is an
/// occurrence based information, that applies to each individual
/// element, it cannot be assigned to an element
/// type.
/// 
/// Materials can be arranged by identified parts of a component
/// based element. Typical elements are dorrs/windows (with
/// components such as lining, framing and glazing), or distribution
/// elements.
/// 
/// An IfcMaterialConstituentSet, for component based
/// elements with an indication of the component by keyword to which
/// the material consituent applies.
/// NOTE See the material use definitions at each
/// applicable subtype of IfcElement or IfcElementType
/// for a provision of these keywords.
/// 
/// As a fallback, or in cases where only a single material
/// information is needed, material information can be directly
/// associated
/// 
/// A single IfcMaterial for any element where the
/// material use definition does not prohibits its direct
/// association
/// An IfcMaterialList, e.g. for composite elements,
/// without an information, how the different materials are arranged.
/// NOTE The use of
/// IfcMaterialList is deprecated in IFC2x4 onwards. Use
/// IfcMaterialConstituentSet
/// instead.
/// 
/// The IfcRelAssociatesMaterial relationship is a special
/// type of the IfcRelAssociates relationship. It can be
/// applied to subtypes of IfcElement and subtypes of
/// IfcElementType.
/// 
/// The IfcElement has an inverse relation to its material
/// definition by the HasAssociations attribute, inherited
/// from IfcObject.
/// The IfcElementType has an inverse relation to its
/// material definition by the HasAssociations attribute,
/// inherited from IfcPropertyDefinition.
/// 
/// If both, the element occurrence (by an instance of
/// IfcElement) and the element type (by an instance of
/// IfcElementType, connected through
/// IfcRelDefinesByType) have an associated material, then the
/// material associated to the element occurrence overrides the
/// material associated to the element type.
/// 
/// HISTORY New entity in IFC Release
/// 2.x.
/// 
/// Informal proposition
/// 
/// An IfcMaterialLayerSetUsage shall not be associated
/// with a subtype of IfcElementType, it should only be
/// associated with individual occurrences
/// An IfcMaterialProfileSetUsage shall not be associated
/// with a subtype of IfcElementType, it should only be
/// associated with individual occurrences
class IfcRelAssociatesMaterial : public IfcRelAssociates {
public:
    /// Material definition assigned to the elements or element types.
    IfcMaterialSelect* RelatingMaterial() const;
    void setRelatingMaterial(IfcMaterialSelect* v);
    virtual unsigned int getArgumentCount() const { return 6; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 5: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcRelAssociates::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 5: return Type::IfcMaterialSelect; } return IfcRelAssociates::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 5: return "RelatingMaterial"; } return IfcRelAssociates::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRelAssociatesMaterial (IfcAbstractEntity* e);
    IfcRelAssociatesMaterial (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcTemplatedEntityList< IfcRoot >::ptr v5_RelatedObjects, IfcMaterialSelect* v6_RelatingMaterial);
    typedef IfcTemplatedEntityList< IfcRelAssociatesMaterial > list;
};

class IfcRelAssociatesProfileProperties : public IfcRelAssociates {
public:
    IfcProfileProperties* RelatingProfileProperties() const;
    void setRelatingProfileProperties(IfcProfileProperties* v);
    /// Whether the optional attribute ProfileSectionLocation is defined for this IfcRelAssociatesProfileProperties
    bool hasProfileSectionLocation() const;
    IfcShapeAspect* ProfileSectionLocation() const;
    void setProfileSectionLocation(IfcShapeAspect* v);
    /// Whether the optional attribute ProfileOrientation is defined for this IfcRelAssociatesProfileProperties
    bool hasProfileOrientation() const;
    IfcOrientationSelect* ProfileOrientation() const;
    void setProfileOrientation(IfcOrientationSelect* v);
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 5: return IfcUtil::Argument_ENTITY_INSTANCE; case 6: return IfcUtil::Argument_ENTITY_INSTANCE; case 7: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcRelAssociates::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 5: return Type::IfcProfileProperties; case 6: return Type::IfcShapeAspect; case 7: return Type::IfcOrientationSelect; } return IfcRelAssociates::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 5: return "RelatingProfileProperties"; case 6: return "ProfileSectionLocation"; case 7: return "ProfileOrientation"; } return IfcRelAssociates::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRelAssociatesProfileProperties (IfcAbstractEntity* e);
    IfcRelAssociatesProfileProperties (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcTemplatedEntityList< IfcRoot >::ptr v5_RelatedObjects, IfcProfileProperties* v6_RelatingProfileProperties, IfcShapeAspect* v7_ProfileSectionLocation, IfcOrientationSelect* v8_ProfileOrientation);
    typedef IfcTemplatedEntityList< IfcRelAssociatesProfileProperties > list;
};
/// IfcRelConnects is a connectivity relationship that connects objects under some criteria. As a general connectivity it does not imply constraints, however subtypes of the relationship define the applicable object types for the connectivity relationship and the semantics of the particular connectivity. 
/// 
/// HISTORY: New entity in IFC Release 2x.
class IfcRelConnects : public IfcRelationship {
public:
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcRelationship::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcRelationship::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcRelationship::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRelConnects (IfcAbstractEntity* e);
    IfcRelConnects (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description);
    typedef IfcTemplatedEntityList< IfcRelConnects > list;
};
/// Definition from IAI: The
///   IfcRelConnectsElements objectified relationship
///   provides the generalization of the connectivity between
///   elements. It is a 1 to 1 relationship. The concept of two
///   elements being physically or logically connected is
///   described independently from the connecting elements. The
///   connectivity may be related to the shape representation of
///   the connected entities by providing a connection geometry.
/// 
/// In this case the geometrical constraints of the
///   connection are provided by the optional relationship to the
///   IfcConnectionGeometry. The connection geometry is
///   provided as a point, curve or surface within the local
///   placement coordinate systems of the connecting elements.
/// 
/// If the connection geometry is omitted then the
///   connection is provided as a logical connection. Under this
///   circumstance, the connection point, curve or surface has to
///   be recalculated by the receiving application.
/// 
/// HISTORY New entity in IFC
///   Release 1.0.
class IfcRelConnectsElements : public IfcRelConnects {
public:
    /// Whether the optional attribute ConnectionGeometry is defined for this IfcRelConnectsElements
    bool hasConnectionGeometry() const;
    /// The geometric shape representation of the connection geometry that is provided in the object coordinate system of the RelatingElement (mandatory) and in the object coordinate system of the RelatedElement (optionally).
    IfcConnectionGeometry* ConnectionGeometry() const;
    void setConnectionGeometry(IfcConnectionGeometry* v);
    /// Reference to a subtype of IfcElement that is connected by the connection relationship in the role of RelatingElement.
    IfcElement* RelatingElement() const;
    void setRelatingElement(IfcElement* v);
    /// Reference to a subtype of IfcElement that is connected by the connection relationship in the role of RelatedElement.
    IfcElement* RelatedElement() const;
    void setRelatedElement(IfcElement* v);
    virtual unsigned int getArgumentCount() const { return 7; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 4: return IfcUtil::Argument_ENTITY_INSTANCE; case 5: return IfcUtil::Argument_ENTITY_INSTANCE; case 6: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcRelConnects::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 4: return Type::IfcConnectionGeometry; case 5: return Type::IfcElement; case 6: return Type::IfcElement; } return IfcRelConnects::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 4: return "ConnectionGeometry"; case 5: return "RelatingElement"; case 6: return "RelatedElement"; } return IfcRelConnects::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRelConnectsElements (IfcAbstractEntity* e);
    IfcRelConnectsElements (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcConnectionGeometry* v5_ConnectionGeometry, IfcElement* v6_RelatingElement, IfcElement* v7_RelatedElement);
    typedef IfcTemplatedEntityList< IfcRelConnectsElements > list;
};
/// The
/// IfcRelConnectsPathElements relationship provides the connectivity information between two elements, which have path information.
/// 
/// The objectified relationship provides the additional
/// information required to describe the connection between two path
/// based elements that might have single or multiple layers of
/// material. The connection type specifies where at the path based
/// element a connection is given (at the start, in the middle or at
/// the end).
/// 
/// The connection is described by a connection geometry, given
/// within the object coordinate systems of the
/// RelatingElement and of the RelatedElement. In case
/// of IfcWallStandardCase as the RelatingElement and
/// RelatedElement the connection geometry is provided by the
/// subtype IfcConnectionCurveGeometry. Both curves indicate
/// the so called "end cap", i.e. the curve that trims the wall outer
/// edges (being parallel along the wall axis) at the end.
/// HISTORY New entity in IFC Release 1.5.
/// 
/// Figure 115 shows the application of IfcRelConnectsPathElements with the ConnectionGeometry of type IfcConnectionCurveGeometry. The example shows the connection relationship between two instances of IfcWallStandardCase using the IfcRelConnectsPathElements relationship. The ConnectionCurveGeometry defines the CurveOnReleatingElement and CurveOnRelatedElement, both are of type IfcPolyline.
/// 
/// Figure 115 — Path connection geometry
/// 
/// Figure 116 illustrates using the IfcRelConnectsPathElements for a "T" type connection between two instances of IfcWallStandardCase.
/// Figure 117 illustrates using the IfcRelConnectsPathElements for a "L" type connection between two instances of IfcWallStandardCase.
/// NOTE  The two wall axes connect in each case.
/// 
/// ÿ
/// 
/// Figure 116 — Path connection T-Type
/// Figure 117 — Path connection L-Type
class IfcRelConnectsPathElements : public IfcRelConnectsElements {
public:
    /// Priorities for connection. It refers to the layers of the RelatingObject.
    std::vector< int > /*[0:?]*/ RelatingPriorities() const;
    void setRelatingPriorities(std::vector< int > /*[0:?]*/ v);
    /// Priorities for connection. It refers to the layers of the RelatedObject.
    std::vector< int > /*[0:?]*/ RelatedPriorities() const;
    void setRelatedPriorities(std::vector< int > /*[0:?]*/ v);
    /// Indication of the connection type in relation to the path of the RelatingObject.
    IfcConnectionTypeEnum::IfcConnectionTypeEnum RelatedConnectionType() const;
    void setRelatedConnectionType(IfcConnectionTypeEnum::IfcConnectionTypeEnum v);
    /// Indication of the connection type in relation to the path of the RelatingObject.
    IfcConnectionTypeEnum::IfcConnectionTypeEnum RelatingConnectionType() const;
    void setRelatingConnectionType(IfcConnectionTypeEnum::IfcConnectionTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 11; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 7: return IfcUtil::Argument_AGGREGATE_OF_INT; case 8: return IfcUtil::Argument_AGGREGATE_OF_INT; case 9: return IfcUtil::Argument_ENUMERATION; case 10: return IfcUtil::Argument_ENUMERATION; } return IfcRelConnectsElements::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 7: return Type::UNDEFINED; case 8: return Type::UNDEFINED; case 9: return Type::IfcConnectionTypeEnum; case 10: return Type::IfcConnectionTypeEnum; } return IfcRelConnectsElements::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 7: return "RelatingPriorities"; case 8: return "RelatedPriorities"; case 9: return "RelatedConnectionType"; case 10: return "RelatingConnectionType"; } return IfcRelConnectsElements::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRelConnectsPathElements (IfcAbstractEntity* e);
    IfcRelConnectsPathElements (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcConnectionGeometry* v5_ConnectionGeometry, IfcElement* v6_RelatingElement, IfcElement* v7_RelatedElement, std::vector< int > /*[0:?]*/ v8_RelatingPriorities, std::vector< int > /*[0:?]*/ v9_RelatedPriorities, IfcConnectionTypeEnum::IfcConnectionTypeEnum v10_RelatedConnectionType, IfcConnectionTypeEnum::IfcConnectionTypeEnum v11_RelatingConnectionType);
    typedef IfcTemplatedEntityList< IfcRelConnectsPathElements > list;
};
/// The objectified relationship
/// IfcRelConnectsPortToElement defines the relationship that
/// is made between a port and the IfcElement, or
/// IfcElementType in which it is contained. It is a 1 to 1
/// relationship.
/// 
/// The
/// IfcRelConnectsPortToElement established a whole part
/// relationship between the element and its port. The port is used as
/// the means to connect to other ports in other elements. Since both,
/// the element-to-port, and the port-to-port relationships are 1:1
/// relationships, a topological system (or system path or ciruit) can
/// be defined.
/// 
/// Ports contained in different elements are connected to each
/// other using the IfcRelConnectsPorts relationship.
/// 
/// See relevant subtypes of
/// IfcDistributionElement for examples and port use
/// definition sections.
/// 
/// HISTORY  New
/// entity in Release IFC2x Edition 2.
/// IFC2x4 CHANGE  The
/// definition has been extended to include element types.
class IfcRelConnectsPortToElement : public IfcRelConnects {
public:
    /// Reference to an Port that is connected by the objectified relationship.
    IfcPort* RelatingPort() const;
    void setRelatingPort(IfcPort* v);
    /// Reference to an IfcElement, or IfcElementType that has ports assigned.
    /// 
    /// IFC2x4 CHANGE  Data type extended to IfcObjectDefinition to enable elements and element types for the port relationship.
    IfcElement* RelatedElement() const;
    void setRelatedElement(IfcElement* v);
    virtual unsigned int getArgumentCount() const { return 6; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 4: return IfcUtil::Argument_ENTITY_INSTANCE; case 5: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcRelConnects::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 4: return Type::IfcPort; case 5: return Type::IfcElement; } return IfcRelConnects::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 4: return "RelatingPort"; case 5: return "RelatedElement"; } return IfcRelConnects::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRelConnectsPortToElement (IfcAbstractEntity* e);
    IfcRelConnectsPortToElement (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcPort* v5_RelatingPort, IfcElement* v6_RelatedElement);
    typedef IfcTemplatedEntityList< IfcRelConnectsPortToElement > list;
};
/// Definition from IAI: An IfcRelConnectsPorts
///   defines the relationship that is made between two ports at
///   their point of connection. It may include the connection
///   geometry between two ports.
/// 
/// IfcRelConnectsPorts is required for defining how
///   instances of IfcPort connect together. Each of the
///   port is being logically attached to the IfcElement
///   by using the IfcRelConnectsPortToElement
///   relationship.
/// 
/// HISTORY New entity in IFC
///   2.0, modified in IFC2x.
class IfcRelConnectsPorts : public IfcRelConnects {
public:
    /// Reference to the first port that is connected by the objectified relationship.
    IfcPort* RelatingPort() const;
    void setRelatingPort(IfcPort* v);
    /// Reference to the second port that is connected by the objectified relationship.
    IfcPort* RelatedPort() const;
    void setRelatedPort(IfcPort* v);
    /// Whether the optional attribute RealizingElement is defined for this IfcRelConnectsPorts
    bool hasRealizingElement() const;
    /// Defines the element that realizes a port connection relationship.
    IfcElement* RealizingElement() const;
    void setRealizingElement(IfcElement* v);
    virtual unsigned int getArgumentCount() const { return 7; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 4: return IfcUtil::Argument_ENTITY_INSTANCE; case 5: return IfcUtil::Argument_ENTITY_INSTANCE; case 6: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcRelConnects::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 4: return Type::IfcPort; case 5: return Type::IfcPort; case 6: return Type::IfcElement; } return IfcRelConnects::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 4: return "RelatingPort"; case 5: return "RelatedPort"; case 6: return "RealizingElement"; } return IfcRelConnects::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRelConnectsPorts (IfcAbstractEntity* e);
    IfcRelConnectsPorts (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcPort* v5_RelatingPort, IfcPort* v6_RelatedPort, IfcElement* v7_RealizingElement);
    typedef IfcTemplatedEntityList< IfcRelConnectsPorts > list;
};
/// Definition from IAI: The IfcRelConnectsStructuralActivity relationship connects a structural activity (either an action or reaction) to a structural member, structural connection, or element.
/// 
/// HISTORY: New entity in IFC 2x2.
class IfcRelConnectsStructuralActivity : public IfcRelConnects {
public:
    /// Reference to a structural item or element to which the specified activity is applied.
    IfcStructuralActivityAssignmentSelect* RelatingElement() const;
    void setRelatingElement(IfcStructuralActivityAssignmentSelect* v);
    /// Reference to a structural activity which is acting upon the specified structural item or element.
    IfcStructuralActivity* RelatedStructuralActivity() const;
    void setRelatedStructuralActivity(IfcStructuralActivity* v);
    virtual unsigned int getArgumentCount() const { return 6; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 4: return IfcUtil::Argument_ENTITY_INSTANCE; case 5: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcRelConnects::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 4: return Type::IfcStructuralActivityAssignmentSelect; case 5: return Type::IfcStructuralActivity; } return IfcRelConnects::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 4: return "RelatingElement"; case 5: return "RelatedStructuralActivity"; } return IfcRelConnects::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRelConnectsStructuralActivity (IfcAbstractEntity* e);
    IfcRelConnectsStructuralActivity (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcStructuralActivityAssignmentSelect* v5_RelatingElement, IfcStructuralActivity* v6_RelatedStructuralActivity);
    typedef IfcTemplatedEntityList< IfcRelConnectsStructuralActivity > list;
};

class IfcRelConnectsStructuralElement : public IfcRelConnects {
public:
    IfcElement* RelatingElement() const;
    void setRelatingElement(IfcElement* v);
    IfcStructuralMember* RelatedStructuralMember() const;
    void setRelatedStructuralMember(IfcStructuralMember* v);
    virtual unsigned int getArgumentCount() const { return 6; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 4: return IfcUtil::Argument_ENTITY_INSTANCE; case 5: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcRelConnects::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 4: return Type::IfcElement; case 5: return Type::IfcStructuralMember; } return IfcRelConnects::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 4: return "RelatingElement"; case 5: return "RelatedStructuralMember"; } return IfcRelConnects::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRelConnectsStructuralElement (IfcAbstractEntity* e);
    IfcRelConnectsStructuralElement (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcElement* v5_RelatingElement, IfcStructuralMember* v6_RelatedStructuralMember);
    typedef IfcTemplatedEntityList< IfcRelConnectsStructuralElement > list;
};
/// The entity IfcRelConnectsStructuralMember defines all needed properties describing the connection between structural members and structural connection objects (nodes or supports).
/// 
/// HISTORY  New entity in IFC2x2.
/// 
/// Use Definition
/// 
/// Point Connection
/// Instances of the entity IfcRelConnectsStructuralMember shall be used to describe a connection between an instance of IfcStructuralPointConnection and either an instance of IfcStructuralCurveMember or IfcStructuralSurfaceMember.  The RelatedStructuralConnection for point connections has to be of type IfcStructuralPointConnection.
/// 
/// Curve Connection
/// Instances of the entity IfcRelConnectsStructuralMember shall be used to describe a connection between an instance of IfcStructuralCurveConnection and an instance of either IfcStructuralCurveMember or IfcStructuralSurfaceMember.  The RelatedStructuralConnection for curve connections has to be of type IfcStructuralCurveConnection.
/// 
/// Surface Connection
/// Instances of the entity IfcRelConnectsStructuralMember shall be used to describe a connection between an instance of IfcStructuralSurfaceConnection and an instance of IfcStructuralSurfaceMember.  The RelatedStructuralConnection for curve connections has to be of type IfcStructuralSurfaceConnection.
/// 
/// Coordinate System for Applied Conditions
/// All values defined by AppliedCondition or AdditionalConditions are given within the coordinate system provided by ConditionCoordinateSystem, which is defined relative to the local coordinate system of the structural member.  If the ConditionCoordinateSystem is not defined, the local coordinate system of the structural member is used instead.
/// 
/// Supported Length
/// Optionally a supported length can be given, which specifies the length (or width) of the physical connection along a curve connection.
/// 
/// Figure 235 illustrates the appropriate definition of support lengths.
/// 
/// Figure 235 — Structural member support lengths
class IfcRelConnectsStructuralMember : public IfcRelConnects {
public:
    /// Reference to an instance of IfcStructuralMember (or its subclasses) which is connected to the specified structural connection.
    IfcStructuralMember* RelatingStructuralMember() const;
    void setRelatingStructuralMember(IfcStructuralMember* v);
    /// Reference to an instance of IfcStructuralConnection (or its subclasses) which is connected to the specified structural member.
    IfcStructuralConnection* RelatedStructuralConnection() const;
    void setRelatedStructuralConnection(IfcStructuralConnection* v);
    /// Whether the optional attribute AppliedCondition is defined for this IfcRelConnectsStructuralMember
    bool hasAppliedCondition() const;
    /// Conditions which define the connections properties.  Connection conditions are often called "release" but are not only used to define mechanisms like hinges but also rigid, elastic, and other conditions.
    IfcBoundaryCondition* AppliedCondition() const;
    void setAppliedCondition(IfcBoundaryCondition* v);
    /// Whether the optional attribute AdditionalConditions is defined for this IfcRelConnectsStructuralMember
    bool hasAdditionalConditions() const;
    /// Describes additional connection properties.
    IfcStructuralConnectionCondition* AdditionalConditions() const;
    void setAdditionalConditions(IfcStructuralConnectionCondition* v);
    /// Whether the optional attribute SupportedLength is defined for this IfcRelConnectsStructuralMember
    bool hasSupportedLength() const;
    /// Defines the 'supported length' of this structural connection. See Fig. for more detail.
    double SupportedLength() const;
    void setSupportedLength(double v);
    /// Whether the optional attribute ConditionCoordinateSystem is defined for this IfcRelConnectsStructuralMember
    bool hasConditionCoordinateSystem() const;
    /// Defines a coordinate system used for the description of the connection properties in ConnectionCondition relative to the local coordinate system of RelatingStructuralMember.  If left unspecified, the placement IfcAxis2Placement3D((x,y,z), ?, ?) is implied with x,y,z being the local member coordinates where the connection is made and the default axes directions being in parallel with the local axes of RelatingStructuralMember.
    IfcAxis2Placement3D* ConditionCoordinateSystem() const;
    void setConditionCoordinateSystem(IfcAxis2Placement3D* v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 4: return IfcUtil::Argument_ENTITY_INSTANCE; case 5: return IfcUtil::Argument_ENTITY_INSTANCE; case 6: return IfcUtil::Argument_ENTITY_INSTANCE; case 7: return IfcUtil::Argument_ENTITY_INSTANCE; case 8: return IfcUtil::Argument_DOUBLE; case 9: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcRelConnects::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 4: return Type::IfcStructuralMember; case 5: return Type::IfcStructuralConnection; case 6: return Type::IfcBoundaryCondition; case 7: return Type::IfcStructuralConnectionCondition; case 8: return Type::IfcLengthMeasure; case 9: return Type::IfcAxis2Placement3D; } return IfcRelConnects::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 4: return "RelatingStructuralMember"; case 5: return "RelatedStructuralConnection"; case 6: return "AppliedCondition"; case 7: return "AdditionalConditions"; case 8: return "SupportedLength"; case 9: return "ConditionCoordinateSystem"; } return IfcRelConnects::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRelConnectsStructuralMember (IfcAbstractEntity* e);
    IfcRelConnectsStructuralMember (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcStructuralMember* v5_RelatingStructuralMember, IfcStructuralConnection* v6_RelatedStructuralConnection, IfcBoundaryCondition* v7_AppliedCondition, IfcStructuralConnectionCondition* v8_AdditionalConditions, boost::optional< double > v9_SupportedLength, IfcAxis2Placement3D* v10_ConditionCoordinateSystem);
    typedef IfcTemplatedEntityList< IfcRelConnectsStructuralMember > list;
};
/// Definition from IAI: The entity IfcRelConnectsWithEccentricity adds the definition of eccentricity to the connection between a structural member and a structural connection (representing either a node or support).
/// 
/// NOTE   Another eccentricity model is available independently of eccentric connection specification:  The section profile of a curve member may be inserted eccentrically with respect to the member's reference curve, see definitions at IfcStructuralCurveMember.  Whether one or the other or both eccentricity models may be used is subject to information requirements and local agreements.
/// 
/// HISTORY  New entity in IFC 2x3.
/// Use definitions changed in IFC 2x4 to always require two topology items.
/// 
/// Use Definition
/// 
/// Point Connection
/// ConnectionConstraint shall be of type IfcConnectionPointGeometry and shall refer to two instances of IfcVertexPoint.
/// 
/// Curve Connection
/// ConnectionConstraint shall be of type IfcConnectionCurveGeometry and shall refer to two instances of IfcEdge or subtypes.
/// 
/// Surface Connection
/// ConnectionConstraint shall be of type IfcConnectionSurfaceGeometry and shall refer to two instances of IfcFaceSurface.
class IfcRelConnectsWithEccentricity : public IfcRelConnectsStructuralMember {
public:
    /// The connection constraint explicitly states the eccentricity between a structural member and a structural connection by means of two topological objects (vertex and vertex, or edge and edge, or face and face).
    IfcConnectionGeometry* ConnectionConstraint() const;
    void setConnectionConstraint(IfcConnectionGeometry* v);
    virtual unsigned int getArgumentCount() const { return 11; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 10: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcRelConnectsStructuralMember::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 10: return Type::IfcConnectionGeometry; } return IfcRelConnectsStructuralMember::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 10: return "ConnectionConstraint"; } return IfcRelConnectsStructuralMember::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRelConnectsWithEccentricity (IfcAbstractEntity* e);
    IfcRelConnectsWithEccentricity (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcStructuralMember* v5_RelatingStructuralMember, IfcStructuralConnection* v6_RelatedStructuralConnection, IfcBoundaryCondition* v7_AppliedCondition, IfcStructuralConnectionCondition* v8_AdditionalConditions, boost::optional< double > v9_SupportedLength, IfcAxis2Placement3D* v10_ConditionCoordinateSystem, IfcConnectionGeometry* v11_ConnectionConstraint);
    typedef IfcTemplatedEntityList< IfcRelConnectsWithEccentricity > list;
};
/// Definition from IAI:
///   IfcRelConnectsWithRealizingElements defines a
///   generic relationship that is made between two elements that
///   require the realization of that relationship by means of
///   further realizing elements.
/// 
/// An IfcRelConnectsWithRealizingElements is a
///   specialization of IfcRelConnectsElement where the
///   connecting operation has the additional attribute of (one
///   or many) realizing elements that may be used to realize or
///   further qualify the relationship. It is defined as a
///   ternary relationship.
/// 
/// EXAMPLE: It may be used to describe the
///   attachment of one element to another where the attachment
///   is realized by a 'fixing' element such as a bracket. It
///   may also be used to describe the mounting of one element
///   onto another such as the requirement for the mounting
///   major plant items onto builders work bases and/or
///   anti-vibration isolators.
/// 
/// HISTORY: New entity in
///   Release IFC2x Edition 2.
class IfcRelConnectsWithRealizingElements : public IfcRelConnectsElements {
public:
    /// Defines the elements that realize a connection relationship.
    IfcTemplatedEntityList< IfcElement >::ptr RealizingElements() const;
    void setRealizingElements(IfcTemplatedEntityList< IfcElement >::ptr v);
    /// Whether the optional attribute ConnectionType is defined for this IfcRelConnectsWithRealizingElements
    bool hasConnectionType() const;
    /// The type of the connection given for informal purposes, it may include labels, like 'joint', 'rigid joint', 'flexible joint', etc.
    std::string ConnectionType() const;
    void setConnectionType(std::string v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 7: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 8: return IfcUtil::Argument_STRING; } return IfcRelConnectsElements::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 7: return Type::IfcElement; case 8: return Type::IfcLabel; } return IfcRelConnectsElements::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 7: return "RealizingElements"; case 8: return "ConnectionType"; } return IfcRelConnectsElements::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRelConnectsWithRealizingElements (IfcAbstractEntity* e);
    IfcRelConnectsWithRealizingElements (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcConnectionGeometry* v5_ConnectionGeometry, IfcElement* v6_RelatingElement, IfcElement* v7_RelatedElement, IfcTemplatedEntityList< IfcElement >::ptr v8_RealizingElements, boost::optional< std::string > v9_ConnectionType);
    typedef IfcTemplatedEntityList< IfcRelConnectsWithRealizingElements > list;
};
/// This objectified relationship,
///   IfcRelContainedInSpatialStructure, is used to assign
///   elements to a certain level of the spatial project
///   structure. Any element can only be assigned once to a
///   certain level of the spatial structure. The question, which
///   level is relevant for which type of element, can only be
///   answered within the context of a particular project and
///   might vary within the various regions.
/// 
/// EXAMPLE A multi-storey space is contained (or
///   belongs to) the building storey at which its ground level
///   is, but it is referenced by all the other building
///   storeys, in which it spans. A lift shaft might be
///   contained by the basement, but referenced by all storeys,
///   through which it spans.
/// 
/// The containment relationship of an element within a
///   spatial structure has to be a hierarchical relationship, an
///   element can only be contained within a single spatial
///   structure element. The reference relationship between an
///   element and the spatial structure may not be hierarchical,
///   i.e. an element can reference many spatial structure
///   elements.
/// 
/// NOTE The reference relationship is expressed by
///   IfcRelReferencedInSpatialStructure.
/// 
/// Predefined spatial structure elements to which elements can
///   be assigned are
/// 
/// site as IfcSite
/// 
/// building as IfcBuilding
/// 
/// storey as IfcBuildingStorey
/// 
/// space as IfcSpace
/// 
/// Occurrences of the same element type can be assigned to
///   different spatial structure elements depending on the
///   context of the occurrence.
/// 
/// EXAMPLE A wall might be normally assigned
///   to a storey, however the curtain wall might be assigned
///   to the building and the retaining wall in the terrain
///   might be assigned to the site.
/// 
/// HISTORY New entity in IFC
///   Release 2x.
/// 
/// IFC2x PLATFORM CHANGE: The
///   data type of the attribute RelatedElements has been
///   changed from IfcElement to its supertype
///   IfcProduct with upward compatibility for file based
///   exchange.
/// 
/// Containment Use Definition
///   Figure 39 shows the use of IfcRelContainedInSpatialStructure to assign a stair and two walls to two different levels within the spatial structure.
/// 
/// ÿ
/// 
/// Figure 39 — Relationship for spatial structure containment
class IfcRelContainedInSpatialStructure : public IfcRelConnects {
public:
    /// Set of elements products, which are contained within this level of the spatial structure hierarchy.
    /// 
    /// IFC2x PLATFORM CHANGE  The data type has been changed from IfcElement to IfcProduct with upward compatibility
    IfcTemplatedEntityList< IfcProduct >::ptr RelatedElements() const;
    void setRelatedElements(IfcTemplatedEntityList< IfcProduct >::ptr v);
    /// Spatial structure element, within which the element is contained. Any element can only be contained within one element of the project spatial structure.
    IfcSpatialStructureElement* RelatingStructure() const;
    void setRelatingStructure(IfcSpatialStructureElement* v);
    virtual unsigned int getArgumentCount() const { return 6; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 4: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 5: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcRelConnects::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 4: return Type::IfcProduct; case 5: return Type::IfcSpatialStructureElement; } return IfcRelConnects::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 4: return "RelatedElements"; case 5: return "RelatingStructure"; } return IfcRelConnects::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRelContainedInSpatialStructure (IfcAbstractEntity* e);
    IfcRelContainedInSpatialStructure (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcTemplatedEntityList< IfcProduct >::ptr v5_RelatedElements, IfcSpatialStructureElement* v6_RelatingStructure);
    typedef IfcTemplatedEntityList< IfcRelContainedInSpatialStructure > list;
};
/// Definition from IAI: The
/// IfcRelCoversBldgElements is an objectified relationship
/// between an element and one to many coverings, which cover the
/// building element.
/// 
/// IfcRelCoversBldgElements, this relationship, expresses
/// the primary relation to the element,
/// IfcRelCoversSpaces expresses the primary relation to
/// the space.
/// 
/// HISTORY New Entity in
/// IFC Release 1.5
/// IFC2x4 CHANGE: The data
/// type of the attribute RelatingElement has been changed
/// from IfcElement to its subtype
/// IfcBuildingElement.
class IfcRelCoversBldgElements : public IfcRelConnects {
public:
    /// Relationship to the building element that is covered. 
    /// 
    /// IFC2x4 CHANGE: The attribute type has been changed from IfcElement to IfcBuildingElement.
    IfcElement* RelatingBuildingElement() const;
    void setRelatingBuildingElement(IfcElement* v);
    /// Relationship to the set of coverings at this element.
    IfcTemplatedEntityList< IfcCovering >::ptr RelatedCoverings() const;
    void setRelatedCoverings(IfcTemplatedEntityList< IfcCovering >::ptr v);
    virtual unsigned int getArgumentCount() const { return 6; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 4: return IfcUtil::Argument_ENTITY_INSTANCE; case 5: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } return IfcRelConnects::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 4: return Type::IfcElement; case 5: return Type::IfcCovering; } return IfcRelConnects::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 4: return "RelatingBuildingElement"; case 5: return "RelatedCoverings"; } return IfcRelConnects::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRelCoversBldgElements (IfcAbstractEntity* e);
    IfcRelCoversBldgElements (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcElement* v5_RelatingBuildingElement, IfcTemplatedEntityList< IfcCovering >::ptr v6_RelatedCoverings);
    typedef IfcTemplatedEntityList< IfcRelCoversBldgElements > list;
};
/// Definition from IAI: The objectified relationship,
///   IfcRelCoversSpace, relatesÿa space object to one or
///   many coverings, which faces (or is assigned to) the space.
/// 
/// NOTE Particularly floorings, ceilings and wall
///   coverings, such as claddings or tiling are often
///   considered as space coverings, rather then wall or slab
///   coverings. In some life cycle phases, such as the
///   operation phase, the relationship is always made to the
///   space.
/// 
/// The IFC specification provides two relationships:
/// 
/// IfcRelCoversBldgElements to assign coverings to
///   elements, and
/// 
/// IfcRelCoversSpaces to assign coverings to spaces
/// 
/// Which relationship should be applied has to be determined
///   by the context of the project or application .
/// 
/// NOTE View definition may determine the necessity
///   to use either of the two relationship elements
/// 
/// HISTORYÿ New Entity in Release
///   IFC 2x Edition 3.
class IfcRelCoversSpaces : public IfcRelConnects {
public:
    IfcSpace* RelatedSpace() const;
    void setRelatedSpace(IfcSpace* v);
    /// Relationship to the set of coverings covering this space.
    IfcTemplatedEntityList< IfcCovering >::ptr RelatedCoverings() const;
    void setRelatedCoverings(IfcTemplatedEntityList< IfcCovering >::ptr v);
    virtual unsigned int getArgumentCount() const { return 6; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 4: return IfcUtil::Argument_ENTITY_INSTANCE; case 5: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } return IfcRelConnects::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 4: return Type::IfcSpace; case 5: return Type::IfcCovering; } return IfcRelConnects::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 4: return "RelatedSpace"; case 5: return "RelatedCoverings"; } return IfcRelConnects::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRelCoversSpaces (IfcAbstractEntity* e);
    IfcRelCoversSpaces (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcSpace* v5_RelatedSpace, IfcTemplatedEntityList< IfcCovering >::ptr v6_RelatedCoverings);
    typedef IfcTemplatedEntityList< IfcRelCoversSpaces > list;
};
/// The decomposition relationship,
/// IfcRelDecomposes, defines the general concept of elements
/// being composed or decomposed. The decomposition relationship
/// denotes a whole/part hierarchy with the ability to navigate from
/// the whole (the composition) to the parts and vice versa.
/// Decompositions may be constrained by requiring both, the whole
/// and its parts, to be of the same type - thus establishing a
/// nesting relationship. Or they may require some form of physical
/// containment, thus establishing special types of aggregation
/// relationships.
/// NOTE There are two special names for
/// decomposition, which are linguistically distinguished, nesting
/// and aggregation. The subtypes of IfcRelDecomposes will
/// introduce either the nesting or aggregation convention (see
/// IfcRelNests and
/// IfcRelAggregates).
/// EXAMPLE A cost element is a nest of other cost
/// elements. Or a structural frame is an aggregation of beams and
/// columns. Both are applications of decomposition
/// relationship.
/// Decompositions imply a dependency, i.e. the definition of the
/// whole depends on the definition of the parts and the parts depend
/// on the existence of the whole. The decomposition relationship can
/// be applied in a recursive manner, i.e. a decomposed element can
/// be part in another decomposition. Cyclic references have to be
/// prevented at application level.
/// 
/// HISTORY New entity in IFC Release 1.5, it is a generalisation of the IFC2.0 entity IfcRelNests.
/// 
/// IFC2x4 CHANGE The differentiation between the aggregation and nesting is determined to be a non-ordered or an ordered collection of parts. The attributes RelatingObject and RelatedObjects have been demoted to the subtypes.
class IfcRelDecomposes : public IfcRelationship {
public:
    IfcObjectDefinition* RelatingObject() const;
    void setRelatingObject(IfcObjectDefinition* v);
    IfcTemplatedEntityList< IfcObjectDefinition >::ptr RelatedObjects() const;
    void setRelatedObjects(IfcTemplatedEntityList< IfcObjectDefinition >::ptr v);
    virtual unsigned int getArgumentCount() const { return 6; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 4: return IfcUtil::Argument_ENTITY_INSTANCE; case 5: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } return IfcRelationship::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 4: return Type::IfcObjectDefinition; case 5: return Type::IfcObjectDefinition; } return IfcRelationship::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 4: return "RelatingObject"; case 5: return "RelatedObjects"; } return IfcRelationship::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRelDecomposes (IfcAbstractEntity* e);
    IfcRelDecomposes (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcObjectDefinition* v5_RelatingObject, IfcTemplatedEntityList< IfcObjectDefinition >::ptr v6_RelatedObjects);
    typedef IfcTemplatedEntityList< IfcRelDecomposes > list;
};
/// A generic and abstract relationship which subtypes are used to:
/// 
/// assign a object type to an object occurrence
/// assign a property set to an object instance
/// assign a property set template to a property set
/// 
/// EXAMPLE ÿSeveral instances of windows within
/// the IFC project model may be of the same (catalogue or
/// manufacturer) type. Thereby they share the same properties. This
/// relationship is established by the subtype
/// IfcRelDefinesByType of IfcRelDefines relationship
/// assigning an IfcWindowStyle to multiple occurrences
/// IfcWindow.
/// 
/// EXAMPLE ÿThe (same) property set, e.g.ÿ
/// Pset_ProductManufacturerInfo, keeping the manufacturer name,
/// label and production year of a product, can be assigned to one,
/// or many instances of furnishing. This relationship is established
/// by the subtype IfcRelDefinesByProperties of
/// IfcRelDefines relationship assigning an
/// IfcPropertySet to one or more instances of
/// IfcFurnishingElement.
/// 
/// HISTORY New entity in IFC2x.
/// 
/// IFC2x4 CHANGE The attribute RelatedObjects had been demoted to the subtypes IfcRelDefinesByProperties and
/// IfcRelDefinesByType.
class IfcRelDefines : public IfcRelationship {
public:
    IfcTemplatedEntityList< IfcObject >::ptr RelatedObjects() const;
    void setRelatedObjects(IfcTemplatedEntityList< IfcObject >::ptr v);
    virtual unsigned int getArgumentCount() const { return 5; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 4: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } return IfcRelationship::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 4: return Type::IfcObject; } return IfcRelationship::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 4: return "RelatedObjects"; } return IfcRelationship::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRelDefines (IfcAbstractEntity* e);
    IfcRelDefines (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcTemplatedEntityList< IfcObject >::ptr v5_RelatedObjects);
    typedef IfcTemplatedEntityList< IfcRelDefines > list;
};
/// The objectified relationship
/// IfcRelDefinesByProperties defines the relationships
/// between property set definitions and objects. Properties are
/// aggregated in property sets. Property sets can be either directly
/// assigned to occurrence objects using this relationship, or
/// assigned to an object type and assigned via that type to
/// occurrence objects.
/// The IfcRelDefinesByProperties is a 1-to-N relationship,
/// as it allows for the assignment of one property set to a single
/// or to many objects. Those objects then share the same property
/// definition.
/// 
/// HISTORY New Entity in IFC Release 2.0. Has been renamed from IfcRelAssignsProperties in IFC Release 2x.
/// 
/// IFC2x4 CHANGE The attribute RelatedObjects had been demoted from the supertype IfcRelDefines to IfcRelDefinesByProperties.
class IfcRelDefinesByProperties : public IfcRelDefines {
public:
    /// Reference to the property set definition for that object or set of objects.
    IfcPropertySetDefinition* RelatingPropertyDefinition() const;
    void setRelatingPropertyDefinition(IfcPropertySetDefinition* v);
    virtual unsigned int getArgumentCount() const { return 6; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 5: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcRelDefines::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 5: return Type::IfcPropertySetDefinition; } return IfcRelDefines::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 5: return "RelatingPropertyDefinition"; } return IfcRelDefines::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRelDefinesByProperties (IfcAbstractEntity* e);
    IfcRelDefinesByProperties (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcTemplatedEntityList< IfcObject >::ptr v5_RelatedObjects, IfcPropertySetDefinition* v6_RelatingPropertyDefinition);
    typedef IfcTemplatedEntityList< IfcRelDefinesByProperties > list;
};
/// The objectified relationship
/// IfcRelDefinesByType defines the relationship between an
/// object type and object occurrences.
/// The IfcRelDefinesByType is a 1-to-N relationship, as it
/// allows for the assignment of one type information to a single or
/// to many objects. Those objects then share the same object type,
/// and the property sets and properties assigned to the object
/// type.
/// 
/// HISTORY New entity in IFC2x.
/// 
/// IFC2x4 CHANGE The attribute RelatedObjects had been demoted from the supertype IfcRelDefines to IfcRelDefinesByType.
/// 
/// Relationship use definition
/// 
/// The IfcRelDefinesByType links the object type
/// definition with the object occurrence. Both may define properties
/// by assigning an IfcPropertySet, including one or many
/// subtypes of IfcProperty to either the object type or
/// object occurrence, as shown in Figure 8.
/// There are several scenarios to define the same property
/// set on the object type definition and object occurrence
/// side:
/// 
/// All properties for all object occurrences of a common
/// object type have the same value - then only the object type
/// definition has a property set assigned.
/// All properties for all object occurrences are
/// different, that is there are no common property values for the
/// object type definition - then each of the object occurrence has a
/// property set assigned.
/// Some properties within the same property set have
/// common values and are assigned to the object type definition and
/// some are occurrence specific and assigned (with potentially
/// different values) to the object occurrences - then:
/// 
/// The sum of all properties within a given property set
/// applicable to an object occurrence is the union of properties
/// assigned to the object type definition plus the properties
/// assigned to the object occurrence.
/// If the object occurrence has a property with the same
/// IfcProperty.Name in an IfcPropertySet, as the
/// corresponding object type definition, then the occurrence
/// property value overrides the type property value.
/// 
/// Figure 8 — Type definition relationships
/// 
/// The following table provides an example of assigning
/// 
/// properties assigned to
/// IfcWall
/// properties assigned to
/// IfcWallType
/// resulting property value for individual
/// wall
/// 
/// Pset_WallCommon
/// Pset_WallCommon
/// ÿ
/// 
/// ÿ-ÿExtendToStructure = TRUE
/// ÿ
/// TRUE
/// 
/// ÿ
/// ÿ-ÿThermalTransmittance = 0.375
/// 0.375
/// 
/// ÿ-ÿExtendToStructure = FALSE
/// ÿ-ÿExtendToStructure = TRUE
/// FALSE
class IfcRelDefinesByType : public IfcRelDefines {
public:
    /// Reference to the type (or style) information for that object or set of objects.
    IfcTypeObject* RelatingType() const;
    void setRelatingType(IfcTypeObject* v);
    virtual unsigned int getArgumentCount() const { return 6; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 5: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcRelDefines::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 5: return Type::IfcTypeObject; } return IfcRelDefines::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 5: return "RelatingType"; } return IfcRelDefines::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRelDefinesByType (IfcAbstractEntity* e);
    IfcRelDefinesByType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcTemplatedEntityList< IfcObject >::ptr v5_RelatedObjects, IfcTypeObject* v6_RelatingType);
    typedef IfcTemplatedEntityList< IfcRelDefinesByType > list;
};
/// IfcRelFillsElement is an objectified relationship between an opening element and an element that fills (or partially fills) the opening element. It is an one-to-one relationship.
/// 
/// NOTE view definitions or implementer agreements may restrict an opening to be filled by one filling element only.
/// 
/// HISTORY New entity in IFC Release 1.0
/// 
/// As shown in Figure 40, the insertion of a door into a wall is represented by two separate relationships. First the door opening is created within the wall by IfcWall(StandardCase) o-- IfcRelVoidsElement --o IfcOpeningElement, then the door is inserted within the opening by IfcOpeningElement o-- IfcRelFillsElement --o IfcDoor.
/// 
/// Figure 40 — Relationships for element filling
class IfcRelFillsElement : public IfcRelConnects {
public:
    /// Opening Element being filled by virtue of this relationship.
    IfcOpeningElement* RelatingOpeningElement() const;
    void setRelatingOpeningElement(IfcOpeningElement* v);
    /// Reference to building element that occupies fully or partially the associated opening.
    /// 
    /// IFC2x PLATFORM CHANGE: The data type has been changed from IfcBuildingElement to IfcElement with upward compatibility for file based exchange.
    IfcElement* RelatedBuildingElement() const;
    void setRelatedBuildingElement(IfcElement* v);
    virtual unsigned int getArgumentCount() const { return 6; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 4: return IfcUtil::Argument_ENTITY_INSTANCE; case 5: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcRelConnects::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 4: return Type::IfcOpeningElement; case 5: return Type::IfcElement; } return IfcRelConnects::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 4: return "RelatingOpeningElement"; case 5: return "RelatedBuildingElement"; } return IfcRelConnects::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRelFillsElement (IfcAbstractEntity* e);
    IfcRelFillsElement (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcOpeningElement* v5_RelatingOpeningElement, IfcElement* v6_RelatedBuildingElement);
    typedef IfcTemplatedEntityList< IfcRelFillsElement > list;
};
/// Objectified relationship between a distribution flow element occurrence instance and one-to-many control element occurrence instances indicating that the control element(s) sense or control some aspect of the flow element. It is applied to IfcDistributionFlowElement and IfcDistributionControlElement.
/// 
/// This relationship may be used to indicate an operation relationship such as an actuator operating a valve, damper, or switch.  It may also be used to indicate a sensing relationship such as a sensor detecting conditions of fluid flow.
/// 
/// This relationship implies a sensing or controlling relationship; if elements are merely connected without any control relationship, then IfcRelConnectsElements should be used.
/// 
/// HISTORY: New entity in IFC R2x.
class IfcRelFlowControlElements : public IfcRelConnects {
public:
    /// References control elements which may be used to impart control on the Distribution Element.
    IfcTemplatedEntityList< IfcDistributionControlElement >::ptr RelatedControlElements() const;
    void setRelatedControlElements(IfcTemplatedEntityList< IfcDistributionControlElement >::ptr v);
    /// Relationship to a distribution flow element
    IfcDistributionFlowElement* RelatingFlowElement() const;
    void setRelatingFlowElement(IfcDistributionFlowElement* v);
    virtual unsigned int getArgumentCount() const { return 6; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 4: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 5: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcRelConnects::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 4: return Type::IfcDistributionControlElement; case 5: return Type::IfcDistributionFlowElement; } return IfcRelConnects::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 4: return "RelatedControlElements"; case 5: return "RelatingFlowElement"; } return IfcRelConnects::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRelFlowControlElements (IfcAbstractEntity* e);
    IfcRelFlowControlElements (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcTemplatedEntityList< IfcDistributionControlElement >::ptr v5_RelatedControlElements, IfcDistributionFlowElement* v6_RelatingFlowElement);
    typedef IfcTemplatedEntityList< IfcRelFlowControlElements > list;
};

class IfcRelInteractionRequirements : public IfcRelConnects {
public:
    /// Whether the optional attribute DailyInteraction is defined for this IfcRelInteractionRequirements
    bool hasDailyInteraction() const;
    double DailyInteraction() const;
    void setDailyInteraction(double v);
    /// Whether the optional attribute ImportanceRating is defined for this IfcRelInteractionRequirements
    bool hasImportanceRating() const;
    double ImportanceRating() const;
    void setImportanceRating(double v);
    /// Whether the optional attribute LocationOfInteraction is defined for this IfcRelInteractionRequirements
    bool hasLocationOfInteraction() const;
    IfcSpatialStructureElement* LocationOfInteraction() const;
    void setLocationOfInteraction(IfcSpatialStructureElement* v);
    IfcSpaceProgram* RelatedSpaceProgram() const;
    void setRelatedSpaceProgram(IfcSpaceProgram* v);
    IfcSpaceProgram* RelatingSpaceProgram() const;
    void setRelatingSpaceProgram(IfcSpaceProgram* v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 4: return IfcUtil::Argument_DOUBLE; case 5: return IfcUtil::Argument_DOUBLE; case 6: return IfcUtil::Argument_ENTITY_INSTANCE; case 7: return IfcUtil::Argument_ENTITY_INSTANCE; case 8: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcRelConnects::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 4: return Type::IfcCountMeasure; case 5: return Type::IfcNormalisedRatioMeasure; case 6: return Type::IfcSpatialStructureElement; case 7: return Type::IfcSpaceProgram; case 8: return Type::IfcSpaceProgram; } return IfcRelConnects::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 4: return "DailyInteraction"; case 5: return "ImportanceRating"; case 6: return "LocationOfInteraction"; case 7: return "RelatedSpaceProgram"; case 8: return "RelatingSpaceProgram"; } return IfcRelConnects::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRelInteractionRequirements (IfcAbstractEntity* e);
    IfcRelInteractionRequirements (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< double > v5_DailyInteraction, boost::optional< double > v6_ImportanceRating, IfcSpatialStructureElement* v7_LocationOfInteraction, IfcSpaceProgram* v8_RelatedSpaceProgram, IfcSpaceProgram* v9_RelatingSpaceProgram);
    typedef IfcTemplatedEntityList< IfcRelInteractionRequirements > list;
};
/// The nesting relationship
/// IfcRelNests is a special type of the general
/// composition/decomposition (or whole/part) relationship
/// IfcRelDecomposes. The nesting relationship can be applied
/// to all non physical subtypes of object and object types, namely
/// processes, controls (like cost items), and resources. The nesting
/// implies an order among the nested parts.
/// EXAMPLE1 A nesting of costs items in a cost
/// schedule is the composition of complex cost items from other cost
/// items. The order of the nested cost items underneath the parent
/// cost item is determined by the order of the list of
/// RelatedObjects.
/// EXAMPLE2 A nesting of work tasks within a work
/// schedule is the composition of a parent work task from more
/// specific sub work tasks. The order of the sub tasks underneath
/// the parent task is determined by the order of the list of
/// RelatedObjects..
/// Decompositions imply a dependency, i.e. the definition of the
/// whole depends on the definition of the parts and the parts depend
/// on the existence of the whole. The behaviour that is implied from
/// the dependency has to be established inside the applications.
/// 
/// HISTORY New entity in IFC Release 2.0
/// 
/// IFC2x4 CHANGE The attributes RelatingObject and RelatedObjects are demoted from the supertype IfcRelDecomposes, and RelatedObjects is refined to be a list. The use of IfcRelNests is repurposed to be a nesting of an ordered collections of parts.
class IfcRelNests : public IfcRelDecomposes {
public:
    virtual unsigned int getArgumentCount() const { return 6; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcRelDecomposes::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcRelDecomposes::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcRelDecomposes::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRelNests (IfcAbstractEntity* e);
    IfcRelNests (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcObjectDefinition* v5_RelatingObject, IfcTemplatedEntityList< IfcObjectDefinition >::ptr v6_RelatedObjects);
    typedef IfcTemplatedEntityList< IfcRelNests > list;
};

class IfcRelOccupiesSpaces : public IfcRelAssignsToActor {
public:
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcRelAssignsToActor::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcRelAssignsToActor::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcRelAssignsToActor::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRelOccupiesSpaces (IfcAbstractEntity* e);
    IfcRelOccupiesSpaces (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcTemplatedEntityList< IfcObjectDefinition >::ptr v5_RelatedObjects, boost::optional< IfcObjectTypeEnum::IfcObjectTypeEnum > v6_RelatedObjectsType, IfcActor* v7_RelatingActor, IfcActorRole* v8_ActingRole);
    typedef IfcTemplatedEntityList< IfcRelOccupiesSpaces > list;
};

class IfcRelOverridesProperties : public IfcRelDefinesByProperties {
public:
    IfcTemplatedEntityList< IfcProperty >::ptr OverridingProperties() const;
    void setOverridingProperties(IfcTemplatedEntityList< IfcProperty >::ptr v);
    virtual unsigned int getArgumentCount() const { return 7; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 6: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } return IfcRelDefinesByProperties::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 6: return Type::IfcProperty; } return IfcRelDefinesByProperties::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 6: return "OverridingProperties"; } return IfcRelDefinesByProperties::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRelOverridesProperties (IfcAbstractEntity* e);
    IfcRelOverridesProperties (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcTemplatedEntityList< IfcObject >::ptr v5_RelatedObjects, IfcPropertySetDefinition* v6_RelatingPropertyDefinition, IfcTemplatedEntityList< IfcProperty >::ptr v7_OverridingProperties);
    typedef IfcTemplatedEntityList< IfcRelOverridesProperties > list;
};
/// The IfcRelProjectsElement is an objectified relationship
/// between an element and one projection element that creates a
/// modifier to the shape of the element. The relationship is defined
/// to be a 1:1 relationship, if an element has more than one
/// projection, several relationship objects have to be used, each
/// pointing to a different projection element. The
/// IfcRelProjectsElement establishes an aggregation
/// relationship between the main element and a sub ordinary addition
/// feature.
/// 
/// NOTE  In contrary the
/// IfcRelAggregates relationship established an aggregation
/// of equal parts to a whole.
/// 
/// The IfcRelProjectsElement implies a Boolean operation of
/// addition for the geometric bodies of the element and the feature
/// element. As with all decomposition relationships it determines:
/// 
/// existence dependency - the RelatedFeatureElement
/// cannot exist without the RelatingElement
/// hierarchical and non-cyclical relationship - the
/// IfcRelProjectsElement can only alter a single
/// IfcElement
/// no spatial containment - the IfcFeatureElementAddition
/// as related element never participates in the hiearchical spatial
/// containment relationship
/// IfcRelContainedInSpatialStructure
/// 
/// HISTORY New entity in
/// Release IFC2x Edition 2.
/// IFC2x4 CHANGE 
/// Supertype changed to IfcRelDecomposes.
class IfcRelProjectsElement : public IfcRelConnects {
public:
    /// Element at which a projection is created by the associated IfcProjectionElement.
    IfcElement* RelatingElement() const;
    void setRelatingElement(IfcElement* v);
    /// Reference to the IfcFeatureElementAddition that defines an addition to the volume of the element, by using a Boolean addition operation. An example is a projection at the associated element.
    IfcFeatureElementAddition* RelatedFeatureElement() const;
    void setRelatedFeatureElement(IfcFeatureElementAddition* v);
    virtual unsigned int getArgumentCount() const { return 6; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 4: return IfcUtil::Argument_ENTITY_INSTANCE; case 5: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcRelConnects::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 4: return Type::IfcElement; case 5: return Type::IfcFeatureElementAddition; } return IfcRelConnects::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 4: return "RelatingElement"; case 5: return "RelatedFeatureElement"; } return IfcRelConnects::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRelProjectsElement (IfcAbstractEntity* e);
    IfcRelProjectsElement (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcElement* v5_RelatingElement, IfcFeatureElementAddition* v6_RelatedFeatureElement);
    typedef IfcTemplatedEntityList< IfcRelProjectsElement > list;
};
/// The objectified relationship,
///   IfcRelReferencedInSpatialStructure is used to
///   assign elements in addition to those levels of the project
///   spatialÿstructure, in which they are referenced, but not
///   primarily contained.ÿ
/// 
/// NOTE ÿThe primary containment relationship between
///   an element and the spatial structure is handled
///   byÿIfcRelContainsInSpatialStructure.
/// 
/// Any element can be referencedÿto zero, one or several
///   levels of the spatial structure. Whereas the
///   IfcRelContainsInSpatialStructure relationship is
///   required to be hierarchical (an element can only be
///   contained in exactly one spatial structure element), the
///   IfcRelReferencedInSpatialStructure is not restricted
///   to be hierarchical.
/// 
/// EXAMPLE A wall might be normally contained within
///   a storey, and since it does not span through several
///   stories, it is not referenced in any additional storey.
///   However a curtain wall might span through several
///   stories, in this case it can be contained within the
///   ground floor, but it would be referenced by all
///   additional stories, it spans.
/// 
/// Predefined spatial structure elements to which elements can
///   be assigned are
/// 
/// site as IfcSite
/// 
/// building as IfcBuilding
/// 
/// storey as IfcBuildingStorey
/// 
/// space as IfcSpace
/// 
/// Elements can also be references in a spatial zone that is provided as IfcSpatialZone.
/// 
/// The same element can be assigned to different spatial
///   structure elements depending on the context.
/// 
/// HISTORY New entity
///   inÿRelease IFC2x Edition 3.
/// 
/// Use Definition
/// Figure 41 shows the use of IfcRelContainedInSpatialStructure and IfcRelReferencedInSpatialStructure to assign an IfcCurtainWallÿto two different levels within the spatial structure. It is primarily contained within the ground floor, and additionally referenced within the first and second floor.
/// 
/// Figure 41 — Relationship for spatial structure referencing
class IfcRelReferencedInSpatialStructure : public IfcRelConnects {
public:
    /// Set of products, which are referenced within this level of the spatial structure hierarchy.
    /// NOTE  Referenced elements are contained elsewhere within the spatial structure, they are referenced additionally by this spatial structure element, e.g., because they span several stories.
    IfcTemplatedEntityList< IfcProduct >::ptr RelatedElements() const;
    void setRelatedElements(IfcTemplatedEntityList< IfcProduct >::ptr v);
    /// Spatial structure element, within which the element is referenced. Any element can be contained within zero, one or many elements of the project spatial and zoning structure.
    /// 
    /// IFC2x Edition 4 CHANGE  The attribute relatingStructure as been promoted to the new supertype IfcSpatialElement with upward compatibility for file based exchange.
    IfcSpatialStructureElement* RelatingStructure() const;
    void setRelatingStructure(IfcSpatialStructureElement* v);
    virtual unsigned int getArgumentCount() const { return 6; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 4: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 5: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcRelConnects::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 4: return Type::IfcProduct; case 5: return Type::IfcSpatialStructureElement; } return IfcRelConnects::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 4: return "RelatedElements"; case 5: return "RelatingStructure"; } return IfcRelConnects::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRelReferencedInSpatialStructure (IfcAbstractEntity* e);
    IfcRelReferencedInSpatialStructure (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcTemplatedEntityList< IfcProduct >::ptr v5_RelatedElements, IfcSpatialStructureElement* v6_RelatingStructure);
    typedef IfcTemplatedEntityList< IfcRelReferencedInSpatialStructure > list;
};

class IfcRelSchedulesCostItems : public IfcRelAssignsToControl {
public:
    virtual unsigned int getArgumentCount() const { return 7; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcRelAssignsToControl::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcRelAssignsToControl::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcRelAssignsToControl::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRelSchedulesCostItems (IfcAbstractEntity* e);
    IfcRelSchedulesCostItems (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcTemplatedEntityList< IfcObjectDefinition >::ptr v5_RelatedObjects, boost::optional< IfcObjectTypeEnum::IfcObjectTypeEnum > v6_RelatedObjectsType, IfcControl* v7_RelatingControl);
    typedef IfcTemplatedEntityList< IfcRelSchedulesCostItems > list;
};
/// IfcRelSequence is a
///   sequential relationship between processes where one process
///   must occur before the other in time and where the timing of
///   the relationship may be described as a type of sequence.
///   The relating process
///   (IfcRelSequence.RelatingProcess) is considered to be
///   the predecessor in the relationship (has precedence) whilst
///   the related process (IfcRelSequence.RelatedProcess)
///   is the successor.
/// 
/// IfcRelSequence is defined as one-to-one
///   relationship; therefore it assigns one predecessor to one
///   successor.
/// 
/// HISTORY  New entity in IFC 1.0.
/// 
/// IFC2x4 CHANGE  Relocated to IfcProcessExtension schema.
///   TimeLag and SequenceType made optional.
///   USERDEFINED added to the IfcSequenceType
///   enumeration. UserDefinedSequenceType attribute
///   added. WHERE rule controlling use of the USERDEFINED
///   enumeration added.
/// 
/// Use definitions
/// 
/// IfcRelSequence is used to describe the logical
///   sequence relationship that exists between two processes.
///   This logical relationship identifies that there is a
///   predecessor or relating process and a successor or related
///   process. In IFC, there may be one predecessor and one
///   successor in the relationship. Many occurrences of
///   IfcRelSequence may exist to describe the sequence
///   relationships of a predecessor task with many successor
///   tasks or of many predecessor tasks with one successor task,
///   thus enabling a m:n sequence relationship between tasks.
///   Please note that sequence relationships always should stay
///   within the limits of a directed, non-cyclic graph.
/// 
/// A sequence type may be set for a sequence. For tasks
///   assigned to a work schedule, it is expected that the
///   sequence type will be asserted. For a process map, where
///   the sequence relationship between processes is simply a
///   logical flow, it need not be asserted.
/// 
/// A time lag may be assigned to a sequence, and the sequence
///   type defines the way in which the time lag applies to the
///   sequence either as a ratio or percentage of time duration
///   (e.g. start successor task when predecessor is 50%
///   complete) or as a time measure (e.g. start successor task 1
///   week after commencement of the predecessor task). Care
///   should be used when assigning a time lag to a sequence
///   depending on the setting of the sequence type since there
///   is no checking that the time lag value is in keeping with
///   the sequence type set.
class IfcRelSequence : public IfcRelConnects {
public:
    /// Reference to the process, that is the predecessor.
    IfcProcess* RelatingProcess() const;
    void setRelatingProcess(IfcProcess* v);
    /// Reference to the process, that is the successor.
    IfcProcess* RelatedProcess() const;
    void setRelatedProcess(IfcProcess* v);
    /// Time duration of the sequence, it is the time lag between the
    ///   predecessor and the successor as specified by the
    ///   SequenceType.
    double TimeLag() const;
    void setTimeLag(double v);
    /// The way in which the time lag applies to the sequence.
    IfcSequenceEnum::IfcSequenceEnum SequenceType() const;
    void setSequenceType(IfcSequenceEnum::IfcSequenceEnum v);
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 4: return IfcUtil::Argument_ENTITY_INSTANCE; case 5: return IfcUtil::Argument_ENTITY_INSTANCE; case 6: return IfcUtil::Argument_DOUBLE; case 7: return IfcUtil::Argument_ENUMERATION; } return IfcRelConnects::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 4: return Type::IfcProcess; case 5: return Type::IfcProcess; case 6: return Type::IfcTimeMeasure; case 7: return Type::IfcSequenceEnum; } return IfcRelConnects::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 4: return "RelatingProcess"; case 5: return "RelatedProcess"; case 6: return "TimeLag"; case 7: return "SequenceType"; } return IfcRelConnects::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRelSequence (IfcAbstractEntity* e);
    IfcRelSequence (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcProcess* v5_RelatingProcess, IfcProcess* v6_RelatedProcess, double v7_TimeLag, IfcSequenceEnum::IfcSequenceEnum v8_SequenceType);
    typedef IfcTemplatedEntityList< IfcRelSequence > list;
};
/// Definition from IAI: An objectified relationship
///   that defines the relationship between a system and the
///   sites, buildings, storeys or spaces, it serves. Examples of
///   systems are:
/// 
/// building service systems (heating, cooling, waste water
///   system) represented by instances of IfcSystem
/// 
/// idealized structural analysis systems represented by
///   instances of IfcStructuralAnalysisSystem
/// 
/// HISTORY New entity in IFC
///   Release 1.0
/// 
/// IFC2x PLATFORM CHANGEÿ The
///   data type of the attributeRelatedBuildings has been
///   changed from IfcBuilding to its supertype
///   IfcSpatialStructureElement with upward compatibility
///   for file based exchange. The name
///   IfcRelServicesBuildings is a knownÿanomaly, as the
///   relationship is not restricted to buildings anymore.
class IfcRelServicesBuildings : public IfcRelConnects {
public:
    /// System that services the Buildings.
    IfcSystem* RelatingSystem() const;
    void setRelatingSystem(IfcSystem* v);
    /// Spatial structure elements (including site, building, storeys) that are serviced by the system.
    /// 
    /// IFC2x PLATFORM CHANGE  The data type has been changed from IfcBuilding to IfcSpatialStructureElement with upward compatibility for file based exchange.
    /// 
    /// IFC2x Edition 4 CHANGE  The data type has been changed from IfcSpatialStructureElement to IfcSpatialElement with upward compatibility for file based exchange.
    IfcTemplatedEntityList< IfcSpatialStructureElement >::ptr RelatedBuildings() const;
    void setRelatedBuildings(IfcTemplatedEntityList< IfcSpatialStructureElement >::ptr v);
    virtual unsigned int getArgumentCount() const { return 6; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 4: return IfcUtil::Argument_ENTITY_INSTANCE; case 5: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } return IfcRelConnects::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 4: return Type::IfcSystem; case 5: return Type::IfcSpatialStructureElement; } return IfcRelConnects::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 4: return "RelatingSystem"; case 5: return "RelatedBuildings"; } return IfcRelConnects::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRelServicesBuildings (IfcAbstractEntity* e);
    IfcRelServicesBuildings (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcSystem* v5_RelatingSystem, IfcTemplatedEntityList< IfcSpatialStructureElement >::ptr v6_RelatedBuildings);
    typedef IfcTemplatedEntityList< IfcRelServicesBuildings > list;
};
/// The space boundary defines the
/// physical or virtual delimiter of a space by the relationship
/// IfcRelSpaceBoundary to the surrounding elements.
/// 
/// In the case of a physical space boundary, the placement and
/// shape of the boundary may be given, and the building element,
/// providing the boundary, is referenced,
/// In the case of a virtual space boundary, the placement and
/// shape of the boundary may be given, but no building element is
/// referenced and a virtual element is
/// referenced instead.
/// 
/// The IfcRelSpaceBoundary is defined as an objectified
/// relationship that handles the element to space relationship by
/// objectifying the relationship between an element and the space it
/// bounds. It is given as a one-to-one relationship, but allows each
/// element (including virutal elements and openings) to define many
/// such relationship and each space to be defined by many such
/// relationships.
/// Space boundaries are always defined as seen from the space. In
/// general two basic types of space boundaries are
/// distinguished:
/// 
/// 1st level space boundary: defined
/// as boundaries of the space, not taking into account any change in
/// building element or spaces on the other side.
/// 2nd level space boundary: defined
/// as boundary taking any change in building element or spaces on
/// the other side into account. It can be further distinguished into
/// 
/// 2nd level type A: There is a space
/// on the other side.
/// 2nd level type B: There is a
/// building element on the other side.
/// 
/// The exact definition of how space boundaries
/// are broken down depends on the view definition, more detailed
/// conventions on how space boundaries are decomposed can only be
/// given at the domain or application type level.
/// 
/// In an architectural or FM related view, a space
/// boundary is defined totally from inside the space. This is a
/// 1st level space boundary.
/// In a thermal view, the decomposition of the space
/// boundary depends on the material of the providing building
/// element and the adjacent spaces behind. This is a
/// 2nd level space boundary.
/// 
/// Figure 42 — Space boundary at first level
/// Figure 43 — Space boundary at second level
/// 
/// Figure 44 — Space boundary at second level type A
/// Figure 45 — Space boundary at second level type B
/// 
/// HISTORY New entity in IFC Release 1.5, the entity has been modified in IFC Release
/// 2x.
/// IFC2x CHANGE The data type of the attributeRelatedBuildingElement has
/// been changed from IfcBuildingElement to its supertype IfcElement. The data type of the attribute
/// ConnectionGeometry has been changed from IfcConnectionSurfaceGeometry to its supertype
/// IfcConnectionGeometry.
/// IFC2x4 CHANGE The attribute RelatedBuildingElement has been made mandatory. For virtual boundaries the reference to IfcVirtualElement is now mandatory.
/// 
/// Attribute Use Definitions
/// The differences between the 1st and
/// 2nd level space boundaries is
/// identified by:
/// 
/// 1st level:
/// SELF\IfcRoot.Name = "1stLevel"
/// SELF\IfcRootDescription = NIL
/// 2nd level:
/// SELF\IfcRoot.Name = "2ndLevel"
/// SELF\IfcRootDescription = "2a", or "2b"
/// 
/// Differentiation between physical and virtual space boundary is illustrated in Figure 46 and Figure 47.
/// 
/// As shown in Figure 46, if the IfcRelSpaceBoundary is used to express a virtual boundary, the attribute PhysicalOrVirtualBoundary has to be set to VIRTUAL. The attribute RelatedBuildingElement shall point to an instance of IfcVirtualElement. If the correct location is of interest, the attribute ConnectionGeometry is required.
/// NOTE The connection geometry, either by a 2D curve or a 3D surface, is used to describe the portion of the "virtual wall" that separates the two spaces. All instances of IfcRelSpaceBoundary given at the adjacent spaces share the same instance of IfcVirtualElement. Each instance of IfcRelSpaceBoundary provides in addition the ConnectionGeometry given within the local placement of each space.
/// 
/// Figure 46 — Space boundary of virtual element
/// 
/// As shown in Figure 47, if the IfcRelSpaceBoundary is used to express a physical boundary between two spaces, the attribute PhysicalOrVirtualBoundary has to be set to PHYSICAL. The attribute RelatedBuildingElement has to be given and points to the element providing the space boundary. The attribute ConnectionGeometry may be inserted, in this case it describes the physical space boundary geometically, or it may be omited, in that case it describes a physical space boundary logically.
/// 
/// Figure 47 — Space boundary of physical element
/// 
/// Geometry Use Definitions
/// The IfcRelSpaceBoundary may have geometry attached. If
/// geometry is not attached, the relationship between space and
/// building element is handled only on a logical level. If geometry
/// is attached, it is given within the local coordinate systems of
/// the space.
/// NOTE: The attributes
/// CurveOnRelatingElement at
/// IfcConnectionCurveGeometry or
/// SurfaceOnRelatingElement at
/// IfcConnectionSurfaceGeometry provide the geometry within
/// the local coordinate system of the IfcSpace, whereas the
/// attributes CurveOnRelatedElement at
/// IfcConnectionCurveGeometry or
/// SurfaceOnRelatedElement at
/// IfcConnectionSurfaceGeometry provide the geometry within
/// the local coordinate system of the subtype of
/// IfcElement.
/// NOTE In most view definitions the connection geometry for
/// the related IfcElement is not
/// provided.
/// The geometric representation (through the
/// ConnectionGeometry attribute) is defined using either 2D
/// curve geometry or 3D surface geometry for space boundaries. In
/// most view definitions the 3D connection surface geometry is
/// required.
/// 
/// 1st level space boundary:
/// 
/// only connection geometry for related space shall be
/// provided
/// only surface connection geometry shall be provided
/// only the following surface representations are supported:
/// 
/// IfcSurfaceOfLinearExtrusion
/// IfcCurveBoundedPlane
/// IfcCurveBoundedSurface
/// IfcFaceBasedSurfaceModel
/// 
/// 2nd level space boundary:
/// 
/// only connection geometry for related space shall be
/// provided
/// only surface connection geometry shall be provided
/// only the following surface representations are supported:
/// 
/// IfcCurveBoundedPlane with restrictions to have
/// polygonal boundaries only
/// IfcFaceBasedSurfaceModel
/// 
/// Surface connection geometry
/// The following constraints apply to the surface connection
/// geometry representation:
/// 
/// planar boundaries:
/// 
/// IfcSurfaceOfLinearExtrusion defined by a
/// SweptCurve being an IfcArbitraryOpenProfileDef with
/// straight segements, or
/// IfcCurveBoundedPlane
/// 
/// curved boundaries
/// 
/// IfcSurfaceOfLinearExtrusion defined by a
/// SweptCurve being an IfcArbitraryOpenProfileDef with
/// curves segements, or
/// IfcCurveBoundedSurface with a BasisSurface
/// being a non planar surface, such as IfcCylindricalSurface,
/// or
/// IfcFaceBasedSurfaceModel if already faceted.
/// 
/// Curve connection geometry
/// The following constraints apply to the 2D curve
/// representation:
/// 
/// Curve: IfcPolyline, IfcTrimmedCurve or
/// IfcCompositeCurve
class IfcRelSpaceBoundary : public IfcRelConnects {
public:
    /// Reference to one spaces that is delimited by this boundary.
    IfcSpace* RelatingSpace() const;
    void setRelatingSpace(IfcSpace* v);
    /// Whether the optional attribute RelatedBuildingElement is defined for this IfcRelSpaceBoundary
    bool hasRelatedBuildingElement() const;
    /// Reference to Building Element, that defines the Space Boundaries.
    /// 
    /// IFC2x PLATFORM CHANGE  The data type has been changed from IfcBuildingElement to IfcElement with upward compatibility for file based exchange.
    /// 
    /// IFC2x4 CHANGE  The attribute has been changed to be mandatory.
    IfcElement* RelatedBuildingElement() const;
    void setRelatedBuildingElement(IfcElement* v);
    /// Whether the optional attribute ConnectionGeometry is defined for this IfcRelSpaceBoundary
    bool hasConnectionGeometry() const;
    /// Physical representation of the space boundary. Provided as a curve or surface given within the LCS of the space.
    /// 
    /// IFC2x PLATFORM CHANGE  The data type has been changed from IfcConnectionSurfaceGeometry to IfcConnectionGeometry with upward compatibility for file based exchange.
    IfcConnectionGeometry* ConnectionGeometry() const;
    void setConnectionGeometry(IfcConnectionGeometry* v);
    /// Defines, whether the Space Boundary is physical (Physical) or virtual (Virtual).
    IfcPhysicalOrVirtualEnum::IfcPhysicalOrVirtualEnum PhysicalOrVirtualBoundary() const;
    void setPhysicalOrVirtualBoundary(IfcPhysicalOrVirtualEnum::IfcPhysicalOrVirtualEnum v);
    /// Defines, whether the Space Boundary is internal (Internal), or external, i.e. adjacent to open space (that can be an partially enclosed space, such as terrace (External).
    IfcInternalOrExternalEnum::IfcInternalOrExternalEnum InternalOrExternalBoundary() const;
    void setInternalOrExternalBoundary(IfcInternalOrExternalEnum::IfcInternalOrExternalEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 4: return IfcUtil::Argument_ENTITY_INSTANCE; case 5: return IfcUtil::Argument_ENTITY_INSTANCE; case 6: return IfcUtil::Argument_ENTITY_INSTANCE; case 7: return IfcUtil::Argument_ENUMERATION; case 8: return IfcUtil::Argument_ENUMERATION; } return IfcRelConnects::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 4: return Type::IfcSpace; case 5: return Type::IfcElement; case 6: return Type::IfcConnectionGeometry; case 7: return Type::IfcPhysicalOrVirtualEnum; case 8: return Type::IfcInternalOrExternalEnum; } return IfcRelConnects::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 4: return "RelatingSpace"; case 5: return "RelatedBuildingElement"; case 6: return "ConnectionGeometry"; case 7: return "PhysicalOrVirtualBoundary"; case 8: return "InternalOrExternalBoundary"; } return IfcRelConnects::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRelSpaceBoundary (IfcAbstractEntity* e);
    IfcRelSpaceBoundary (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcSpace* v5_RelatingSpace, IfcElement* v6_RelatedBuildingElement, IfcConnectionGeometry* v7_ConnectionGeometry, IfcPhysicalOrVirtualEnum::IfcPhysicalOrVirtualEnum v8_PhysicalOrVirtualBoundary, IfcInternalOrExternalEnum::IfcInternalOrExternalEnum v9_InternalOrExternalBoundary);
    typedef IfcTemplatedEntityList< IfcRelSpaceBoundary > list;
};
/// IfcRelVoidsElement is an objectified relationship between a building element and one opening element that creates a void in the element. It is a one-to-one relationship. This relationship implies a Boolean operation of subtraction between the geometric bodies of the element and the opening.
/// 
/// As shown in Figure 50, the insertion of a void into a wall is represented by the relationship IfcRelVoidsElement. The opening is created within the wall by IfcWall(StandardCase) o-- IfcRelVoidsElement --o IfcOpeningElement.
/// 
/// Figure 50 — Relationship for element voiding
/// 
/// HISTORY New entity in IFC Release 1.0
class IfcRelVoidsElement : public IfcRelConnects {
public:
    IfcElement* RelatingBuildingElement() const;
    void setRelatingBuildingElement(IfcElement* v);
    IfcFeatureElementSubtraction* RelatedOpeningElement() const;
    void setRelatedOpeningElement(IfcFeatureElementSubtraction* v);
    virtual unsigned int getArgumentCount() const { return 6; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 4: return IfcUtil::Argument_ENTITY_INSTANCE; case 5: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcRelConnects::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 4: return Type::IfcElement; case 5: return Type::IfcFeatureElementSubtraction; } return IfcRelConnects::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 4: return "RelatingBuildingElement"; case 5: return "RelatedOpeningElement"; } return IfcRelConnects::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRelVoidsElement (IfcAbstractEntity* e);
    IfcRelVoidsElement (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcElement* v5_RelatingBuildingElement, IfcFeatureElementSubtraction* v6_RelatedOpeningElement);
    typedef IfcTemplatedEntityList< IfcRelVoidsElement > list;
};
/// IfcResource contains the information needed to represent the costs, schedule, and other impacts from the use of a thing in a process. It is not intended to use IfcResource to model the general properties of the things themselves, while an optional linkage from IfcResource to the things to be used can be specified (specifically, the relationship from subtypes of IfcResource to IfcProduct through the IfcRelAssignsToResource relationship).  
/// 
/// There are two basic intended uses of IfcResource. First, if the attributes of the thing are not needed for the purpose of the use of IfcResource, or the types of things are not explicitly modeled in IFC yet, then the linkage between the resource and the thing doesn't have to be instantiated in the system. That is, the attributes of IfcResource (or its subtypes) alone are sufficient to represent the use of the thing as a resource for the purpose of the project.  
/// 
/// EXAMPLE: construction equipment such as earth-moving vehicles or tools are not currently modeled within the IFC. For the purpose of estimating and scheduling, these can be represented using subtypes of IfcResource alone.
/// 
/// Second, if the attributes of the thing are needed for the use of IfcResource objects, and they are modeled explicitly as objects, then the IfcResource instances can be linked to the instances of the type of the things being referenced. Things that might be used as resources and that are already modeled in the IFC include physical products, people and organizations, and materials. The relationship object IfcRelAssignsToResource is provided for this approach. 
/// 
/// The inherited attribute ObjectType is used as a textual code that identifies the resource type.  
/// 
/// HISTORY New entity in IFC Release 1.0
/// 
/// IFC2x PLATFORM CHANGE: The attributes BaseUnit and ResourceConsumption have been removed from the abstract entity; they are reintroduced at a lower level in the hierarchy.
class IfcResource : public IfcObject {
public:
    virtual unsigned int getArgumentCount() const { return 5; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcObject::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcObject::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcObject::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcRelAssignsToResource >::ptr ResourceOf() const; // INVERSE IfcRelAssignsToResource::RelatingResource
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcResource (IfcAbstractEntity* e);
    IfcResource (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType);
    typedef IfcTemplatedEntityList< IfcResource > list;
};
/// An IfcRevolvedAreaSolid is a solid created by revolving
/// a cross section provided by a profile definition about an axis. The
/// axis and the cross section shall be in the same plane.
/// NOTE Both the axis and the cross section are
/// required to lie in the xy plane of the object position coordinate
/// system.
/// The following definitions from ISO 10303-42 apply:
/// 
/// A revolved area solid
/// is a solid formed by revolving a planar bounded surface about an
/// axis. The axis shall be in the plane of the surface and the axis
/// shall not intersect the interior of the bounded surface. The
/// bounded surface may have holes which will sweep into holes in the
/// solid. The direction of revolution is clockwise when viewed along
/// the axis in the positive direction. More precisely if A is
/// the axis location and d is the axis direction and C
/// is an arc on the surface of revolution generated by an arbitrary
/// point p on the boundary of the swept area, then C
/// leaves p in direction d x (p - A) as
/// the area is revolved.
/// 
/// Figure 262 illustrates geometric parameters of the revolved solid. The revolved area solid defines the revolution of a 2D area (given by a profile definition) by an axis and angle. The result is a solid. The swept area is given by a profile definition. This profile is defined: 
/// 
/// as a 2D bounded curve within the xy plane of the position coordinate system,
/// as a 2D bounded curve with holes within the xy plane of the position coordinate system,
/// or as a 2D primitive, defined within a 2D position coordinate system, that is placed relative to the xy plane of the position coordinate system
/// 
/// The AxisLine can have any orientation within the XY plane, it does not have to be parallel to the y-axis as shown in the illustration.
/// 
/// Figure 262 — Revolved area solid geometry
/// 
/// NOTE  Corresponding ISO 10303-42 entity: revolved_area_solid. Please refer to ISO/IS 10303-42:1994, p. 184 for the final definition of the formal standard. The data type of the inherited SweptArea attribute is different, i.e. of type IfcProfileDef. The position attribute has been added to position the cross section used for the revolution.
/// 
/// HISTORY  New entity in IFC Release 1.5, capabilities of this entity have been enhanced in IFC Release 2x.
/// 
/// Informal propositions:
/// 
/// The AxisLine shall lie in the plane of the
/// SweptArea (as defined at supertype
/// IfcSweptAreaSolid).
/// The AxisLine shall not intersect the interior of the
/// SweptArea (as defined at supertype
/// IfcSweptAreaSolid).
/// The Angle shall be between 0° and 360°, or 0
/// and 2π (depending on the unit type for
/// IfcPlaneAngleMeasure).
/// 
/// Texture Use Definition
/// For side faces, textures are aligned facing upright along the
/// sides with origin at the first point of an arbitrary profile, and
/// following the outer bound of the profile counter-clockwise (as seen
/// from above). For parameterized profiles, the origin is defined at
/// the +Y extent for rounded profiles (having no sharp edge) and the
/// first sharp edge counter-clockwise from the +Y extent for all other
/// profiles. Textures are stretched or repeated on each side along the
/// outer boundary of the profile according to RepeatS.
/// Textures are stretched or repeated on each side along the outermost
/// (longest) revolution path according to RepeatT, where
/// coordinates are compressed towards the axis of revolution.
/// For top and bottom caps, textures are aligned facing
/// front-to-back, with the origin at the minimum X and Y extent.
/// Textures are stretched or repeated on the top and bottom to the
/// extent of each face according to RepeatS and
/// RepeatT.
/// For profiles with voids, textures are aligned facing upright
/// along the inner side with origin at the first point of an arbitrary
/// profile, and following the inner bound of the profile clockwise (as
/// seen from above). For parameterized profiles, the origin of inner
/// sides is defined at the +Y extent for rounded profiles (having no
/// sharp edge such as hollow ellipses or rounded rectangles) and the
/// first sharp edge clockwise from the +Y extent for all other
/// profiles.
/// 
/// Figure 263 illustrates default texture mapping with a repeated texture (RepeatS=True and RepeatT=True). The image on the left shows the texture where the S axis points to the right and the T axis points up. The image on the right shows the texture applied to the geometry where the X axis points back to the right, the Y axis points back to the left, and the Z axis points up. For an IfcRevolvedAreaSolid having a profile of IfcTShapeProfileDef and revolved at 22.5 degrees, the side texture coordinate origin is the first corner counter-clockwise from the +Y axis, which equals (-0.5*IfcTShapeProfileDef.OverallWidth, +0.5*IfcTShapeProfileDef.OverallDepth), while the top (end cap) texture coordinates start at (-0.5*IfcTShapeProfileDef.OverallWidth, -0.5*IfcTShapeProfileDef.OverallDepth).
/// 
/// Figure 263 — Revolved area solid textures
class IfcRevolvedAreaSolid : public IfcSweptAreaSolid {
public:
    /// Axis about which revolution will take place.
    IfcAxis1Placement* Axis() const;
    void setAxis(IfcAxis1Placement* v);
    /// The angle through which the sweep will be made. This angle is measured from the plane of the swept area provided by the XY plane of the position coordinate system.
    double Angle() const;
    void setAngle(double v);
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 2: return IfcUtil::Argument_ENTITY_INSTANCE; case 3: return IfcUtil::Argument_DOUBLE; } return IfcSweptAreaSolid::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 2: return Type::IfcAxis1Placement; case 3: return Type::IfcPlaneAngleMeasure; } return IfcSweptAreaSolid::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 2: return "Axis"; case 3: return "Angle"; } return IfcSweptAreaSolid::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRevolvedAreaSolid (IfcAbstractEntity* e);
    IfcRevolvedAreaSolid (IfcProfileDef* v1_SweptArea, IfcAxis2Placement3D* v2_Position, IfcAxis1Placement* v3_Axis, double v4_Angle);
    typedef IfcTemplatedEntityList< IfcRevolvedAreaSolid > list;
};
/// The IfcRightCircularCone is a Construction Solid
/// Geometry (CSG) 3D primitive. It is a solid with a circular base and
/// a point called apex as the top. The tapers from the base to the
/// top. The axis from the center of the circular base to the apex is
/// perpendicular to the base. The inherited Position
/// attribute defines the IfcAxisPlacement3D and provides the
/// location and orientation of the cone:
/// 
/// SELF\IfcCsgPrimitive3D.Position: The location and
/// orientation of the axis system for the primitive. 
/// SELF\IfcCsgPrimitive3D.Position.Location: The center
/// of the circular area being the bottom face of the cone.
/// SELF\IfcCsgPrimitive3D.Position.Position[3]: The
/// z-axis of the inherited placement coordinate system provides the
/// center axis of the IfcRightCircularCone, and the apex is
/// at the Height value applied to the positive direction of
/// the z-axis. The BottomRadius defines the circular base at
/// the xy-plane of the placement coordinate system.
/// 
/// Figure 264 illustrates geometric parameters of the cone. The cone is positioned within its own placement coordinate system. The origin is the center of the bottom circular disk, that lies in the XY plane. The apex lies on the positive z axis at [0, 0, Height].
/// 
/// Figure 264 — Right circular cone geometry
/// 
/// NOTE  Corresponding ISO 10303 entity: right_circular_cone, the position attribute has been promoted to the immediate supertype IfcCsgPrimitive3D. No semi_angle attribute, and the radius defines the bottom radius, since only a non-truncated cone is in scope. Please refer to ISO/IS 10303-42:1994, p. 176 for the final definition of the formal standard.
/// 
/// HISTORY  New entity in IFC2x3
/// 
/// Texture use definition
/// On the circular side, textures are aligned facing upright with
/// origin at the back (+Y direction) revolving counter-clockwise.
/// Textures are stretched or repeated to the extent of the base
/// circumference according to RepeatS. Textures are compressed
/// linearly going upwards towards the top point according to
/// RepeatT.
/// On the bottom face, textures are aligned facing front-to-back,
/// with the center of the circle aligned to the center of the
/// texture.
/// 
/// Figure 265 illustrates default texture mapping with a clamped texture (RepeatS=False and RepeatT=False). The image on the left shows the texture where the S axis points to the right and the T axis points up. The image on the right shows the texture applied to the geometry where the X axis points back to the right, the Y axis points back to the left, and the Z axis points up.
/// 
/// Side
/// Normal
/// Origin X
/// Origin Y
/// Origin Z
/// S Axis
/// T Axis
/// 
/// Side
/// -Y
/// 0
/// +Radius
/// 0
/// -X
/// (towards top point)
/// 
/// Bottom
/// -Z
/// 0
/// 0
/// 0
/// -X
/// +Y
/// 
/// Figure 265 — Right circular cone textures
class IfcRightCircularCone : public IfcCsgPrimitive3D {
public:
    /// The distance between the base of the cone and the apex.
    double Height() const;
    void setHeight(double v);
    /// The radius of the cone at the base.
    double BottomRadius() const;
    void setBottomRadius(double v);
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 1: return IfcUtil::Argument_DOUBLE; case 2: return IfcUtil::Argument_DOUBLE; } return IfcCsgPrimitive3D::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 1: return Type::IfcPositiveLengthMeasure; case 2: return Type::IfcPositiveLengthMeasure; } return IfcCsgPrimitive3D::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 1: return "Height"; case 2: return "BottomRadius"; } return IfcCsgPrimitive3D::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRightCircularCone (IfcAbstractEntity* e);
    IfcRightCircularCone (IfcAxis2Placement3D* v1_Position, double v2_Height, double v3_BottomRadius);
    typedef IfcTemplatedEntityList< IfcRightCircularCone > list;
};
/// The IfcRightCircularCylinder is a Construction Solid
/// Geometry (CSG) 3D primitive. It is a solid with a circular base and
/// top. The cylindrical surface between if formed by points at a fixed
/// distance from the axis of the cylinder. The inherited
/// Position attribute defines the IfcAxisPlacement3D
/// and provides:
/// 
/// SELF\IfcCsgPrimitive3D.Position: The location and
/// orientation of the axis system for the primitive.
/// SELF\IfcCsgPrimitive3D.Position.Location: The center
/// of the circular area being the bottom face of the cylinder.
/// SELF\IfcCsgPrimitive3D.Position.Position[3]: The z
/// axis provides the center axis and the height is measured from the
/// origin along the positive direction of the z axis.
/// 
/// The following definitions from ISO 10303-42 apply:
/// 
/// A right circular
/// cylinder is a CSG primitive in the form of a solid cylinder of
/// finite height. It is defined by an axis point at the centre of one
/// planar circular face, an axis, a height, and a radius. The faces
/// are perpendicular to the axis and are circular discs with the
/// specified radius. The height is the distance from the first
/// circular face centre in the positive direction of the axis to the
/// second circular face centre.
/// 
/// Figure 266 illustrates geometric parameters of the cylinder. The cylinder is positioned within its own placement coordiante system. The origin is the center of the bottom circular disk, that lies in the XY plane. The center of the top circular disk is on the positive z axis at [0, 0, Height].
/// 
/// Figure 266 — Right circular cylinder geometry
/// 
/// NOTE  Corresponding ISO 10303 entity: right_circular_cyclinder, the position attribute has been promoted to the immediate supertype IfcCsgPrimitive3D. Please refer to ISO/IS 10303-42:1994, p. 177 for the definition in the international standard.
/// 
/// HISTORY  New entity in IFC2x3.
/// 
/// Texture use definition
/// On the circular side, textures are aligned facing upright with
/// origin at the back (+Y direction) revolving counter-clockwise.
/// Textures are stretched or repeated to the extent of the
/// circumference according to RepeatS. Textures are stretched or
/// repeated to the extent of the Height according to
/// RepeatT.
/// On the top and bottom faces, textures are aligned facing
/// front-to-back, with the center of the circle aligned to the center
/// of the texture.
/// 
/// Figure 267 illustrates default texture mapping with a clamped texture (RepeatS=False and RepeatT=False). The image on the left shows the texture where the S axis points to the right and the T axis points up. The image on the right shows the texture applied to the geometry where the X axis points back to the right, the Y axis
/// points back to the left, and the Z axis points up.
/// 
/// Side
/// Normal
/// Origin X
/// Origin Y
/// Origin Z
/// S Axis
/// T Axis
/// 
/// Side
/// -Y
/// 0
/// +Radius
/// 0
/// -X
/// +Z
/// 
/// Bottom
/// -Z
/// 0
/// 0
/// 0
/// -X
/// +Y
/// 
/// Top
/// +Z
/// 0
/// 0
/// +Height
/// +X
/// +Y
/// 
/// Figure 267 — Right circular cylinder textures
class IfcRightCircularCylinder : public IfcCsgPrimitive3D {
public:
    /// The distance between the planar circular faces of the cylinder.
    double Height() const;
    void setHeight(double v);
    /// The radius of the cylinder.
    double Radius() const;
    void setRadius(double v);
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 1: return IfcUtil::Argument_DOUBLE; case 2: return IfcUtil::Argument_DOUBLE; } return IfcCsgPrimitive3D::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 1: return Type::IfcPositiveLengthMeasure; case 2: return Type::IfcPositiveLengthMeasure; } return IfcCsgPrimitive3D::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 1: return "Height"; case 2: return "Radius"; } return IfcCsgPrimitive3D::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRightCircularCylinder (IfcAbstractEntity* e);
    IfcRightCircularCylinder (IfcAxis2Placement3D* v1_Position, double v2_Height, double v3_Radius);
    typedef IfcTemplatedEntityList< IfcRightCircularCylinder > list;
};
/// A spatial structure element
/// (IfcSpatialStructureElement) is the generalization of all
/// spatial elements that might be used to define a spatial
/// structure. That spatial structure is often used to provide a
/// project structure to organize a building project.
/// A spatial project structure might define as many levels of
/// decomposition as necessary for the building project. Elements
/// within the spatial project structure are:
/// 
/// site as IfcSite
/// building as IfcBuilding
/// storey as IfcBuildingStorey
/// space as IfcSpace
/// 
/// or aggregations or parts thereof. The composition type
/// declares an element to be either an element itself, or an
/// aggregation (complex) or a decomposition (part). The
/// interpretation of these types is given at each subtype of
/// IfcSpatialStructureElement.
/// The IfcRelAggregates is defined as an 1-to-many
/// relationship and used to establish the relationship between
/// exactly two levels within the spatial project structure. Finally
/// the highest level of the spatial structure is assigned to
/// IfcProject using the IfcRelAggregates.
/// Informal proposition:
/// 
/// The spatial project structure, established by the
/// IfcRelAggregates, shall be acyclic.
/// A site should not be (directly or indirectly) associated to a
/// building, storey or space.
/// A building should not be (directly or indirectly) associated
/// to a storey or space.
/// A storey should not be (directly or indirectly) associated to
/// a space.
/// 
/// HISTORY New entity in IFC Release 2x.
/// 
/// Relationship Use Definition
/// The subtypes of IfcSpatialStructureElement relate to
/// other elements and systems by establishing the following
/// relationships:
/// 
/// Containment of elements :
/// IfcRelContainedInSpatialStructure by inverse attribute
/// ContainsElements, used to assign any element, like
/// building elements, MEP elements, etc. to the spatial structure
/// element in which they are primarily contained.
/// 
/// NOTE This relationship is
/// mandatory for elements in several view definitions and
/// implementer agreements.
/// 
/// Reference of elements :
/// IfcRelReferencedInSpatialStructure by inverse attribute
/// ReferencesElements, used to reference any element, like
/// building elements, MEP elements, etc. in spatial structure
/// elements, other then the one, where it is contained.
/// Reference of systems : IfcRelServicesBuildings
/// by inverse attribute ServicedBySystems, used to reference
/// a sytem, like a building service or electrical distribution
/// system, a zonal system, or a structural analysis system, that is
/// assigned to this spatial structure element.
/// 
/// NOTE Elements within the
/// referenced system may be directly contained (or referenced) by
/// other spatial structure elements.
/// 
/// The subtypes of IfcSpatialStructureElement relate to
/// each other by using the IfcRelAggregates relationship to
/// build the project spatial structure.
/// 
/// Figure 62 shows the use of IfcRelAggregates to establish a spatial structure including site, building, building section and storey. More information is provided at the level of the subtypes.
/// 
/// Figure 62 — Spatial structure element composition
class IfcSpatialStructureElement : public IfcProduct {
public:
    /// Whether the optional attribute LongName is defined for this IfcSpatialStructureElement
    bool hasLongName() const;
    std::string LongName() const;
    void setLongName(std::string v);
    /// Denotes, whether the predefined spatial structure element represents itself, or an aggregate (complex) or a part (part). The interpretation is given separately for each subtype of spatial structure element. If no CompositionType is asserted, the dafault value 'ELEMENT' applies.
    /// 
    /// IFC2x4 CHANGE&nbsp
    ///   Attribute made optional.
    IfcElementCompositionEnum::IfcElementCompositionEnum CompositionType() const;
    void setCompositionType(IfcElementCompositionEnum::IfcElementCompositionEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 7: return IfcUtil::Argument_STRING; case 8: return IfcUtil::Argument_ENUMERATION; } return IfcProduct::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 7: return Type::IfcLabel; case 8: return Type::IfcElementCompositionEnum; } return IfcProduct::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 7: return "LongName"; case 8: return "CompositionType"; } return IfcProduct::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcRelReferencedInSpatialStructure >::ptr ReferencesElements() const; // INVERSE IfcRelReferencedInSpatialStructure::RelatingStructure
    IfcTemplatedEntityList< IfcRelServicesBuildings >::ptr ServicedBySystems() const; // INVERSE IfcRelServicesBuildings::RelatedBuildings
    IfcTemplatedEntityList< IfcRelContainedInSpatialStructure >::ptr ContainsElements() const; // INVERSE IfcRelContainedInSpatialStructure::RelatingStructure
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcSpatialStructureElement (IfcAbstractEntity* e);
    IfcSpatialStructureElement (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_LongName, IfcElementCompositionEnum::IfcElementCompositionEnum v9_CompositionType);
    typedef IfcTemplatedEntityList< IfcSpatialStructureElement > list;
};
/// Definition from IAI: The element type
///   (IfcSpatialStructureElementType) defines a list of
///   commonly shared property set definitions of a spatial
///   structure element and an optional set of product
///   representations. It is used to define an element
///   specification (i.e. the specific element information, that
///   is common to all occurrences of that element type).
/// 
/// NOTE ÿThe product representations are defined as
///   representation maps (at the level of the supertype
///   IfcTypeProduct, which gets assigned by an element
///   occurrence instance through the
///   IfcShapeRepresentation.Item[1] being an
///   IfcMappedItem.
/// 
/// A spatial structure element type is used to define the
///   common properties of a certain type of a spatial structure
///   element that may be applied to many instances of thatÿtype
///   to assign a specific style. Spatial structure element types
///   (i.e. the instantiable subtypes) may be exchanged without
///   being already assigned to occurrences.
/// 
/// NOTE ÿThe spatial structure element types are
///   often used to represent catalogues of predefined spatial
///   types for shared attributes, less so for sharing a common
///   representation map.
/// 
/// The occurrences of subtypes of the
///   abstractÿIfcSpatialStructureElementType are
///   represented by instances of subtypes of
///   IfcSpatialStructureElement.
/// 
/// HISTORY ÿNew entity in
///   Release IFC2x Edition 3.
class IfcSpatialStructureElementType : public IfcElementType {
public:
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcElementType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcElementType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcElementType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcSpatialStructureElementType (IfcAbstractEntity* e);
    IfcSpatialStructureElementType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType);
    typedef IfcTemplatedEntityList< IfcSpatialStructureElementType > list;
};
/// The IfcSphere is a Construction Solid Geometry (CSG) 3D
/// primitive. It is a solid where all points at the surface have the
/// same distance from the center point. The inherited
/// Position attribute defines the IfcAxisPlacement3D
/// and provides:
/// 
/// SELF\IfcCsgPrimitive3D.Position: The location and
/// orientation of the axis system for the primitive. 
/// SELF\IfcCsgPrimitive3D.Position.Location: The center
/// of the sphere.
/// SELF\IfcCsgPrimitive3D.Position.Position[3]: The z
/// axis points at its positve direction towards the north pole, and by
/// its negative directions towards the south pole.
/// 
/// The following definitions from ISO 10303-42 apply:
/// 
/// A sphere is a CSG
/// primitive with a spherical shape defined by a centre and a
/// radius.
/// 
/// Figure 270 illustrates geometric parameters of the sphere. The sphere is positioned within its own placement coordiante system. The origin is the center of the sphere.
/// 
/// Figure 270 — Sphere geometry
/// 
/// NOTE  Corresponding STEP entity: sphere, the position attribute, including the centre point,  has been promoted to the immediate supertype IfcCsgPrimitive3D. Please refer to ISO/IS 10303-42:1994, p. 175 for the final definition of the formal standard.
/// 
/// HISTORY  New entity in IFC2x3.
/// 
/// Texture Use Definition
/// Textures are aligned facing upright with origin at the back (+Y direction) revolving counter-clockwise. Textures are stretched or repeated to the extent of the circumference at the equator according to RepeatS and RepeatT.
/// 
/// Figure 271 illustrates default texture mapping with a clamped texture (RepeatS=False and RepeatT=False). The image on the left shows the texture where the S axis points to the right and the T axis points up. The image on the right shows the texture applied to the geometry where the X axis points back to the right, the Y axis points back to the left, and the Z axis points up.
/// 
/// Side
/// Normal
/// Origin X
/// Origin Y
/// Origin Z
/// S Axis
/// T Axis
/// 
/// Side
/// -Y
/// 0
/// +Radius
/// 0
/// (-X, then curving counter-clockwise)
/// (+Y, then curving towards top)
/// 
/// Figure 271 — Sphere textures
class IfcSphere : public IfcCsgPrimitive3D {
public:
    /// The radius of the sphere.
    double Radius() const;
    void setRadius(double v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 1: return IfcUtil::Argument_DOUBLE; } return IfcCsgPrimitive3D::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 1: return Type::IfcPositiveLengthMeasure; } return IfcCsgPrimitive3D::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 1: return "Radius"; } return IfcCsgPrimitive3D::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcSphere (IfcAbstractEntity* e);
    IfcSphere (IfcAxis2Placement3D* v1_Position, double v2_Radius);
    typedef IfcTemplatedEntityList< IfcSphere > list;
};
/// Definition from IAI: The abstract entity IfcStructuralActivity combines the definition of actions (such as forces, displacements, etc.) and reactions (support reactions, internal forces, deflections, etc.) which are specified by using the basic load definitions from the IfcStructuralLoadResource.
/// 
/// The differentiation between actions and reactions is realized by instantiating objects either from subclasses of IfcStructuralAction or IfcStructuralReaction respectively.  They inherit commonly needed attributes from the abstract superclass IfcStructuralActivity, notably the relationship which connects actions or reactions with connections, analysis members, or elements (subtypes of IfcStructuralItem or IfcElement).
/// 
/// NOTE  Instances of IfcStructuralActivity which are connected with an IfcElement are subject to agreements outside the scope of this specification.
/// 
/// NOTE  The semantics of IfcStructuralActivity are only fully defined
/// if an activity instance is connected with exactly one structural item.  The inverse attribute
/// AssignedToStructuralItem can only be empty in incomplete models or in conceptual models
/// which are not yet ready for analysis.
/// 
/// HISTORY: New entity in IFC 2x2.
/// 
/// IFC 2x4 change:  Cardinality of attribute
/// AssignedToStructuralItem relaxed from 1 to 0..1 in order to allow for schema-compliant
/// incomplete models as well as conceptual models without load—item relationships.
/// 
/// Coordinate Systems:
/// 
/// The following coordinate systems are distinguished:
/// 
/// The so-called global coordinate system is the coordinate system shared by all items and activities which are grouped in a common IfcStructuralAnalysisModel.  This coordinate system is established by an ObjectPlacement.  (This coordinate system is not necessarily the same as the IfcProject's world coordinate system.)
///   The so-called local coordinate system is a coordinate system local to a structural item (connection or member).  This coordinate system is established by a Representation in conjunction with further use definitions and attributes of subtypes of IfcStructuralItem.
/// 
/// Representation items in topology representations are always given within the ObjectPlacement, i.e. in so-called global coordinates (global with respect to the IfcStructuralAnalysisModel to which this activity belongs).
/// 
/// Locations of the load objects in the AppliedLoad attribute (if of type IfcStructuralLoadConfiguration) are always given in local coordinates.
/// 
/// Directions of the load objects in the AppliedLoad attribute refer to global or local coordinates according to the GlobalOrLocal attribute.
/// 
/// The ObjectPlacement and Representation are sometimes not explicitly instantiated; instead they may be implied as described below.  Global and local coordinate systems are then determined in the same way as with explicit placement and representation.
/// 
/// Topology Use Definitions:
/// 
/// Instances of IfcStructuralActivity which are connected with a structural item of same dimensionality, i.e.
/// 
/// a point action or reaction connected with a point item (IfcStructuralPointConnection),
///   a curve action or reaction connected with a curve item (IfcStructuralCurveConnection, IfcStructuralCurveMember), or
///   a surface action or reaction connected with a surface item (IfcStructuralSurfaceConnection, IfcStructuralSurfaceMember) and which acts on the entire surface of the item and is not specified by isocontours
/// 
/// shall not have an ObjectPlacement nor a Representation.  It is implied that the placement and representation of the IfcStructuralActivity is the same as the ones of the IfcStructuralItem.
/// 
/// Instances of IfcStructuralActivity which are connected with
/// 
/// a curve item (IfcStructuralCurveConnection, IfcStructuralCurveMember) and act on a point of the item, or
///   a surface item (IfcStructuralSurfaceConnection, IfcStructuralSurfaceMember) and act on a point or on a curve or on a part of the surface of the item
/// 
/// shall have a topology representation as specified below.  It includes a placement and a product representation. The IfcProductRepresentation shall be given by an item in a Representation of type IfcTopologyRepresentation.
/// 
/// Instances of IfcStructuralActivity which are connected with
/// 
/// a surface item (IfcStructuralSurfaceConnection, IfcStructuralSurfaceMember) and are specified by isocontours
/// 
/// shall have a shape representation as specified below.  It includes a placement and a product representation. The IfcProductRepresentation shall be given by items in a Representation of type IfcShapeRepresentation.  Shape representation and topology representation may be combined.
/// 
/// Local Placement
/// 
/// The local placement for IfcStructuralActivity is defined in its supertype IfcProduct.  It is defined by the IfcLocalPlacement, which establishes a global coordinate system which shall be common to all items and activities in an IfcStructuralAnalysisModel.
/// 
/// Topology Representation
/// 
/// Instances of IfcStructuralActivity which act on parts of a surface item shall have a topology representation given by a face with underlying surface geometry, IfcFaceSurface, which should be the single item of IfcTopologyRepresentation.Items.  The surface establishes a local coordinate system of the activity:
/// 
/// The origin of surface parameters u,v is the origin of the local coordinate system.
///   The local x and y directions follow the tangents on the surface and are in parallel with and directed like u and v respectively.
///   The local z direction is in parallel with and directed like the surface normal.
/// 
/// RepresentationIdentifier: 'Reference'
///   RepresentationType: 'Face'
/// 
/// Instances of IfcStructuralActivity which act on a curve on a surface item shall have a topology representation given by an edge (IfcEdge or subtype), which should be the single item of IfcTopologyRepresentation.Items.  The curve geometry shall be compatible with the surface geometry of the connected item.  In conjunction with this surface, the curve establishes a local coordinate system of the activity:
/// 
/// The origin of the curve parameter u is the origin of the local coordinate system.
///   The local x direction follows the tangent on the curve and is directed like u.
///   The local z direction is in parallel with and directed like the surface normal of the connected surface item.
///   The local x,y,z directions form a right-handed Cartesian coordinate system.
/// 
/// RepresentationIdentifier: 'Reference'
///   RepresentationType: 'Edge'
/// 
/// NOTE  While an IfcEdge (or IfcOrientedEdge with underlying IfcEdge) does not provide an explicit underlying curve geometry, it may be used to imply an underlying straight line as reference curve with the origin of the curve parameter at the start vertex point.
/// 
/// Instances of IfcStructuralActivity which act on a single point on a curve or surface item shall have a topology representation given by an IfcVertexPoint, which should be the single item of IfcTopologyRepresentation.Items.  The point geometry shall be compatible with the curve or surface geometry of the connected item.  The local coordinate system of the activity is oriented by the curve or surface geometry of the connected item as described above for activities with edge or face topology.
/// 
/// RepresentationIdentifier: 'Reference'
///   RepresentationType: 'Vertex'
/// 
/// Shape Representation
/// 
/// Instances of IfcStructuralActivity which act on a surface item and are specified by isocontours (level sets) shall have a shape representation given by a set of curves on a surface, IfcPCurve.  The basis surface shall comply with or preferably be identical with the surface of the structural item to which the activity is connected.  The representation identifier and type of this geometric representation is:
/// 
/// RepresentationIdentifier: 'Level set'
///   RepresentationType: 'GeometricCurveSet'
class IfcStructuralActivity : public IfcProduct {
public:
    /// Load or result resource object which defines the load type, direction, and load values.
    /// 
    /// In case of activities which are variably distributed over curves or surfaces, IfcStructuralLoadConfiguration is used which provides a list of load samples and their locations within the load distribution, measured in local coordinates of the curve or surface on which this activity acts.  The contents of this load or result distribution may be further restricted by definitions at subtypes of IfcStructuralActivity.
    IfcStructuralLoad* AppliedLoad() const;
    void setAppliedLoad(IfcStructuralLoad* v);
    /// Indicates whether the load directions refer to the global coordinate system (global to
    /// the analysis model, i.e. as established by IfcStructuralAnalysisModel.SharedPlacement)
    /// or to the local coordinate system (local to the activity or connected item, as established by
    /// an explicit or implied representation and its parameter space).
    /// 
    /// NOTE, the informal definition of
    /// IfcRepresentationResource.IfcGlobalOrLocalEnum doe s not distinguish between
    /// "global coordinate system" and "world coordinate system".
    /// On the other hand, this distinction is necessary in the IfcStructuralAnalysisDomain
    /// where the shared "global" coordinate system of an analysis model may very well
    /// not be the same as the project-wide world coordinate system.
    /// 
    /// In the scope of IfcStructuralActivity.GlobalOrLocal,
    /// the meaning of GLOBAL_COORDS is therefore not to be taken as world coordinate system
    /// but as the analysis model specific shared coordinate system.  In contrast, LOCAL_COORDS
    /// is to be taken as coordinates which are local to individual structural items and activities,
    /// as established by subclass-specific geometry use definitions.
    IfcGlobalOrLocalEnum::IfcGlobalOrLocalEnum GlobalOrLocal() const;
    void setGlobalOrLocal(IfcGlobalOrLocalEnum::IfcGlobalOrLocalEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 7: return IfcUtil::Argument_ENTITY_INSTANCE; case 8: return IfcUtil::Argument_ENUMERATION; } return IfcProduct::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 7: return Type::IfcStructuralLoad; case 8: return Type::IfcGlobalOrLocalEnum; } return IfcProduct::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 7: return "AppliedLoad"; case 8: return "GlobalOrLocal"; } return IfcProduct::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcRelConnectsStructuralActivity >::ptr AssignedToStructuralItem() const; // INVERSE IfcRelConnectsStructuralActivity::RelatedStructuralActivity
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcStructuralActivity (IfcAbstractEntity* e);
    IfcStructuralActivity (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, IfcStructuralLoad* v8_AppliedLoad, IfcGlobalOrLocalEnum::IfcGlobalOrLocalEnum v9_GlobalOrLocal);
    typedef IfcTemplatedEntityList< IfcStructuralActivity > list;
};
/// Definition from IAI: The abstract entity IfcStructuralItem is the generalization of structural members and structural connections, i.e. analysis idealizations of elements in the building model.  It defines the relation between structural members and connections with structural activities (actions and reactions).
/// 
/// Relationships between elements in the building model and structural items as their idealizations can be expressed by instances of IfcRelAssignsToProduct.
/// 
/// HISTORY: New entity in IFC 2x2.
/// IFC 2x4 change:  Use definitions and informal proposition added.
/// 
/// Coordinate Systems:
/// 
/// The following coordinate systems are distinguished:
/// 
/// The so-called global coordinate system is the coordinate system shared by all items and activities which are grouped in a common IfcStructuralAnalysisModel.  This coordinate system is established by SELF\IfcProduct.ObjectPlacement.  (This coordinate system is not necessarily the same as the IfcProject's world coordinate system.)
///   The so-called local coordinate system is a coordinate system local to a structural item (connection or member).  This coordinate system is established by a Representation (attribute inherited from IfcProduct) in conjunction with further use definitions and attributes of subtypes of IfcStructuralItem.
/// 
/// Representation items in topology representations are always given within the ObjectPlacement, i.e. in so-called global coordinates (global with respect to the IfcStructuralAnalysisModel to which this item belongs).
/// 
/// The usage of local coordinate systems is further defined in subtypes.
/// 
/// Topology Use Definitions:
/// 
/// Instances of IfcStructuralItem shall have a topology representation.  It includes a placement and a product representation. The IfcProductRepresentation shall be given by an item in a Representation of type IfcTopologyRepresentation.
/// 
/// Local Placement
/// 
/// The local placement for IfcStructuralActivity is defined in its supertype IfcProduct.  It is defined by the IfcLocalPlacement, which establishes a global coordinate system which shall be common to all items and activities in an IfcStructuralAnalysisModel.
/// 
/// Topology Representation
/// 
/// Instances of IfcStructuralItem shall have a topology representation given by an instance of a subtype of IfcTopologicalRepresentationItem, which should be the single item of IfcTopologyRepresentation.Items.  Depending on the dimensionality of the structural item, one of the following types of toplogical representation items shall be used:
/// 
/// Point connections shall be represented by an IfcVertexPoint with an underlying IfcCartesianPoint.
///   The Cartesian point is the reference point of the connection in the so-called global coordinate system.
///   The following labels are used in the IfcTopologyRepresentation:
/// 
/// RepresentationIdentifier: 'Reference'
///   RepresentationType: 'Vertex'
/// 
/// Curve members and curve connections shall either be represented by an IfcOrientedEdge,
///   IfcEdgeCurve, or IfcEdge.  The curve to which the IfcEdgeCurve (or an
///   IfcOrientedEdge's underlying IfcEdgeCurve) refers to is the reference curve of the structural
///   item in the global coordinate system.  Start and end vertex of the edge shall be IfcVertexPoints
///   with underlying IfcCartesianPoints.
///   The following labels are used in the IfcTopologyRepresentation:
/// 
/// RepresentationIdentifier: 'Reference'
///   RepresentationType: 'Edge'
/// 
/// NOTE  While an IfcEdge (or IfcOrientedEdge with underlying
///   IfcEdge) does not provide an explicit underlying curve geometry, it may be used to imply an
///   underlying straight line as reference curve with the origin of the curve parameter at the start vertex
///   point.
/// 
/// Surface members and surface connections shall be represented by an IfcFaceSurface.
///   The underlying surface defeines the reference surface of the structural surface item in the global
///   coordiante system.  All edges in the bounds of the face shall conform to the rules for edge
///   representations of structural curve item.
///   The following labels are used in the IfcTopologyRepresentation:
/// 
/// RepresentationIdentifier: 'Reference'
///   RepresentationType: 'Face'
/// 
/// The reference point, reference curve, or reference surface partially or completely defines the local coordinate system of the represented structural item according to the following rules.  In all cases, The local x,y,z directions form a right-handed Cartesian coordinate system.
/// 
/// Structural point items
/// 
/// The reference point in the representation is the origin of the local coordinate system of the structural item.
///   The axes of the local coordiante system are either parallel with and directed like the so-called global coordinate axes, or are oriented according to definitions at the respective subtype of IfcStructuralItem.
/// 
/// Structural curve items
/// 
/// The u parameter origin of the reference curve in the representation is the origin of the local coordinate system of the structural item.
///   The local x axis is parallel with the tangent on the curve and directed like the u parameter direction.
///   The local y and z axes are oriented according to definitions at the respective subtypes of IfcStructuralItem.
/// 
/// Structural surface items
/// 
/// The u,v parameter origin of the reference surface in the representation is the origin of the local coordinate system of the structural item.
///   The local x and y directions follow the tangents on the surface and are in parallel with and directed like u and v respectively.
///   The local z direction is in parallel with and directed like the surface normal.
/// 
/// Informal propositions:
/// 
/// The ObjectPlacements of all structural items which are grouped into the same instance of IfcStructuralAnalysisModel shall refer to the same instance of IfcObjectPlacement.
/// 
/// NOTE  This rule is necessary to achieve consistent topology representations.  The topology representations of structural items in an analysis model are meant to share vertices and edges und must therefore have the same object placement.
/// 
/// NOTE  A structural item may be grouped into more than one analysis model.  In this case, all these models must use the same instance of IfcObjectPlacement.
class IfcStructuralItem : public IfcProduct {
public:
    virtual unsigned int getArgumentCount() const { return 7; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcProduct::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcProduct::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcProduct::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcRelConnectsStructuralActivity >::ptr AssignedStructuralActivity() const; // INVERSE IfcRelConnectsStructuralActivity::RelatingElement
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcStructuralItem (IfcAbstractEntity* e);
    IfcStructuralItem (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation);
    typedef IfcTemplatedEntityList< IfcStructuralItem > list;
};
/// Definition from IAI: The abstract entity IfcStructuralMember is the superclass of all structural items which represent the idealized structural behavior of building elements.
/// 
/// HISTORY: New entity in IFC 2x2.
/// IFC 2x4 change:  Use definitions moved to supertype and subtypes.
class IfcStructuralMember : public IfcStructuralItem {
public:
    virtual unsigned int getArgumentCount() const { return 7; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcStructuralItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcStructuralItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcStructuralItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcRelConnectsStructuralElement >::ptr ReferencesElement() const; // INVERSE IfcRelConnectsStructuralElement::RelatedStructuralMember
    IfcTemplatedEntityList< IfcRelConnectsStructuralMember >::ptr ConnectedBy() const; // INVERSE IfcRelConnectsStructuralMember::RelatingStructuralMember
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcStructuralMember (IfcAbstractEntity* e);
    IfcStructuralMember (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation);
    typedef IfcTemplatedEntityList< IfcStructuralMember > list;
};
/// Definition from IAI: A structural reaction is a structural activity that results from a
/// structural action imposed to a structural item or building element.  Examples are support reactions,
/// internal forces, and deflections.
/// 
/// HISTORY  New entity in IFC 2x2.
/// 
/// IFC 2x4 change:  Inverse attribute Causes deleted; use IfcRelAssignsToProduct via HasAssignments instead.
/// 
/// Structural reactions are grouped into IfcStructuralResultGroups via the inverse
/// relationship HasAssignments and an IfcRelAssignsToGroup relationship object.
/// IfcStructuralResultGroup.ResultGroupFor finally refers to the structural analysis model
/// in which the results occur.
/// 
/// It is furthermore possible to establish relationships between reactions in one analysis model
/// and actions which they cause in another analysis model.  For example, a support reaction from one
/// structural system may be taken over as a load onto another supporting structural system.  This is
/// expressed by means of the inverse relationship HasAssignments of the reaction and an
/// IfcRelAssignsToProduct relationship object.  IfcRelAssignsToProduct.Name is set to
/// 'Causes' and IfcRelAssignsToProduct.RelatingProduct refers to an instance of a subtype of
/// IfcStructuralAction.
class IfcStructuralReaction : public IfcStructuralActivity {
public:
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcStructuralActivity::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcStructuralActivity::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcStructuralActivity::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcStructuralAction >::ptr Causes() const; // INVERSE IfcStructuralAction::CausedBy
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcStructuralReaction (IfcAbstractEntity* e);
    IfcStructuralReaction (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, IfcStructuralLoad* v8_AppliedLoad, IfcGlobalOrLocalEnum::IfcGlobalOrLocalEnum v9_GlobalOrLocal);
    typedef IfcTemplatedEntityList< IfcStructuralReaction > list;
};
/// Definition from IAI: Instances of IfcStructuralSurfaceMember describe face members, i.e. structural analysis idealizations of slabs, walls, shells, etc..  Surface members may be planar or curved.
/// 
/// HISTORY: New entity in IFC 2x2.
/// IFC 2x4 change:  Use definitions changed, WHERE rule added.
/// 
/// Coordinate Systems:
/// 
/// See definitions at IfcStructuralItem.  The local coordinate system is established by the reference surface given by topology representation.
/// 
/// Material Use Definition
/// 
/// The material of direct instances IfcStructuralSurfaceMember (in contrast to instances of the subtype IfcStructuralSurfaceMemberVarying) is defined by IfcMaterial and attached by the IfcRelAssociatesMaterial.RelatingMaterial.  It is accessible by the inverse HasAssociations relationship.
/// 
/// The material is specified minimally by a name which corresponds with an agreed upon standardized structural material designation.  An external reference to the source which specifies the material designation should be provided.  Alternatively, structural material properties may be provided by means of IfcMechanicalMaterialProperties and IfcExtendedMaterialProperties.
/// 
/// Direct instances of IfcStructuralSurfaceMember are assumed to be located centrically relative to their reference surface.  Their depth is provided in the attribute Thickness.
/// 
/// Topology Use Definitions:
/// 
/// Direct instances of IfcStructuralSurfaceMember shall have a topology representation which consists of one IfcFaceSurface, representing the reference surface of the surface member.  See definitions at IfcStructuralItem for further specifications.
class IfcStructuralSurfaceMember : public IfcStructuralMember {
public:
    /// Type of member with respect to its load carrying behavior in this analysis idealization.
    IfcStructuralSurfaceTypeEnum::IfcStructuralSurfaceTypeEnum PredefinedType() const;
    void setPredefinedType(IfcStructuralSurfaceTypeEnum::IfcStructuralSurfaceTypeEnum v);
    /// Whether the optional attribute Thickness is defined for this IfcStructuralSurfaceMember
    bool hasThickness() const;
    /// Defines the typically understood thickness of the structural surface member, measured normal to its reference surface.
    double Thickness() const;
    void setThickness(double v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 7: return IfcUtil::Argument_ENUMERATION; case 8: return IfcUtil::Argument_DOUBLE; } return IfcStructuralMember::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 7: return Type::IfcStructuralSurfaceTypeEnum; case 8: return Type::IfcPositiveLengthMeasure; } return IfcStructuralMember::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 7: return "PredefinedType"; case 8: return "Thickness"; } return IfcStructuralMember::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcStructuralSurfaceMember (IfcAbstractEntity* e);
    IfcStructuralSurfaceMember (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, IfcStructuralSurfaceTypeEnum::IfcStructuralSurfaceTypeEnum v8_PredefinedType, boost::optional< double > v9_Thickness);
    typedef IfcTemplatedEntityList< IfcStructuralSurfaceMember > list;
};
/// Definition from IAI: Describes surface members with varying section properties.  The properties are provided by means of a property set and IfcRelDefinesByProperties or by means of aggregation:  An instance of IfcStructuralSurfaceMemberVarying may be composed of two or more instances of IfcStructuralSurfaceMember with differing section properties.  These subordinate members relate to the instance of IfcStructuralSurfaceMemberVarying by IfcRelAggregates.
/// 
/// NOTE   It is recommended that structural activities (actions or reactions) are not connected with aggregated IfcStructuralSurfaceMemberVarying but only with the IfcStructuralSurfaceMembers in the aggregation.  That way, difficulties in interpretation of local coordinates are avoided.
/// 
/// HISTORY: New entity in IFC 2x2.
/// Use definition changed and attributes deleted in IFC 2x4.
/// 
/// Coordinate Systems:
/// 
/// See definitions at IfcStructuralItem and IfcStructuralSurfaceMember.  The local coordinates of an aggregate are generally undefined since continuity of local coordinates of the parts is not ensured.
/// 
/// Material Use Definition
/// 
/// In case of aggregation, only the individual parts (direct instances of IfcStructuralSurfaceMember) carry material and thickness information.  Otherwise, definitions at IfcStructuralSurfaceMember apply.
/// 
/// Topology Use Definitions:
/// 
/// In case of aggregation, instances of IfcStructuralSurfaceMemberVarying may have a topology representation which contains a single IfcConnectedFaceSet, based upon the faces of the parts.  Otherwise, definitions at IfcStructuralSurfaceMember apply.
class IfcStructuralSurfaceMemberVarying : public IfcStructuralSurfaceMember {
public:
    std::vector< double > /*[2:?]*/ SubsequentThickness() const;
    void setSubsequentThickness(std::vector< double > /*[2:?]*/ v);
    IfcShapeAspect* VaryingThicknessLocation() const;
    void setVaryingThicknessLocation(IfcShapeAspect* v);
    virtual unsigned int getArgumentCount() const { return 11; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_AGGREGATE_OF_DOUBLE; case 10: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcStructuralSurfaceMember::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcPositiveLengthMeasure; case 10: return Type::IfcShapeAspect; } return IfcStructuralSurfaceMember::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "SubsequentThickness"; case 10: return "VaryingThicknessLocation"; } return IfcStructuralSurfaceMember::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcStructuralSurfaceMemberVarying (IfcAbstractEntity* e);
    IfcStructuralSurfaceMemberVarying (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, IfcStructuralSurfaceTypeEnum::IfcStructuralSurfaceTypeEnum v8_PredefinedType, boost::optional< double > v9_Thickness, std::vector< double > /*[2:?]*/ v10_SubsequentThickness, IfcShapeAspect* v11_VaryingThicknessLocation);
    typedef IfcTemplatedEntityList< IfcStructuralSurfaceMemberVarying > list;
};

class IfcStructuredDimensionCallout : public IfcDraughtingCallout {
public:
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcDraughtingCallout::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcDraughtingCallout::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcDraughtingCallout::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcStructuredDimensionCallout (IfcAbstractEntity* e);
    IfcStructuredDimensionCallout (IfcEntityList::ptr v1_Contents);
    typedef IfcTemplatedEntityList< IfcStructuredDimensionCallout > list;
};
/// The IfcSurfaceCurveSweptAreaSolid is the result of
/// sweeping an area along a directrix that lies on a reference
/// surface. The swept area is provided by an IfcProfileDef
/// (or subtypes). The profile definition is based on a 2D coordinate
/// system, which is inserted into the XY plane of the 3D
/// Position coordinate system inherited from the supertype
/// IfcSweptAreaSolid.
/// The following definitions from ISO 10303-42 apply:
/// 
/// A surface curve swept
/// area solid is a type of swept area solid which is the result of
/// sweeping a face along a Directrix lying on a
/// ReferenceSurface. The orientation of the
/// SweptArea is related to the direction of the surface
/// normal.
/// The
/// SweptArea is required to be a curve bounded surface lying
/// in the plane z = 0 and this is swept along the Directrix
/// in such a way that the origin of the local coordinate system used
/// to define the SweptArea is on the Directrix and
/// the local x-axis is in the direction of the normal to the
/// ReferenceSurface at the current point. The resulting solid
/// has the property that the cross section of the surface by the
/// normal plane to the Directrix at any point is a copy of
/// the SweptArea.
/// The orientation of
/// the SweptArea as it sweeps along the Directrix is
/// precisely defined by a Cartesian Transformation Operator 3D with
/// attributes:
/// 
/// LocalOrigin
/// as point (0; 0; 0),
/// Axis1 as
/// the normal N to the ReferenceSurface at the point of the
/// Directrix with parameter u.
/// Axis3 as
/// the direction of the tangent vector t at the point of the
/// Directrix with parameter u.
/// The remaining attributes are defaulted to define a corresponding
/// transformation matrix T(u), which varies with the
/// Directrix parameter u.
/// 
/// NOTE  The
/// geometric shape of the solid is not dependent upon the curve
/// parameterization; the volume depends upon the area swept and the
/// length of the Directrix.
/// 
/// The attributes of the Cartesian Transformation Operator (as
/// shown above) should apply to the Position coordinate
/// system, in which the profile is inserted. The Directrix
/// and the ReferenceSurface are positioned within the 3D
/// Position coordinate system.
/// 
/// NOTE  Corresponding ISO 10303-42 entity: surface_curve_swept_area_solid. Please refer to ISO 10303-42 ed.2:1999, p. 274 for the definition in the international standard.
/// 
/// HISTORY  New entity in IFC2x2.
/// 
/// Informal propositions:
/// 
/// The SweptArea shall lie in the plane z = 0.
/// The Directrix shall lie on the
/// ReferenceSurface.
class IfcSurfaceCurveSweptAreaSolid : public IfcSweptAreaSolid {
public:
    /// The curve used to define the sweeping operation. The solid is generated by sweeping the SELF\IfcSweptAreaSolid.SweptArea along the Directrix.
    IfcCurve* Directrix() const;
    void setDirectrix(IfcCurve* v);
    /// The parameter value on the Directrix at which the sweeping operation commences. If no value is provided the start of the sweeping operation is at the start of the Directrix..
    /// 
    /// IFC2x4 CHANGE  The attribute has been changed to OPTIONAL with upward compatibility for file-based exchange.
    double StartParam() const;
    void setStartParam(double v);
    /// The parameter value on the Directrix at which the sweeping operation ends. If no value is provided the end of the sweeping operation is at the end of the Directrix..
    /// 
    /// IFC2x4 CHANGE  The attribute has been changed to OPTIONAL with upward compatibility for file-based exchange.
    double EndParam() const;
    void setEndParam(double v);
    /// The surface containing the Directrix.
    IfcSurface* ReferenceSurface() const;
    void setReferenceSurface(IfcSurface* v);
    virtual unsigned int getArgumentCount() const { return 6; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 2: return IfcUtil::Argument_ENTITY_INSTANCE; case 3: return IfcUtil::Argument_DOUBLE; case 4: return IfcUtil::Argument_DOUBLE; case 5: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcSweptAreaSolid::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 2: return Type::IfcCurve; case 3: return Type::IfcParameterValue; case 4: return Type::IfcParameterValue; case 5: return Type::IfcSurface; } return IfcSweptAreaSolid::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 2: return "Directrix"; case 3: return "StartParam"; case 4: return "EndParam"; case 5: return "ReferenceSurface"; } return IfcSweptAreaSolid::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcSurfaceCurveSweptAreaSolid (IfcAbstractEntity* e);
    IfcSurfaceCurveSweptAreaSolid (IfcProfileDef* v1_SweptArea, IfcAxis2Placement3D* v2_Position, IfcCurve* v3_Directrix, double v4_StartParam, double v5_EndParam, IfcSurface* v6_ReferenceSurface);
    typedef IfcTemplatedEntityList< IfcSurfaceCurveSweptAreaSolid > list;
};
/// Definition from ISO/CD 10303-42:1992: This surface is a simple swept surface or a generalized cylinder obtained by sweeping a curve in a given direction. The parameterization is as follows where the curve has a parameterization l(u): 
/// 
/// V = ExtrusionAxis 
/// 
/// The parameterization range for v is -¥ < v < ¥ and for u it is defined by the curve parameterization. 
/// 
/// NOTE: Corresponding ISO 10303 entity: surface_of_linear_extrusion. Please refer to ISO/IS 10303-42:1994, p.76 for the final definition of the formal standard. The following adaption has been made. The ExtrusionAxis and the Direction are defined as two separate attributes in correlation to the definition of the extruded_area_solid, and not as a single vector attribute. The vector is derived as ExtrusionAxis.
/// 
/// HISTORY: New entity in IFC Release 2x.
/// 
/// Informal propositions: 
/// 
/// The surface shall not self-intersect
class IfcSurfaceOfLinearExtrusion : public IfcSweptSurface {
public:
    /// The direction of the extrusion.
    IfcDirection* ExtrudedDirection() const;
    void setExtrudedDirection(IfcDirection* v);
    /// The depth of the extrusion, it determines the parameterization.
    double Depth() const;
    void setDepth(double v);
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 2: return IfcUtil::Argument_ENTITY_INSTANCE; case 3: return IfcUtil::Argument_DOUBLE; } return IfcSweptSurface::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 2: return Type::IfcDirection; case 3: return Type::IfcLengthMeasure; } return IfcSweptSurface::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 2: return "ExtrudedDirection"; case 3: return "Depth"; } return IfcSweptSurface::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcSurfaceOfLinearExtrusion (IfcAbstractEntity* e);
    IfcSurfaceOfLinearExtrusion (IfcProfileDef* v1_SweptCurve, IfcAxis2Placement3D* v2_Position, IfcDirection* v3_ExtrudedDirection, double v4_Depth);
    typedef IfcTemplatedEntityList< IfcSurfaceOfLinearExtrusion > list;
};
/// Definition from ISO/CD 10303-42:1992: A surface of revolution (IfcSurfaceOfRevolution) is the surface obtained by rotating a curve one complete revolution about an axis. The data shall be interpreted as below. 
/// 
/// The parameterization is as follows where the curve has a parameterization l(u): 
/// 
/// C = AxisPosition.LocationV = AxisPosition.Z
/// 
/// In order to produce a single-value surface the a complete revolution, the curve shall be such that when expressed in a cylindrical coordinate system the curve shall be such that when expressed in a cylindrical coordinate system (r,φ ,z) centred at C with an axis V no two distinct parametric points on the curve shall have the same values for (r, z).  
/// For a surface of revolution the parametric range is 0 < u < 360 degree. The parameterization range for v is defined by referenced curve. 
/// 
/// NOTE: Corresponding ISO 10303 entity: surface_of_revolution. Please refer to ISO/IS 10303-42:1994, p.76 for the final definition of the formal standard.
/// 
/// HISTORY: New entity in IFC2x.
/// 
/// Informal propositions: 
/// 
/// The surface shall not self-intersect 
/// The swept curve shall not be coincident with the axis line for any finite part of its legth.
class IfcSurfaceOfRevolution : public IfcSweptSurface {
public:
    /// A point on the axis of revolution and the direction of the axis of revolution.
    IfcAxis1Placement* AxisPosition() const;
    void setAxisPosition(IfcAxis1Placement* v);
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 2: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcSweptSurface::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 2: return Type::IfcAxis1Placement; } return IfcSweptSurface::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 2: return "AxisPosition"; } return IfcSweptSurface::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcSurfaceOfRevolution (IfcAbstractEntity* e);
    IfcSurfaceOfRevolution (IfcProfileDef* v1_SweptCurve, IfcAxis2Placement3D* v2_Position, IfcAxis1Placement* v3_AxisPosition);
    typedef IfcTemplatedEntityList< IfcSurfaceOfRevolution > list;
};
/// The furnishing element type IfcSystemFurnitureElementType defines commonly shared information for occurrences of furniture elements.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// applicable assignment of process types 
/// 
/// It is used to define a furniture element specification (i.e. the specific product information, that is common to all occurrences of that product type).  Furniture Element types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcSystemFurnitureElementType are represented by instances of IfcSystemFurnitureElement. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcFurnishingElementType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_SystemFurnitureElementTypeCommon 
/// 
/// The following property set definitions are applicable to this entity according to the PredefinedType attribute:  
/// Pset_SystemFurnitureElementTypePanel (PANEL) 
/// Pset_SystemFurnitureElementTypeWorkSurface (WORKSURFACE) 
/// 
/// Material Use Definition 
/// The material of the IfcSystemFurnitureElementType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Finish': The finish, typically at visible aspects of the furniture. 
/// 'Frame': The frame from which the object is constructed. 
/// 'Hardware': Finish hardware such as knobs or handles. 
/// 'Padding': Padding such as cushions. 
/// 'Panel': Panels such as glass.
class IfcSystemFurnitureElementType : public IfcFurnishingElementType {
public:
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcFurnishingElementType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcFurnishingElementType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcFurnishingElementType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcSystemFurnitureElementType (IfcAbstractEntity* e);
    IfcSystemFurnitureElementType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType);
    typedef IfcTemplatedEntityList< IfcSystemFurnitureElementType > list;
};
/// An IfcTask is an identifiable unit of work to be
///   carried out in a construction project.
/// 
/// A task is typically used to describe an activity for the
///   construction or installation of products, but is not
///   limited to these types. For example it might be used to
///   describe design processes, move operations and other
///   design, construction and operation related activities as
///   well.
/// 
/// HISTORY  New entity in IFC 1.0. Renamed from IfcWorkTask in IFC 2x.
/// 
/// IFC2x4 CHANGE  Attributes TaskTime and PredefinedType added.  IfcMove and IfcOrderRequest has been removed in IFC2x4 and are now represented by IfcTask. Further information can be found in the description below.
/// 
/// Type use definition
/// 
/// IfcTask defines the anticipated or actual occurrence
///   of any task; common information about task types is handled
///   by IfcTaskType. The IfcTaskType (if present)
///   may establish the common type name, usage (or predefined)
///   type, common set of properties, and common product
///   assignment using IfcRelAssignsToProduct. The
///   IfcTaskType is attached using the
///   IfcRelDefinesByType.RelatingType objectified
///   relationship and is accessible by the inverse
///   IsTypedBy attribute. Special type information
///   relating to a task occurrence is asserted using
///   IfcTask.ObjectType (inherited from
///   IfcObject). Examples that may be used include fixed
///   duration, fixed unit or fixed work. IfcTask can be
///   aggregated to a task type in order to specify a task
///   sequence or any time related information, e.g. the duration
///   of a task. Please see the documentation of
///   IfcTaskType for further information.
/// 
/// Attribute use definition
/// 
/// Each occurrence of IfcTask is given a name that is
///   indicative of its content (IfcRoot.Name). A textual
///   description of the task may be provided and this may be
///   further elaborated by a narrative long description
///   (IfcProcess.LongDescription). A work method may be
///   declared for the method of work used in carrying out a
///   task. A task is identified as being either a milestone task
///   or not. A milestone task is defined by the marker
///   IsMilestone. and has no duration. A status and
///   priority for each task may also be set.
/// 
/// Property set use definition
/// 
/// The property sets relating to IfcTask are defined by
///   IfcPropertySet and attached by the
///   IfcRelDefinesByProperties relationship. They are
///   accessible by the inverse IsDefinedBy relationship.
///   Such property sets may define task parameters. No property
///   sets for IfcTask are currently defined by IFC.
/// 
/// Connectivity Use Definition
/// 
/// The relationship IfcRelSequence is used to indicate
///   control flow. An IfcTask as a successor to an
///   IfcTask indicates logical sequence how these tasks
///   should be performed. IfcTask's can be triggered or
///   can trigger IfcEvent's, which is also defined
///   through the relationship IfcRelSequence.
/// 
/// Composition use definition
/// 
/// IfcTask may be contained within an IfcTask
///   using the IfcRelNests relationship. An
///   IfcTask may in turn nest other IfcTask,
///   IfcProcedure or IfcEvent entities. Such
///   nesting indicates decomposed level of detail. From IFC2x4
///   onwards it is required to have a summary task (root of all
///   tasks), which is used to define a link to the work plan or
///   work schedule. All subtasks of the summary tasks are then
///   implicitly linked to this work plan or work schedule.
///   Please note that the summary task is used for data
///   organization and not meant to store typical task
///   information as defined by the user. It is therefore
///   recommended that the summary task is hidden from the user
///   to avoid confusion. Please also note that
///   IfcRelNests is used to show the dependency between
///   regular tasks and recurring task definitions (please see
///   the section about time and duration use definitions).
/// 
/// As shown in Figure 13, the installation of a number of items of equipment within a
///   particular space may be the subject of a single task which
///   is identified as 'fix equipment in space 123'.
///   IfcTask represents the occurrence of a work
///   performance of a type of process in a construction plan.
/// 
/// Figure 13 — Task visualization
/// 
/// A task may nest other tasks as sub-items; the nesting
///   relationship is modeled by IfcRelNests as shown in Figure 14. For example,
///   the construction of a stud wall may be designated as a
///   nesting task named 'install wall #1' including other tasks
///   such as 'install dry wall', 'install studs', 'wall taping',
///   and 'erect wall' as sub-processes. A value that indicates
///   the relative tree view position of the task (in comparison
///   to the tree view position of other tasks and the task
///   hierarchy defined by IfcRelNests).
///   The task order information that is used for viewing
///   purposes is derived from the order defined by the
///   IfcRelNests relationship and thus is independent of
///   the logical task order defined through
///   IfcRelSequence. The hierarchy and order defined
///   through IfcRelNests enables to order the tasks in a
///   tree view or list view structure.
/// 
/// Figure 14 — Task nesting relationships
/// 
/// Time and duration use definition
/// 
/// Compared to previous IFC releases, basic task time
///   information (scheduled start time, scheduled finish
///   time, duration) is now directly attached to IfcTask
///   through the TaskTime attribute. Regular tasks are
///   defined through IfcTaskTime. Recurring tasks are
///   defined through IfcTaskTimeRecurring. In case a
///   regular task is derived from a recurring task both tasks
///   should be linked together through a IfcRelNests
///   relationship, where IfcRelNests.IsNestedBy points to
///   the recurring task and IfcRelNests.Nests points to
///   all regular tasks that have been derived from the recurring
///   task.
/// 
/// Assignment use definition
/// 
/// Occurrences of IfcTask may be assigned to an
///   IfcWorkControl (either a work plan or a work
///   schedule) through IfcRelAssignsToControl. From
///   IFC2x4 onwards it is suggested to use the 'summary task'
///   (root element of the task hierarchy that is required for
///   task management purposes) to assign all subtask to a work
///   plan or work schedule. Resources used by tasks are assigned
///   by IfcRelAssignsToProcess. Quantities of resources
///   consumed by the task are dealt with by defining the
///   IfcElementQuantity for the resource and not at the
///   instance of IfcTask. Please note that the
///   IfcRelAssignsTasks relationship class has been
///   removed in IFC2x4 and is no longer available.
/// 
/// An IfcTask may be assigned a Work Breakdown
///   Structure (WBS) code. A WBS code is dealt with as a
///   classification of task and is associated to a task
///   occurrence using the IfcRelAssociatesClassification
///   relationship class. As well as being to designate the code,
///   the classification structure of the IFC model also enables
///   the source of the work breakdown structure classification
///   to be identified.
/// 
/// Constraint use definition
/// 
/// Constraints may be applied to a task to indicate fixed task
///   duration, fixed start or fixed finish (see Figure 15). The relationship
///   IfcRelAssociatesConstraint is used where
///   RelatingConstraint points to an IfcMetric and
///   RelatedObjects includes the IfcTask.
///   IfcRelAssociatesConstraint.Name identifies the
///   attribute to be constrained using a period (".") to
///   dereference; for example, "TaskTime.ScheduleStart" refers
///   to the ScheduleStart attribute on the
///   IfcTaskTime entity referenced on the TaskTime
///   attribute. The following attributes may be constrained:
/// 
/// 'TaskTime.ScheduleDuration': Indicate fixed
///   duration of task with ConstraintGrade=HARD and
///   Benchmark=EQUALTO such that changes to an assigned
///   IfcConstructionResource.ResourceTime.ScheduleWork
///   should impact
///   IfcConstructionResource.ResourceTime.ScheduleUsage,
///   and vice-versa.
/// 
/// 'TaskTime.ScheduleStart': Indicate constrained
///   start date with ConstraintGrade=HARD and Benchmark of
///   EQUALTO, GREATERTHANOREQUALTO, or LESSTHANOREQUALTO to
///   indicate "must start on", "start no earlier than" or
///   "start no later than" respectively where
///   IfcMetric.DataValue indicates the specific
///   IfcDateTime. Use SOFT constraint having LESSTHAN
///   benchmark to indicate "start as soon as possible".
/// 
/// 'TaskTime.ScheduleFinish': Indicate constrained
///   finish date with ConstraintGrade=HARD and Benchmark of
///   EQUALTO, GREATERTHANOREQUALTO, or LESSTHANOREQUALTO to
///   indicate "must finish on", "finish no earlier than" or
///   "finish no later than" respectively where
///   IfcMetric.DateValue indicates the specific
///   IfcDateTime. Use SOFT constraint having
///   GREATERTHAN benchmark to indicate "finish as late as
///   possible".
/// 
/// A "manual scheduled task" is indicated with
///   ConstraintGrade=HARD and Benchmark=EQUALTO for both
///   TaskTime.ScheduleStart and
///   TaskTime.ScheduleFinish.
/// 
/// Figure 15 — Task constraints
/// 
/// Use Definition to represent other activities
/// 
/// The use definitions for IfcTask have been generalised to
///   represent other activities as well, including actitities
///   that had been defined by own entities in previous IFC
///   releases. This includes
/// 
/// Order actions
///   Move operations
/// 
/// IfcTask represents an order that might be carried
///   out by a Helpdesk acting the role of interface for the
///   organization between the facility user and the functional
///   requirement of fulfilling their needs. The actual task
///   represented by the IfcTask entity is turning a
///   request into an order and initiating the action that will
///   enable the order to be completed. The
///   IfcProjectOrder or one of its subtypes including
///   maintenance work order, is related to the IfcTask
///   using IfcRelAssignsToControl.
/// 
/// IfcTask can also be used to describe an activity
///   that moves people, groups within an organization or
///   complete organizations together with their associated
///   furniture and equipment from one place to another. It thus
///   replaces the previous IFC entity IfcMove. The functionality
///   is represented in IfcTask as follows:
/// 
/// Move from: The place from which actors and their
///   associated equipment are moving.
///   Use IfcRelAssignsToProcess where
///   RelatingProcess points to the task and
///   RelatedObjects holds the location(s) from which to
///   move.
///   Move to: The place to which actors and their
///   associated equipment are moving.
///   Use IfcRelAssignsToProduct where
///   RelatedObjects points to the task(s) and
///   RelatingProduct points to the location to which to
///   move.
///   Punch list: A list of points concerning a move that
///   require attention.
///   Use LongDescription or else identify sub-tasks to
///   track punch list items individually via IfcRelNests.
class IfcTask : public IfcProcess {
public:
    std::string TaskId() const;
    void setTaskId(std::string v);
    /// Whether the optional attribute Status is defined for this IfcTask
    bool hasStatus() const;
    /// Current status of the task.
    /// 
    /// NOTE: Particular values for status are not
    ///   specified, these should be determined and agreed by local
    ///   usage. Examples of possible status values include 'Not Yet
    ///   Started', 'Started', 'Completed'.
    std::string Status() const;
    void setStatus(std::string v);
    /// Whether the optional attribute WorkMethod is defined for this IfcTask
    bool hasWorkMethod() const;
    /// The method of work used in carrying out a task.
    /// 
    /// NOTE: This attribute should
    ///   not be used if the work method is specified for the
    ///   IfcTaskType
    std::string WorkMethod() const;
    void setWorkMethod(std::string v);
    /// Identifies whether a task is a milestone task (=TRUE) or not
    ///   (= FALSE).
    /// 
    /// NOTE: In small project planning applications,
    ///   a milestone task may be understood to be a task having no
    ///   duration. As such, it represents a singular point in
    ///   time.
    bool IsMilestone() const;
    void setIsMilestone(bool v);
    /// Whether the optional attribute Priority is defined for this IfcTask
    bool hasPriority() const;
    /// A value that indicates the relative priority of the task (in
    ///   comparison to the priorities of other tasks).
    int Priority() const;
    void setPriority(int v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 5: return IfcUtil::Argument_STRING; case 6: return IfcUtil::Argument_STRING; case 7: return IfcUtil::Argument_STRING; case 8: return IfcUtil::Argument_BOOL; case 9: return IfcUtil::Argument_INT; } return IfcProcess::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 5: return Type::IfcIdentifier; case 6: return Type::IfcLabel; case 7: return Type::IfcLabel; case 8: return Type::UNDEFINED; case 9: return Type::UNDEFINED; } return IfcProcess::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 5: return "TaskId"; case 6: return "Status"; case 7: return "WorkMethod"; case 8: return "IsMilestone"; case 9: return "Priority"; } return IfcProcess::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcTask (IfcAbstractEntity* e);
    IfcTask (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, std::string v6_TaskId, boost::optional< std::string > v7_Status, boost::optional< std::string > v8_WorkMethod, bool v9_IsMilestone, boost::optional< int > v10_Priority);
    typedef IfcTemplatedEntityList< IfcTask > list;
};
/// Definition from IAI: The element type
/// IfcTransportElementType defines commonly shared
/// information for occurrences of transport elements. The set of
/// shared information may include:
/// 
/// common properties within shared property sets
/// common material information
/// common shape representations
/// 
/// It is used to define a transport element specification (i.e.
/// the specific product information that is common to all
/// occurrences of that beam type). Transport element types (or the
/// instantiable subtypes) may be exchanged without being already
/// assigned to occurrences.
/// The occurrences of the IfcTransportElementType are
/// represented by instances of IfcTransportElement (or its
/// subtypes).
/// 
/// HISTORY: New entity in Release
/// IFC2x Edition 2.
/// 
/// Property Set Use Definition:
/// The shared property sets relating to the
/// IfcTransportElementType are defined by the
/// IfcPropertySet and are attached by the
/// HasPropertySets attribute. The following property set
/// definitions specific to the IfcTransportElementType are
/// part of this IFC release:
/// NOTE There is no differentiation between
/// properties within the property set that are only assignable to
/// IfcTransportElementType and those that are only assignable
/// to IfcTransportElement. If the same property is assigned
/// to the IfcTransportElementType and the
/// IfcTransportElement being an occurrence of the
/// IfcTransportElementType, then the occurrence property
/// overrides the type property.
/// 
/// Pset_TransportElementCommon: common property
/// set for all transport element types
/// 
/// Pset_TransportElementElevator: specific
/// property set for all types of transport elements with the
/// PredefinedType: ELEVATOR
/// 
/// Geometry Use Definition:
/// The IfcTransportElementType may define the shared
/// geometric representation for all transport element occurrences.
/// The RepresentationMaps attribute refers to a list of
/// IfcRepresentationMap's, that allow for multiple geometric
/// representations (e.g. with IfcShaperepresentation's having
/// an RepresentationIdentifier 'Box', 'FootPrint', or
/// 'Body').
/// NOTE The product shape representations are
/// defined as RepresentationMaps (attribute of the supertype
/// IfcTypeProduct), which get assigned by an element
/// occurrence instance through the
/// IfcShapeRepresentation.Item[n] being an
/// IfcMappedItem. See IfcTypeProduct for further
/// information.
/// NOTE The values of attributes
/// RepresentationIdentifier and RepresentationType of
/// IfcShapeRepresentation are restricted in the same way as
/// those for IfcTransportElementType.
class IfcTransportElementType : public IfcElementType {
public:
    /// Predefined types to define the particular type of the transport element. There may be property set definitions available for each predefined type.
    IfcTransportElementTypeEnum::IfcTransportElementTypeEnum PredefinedType() const;
    void setPredefinedType(IfcTransportElementTypeEnum::IfcTransportElementTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcElementType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcTransportElementTypeEnum; } return IfcElementType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcElementType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcTransportElementType (IfcAbstractEntity* e);
    IfcTransportElementType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcTransportElementTypeEnum::IfcTransportElementTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcTransportElementType > list;
};
/// The IfcActor defines all actors or human agents involved in a project during its full life cycle. It facilitates the use of person and organization definitions in the resource part of the IFC object model. This includes name, address, telecommunication addresses, and roles.
/// 
/// HISTORY New Entity in IFC Release 2.0
/// 
/// Relationship use definition
/// Actors are assigned (such as to a process or a resource) by the relationship object that refers to the corresponding object:
/// 
/// Process: assigned using IfcRelAssignsToProcess
/// Resource: assigned using IfcRelAssignsToResource
/// 
/// Property set use definition
/// The property sets relating to the IfcActor are defined by IfcPropertySet and attached by the
/// IfcRelDefinesByProperties relationship. They are accessible by the inverse IsDefinedBy relationship. The following property set definitions specific to IfcActor are part of this IFC release:
/// 
/// Pset_ActorCommon: common property set for all actor occurrences
class IfcActor : public IfcObject {
public:
    /// Information about the actor.
    IfcActorSelect* TheActor() const;
    void setTheActor(IfcActorSelect* v);
    virtual unsigned int getArgumentCount() const { return 6; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 5: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcObject::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 5: return Type::IfcActorSelect; } return IfcObject::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 5: return "TheActor"; } return IfcObject::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcRelAssignsToActor >::ptr IsActingUpon() const; // INVERSE IfcRelAssignsToActor::RelatingActor
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcActor (IfcAbstractEntity* e);
    IfcActor (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcActorSelect* v6_TheActor);
    typedef IfcTemplatedEntityList< IfcActor > list;
};
/// Definition from IAI: An annotation is a graphical
///   representation within the geometric (and spatial) context
///   of a project, that adds a note or meaning to the objects
///   which constitutes the project model. Annotations include
///   additional line drawings, text, dimensioning, hatching and
///   other forms of graphical notes.
/// 
/// NOTE Additional presentation information (often
///   2D) such as tag number, hatching, etc., that is directly
///   related to a particular product representation is
///   included within the IfcProductDefinitionShape
///   having various IfcShapeRepresentation's of the
///   IfcElement (and its subtypes). Only those
///   presentation information, that cannot be directly related
///   to a single product, have to be wrapped within the
///   IfcAnnotation.
/// 
/// If available, the annotation should be related to the
///   spatial context of the project, by containing the
///   annotation within the appropriate level of the building
///   structure (site, building, storey, or space). This is
///   handled by the IfcRelContainedInSpatialStructure
///   relationship.
/// 
/// HISTORY: New entity in
///   Release IFC2x Edition 2.
/// 
/// Use definition
/// 
/// The IfcAnnotation can provide specific 0D, 1D, and
///   2D geometric items as representation of the annotation,
///   offering annotation point, curves, and surfaces.
/// 
/// 'Annotation point' is an annotation provided by a
///   point that has additional semantic. The inherited
///   attribute ObjectType should be used to capture the
///   type of point annotation, some predefined values are:
/// 
/// 'Survey': A survey point has a set of
///   cartesian coordinates determined by its location at
///   point. These coordinates are determined relative to the
///   coordinates of a reference point, which acts as the
///   datum for the survey. The difference in elevation of
///   the survey points enables terrain to be determined.
/// 
/// 'Annotation curve' is an annotation provided by a
///   curve that has additional semantic. The inherited
///   attribute ObjectType should be used to capture the
///   type of curve annotation, some predefined values are:
/// 
/// 'ContourLine': A line of constant
///   elevation typically used on geographic maps where the
///   spacing of lines at constant intervals of elevation may
///   be used as an indication of slope.
/// 
/// 'IsoBar': A line of constant pressure
///   typically used on weather maps or to show pressure
///   gradient in spaces, chambers or externally.
/// 
/// 'IsoLux': A line of constant illumination
///   typically used to show the distribution of illumination
///   levels and/or daylighting in a space or externally.
/// 
/// 'IsoTherm': A line of constant temperature
///   typically used to show the distribution and effect of
///   heating or cooling within a space or to show
///   temperature distribution on a geographic map.
/// 
/// 'Annotation surface' is an annotation provided by
///   a surface that has additional semantic. The inherited
///   attribute ObjectType should be used to capture the
///   type of surface annotation, some predefined values are:
/// 
/// 'SurveyArea': A surface patch based on
///   survey points.
/// 
/// Geometry Use Definitions
/// 
/// The geometric representation of any IfcAnnotation is
///   given by the IfcProductDefinitionShape and
///   IfcLocalPlacement allowing multiple geometric
///   representations.
/// 
/// Local Placement
/// 
/// The local placement for any IfcAnnotation is defined
///   in its supertype IfcProduct. It is defined by the
///   IfcLocalPlacement, which defines the local
///   coordinate system that is referenced by all geometric
///   representations.
/// 
/// The PlacementRelTo relationship of
///   IfcLocalPlacement shall point (if given) to the
///   local placement of the same
///   IfcSpatialStructureElement, which is used in the 
///   ContainedInStructure inverse attribute, or to a
///   spatial structure element at a higher level, referenced
///   by that.
/// 
/// If the relative placement is not used, the absolute
///   placement is defined within the world coordinate system.
/// 
/// Geometric Representations
/// 
/// The standard representation of IfcAnnotation is
///   defined using 'Annotation2D', when using 2D geometry,
///   hatching and text, 'GeometricCurveSet' when using points
///   and curves, or, when including als surfaces, the
///   'GeometricSet' geometry. Geometric representation items may
///   be styled items by adding the style information.
/// 
/// Annotation2D Representation
///   This representation is used, when the representation of the
///   IfcAnnotation includes specific drafting
///   representation elements. The Annotation may have:
/// 
/// subtypes of IfcPoint, IfcCurve being 2D
/// 
/// directly as Items, or
///   within an IfcGeometricCurveSet
/// 
/// subtypes of IfcAnnotationFillArea for hatches
/// 
/// subtypes of IfcDefinedSymbol for symbols
/// 
/// subtypes of IfcTextLiteral for text
/// 
/// subtypes of IfcDraughtingCallout for dimensions
/// 
/// The following attribute values for the
///   IfcShapeRepresentation holding this geometric
///   representation shall be used:
/// 
/// RepresentationIdentifier : 'Annotation'
/// 
/// RepresentationType : 'Annotation2D'
/// 
/// Annotation Curve Representation
///   This representation is used, when the representation of the
///   IfcAnnotation does not includes specific drafting
///   representation elements. The Annotation may have:
/// 
/// subtypes of IfcPoint, IfcCurve being 2D
/// 
/// directly as Items, or
///   within an IfcGeometricCurveSet
/// 
/// The following attribute values for the
///   IfcShapeRepresentation holding this geometric
///   representation shall be used:
/// 
/// RepresentationIdentifier : 'Annotation'
/// 
/// RepresentationType : 'GeometricCurveSet'
/// 
/// Annotation Surface Representation
///   This representation is used, when the representation of the
///   IfcAnnotation does includes surfaces. The Annotation
///   may have:
/// 
/// subtypes of IfcPoint, IfcCurve, or
///   IfcSurface
/// 
/// directly as Items, or
///   within an IfcGeometricCurveSet
/// 
/// The following attribute values for the
///   IfcShapeRepresentation holding this geometric
///   representation shall be used:
/// 
/// RepresentationIdentifier : 'Annotation'
/// 
/// RepresentationType : 'GeometricSet'
class IfcAnnotation : public IfcProduct {
public:
    virtual unsigned int getArgumentCount() const { return 7; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcProduct::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcProduct::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcProduct::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcRelContainedInSpatialStructure >::ptr ContainedInStructure() const; // INVERSE IfcRelContainedInSpatialStructure::RelatedElements
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcAnnotation (IfcAbstractEntity* e);
    IfcAnnotation (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation);
    typedef IfcTemplatedEntityList< IfcAnnotation > list;
};
/// IfcAsymmetricIShapeProfileDef
/// defines a section profile that provides the defining parameters of a
/// singly symmetric I-shaped section. Its parameters and orientation relative to the
/// position coordinate system are according to the following illustration.
/// The centre of the position coordinate system is in the profile's centre
/// of the bounding box.
/// 
/// The inherited attributes are redefined as:
/// 
/// OverallWidth -- BottomFlangeWidth
///   FlangeThickness -- BottomFlangeThickness
///   FilletRadius -- BottomFlangeFilletRadius
/// 
/// The overall width of the profile is implicitly given by the maximum of
/// the bottom flange width and the top flange width.
/// 
/// IfcAsymmetricIShapeProfileDef can also be used to model rail profiles
/// if the application scenario does not require a full explicit shape model of the
/// rail profile. Alternatively, IfcArbitraryClosedProfileDef can be
/// used to provide the exact shape of rail profiles. Either way, a reference
/// to an external document or library should be provided to further define the
/// profile as described at IfcProfileDef.
/// 
/// HISTORY  New entity in Release IFC2x Edition 2.
/// 
/// IFC2x3 CHANGE  All profile origins are now in the center of the bounding box. The attribute CentreOfGravityInY has been made OPTIONAL.
/// 
/// IFC2x4 CHANGE  Bottom flange is not necessarily wider than top flange. TopFlangeThickness changed from OPTIONAL to mandatory. Type of TopFlangeFilletRadius relaxed to allow for zero radius. Trailing attribute CentreOfGravityInY deleted, use respective property in IfcExtendedProfileProperties instead.
/// 
/// Figure 310 illustrates parameters of the asymmetric I-shaped section definition. The parameterized profile defines its own position coordinate system. The underlying coordinate system is defined by the swept area solid that uses the profile definition. It is the xy plane of:
/// 
/// IfcSweptAreaSolid.Position
/// 
/// By using offsets of the position location, the parameterized profile can be positioned centric (using x,y offsets = 0.), or at any position
/// relative to the profile. The parameterized profile is defined by a set of parameter attributes.  In the illustrated example, the 'CentreOfGravityInY' property in IfcExtendedProfileProperties, if provided, is negative.
/// 
/// Figure 310 — Assymetric I-shape profile
class IfcAsymmetricIShapeProfileDef : public IfcIShapeProfileDef {
public:
    /// Extent of the top flange, defined parallel to the x axis of the position coordinate system.
    double TopFlangeWidth() const;
    void setTopFlangeWidth(double v);
    /// Whether the optional attribute TopFlangeThickness is defined for this IfcAsymmetricIShapeProfileDef
    bool hasTopFlangeThickness() const;
    /// Flange thickness of the top flange of the I-shape.
    double TopFlangeThickness() const;
    void setTopFlangeThickness(double v);
    /// Whether the optional attribute TopFlangeFilletRadius is defined for this IfcAsymmetricIShapeProfileDef
    bool hasTopFlangeFilletRadius() const;
    /// The fillet between the web and the top flange of the I-shape.
    double TopFlangeFilletRadius() const;
    void setTopFlangeFilletRadius(double v);
    /// Whether the optional attribute CentreOfGravityInY is defined for this IfcAsymmetricIShapeProfileDef
    bool hasCentreOfGravityInY() const;
    double CentreOfGravityInY() const;
    void setCentreOfGravityInY(double v);
    virtual unsigned int getArgumentCount() const { return 12; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_DOUBLE; case 9: return IfcUtil::Argument_DOUBLE; case 10: return IfcUtil::Argument_DOUBLE; case 11: return IfcUtil::Argument_DOUBLE; } return IfcIShapeProfileDef::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcPositiveLengthMeasure; case 9: return Type::IfcPositiveLengthMeasure; case 10: return Type::IfcPositiveLengthMeasure; case 11: return Type::IfcPositiveLengthMeasure; } return IfcIShapeProfileDef::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "TopFlangeWidth"; case 9: return "TopFlangeThickness"; case 10: return "TopFlangeFilletRadius"; case 11: return "CentreOfGravityInY"; } return IfcIShapeProfileDef::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcAsymmetricIShapeProfileDef (IfcAbstractEntity* e);
    IfcAsymmetricIShapeProfileDef (IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< std::string > v2_ProfileName, IfcAxis2Placement2D* v3_Position, double v4_OverallWidth, double v5_OverallDepth, double v6_WebThickness, double v7_FlangeThickness, boost::optional< double > v8_FilletRadius, double v9_TopFlangeWidth, boost::optional< double > v10_TopFlangeThickness, boost::optional< double > v11_TopFlangeFilletRadius, boost::optional< double > v12_CentreOfGravityInY);
    typedef IfcTemplatedEntityList< IfcAsymmetricIShapeProfileDef > list;
};
/// The IfcBlock is a Construction Solid Geometry (CSG) 3D
/// primitive. It is defined by a position and a positve distance along
/// the three orthogonal axes. The inherited Position
/// attribute has the IfcAxisPlacement3D type and
/// provides:
/// 
/// SELF\IfcCsgPrimitive3D.Position: The location and
/// orientation of the axis system for the primitive.
/// SELF\IfcCsgPrimitive3D.Position.Location: The block
/// has one vertex at location and the edges are aligned with the
/// placement axes in the positive sense.
/// 
/// The XLength, YLength, and ZLength
/// attributes define the size of the IfcBlock along the three
/// axes.
/// The following definitions from ISO 10303-42 apply:
/// 
/// A block is a solid
/// rectangular parallelepiped, defined with a location and placement
/// coordinate system. The block is specified by the positive lengths
/// x, y, and z along the axes of the placement coordinate system, and
/// has one vertex at the origin of the placement coordinate
/// system.
/// 
/// Figure 250 illustrates geometric parameters of a block where the block positioned within its own placement coordinate system. The values for XLength, YLength, and ZLength are applied to the positive direction of the X, Y, and Z axis.
/// 
/// Figure 250 — Block geometry
/// 
/// NOTE  Corresponding ISO 10303-42 entity: block, the position attribute has been promoted to the immediate supertype IfcCsgPrimitive3D. Please refer to ISO 10303-42:1994, p. 244 for the definition in the international standard.
/// 
/// HISTORY  New entity in IFC2x3.
/// 
/// Texture use definition
/// On each side face, textures are aligned facing upright. On the
/// top and bottom faces, textures are aligned facing front-to-back.
/// Textures are stretched or repeated to the extent of each face
/// according to RepeatS and RepeatT.
/// 
/// Figure 251 illustrates default texture mapping with a clamped texture (RepeatS=False and RepeatT=False). The image on the left shows the texture where the S axis points to the right and the T axis points up. The image on the right shows the texture applied to the geometry where the X axis points back to the right, the Y axis points back to the left, and the Z axis points up.
/// 
/// Side
/// Normal
/// Origin X
/// Origin Y
/// Origin Z
/// S Axis
/// T Axis
/// 
/// Left
/// -X
/// 0
/// +YLength
/// 0
/// -Y
/// +Z
/// 
/// Right
/// +X
/// 0
/// +YLength
/// 0
/// +Y
/// +Z
/// 
/// Front
/// +X
/// 0
/// 0
/// 0
/// +X
/// +Z
/// 
/// Back
/// +Y
/// +XLength
/// +YLength
/// 0
/// -X
/// +Z
/// 
/// Bottom
/// -Z
/// +XLength
/// 0
/// 0
/// -X
/// +Y
/// 
/// Top
/// +Z
/// 0
/// 0
/// +ZLength
/// +X
/// +Y
/// 
/// Figure 251 — Block textures
class IfcBlock : public IfcCsgPrimitive3D {
public:
    /// The size of the block along the placement X axis. It is provided by the inherited axis placement through SELF\IfcCsgPrimitive3D.Position.P[1].
    double XLength() const;
    void setXLength(double v);
    /// The size of the block along the placement Y axis. It is provided by the inherited axis placement through SELF\IfcCsgPrimitive3D.Position.P[2].
    double YLength() const;
    void setYLength(double v);
    /// The size of the block along the placement Z axis. It is provided by the inherited axis placement through SELF\IfcCsgPrimitive3D.Position.P[3].
    double ZLength() const;
    void setZLength(double v);
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 1: return IfcUtil::Argument_DOUBLE; case 2: return IfcUtil::Argument_DOUBLE; case 3: return IfcUtil::Argument_DOUBLE; } return IfcCsgPrimitive3D::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 1: return Type::IfcPositiveLengthMeasure; case 2: return Type::IfcPositiveLengthMeasure; case 3: return Type::IfcPositiveLengthMeasure; } return IfcCsgPrimitive3D::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 1: return "XLength"; case 2: return "YLength"; case 3: return "ZLength"; } return IfcCsgPrimitive3D::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcBlock (IfcAbstractEntity* e);
    IfcBlock (IfcAxis2Placement3D* v1_Position, double v2_XLength, double v3_YLength, double v4_ZLength);
    typedef IfcTemplatedEntityList< IfcBlock > list;
};
/// A clipping result is defined as a special subtype of the general Boolean result (IfcBooleanResult). It constrains the operands and the operator of the Boolean result. 
/// 
/// A clipping result is the Boolean difference between a solid (restricted to swept area solid) and a half space solid, whereas more than one difference operation can be applied to the Boolean result. 
/// 
/// NOTE The IfcBooleanClippingResult is defined as a special case of the boolean_result, as defined in ISO 10303-42:1994, p. 175. It has been added to apply further constraints to the CSG representation type.
/// 
/// HISTORY New entity in IFC Release 2.x.
class IfcBooleanClippingResult : public IfcBooleanResult {
public:
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcBooleanResult::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcBooleanResult::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcBooleanResult::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcBooleanClippingResult (IfcAbstractEntity* e);
    IfcBooleanClippingResult (IfcBooleanOperator::IfcBooleanOperator v1_Operator, IfcBooleanOperand* v2_FirstOperand, IfcBooleanOperand* v3_SecondOperand);
    typedef IfcTemplatedEntityList< IfcBooleanClippingResult > list;
};
/// Definition from ISO/CD 10303-42:1992: A bounded curve is a curve of finite arc length with identifiable end points. 
/// 
/// NOTE Corresponding ISO 10303 name: bounded_curve, only the following subtypes have been incorporated into IFC: polyline as IfcPolyline, trimmed_curve as IfcTrimmedCurve, composite_curve as IfcCompositeCurve. Please refer to ISO/IS 10303-42:1994, p.44 for the final definition of the formal standard.
/// 
/// HISTORY New class in IFC Release 1.0
/// 
/// Informal propositions: 
/// 
/// A bounded curve has finite arc length. 
/// A bounded curve has a start point and an end point.
class IfcBoundedCurve : public IfcCurve {
public:
    virtual unsigned int getArgumentCount() const { return 0; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcCurve::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcCurve::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcCurve::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcBoundedCurve (IfcAbstractEntity* e);
    IfcBoundedCurve ();
    typedef IfcTemplatedEntityList< IfcBoundedCurve > list;
};
/// Definition from ISO 6707-1:1989: Construction work that
/// has the provision of shelter for its occupants or contents as one
/// of its main purpose and is normally designed to stand permanently
/// in one place.
/// A building represents a structure
/// that provides shelter for its occupants or contents and stands in
/// one place. The building is also used to provide a basic element
/// within the spatial structure hierarchy for the components of a
/// building project (together with site, storey, and space).
/// A building is (if specified) associated to a site. A building
/// may span over several connected or disconnected buildings.
/// Therefore building complex provides for a collection of buildings
/// included in a site. A building can also be decomposed in
/// (vertical) parts, where each part defines a building section.
/// This is defined by the composition type attribute of the
/// supertype IfcSpatialStructureElements which is interpreted
/// as follow:
/// 
/// COMPLEX = building complex
/// ELEMENT = building
/// PARTIAL = building section
/// 
/// HISTORY New entity in IFC Release 1.0.
/// 
/// Property Set Use Definition
/// The property sets relating to the IfcBuilding are
/// defined by the IfcPropertySet and attached by the
/// IfcRelDefinesByProperties relationship. It is accessible
/// by the inverse IsDefinedBy relationship. The following
/// property set definitions specific to the IfcBuilding are
/// part of this IFC release:
/// 
/// Pset_BuildingCommon: common property set for all
/// types of buildings
/// Pset_BuildingWaterStorage: specific property
/// set for buildings to capture the water supply requirements
/// Pset_BuildingUse: specific property set for
/// buildings to capture the current and anticipated real estate
/// context.
/// Pset_BuildingUseAdjacent: specific property
/// set for buildings to capture the use information about the
/// adjacent buildings.
/// 
/// Quantity Use Definition
/// The quantities relating to the IfcBuilding are defined
/// by the IfcElementQuantity and attached by the
/// IfcRelDefinesByProperties relationship. It is accessible
/// by the inverse IsDefinedBy relationship. The following
/// base quantities are defined and should be exchanged with the
/// IfcElementQuantity.Name = 'BaseQuantities'. Other
/// quantities, being subjected to local standard of measurement, can
/// be defined with another string value assigned to Name. In
/// this case a valid value for MethodOfMeasurement has to be
/// provided.
/// 
/// Qto_BuildingBaseQuantities: base quantities
/// for all building occurrences.
/// 
/// Spatial Structure Use Definition
/// The IfcBuilding is used to build the spatial structure
/// of a building (that serves as the primary project breakdown and
/// is required to be hierarchical). The spatial structure elements
/// are linked together by using the objectified relationship
/// IfcRelAggregates. The IfcBuilding references them
/// by its inverse relationships:
/// 
/// IfcBuilding.Decomposes -- referencing (IfcSite
/// || IfcBuilding) by IfcRelAggregates.RelatingObject,
/// If it refers to another instance of IfcBuilding, the
/// referenced IfcBuilding needs to have a different and
/// higher CompositionType, i.e. COMPLEX (if the other
/// IfcBuilding has ELEMENT), or ELEMENT (if the other
/// IfcBuilding has PARTIAL).
/// IfcBuilding.IsDecomposedBy -- referencing
/// (IfcBuilding || IfcBuildingStorey) by
/// IfcRelAggregates.RelatedObjects. If it refers to another
/// instance ofÿIfcBuilding, the referenced IfcBuilding
/// needs to have a different and lower CompositionType, i.e. ELEMENT
/// (if the other IfcBuilding has COMPLEX), or PARTIAL (if the
/// other IfcBuilding has ELEMENT).
/// 
/// If there are building elements and/or other elements directly
/// related to the IfcBuildingÿ(like a curtain wall spanning
/// several stories), they are associated with the IfcBuilding
/// by using the objectified relationship
/// IfcRelContainedInSpatialStructure. The IfcBuilding
/// references them by its inverse relationship:
/// 
/// IfcBuilding.ContainsElements -- referencing any
/// subtype of IfcProduct (with the exception of other spatial
/// structure element) by
/// IfcRelContainedInSpatialStructure.RelatedElements.
/// 
/// Figure 20 shows the IfcBuilding as part of the spatial
/// structure. It also serves as the spatial container for building
/// and other elements.
/// NOTE Detailed requirements on mandatory element
/// containment and placement structure relationships are given in
/// view definitions and implementer agreements.
/// 
/// Figure 20 — Building composition
/// 
/// Systems, such as building service or electrical distribution
/// systems, zonal systems, or structural analysis systems, relate to
/// IfcBuilding by using the objectified relationship
/// IfcRelServicesBuildings.
/// 
/// Attribute Use Definition
/// 
/// Figure 21 describes the heights and elevations  of the IfcBuilding. It is used to provide the height above sea level of the project height datum for this building, that is, the internal height 0.00. The height 0.00 is often used as a building internal reference height and equal to the floor finish level of the ground floor.
/// 
/// base elevation of building provided by: IfcBuilding.ElevationOfRefHeight, it is usually the top of construction slab
/// base elevation of terrain at the perimeter of the building provided by: IfcBuilding.ElevationOfTerrain, it is usually the minimum elevation is sloped terrain
/// total height of building, also referred to as ridge height (top of roof structure, e.g the ridge against terrain): provided by BaseQuantity with Name="TotalHeight"
/// eaves height of building (base of roof structure, e.g the eaves against terrain): provided by BaseQuantity with Name="EavesHeight"
/// 
/// ÿ
/// Figure 21 — Building elevations
/// 
/// Geometry Use Definitions
/// The geometric representation of IfcBuilding is given by
/// the IfcProductDefinitionShape and
/// IfcLocalPlacement, allowing multiple geometric
/// representation.
/// Local Placement
/// The local placement for IfcBuilding is defined in its
/// supertype IfcProduct. It is defined by the
/// IfcLocalPlacement, which defines the local coordinate
/// system that is referenced by all geometric representations.
/// 
/// The PlacementRelTo relationship of
/// IfcLocalPlacement shall point (if relative placement is
/// used) to the IfcSpatialStructureElement of type
/// IfcSite, or of type IfcBuilding (e.g. to position a
/// building relative to a building complex, or a building section to
/// a building).
/// If the relative placement is not used, the absolute placement
/// is defined within the world coordinate system.
/// 
/// Geometric Representations
/// Currently, the use of a 2D 'FootPrint' representation of type
/// 'GeometricCurveSet' and a 3D 'Body' representation of type 'Brep'
/// is supported.
/// Foot Print Representation
/// The foot print representation of IfcBuilding is given
/// by either a single 2D curve (such as IfcPolyline or
/// IfcCompositeCurve), or by a list of 2D curves (in case of
/// inner boundaries), if the building has an independent geometric
/// representation.
/// The representation identifier and type of this geometric
/// representation of IfcBuilding is:
/// 
/// IfcShapeRepresentation.RepresentationIdentifier =
/// 'FootPrint'
/// IfcShapeRepresentation.RepresentationType =
/// 'GeometricCurveSet'
/// 
/// Body Representation
/// The body (or solid model) geometric representation (if the
/// building has an independent geometric representation) of
/// IfcBuilding is defined using faceted B-Rep capabilities
/// (with or without voids), based on the IfcFacetedBrep or on
/// the IfcFacetedBrepWithVoids.
/// The representation identifier and type of this representation
/// of IfcBuilding is:
/// 
/// IfcShapeRepresentation.RepresentationIdentifier =
/// 'Body'
/// IfcShapeRepresentation.RepresentationType =
/// 'Brep'
/// 
/// Since the building shape is usually described by the exterior
/// building elements, an independent shape representation shall only
/// be given, if the building is exposed independently from its
/// constituting elements.
class IfcBuilding : public IfcSpatialStructureElement {
public:
    /// Whether the optional attribute ElevationOfRefHeight is defined for this IfcBuilding
    bool hasElevationOfRefHeight() const;
    /// Elevation above sea level of the reference height used for all storey elevation measures, equals to height 0.0. It is usually the ground floor level.
    double ElevationOfRefHeight() const;
    void setElevationOfRefHeight(double v);
    /// Whether the optional attribute ElevationOfTerrain is defined for this IfcBuilding
    bool hasElevationOfTerrain() const;
    /// Elevation above the minimal terrain level around the foot print of the building, given in elevation above sea level.
    double ElevationOfTerrain() const;
    void setElevationOfTerrain(double v);
    /// Whether the optional attribute BuildingAddress is defined for this IfcBuilding
    bool hasBuildingAddress() const;
    /// Address given to the building for postal purposes.
    IfcPostalAddress* BuildingAddress() const;
    void setBuildingAddress(IfcPostalAddress* v);
    virtual unsigned int getArgumentCount() const { return 12; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_DOUBLE; case 10: return IfcUtil::Argument_DOUBLE; case 11: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcSpatialStructureElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcLengthMeasure; case 10: return Type::IfcLengthMeasure; case 11: return Type::IfcPostalAddress; } return IfcSpatialStructureElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "ElevationOfRefHeight"; case 10: return "ElevationOfTerrain"; case 11: return "BuildingAddress"; } return IfcSpatialStructureElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcBuilding (IfcAbstractEntity* e);
    IfcBuilding (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_LongName, IfcElementCompositionEnum::IfcElementCompositionEnum v9_CompositionType, boost::optional< double > v10_ElevationOfRefHeight, boost::optional< double > v11_ElevationOfTerrain, IfcPostalAddress* v12_BuildingAddress);
    typedef IfcTemplatedEntityList< IfcBuilding > list;
};
/// Definition from IAI: The element type
///   (IfcBuildingElementType) defines a list of commonly
///   shared property set definitions of a building element and
///   an optional set of product representations. It is used to
///   define an element specification (i.e. the specific product
///   information, that is common to all occurrences of that
///   product type).
/// 
/// NOTE: The product representations are
///   defined as representation maps (at the level of the
///   supertype IfcTypeProduct, which gets assigned by
///   an element occurrence instance through the
///   IfcShapeRepresentation.Item[1] being an
///   IfcMappedItem.
/// 
/// A building element type is used to define the common
///   properties of a certain type of a building element that may
///   be applied to many instances of that feature type to assign
///   a specific style. Building element types (or the
///   instantiable subtypes) may be exchanged without being
///   already assigned to occurrences.
/// 
/// The IfcBuildingElementType is an abstract type.
///   Occurrences of subtypes of the
///   IfcBuildingElementType are represented by instances
///   of the appropriate subtypes of IfcBuildingElement.
/// 
/// HISTORY  New entity in
///   Release IFC2x Edition 2.
class IfcBuildingElementType : public IfcElementType {
public:
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcElementType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcElementType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcElementType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcBuildingElementType (IfcAbstractEntity* e);
    IfcBuildingElementType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType);
    typedef IfcTemplatedEntityList< IfcBuildingElementType > list;
};
/// The building storey has an
/// elevation and typically represents a (nearly) horizontal
/// aggregation of spaces that are vertically bound.
/// A storey is (if specified) associated to a building. A storey
/// may span over several connected storeys. Therefore storey complex
/// provides for a collection of storeys included in a building. A
/// storey can also be decomposed in (horizontical) parts, where each
/// part defines a partial storey. This is defihned by the composition
/// type attribute of the supertype
/// IfcSpatialStructureElements which is interpreted as
/// follow:
/// 
/// COMPLEX = building storey complex
/// ELEMENT = building storey
/// PARTIAL = partial building storey
/// 
/// EXAMPLE In split level houses, a storey is split into two or more partial storeys, each with a different elevation. It can be handled by defining a storey, which includes two or more partial storeys with the individual elevations.
/// HISTORY New entity in IFC Release 1.0
/// 
/// Property Set Use Definition
/// The property sets relating to the IfcBuildingStorey are
/// defined by the IfcPropertySet and attached by the
/// IfcRelDefinesByProperties relationship. It is accessible
/// by the inverse IsDefinedBy relationship. The following
/// property set definitions specific to the IfcBuildingStorey
/// are part of this IFC release:
/// 
/// Pset_BuildingStoreyCommon: common property
/// set for all types of building stories
/// 
/// Quantity Use Definition
/// The quantities relating to the IfcBuildingStorey are
/// defined by the IfcElementQuantity and attached by the
/// IfcRelDefinesByProperties relationship. It is accessible
/// by the inverse IsDefinedBy relationship. The following
/// base quantities are defined and should be exchanged with the
/// IfcElementQuantity.Name = 'BaseQuantities'. Other
/// quantities, being subjected to local standard of measurement, can
/// be defined with another string value assigned to Name. In
/// this case a valid value for MethodOfMeasurement has to be
/// provided.
/// 
/// Qto_BuildingStoreyBaseQuantities: base
/// quantities for all building storey occurrences.
/// 
/// Spatial Structure Use Definition
/// The IfcBuildingStorey is used to build the spatial
/// structure of a building (that serves as the primary project
/// breakdown and is required to be hierarchical). The spatial
/// structure elements are linked together by using the objectified
/// relationship IfcRelAggregates. The
/// IfcBuildingStoreyreferences them by its inverse
/// relationships:
/// 
/// IfcBuildingStorey.Decomposes -- referencing
/// (IfcBuilding || IfcBuildingStorey) by
/// IfcRelAggregates.RelatingObject, If it refers to another
/// instance ofÿIfcBuildingStorey, the referenced
/// IfcBuildingStorey needs to have a different and higher
/// CompositionType, i.e. COMPLEX (if the other
/// IfcBuildingStorey has ELEMENT), or ELEMENT (if the other
/// IfcBuildingStorey has PARTIAL).
/// IfcBuildingStorey.IsDecomposedBy -- referencing
/// (IfcBuildingStorey || IfcSpace) by
/// IfcRelAggregates.RelatedObjects. If it refers to another
/// instance ofÿIfcBuildingStorey, the referenced
/// IfcBuildingStorey needs to have a different and lower
/// CompositionType, i.e. ELEMENT (if the other
/// IfcBuildingStorey has COMPLEX), or PARTIAL (if the other
/// IfcBuildingStorey has ELEMENT).
/// 
/// If there are building elements and/or other elements directly
/// related to the IfcBuildingStorey (like most building
/// elements, such as walls, columns, etc.), they are associated with
/// the IfcBuildingStorey by using the objectified
/// relationship IfcRelContainedInSpatialStructure. The
/// IfcBuildingStorey references them by its inverse
/// relationship:
/// 
/// IfcBuildingStorey.ContainsElements -- referencing any
/// subtype of IfcProduct (with the exception of other spatial
/// structure element) by
/// IfcRelContainedInSpatialStructure.RelatedElements.
/// 
/// Figure 25 shows the IfcBuildingStorey as part of the
/// spatial structure. It also serves as the spatial container for
/// building and other elements.
/// NOTE Detailed requirements on mandatory element
/// containment and placement structure relationships are given in
/// view definitions and implementer agreements.
/// 
/// Figure 25 — Building storey composition
/// 
/// Elements can also be referenced in an
/// IfcBuildingStorey, for example, if they span through several
/// storeys. This is expressed by using the objectified relationship
/// IfcRelReferencedInSpatialStructure. Systems, such as
/// building service or electrical distribution systems, zonal
/// systems, or structural analysis systems, relate to
/// IfcBuildingStorey by using the objectified relationship
/// IfcRelServicesBuildings.
/// 
/// Attribute Use Definition
/// 
/// Figure 26 describes the heights and elevations of the IfcBuildingStorey.
/// 
/// elevation of storey provided by: IfcBuildingStorey.Elevation as a local height value
/// relative to IfcBuilding.ElevationOfRefHeight, it is usually the top of construction slab
/// net height of storey, also referred to as total height or system height (top of construction slab to top of construction slab above): provided by BaseQuantity with Name="GrossHeight"
/// net height of storey (top of construction slab to bottom of construction slab above): provided by BaseQuantity with Name="NetHeight"
/// 
/// Figure 26 — Building storey elevations
/// 
/// Geometry Use Definitions
/// The geometric representation of IfcBuildingStorey is
/// given by the IfcProductDefinitionShape and
/// IfcLocalPlacement, allowing multiple geometric
/// representation.
/// Local Placement
/// The local placement for IfcBuildingStorey is defined in
/// its supertype IfcProduct. It is defined by the
/// IfcLocalPlacement, which defines the local coordinate
/// system that is referenced by all geometric representations.
/// 
/// The PlacementRelTo relationship of
/// IfcLocalPlacement shall point (if relative placement is
/// used) to the IfcSpatialStructureElement of type
/// IfcBuilding, or of type IfcBuildingStorey (e.g. to
/// position a building storey relative to a building storey complex,
/// or a partial building storey to a building storey).
/// If the relative placement is not used, the absolute placement
/// is defined within the world coordinate system.
/// 
/// Geometric Representations
/// Currently, the use of a 2D 'FootPrint' representation of type
/// 'GeometricCurveSet' and a 3D 'Body' representation of type 'Brep'
/// is supported.
/// 
/// NOTE The independent geometric representation of
/// IfcBuildingStorey may not be required or allowed in
/// certain view definitions. In those cases only the contained
/// elements and spaces have an independent geometric
/// representation.
/// 
/// Foot Print Representation
/// The foot print representation of IfcBuildingStorey is
/// given by either a single 2D curve (such as IfcPolyline or
/// IfcCompositeCurve), or by a list of 2D curves (in case of
/// inner boundaries), if the building storey has an independent
/// geometric representation.
/// The representation identifier and type of this geometric
/// representation of IfcBuildingStorey is:
/// 
/// IfcShapeRepresentation.RepresentationIdentifier =
/// 'FootPrint'
/// IfcShapeRepresentation.RepresentationType =
/// 'GeometricCurveSet'
/// 
/// Body Representation
/// The body (or solid model) geometric representation (if the
/// building storey has an independent geometric representation) of
/// IfcBuildingStorey is defined using faceted B-Rep
/// capabilities (with or without voids), based on the
/// IfcFacetedBrep or on the
/// IfcFacetedBrepWithVoids.
/// The representation identifier and type of this representation
/// of IfcBuildingStorey is:
/// 
/// IfcShapeRepresentation.RepresentationIdentifier =
/// 'Body'
/// IfcShapeRepresentation.RepresentationType =
/// 'Brep'
/// 
/// Since the building storey shape is usually described by the
/// exterior building elements, an independent shape representation
/// shall only be given, if the building storey is exposed
/// independently from its constituting elements.
class IfcBuildingStorey : public IfcSpatialStructureElement {
public:
    /// Whether the optional attribute Elevation is defined for this IfcBuildingStorey
    bool hasElevation() const;
    /// Elevation of the base of this storey, relative to the 0,00 internal reference height of the building. The 0.00 level is given by the absolute above sea level height by the ElevationOfRefHeight attribute given at IfcBuilding.
    double Elevation() const;
    void setElevation(double v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_DOUBLE; } return IfcSpatialStructureElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcLengthMeasure; } return IfcSpatialStructureElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "Elevation"; } return IfcSpatialStructureElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcBuildingStorey (IfcAbstractEntity* e);
    IfcBuildingStorey (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_LongName, IfcElementCompositionEnum::IfcElementCompositionEnum v9_CompositionType, boost::optional< double > v10_Elevation);
    typedef IfcTemplatedEntityList< IfcBuildingStorey > list;
};
/// IfcCircleHollowProfileDef
/// defines a section profile that provides the defining parameters of a
/// circular hollow section (tube) to be used by the swept area solid. Its
/// parameters and orientation relative to the
/// position coordinate system are according to the following
/// illustration.The centre of the position coordinate system is in the
/// profile's centre of the bounding box (for symmetric profiles identical
/// with the centre of gravity).
/// 
/// HISTORY  New entity in IFC2x2.
/// 
/// Figure 312 illustrates parameters of the circular hollow profile definition. The parameterized profile defines its own position coordinate system. The underlying coordinate system is defined by the swept area solid that uses the profile definition. It is the xy plane of:
/// 
/// IfcSweptAreaSolid.Position
/// 
/// By using offsets of the position location, the parameterized profile can be positioned centric (using x,y offsets = 0.), or at any position relative to the profile. Explicit coordinate offsets are used to define cardinal points (for example, upper-left bound). The parameterized profile is defined by a set of parameter attributes.
/// 
/// Figure 312 — Circle hollow profile
class IfcCircleHollowProfileDef : public IfcCircleProfileDef {
public:
    /// Thickness of the material, it is the difference between the outer and inner radius.
    double WallThickness() const;
    void setWallThickness(double v);
    virtual unsigned int getArgumentCount() const { return 5; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 4: return IfcUtil::Argument_DOUBLE; } return IfcCircleProfileDef::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 4: return Type::IfcPositiveLengthMeasure; } return IfcCircleProfileDef::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 4: return "WallThickness"; } return IfcCircleProfileDef::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCircleHollowProfileDef (IfcAbstractEntity* e);
    IfcCircleHollowProfileDef (IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< std::string > v2_ProfileName, IfcAxis2Placement2D* v3_Position, double v4_Radius, double v5_WallThickness);
    typedef IfcTemplatedEntityList< IfcCircleHollowProfileDef > list;
};
/// Definition from IAI: The element type
/// IfcColumnType defines commonly shared information for
/// occurrences of columns. The set of shared information may
/// include:
/// 
/// common properties within shared property sets
/// common material information
/// common profile definitions
/// common shape representations
/// 
/// It is used to define a column specification, or column style
/// (i.e. the specific product information that is common to all
/// occurrences of that column type). Column types may be exchanged
/// without being already assigned to occurrences.
/// Occurrences of the IfcColumnType within building models
/// are represented by instances of IfcColumnStandardCase if
/// the IfcColumnType has a single associated
/// IfcMaterialProfileSet; otherwise they are represented by
/// instances of IfcColumn. Occurrences of the
/// IfcColumnType within structural analysis models are
/// represented by instances of IfcStructuralCurveMember, or
/// its applicable subtypes.
/// HISTORY New entity in
/// Release IFC2x Edition 2.
/// Material Use Definition
/// The material of the IfcColumnType is defined by the
/// IfcMaterialProfileSet or as fall back by
/// IfcMaterial and attached by the
/// IfcRelAssociatesMaterial.RelatingMaterial. It is
/// accessible by the inverse HasAssociations
/// relationship.
/// Note: It is illegal to assign an
/// IfcMaterial to an IfcColumnType, if there is at
/// least one occurrences of IfcColumnStandardCase for this
/// type.
/// Property Set Use Definition:
/// The shared property sets relating to the IfcColumnType
/// are defined by the IfcPropertySet and are attached by the
/// HasPropertySets attribute. The following property set
/// definitions specific to the IfcColumnType are part of this
/// IFC release:
/// NOTE There is no differentiation between
/// properties within the property set that are only assignable to
/// IfcColumnType and those that are only assignable to
/// IfcColumn. If the same property is assigned to the
/// IfcColumnType and the IfcColumn being an occurrence
/// of the IfcColumnType, then the occurrence property
/// overrides the type property.
/// 
/// Pset_ColumnCommon: common property set for all
/// column types.
/// 
/// Profile Use Definition:
/// The shared profile definition is defined by assigning an
/// IfcMaterialProfileSet (see material use definition above).
/// The IfcMaterialProfile refers to the subtype of
/// IfcProfileDef that is the common profile for all column
/// occurrence, if used. It is only applicable if the
/// IfcColumnType has only occurrences of type
/// IfcColumnStandardCase (see definition of
/// IfcColumnStandardCase for further information).
/// NOTE The attribute ProfileName of the
/// IfcProfileDef subtype, referenced in
/// IfcMaterialProfile should contain a standardized profile
/// name according to local standards. However, an additional
/// geometric representation of the profile is necessary (e.g. as
/// IfcExtrudedAreaSolid). An importing application is allowed
/// to check for the existence of the profile name: in case of
/// identifying it as a standardized name, the corresponding profile
/// geometry and possibly other cross sectional properties can be
/// read from a library. Otherwise the geometric representation and
/// possible non geometric IfcProfileProperties have to be
/// used.
/// Geometry Use Definition:
/// The IfcColumnType may define the shared geometric
/// representation for all column occurrences. The
/// RepresentationMaps attribute refers to a list of
/// IfcRepresentationMap's, that allow for multiple geometric
/// representations (e.g. with IfcShaperepresentation's having
/// an RepresentationIdentifier 'Box', 'Axis', or 'Body'). It
/// is only applicable if the IfcColumnType has only
/// occurrences of type IfcColumn (See geometric use
/// definition of IfcColumn for further information).
/// NOTE If the IfcColumnType has an
/// associated IfcMaterialProfileSet, then no shared geometric
/// representation shall be provided.
/// NOTE The product shape representations are
/// defined as RepresentationMaps (attribute of the supertype
/// IfcTypeProduct), which get assigned by an element
/// occurrence instance through the
/// IfcShapeRepresentation.Item[n] being an
/// IfcMappedItem. See IfcTypeProduct for further
/// information.
/// NOTE The values of attributes
/// RepresentationIdentifier and RepresentationType of
/// IfcShapeRepresentation are restricted in the same way as
/// those for IfcColumn and
/// IfcColumnStandardCase
class IfcColumnType : public IfcBuildingElementType {
public:
    /// Identifies the predefined types of a column element from which the type required may be set.
    IfcColumnTypeEnum::IfcColumnTypeEnum PredefinedType() const;
    void setPredefinedType(IfcColumnTypeEnum::IfcColumnTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcBuildingElementType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcColumnTypeEnum; } return IfcBuildingElementType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcBuildingElementType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcColumnType (IfcAbstractEntity* e);
    IfcColumnType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcColumnTypeEnum::IfcColumnTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcColumnType > list;
};
/// Definition from ISO/CD 10303-42:1992: A composite
///   curve is a collection of curves joined end-to-end. The
///   individual segments of the curve are themselves defined as
///   composite curve segments. The parameterization of the
///   composite curve is an accumulation of the parametric ranges
///   of the referenced bounded curves. The first segment is
///   parameterized from 0 to
///   l1 and for i
///   ≤ 2, the
///   ith segment is
///   parameterized from:
/// 
/// where lk is the parametric
///   length (i.e., difference between maximum and minimum
///   parameter values) of the curve underlying the
///   kth segment.
/// 
/// Let T denote the parameter for the composite curve.
///   Then, if the ith segment is not a reparameterised
///   composite curve segment, T is related to the
///   parameter ti; ti0
///   ≤ ti ≤
///   ti1; for the ith segment by the
///   equation:
/// 
/// if Segments[i].SameSense =
///   TRUE;
/// 
/// or by the equation:
/// 
/// if Segments[i].SameSense =
///   FALSE;
/// 
/// If the segments[i] is of type reparameterised composite
///   curve segment,
/// 
/// where τ is defined at
///   reparameterized composite curve segment (see
///   IfcReparameterizedCompositeCurveSegment).
/// 
/// Figure 279 illustrates an example of a composite curve.
/// 
/// Figure 279 — Composite curve
/// 
/// Consider an IfcCompositeCurve having line segment and an arc segment. The line should be parameterized:
/// 
/// IfcPolyline with start= 0.,0. end= 0.,1., SameSense= TRUE, parametric length = 1.
/// 
/// The arch should be parameterized:
/// 
/// IfcTrimmedCurve with start= 180', end= 90', SameSense= FALSE, parametric length = 90.
/// 
/// Then the parameterization of the composite curve is:
/// 
/// IfcCompositeCurve with 0. ≤ T ≤ 1. (line segment) and 1. ≤ T ≤ 91. (arc segment), parametric length = 91.
/// 
/// NOTE Corresponding ISO 10303 entity: composite_curve, please refer to ISO/IS 10303-42:1994, p. 56 for the final definition of the formal standard. The WR2 is added to ensure consistent Dim at all segments.
/// 
/// HISTORY New class in IFC Release 1.0
/// 
/// Informal Propositions:
/// 
/// The SameSense attribute of each segment
///   correctly specifies the senses of the component curves.
///   When traversed in the direction indicated by
///   SameSense, the segments shall join end-to-end.
class IfcCompositeCurve : public IfcBoundedCurve {
public:
    /// The component bounded curves, their transitions and senses. The transition attribute for the last segment defines the transition between the end of the last segment and the start of the first; this transition attribute may take the value discontinuous, which indicates an open curve.
    IfcTemplatedEntityList< IfcCompositeCurveSegment >::ptr Segments() const;
    void setSegments(IfcTemplatedEntityList< IfcCompositeCurveSegment >::ptr v);
    /// Indication of whether the curve intersects itself or not; this is for information only.
    bool SelfIntersect() const;
    void setSelfIntersect(bool v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_BOOL; } return IfcBoundedCurve::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcCompositeCurveSegment; case 1: return Type::UNDEFINED; } return IfcBoundedCurve::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Segments"; case 1: return "SelfIntersect"; } return IfcBoundedCurve::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCompositeCurve (IfcAbstractEntity* e);
    IfcCompositeCurve (IfcTemplatedEntityList< IfcCompositeCurveSegment >::ptr v1_Segments, bool v2_SelfIntersect);
    typedef IfcTemplatedEntityList< IfcCompositeCurve > list;
};
/// Definition from ISO/CD 10303-42:1992: A conic (IfcConic) is a planar curve which could be produced by intersecting a plane with a cone. A conic is defined in terms of its intrinsic geometric properties rather than being described in terms of other geometry. A conic class always has a placement coordinate system defined by a two or three dimensional placement. The parametric representation is defined in terms of this placement coordinate system.
/// 
/// NOTE Corresponding ISO 10303 entity: conic, only the following subtypes have been incorporated into IFC 1.0, 1.5 & 2.0: circle as IfcCircle, ellipse as IfcEllipse. The derived attribute Dim has been added at this level and was therefore demoted from the geometric_representation_item. Please refer to ISO/IS 10303-42:1994, p. 38 for the final definition of the formal standard.
/// 
/// HISTORY New class in IFC Release 1.0
class IfcConic : public IfcCurve {
public:
    /// The location and orientation of the conic. Further details of the interpretation of this attribute are given for the individual subtypes."
    IfcAxis2Placement* Position() const;
    void setPosition(IfcAxis2Placement* v);
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcCurve::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcAxis2Placement; } return IfcCurve::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Position"; } return IfcCurve::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcConic (IfcAbstractEntity* e);
    IfcConic (IfcAxis2Placement* v1_Position);
    typedef IfcTemplatedEntityList< IfcConic > list;
};
/// IfcConstructionResource is an abstract generalization of the different resources used in
/// construction projects, mainly labor, material, equipment and product resources, plus subcontracted resources and aggregations such as a crew resource.
/// 
/// A resource represents "use of something" and does not necessarily correspond to a single item such as a person or vehicle, but
/// represents a pool of items having limited availability such as general labor or an equipment fleet. A resource can represent either a generic resource pool (not having any task assignment) or a task-specific resource allocation (having an IfcTask
/// assignment).
/// 
/// HISTORY  New entity in IFC2x2.
/// 
/// IFC2x4 CHANGE  Modified in to promote ResourceIdentifer and ResourceGroup (renamed to LongDescription) to supertype IfcResource and add attributes as described.
/// 
/// Type use definition
/// IfcConstructionResource defines the occurrence of any construction resource; common information about construction resource types is handled by IfcConstructionResourceType. The IfcConstructionResourceType (if present) may establish the common type name, common properties, common cost rates, and common productivities applied to specific task types. The IfcConstructionResourceType is attached using the IfcRelDefinesByType.RelatingType objectified relationship and is accessible by the inverse IsTypedBy attribute as shown in Figure 186.
/// The resource type may provide shared productivity and cost information, allowing tasks and resources to be selected according to lowest cost and/or shortest duration. Given an IfcProduct of a particular IfcTypeProduct type, an IfcTypeProcess may be selected from those assigned to the product type using IfcRelAssignsToProduct, and an IfcTypeResource may be selected from those assigned to the process type using IfcRelAssignsToProcess. Then IfcTask and IfcConstructionResource occurrences may be instantiated from the type definitions, applying productivitity and rate information to assigned quantities to calculate ResourceTime.ScheduleWork. Task durations can then be calculated by dividing ResourceTime.ScheduleWork by ResourceTime.ScheduleUsage.
/// 
/// Figure 186 — Construction resource type use
/// 
/// Composition use definition
/// Resources may be decomposed into allocation pools using the IfcRelNests relationship as shown in Figure 187. For example, an IfcLaborResource for "Electrician" may be decomposed into three task-specific IfcLaborResource objects: "Electrical Rough-in", "First Floor Circuits", and "Second Floor Circuits". Both relating and related sides may represent the same ResourceTime.ScheduleUsage quantity (for example, 6 workers time-shared), or the related side may break out ResourceTime.ScheduleUsage quantities for reserved use (for example, 4 workers and 2 workers). 
/// A common scenario is two nesting levels where the first-level resources have no task assignments; while second-level resources have specific task assignments indicating that the resource is subdivided into allocations for specific tasks. While the model allows unlimited nesting of resources, implementer agreements may restrict to two nesting levels with task assignments specifically at the second level.
/// 
/// Figure 187 — Construction resource composition use
/// 
/// Declaration use definition
/// A root-level resource (specifically IfcCrewResource or IfcSubContractResource) is declared within the project by IfcRelDeclares where RelatingContext refers to the single IfcProject and RelatedObjects refers to one or more IfcConstructionResource, and other root-level objects within the project.
/// 
/// Assignment use definition
/// A resource may be assigned to an actor by IfcRelAssignsToActor where RelatingActor refers to an IfcActor and RelatedObjects refers to one or more IfcConstructionResource or other objects. Such relationship indicates the actor responsible for allocating the resource such as partitioning into task-specific allocations, delegating to other actors, and/or scheduling over time. Note that this assignment does not indicate the person or organization performing the work; that is indicated by IfcRelAssignsToResource. The actor responsible for the resource may or may not be the same as any actor(s) performing work.
/// A resource may be assigned to a control by IfcRelAssignsToControl where RelatingProduct refers to an IfcControl and RelatedObjects refers to one or more IfcConstructionResource or other objects. Most commonly an IfcWorkCalendar is assigned indicating availability of the resource, where such calendar is nested within a base calendar or an IfcWorkPlan which in turn is assigned to the IfcProject.
/// A resource may be assigned to a group by IfcRelAssignsToGroup where RelatingGroup refers to an IfcGroup and RelatedObjects refers to one or more IfcConstructionResource or other objects. Most commonly an IfcAsset is assigned indicating the asset to be tracked, where such asset is nested within an IfcInventory which in turn is assigned to the IfcProject.
/// A resource may be assigned to a product by IfcRelAssignsToProduct where RelatingProduct refers to an IfcProduct and RelatedObjects refers to one or more IfcConstructionResource or other objects. Most commonly an IfcElement subtype is assigned indicating the product to be constructed, where such product is connected to a spatial
/// structure which in turn is aggregated within the IfcProject.
/// A resource may be assigned to a process by IfcRelAssignsToProcess where RelatingProcess refers to an IfcProcess and RelatedObjects refers to one or more IfcConstructionResource or other objects. Most commonly an IfcTask is assigned indicating the task to be performed by the resource, where such task is nested within a summary task which in turn is assigned to the IfcProject. 
/// A resource may have assignments of other objects using IfcRelAssignsToResource where RelatingResource refers to the IfcConstructionResource and RelatedObjects refers to one or more objects such as IfcActor or IfcProduct subtypes. This relationship indicates specific objects assigned to fulfill resource usage.
/// Figure 188 illustrates resource assignment.
/// 
/// Figure 188 — Construction resource assignment use
/// 
/// Constraint use definition
/// Constraints may be applied to a resource to indicate fixed work (such as total person-hours) or fixed usage (such as simultaneous workers). The relationship IfcRelAssociatesConstraint is used where RelatingConstraint points to an IfcMetric and RelatedObjects includes the IfcConstructionResource as shown in Figure 189. IfcRelAssociatesConstraint.Name identifies the attribute to be constrained using a period (".") to dereference; for example, "ResourceTime.ScheduleWork" refers to the ScheduleWork attribute on the IfcResourceTime entity referenced on the ResourceTime attribute. The following attributes may be constrained:
/// 
/// 'ResourceTime.ScheduleUsage': Indicate fixed usage (e.g.
/// simultaneous workers) with ConstraintGrade=HARD and
/// Benchmark=EQUALTO such that changes to
/// ResourceTime.ScheduleWork should impact the assigned
/// IfcTask.TaskTime.ScheduleDuration and vice-versa
/// 'ResourceTime.ScheduleWork': Indicate fixed work (e.g.
/// total person-hours) with ConstraintGrade=HARD and
/// Benchmark=EQUALTO such that changes to
/// ResourceTime.ScheduleUsage should impact the assigned
/// IfcTask.TaskTime.ScheduleDuration and vice-versa.
/// 
/// Figure 189 — Construction resource constraint use
/// 
/// Time series use definition
/// Time series may be applied to a resource to indicate the break-out of attribute values over time. The relationship IfcRelAssociatesTimeSeries is used where RelatingTimeSeries points to an IfcTimeSeries (either IfcRegularTimeSeries or IfcIrregularTimeSeries) and RelatedObjects includes the IfcConstructionResource as shown in Figure 190. IfcRelAssociatesTimeSeries.Name identifies the attribute to be constrained using a period (".") to dereference; for example, "ResourceTime.ScheduleWork" refers to the ScheduleWork attribute on the IfcResourceTime entity referenced on the ResourceTime attribute. Refer to attribute descriptions on IfcResourceTime for attribute-specific usage.
/// Each IfcTimeSeriesValue indicates a LIST of values, where the sequence of the value corresponds to the IfcCostValue at IfcConstructionResource.CostRatesConsumed. For example, if CostRatesConsumed has two IfcCostValue items in the LIST, "Standard" and "Overtime", then IfcTimeSeriesValue(IfcDuration('T8H0M0S'),IfcDuration('T2H0M0S')) would indicate 8 hours at Standard rate and 2 hours at Overtime rate. If the list of values at IfcTimeSeriesValue.ListValues is less than the size of CostRatesConsumed, then subsequent values are considered to be zero.
/// 
/// Figure 190 — Construction resource time series use
/// 
/// Document use definition
/// Documents may be published for work plans consisting of schedules, calendars, tasks, and resources. The relationship IfcRelAssociatesDocument may be used to preserve mappings to such document where RelatingDocument points to an IfcDocumentReference and RelatedObjects includes the IfcConstructionResource as shown in Figure 191.
/// IfcDocumentReference.ItemReference identifies the resource within the scope of the document, such as an integer or guid. The IfcDocumentReference.ReferencedDocument corresponds to the document which is uniquely identified by IfcDocumentInformation.DocumentId and/or IfcDocumentInformation.PublicationLocation. Such document mapping allows items in the document to be updated from the building information model and vice-versa.
/// 
/// Figure 191 — Construction resource document use
/// 
/// Baseline use definition
/// A resource may have any number of baselines defined using the relationship IfcRelDefinesByObject where RelatingObject is the "current" resource and RelatedObjects consists of multiple "baseline" resources, each representing a copy of the resource as it existed at an earlier point in time as shown in Figure 192. Each baseline IfcConstructionResource is identified by its nested IfcRelAssignsToControl relationship to an IfcWorkSchedule having
/// PredefinedType=BASELINE, IfcWorkSchedule.CreationDate indicating the date of the baseline, and
/// IfcWorkSchedule.Name indicating the name of the baseline.
/// 
/// Figure 192 — Construction resource baseline use
class IfcConstructionResource : public IfcResource {
public:
    /// Whether the optional attribute ResourceIdentifier is defined for this IfcConstructionResource
    bool hasResourceIdentifier() const;
    std::string ResourceIdentifier() const;
    void setResourceIdentifier(std::string v);
    /// Whether the optional attribute ResourceGroup is defined for this IfcConstructionResource
    bool hasResourceGroup() const;
    std::string ResourceGroup() const;
    void setResourceGroup(std::string v);
    /// Whether the optional attribute ResourceConsumption is defined for this IfcConstructionResource
    bool hasResourceConsumption() const;
    /// Indicates how the resource is consumed or occupied during its use in a process.  Production-based consumption is indicated by CONSUMED, PARTIALLYCONSUMED, or NOTCONSUMED, where QuantityProduced refers to a quantity on the IfcProduct to which the assigned IfcProcess is assigned.  Duration-based occupation is indicated by OCCUPIED, PARTIALLYOCCUPIED, or NOTOCCUPIED, where QuantityProduced refers to a quantity on the IfcProcess to which the resource is assigned.
    IfcResourceConsumptionEnum::IfcResourceConsumptionEnum ResourceConsumption() const;
    void setResourceConsumption(IfcResourceConsumptionEnum::IfcResourceConsumptionEnum v);
    /// Whether the optional attribute BaseQuantity is defined for this IfcConstructionResource
    bool hasBaseQuantity() const;
    IfcMeasureWithUnit* BaseQuantity() const;
    void setBaseQuantity(IfcMeasureWithUnit* v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 5: return IfcUtil::Argument_STRING; case 6: return IfcUtil::Argument_STRING; case 7: return IfcUtil::Argument_ENUMERATION; case 8: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcResource::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 5: return Type::IfcIdentifier; case 6: return Type::IfcLabel; case 7: return Type::IfcResourceConsumptionEnum; case 8: return Type::IfcMeasureWithUnit; } return IfcResource::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 5: return "ResourceIdentifier"; case 6: return "ResourceGroup"; case 7: return "ResourceConsumption"; case 8: return "BaseQuantity"; } return IfcResource::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcConstructionResource (IfcAbstractEntity* e);
    IfcConstructionResource (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, boost::optional< std::string > v6_ResourceIdentifier, boost::optional< std::string > v7_ResourceGroup, boost::optional< IfcResourceConsumptionEnum::IfcResourceConsumptionEnum > v8_ResourceConsumption, IfcMeasureWithUnit* v9_BaseQuantity);
    typedef IfcTemplatedEntityList< IfcConstructionResource > list;
};
/// IfcControl is the abstract generalization of all concepts that control or constrain the utilization of products, processes, or resources in general. It can be seen as a regulation, cost schedule, request or order, or other requirements applied to a product, process or resource whose requirements and provisions must be fulfilled.
/// 
/// EXAMPLE Controls include action requests, cost schedules, project orders, work plans, and work calendars.
/// 
/// HISTORY New entity in IFC Release 1.0.
/// 
/// IFC2x4 CHANGE Attribute Identification added.
/// 
/// Relationship use definition
/// Controls have assignments from products, processes, or other objects by using the relationship object IfcRelAssignsToControl.
class IfcControl : public IfcObject {
public:
    virtual unsigned int getArgumentCount() const { return 5; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcObject::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcObject::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcObject::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcRelAssignsToControl >::ptr Controls() const; // INVERSE IfcRelAssignsToControl::RelatingControl
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcControl (IfcAbstractEntity* e);
    IfcControl (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType);
    typedef IfcTemplatedEntityList< IfcControl > list;
};
/// An IfcCostItem describes a cost or financial value together with descriptive information that describes its context in a form that enables it to be used within a cost schedule. An IfcCostItem can be used to represent the cost of goods and services, the execution of works by a process, lifecycle cost and more.
/// 
/// Each instance of IfcCostItem may have a name and a description. Depending on the use for which the cost is intended, these values should be asserted on the basis of agreement. For instance, the Name attribute could be used to provide a common value that enables distinct instances to be brought together in a nesting arrangement (see below) while the Description attribute may be used to provide text used for item description in a costing schedule.
/// 
/// An IfcCostItem can link one or many IfcCostValue's representing a unit cost, total cost, or a unit cost with one or many quantities used to generate the total cost. The quantities can be given as individual quantities, or those quantities are provided as element quantities by one or many building elements.  The IfcCostValue.CostType attribute indicates the category of cost, which may be used to present the value in a particular column.  For nested cost items (having IfcRelNests relationship), IfcCostValue.CostType is significant such that IfcCostValue.AppliedValue is calculated as the sum of all nested costs having the same IfcCostValue.CostType or if set to an asterisk ('*'), then the sum of all nested costs of all cost types. An IfcCostValue may represent an original value or a value derived from formulas using IfcAppliedValueRelationship.  For example, taxes may be calculated as a percentage of a subtotal.
/// 
/// HISTORY New Entity in IFC Release 2.0.
/// IFC2x4 CHANGE Attribute PredefinedType, CostValues, and CostQuantities added.
/// 
/// Classification Use Definition
/// 
/// Instances of IfcCostItem are used for cost estimates, budgets, and other forms, where a variety of identification codes are used extensively to identify the meaning of the cost. Examples include project phase codes, CSI codes, takeoff sequence numbers, and cost accounts. The model allows for all classes that are ultimately subtypes of IfcObject to inherit the ability to have one or more instances of IfcClassificationReference to be assigned. Where identification codes are required, the generic IfcRelAssociatesClassification facility should be used.
/// 
/// Composition Use Definition
/// 
/// An IfcCostItem can nest other instances of IfcCostItem through its relationships to IfcRelNests. This can be used to enable the development of complex groups of costs as may be found in cost schedules through to pages, sections and complete cost schedules.
/// 
/// There is always a summary cost item as the root item of the tree representing the cost item nesting. Subsequent instances of IfcCostItem are assigned to the summary cost item using IfcRelNests.  The summary cost item itself is assigned to IfcCostSchedule through the IfcRelAssignsToControl relationship.
/// 
/// Figure 157 illustrates a cost item composition used for a cost schedule.  Each line item has a quantity and separate unit costs where IfcCostValue.CostType indicates the category of cost.  The summary item has a hierarchy of costs calculated according to IfcAppliedValueRelationship.ArithmeticOperator, where IfcCostValue.CostType identifies the category to be totalled.  The Tax component has IfcCostValue.CostType set to 'Material' which indicates it is the sum of all nested values of the 'Material' category ($3 x 3000 + $118 x 100 = $20800).  The Subtotal component has IfcCostValue.CostType set to an asterisk ('*') which indicates it is the sum of all nested values of all categories.
/// 
/// Figure 157 — Cost composition
/// 
/// Assignment Use Definition
/// 
/// An IfcCostItem can be calculated based on quantities from objects through its relationship to IfcRelAssignsToControl.
/// 
/// For quantity-based costing, IfcElement, IfcTask, or IfcResource occurrence subtypes may be used.  Multiple elements may be assigned of the same or different types, using IfcPhysicalQuantity entities defined at each object.  Each IfcPhysicalQuantity type must be identical (for example, all values are IfcAreaQuantity) such that they can be added together.
/// 
/// For rate-based costing (specifically for IfcCostScheduleTypeEnum.SCHEDULEOFRATES), a single IfcTypeProduct, IfcTypeProcess, or IfcTypeResource subtype may be used to reflect rates for occurrences of such types.  This enables the possibility to generate a quantity-based cost schedule for occurrences based on types with rate-based cost schedules.
/// 
/// IfcRelAssignsToControl is also used in the opposite direction to link the root IfcCostItem to an IfcCostSchedule where RelatingControl is the IfcCostSchedule. 
/// 
/// Figure 158 illustrates cost item assignment derived from building elements.  The IfcRelAssignsToControl relationship indicates building elements for which quantities are derived.  Not shown, costs may also be derived from building elements by traversing assignment relationships from the assigned IfcProduct to IfcProcess to IfcResource, where all costs ultimately originate at resources.  It is also possible for cost items to have assignments from processes or resources directly.
/// 
/// Figure 168 — Cost assignment
class IfcCostItem : public IfcControl {
public:
    virtual unsigned int getArgumentCount() const { return 5; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcControl::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcControl::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcControl::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCostItem (IfcAbstractEntity* e);
    IfcCostItem (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType);
    typedef IfcTemplatedEntityList< IfcCostItem > list;
};
/// An IfcCostSchedule brings together instances of IfcCostItem either for the purpose of identifying purely cost information as in an estimate for constructions costs or for including cost information within another presentation form such as a work order.
/// 
/// HISTORY New Entity in IFC Release 2.0. Modified in IFC 2x2
/// IFC2x4 CHANGE Attribute 'ID' changed to Identification and promoted to supertype IfcControl, PredefinedType made optional, attributes PreparedBy, SubmittedBy, TargetUsers removed.
/// 
/// Declaration Use Definition 
/// The IfcCostSchedule may be declared within the project using the IfcRelDeclares relationship where RelatingContext refers to the single IfcProject and RelatedDefinitions contains the IfcCostSchedule.  Alternatively, if the IfcCostSchedule is aggregated within another IfcControl object, then it shall not have a direct declaration relationship (whereas the containing object may have a declaration relationship). 
/// 
/// Assignment Use Definition 
///   The IfcCostSchedule may be assigned to the following entities using relationships as indicated: 
/// 
/// IfcActor (IfcRelAssignsToActor): Persons and organizations involved in the preparation, submittal, and as target users. 
/// 
/// The IfcCostSchedule may have assignments of its own using the IfcRelAssignsToControl relationship where RelatingControl refers to the IfcCostSchedule and RelatedObjects contains one or more objects of the following types:  
/// IfcCostItem: Indicates costs published within this cost schedule, typically a single root cost item forming a hierarchy of nested cost items. 
/// 
/// Classification Use Definition 
/// Classifications may be applied using IfcRelAssociatesClassification where RelatedObjects contains the  IfcCostSchedule and RelatingClassification refers to an IfcClassification or IfcClassificationReference. 
/// 
/// IfcClassification: Classifications to be used for cost items within the cost schedule. 
/// 
/// Approval Use Definition 
/// Approvals may be associated to indicate the status of acceptance or rejection using the IfcRelAssociatesApproval relationship where RelatingApproval refers to an IfcApproval and RelatedObjects contains the IfcCostSchedule.  Approvals may be split into sub-approvals using IfcApprovalRelationship to track approval status separately for each party where RelatingApproval refers to the higher-level approval and RelatedApprovals contains one or more lower-level approvals.  The hierarchy of approvals implies sequencing such that a higher-level approval is not executed until all of its lower-level approvals have been accepted.
class IfcCostSchedule : public IfcControl {
public:
    /// Whether the optional attribute SubmittedBy is defined for this IfcCostSchedule
    bool hasSubmittedBy() const;
    IfcActorSelect* SubmittedBy() const;
    void setSubmittedBy(IfcActorSelect* v);
    /// Whether the optional attribute PreparedBy is defined for this IfcCostSchedule
    bool hasPreparedBy() const;
    IfcActorSelect* PreparedBy() const;
    void setPreparedBy(IfcActorSelect* v);
    /// Whether the optional attribute SubmittedOn is defined for this IfcCostSchedule
    bool hasSubmittedOn() const;
    /// The date and time on which the cost schedule was submitted.
    /// 
    /// IFC2x4 CHANGE Type changed from IfcDateTimeSelect.
    IfcDateTimeSelect* SubmittedOn() const;
    void setSubmittedOn(IfcDateTimeSelect* v);
    /// Whether the optional attribute Status is defined for this IfcCostSchedule
    bool hasStatus() const;
    /// The current status of a cost schedule. Examples of status values that might be used for a cost schedule status include:
    /// 
    /// PLANNED 
    ///   APPROVED 
    ///   AGREED 
    ///   ISSUED 
    ///   STARTED
    std::string Status() const;
    void setStatus(std::string v);
    /// Whether the optional attribute TargetUsers is defined for this IfcCostSchedule
    bool hasTargetUsers() const;
    IfcEntityList::ptr TargetUsers() const;
    void setTargetUsers(IfcEntityList::ptr v);
    /// Whether the optional attribute UpdateDate is defined for this IfcCostSchedule
    bool hasUpdateDate() const;
    /// The date and time that this cost schedule is updated; this allows tracking the schedule history.
    /// 
    /// IFC2x4 CHANGE Type changed from IfcDateTimeSelect.
    IfcDateTimeSelect* UpdateDate() const;
    void setUpdateDate(IfcDateTimeSelect* v);
    std::string ID() const;
    void setID(std::string v);
    /// Predefined generic type for a cost schedule that is specified in an enumeration. There may be a property set given specifically for the predefined types.
    /// 
    /// IFC2x4 CHANGE  The attribute has been made optional.
    IfcCostScheduleTypeEnum::IfcCostScheduleTypeEnum PredefinedType() const;
    void setPredefinedType(IfcCostScheduleTypeEnum::IfcCostScheduleTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 13; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 5: return IfcUtil::Argument_ENTITY_INSTANCE; case 6: return IfcUtil::Argument_ENTITY_INSTANCE; case 7: return IfcUtil::Argument_ENTITY_INSTANCE; case 8: return IfcUtil::Argument_STRING; case 9: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 10: return IfcUtil::Argument_ENTITY_INSTANCE; case 11: return IfcUtil::Argument_STRING; case 12: return IfcUtil::Argument_ENUMERATION; } return IfcControl::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 5: return Type::IfcActorSelect; case 6: return Type::IfcActorSelect; case 7: return Type::IfcDateTimeSelect; case 8: return Type::IfcLabel; case 9: return Type::IfcActorSelect; case 10: return Type::IfcDateTimeSelect; case 11: return Type::IfcIdentifier; case 12: return Type::IfcCostScheduleTypeEnum; } return IfcControl::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 5: return "SubmittedBy"; case 6: return "PreparedBy"; case 7: return "SubmittedOn"; case 8: return "Status"; case 9: return "TargetUsers"; case 10: return "UpdateDate"; case 11: return "ID"; case 12: return "PredefinedType"; } return IfcControl::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCostSchedule (IfcAbstractEntity* e);
    IfcCostSchedule (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcActorSelect* v6_SubmittedBy, IfcActorSelect* v7_PreparedBy, IfcDateTimeSelect* v8_SubmittedOn, boost::optional< std::string > v9_Status, boost::optional< IfcEntityList::ptr > v10_TargetUsers, IfcDateTimeSelect* v11_UpdateDate, std::string v12_ID, IfcCostScheduleTypeEnum::IfcCostScheduleTypeEnum v13_PredefinedType);
    typedef IfcTemplatedEntityList< IfcCostSchedule > list;
};
/// Definition from IAI: The element type
/// IfcCoveringType defines commonly shared information for
/// occurrences of coverings. The set of shared information may
/// include:
/// 
/// common properties within shared property sets
/// common material (layer set) information
/// common shape representations
/// 
/// It is used to define an covering specification or covering
/// style (i.e. the specific product information, that is common to
/// all occurrences of that product type). Covering types may be
/// exchanged without being already assigned to occurrences.
/// The occurrences of the IfcCoveringType are represented
/// by instances of IfcCovering
/// 
/// HISTORY New entity in Release
/// IFC2x Edition 2.
/// 
/// Informal proposition
/// 
/// The material assignment, if provided using the
/// IfcRelAssociatesMaterial relationship, shall not reference
/// the IfcMaterialLayerSetUsage.
/// 
/// Material Use Definition
/// The material of the IfcCoveringType is defined by the
/// IfcMaterialLayerSet or as fall back by IfcMaterial
/// and attached by the
/// IfcRelAssociatesMaterial.RelatingMaterial. It is
/// accessible by the inverse HasAssociations
/// relationship.
/// Property Set Use Definition:
/// The shared property sets relating to the
/// IfcCoveringType are defined by the IfcPropertySet
/// and are attached by the HasPropertySets attribute. The
/// following property set definitions specific to the
/// IfcCoveringType are part of this IFC release:
/// NOTE There is no differentiation between
/// properties within the property set that are only assignable to
/// IfcCoveringType and those that are only assignable to
/// IfcCovering. If the same property is assigned to the
/// IfcCoveringType and the IfcCovering being an
/// occurrence of the IfcCoveringType, then the occurrence
/// property overrides the type property.
/// 
/// Pset_CoveringCommon: common property set for all
/// covering types
/// 
/// Pset_CoveringCeiling: specific property set
/// for all occurrences of covering types with the PredefinedType:
/// CEILING
/// Pset_CoveringFlooring: specific property set
/// for all occurrences of coverings with the PredefinedType:
/// FLOORING
/// 
/// Geometry Use Definition:
/// The IfcCoveringType may define the shared geometric
/// representation for all covering occurrences. The
/// RepresentationMaps attribute refers to a list of
/// IfcRepresentationMap's, that allow for multiple geometric
/// representations (e.g. with IfcShaperepresentation's having
/// an RepresentationIdentifier 'Box', 'Surface', or 'Body').
/// (See geometric use definition of IfcCovering for further
/// information).
/// NOTE If the IfcCoveringType has an
/// associated IfcMaterialLayerSet, then no shared geometric
/// representation shall be provided.
/// NOTE The product shape representations are
/// defined as RepresentationMaps (attribute of the supertype
/// IfcTypeProduct), which get assigned by an element
/// occurrence instance through the
/// IfcShapeRepresentation.Item[n] being an
/// IfcMappedItem. See IfcTypeProduct for further
/// information.
/// NOTE The values of attributes
/// RepresentationIdentifier and RepresentationType of
/// IfcShapeRepresentation are restricted in the same way as
/// those for IfcCoveringType.
class IfcCoveringType : public IfcBuildingElementType {
public:
    /// Predefined types to define the particular type of the covering. There may be property set definitions available for each predefined type.
    IfcCoveringTypeEnum::IfcCoveringTypeEnum PredefinedType() const;
    void setPredefinedType(IfcCoveringTypeEnum::IfcCoveringTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcBuildingElementType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcCoveringTypeEnum; } return IfcBuildingElementType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcBuildingElementType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCoveringType (IfcAbstractEntity* e);
    IfcCoveringType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcCoveringTypeEnum::IfcCoveringTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcCoveringType > list;
};
/// IfcCrewResource represents a collection of internal resources used in construction processes. 
/// 
/// HISTORY: New Entity in IFC Release 2.0.  Base type and documentation extended in IFC2x4
/// 
/// Identification of people and equipment of a crew is achieved through their specification at the level of the component. Therefore, knowing which persons are within a crew is achieved through identifying the persons assigned to each IfcLaborResource within the IfcCrewResource.  Similarly, identifying that a screwing machine for pipe fitting forms part of the crew is achieved by relating an appropriate instance of IfcElementComponent to the IfcConstructionEquipmentResource forming an element of the IfcCrewResource.
/// 
/// Use definitions for composition, assignment, constraints, time series, and baselines are described at the base type IfcConstructionResource.
/// 
/// Type use definition
/// IfcCrewResource defines the occurrence of any crew resource; common information about crew resource types is handled by IfcCrewResourceType.  The IfcCrewResourceType (if present) may establish the common type name, common properties, and common productivities for various task types using IfcRelAssignsToProcess.  The IfcCrewResourceType is attached using the IfcRelDefinesByType.RelatingType objectified relationship and is accessible by the inverse IsTypedBy attribute.
class IfcCrewResource : public IfcConstructionResource {
public:
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcConstructionResource::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcConstructionResource::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcConstructionResource::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCrewResource (IfcAbstractEntity* e);
    IfcCrewResource (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, boost::optional< std::string > v6_ResourceIdentifier, boost::optional< std::string > v7_ResourceGroup, boost::optional< IfcResourceConsumptionEnum::IfcResourceConsumptionEnum > v8_ResourceConsumption, IfcMeasureWithUnit* v9_BaseQuantity);
    typedef IfcTemplatedEntityList< IfcCrewResource > list;
};
/// Definition from IAI: The element type (IfcCurtainWallType)
/// defines a list of commonly shared property set definitions of a curtain
/// wall element and an optional set of product representations. It is used
/// to define a curtain wall specification (i.e. the specific product
/// information, that is common to all occurrences of that product type).
/// 
/// NOTE: The product
/// representations are defined as representation maps (at the level of the
/// supertype IfcTypeProduct, which gets assigned by an
/// element occurrence instance through the IfcShapeRepresentation.Item[1]
/// being an IfcMappedItem.
/// 
/// A curtain wall type is used to define the common properties of
/// a certain type of curtain wall that may be applied to many instances of
/// that type to assign a specific style. Curtain wall types may be
/// exchanged without being already assigned to occurrences.
/// The occurrences of the IfcCurtainWallType
/// are represented by instances of IfcCurtainWall.
/// 
/// HISTORY
/// New entity in Release IFC2x Editon 3.
class IfcCurtainWallType : public IfcBuildingElementType {
public:
    /// Identifies the predefined types of a curtain wall element from which the type required may be set.
    IfcCurtainWallTypeEnum::IfcCurtainWallTypeEnum PredefinedType() const;
    void setPredefinedType(IfcCurtainWallTypeEnum::IfcCurtainWallTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcBuildingElementType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcCurtainWallTypeEnum; } return IfcBuildingElementType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcBuildingElementType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCurtainWallType (IfcAbstractEntity* e);
    IfcCurtainWallType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcCurtainWallTypeEnum::IfcCurtainWallTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcCurtainWallType > list;
};

class IfcDimensionCurveDirectedCallout : public IfcDraughtingCallout {
public:
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcDraughtingCallout::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcDraughtingCallout::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcDraughtingCallout::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcDimensionCurveDirectedCallout (IfcAbstractEntity* e);
    IfcDimensionCurveDirectedCallout (IfcEntityList::ptr v1_Contents);
    typedef IfcTemplatedEntityList< IfcDimensionCurveDirectedCallout > list;
};
/// Definition from IAI: The
/// IfcDistributionElementType defines a list of commonly
/// shared property set definitions of an element and an optional set
/// of product representations. It is used to define an element
/// specification (i.e. the specific product information, that is
/// common to all occurrences of that product type).
/// NOTEÿ The product representations are defined
/// as representation maps (at the level of the supertype
/// IfcTypeProduct, which gets assigned by an element
/// occurrence instance through the
/// IfcShapeRepresentation.Item[1] being an
/// IfcMappedItem.
/// A distribution element type is used to define the common
/// properties of a certain type of a distribution element that may
/// be applied to many instances of that feature type to assign a
/// specific style. Distribution element types (or the instantiable
/// subtypes) may be exchanged without being already assigned to
/// occurrences.
/// The occurrences of the IfcDistributionElementType are
/// represented by instances of IfcDistributionElement (or its
/// subtypes).
/// HISTORYÿ New entity in
/// Release IFC2x Edition 2.
/// IFC2x3 CHANGEÿ The entity has been made
/// non-abstract
/// IFC2x4 CHANGE The entity is marked
/// as deprecated for instantiation - will be made ABSTRACT after
/// IFC2x4.
class IfcDistributionElementType : public IfcElementType {
public:
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcElementType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcElementType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcElementType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcDistributionElementType (IfcAbstractEntity* e);
    IfcDistributionElementType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType);
    typedef IfcTemplatedEntityList< IfcDistributionElementType > list;
};
/// The element type IfcDistributionFlowElementType defines a list of commonly shared property set definitions of an element and an optional set of product representations.  It is used to define an element specification (the specific product information that is common to all occurrences of that product type). 
/// 
/// Distribution flow element types (orthe instantiable subtypes) may be exchanged without being already assigned to occurrences. 
/// 
/// The occurrences of the IfcDistributionFlowElementType are represented	by instances of IfcDistributionFlowElement or its subtypes. 
/// 
/// HISTORY: New entity in IFC Release 2x2.
/// 
/// Declaration Use Definition
/// The IfcDistributionFlowElementType may be declared within a project or project library using IfcRelDeclares where RelatingContext refers to the project or library and RelatedDefinitions includes the element type.  Inclusion within IfcProject indicates the type is editable within the direct project and may be available to other referencing projects that may incorporate the type.  Inclusion within IfcProjectLibrary indicates the type is incorporated from a referenced project.  Default units and coordinate systems (used for representations, materials, and property sets) are indicated by the declaring project or library.
/// 
/// Classification Use Definition
/// The IfcDistributionFlowElementType may be classified using IfcRelAssociatesClassification where RelatingClassification refers to an IfcClassificationReference indicating a classification notation. Classifications may refer to industry standards such as MasterFormat, OmniFormat, or UniFormat.  Classifications may also refer to organization-specific, project-specific, or system-specific designations.  Classification reference identification schemes are described by IfcClassification.ReferenceTokens.
/// 
/// Document Use Definition
/// The IfcDistributionFlowElementType may be documented using IfcRelAssociatesDocument where RelatingDocument refers to an IfcDocumentReference indicating content within a document, or IfcDocumentInformation indicating an entire document. Document information may refer to arbitrary attachments such as text or multimedia, while document references may refer to items within particular formats (such as XML element IDs) where there is need to synchronize document information with model information.  Document reference identification schemes depend on the particular document format.
/// 
/// Library Use Definition
/// The IfcDistributionFlowElementType may be published to a model server using IfcRelAssociatesLibrary where RelatingLibrary refers to an IfcLibraryReference indicating the unique identification within the published project.  If the published project is IFC format, then IfcLibraryReference.Identification shall match IfcRoot.GlobalID of the published (master) project, using the same encoding as described for IfcGloballyUniqueId.  Multiple library references may be provided to indicate alternate names and descriptions for particular languages.  If the element type is declared within IfcProject, then IfcLibraryInformation.Location and IfcLibraryInformation.Version indicate the URL and version as last published.  If the element type is declared within IfcProjectLibrary, then the library information indicates the location and version of the definition as last retrieved.
/// 
/// Figure 148 illustrates a project containing a light fixture in a building, where the definition of the light fixture is obtained from an external project.
/// 
/// Figure 148 — Distribution flow element library
/// 
/// Composition Use Definition
/// The IfcDistributionFlowElementType may be decomposed into components using IfcRelAggregates where RelatingObject refers to the enclosing IfcDistributionFlowElementType and RelatedObjects contains one or more components.  For example, a cable type may be decomposed into wires.  Standard types for composition are defined at occurrences for subtypes.
/// 
/// Connection Use Definition
/// The IfcDistributionFlowElementType may be connected to other objects as follows using the indicated relationship:
/// 
/// IfcDistributionPort (IfcRelConnectsPortToElement) : Indicates port definitions on the element to be instantiated at occurrences.  Standard port names, types, and directions are defined at occurrences for subtypes.
/// 
/// Assignment Use Definition
///   The IfcDistributionFlowElementType may have assignments of its own using the IfcRelAssignsToProduct relationship where RelatingProduct refers to the IfcDistributionFlowElementType and RelatedObjects contains one or more objects of the following types: 
/// 
/// IfcTaskType: Indicates task types available to purchase, install, renovate, demolish, operate, or otherwise act upon occurrences of the element type.  Such task types may be instantiated as task occurrences assigned to occurrences of the element type.  Prices (such as for purchasing or shipping) may be established by resource types assigned to task types.
/// IfcProcedureType: Indicates procedure types available to operate occurrences of the element type.  Such procedure types may be instantiated as procedure occurrences assigned to occurrences of the element type.
/// IfcEventType: Indicates event types available to be raised by occurrences of the element, sequenced by procedures to be followed.  Such event types may be instantiated as event occurrences assigned to occurrences of the element type.
/// 
/// Material Use Definition
/// The material of the IfcDistributionFlowElementType is defined using one of the following entities:
/// 
/// IfcMaterialProfileSet: For elements having a constant cross-section, this defines the material profile which may be used to generate the 'Body' representation at occurrences (for parametric definitions not having representation), or for analysis purposes.
/// IfcMaterialConstituentSet: For elements containing multiple materials, this indicates materials at named aspects.
/// 
/// IfcMaterial: For elements comprised of a single material, this indicates the material.
/// 
/// The material is attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.
/// 
/// Representation Use Definition
/// The following shape representations are supported for subtypes of IfcDistributionFlowElementType, distinguished by IfcShapeRepresentation.RepresentationIdentifier:
/// 
/// 'Axis': Represents the 3D flow path of the item having IfcShapeRepresentation.RepresentationType of 'Curve3D' and containing a single IfcBoundedCurve subtype such as IfcPolyline, IfcTrimmedCurve, or IfcCompositeCurve.  For elements containing directional ports (IfcDistributionPort with FlowDirection of SOURCE or SINK), the direction of the curve indicates direction of flow where a SINK port is positioned at the start of the curve and a SOURCE port is positioned at the end of the curve.  This representation is most applicable to flow segment types (pipes, ducts, cables), however may be used at other elements to define a primary flow path if applicable. 
/// 
/// 'Footprint': Represents the 2D footprint outline of the item having IfcShapeRepresentation.RepresentationType of 'GeometricCurveSet' and containing a single IfcGeometricCurveSet consisting of one or more IfcCurve subtypes such as IfcPolyline, IfcTrimmedCurve, IfcCompositeCurve, or IfcCircle.
/// 
/// 'Body': Represents the 3D shape of the item having IfcShapeRepresentation.RepresentationType of 'SurfaceModel', 'SolidModel', or any solid model specializations including 'Brep', 'AdvancedBrep', 'SweptSolid', 'AdvancedSweptSolid', 'CSG', 'Clipping', or 'SectionedSpine').
/// 
/// 'Clearance': Represents the 3D clearance volume of the item having RepresentationType of 'Surface3D'.  Such clearance region indicates space that should not intersect with the 'Body' representation between element occurrences, though may intersect with the 'Clearance' representation of other element occurrences.  The particular use of clearance space may be for safety, maintenance, or other purpose.
/// 
/// 'Lighting': Represents the light emission of the item having IfcShapeRepresentation.RepresentationType of 'LightSource' and containing one or more IfcLightSource subtypes.  This representation is most applicable to lamps and light fixtures, however may be used at other elements that emit light.
/// 
/// If an element type is defined parametrically (such as a flow segment type defining common material profile but no particular length or path), then no representations shall be asserted at the type.
/// 
/// NOTE: The product representations are defined as representation maps (at the level of the supertype IfcTypeProduct, which get assigned by an element occurrence instance through the IfcShapeRepresentation.Item[1] being an IfcMappedItem.
class IfcDistributionFlowElementType : public IfcDistributionElementType {
public:
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcDistributionElementType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcDistributionElementType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcDistributionElementType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcDistributionFlowElementType (IfcAbstractEntity* e);
    IfcDistributionFlowElementType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType);
    typedef IfcTemplatedEntityList< IfcDistributionFlowElementType > list;
};

class IfcElectricalBaseProperties : public IfcEnergyProperties {
public:
    /// Whether the optional attribute ElectricCurrentType is defined for this IfcElectricalBaseProperties
    bool hasElectricCurrentType() const;
    IfcElectricCurrentEnum::IfcElectricCurrentEnum ElectricCurrentType() const;
    void setElectricCurrentType(IfcElectricCurrentEnum::IfcElectricCurrentEnum v);
    double InputVoltage() const;
    void setInputVoltage(double v);
    double InputFrequency() const;
    void setInputFrequency(double v);
    /// Whether the optional attribute FullLoadCurrent is defined for this IfcElectricalBaseProperties
    bool hasFullLoadCurrent() const;
    double FullLoadCurrent() const;
    void setFullLoadCurrent(double v);
    /// Whether the optional attribute MinimumCircuitCurrent is defined for this IfcElectricalBaseProperties
    bool hasMinimumCircuitCurrent() const;
    double MinimumCircuitCurrent() const;
    void setMinimumCircuitCurrent(double v);
    /// Whether the optional attribute MaximumPowerInput is defined for this IfcElectricalBaseProperties
    bool hasMaximumPowerInput() const;
    double MaximumPowerInput() const;
    void setMaximumPowerInput(double v);
    /// Whether the optional attribute RatedPowerInput is defined for this IfcElectricalBaseProperties
    bool hasRatedPowerInput() const;
    double RatedPowerInput() const;
    void setRatedPowerInput(double v);
    int InputPhase() const;
    void setInputPhase(int v);
    virtual unsigned int getArgumentCount() const { return 14; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 6: return IfcUtil::Argument_ENUMERATION; case 7: return IfcUtil::Argument_DOUBLE; case 8: return IfcUtil::Argument_DOUBLE; case 9: return IfcUtil::Argument_DOUBLE; case 10: return IfcUtil::Argument_DOUBLE; case 11: return IfcUtil::Argument_DOUBLE; case 12: return IfcUtil::Argument_DOUBLE; case 13: return IfcUtil::Argument_INT; } return IfcEnergyProperties::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 6: return Type::IfcElectricCurrentEnum; case 7: return Type::IfcElectricVoltageMeasure; case 8: return Type::IfcFrequencyMeasure; case 9: return Type::IfcElectricCurrentMeasure; case 10: return Type::IfcElectricCurrentMeasure; case 11: return Type::IfcPowerMeasure; case 12: return Type::IfcPowerMeasure; case 13: return Type::UNDEFINED; } return IfcEnergyProperties::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 6: return "ElectricCurrentType"; case 7: return "InputVoltage"; case 8: return "InputFrequency"; case 9: return "FullLoadCurrent"; case 10: return "MinimumCircuitCurrent"; case 11: return "MaximumPowerInput"; case 12: return "RatedPowerInput"; case 13: return "InputPhase"; } return IfcEnergyProperties::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcElectricalBaseProperties (IfcAbstractEntity* e);
    IfcElectricalBaseProperties (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< IfcEnergySequenceEnum::IfcEnergySequenceEnum > v5_EnergySequence, boost::optional< std::string > v6_UserDefinedEnergySequence, boost::optional< IfcElectricCurrentEnum::IfcElectricCurrentEnum > v7_ElectricCurrentType, double v8_InputVoltage, double v9_InputFrequency, boost::optional< double > v10_FullLoadCurrent, boost::optional< double > v11_MinimumCircuitCurrent, boost::optional< double > v12_MaximumPowerInput, boost::optional< double > v13_RatedPowerInput, int v14_InputPhase);
    typedef IfcTemplatedEntityList< IfcElectricalBaseProperties > list;
};
/// Definition from IAI: Generalization of all components
/// that make up an AEC product. Those elements can be logically
/// contained by a spatial structure element that constitutes a
/// certain level within a project structure hierarchy (e.g., site,
/// building, storey or space). This is done by using the
/// IfcRelContainedInSpatialStructure relationship.
/// Elements are physically existent objects, although they might
/// be void elements, such as holes. Elements either remain
/// permanently in the AEC product, or only temporarily, as formwork
/// does. Elements can be either assembled on site or
/// pre-manufactured and built in on site.
/// EXAMPLEs of elements in a building
/// construction context are walls, floors, windows and
/// recesses.
/// An element can have material and quantity information assigned
/// through the IfcRelAssociatesMaterial and
/// IfcRelDefinesByProperties relationship.
/// In addition an element can be declared to be a specific
/// occurrence of an element type (and thereby be defined by the
/// element type properties) using the IfcRelDefinesByType
/// relationship.
/// An element can also be defined as an element assembly that is
/// a group of semantically and topologically related elements that
/// form a higher level part of the AEC product. Those element
/// assemblies are defined by virtue of the IfcRelAggregates
/// relationship.
/// EXAMPLEs for element assembly are
/// complete Roof Structures, made by several Roof Areas, or a Stair,
/// composed by Flights and Landings.
/// Elements that performs the same function may be grouped by an
/// "Element Group By Function". It is realized by an instance of
/// IfcGroup with the ObjectType =
/// 'ElementGroupByFunction".
/// HISTORY New entity in
/// IFC Release 1.0
/// Property Set Use Definition:
/// The property sets relating to the IfcElement are
/// defined by the IfcPropertySet and attached by the
/// IfcRelDefinesByProperties relationship. It is accessible
/// by the inverse IsDefinedBy relationship.
/// Quantity Use Definition:
/// The quantities relating to the IfcElement are defined
/// by the IfcElementQuantity and attached by the
/// IfcRelDefinesByProperties. A detailed specification for
/// individual quantities is introduced at the level of subtypes of
/// IfcElement.
/// Geometry Use Definitions
/// The geometric representation of any IfcElement is given
/// by the IfcProductDefinitionShape and
/// IfcLocalPlacement allowing multiple geometric
/// representations. A detailed specification for the local placement
/// and shape representaion is introduced at the level of subtypes of
/// IfcElement.
class IfcElement : public IfcProduct {
public:
    /// Whether the optional attribute Tag is defined for this IfcElement
    bool hasTag() const;
    /// The tag (or label) identifier at the particular instance of a product, e.g. the serial number, or the position number. It is the identifier at the occurrence level.
    std::string Tag() const;
    void setTag(std::string v);
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 7: return IfcUtil::Argument_STRING; } return IfcProduct::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 7: return Type::IfcIdentifier; } return IfcProduct::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 7: return "Tag"; } return IfcProduct::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcRelConnectsStructuralElement >::ptr HasStructuralMember() const; // INVERSE IfcRelConnectsStructuralElement::RelatingElement
    IfcTemplatedEntityList< IfcRelFillsElement >::ptr FillsVoids() const; // INVERSE IfcRelFillsElement::RelatedBuildingElement
    IfcTemplatedEntityList< IfcRelConnectsElements >::ptr ConnectedTo() const; // INVERSE IfcRelConnectsElements::RelatingElement
    IfcTemplatedEntityList< IfcRelCoversBldgElements >::ptr HasCoverings() const; // INVERSE IfcRelCoversBldgElements::RelatingBuildingElement
    IfcTemplatedEntityList< IfcRelProjectsElement >::ptr HasProjections() const; // INVERSE IfcRelProjectsElement::RelatingElement
    IfcTemplatedEntityList< IfcRelReferencedInSpatialStructure >::ptr ReferencedInStructures() const; // INVERSE IfcRelReferencedInSpatialStructure::RelatedElements
    IfcTemplatedEntityList< IfcRelConnectsPortToElement >::ptr HasPorts() const; // INVERSE IfcRelConnectsPortToElement::RelatedElement
    IfcTemplatedEntityList< IfcRelVoidsElement >::ptr HasOpenings() const; // INVERSE IfcRelVoidsElement::RelatingBuildingElement
    IfcTemplatedEntityList< IfcRelConnectsWithRealizingElements >::ptr IsConnectionRealization() const; // INVERSE IfcRelConnectsWithRealizingElements::RealizingElements
    IfcTemplatedEntityList< IfcRelSpaceBoundary >::ptr ProvidesBoundaries() const; // INVERSE IfcRelSpaceBoundary::RelatedBuildingElement
    IfcTemplatedEntityList< IfcRelConnectsElements >::ptr ConnectedFrom() const; // INVERSE IfcRelConnectsElements::RelatedElement
    IfcTemplatedEntityList< IfcRelContainedInSpatialStructure >::ptr ContainedInStructure() const; // INVERSE IfcRelContainedInSpatialStructure::RelatedElements
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcElement (IfcAbstractEntity* e);
    IfcElement (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag);
    typedef IfcTemplatedEntityList< IfcElement > list;
};
/// The IfcElementAssembly
/// represents complex element assemblies aggregated from several
/// elements, such as discrete elements, building elements, or other
/// elements.
/// EXAMPLE Steel construction assemblies, such as
/// trusses and different kinds of frames, can be represented by the
/// IfcElementAssembly entity. Other examples include slab
/// fields aggregated from a number of precast concrete slabs or
/// reinforcement units made from several reinforcement bars. Also
/// bathroom units, staircase sections and other premanufactured or
/// precast elements are examples of the general
/// IfcElementAssembly entity
/// NOTE The IfcElementAssembly is a
/// general purpose entity that is required to be decomposed. Also
/// other subtypes of IfcElement can be decomposed, with some
/// dedicated entities such as IfcWallElementedCase and
/// IfcSlabElementedCase.
/// The assembly structure can be nested, i.e. an
/// IfcElementAssembly could be an aggregated part within
/// another IfcElementAssembly.
/// NOTE View definitions and/or implementer
/// agreements may restrict the number of allowed levels of
/// nesting.
/// HISTORY New Entity for
/// Release IFC2x Edition 2.
/// 
/// Containment Use Definition
/// The IfcElementAssembly should have (and in most
/// implementation scenarios it is mandatory) a relationship for its
/// hierachical containment in the spatial structure of the
/// project.
/// 
/// The IfcElementAssembly is places within the project
/// spatial hierarchy using the objectified relationship
/// IfcRelContainedInSpatialStructure, refering to it by its
/// inverse attribute SELF\IfcElement.ContainedInStructure.
/// Subtypes of IfcSpatialStructureElement are valid spatial
/// containers, with IfcBuildingStorey being the default
/// container.
/// 
/// The IfcElementAssembly shall represent an aggregate,
/// i.e. it should have other elements, being subtypes of
/// IfcElement, as contained (sub)parts.
/// 
/// The IfcElementAssembly is an aggregate i.e. being
/// composed by other elements and acting as an assembly using the
/// objectified relationship IfcRelAggregates, refering to it
/// by its inverse attribute
/// SELF\IfcObjectDefinition.IsDecomposedBy. Components of an
/// assembly are described by instances of subtypes of
/// IfcElement.
/// In this case, the containedÿsubtypes of IfcElement
/// shall not be additionally contained in the project spatial
/// hierarchy, i.e. the inverse attribute
/// SELF\IfcElement.ContainedInStructure of those
/// IfcElement's shall be NIL.
/// 
/// Figure 27 illustrates spatial containment and element aggregation relationships.
/// 
/// Figure 27 — Element assembly containment
/// 
/// Geometry Use Definitions
/// The geometric representation of IfcElementAssembly is
/// given by the IfcProductDefinitionShape, allowing multiple
/// geometric representations.
/// Local Placement
/// The local placement for IfcElementAssembly is defined
/// in its supertype IfcProduct. It is defined by the
/// IfcLocalPlacement, which defines the local coordinate
/// system that is referenced by all geometric representations.
/// 
/// The PlacementRelTo relationship of
/// IfcLocalPlacement shall point (if given) to the local
/// placement of the same IfcSpatialStructureElement that is
/// used in the ContainedInStructure inverse attribute or to a
/// referenced spatial structure element at a higher level.
/// If the relative placement is not used, the absolute placement
/// is defined within the world coordinate system.
/// 
/// Geometric Representations
/// The geometry of an IfcElementAssembly is generally
/// formed from its components, in which case it does not need to
/// have an explicit geometric representation. In some cases it may
/// be useful to also expose an own explicit representation of the
/// aggregate.
/// NOTEÿ View definitions or implementer
/// agreements may further constrain the applicability of certain
/// shape representations at the IfcElementAssembly in respect
/// of the shape representations of its parts.
/// Informal proposition
/// 
/// The IfcElementAssembly shall have an aggregation
/// relationship to the contained parts, i.e. the (INV)
/// IsDecomposedBy relationship shall be utilzed.
class IfcElementAssembly : public IfcElement {
public:
    /// Whether the optional attribute AssemblyPlace is defined for this IfcElementAssembly
    bool hasAssemblyPlace() const;
    /// A designation of where the assembly is intended to take place defined by an Enum.
    IfcAssemblyPlaceEnum::IfcAssemblyPlaceEnum AssemblyPlace() const;
    void setAssemblyPlace(IfcAssemblyPlaceEnum::IfcAssemblyPlaceEnum v);
    /// Predefined generic types for a element assembly that are specified in an enumeration. There might be property sets defined specifically for each predefined type.
    /// 
    /// IFC2x4 CHANGE  The attribute has been changed to be optional.
    IfcElementAssemblyTypeEnum::IfcElementAssemblyTypeEnum PredefinedType() const;
    void setPredefinedType(IfcElementAssemblyTypeEnum::IfcElementAssemblyTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; case 9: return IfcUtil::Argument_ENUMERATION; } return IfcElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcAssemblyPlaceEnum; case 9: return Type::IfcElementAssemblyTypeEnum; } return IfcElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "AssemblyPlace"; case 9: return "PredefinedType"; } return IfcElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcElementAssembly (IfcAbstractEntity* e);
    IfcElementAssembly (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcAssemblyPlaceEnum::IfcAssemblyPlaceEnum > v9_AssemblyPlace, IfcElementAssemblyTypeEnum::IfcElementAssemblyTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcElementAssembly > list;
};
/// An element component is a representation for minor items included in, added to or connecting to or between
///   elements, which usually are not of interest from the overall building structure viewpoint.
///   However, these small parts may have vital and load carrying functions within the construction.
///   These items do not provide any actual space boundaries.
///   Typical examples of IfcElementComponents include different kinds of fasteners and various accessories.
/// 
/// HISTORY New entity in IFC Release 2x2
/// 
/// It is often desirable to model a number of same-shaped element components by means of a single
/// occurrence object, e.g. several bolts within a connection or a row of reinforcement elements.
/// In this IFC release, this is possible by means of multiple mapped representation as documented below.
/// 
/// To express the multiplicity of element components also on a higher semantic level,
/// an IfcElementQuantity should be provided via IfcRelDefinesByProperties.
/// The quantity should contain an IfcQuantityCount named 'Count' with the number of components.
/// 
/// Geometry Use Definition
/// 
/// The geometric representation of IfcElementComponent is given by the IfcProductDefinitionShape,
///   allowing multiple geometric representations. Included are:
/// 
/// Local Placement
///   The local placement for IfcElementComponent is defined in its supertype IfcProduct.
///   It is defined by the IfcLocalPlacement, which defines the local coordinate system that is
///   referenced by all geometric representations. 
/// 
/// The PlacementRelTo relationship of IfcLocalPlacement shall point (if given) to
///   the local placement of the same IfcElement or IfcElementAssembly, which is
///   used in the Decomposes inverse attribute, i.e. the local placement is defined relative to
///   the local placement of the element or element assembly in which the component is contained. 
///   If the relative placement is not used, the absolute placement is defined within the world coordinate system. 
/// 
/// Surface Model Representation
/// 
/// Any IfcElementComponent (if no further constraints are defined at the level of its subtypes)
///   may be represented as a single or multiple surface models, based on either shell or face based models.
///   The following attribute values for the IfcShapeRepresentation holding this geometric representation
///   shall be used:
/// 
/// RepresentationIdentifier : 'Body'
///   RepresentationType : 'SurfaceModel'
/// 
/// Brep Representation
/// 
/// Any IfcElementComponent (if no further constraints are defined at the level of its subtypes)
///   may be represented as a single or multiple Boundary Representation elements (which are restricted to faceted
///   Brep with or without voids). The Brep representation allows for the representation of complex element shape.
///   The following attribute values for the IfcShapeRepresentation holding this geometric representation
///   shall be used:
/// 
/// RepresentationIdentifier : 'Body'
///   RepresentationType : 'Brep'
/// 
/// Mapped Representation
/// 
/// The mapped item, IfcMappedItem, should be used if appropriate as it allows for reusing the geometry
///   definition of a type at occurrences of the same type.
///   The following attribute values for the IfcShapeRepresentation holding this geometric representation
///   shall be used:
/// 
/// RepresentationIdentifier : 'Body'
///   RepresentationType : 'MappedRepresentation'
/// 
/// Multiple Mapped Representation
/// 
/// A single instance of a subtype of IfcElementComponent can stand for several
/// actual element components at once.  In this case, the IfcShapeRepresentation
/// contains as many mapped items as there are element components combined within this
/// occurrence object:
/// 
/// Figure 151 illustrates multiple components modeled as a single occurrence object (here: IfcFastener)
/// 
/// Figure 151 — Element component mapped representation
/// 
/// Representation identifier and type are the same as in single mapped representation.
/// The number of mapped items in the representation corresponds with the count of
/// element components in the IfcElementQuantity.
class IfcElementComponent : public IfcElement {
public:
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcElementComponent (IfcAbstractEntity* e);
    IfcElementComponent (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag);
    typedef IfcTemplatedEntityList< IfcElementComponent > list;
};
/// Definition from IAI:
///   The element type (IfcElementComponentType) represents the supertype for element 
///   types which define lists of commonly shared property set definitions of various small parts and       accessories and an optional set of product
///   representations. It is used to define a supporting element mainly within 
///   structural and building services domains (i.e. the specific type information  
///   common to all occurrences of that type). 
/// 
/// HISTORY New entity in IFC
///   Release 2x2
class IfcElementComponentType : public IfcElementType {
public:
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcElementType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcElementType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcElementType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcElementComponentType (IfcAbstractEntity* e);
    IfcElementComponentType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType);
    typedef IfcTemplatedEntityList< IfcElementComponentType > list;
};
/// Definition from ISO/CD 10303-42:1992: An ellipse (IfcEllipse) is a conic section defined by the lengths of the semi-major and semi-minor diameters and the position (center or mid point of the line joining the foci) and orientation of the curve. Interpretation of the data shall be as follows:
/// 
/// C  = SELF\IfcConic.Position.Location  
///   x  = SELF\IfcConic.Position.P[1]  
///   y  = SELF\IfcConic.Position.P[2]  
///   z  = SELF\IfcConic.Position.P[3]  
///   R1 = SemiAxis1 
///   R2 = SemiAxis2 
///   and the ellipse is parameterized as:  
/// 
/// The parameterization range is 0 £
///   u £ 2p (or 0
///   £ u £
///   360 degree). In the placement coordinate system defined above, the ellipse is
///   the equation C = 0, where 
/// 
/// The positive sense of the ellipse at any point is in the tangent direction, T, to the curve at the point, where 
/// 
/// The inherited Position.Location from IfcConic is the center of the IfcEllipse, and the inherited Position.P[1] from IfcConic the direction of the SemiAxis1.  
/// 
/// NOTE  Corresponding ISO 10303 entity: ellipse. Please refer to ISO/IS 10303-42:1994, p. 39 for the final definition of the formal standard.
/// 
/// HISTORY  New class in IFC Release 1.0
/// 
/// Figure 280 illustrates the definition of the IfcEllipse within the (in this case three-dimensional) position coordinate system. 
/// 
/// Figure 280 — Ellipse geometry
class IfcEllipse : public IfcConic {
public:
    /// The first radius of the ellipse which shall be positive. Placement.Axes[1] gives the direction of the SemiAxis1.
    double SemiAxis1() const;
    void setSemiAxis1(double v);
    /// The second radius of the ellipse which shall be positive.
    double SemiAxis2() const;
    void setSemiAxis2(double v);
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 1: return IfcUtil::Argument_DOUBLE; case 2: return IfcUtil::Argument_DOUBLE; } return IfcConic::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 1: return Type::IfcPositiveLengthMeasure; case 2: return Type::IfcPositiveLengthMeasure; } return IfcConic::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 1: return "SemiAxis1"; case 2: return "SemiAxis2"; } return IfcConic::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcEllipse (IfcAbstractEntity* e);
    IfcEllipse (IfcAxis2Placement* v1_Position, double v2_SemiAxis1, double v3_SemiAxis2);
    typedef IfcTemplatedEntityList< IfcEllipse > list;
};
/// The element type IfcEnergyConversionType defines a list of commonly shared property
///   set definitions of an energy conversion device and an optional set of product representations.
///   It is used to define an energy conversion device specification (i.e. the specific product
///   information, that is common to all occurrences of that product type). 
/// 
/// NOTE: The product representations are defined as
///   representation maps (at the level of the supertype IfcTypeProduct, which
///   get assigned by an element occurrence instance through the
///   IfcShapeRepresentation.Item[1] being an
///   IfcMappedItem.
/// 
/// A energy conversion type is used to define the common properties of a
///   energy conversion device that may be applied to many occurrences of that type. 
/// An energy conversion device is a building systems device that converts energy from one form into another such 
/// 
/// as a boiler (i.e., combusting gas to heat water), chiller (i.e., using a refrigeration cycle to cool a 
/// 
/// liquid), or a cooling coil (i.e., using the phase-change characteristics of a refrigerant to cool air).
///   Energy conversion types (or the instantiable subtypes) may be exchanged 
///   without being already assigned to occurrences. 
/// 
/// The occurrences of the IfcEnergyConversionType are represented
///   by instances of IfcEnergyConversionDevice. 
/// 
/// HISTORY: New entity in IFC Release 2x2.
class IfcEnergyConversionDeviceType : public IfcDistributionFlowElementType {
public:
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcDistributionFlowElementType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcDistributionFlowElementType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcDistributionFlowElementType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcEnergyConversionDeviceType (IfcAbstractEntity* e);
    IfcEnergyConversionDeviceType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType);
    typedef IfcTemplatedEntityList< IfcEnergyConversionDeviceType > list;
};

class IfcEquipmentElement : public IfcElement {
public:
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcEquipmentElement (IfcAbstractEntity* e);
    IfcEquipmentElement (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag);
    typedef IfcTemplatedEntityList< IfcEquipmentElement > list;
};

class IfcEquipmentStandard : public IfcControl {
public:
    virtual unsigned int getArgumentCount() const { return 5; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcControl::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcControl::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcControl::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcEquipmentStandard (IfcAbstractEntity* e);
    IfcEquipmentStandard (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType);
    typedef IfcTemplatedEntityList< IfcEquipmentStandard > list;
};
/// The energy conversion device type IfcEvaporativeCoolerType defines commonly shared information for occurrences of evaporative coolers.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a evaporative cooler specification (i.e. the specific product information, that is common to all occurrences of that product type).  Evaporative Cooler types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcEvaporativeCoolerType are represented by instances of IfcEvaporativeCooler. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcEnergyConversionDeviceType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_EvaporativeCoolerTypeCommon 
/// 
/// Material Use Definition 
/// The material of the IfcEvaporativeCoolerType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Media': Heat exchanger media material. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcEvaporativeCoolerType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcEvaporativeCooler for standard port definitions.
class IfcEvaporativeCoolerType : public IfcEnergyConversionDeviceType {
public:
    /// Defines the type of evaporative cooler.
    IfcEvaporativeCoolerTypeEnum::IfcEvaporativeCoolerTypeEnum PredefinedType() const;
    void setPredefinedType(IfcEvaporativeCoolerTypeEnum::IfcEvaporativeCoolerTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcEnergyConversionDeviceType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcEvaporativeCoolerTypeEnum; } return IfcEnergyConversionDeviceType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcEnergyConversionDeviceType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcEvaporativeCoolerType (IfcAbstractEntity* e);
    IfcEvaporativeCoolerType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcEvaporativeCoolerTypeEnum::IfcEvaporativeCoolerTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcEvaporativeCoolerType > list;
};
/// The energy conversion device type IfcEvaporatorType defines commonly shared information for occurrences of evaporators.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a evaporator specification (i.e. the specific product information, that is common to all occurrences of that product type).  Evaporator types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcEvaporatorType are represented by instances of IfcEvaporator. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcEnergyConversionDeviceType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_EvaporatorTypeCommon 
/// 
/// Material Use Definition 
/// The material of the IfcEvaporatorType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Refrigerant': Refrigerant material. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcEvaporatorType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcEvaporator for standard port definitions.
class IfcEvaporatorType : public IfcEnergyConversionDeviceType {
public:
    /// Defines the type of evaporator.
    IfcEvaporatorTypeEnum::IfcEvaporatorTypeEnum PredefinedType() const;
    void setPredefinedType(IfcEvaporatorTypeEnum::IfcEvaporatorTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcEnergyConversionDeviceType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcEvaporatorTypeEnum; } return IfcEnergyConversionDeviceType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcEnergyConversionDeviceType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcEvaporatorType (IfcAbstractEntity* e);
    IfcEvaporatorType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcEvaporatorTypeEnum::IfcEvaporatorTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcEvaporatorType > list;
};
/// Definition from ISO/CD 10303-42:1992: A faceted B-rep
/// is a simple form of boundary representation model in which all
/// faces are planar and all edges are straight lines. Unlike the
/// B-rep model, edges and vertices are not represented explicitly in
/// the model but are implicitly available through the poly loop
/// entity. A faceted B-rep has to meet the same topological
/// constraints as the manifold solid B-rep.
/// 
/// NOTE The faceted B-rep has been introduced in order to support the larger number of systems that allow boundary type solid representations with planar surfaces only.
/// 
/// NOTE Corresponding ISO 10303-42 entity: faceted_brep. Please refer to ISO/IS 10303-42:1994, p. 173 for the final definition of the formal standard. In the current IFC Release faceted B-rep with voids is represented by an own subtype and not defined via an implicit ANDOR supertype constraint as in ISO/IS 10303-42:1994. This change has been made due to the fact, that only ONEOF supertype constraint is allowed within the IFC data schema.
/// 
/// HISTORY  New entity in IFC Release 1.0
/// 
/// Informal proposition:
/// 
/// All the bounding loops of all the faces of all the shells in
/// the IfcFacetedBrep shall be of type
/// IfcPolyLoop.
/// All vertices shall be referenced by all polyloops, sharing the vertex. That is, each Cartesian point shall be referenced by at least three polyloops.
/// 
/// Figure 257 illustrates use of IfcFacetedBrep for boundary representation models with planar surfaces only. The diagram shows the topological and geometric representation items that are used for faceted breps. Each IfcCartesianPoint, used within the IfcFacetedBrep shall be referenced three times by an IfcPolyLoop bounding a different IfcFace.
/// 
/// Figure 257 — Faceted B-rep
class IfcFacetedBrep : public IfcManifoldSolidBrep {
public:
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcManifoldSolidBrep::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcManifoldSolidBrep::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcManifoldSolidBrep::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcFacetedBrep (IfcAbstractEntity* e);
    IfcFacetedBrep (IfcClosedShell* v1_Outer);
    typedef IfcTemplatedEntityList< IfcFacetedBrep > list;
};
/// The IfcFacetedBrepWithVoids
/// is a specialization of a faceted B-rep which contains one or more
/// voids in its interior. The voids are represented as closed shells
/// which are defined so that the shell normal point into the
/// void.
/// 
/// NOTEÿ Corresponding ISO 10303-42 entity: brep_with_voids (see note above). Please refer to ISO/IS 10303-42:1994, p. 173 for the final definition of the formal standard. In IFC faceted B-rep with voids is represented by this subtype IfcFacetedBrepWithVoids and not defined via an implicit ANDOR supertype constraint as in ISO/IS 10303-42:1994 between an instance of faceted_brep AND brep_with_voids. This change has been made due to the fact, that only ONEOF supertype constraint is allowed within the IFC object model.
/// 
/// HISTORYÿ New entity in IFC Release 1.0
/// 
/// IFC2x4 CHANGEÿ Subtyping changed from IfcManifoldSolidBrep to IfcFacetedBrep with upward compatibility for file based exchange.
/// 
/// Informal propositions:
/// 
/// Each void shell shall be disjoint from the outer shell and
/// from every other void shell
/// Each void shell shall be enclosed within the outer shell but
/// not within any other void shell. In particular the outer shell is
/// not in the set of void shells
/// Each shell in the IfcManifoldSolidBrep shall be
/// referenced only once.
/// All the bounding loops of all the faces of all the shells in
/// the IfcFacetedBrep shall be of type
/// IfcPolyLoop.
class IfcFacetedBrepWithVoids : public IfcManifoldSolidBrep {
public:
    /// Set of closed shells defining voids within the solid.
    IfcTemplatedEntityList< IfcClosedShell >::ptr Voids() const;
    void setVoids(IfcTemplatedEntityList< IfcClosedShell >::ptr v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 1: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } return IfcManifoldSolidBrep::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 1: return Type::IfcClosedShell; } return IfcManifoldSolidBrep::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 1: return "Voids"; } return IfcManifoldSolidBrep::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcFacetedBrepWithVoids (IfcAbstractEntity* e);
    IfcFacetedBrepWithVoids (IfcClosedShell* v1_Outer, IfcTemplatedEntityList< IfcClosedShell >::ptr v2_Voids);
    typedef IfcTemplatedEntityList< IfcFacetedBrepWithVoids > list;
};
/// Definition from IAI:
///   Representations of fixing parts which are used as fasteners to connect or join elements with 
///   other elements.
/// 
/// HISTORY New entity in IFC Release 2x2
/// 
/// IFC 2x4 change:
/// Attribute PredefinedType added.
class IfcFastener : public IfcElementComponent {
public:
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcElementComponent::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcElementComponent::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcElementComponent::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcFastener (IfcAbstractEntity* e);
    IfcFastener (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag);
    typedef IfcTemplatedEntityList< IfcFastener > list;
};
/// Definition from IAI:
///   The element type (IfcFastenerType) defines a list of commonly shared
///   property set definitions of a fastener and an optional set of product
///   representations. It is used to define fasteners mainly within 
///   structural and building services domains (i.e. the specific type information  
///   common to all occurrences of that type). 
/// 
/// The occurrences of the IfcFastenerType are represented by
///   instances of IfcFastener.
/// 
/// HISTORY New entity in IFC Release 2x2
/// 
/// IFC 2x4 change:
/// Attribute PredefinedType added.
/// Subtype IfcMechanicalFastenerType redefined as direct subtype of IfcElementComponentType.
/// 
/// Property Set Use Definition
/// 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.
/// 
/// The following property set definitions are applicable to this entity according to the PredefinedType attribute:
/// 
/// Pset_FastenerWeld (WELD)
class IfcFastenerType : public IfcElementComponentType {
public:
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcElementComponentType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcElementComponentType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcElementComponentType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcFastenerType (IfcAbstractEntity* e);
    IfcFastenerType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType);
    typedef IfcTemplatedEntityList< IfcFastenerType > list;
};
/// Definition from IAI: Generalization of all existence
/// dependent elements which modify the shape and appearance of the
/// associated master element. The IfcFeatureElement offers
/// the ability to handle shape modifiers as semantic objects within
/// the IFC object model.
/// 
/// NOTE The term "feature" has a predefined meaning in a
/// context of "feature-based modeling" and within steel construction
/// work. It is introduced here in a broader sense to cover all
/// existence dependent, but semantically described, modifiers of an
/// element's shape and appearance. It is envisioned that future
/// releases enhance the feature-based capabilities of the IFC
/// model.
/// 
/// In contrary to the aggregation, as used in
/// IfcElementAssembly, that defines the aggregate as a
/// container element, that has equally treated parts, the feature
/// concept introduced by IfcFeatureElement defines the master
/// element with subordinate parts as additions, or with voids or
/// cut-outs as subtractions.
/// 
/// HISTORY New entity in Release
/// IFC2x Edition 2.
/// NOTE The entity is introduced as an
/// upward compatible extension of the IFC2x platform. It is an
/// intermediate abstract supertype without defining its own explicit
/// attributes.
/// 
/// Containment Use Definition
/// As a subordinate part being fully dependent on the master
/// element the IfcFeatureElement shall have no independent
/// containment relationship to the spatial structure.
/// 
/// The SELF\IfcElement.ContainedInStructure relationship
/// shall be NIL.
/// 
/// Geometry Use Definition
/// The geometric representation of IfcFeatureElement is
/// given by the IfcProductDefinitionShape, allowing multiple
/// geometric representation.
/// Local Placement
/// The local placement for IfcFeatureElement is defined in
/// its supertype IfcProduct. It is defined by the
/// IfcLocalPlacement, which defines the local coordinate
/// system that is referenced by all geometric representations.
/// 
/// The PlacementRelTo relationship of
/// IfcLocalPlacement shall point (if given) to the local
/// placement of the master IfcElement (its relevant
/// subtypes), which is associated to the IfcFeatureElement by
/// the appropriate relationship object.
/// If the relative placement is not used, the absolute placement
/// is defined within the world coordinate system.
/// 
/// Geometric Representations
/// Any IfcFeatureElement can be represented by one or
/// several geometric representations. A detailed specification is
/// introduced at the level of subtypes. Only the general
/// representation identifier 'Box' with representation type
/// 'BoundingBox', and representation identifier 'Body' with
/// representation type 'Brep' are defined here.
/// Box Representation
/// Any IfcFeatureElement may be represented as a bounding
/// box, which shows the maximum extend of the body within the
/// coordinated system established by the IfcLocalPlacement.
/// The bounding box representation is the simplest geometric
/// representation available. The following attribute values for the
/// IfcShapeRepresentation holding this geometric
/// representation shall be used:
/// 
/// RepresentationIdentifier : 'Box'
/// RepresentationType : 'BoundingBox'
/// 
/// Body Representation
/// The body representation of any IfcFeatureElement can
/// have the following representation types: 'Brep'. Other
/// representation types might be specified at the level of
/// subtypes.
/// Brep Representation Type
/// Any IfcFeatureElement (so far no further constraints
/// are defined at the level of its subtypes) may be represented as a
/// single or multiple Boundary Representation elements (which are
/// restricted to faceted Brep with or without voids). The Brep
/// representation allows for the representation of complex element
/// shape. The following attribute values for the
/// IfcShapeRepresentation holding this geometric
/// representation shall be used:
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'Brep'
/// 
/// In some cases it may be useful to also expose a simple
/// representation as a bounding box representation of the same
/// complex shape.
class IfcFeatureElement : public IfcElement {
public:
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcFeatureElement (IfcAbstractEntity* e);
    IfcFeatureElement (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag);
    typedef IfcTemplatedEntityList< IfcFeatureElement > list;
};
/// Definition from IAI: A specialization of the general
///   feature element, that represents an existence dependent
///   element which modifies the shape and appearance of the
///   associated master element. The
///   IfcFeatureElementAddition offers the ability to
///   handle shape modifiers as semantic objects within the IFC
///   object model that add to the shape of the master element.
/// 
/// HISTORY New entity in
///   Release IFC2x Edition 2.
///   NOTE The entity is
///   introduced as an upward compatible extension of the IFC2x
///   platform. It is an intermediate abstract supertype
///   without defining its own explicit
///   attributes.
/// 
/// The IfcFeatureElementAddition is associated to its
///   master element by virtue of the objectified relationship
///   IfcRelProjectsElement. This relationship implies a
///   Boolean 'union' operation between the shape of the master
///   element and the shape of the addition feature.
/// 
/// Containment use definition
/// 
/// The containment to the spatial structure is defined at the
///   level of the supertype IfcFeatureElement
/// 
/// Geometry Use Definitions
/// 
/// The geometric representation of
///   IfcFeatureElementAddition is given by the
///   IfcProductDefinitionShape, allowing multiple
///   geometric representations.
/// 
/// Local Placement
/// 
/// The local placement for IfcFeatureElementAddition is
///   defined in its supertype IfcProduct. It is defined
///   by the IfcLocalPlacement, which defines the local
///   coordinate system that is referenced by all geometric
///   representations. The local placement is always defined in
///   relation to the local placement of the element to which the
///   feature element is added:
/// 
/// The PlacementRelTo relationship of
///   IfcLocalPlacement shall point to the local placement
///   of the same IfcElement, which is used in the
///   HasAdditionFeature.RelatingElement inverse
///   attribute.
/// 
/// Shape Representation
/// 
/// The geometry use definitions for the shape representation
///   of the IfcFeatureElementAddition is given at the
///   level of its subtypes.
class IfcFeatureElementAddition : public IfcFeatureElement {
public:
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcFeatureElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcFeatureElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcFeatureElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcRelProjectsElement >::ptr ProjectsElements() const; // INVERSE IfcRelProjectsElement::RelatedFeatureElement
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcFeatureElementAddition (IfcAbstractEntity* e);
    IfcFeatureElementAddition (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag);
    typedef IfcTemplatedEntityList< IfcFeatureElementAddition > list;
};
/// The IfcFeatureElementSubtraction is specialization of
/// the general feature element, that represents an existence dependent
/// elements which modifies the shape and appearance of the associated
/// master element. The IfcFeatureElementSubtraction offers the
/// ability to handle shape modifiers as semantic objects within the
/// IFC object model that subtract from the shape of the master
/// element.
/// 
/// A single subtraction feature
/// such as the subtype IfcOpeningElement is assigned by a
/// single subtraction relationship IfcRelVoidsElement to one
/// occurrences of IfcElement. It establishes a 1:1
/// relationship between the opening and the element. An element may
/// have several IfcRelVoidsElement relationships, enabling
/// several voids.
/// 
/// The voiding relationship between a master element and a
/// subtraction feature is geometrically resolved by a Boolean
/// difference operation.
/// 
/// HISTORY New entity in
/// Release IFC2x Edition 2.
/// 
/// Containment use definition
/// The IfcFeatureElementSubtraction shall have no
/// independent containment relationship to the spatial structure. See
/// explanation at supertype IfcFeatureElement
/// Geometry Use Definitions
/// The geometric representation of
/// IfcFeatureElementSubtraction is given by the
/// IfcProductDefinitionShape, allowing multiple geometric
/// representations.
/// Local Placement
/// The local placement for IfcFeatureElementSubtraction is
/// defined in its supertype IfcProduct. It is defined by the
/// IfcLocalPlacement, which defines the local coordinate system
/// that is referenced by all geometric representations. The local
/// placement is always defined in relation to the local placement of
/// the building element from which the feature element substration is
/// substracted:
/// 
/// The PlacementRelTo relationship of
/// IfcLocalPlacement shall point (if given) to the local
/// placement of the same IfcElement, which is used in the
/// VoidsElements.RelatingElement inverse attribute.
/// 
/// Shape Representation
/// The geometry use definitions for the shape representation of the
/// IfcFeatureElementSubtraction is given at the level of its
/// subtypes.
class IfcFeatureElementSubtraction : public IfcFeatureElement {
public:
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcFeatureElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcFeatureElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcFeatureElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcRelVoidsElement >::ptr VoidsElements() const; // INVERSE IfcRelVoidsElement::RelatedOpeningElement
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcFeatureElementSubtraction (IfcAbstractEntity* e);
    IfcFeatureElementSubtraction (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag);
    typedef IfcTemplatedEntityList< IfcFeatureElementSubtraction > list;
};
/// The element type IfcFlowControllerType defines a list of commonly shared property
///   set definitions of a flow controller and an optional set of product representations.
///   It is used to define a flow controller specification (i.e. the specific product
///   information, that is common to all occurrences of that product type). 
/// 
/// NOTE: The product representations are defined as
///   representation maps (at the level of the supertype IfcTypeProduct, which
///   get assigned by an element occurrence instance through the
///   IfcShapeRepresentation.Item[1] being an
///   IfcMappedItem.
/// 
/// A flow controller type is used to define the common properties of a
///   flow controller that may be applied to many occurrences of that type.
/// A flow controller is a device that regulates flow within a distribution system, such as a valve in a piping 
/// 
/// system, modulating damper in an air distribution system, or electrical switch in an electrical distribution 
/// 
/// system. Flow controller types (or the instantiable subtypes) may be exchanged 
///   without being already assigned to occurrences. 
/// 
/// The occurrences of the IfcFlowControllerType are represented
///   by instances of IfcFlowController or its subtypes. 
/// 
/// HISTORY: New entity in IFC Release 2x2.
class IfcFlowControllerType : public IfcDistributionFlowElementType {
public:
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcDistributionFlowElementType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcDistributionFlowElementType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcDistributionFlowElementType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcFlowControllerType (IfcAbstractEntity* e);
    IfcFlowControllerType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType);
    typedef IfcTemplatedEntityList< IfcFlowControllerType > list;
};
/// The element type IfcFlowFittingType defines a list of commonly shared property
///   set definitions of a flow fitting and an optional set of product representations.
///   It is used to define a flow fitting specification (i.e. the specific product
///   information, that is common to all occurrences of that product type). 
/// 
/// NOTE: The product representations are defined as
///   representation maps (at the level of the supertype IfcTypeProduct, which
///   get assigned by an element occurrence instance through the
///   IfcShapeRepresentation.Item[1] being an
///   IfcMappedItem.
/// 
/// A flow fitting type is used to define the common properties of a
///   flow fitting that may be applied to many occurrences of that type.
/// A flow fitting is a device that is used to interconnect flow segments or other fittings within a distribution 
/// 
/// system, such as a tee in a ducted system that branches flow into two directions, a junction box in an 
/// 
/// electrical distribution system, etc. 
///   Flow fitting types (or the instantiable subtypes) may be exchanged 
///   without being already assigned to occurrences. 
/// 
/// The occurrences of the IfcFlowFittingType are represented
///   by instances of IfcFlowFitting or its subtypes. 
/// 
/// HISTORY: New entity in IFC Release 2x2.
class IfcFlowFittingType : public IfcDistributionFlowElementType {
public:
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcDistributionFlowElementType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcDistributionFlowElementType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcDistributionFlowElementType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcFlowFittingType (IfcAbstractEntity* e);
    IfcFlowFittingType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType);
    typedef IfcTemplatedEntityList< IfcFlowFittingType > list;
};
/// The flow controller type IfcFlowMeterType defines commonly shared information for occurrences of flow meters.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a flow meter specification (i.e. the specific product information, that is common to all occurrences of that product type).  Flow Meter types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcFlowMeterType are represented by instances of IfcFlowMeter. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcFlowControllerType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_FlowMeterTypeCommon 
/// 
/// The following property set definitions are applicable to this entity according to the PredefinedType attribute:  
/// Pset_FlowMeterTypeEnergyMeter (ENERGYMETER) 
/// Pset_FlowMeterTypeGasMeter (GASMETER) 
/// Pset_FlowMeterTypeOilMeter (OILMETER) 
/// Pset_FlowMeterTypeWaterMeter (WATERMETER) 
/// 
/// Material Use Definition 
/// The material of the IfcFlowMeterType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Casing': Material from which the casing is constructed. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcFlowMeterType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcFlowMeter for standard port definitions.
class IfcFlowMeterType : public IfcFlowControllerType {
public:
    /// Defines the type of flow meter.
    IfcFlowMeterTypeEnum::IfcFlowMeterTypeEnum PredefinedType() const;
    void setPredefinedType(IfcFlowMeterTypeEnum::IfcFlowMeterTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcFlowControllerType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcFlowMeterTypeEnum; } return IfcFlowControllerType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcFlowControllerType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcFlowMeterType (IfcAbstractEntity* e);
    IfcFlowMeterType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcFlowMeterTypeEnum::IfcFlowMeterTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcFlowMeterType > list;
};
/// The element type IfcFlowMovingDeviceType defines a list of commonly shared property
///   set definitions of a flow moving device and an optional set of product representations.
///   It is used to define a flow moving device specification (i.e. the specific product
///   information, that is common to all occurrences of that product type). 
/// 
/// NOTE: The product representations are defined as
///   representation maps (at the level of the supertype IfcTypeProduct, which
///   get assigned by an element occurrence instance through the
///   IfcShapeRepresentation.Item[1] being an
///   IfcMappedItem.
/// 
/// A flow moving type is used to define the common properties of a
///   flow moving device that may be applied to many occurrences of that type.
/// A flow moving device is a device that is used to produce a pressure differential in a distribution system, 
/// 
/// such as a pump, fan, compressor, etc. 
///   Flow moving types (or the instantiable subtypes) may be exchanged 
///   without being already assigned to occurrences. 
/// 
/// The occurrences of the IfcFlowMovingDeviceType are represented
///   by instances of IfcFlowMovingDevice. 
/// 
/// HISTORY: New entity in IFC Release 2x2.
class IfcFlowMovingDeviceType : public IfcDistributionFlowElementType {
public:
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcDistributionFlowElementType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcDistributionFlowElementType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcDistributionFlowElementType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcFlowMovingDeviceType (IfcAbstractEntity* e);
    IfcFlowMovingDeviceType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType);
    typedef IfcTemplatedEntityList< IfcFlowMovingDeviceType > list;
};
/// The element type IfcFlowSegmentType defines a list of commonly shared property
///   set definitions of a flow segment and an optional set of product representations.
///   It is used to define a flow segment specification (i.e. the specific product
///   information, that is common to all occurrences of that product type). 
/// 
/// NOTE: The product representations are defined as
///   representation maps (at the level of the supertype IfcTypeProduct, which
///   get assigned by an element occurrence instance through the
///   IfcShapeRepresentation.Item[1] being an
///   IfcMappedItem.
/// 
/// A flow segment type is used to define the common properties of a
///   flow segment that may be applied to many occurrences of that type.
/// A flow segment is a section of a distribution system, such as a duct, pipe, conduit, etc. that typically has 
/// 
/// only two ports. 
///   Flow segment types (or the instantiable subtypes) may be exchanged 
///   without being already assigned to occurrences. 
/// 
/// The occurrences of the IfcFlowSegmentType are represented
///   by instances of IfcFlowSegment or its subtypes. 
/// 
/// HISTORY: New entity in IFC Release 2x2.
/// 
/// Material Use Definition
/// The material of the IfcDistributionFlowSegmentType is defined using one of the following entities:
/// 
/// IfcMaterialProfileSet : This defines the material cross section which may be used to generate the 'Body' representation at occurrences (for parametric definitions not having representation), or for analysis purposes.
/// 
/// IfcMaterialConstituentSet : For elements containing multiple materials where profiles are not applicable, this indicates materials at named aspects.
/// 
/// IfcMaterial : For elements comprised of a single material where profiles are not applicable, this indicates the material.
class IfcFlowSegmentType : public IfcDistributionFlowElementType {
public:
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcDistributionFlowElementType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcDistributionFlowElementType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcDistributionFlowElementType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcFlowSegmentType (IfcAbstractEntity* e);
    IfcFlowSegmentType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType);
    typedef IfcTemplatedEntityList< IfcFlowSegmentType > list;
};
/// The element type IfcFlowStorageDeviceType defines a list of commonly shared property set definitions of a flow storage device and an optional set of product representations.  It is used to define a flow storage device specification (the specific product information that is common to all occurrences of that product type). 
/// 
/// A flow storage device is a device used for the temporary storage of a fluid (such as a tank) or the voltage potential induced by the induced electron flow (such as a battery). Flow storage types (or the instantiable subtypes) may be exchanged without being already assigned to occurrences. 
/// 
/// The occurrences of the IfcFlowStorageDeviceType are represented by instances of IfcFlowStorageDevice or its subtypes. 
/// 
/// HISTORY: New entity in IFC Release 2x2.
class IfcFlowStorageDeviceType : public IfcDistributionFlowElementType {
public:
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcDistributionFlowElementType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcDistributionFlowElementType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcDistributionFlowElementType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcFlowStorageDeviceType (IfcAbstractEntity* e);
    IfcFlowStorageDeviceType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType);
    typedef IfcTemplatedEntityList< IfcFlowStorageDeviceType > list;
};
/// The element type IfcFlowTerminalType defines a list of commonly shared property set definitions of a flow terminal and an optional set of product representations.  It is used to define a flow terminal specification (the specific product information that is common to all occurrences of that product type). 
/// 
/// A flow terminal type is used to define the common properties of a flow terminal that may be applied to many occurrences of that type.  A flow terminal acts as a terminus or beginning element in a distribution system such as a ceiling register in a ducted air distribution system, a sink in a waste-water system, or a light fixture in an electrical lighting system. Flow terminal types (or the instantiable subtypes) may be exchanged without being already assigned to occurrences. 
/// 
/// The occurrences of the IfcFlowTerminalType are represented by instances of IfcFlowTerminal or its subtypes. 
/// 
/// HISTORY: New entity in IFC Release 2x2.
class IfcFlowTerminalType : public IfcDistributionFlowElementType {
public:
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcDistributionFlowElementType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcDistributionFlowElementType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcDistributionFlowElementType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcFlowTerminalType (IfcAbstractEntity* e);
    IfcFlowTerminalType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType);
    typedef IfcTemplatedEntityList< IfcFlowTerminalType > list;
};
/// The element type IfcFlowTreatmentDeviceType defines a list of commonly shared property set definitions of a flow treatment device and an optional set of product representations. It is used to define a flow treatment device specification (the specific product information that is common to all occurrences of that product type). 
/// 
/// A flow treatment device is a device used to change the physical properties of the medium, such as an air, oil 
/// 
/// or water filter (used to remove particulates from the fluid), or a duct silencer (used to attenuate noise).  Flow treatment types (or the instantiable subtypes) may be exchanged without being already assigned to occurrences. 
/// 
/// The occurrences of the IfcFlowTreatmentDeviceType are represented by instances of IfcFlowTreatmentDevice or its subtypes. 
/// 
/// HISTORY: New entity in IFC Release 2x2.
class IfcFlowTreatmentDeviceType : public IfcDistributionFlowElementType {
public:
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcDistributionFlowElementType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcDistributionFlowElementType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcDistributionFlowElementType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcFlowTreatmentDeviceType (IfcAbstractEntity* e);
    IfcFlowTreatmentDeviceType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType);
    typedef IfcTemplatedEntityList< IfcFlowTreatmentDeviceType > list;
};
/// Definition from IAI: Generalization of all furniture
/// related objects. Furnishing objects are characterized as
/// being
/// 
/// pre-manufactured and assembled on-site, or
/// manufactured on-site (built-in)
/// 
/// Thus furnishing elements can either be movable, or not (as the
/// built-ins).
/// HISTORY New entity in
/// IFC Release 2x.
/// IFC2x4 CHANGE The entity is marked
/// as deprecated for instantiation - will be made ABSTRACT after
/// IFC2x4.
/// Geometry Use Definitions:
/// The geometric representation of IfcFurnishingElement is
/// given by the IfcProductDefinitionShape and
/// IfcLocalPlacement allowing multiple geometric
/// representation.
/// Local Placement
/// The local placement for IfcFurnishingElement is defined
/// in its supertype IfcProduct. It is defined by the
/// IfcLocalPlacement, which defines the local coordinate
/// system that is referenced by all geometric representations.
/// 
/// The PlacementRelTo relationship of
/// IfcLocalPlacement shall point (if given) to the local
/// placement of the same IfcSpatialStructureElement , which
/// is used in the ContainedInStructure inverse attribute, or
/// to a spatial structure element at a higher level, referenced by
/// that.
/// If the relative placement is not used, the absolute placement
/// is defined within the world coordinate system.
/// 
/// Geometric Representations
/// Any IfcFurnishingElement can be represented by one or
/// several geometric representations. This includes the general
/// representation types 'BoundingBox', 'GeometricCurveSet',
/// 'SurfaceModel', 'Brep', and 'MappedRepresentation' being defined
/// here.
/// Bounding Box Representation
/// Any IfcFurnishingElement may be represented as a
/// bounding box, which shows the maximum extend of the body within
/// the coordinated system established by the
/// IfcLocalPlacement. The bounding box representation is the
/// simplest geometric representation available. The following
/// attribute values for the IfcShapeRepresentation holding
/// this geometric representation shall be used:
/// 
/// RepresentationIdentifier : 'Box'
/// RepresentationType : 'BoundingBox'
/// 
/// Foot Print Representation
/// The foot print representation of IfcFurnishingElement
/// is given by either a single or multiple 2D points and curves. The
/// representation identifier and type of this geometric
/// representation are:
/// 
/// IfcShapeRepresentation.RepresentationIdentifier =
/// 'FootPrint'
/// IfcShapeRepresentation.RepresentationType =
/// 'GeometricCurveSet'
/// 
/// SurfaceModel Representation
/// Any IfcFurnishingElement (so far no further constraints
/// are defined at the level of its subtypes) may be represented as a
/// single or multiple surface models, based on either shell or face
/// based models. In some cases it may be useful to also expose a
/// simple representation as a bounding box representation of the
/// same complex shape. The representation identifier and type of
/// this geometric representation are:
/// 
/// IfcShapeRepresentation.RepresentationIdentifier =
/// 'Body'
/// IfcShapeRepresentation.RepresentationType =
/// 'SurfaceModel'
/// 
/// Brep Representation
/// Any IfcFurnishingElement (so far no further constraints
/// are defined at the level of its subtypes) may be represented as a
/// single or multiple Boundary Representation elements (which are
/// restricted to faceted Brep with or without voids). The Brep
/// representation allows for the representation of complex element
/// shape. In some cases it may be useful to also expose a simple
/// representation as a bounding box representation of the same
/// complex shape. The representation identifier and type of this
/// geometric representation are:
/// 
/// IfcShapeRepresentation.RepresentationIdentifier =
/// 'Body'
/// IfcShapeRepresentation.RepresentationType =
/// 'Brep'
/// 
/// MappedRepresentation
/// The IfcMappedItem should always be used in appropriate
/// cases as it allows for reusing the geometry definition of the
/// furnishing type for all occurrences of the same type. The
/// representation identifier and type of this geometric
/// representation are:
/// 
/// IfcShapeRepresentation.RepresentationIdentifier =
/// 'FootPrint', or 'Body' (depending of the representation map)
/// IfcShapeRepresentation.RepresentationType =
/// 'MappedRepresentation'
class IfcFurnishingElement : public IfcElement {
public:
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcFurnishingElement (IfcAbstractEntity* e);
    IfcFurnishingElement (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag);
    typedef IfcTemplatedEntityList< IfcFurnishingElement > list;
};

class IfcFurnitureStandard : public IfcControl {
public:
    virtual unsigned int getArgumentCount() const { return 5; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcControl::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcControl::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcControl::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcFurnitureStandard (IfcAbstractEntity* e);
    IfcFurnitureStandard (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType);
    typedef IfcTemplatedEntityList< IfcFurnitureStandard > list;
};

class IfcGasTerminalType : public IfcFlowTerminalType {
public:
    IfcGasTerminalTypeEnum::IfcGasTerminalTypeEnum PredefinedType() const;
    void setPredefinedType(IfcGasTerminalTypeEnum::IfcGasTerminalTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcFlowTerminalType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcGasTerminalTypeEnum; } return IfcFlowTerminalType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcFlowTerminalType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcGasTerminalType (IfcAbstractEntity* e);
    IfcGasTerminalType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcGasTerminalTypeEnum::IfcGasTerminalTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcGasTerminalType > list;
};
/// IfcGrid ia a planar design
/// grid defined in 3D space used as an aid in locating structural and
/// design elements. The position of the grid (ObjectPlacement)
/// is defined by a 3D coordinate system (and thereby the design grid
/// can be used in plan, section or in any position relative to the
/// world coordinate system). The position can be relative to the
/// object placement of other products or grids. The XY plane of the 3D
/// coordinate system is used to place the grid axes, which are 2D
/// curves (for example, line, circle, trimmed curve, polyline, or composite
/// curve).
/// The inherited attributes Name and Description can
/// be used to define a descriptive name of the grid and to indicate
/// the grid's purpose. A grid is defined by (normally) two, or
/// (in case of a triangular grid) three lists of grid axes. The
/// following table shows some examples.
/// A grid may support a rectangular layout (Figure 28), a radial layout (Figure 29), or a triangular layout (Figure 30).
/// 
/// Figure 28 — Grid rectangular layout
/// Figure 29 — Grid radial layout
/// Figure 30 — Grid triangular layout
/// 
/// The grid axes, defined within the design grid, are those
/// elements to which project objects will be placed relatively using
/// the IfcGridPlacement.
/// 
/// HISTORY New entity in IFC Release 1.0.
/// Informal Proposition
/// 
/// Grid axes, which are referenced in different lists of axes
/// (UAxes, VAxes, WAxes) shall not be parallel.
/// Grid axes should be defined such as there are no two grid axes
/// which intersect twice (see Figure 31).
/// 
/// left side: ambiguous intersections A1 and A2, a grid containing
/// such grid axes is not a valid design grid.
/// right side: the conflict can be resolved by splitting one grid
/// axis in a way, such as no ambiguous intersections exist.
/// 
/// Figure 31 — Grid intersections
/// 
/// Geometry Use Definitions
/// The geometric representation of IfcGrid is given by the
/// IfcProductDefinitionShape, allowing geometric
/// representations. Included are:
/// Local Placement
/// The local placement for IfcGrid is defined in its
/// supertype IfcProduct. It is defined by the
/// IfcLocalPlacement, which defines the local coordinate system
/// that is referenced by all geometric representations.
/// 
/// The PlacementRelTo relationship of
/// IfcLocalPlacement shall point (if given) to the local
/// placement of the same IfcSpatialStructureElement, which is
/// used in the ContainedInStructure inverse attribute, or to a
/// spatial structure element at a higher level, referenced by
/// that.
/// If the relative placement is not used, the absolute placement
/// is defined within the world coordinate system.
/// 
/// Geometric Representations
/// Currently, the use of a 2D 'FootPrint' representation of type
/// 'GeometricCurveSet' is supported.
/// GeometricCurveSet representation
/// The 2D geometric representation of IfcGrid is defined
/// using the 'GeometricCurveSet' geometry. The following attribute
/// values should be inserted
/// 
/// IfcShapeRepresentation.RepresentationIdentifier =
/// 'FootPrint'.
/// IfcShapeRepresentation.RepresentationType =
/// 'GeometricCurveSet' .
/// 
/// The following constraints apply to the 2D representation:
/// 
/// The IfcGeometricCurveSet shall be an (and the only)
/// Item of the IfcShapeRepresentation. It should contain
/// an IfcGeometricCurveSet containing subtypes of
/// IfcCurve, each representing a grid axis. Applicable subtypes
/// of IfcCurve are: IfcPolyline, IfcCircle,
/// IfcTrimmedCurve (based on BaseCurve referencing
/// IfcLine or IfcCircle). 
/// Each subtype of IfcCurve may have a curve style
/// assigned, using IfcAnnotationCurveOccurrence referencing
/// IfcCurveStyle.
/// Optionally the grid axis labels may be added as
/// IfcTextLiteral, and they may have text styles assigned,
/// using IfcAnnotationTextOccurrence referencing
/// IfcTextStyle.
/// 
/// As shown in Figure 32, the IfcGrid defines a placement coordinate system using the ObjectPlacement. The XY plane of the coordinate system is used to place the 2D grid axes. The Representation of IfcGrid is defined using IfcProductRepresentation, referencing an IfcShapeRepresentation, that includes IfcGeometricCurveSet as Items. All grid axes are added as IfcPolyline to the IfcGeometricCurveSet.
/// 
/// Figure 32 — Grid layout
/// 
/// As shown in Figure 33, the attributes UAxes and VAxes define lists of IfcGridAxis within the context of the grid. Each instance of IfcGridAxis refers to the same instance of IfcCurve (here the subtype IfcPolyline) that is contained within the IfcGeometricCurveSet that represents the IfcGrid.
/// 
/// Figure 33 — Grid representation
class IfcGrid : public IfcProduct {
public:
    /// List of grid axes defining the first row of grid lines.
    IfcTemplatedEntityList< IfcGridAxis >::ptr UAxes() const;
    void setUAxes(IfcTemplatedEntityList< IfcGridAxis >::ptr v);
    /// List of grid axes defining the second row of grid lines.
    IfcTemplatedEntityList< IfcGridAxis >::ptr VAxes() const;
    void setVAxes(IfcTemplatedEntityList< IfcGridAxis >::ptr v);
    /// Whether the optional attribute WAxes is defined for this IfcGrid
    bool hasWAxes() const;
    /// List of grid axes defining the third row of grid lines. It may be given in the case of a triangular grid.
    IfcTemplatedEntityList< IfcGridAxis >::ptr WAxes() const;
    void setWAxes(IfcTemplatedEntityList< IfcGridAxis >::ptr v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 7: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 8: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 9: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } return IfcProduct::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 7: return Type::IfcGridAxis; case 8: return Type::IfcGridAxis; case 9: return Type::IfcGridAxis; } return IfcProduct::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 7: return "UAxes"; case 8: return "VAxes"; case 9: return "WAxes"; } return IfcProduct::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcRelContainedInSpatialStructure >::ptr ContainedInStructure() const; // INVERSE IfcRelContainedInSpatialStructure::RelatedElements
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcGrid (IfcAbstractEntity* e);
    IfcGrid (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, IfcTemplatedEntityList< IfcGridAxis >::ptr v8_UAxes, IfcTemplatedEntityList< IfcGridAxis >::ptr v9_VAxes, boost::optional< IfcTemplatedEntityList< IfcGridAxis >::ptr > v10_WAxes);
    typedef IfcTemplatedEntityList< IfcGrid > list;
};
/// IfcGroup is an generalization of any arbitrary group. A group is a logical collection of objects. It does not have its own position, nor can it hold its own shape representation. Therefore a group is an aggregation under some non-geometrical / topological grouping aspects.
/// 
/// NOTE Use IfcRelDecomposes together with the appropriate subtypes of IfcProduct to define an aggregation of products that may have its own position and shape representation.
/// 
/// EXAMPLE An example for a group is a system, since it groups elements under the aspect of their role, regardless of their position in a building.
/// 
/// A group can hold any collection of objects (beingÿproducts, processes, controls, resources, actors or other groups). Thus groups can be nested. An object can be part of zero, one, or many groups. Grouping relationships are not required to be hierarchical nor do they imply a dependency.
/// 
/// NOTE Use IfcRelDecomposes together with the appropriate subtypes of IfcProduct to define an hierarchical aggregation of products.
/// 
/// A group can be exchanged without having already objects within the group collection.
/// 
/// HISTORY New entity in IFC Release 1.0.
/// 
/// IFC2x4 CHANGE The inverse IsGroupedBy relationship is set to 0..n
/// 
/// Relationship use definition
/// The group collection is handled by an instance of IfcRelAssignsToGroup, which assigns all group members to the IfcGroup.
/// 
/// Objects: included in group using IfcRelAssignsToGroup
/// 
/// Groups are assigned to other objects (such as a process or a resource) by the relationship object that refers to the corresponding
/// object:
/// 
/// Process: assigned using IfcRelAssignsToProcess
/// Resource: assigned using IfcRelAssignsToResource
/// 
/// Groups can be subjected to a control. The control information is then assigned:
/// 
/// Controls: affecting the group using IfcRelAssignsToControl
class IfcGroup : public IfcObject {
public:
    virtual unsigned int getArgumentCount() const { return 5; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcObject::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcObject::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcObject::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcRelAssignsToGroup >::ptr IsGroupedBy() const; // INVERSE IfcRelAssignsToGroup::RelatingGroup
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcGroup (IfcAbstractEntity* e);
    IfcGroup (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType);
    typedef IfcTemplatedEntityList< IfcGroup > list;
};
/// The energy conversion device type IfcHeatExchangerType defines commonly shared information for occurrences of heat exchangers.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a heat exchanger specification (i.e. the specific product information, that is common to all occurrences of that product type).  Heat Exchanger types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcHeatExchangerType are represented by instances of IfcHeatExchanger. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcEnergyConversionDeviceType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_HeatExchangerTypeCommon 
/// 
/// The following property set definitions are applicable to this entity according to the PredefinedType attribute:  
/// Pset_HeatExchangerTypePlate (PLATE) 
/// 
/// Material Use Definition 
/// The material of the IfcHeatExchangerType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Shell': Material used to construct the shell of the heat exchanger. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcHeatExchangerType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcHeatExchanger for standard port definitions.
class IfcHeatExchangerType : public IfcEnergyConversionDeviceType {
public:
    /// Defines the basic types of heat exchanger (e.g., plate, shell and tube, etc.).
    IfcHeatExchangerTypeEnum::IfcHeatExchangerTypeEnum PredefinedType() const;
    void setPredefinedType(IfcHeatExchangerTypeEnum::IfcHeatExchangerTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcEnergyConversionDeviceType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcHeatExchangerTypeEnum; } return IfcEnergyConversionDeviceType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcEnergyConversionDeviceType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcHeatExchangerType (IfcAbstractEntity* e);
    IfcHeatExchangerType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcHeatExchangerTypeEnum::IfcHeatExchangerTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcHeatExchangerType > list;
};
/// The energy conversion device type IfcHumidifierType defines commonly shared information for occurrences of humidifiers.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a humidifier specification (i.e. the specific product information, that is common to all occurrences of that product type).  Humidifier types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcHumidifierType are represented by instances of IfcHumidifier. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcEnergyConversionDeviceType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_HumidifierTypeCommon 
/// 
/// Material Use Definition 
/// The material of the IfcHumidifierType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Casing': Material from which the casing is constructed. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcHumidifierType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcHumidifier for standard port definitions.
class IfcHumidifierType : public IfcEnergyConversionDeviceType {
public:
    /// Defines the type of humidifier.
    IfcHumidifierTypeEnum::IfcHumidifierTypeEnum PredefinedType() const;
    void setPredefinedType(IfcHumidifierTypeEnum::IfcHumidifierTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcEnergyConversionDeviceType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcHumidifierTypeEnum; } return IfcEnergyConversionDeviceType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcEnergyConversionDeviceType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcHumidifierType (IfcAbstractEntity* e);
    IfcHumidifierType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcHumidifierTypeEnum::IfcHumidifierTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcHumidifierType > list;
};
/// An inventory is a list of items within an enterprise. 
/// 
/// Various types of inventory can be included. These are identified by the range of values within the inventory type enumeration which includes space, asset, and furniture. User defined inventories can also be defined for lists of particular types of element such as may be required in operating and maintenance instructions. Such inventories should be constrained to contain a list of elements of a restricted type.There are a number of actors that can be associated with an inventory, each actor having a role. Actors within the scope of the project are indicated using the IfcRelAssignsToActor relationship in which case roles should be defined through the IfcActorRole class; otherwise principal actors are identified as attributes of the class. In the existence of both, direct attributes take precedence.There are a number of costs that can be associated with an inventory, each cost having a role. These are specified through the CurrentValue and OriginalValue attributes.HISTORY: New entity in IFC2.0.  Modified in IFC2x4 to make all attributes optional and remove Where Rule. 
/// 
/// Assignment Use Definition 
///   The IfcInventory may have assignments of its own using the IfcRelAssignsToGroup relationship where RelatingGroup refers to the IfcInventory and RelatedObjects contains one or more objects of the following types:  
/// IfcAsset: Assets included in the inventory.
/// 
/// IfcElement: Elements such as furniture included in the inventory.
/// 
/// IfcSpace: Spaces included in the inventory.
class IfcInventory : public IfcGroup {
public:
    IfcInventoryTypeEnum::IfcInventoryTypeEnum InventoryType() const;
    void setInventoryType(IfcInventoryTypeEnum::IfcInventoryTypeEnum v);
    /// The organizational unit to which the inventory is applicable.
    IfcActorSelect* Jurisdiction() const;
    void setJurisdiction(IfcActorSelect* v);
    /// Persons who are responsible for the inventory.
    IfcTemplatedEntityList< IfcPerson >::ptr ResponsiblePersons() const;
    void setResponsiblePersons(IfcTemplatedEntityList< IfcPerson >::ptr v);
    /// The date on which the last update of the inventory was carried out.
    /// 
    /// IFC2x4 CHANGE Type changed from IfcDateTimeSelect.
    IfcCalendarDate* LastUpdateDate() const;
    void setLastUpdateDate(IfcCalendarDate* v);
    /// Whether the optional attribute CurrentValue is defined for this IfcInventory
    bool hasCurrentValue() const;
    /// An estimate of the current cost value of the inventory.
    IfcCostValue* CurrentValue() const;
    void setCurrentValue(IfcCostValue* v);
    /// Whether the optional attribute OriginalValue is defined for this IfcInventory
    bool hasOriginalValue() const;
    /// An estimate of the original cost value of the inventory.
    IfcCostValue* OriginalValue() const;
    void setOriginalValue(IfcCostValue* v);
    virtual unsigned int getArgumentCount() const { return 11; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 5: return IfcUtil::Argument_ENUMERATION; case 6: return IfcUtil::Argument_ENTITY_INSTANCE; case 7: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 8: return IfcUtil::Argument_ENTITY_INSTANCE; case 9: return IfcUtil::Argument_ENTITY_INSTANCE; case 10: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcGroup::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 5: return Type::IfcInventoryTypeEnum; case 6: return Type::IfcActorSelect; case 7: return Type::IfcPerson; case 8: return Type::IfcCalendarDate; case 9: return Type::IfcCostValue; case 10: return Type::IfcCostValue; } return IfcGroup::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 5: return "InventoryType"; case 6: return "Jurisdiction"; case 7: return "ResponsiblePersons"; case 8: return "LastUpdateDate"; case 9: return "CurrentValue"; case 10: return "OriginalValue"; } return IfcGroup::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcInventory (IfcAbstractEntity* e);
    IfcInventory (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcInventoryTypeEnum::IfcInventoryTypeEnum v6_InventoryType, IfcActorSelect* v7_Jurisdiction, IfcTemplatedEntityList< IfcPerson >::ptr v8_ResponsiblePersons, IfcCalendarDate* v9_LastUpdateDate, IfcCostValue* v10_CurrentValue, IfcCostValue* v11_OriginalValue);
    typedef IfcTemplatedEntityList< IfcInventory > list;
};
/// The flow fitting type IfcJunctionBoxType defines commonly shared information for occurrences of junction boxs.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a junction box specification (i.e. the specific product information, that is common to all occurrences of that product type).  Junction Box types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcJunctionBoxType are represented by instances of IfcJunctionBox. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcFlowFittingType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_ElectricalDeviceCommon 
/// Pset_JunctionBoxTypeCommon 
/// 
/// Material Use Definition 
/// The material of the IfcJunctionBoxType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Casing': Material from which the casing is constructed. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcJunctionBoxType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcJunctionBox for standard port definitions.
class IfcJunctionBoxType : public IfcFlowFittingType {
public:
    /// Identifies the predefined types of junction boxes from which the type required may be set.
    IfcJunctionBoxTypeEnum::IfcJunctionBoxTypeEnum PredefinedType() const;
    void setPredefinedType(IfcJunctionBoxTypeEnum::IfcJunctionBoxTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcFlowFittingType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcJunctionBoxTypeEnum; } return IfcFlowFittingType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcFlowFittingType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcJunctionBoxType (IfcAbstractEntity* e);
    IfcJunctionBoxType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcJunctionBoxTypeEnum::IfcJunctionBoxTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcJunctionBoxType > list;
};
/// An IfcLaborResource is used in construction with particular skills or crafts required to perform certain types of construction or management related work.  
/// 
/// HISTORY: New Entity in IFC Release 2.0.  Base type and documentation extended in IFC 2x4.
/// 
/// IFC2x4 CHANGE: The attribute Skillset has been deleted; use LongDescription to describe the skillset.
/// 
/// The purpose of an IfcLaborResource is to identify a skillset that may be required or used. The skillset identified may be (for instance) chargehand, foreman, labourer, plumbers mate etc. and provides a designation of a particular level of skill. It can be used to identify the generic type of labor resource that is required for a purpose without having to be specific about the actor (person or organization) providing the resource occurrence. It may be particularly useful when creating an overall plan for a process or processes. For instance, within maintenance or work planning there may be a known task that needs to be done which is planned to require a 'chargehand pipe fitter'. There may be several such labor resources available and so the need to identify which will be used is not necessary at the planning stage.
/// 
/// At a later stage, individual actors can be determined for the labor resources. This is achieved through specifiying the actor through IfcActor. The actor is then identified as the labour resource occurrence through the IfcRelAssignsToResource.RelatedResource attribute. The IfcLaborResource provides the IfcRelAssignsToResource.RelatingResource attribute. 
/// 
/// Use definitions for composition, assignment, constraints, time series, and baselines are described at the base type IfcConstructionResource.
/// 
/// Type use definition
/// IfcLaborResource defines the occurrence of any labor resource; common information about labor resource types is handled by IfcLaborResourceType.  The IfcLaborResourceType (if present) may establish the common type name, common properties, common productivities for various task types using IfcRelAssignsToProcess.  The IfcLaborResourceType is attached using the IfcRelDefinesByType.RelatingType objectified relationship and is accessible by the inverse IsTypedBy attribute.
/// 
/// Quantity use definition
/// The quantities relating to the IfcLaborResource are defined by IfcElementQuantity and attached by the IfcRelDefinesByProperties relationship. It is accessible by the inverse IsDefinedBy relationship. The following base quantities are defined and should be exchanged with the IfcElementQuantity.Name = 'BaseQuantities'. Other quantities can be defined being subjected to local standard of measurement with another string value assigned to Name and a value provided for MethodOfMeasurement.
/// 
/// Qto_LaborResourceBaseQuantities: base quantities for all labor resources.
/// 
/// Assignment use definition
/// In addition to assignments specified at the base class IfcConstructionResource, a labor resource may have assignments of its own using IfcRelAssignsToResource where RelatingResource refers to the IfcLaborResource and RelatedObjects contains one or more IfcActor subtypes as shown in Figure 194.  Such relationship indicates the specific people used as input for the resource.  Such actors are nested according to organizational structure with the root organization assigned to the IfcProject.  The IfcActor entity is used to represent the people or organizations.
/// 
/// Figure 194 — Labor resource assignment use
class IfcLaborResource : public IfcConstructionResource {
public:
    /// Whether the optional attribute SkillSet is defined for this IfcLaborResource
    bool hasSkillSet() const;
    std::string SkillSet() const;
    void setSkillSet(std::string v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_STRING; } return IfcConstructionResource::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcText; } return IfcConstructionResource::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "SkillSet"; } return IfcConstructionResource::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcLaborResource (IfcAbstractEntity* e);
    IfcLaborResource (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, boost::optional< std::string > v6_ResourceIdentifier, boost::optional< std::string > v7_ResourceGroup, boost::optional< IfcResourceConsumptionEnum::IfcResourceConsumptionEnum > v8_ResourceConsumption, IfcMeasureWithUnit* v9_BaseQuantity, boost::optional< std::string > v10_SkillSet);
    typedef IfcTemplatedEntityList< IfcLaborResource > list;
};
/// The flow terminal type IfcLampType defines commonly shared information for occurrences of lamps.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a lamp specification (i.e. the specific product information, that is common to all occurrences of that product type).  Lamp types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcLampType are represented by instances of IfcLamp. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcFlowTerminalType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_ElectricalDeviceCommon 
/// Pset_LampTypeCommon 
/// 
/// Material Use Definition 
/// The material of the IfcLampType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Bulb': Material from which the bulb is constructed (e.g. glass). 
/// 'Conductor': Material from which the conductor is constructed. 
/// 'Filament': Material from which the filament is constructed. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcLampType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcLamp for standard port definitions.
class IfcLampType : public IfcFlowTerminalType {
public:
    /// Identifies the predefined types of lamp from which the type required may be set.
    IfcLampTypeEnum::IfcLampTypeEnum PredefinedType() const;
    void setPredefinedType(IfcLampTypeEnum::IfcLampTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcFlowTerminalType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcLampTypeEnum; } return IfcFlowTerminalType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcFlowTerminalType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcLampType (IfcAbstractEntity* e);
    IfcLampType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcLampTypeEnum::IfcLampTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcLampType > list;
};
/// The flow terminal type IfcLightFixtureType defines commonly shared information for occurrences of light fixtures.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a light fixture specification (i.e. the specific product information, that is common to all occurrences of that product type).  Light Fixture types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcLightFixtureType are represented by instances of IfcLightFixture. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcFlowTerminalType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_ElectricalDeviceCommon 
/// Pset_LightFixtureTypeCommon 
/// Pset_LightFixtureTypeThermal 
/// 
/// The following property set definitions are applicable to this entity according to the PredefinedType attribute:  
/// Pset_LightFixtureTypeSecurityLighting (SECURITYLIGHTING) 
/// 
/// Material Use Definition 
/// The material of the IfcLightFixtureType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Casing': Material from which the casing is constructed. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcLightFixtureType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcLightFixture for standard port definitions.
class IfcLightFixtureType : public IfcFlowTerminalType {
public:
    /// Identifies the predefined types of light fixture from which the type required may be set.
    IfcLightFixtureTypeEnum::IfcLightFixtureTypeEnum PredefinedType() const;
    void setPredefinedType(IfcLightFixtureTypeEnum::IfcLightFixtureTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcFlowTerminalType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcLightFixtureTypeEnum; } return IfcFlowTerminalType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcFlowTerminalType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcLightFixtureType (IfcAbstractEntity* e);
    IfcLightFixtureType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcLightFixtureTypeEnum::IfcLightFixtureTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcLightFixtureType > list;
};

class IfcLinearDimension : public IfcDimensionCurveDirectedCallout {
public:
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcDimensionCurveDirectedCallout::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcDimensionCurveDirectedCallout::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcDimensionCurveDirectedCallout::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcLinearDimension (IfcAbstractEntity* e);
    IfcLinearDimension (IfcEntityList::ptr v1_Contents);
    typedef IfcTemplatedEntityList< IfcLinearDimension > list;
};
/// Definition from IAI: Fasteners connecting building elements mechanically.  A single instance of this class may represent one or many of actual mechanical fasteners, for example an array of bolts or a row of nails.
/// 
/// HISTORY New entity in IFC Release 2x2
/// 
/// IFC 2x4 change:
/// Supertype changed from IfcFastener to IfcElementComponent.
/// Attribute PredefinedType added.
/// Attributes NominalDiameter and NominalLength moved to IfcMechanicalFastenerType.
/// 
/// Geometry Use Definition
/// 
/// See definitions at the supertype IfcElementComponent.
/// 
/// In addition, a symbolic representation is defined for a row of fasteners or several rows of
/// fasteners within a single instance of IfcMechanicalFastener.  Such rows or arrays may
/// contain possibly large numbers of individual pieces.  The product definition shape consists of
/// an IfcShapeRepresentation with the attribute values
/// 
/// RepresentationIdentifier : 'Row'
///   RepresentationType : 'GeometricCurveSet'
/// 
/// and one or several curves as geometric items.  The curves represent where the heads of the fasteners
/// are located.  The local placement of the IfcMechanicalFastener shall be located and oriented such
/// that the local z axis is parallel with the axes of the fasteners (bolts, nails, staples or similar).
/// 
/// In case of such a symbolic 'Row' representation, an IfcElementQuantity should be attached to
/// the IfcMechanicalFastener via IfcRelDefinesByProperties.  The quantity should contain an
/// IfcQuantityCount named 'Count' with the number of fasteners and an IfcQuantityLength
/// named 'Spacing' which expresses the center-to-center distances of fasteners.
class IfcMechanicalFastener : public IfcFastener {
public:
    /// Whether the optional attribute NominalDiameter is defined for this IfcMechanicalFastener
    bool hasNominalDiameter() const;
    double NominalDiameter() const;
    void setNominalDiameter(double v);
    /// Whether the optional attribute NominalLength is defined for this IfcMechanicalFastener
    bool hasNominalLength() const;
    double NominalLength() const;
    void setNominalLength(double v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_DOUBLE; case 9: return IfcUtil::Argument_DOUBLE; } return IfcFastener::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcPositiveLengthMeasure; case 9: return Type::IfcPositiveLengthMeasure; } return IfcFastener::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "NominalDiameter"; case 9: return "NominalLength"; } return IfcFastener::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcMechanicalFastener (IfcAbstractEntity* e);
    IfcMechanicalFastener (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< double > v9_NominalDiameter, boost::optional< double > v10_NominalLength);
    typedef IfcTemplatedEntityList< IfcMechanicalFastener > list;
};
/// Definition from IAI: The element type (IfcMechanicalFastenerType) defines a list of commonly shared property set definitions of a fastener and an optional set of product representations. It is used to define mechanical fasteners mainly within structural and building services domains (i.e. the specific type information common to all occurrences of that type). 
/// 
/// The occurrences of the IfcMechanicalFastenerType are represented by instances of IfcMechanicalFastener. 
/// 
/// HISTORY New entity in IFC Release 2x2
/// 
/// IFC 2x4 change:
/// Supertype changed from IfcFastenerType to IfcElementComponentType.
/// Attributes PredefinedType, NominalDiameter, NominalLength added.
/// 
/// Mechanical fasteners, especially bolts, are often standardized.  To refer to a formal fastener
/// designation according to a standard (a product norm), IfcRelAssociatesClassification together
/// with IfcClassificationReference should be used.
/// 
/// IfcClassificationReference.ItemReference
/// contains a machine-readable form of the formal fastener designation from the norm.
/// Example: 'M16X80-10.9-HV' for a high-strength structural bolting assembly for preloading with
/// hexagon bolt and nut.  (On the other hand, IfcMechanicalFastenerType.Name contains a
/// displayable name which may not necessarily be the same as the formal designation.)
/// IfcClassificationReference.Name carries the short name of the fastener norm.
/// Example: 'EN 14399-4' as the respective European standard for high-strength hexagon bolts.
/// Optionally, the norm can be further described by
/// IfcClassificationReference.ReferencedSource, including information like publisher and
/// date of issue of the norm.
/// 
/// Furthermore, IfcRelAssociatesLibrary together with IfcLibraryReference may be
/// used to refer to a library which contains fastener definitions.
/// 
/// Property Set Use Definition
/// 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.
/// 
/// The following property set definitions are applicable to this entity according to the PredefinedType attribute:
/// 
/// Pset_MechanicalFastenerBolt (BOLT)
class IfcMechanicalFastenerType : public IfcFastenerType {
public:
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcFastenerType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcFastenerType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcFastenerType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcMechanicalFastenerType (IfcAbstractEntity* e);
    IfcMechanicalFastenerType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType);
    typedef IfcTemplatedEntityList< IfcMechanicalFastenerType > list;
};
/// Definition from IAI: The element type
/// IfcMemberType defines commonly shared information for
/// occurrences of members. Members are predominately linear building
/// elements, often forming part of a structural system. The
/// orientation of the member (being horizontal, vertical or sloped)
/// is not relevant to its definition (in contrary to beam and
/// column). The set of shared information may include:
/// 
/// common properties within shared property sets
/// common material information
/// common profile definitions
/// common shape representations
/// 
/// It is used to define a member specification, or member style
/// (i.e. the specific product information that is common to all
/// occurrences of that member type). Member types may be exchanged
/// without being already assigned to occurrences.
/// Occurrences of the IfcMemberType within building models
/// are represented by instances of IfcMemberStandardCase if
/// the IfcMemberType has a single associated
/// IfcMaterialProfileSet; otherwise they are represented by
/// instances of IfcMember. Occurrences of the
/// IfcMemberType within structural analysis models are
/// represented by instances of IfcStructuralCurveMember, or
/// its applicable subtypes.
/// HISTORY New entity in
/// Release IFC2x2 Addendum 1.
/// Material Use Definition
/// The material of the IfcMemberType is defined by the
/// IfcMaterialProfileSet or as fall back by
/// IfcMaterial and attached by the
/// IfcRelAssociatesMaterial.RelatingMaterial. It is
/// accessible by the inverse HasAssociations
/// relationship.
/// Note: It is illegal to assign an
/// IfcMaterial to an IfcMemberType, if there is at
/// least one occurrences of IfcMemberStandardCase for this
/// type.
/// Property Set Use Definition:
/// The shared property sets relating to the IfcMemberType
/// are defined by the IfcPropertySet and are attached by the
/// HasPropertySets attribute. The following property set
/// definitions specific to the IfcMemberType are part of this
/// IFC release:
/// NOTE There is no differentiation between
/// properties within the property set that are only assignable to
/// IfcMemberType and those that are only assignable to
/// IfcMember. If the same property is assigned to the
/// IfcMemberType and the IfcMember being an occurrence
/// of the IfcMemberType, then the occurrence property
/// overrides the type property.
/// 
/// Pset_MemberCommon: common property set for all
/// member types.
/// 
/// Profile Use Definition:
/// The shared profile definition is defined by assigning an
/// IfcMaterialProfileSet (see material use definition above).
/// The IfcMaterialProfile refers to the subtype of
/// IfcProfileDef that is the common profile for all member
/// occurrence, if used. It is only applicable if the
/// IfcMemberType has only occurrences of type
/// IfcMemberStandardCase (see definition of
/// IfcMemberStandardCase for further information).
/// NOTE The attribute ProfileName of the
/// IfcProfileDef subtype, referenced in
/// IfcMaterialProfile should contain a standardized profile
/// name according to local standards. However, an additional
/// geometric representation of the profile is necessary (e.g. as
/// IfcExtrudedAreaSolid). An importing application is allowed
/// to check for the existence of the profile name: in case of
/// identifying it as a standardized name, the corresponding profile
/// geometry and possibly other cross sectional properties can be
/// read from a library. Otherwise the geometric representation and
/// possible non geometric IfcProfileProperties have to be
/// used.
/// Geometry Use Definition:
/// The IfcMemberType may define the shared geometric
/// representation for all member occurrences. The
/// RepresentationMaps attribute refers to a list of
/// IfcRepresentationMap's, that allow for multiple geometric
/// representations (e.g. with IfcShaperepresentation's having
/// an RepresentationIdentifier 'Box', 'Axis', or 'Body'). It
/// is only applicable if the IfcMemberType has only
/// occurrences of type IfcMember (See geometric use
/// definition of IfcMember for further information).
/// NOTE If the IfcMemberType has an
/// associated IfcMaterialProfileSet, then no shared geometric
/// representation shall be provided.
/// NOTE The product shape representations are
/// defined as RepresentationMaps (attribute of the supertype
/// IfcTypeProduct), which get assigned by an element
/// occurrence instance through the
/// IfcShapeRepresentation.Item[n] being an
/// IfcMappedItem. See IfcTypeProduct for further
/// information.
/// NOTE The values of attributes
/// RepresentationIdentifier and RepresentationType of
/// IfcShapeRepresentation are restricted in the same way as
/// those for IfcMember and
/// IfcMemberStandardCase
class IfcMemberType : public IfcBuildingElementType {
public:
    /// Identifies the predefined types of a linear structural member element from which the type required may be set.
    IfcMemberTypeEnum::IfcMemberTypeEnum PredefinedType() const;
    void setPredefinedType(IfcMemberTypeEnum::IfcMemberTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcBuildingElementType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcMemberTypeEnum; } return IfcBuildingElementType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcBuildingElementType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcMemberType (IfcAbstractEntity* e);
    IfcMemberType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcMemberTypeEnum::IfcMemberTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcMemberType > list;
};
/// The energy conversion device type IfcMotorConnectionType defines commonly shared information for occurrences of motor connections.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a motor connection specification (i.e. the specific product information, that is common to all occurrences of that product type).  Motor Connection types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcMotorConnectionType are represented by instances of IfcMotorConnection. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcEnergyConversionDeviceType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_ElectricalDeviceCommon 
/// Pset_MotorConnectionTypeCommon 
/// 
/// Material Use Definition 
/// The material of the IfcMotorConnectionType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Casing': Material from which the casing is constructed. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcMotorConnectionType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcMotorConnection for standard port definitions.
class IfcMotorConnectionType : public IfcEnergyConversionDeviceType {
public:
    /// Identifies the predefined types of motor connection from which the type required may be set.
    IfcMotorConnectionTypeEnum::IfcMotorConnectionTypeEnum PredefinedType() const;
    void setPredefinedType(IfcMotorConnectionTypeEnum::IfcMotorConnectionTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcEnergyConversionDeviceType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcMotorConnectionTypeEnum; } return IfcEnergyConversionDeviceType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcEnergyConversionDeviceType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcMotorConnectionType (IfcAbstractEntity* e);
    IfcMotorConnectionType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcMotorConnectionTypeEnum::IfcMotorConnectionTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcMotorConnectionType > list;
};

class IfcMove : public IfcTask {
public:
    IfcSpatialStructureElement* MoveFrom() const;
    void setMoveFrom(IfcSpatialStructureElement* v);
    IfcSpatialStructureElement* MoveTo() const;
    void setMoveTo(IfcSpatialStructureElement* v);
    /// Whether the optional attribute PunchList is defined for this IfcMove
    bool hasPunchList() const;
    std::vector< std::string > /*[1:?]*/ PunchList() const;
    void setPunchList(std::vector< std::string > /*[1:?]*/ v);
    virtual unsigned int getArgumentCount() const { return 13; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 10: return IfcUtil::Argument_ENTITY_INSTANCE; case 11: return IfcUtil::Argument_ENTITY_INSTANCE; case 12: return IfcUtil::Argument_AGGREGATE_OF_STRING; } return IfcTask::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 10: return Type::IfcSpatialStructureElement; case 11: return Type::IfcSpatialStructureElement; case 12: return Type::IfcText; } return IfcTask::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 10: return "MoveFrom"; case 11: return "MoveTo"; case 12: return "PunchList"; } return IfcTask::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcMove (IfcAbstractEntity* e);
    IfcMove (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, std::string v6_TaskId, boost::optional< std::string > v7_Status, boost::optional< std::string > v8_WorkMethod, bool v9_IsMilestone, boost::optional< int > v10_Priority, IfcSpatialStructureElement* v11_MoveFrom, IfcSpatialStructureElement* v12_MoveTo, boost::optional< std::vector< std::string > /*[1:?]*/ > v13_PunchList);
    typedef IfcTemplatedEntityList< IfcMove > list;
};
/// An occupant is a type of actor that defines the form of occupancy of a property. 
/// 
/// The principal purpose of IfcOccupant is to determine the nature of occupancy of a property for a particular actor. All characteristics relating to the actor (name and organization details) are inherited from the IfcActor class.HISTORY: New entity in IFC2x 
/// 
/// Assignment Use Definition 
///   The IfcOccupant may have assignments of its own using the IfcRelAssignsToActor relationship where RelatingActor refers to the IfcOccupant and RelatedObjects contains one or more objects of the following types:  
/// IfcSpatialStructureElement: Indicates the property to be occupied. Particular details of the agreement relating to the occupancy of a property are dealt within the Pset_PropertyAgreement that is defined for the instance of IfcSpatialStructureElement. This means that an occupant may be related to a site, building, building storey or space through the IfcSpatialStructureElement.ElementComposition attribute. For instance, if the property concerned is several office spaces on a building storey, it might be appropriate to reference IfcBuildingStorey.ElementComposition=PARTIAL.  Occupants of a property may be considered to be the parties to an agreement. The roles that the occupant may play in respect to an agreement are defined in the IfcOccupantTypeEnum enumeration. If the role is not specified by the predefined contents of this enumeration, the value USERDEFINED may be set and the ObjectType attribute asserted.
class IfcOccupant : public IfcActor {
public:
    /// Predefined occupant types from which that required may be set.
    /// 
    /// IFC2x4 CHANGE Attribute made optional.
    IfcOccupantTypeEnum::IfcOccupantTypeEnum PredefinedType() const;
    void setPredefinedType(IfcOccupantTypeEnum::IfcOccupantTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 7; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 6: return IfcUtil::Argument_ENUMERATION; } return IfcActor::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 6: return Type::IfcOccupantTypeEnum; } return IfcActor::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 6: return "PredefinedType"; } return IfcActor::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcOccupant (IfcAbstractEntity* e);
    IfcOccupant (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcActorSelect* v6_TheActor, IfcOccupantTypeEnum::IfcOccupantTypeEnum v7_PredefinedType);
    typedef IfcTemplatedEntityList< IfcOccupant > list;
};
/// The opening element stands for
/// opening, recess or chase, all reflecting voids. It represents a
/// void within any element that has physical manifestation. Openings
/// can be inserted into walls, slabs, beams, columns, or other
/// elements.
/// The IFC specification provides two entities for opening
/// elements:
/// 
/// IfcOpeningStandardCase is used for all openings that
/// have a constant profile along a linear extrusion. They are placed
/// relative to the voided elements and the extrusion direction is
/// perpendicular to the plane of the element (horizontally for
/// walls, vertically for slabs). Only a single extrusion body is
/// allowed. It cuts through the whole thickness of the voided
/// element, i.e. it reflects a true opening.
/// IfcOpeningElement is used for all other occurrences of
/// openings and in particular also for niches or recesses.
/// 
/// NOTE View definitions or implementer
/// agreements may restrict the types of elements which can be voided
/// by an IfcOpeningElement or
/// IfcOpeningStandardCase
/// There are two different types of opening elements:
/// 
/// an opening, where the thickness of the opening is greater or
/// equal to the thickness of the element;
/// a recess or niche, where the thickness of the recess is
/// smaller than the thickness of the element.
/// 
/// The attribute PredefinedType should be used to capture
/// the differences,
/// 
/// the attribute is set to OPENING for an opening or
/// the attribute is set to RECESS for a recess or niche.
/// If the value for PredefinedType is omitted, or the
/// value is set to NOTDEFINED, no specific information of whether it
/// is an opening or recess shall be assumed.
/// 
/// NOTE Until IFC2x3 the information had been
/// provided by the inherited attribute
/// ObjectType.
/// An IfcOpeningElement has to be inserted into an
/// IfcElement by using the IfcRelVoidsElement
/// relationship. The relationship implies a Boolean subtraction
/// operation between the volume of the voided element and the volume
/// of the opening. It may be filled by an IfcDoor,
/// IfcWindow, or another filling element by using the
/// relationship IfcRelFillsElements.
/// HISTORY New entity in
/// IFC Release 1.0
/// IFC2x CHANGE The intermediate
/// ABSTRACT supertypes IfcFeatureElement and
/// IfcFeatureSubtraction have been added.
/// IFC2x4 CHANGE The attribute
/// PredefinedType has been added at the end of attribute
/// list.
/// Property Set Use Definition:
/// The property sets relating to the IfcOpeningElement are
/// defined by the IfcPropertySet and attached by the
/// IfcRelDefinesByProperties relationship. It is accessible
/// by the inverse IsDefinedBy relationship. The following
/// property set definitions specific to the IfcOpeningElement
/// are part of this IFC release:
/// 
/// Pset_OpeningElementCommon: common property
/// set for all opening occurrences
/// 
/// Quantity Use Definition:
/// The quantities relating to the IfcOpeningElement are
/// defined by the IfcElementQuantity and attached by the
/// IfcRelDefinesByProperties relationship. It is accessible
/// by the inverse IsDefinedBy relationship. The following
/// base quantities are defined and should be exchanged with the
/// IfcElementQuantity.Name = 'BaseQuantities'. Other
/// quantities, being subjected to local standard of measurement, can
/// be defined with another string value assigned to Name. In
/// this case a valid value for MethodOfMeasurement has to be
/// provided.
/// 
/// Qto_OpeningElementBaseQuantities: base
/// quantities for all opening occurrences.
/// 
/// Containment Use Definition
/// The IfcOpeningElement shall not participate in the
/// containment relationship, i.e. it is not linked directly to the
/// spatial structure of the project. It has a mandatory
/// VoidsElements inverse relationship pointing to the
/// IfcElement that is contained in the spatial structure.
/// 
/// The inverse relationship ContainedInStructure shall be
/// NIL.
/// 
/// NOTE See IfcRelVoidsElement for a
/// diagram on how to apply spatial containment and the voiding
/// relationship.
/// Geometry Use Definitions
/// The geometric representation of IfcOpeningElement is
/// given by the IfcProductDefinitionShape and
/// IfcLocalPlacement allowing multiple geometric
/// representations.
/// Local Placement
/// The local placement for IfcOpeningElement is defined in
/// its supertype IfcProduct. It is defined by the
/// IfcLocalPlacement, which defines the local coordinate
/// system that is referenced by all geometric representations.
/// 
/// The PlacementRelTo relationship of
/// IfcLocalPlacement should point to the local placement of
/// the same element, which is voided by the opening, i.e. referred
/// to by VoidsElement.RelatingBuildingElement.
/// 
/// Geometric Representation
/// Currently, the 'Body', and 'Box' representations are
/// supported. The 'Box' representation includes the representation
/// type 'BoundingBox' and is explained at
/// IfcFeatureElement.
/// Body Representation
/// The 'Body' representation of IfcOpeningElement can be
/// represented using the representation types 'SweptSolid', and
/// 'Brep'. The representation type 'Brep' is explained at
/// IfcFeatureElement
/// Swept Solid Representation Type with Horizontal
/// Extrusion
/// The 'SweptSolid' geometric representation of
/// IfcOpeningElement, using horizontal extrusion direction
/// (for walls), is defined using the swept area solid geometry. The
/// following attribute values for the IfcShapeRepresentation
/// holding this geometric representation shall be used:
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'SweptSolid'
/// 
/// The following additional constraints apply to the swept solid
/// representation:
/// 
/// Solid: IfcExtrudedAreaSolid is required, the
/// set of IfcShapeRepresentation.Items may include a single,
/// or multiple, instances of IfcExtrudedAreaSolid.
/// Profile: IfcRectangleProfileDef,
/// IfcCircleProfileDef and
/// IfcArbitraryClosedProfileDef shall be supported.
/// Extrusion: The profile shall be extruded horizontally
/// (i.e. perpendicular to the extrusion direction of the voided
/// element), e.g. for wall openings, or vertically (i.e. in the
/// extrusion direction of the voided element), e.g., for floor
/// openings. If multiple instances of IfcExtrudedAreaSolid
/// are used, the extrusion direction of each extrusion should be
/// equal.
/// 
/// NOTE In case of non-parallel jambs, the shape
/// representation shall be a 'SweptSolid' representation with
/// vertical extrusion.
/// 
/// Figure 34 illustrates an opening with horizontal extrusion.
/// NOTE  The local placement directions for the IfcOpeningElement are only given as an example, other directions are valid as well.
/// 
/// Figure 34 — Opening with full extrusion
/// 
/// Figure 35 illustrates an opening for a recess.
/// NOTE  The local placement directions for the IfcOpeningElement are only given as an example, other directions are valid as well.
/// NOTE  Rectangles are now defined centric, the placement
/// location has to be set:
/// 
/// IfcCartesianPoint(XDim/2,YDim/2)
/// 
/// Figure 35 — Opening with recess extrusion
/// 
/// Swept Solid Representation with Vertical Extrusion
/// The 'SweptSolid' geometric representation of
/// IfcOpeningElement, using vertical extrusion direction (for
/// walls), is defined using the swept area solid geometry, however
/// the extrusion direction may be vertical, i.e. in case of a wall
/// opening, the extrusion would be in the direction of the wall
/// height. The following attribute values for the
/// IfcShapeRepresentation holding this geometric
/// representation shall be used:
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'SweptSolid'
/// 
/// The following additional constraints apply to the swept solid
/// representation:
/// 
/// Solid: IfcExtrudedAreaSolid is required, the
/// set of IfcShapeRepresentation.Items may include a single,
/// or multiple, instances of IfcExtrudedAreaSolid.
/// Profile: IfcRectangleProfileDef,
/// IfcCircleProfileDef and
/// IfcArbitraryClosedProfileDef shall be supported.
/// Extrusion: The profile shall be extruded vertically,
/// i.e. for wall openings along the extrusion direction of the
/// voided element.ÿ If multiple instances of
/// IfcExtrudedAreaSolid are used, the extrusion direction
/// should be equal.
/// 
/// Vertical extrusions shall be used when an opening or recess
/// has a non rectangular foot print geometry that does not change
/// along the height of the opening or recess.
/// Figure 36 shows a vertical extrusion with multiple extrusion bodies for the opening. Each extrusion body has a different extrusion lenght.
/// NOTE  The local placement directions for the IfcOpeningElement are only given as an example, other directions are valid as well.
/// 
/// Figure 36 — Opening with multiple extrusions
class IfcOpeningElement : public IfcFeatureElementSubtraction {
public:
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcFeatureElementSubtraction::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcFeatureElementSubtraction::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcFeatureElementSubtraction::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcRelFillsElement >::ptr HasFillings() const; // INVERSE IfcRelFillsElement::RelatingOpeningElement
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcOpeningElement (IfcAbstractEntity* e);
    IfcOpeningElement (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag);
    typedef IfcTemplatedEntityList< IfcOpeningElement > list;
};

class IfcOrderAction : public IfcTask {
public:
    std::string ActionID() const;
    void setActionID(std::string v);
    virtual unsigned int getArgumentCount() const { return 11; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 10: return IfcUtil::Argument_STRING; } return IfcTask::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 10: return Type::IfcIdentifier; } return IfcTask::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 10: return "ActionID"; } return IfcTask::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcOrderAction (IfcAbstractEntity* e);
    IfcOrderAction (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, std::string v6_TaskId, boost::optional< std::string > v7_Status, boost::optional< std::string > v8_WorkMethod, bool v9_IsMilestone, boost::optional< int > v10_Priority, std::string v11_ActionID);
    typedef IfcTemplatedEntityList< IfcOrderAction > list;
};
/// The flow terminal type IfcOutletType defines commonly shared information for occurrences of outlets.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a outlet specification (i.e. the specific product information, that is common to all occurrences of that product type).  Outlet types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcOutletType are represented by instances of IfcOutlet. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcFlowTerminalType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_ElectricalDeviceCommon 
/// Pset_OutletTypeCommon 
/// 
/// Material Use Definition 
/// The material of the IfcOutletType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Casing': Material from which the casing is constructed. 
/// 'Conductor': Material from which the conductors are constructed. 
/// 'Surface': Material from which the outlet plate is constructed. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcOutletType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcOutlet for standard port definitions.
class IfcOutletType : public IfcFlowTerminalType {
public:
    /// Identifies the predefined types of outlet from which the type required may be set.
    IfcOutletTypeEnum::IfcOutletTypeEnum PredefinedType() const;
    void setPredefinedType(IfcOutletTypeEnum::IfcOutletTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcFlowTerminalType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcOutletTypeEnum; } return IfcFlowTerminalType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcFlowTerminalType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcOutletType (IfcAbstractEntity* e);
    IfcOutletType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcOutletTypeEnum::IfcOutletTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcOutletType > list;
};
/// IfcPerformanceHistory is used to document the actual performance of an occurrence instance over time. In practice, performance-related data are generally not easy to obtain as they can originate from different sources (predicted, simulated, or measured) and occur during different stages of the building life-cycle. Such time-related data cover a large spectrum, including meteorological data, schedules, operational status measurements, trend reports, etc.
/// 
/// IfcPerformanceHistory is assigned to other objects (represented by subtypes of IfcObjectDefinition, excluding subtypes of IfcControl), by the objectified relationship IfcRelAssignsToControl.
/// 
/// HISTORY: New entity in Release IFC2x Edition 2.
class IfcPerformanceHistory : public IfcControl {
public:
    /// Describes the applicable building life-cycle phase. Typical values should be DESIGNDEVELOPMENT, SCHEMATICDEVELOPMENT, CONSTRUCTIONDOCUMENT, CONSTRUCTION, ASBUILT, COMMISSIONING, OPERATION, etc.
    std::string LifeCyclePhase() const;
    void setLifeCyclePhase(std::string v);
    virtual unsigned int getArgumentCount() const { return 6; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 5: return IfcUtil::Argument_STRING; } return IfcControl::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 5: return Type::IfcLabel; } return IfcControl::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 5: return "LifeCyclePhase"; } return IfcControl::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPerformanceHistory (IfcAbstractEntity* e);
    IfcPerformanceHistory (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, std::string v6_LifeCyclePhase);
    typedef IfcTemplatedEntityList< IfcPerformanceHistory > list;
};
/// A permit is a permission to perform work in places and on artifacts where regulatory, security or other access restrictions apply. 
/// 
/// HISTORY New entity in IFC2x2 
/// IFC2x4 CHANGE  PermitID renamed to Identification and promoted to supertype IfcControl, Attributes PredefinedType, Status, and LongDescription added.
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the IfcRelDefinesByProperties relationship. They are accessible by the IsDefinedBy inverse attribute.  Refer to the documentation at the supertype IfcControl and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_Permit 
/// 
/// Declaration Use Definition 
/// The IfcPermit may be declared within the project using the IfcRelDeclares relationship where RelatingContext refers to the single IfcProject and RelatedDefinitions contains the IfcPermit.  Alternatively, if the IfcPermit is aggregated within an IfcWorkPlan, then it shall not have a direct declaration relationship (whereas the containing work plan may have a declaration relationship). 
/// 
/// Composition Use Definition 
/// The IfcPermit may be aggregated into components using IfcRelAggregates where RelatingObject refers to the enclosing IfcPermit and RelatedObjects contains one or more components.  Aggregation use is defined for the following predefined types:
/// 
/// ACCESS: May contain IfcWorkCalendar components.  A work calendar may indicate the time period of the permit and allowed times when work may be performed.  Such work calendar may have assigned resources indicating equipment or labor permitted at various times. 
/// WORK: May contain IfcWorkSchedule components.  A work schedule may indicate tasks and scheduled times where the work schedule type may designate whether tasks and/or times are planned or actual.  Such work schedule may have assigned tasks indicating detail, where tasks may be assigned to products and may have assigned resources. 
/// 
/// As shown in Figure 159, an IfcPermit may be nested into sub-items using IfcRelNests where RelatingObject refers to the enclosing IfcPermit and RelatedObjects contains one or more sub-items.  Nesting use is defined for the following predefined types:
/// 
/// (All Types): May contain IfcPermit sub-items.  A permit may be nested to indicate permit ammendments, in order of issue. 
/// 
/// Figure 159 — Permit composition
/// 
/// Assignment Use Definition 
/// As shown in Figure 160, an IfcPermit may be assigned to the following entities using relationships as indicated: 
/// 
/// IfcActor (IfcRelAssignsToActor): Organization issuing the permit such as a local government agency or security organization. 
/// 
/// The IfcPermit may have assignments of its own using the IfcRelAssignsToControl relationship where RelatingControl refers to the IfcPermit and RelatedObjects contains one or more objects of the following types:  
/// IfcActor: Organization(s) bound to the permit, typically a single contractor.
/// 
/// Figure 160 — Permit assignment
/// 
/// Approval Use Definition 
/// Approvals may be associated to indicate the status of acceptance or rejection using the IfcRelAssociatesApproval relationship where RelatingApproval refers to an IfcApproval and RelatedObjects contains the IfcPermit.  Approvals may be split into sub-approvals using IfcApprovalRelationship to track approval status separately for each party where RelatingApproval refers to the higher-level approval and RelatedApprovals contains one or more lower-level approvals.  The hierarchy of approvals implies sequencing such that a higher-level approval is not executed until all of its lower-level approvals have been accepted.
class IfcPermit : public IfcControl {
public:
    std::string PermitID() const;
    void setPermitID(std::string v);
    virtual unsigned int getArgumentCount() const { return 6; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 5: return IfcUtil::Argument_STRING; } return IfcControl::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 5: return Type::IfcIdentifier; } return IfcControl::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 5: return "PermitID"; } return IfcControl::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPermit (IfcAbstractEntity* e);
    IfcPermit (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, std::string v6_PermitID);
    typedef IfcTemplatedEntityList< IfcPermit > list;
};
/// The flow fitting type IfcPipeFittingType defines commonly shared information for occurrences of pipe fittings.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a pipe fitting specification (i.e. the specific product information, that is common to all occurrences of that product type).  Pipe Fitting types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcPipeFittingType are represented by instances of IfcPipeFitting. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcFlowFittingType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_PipeFittingTypeCommon 
/// 
/// Material Use Definition 
/// The material of the IfcPipeFittingType is defined by IfcMaterialProfileSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialProfileSet.MaterialProfiles[n].Name shall be used: 
/// 
/// 'Body': Material from which the pipe fitting is constructed. 
/// 'Coating': The outer coating, if applicable. 
/// 'Insulation': The insulating wrapping, if applicable. 
/// 'Lining': The inner lining, if applicable. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcPipeFittingType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcPipeFitting for standard port definitions.
class IfcPipeFittingType : public IfcFlowFittingType {
public:
    /// The type of pipe fitting.
    IfcPipeFittingTypeEnum::IfcPipeFittingTypeEnum PredefinedType() const;
    void setPredefinedType(IfcPipeFittingTypeEnum::IfcPipeFittingTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcFlowFittingType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcPipeFittingTypeEnum; } return IfcFlowFittingType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcFlowFittingType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPipeFittingType (IfcAbstractEntity* e);
    IfcPipeFittingType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcPipeFittingTypeEnum::IfcPipeFittingTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcPipeFittingType > list;
};
/// The flow segment type IfcPipeSegmentType defines commonly shared information for occurrences of pipe segments.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a pipe segment specification (i.e. the specific product information, that is common to all occurrences of that product type).  Pipe Segment types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcPipeSegmentType are represented by instances of IfcPipeSegment. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcFlowSegmentType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_PipeSegmentTypeCommon 
/// 
/// The following property set definitions are applicable to this entity according to the PredefinedType attribute:  
/// Pset_PipeSegmentTypeCulvert (CULVERT) 
/// Pset_PipeSegmentTypeGutter (GUTTER) 
/// 
/// Material Use Definition 
/// The material of the IfcPipeSegmentType is defined by IfcMaterialProfileSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialProfileSet.MaterialProfiles[n].Name shall be used: 
/// 
/// 'Body': Material from which the pipe segment is constructed. 
/// 'Coating': The outer coating, if applicable. 
/// 'Insulation': The insulating wrapping, if applicable. 
/// 'Lining': The inner lining, if applicable. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcPipeSegmentType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcPipeSegment for standard port definitions.
class IfcPipeSegmentType : public IfcFlowSegmentType {
public:
    /// The type of pipe segment.
    IfcPipeSegmentTypeEnum::IfcPipeSegmentTypeEnum PredefinedType() const;
    void setPredefinedType(IfcPipeSegmentTypeEnum::IfcPipeSegmentTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcFlowSegmentType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcPipeSegmentTypeEnum; } return IfcFlowSegmentType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcFlowSegmentType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPipeSegmentType (IfcAbstractEntity* e);
    IfcPipeSegmentType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcPipeSegmentTypeEnum::IfcPipeSegmentTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcPipeSegmentType > list;
};
/// The element type IfcPlateType defines commonly shared
/// information for occurrences of plates. The set of shared
/// information may include:
/// 
/// common properties within shared property sets
/// common material information
/// common material layer definitions
/// common shape representations
/// 
/// NOTE It is illegal to share shape
/// representations as representation maps for occurrences of
/// IfcPlateStandardCase.
/// 
/// It is used to define a plate specification (i.e. the specific
/// product information, that is common to all occurrences of that
/// product type). Plate types may be exchanged without being already
/// assigned to occurrences.
/// NOTE The product representations are defined as
/// representation maps (at the level of the supertype
/// IfcTypeProduct, which gets assigned by an element occurrence
/// instance through the IfcShapeRepresentation.Item[1] being an
/// IfcMappedItem.
/// The occurrences of the IfcPlateType within building
/// models are represented by instances of IfcPlateStandardCase
/// if the IfcPlateType has a single associated
/// IfcMaterialLayerSet; otherwise they are represented by
/// instances of IfcPlate.
/// 
/// HISTORY  New
/// entity in Release IFC2x2.
/// 
/// Informal proposition:
/// 
/// The material assignment, if provided using the
/// IfcRelAssociatesMaterial relationship, shall not reference
/// the IfcMaterialLayerSetUsage.
/// 
/// Material Use Definition
/// The material of the IfcPlateType is defined by the
/// IfcMaterialLayerSet or as fall back by IfcMaterial
/// and attached by the
/// IfcRelAssociatesMaterial.RelatingMaterial. It is
/// accessible by the inverse HasAssociations relationship.
/// Note: It is illegal to assign an
/// IfcMaterial to an IfcPlateType, if there is at least
/// one occurrences of IfcPlateStandardCase for this
/// type.
/// Layer Set Use Definition:
/// The shared material layer set definition is defined by assigning
/// an IfcMaterialLayerSet (see material use definition above).
/// The IfcMaterialLayer refers to one or several of
/// IfcMaterial that is the common for all plate occurrence, if
/// used. It is only applicable if the IfcPlateType has only
/// occurrences of type IfcPlateStandardCase (see definition of
/// IfcPlateStandardCase for further information).
/// NOTE Since each individual instance of
/// IfcPlateStandardCase defines its own
/// IfcMaterialLayerSetUsage including the offset from the
/// reference plane, the same IfcPlateType can be used
/// independently of the reference plane alignment of its
/// occurrences.
/// Property Set Use Definition:
/// The shared property sets relating to the IfcPlateType are
/// defined by the IfcPropertySet and are attached by the
/// HasPropertySets attribute. The following property set
/// definitions specific to the IfcWallType are part of this IFC
/// release:
/// NOTE There is no differentiation between
/// properties within the property set that are only assignable to
/// IfcPlateType and those that are only assignable to
/// IfcPlate. If the same property is assigned to the
/// IfcPlateType and the IfcPlate being an occurrence of
/// the IfcPlateType, then the occurrence property overrides the
/// type property.
/// 
/// Pset_PlateCommon: common property set for all
/// plate types.
class IfcPlateType : public IfcBuildingElementType {
public:
    /// Identifies the predefined types of a planar member element from which the type required may be set.
    IfcPlateTypeEnum::IfcPlateTypeEnum PredefinedType() const;
    void setPredefinedType(IfcPlateTypeEnum::IfcPlateTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcBuildingElementType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcPlateTypeEnum; } return IfcBuildingElementType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcBuildingElementType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPlateType (IfcAbstractEntity* e);
    IfcPlateType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcPlateTypeEnum::IfcPlateTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcPlateType > list;
};
/// Definition from ISO/CD 10303-42:1992: A polyline
///   is a bounded curve of n - 1 linear segments, defined by a
///   list of n points, P1, P2 ... Pn. 
///   The ith segment of the curve is parameterized as follows:
/// 
///    
///   for 1 ≤ i ≤ n - 1
/// 
/// where i - 1 ≤ u ≤ i and
///   with parametric range of 0 <≤ u ≤ n - 1.
/// 
/// NOTE  Corresponding ISO 10303 entity: polyline. Please refer to ISO/IS 10303-42:1994, p. 45 for the final definition of the formal standard.
/// 
/// HISTORY  New class in IFC Release 1.0
class IfcPolyline : public IfcBoundedCurve {
public:
    /// The points defining the polyline.
    IfcTemplatedEntityList< IfcCartesianPoint >::ptr Points() const;
    void setPoints(IfcTemplatedEntityList< IfcCartesianPoint >::ptr v);
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } return IfcBoundedCurve::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcCartesianPoint; } return IfcBoundedCurve::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Points"; } return IfcBoundedCurve::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPolyline (IfcAbstractEntity* e);
    IfcPolyline (IfcTemplatedEntityList< IfcCartesianPoint >::ptr v1_Points);
    typedef IfcTemplatedEntityList< IfcPolyline > list;
};
/// Definition from IAI: An IfcPort provides the
///   means for an element to connect to other elements.
/// 
/// An IfcPort is associated with an IfcElement,
///   it belongs to, through the objectified relationship
///   IfcRelConnectsPortToElement. Exactly two ports,
///   belonging to two different elements, are connected with
///   each other through the objectified relationship
///   IfcRelConnectsPorts.
/// 
/// An instance of IfcElement may have one or more
///   points at which it connects to other instances of
///   IfcElement. An instance of IfcPort is located
///   at a point where a connection can occur. The location of
///   the port is determined in the context of the local
///   coordinate system of the element to which it belongs.
/// 
/// HISTORY New entity in
///   Release IFC2x Edition 2.
/// 
/// Containment Use Definitions
/// 
/// As a subordinate part being fully dependent on the master
///   element the IfcPort shall have no
///   independent containment relationship to the spatial
///   structure.
/// 
/// Geometry Use Definition
/// 
/// The geometric representation of IfcPort is
///   given by the IfcProductDefinitionShape, allowing
///   multiple geometric representation.
/// 
/// Local Placement
/// 
/// The local placement for IfcPort is defined
///   in its supertype IfcProduct. It is defined by the
///   IfcLocalPlacement, which defines the local
///   coordinate system that is referenced by all geometric
///   representations.
/// 
/// The PlacementRelTo relationship of
///   IfcLocalPlacement shall point to the
///   local placement of the master IfcElement (its
///   relevant subtypes), which is associated to the
///   IfcPort by the relationship object
///   IfcRelConnectsPortToElement.
/// 
/// Shape Representation
/// 
/// The geometry use definitions for the shape representation
///   of the IfcPort is given at the level of
///   its subtypes.
class IfcPort : public IfcProduct {
public:
    virtual unsigned int getArgumentCount() const { return 7; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcProduct::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcProduct::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcProduct::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcRelConnectsPortToElement >::ptr ContainedIn() const; // INVERSE IfcRelConnectsPortToElement::RelatingPort
    IfcTemplatedEntityList< IfcRelConnectsPorts >::ptr ConnectedFrom() const; // INVERSE IfcRelConnectsPorts::RelatedPort
    IfcTemplatedEntityList< IfcRelConnectsPorts >::ptr ConnectedTo() const; // INVERSE IfcRelConnectsPorts::RelatingPort
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPort (IfcAbstractEntity* e);
    IfcPort (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation);
    typedef IfcTemplatedEntityList< IfcPort > list;
};
/// An IfcProcedure is a
///   logical set of actions to be taken in response to an event
///   or to cause an event to occur.
/// 
/// HISTORY  New entity in IFC2x2
/// 
/// IFC2x4 CHANGE  ProcedureType renamed to PredefinedType and made optional (upward compatible).  Where rules WR1 and WR2 have been removed.
/// 
/// Use definitions
/// 
/// IfcProcedure is used to capture information about
///   stepped processes such as calibration, start/stop
///   procedures for equipment items, designated actions to take
///   in the event of an emergency etc. A procedure is not a
///   task, but may describe a set of tasks and their order of
///   occurrence in response to or to cause an event.
/// 
/// Type use definition
/// 
/// IfcProcedure defines the anticipated or actual
///   occurrence of any procedure; common information about
///   procedure types is handled by IfcProcedureType. The
///   IfcProcedureType (if present) may establish the
///   common type name, usage (or predefined) type, common nested
///   procedures (using IfcRelNests), common set of
///   properties, and common product assignment using
///   IfcRelAssignsToProduct. The IfcProcedureType
///   is attached using the
///   IfcRelDefinesByType.RelatingType objectified
///   relationship and is accessible by the inverse
///   IsTypedBy attribute.
/// 
/// Property set use definition
/// 
/// The property sets relating to IfcProcedure are
///   defined by IfcPropertySet and attached by the
///   IfcRelDefinesByProperties relationship. They are
///   accessible by the inverse IsDefinedBy relationship.
///   Such property sets may define procedure parameters. No
///   property sets for IfcProcedure are currently defined
///   by IFC.
/// 
/// Connectivity use definition
/// 
/// The relationship IfcRelSequence is used to indicate
///   control flow. An IfcProcedure as a successor to an
///   IfcEvent indicates that the procedure should be
///   performed in response to the event. An IfcProcedure
///   as a predecessor to an IfcEvent indicates that the
///   event should be trigerred following the procedure. As
///   procedures have arbitrary duration, the
///   IfcRelSequence.SequenceType attribute has no effect
///   on an IfcProcedure but still applies to the opposite
///   end of the relationship if IfcTask is used.
/// 
/// Composition use definition
/// 
/// IfcProcedure may be contained within an
///   IfcTask or IfcProcedure using the
///   IfcRelNests relationship. An IfcProcedure may
///   in turn nest other IfcProcedure or IfcEvent
///   entities. Such nesting indicates decomposed level of
///   detail.
/// 
/// Note that a particular type of IfcProcedure is a
///   caution, warning or other form of advisory note. Typically,
///   it is anticipated that such a procedure would be assigned
///   to the specific IfcProcess for which it gives advice
///   using IfcRelAssignsToProcess.
/// 
/// Assignment use definition
/// 
/// An IfcProcedure may be assigned to an
///   IfcWorkCalendar to indicate times when such
///   procedure may be performed using
///   IfcRelAssignsToControl; otherwise the effective
///   calendar is determined by the nearest IfcProcess
///   ancestor with a calendar assigned. Advisory notes should be
///   assigned to the specific IfcProcess for which it
///   gives advice using IfcRelAssignsToProcess.
/// 
/// For building operation scenarios, IfcProcedure may
///   be assigned to a product (IfcElement subtype) using
///   IfcRelAssignsToProduct to indicate a specific
///   product occurrence that performs the procedure. For
///   example, an IfcActuator may have a "Close"
///   procedure. If the IfcProcedure is defined by an
///   IfcProcedureType and the IfcProcedureType is
///   assigned to a product type (using
///   IfcRelAssignsToProduct), then the
///   IfcProcedure must be assigned to one or more
///   occurrences of the specified product type using
///   IfcRelAssignsToProduct.
/// 
/// As shown in Figure 12, IfcProcedure does not restrict anything but
///   describes specific steps of how something should happen.
///   While a procedure does control/restrict in the sense of
///   indicating "this is how the task should be performed" by
///   nature of describing inner detail, this is not different than
///   parts of a product indicating "this is how the parts should
///   be assembled". Consequently, it doesn't restrict the outer
///   item as a whole but provides inner detail of the item.
/// 
/// Figure 12 — Procedure relationships
class IfcProcedure : public IfcProcess {
public:
    std::string ProcedureID() const;
    void setProcedureID(std::string v);
    IfcProcedureTypeEnum::IfcProcedureTypeEnum ProcedureType() const;
    void setProcedureType(IfcProcedureTypeEnum::IfcProcedureTypeEnum v);
    /// Whether the optional attribute UserDefinedProcedureType is defined for this IfcProcedure
    bool hasUserDefinedProcedureType() const;
    std::string UserDefinedProcedureType() const;
    void setUserDefinedProcedureType(std::string v);
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 5: return IfcUtil::Argument_STRING; case 6: return IfcUtil::Argument_ENUMERATION; case 7: return IfcUtil::Argument_STRING; } return IfcProcess::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 5: return Type::IfcIdentifier; case 6: return Type::IfcProcedureTypeEnum; case 7: return Type::IfcLabel; } return IfcProcess::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 5: return "ProcedureID"; case 6: return "ProcedureType"; case 7: return "UserDefinedProcedureType"; } return IfcProcess::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcProcedure (IfcAbstractEntity* e);
    IfcProcedure (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, std::string v6_ProcedureID, IfcProcedureTypeEnum::IfcProcedureTypeEnum v7_ProcedureType, boost::optional< std::string > v8_UserDefinedProcedureType);
    typedef IfcTemplatedEntityList< IfcProcedure > list;
};
/// A project order is a directive to purchase products and/or perform work, such as for construction or facilities management. 
/// 
/// Project orders are typically formal contracts between two organizations, where cost and time information may be rigid or flexible according to contained schedule types and constraints. 
/// 
/// HISTORY New entity in IFC 2.0 
/// IFC2x4 CHANGE Attribute 'ID' changed to Identification and promoted to supertype IfcControl.  Attribute 'LongDescription' added.
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the IfcRelDefinesByProperties relationship. They are accessible by the IsDefinedBy inverse attribute.  Refer to the documentation at the supertype IfcControl and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity according to the PredefinedType attribute:  
/// Pset_ProjectOrderChangeOrder (CHANGEORDER) 
/// Pset_ProjectOrderMaintenanceWorkOrder (MAINTENANCEWORKORDER) 
/// Pset_ProjectOrderMoveOrder (MOVEORDER) 
/// Pset_ProjectOrderPurchaseOrder (PURCHASEORDER) 
/// Pset_ProjectOrderWorkOrder (WORKORDER) 
/// 
/// Declaration Use Definition 
/// The IfcProjectOrder may be declared within the project using the IfcRelDeclares relationship where RelatingContext refers to the single IfcProject and RelatedDefinitions contains the IfcProjectOrder.  Alternatively, if the IfcProjectOrder is aggregated within an IfcWorkPlan, then it shall not have a direct declaration relationship (whereas the containing work plan may have a declaration relationship). 
/// 
/// Composition Use Definition 
/// As shown in Figure 160, an IfcProjectOrder may be aggregated into components using IfcRelAggregates where RelatingObject refers to the enclosing IfcProjectOrder and RelatedObjects contains one or more components.  Aggregation use is defined for the following predefined types:
/// 
/// (All Types): May contain IfcCostSchedule components.  A cost schedule may indicate costs and quantities where the cost schedule type may designate whether rates and/or quantities are estimated or final.  Such cost schedule may have assigned cost items indicating detail, where each cost item may have assigned products, processes, or resources. 
/// WORKORDER: May contain IfcWorkSchedule components.  A work schedule may indicate tasks and scheduled times where the work schedule type may designate whether tasks and/or times are planned or actual.  Such work schedule may have assigned tasks indicating detail, where tasks may be assigned to products and may have assigned resources. 
/// 
/// The IfcProjectOrder may be nested into sub-items using IfcRelNests where RelatingObject refers to the enclosing IfcProjectOrder and RelatedObjects contains one or more sub-items.  Nesting use is defined for the following predefined types:
/// 
/// WORKORDER: May contain IfcProjectOrder sub-items having PredefinedType CHANGEORDER.  A work order may be nested into change orders to indicate contract ammendment, in order of issue. 
/// 
/// Figure 161 — Project order composition
/// 
/// Assignment Use Definition 
/// As shown in Figure 161, an IfcProjectOrder may be assigned to the following entities using relationships as indicated: 
/// 
/// IfcActor (IfcRelAssignsToActor): Organization issuing the order such as an owner or contractor. 
/// 
/// The IfcProjectOrder may have assignments of its own using the IfcRelAssignsToControl relationship where RelatingControl refers to the IfcProjectOrder and RelatedObjects contains one or more objects of the following types:  
/// IfcActor: Organization(s) contracted to fulfill the order, typically a single contractor, subcontractor, or supplier.
/// 
/// Figure 162 — Project order assignment
/// 
/// Approval Use Definition 
/// Approvals may be associated to indicate the status of acceptance or rejection using the IfcRelAssociatesApproval relationship where RelatingApproval refers to an IfcApproval and RelatedObjects contains the IfcProjectOrder.  Approvals may be split into sub-approvals using IfcApprovalRelationship to track approval status separately for each party where RelatingApproval refers to the higher-level approval and RelatedApprovals contains one or more lower-level approvals.  The hierarchy of approvals implies sequencing such that a higher-level approval is not executed until all of its lower-level approvals have been accepted.
class IfcProjectOrder : public IfcControl {
public:
    std::string ID() const;
    void setID(std::string v);
    /// Predefined generic type for a project order that is specified in an enumeration. There may be a property set given specificly for the predefined types.
    /// 
    /// IFC2x4 CHANGE  The attribute has been made optional.
    IfcProjectOrderTypeEnum::IfcProjectOrderTypeEnum PredefinedType() const;
    void setPredefinedType(IfcProjectOrderTypeEnum::IfcProjectOrderTypeEnum v);
    /// Whether the optional attribute Status is defined for this IfcProjectOrder
    bool hasStatus() const;
    /// The current status of a project order.Examples of status values that might be used for a project order status include:
    /// 
    /// PLANNED
    /// REQUESTED
    /// APPROVED
    /// ISSUED
    /// STARTED
    /// DELAYED
    /// DONE
    std::string Status() const;
    void setStatus(std::string v);
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 5: return IfcUtil::Argument_STRING; case 6: return IfcUtil::Argument_ENUMERATION; case 7: return IfcUtil::Argument_STRING; } return IfcControl::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 5: return Type::IfcIdentifier; case 6: return Type::IfcProjectOrderTypeEnum; case 7: return Type::IfcLabel; } return IfcControl::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 5: return "ID"; case 6: return "PredefinedType"; case 7: return "Status"; } return IfcControl::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcProjectOrder (IfcAbstractEntity* e);
    IfcProjectOrder (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, std::string v6_ID, IfcProjectOrderTypeEnum::IfcProjectOrderTypeEnum v7_PredefinedType, boost::optional< std::string > v8_Status);
    typedef IfcTemplatedEntityList< IfcProjectOrder > list;
};

class IfcProjectOrderRecord : public IfcControl {
public:
    IfcTemplatedEntityList< IfcRelAssignsToProjectOrder >::ptr Records() const;
    void setRecords(IfcTemplatedEntityList< IfcRelAssignsToProjectOrder >::ptr v);
    IfcProjectOrderRecordTypeEnum::IfcProjectOrderRecordTypeEnum PredefinedType() const;
    void setPredefinedType(IfcProjectOrderRecordTypeEnum::IfcProjectOrderRecordTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 7; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 5: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 6: return IfcUtil::Argument_ENUMERATION; } return IfcControl::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 5: return Type::IfcRelAssignsToProjectOrder; case 6: return Type::IfcProjectOrderRecordTypeEnum; } return IfcControl::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 5: return "Records"; case 6: return "PredefinedType"; } return IfcControl::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcProjectOrderRecord (IfcAbstractEntity* e);
    IfcProjectOrderRecord (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcTemplatedEntityList< IfcRelAssignsToProjectOrder >::ptr v6_Records, IfcProjectOrderRecordTypeEnum::IfcProjectOrderRecordTypeEnum v7_PredefinedType);
    typedef IfcTemplatedEntityList< IfcProjectOrderRecord > list;
};
/// The projection element is a
/// specialization of the general feature element to represent
/// projections applied to building elements. It represents a solid
/// attached to any element that has physical manifestation.
/// EXAMPLE A wall projection such as a pilaster
/// strip is handled by
/// IfcProjectionElement
/// NOTE View definitions or implementer agreements
/// may restrict the types of elements to which
/// IfcProjectionElement can be applied.
/// An IfcProjectionElement has to be linked to a element
/// (all subtypes of IfcElement) by using the
/// IfcRelProjectsElement relationship. Its existence depends on
/// the existence of the master element. The relationship implies a
/// Boolean union operation between the volume of the projection
/// element and the volume of the element.
/// HISTORY New entity in IFC2x2.
/// IFC2x4 CHANGE The attribute PredefinedType has been added at the end of attribute
/// list.
/// The quantities relating to the IfcProjectionElement are
/// defined by the IfcElementQuantity and attached by the
/// IfcRelDefinesByProperties relationship. It is accessible by
/// the inverse IsDefinedBy relationship. The following base
/// quantities are defined and should be exchanged with the
/// IfcElementQuantity.Name = 'BaseQuantities'. Other
/// quantities, being subjected to local standard of measurement, can
/// be defined with another string value assigned to Name. In
/// this case a valid value for MethodOfMeasurement has to be
/// provided.
/// 
/// Qto_ProjectionElementBaseQuantities: base
/// quantities for all opening occurrences.
/// 
/// Containment Use Definition
/// The IfcProjectionElement shall not participate in the
/// containment relationship, i.e. it is not linked directly to the
/// spatial structure of the project. It has a mandatory
/// ProjectsElements inverse relationship pointing to the
/// IfcElement that is contained in the spatial structure.
/// 
/// The inverse relationship ContainedInStructure shall be
/// NIL.
/// 
/// Geometry Use Definition
/// The geometric representation of IfcProjectionElement is
/// given by the IfcProductDefinitionShape and
/// IfcLocalPlacement allowing multiple geometric
/// representations.
/// Local Placement
/// The local placement for IfcOpeningRecess is defined in
/// its supertype IfcProduct. It is defined by the
/// IfcLocalPlacement, which defines the local coordinate system
/// that is referenced by all geometric representations.
/// 
/// The PlacementRelTo relationship of
/// IfcLocalPlacement should point to the local placement of the
/// same element, to which the projection adds, i.e. referred to by
/// ProjectsElement.RelatingBuildingElement.
/// 
/// Swept Solid Representation
/// The geometric representation of IfcProjectionElement is
/// defined using the swept area solid geometry. The following
/// attribute values for the IfcShapeRepresentation holding this
/// geometric representation shall be used:
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'SweptSolid'
/// 
/// The following additional constraints apply to the swept solid
/// representation:
/// 
/// Solid: IfcExtrudedAreaSolid is required.
/// Profile: IfcRectangleProfileDef,
/// IfcCircleProfileDef and IfcArbitraryClosedProfileDef
/// shall be supported.
/// Extrusion: The profile shall be extruded horizontally
/// (that is, perpendicular to the extrusion direction of the modified
/// element), such as for wall projections, or vertically (that is, in the
/// extrusion direction of the projected element), such as for floor
/// projections.
/// 
/// As shown in Figure 38, the following interpretation of dimension parameter applies for
/// rectangular projection:
/// 
/// IfcRectangleProfileDef.YDim interpreted as projection
/// width
/// IfcRectangleProfileDef.XDim interpreted as projection
/// height
/// IfcExtrudedAreaSolid.Depth is interpreted as projection
/// depth
/// 
/// NOTE  Rectangles are now defined centric, the placement location has to be set:
/// IfcCartesianPoint(XDim/2,YDim/2)
/// NOTE  The local placement directions for the IfcProjectionElement are only given as an example, other directions are valid as well.
/// 
/// Figure 38 — Projection representation
/// 
/// Brep Representation
/// The general b-rep geometric representation of
/// IfcProjectionElement is defined using the Brep geometry. The
/// Brep representation allows for the representation of complex
/// element shape. The following attribute values for the
/// IfcShapeRepresentation holding this geometric representation
/// shall be used:
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'Brep'
class IfcProjectionElement : public IfcFeatureElementAddition {
public:
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcFeatureElementAddition::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcFeatureElementAddition::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcFeatureElementAddition::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcProjectionElement (IfcAbstractEntity* e);
    IfcProjectionElement (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag);
    typedef IfcTemplatedEntityList< IfcProjectionElement > list;
};
/// The flow controller type IfcProtectiveDeviceType defines commonly shared information for occurrences of protective devices.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a protective device specification (i.e. the specific product information, that is common to all occurrences of that product type).  Protective Device types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcProtectiveDeviceType are represented by instances of IfcProtectiveDevice. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcFlowControllerType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_ElectricalDeviceCommon 
/// Pset_ProtectiveDeviceTypeCommon 
/// 
/// The following property set definitions are applicable to this entity according to the PredefinedType attribute:  
/// Pset_ProtectiveDeviceTypeCircuitBreaker (CIRCUITBREAKER) 
/// Pset_ProtectiveDeviceTypeEarthLeakageCircuitBreaker (EARTHLEAKAGECIRCUITBREAKER) 
/// Pset_ProtectiveDeviceTypeFuseDisconnector (FUSEDISCONNECTOR) 
/// Pset_ProtectiveDeviceTypeResidualCurrentCircuitBreaker (RESIDUALCURRENTCIRCUITBREAKER) 
/// Pset_ProtectiveDeviceTypeResidualCurrentSwitch (RESIDUALCURRENTSWITCH) 
/// Pset_ProtectiveDeviceTypeVaristor (VARISTOR) 
/// 
/// Material Use Definition 
/// The material of the IfcProtectiveDeviceType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Casing': Material from which the casing is constructed. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcProtectiveDeviceType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcProtectiveDevice for standard port definitions.
class IfcProtectiveDeviceType : public IfcFlowControllerType {
public:
    /// Identifies the predefined types of protective device from which the type required may be set.
    IfcProtectiveDeviceTypeEnum::IfcProtectiveDeviceTypeEnum PredefinedType() const;
    void setPredefinedType(IfcProtectiveDeviceTypeEnum::IfcProtectiveDeviceTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcFlowControllerType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcProtectiveDeviceTypeEnum; } return IfcFlowControllerType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcFlowControllerType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcProtectiveDeviceType (IfcAbstractEntity* e);
    IfcProtectiveDeviceType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcProtectiveDeviceTypeEnum::IfcProtectiveDeviceTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcProtectiveDeviceType > list;
};
/// The flow moving device type IfcPumpType defines commonly shared information for occurrences of pumps.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a pump specification (i.e. the specific product information, that is common to all occurrences of that product type).  Pump types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcPumpType are represented by instances of IfcPump. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcFlowMovingDeviceType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_PumpTypeCommon 
/// 
/// Material Use Definition 
/// The material of the IfcPumpType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Casing': Material from which the casing is constructed. 
/// 'Impeller': Material from which the impeller of the pump is constructed. In the case of a positive displacement pump, the piston acts as the impeller. 
/// 'ImpellerSeal': Material from which the impeller shaft seal of the pump is constructed. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcPumpType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcPump for standard port definitions.
class IfcPumpType : public IfcFlowMovingDeviceType {
public:
    /// Defines the type of pump typically used in building services.
    IfcPumpTypeEnum::IfcPumpTypeEnum PredefinedType() const;
    void setPredefinedType(IfcPumpTypeEnum::IfcPumpTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcFlowMovingDeviceType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcPumpTypeEnum; } return IfcFlowMovingDeviceType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcFlowMovingDeviceType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPumpType (IfcAbstractEntity* e);
    IfcPumpType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcPumpTypeEnum::IfcPumpTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcPumpType > list;
};

class IfcRadiusDimension : public IfcDimensionCurveDirectedCallout {
public:
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcDimensionCurveDirectedCallout::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcDimensionCurveDirectedCallout::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcDimensionCurveDirectedCallout::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRadiusDimension (IfcAbstractEntity* e);
    IfcRadiusDimension (IfcEntityList::ptr v1_Contents);
    typedef IfcTemplatedEntityList< IfcRadiusDimension > list;
};
/// Definition from IAI: The element type (IfcRailingType)
///   defines a list of commonly shared property set definitions of a railing element
///   and an optional set of product representations. It is used to define a railing
///   specification (i.e. the specific product information, that is common to all
///   occurrences of that product type). 
/// 
/// NOTE: The product representations are defined as
///   representation maps (at the level of the supertype IfcTypeProduct, which
///   gets assigned by an element occurrence instance through the
///   IfcShapeRepresentation.Item[1] being an
///   IfcMappedItem. 
///   A railing type is used to define the common properties of a certain type
///   of railing that may be applied to many instances of that type to assign a
///   specific style. Railing types may be exchanged without being already assigned
///   to occurrences. 
///   The occurrences of the IfcRailingType are represented by
///   instances of IfcRailing. 
/// 
/// HISTORY New entity in Release IFC2x
///   Editon 2.
class IfcRailingType : public IfcBuildingElementType {
public:
    /// Identifies the predefined types of a railing element from which the type required may be set.
    IfcRailingTypeEnum::IfcRailingTypeEnum PredefinedType() const;
    void setPredefinedType(IfcRailingTypeEnum::IfcRailingTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcBuildingElementType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcRailingTypeEnum; } return IfcBuildingElementType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcBuildingElementType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRailingType (IfcAbstractEntity* e);
    IfcRailingType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcRailingTypeEnum::IfcRailingTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcRailingType > list;
};
/// Definition from IAI: The element type (IfcRampFlightType)
///   defines a list of commonly shared property set definitions of a ramp flight and
///   an optional set of product representations. It is used to define an ramp flight
///   specification (i.e. the specific product information, that is common to all
///   occurrences of that product type). 
/// 
/// NOTE: The product representations are defined as
///   representation maps (at the level of the supertype IfcTypeProduct, which
///   gets assigned by an element occurrence instance through the
///   IfcShapeRepresentation.Item[1] being an
///   IfcMappedItem. 
///   A ramp flight type is used to define the common properties of a certain
///   type of a ramp flight that may be applied to many instances of that type to
///   assign a specific style. Ramp flight types may be exchanged without being
///   already assigned to occurrences. 
///   The occurrences of the IfcRampFlightType are represented by
///   instances of IfcRampFlight. 
/// 
/// HISTORY New entity in Release IFC2x
///   Edition 2.
class IfcRampFlightType : public IfcBuildingElementType {
public:
    /// Identifies the predefined types of a ramp flight element from which the type required may be set.
    IfcRampFlightTypeEnum::IfcRampFlightTypeEnum PredefinedType() const;
    void setPredefinedType(IfcRampFlightTypeEnum::IfcRampFlightTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcBuildingElementType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcRampFlightTypeEnum; } return IfcBuildingElementType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcBuildingElementType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRampFlightType (IfcAbstractEntity* e);
    IfcRampFlightType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcRampFlightTypeEnum::IfcRampFlightTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcRampFlightType > list;
};
/// The aggregation relationship
/// IfcRelAggregates is a special type of the general
/// composition/decomposition (or whole/part) relationship
/// IfcRelDecomposes. The aggregation relationship can be
/// applied to all subtypes of IfcObjectDefinition.
/// In cases of aggregation of physical elements into a physical
/// aggregate the shape representation of the whole (within the same
/// representation identifier) can be taken from the sum of the shape
/// representations of the parts.
/// EXAMPLE A roof is the aggregation of the roof
/// elements, such as roof slabs, rafters, purlins, etc. Within the
/// same representation identifier, e.g. the body geometric
/// representation, the shape representation of the roof is given by
/// the shape representation of its parts
/// Decompositions imply a dependency, i.e. the definition of the
/// whole depends on the definition of the parts and the parts depend
/// on the existence of the whole. The behaviour that is implied from
/// the dependency has to be established inside the applications.
/// 
/// HISTORY New entity in IFC Release 2x.
/// 
/// IFC2x4 CHANGE The attributes RelatingObject and RelatedObjects are demoted from the supertype IfcRelDecomposes.
class IfcRelAggregates : public IfcRelDecomposes {
public:
    virtual unsigned int getArgumentCount() const { return 6; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcRelDecomposes::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcRelDecomposes::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcRelDecomposes::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRelAggregates (IfcAbstractEntity* e);
    IfcRelAggregates (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcObjectDefinition* v5_RelatingObject, IfcTemplatedEntityList< IfcObjectDefinition >::ptr v6_RelatedObjects);
    typedef IfcTemplatedEntityList< IfcRelAggregates > list;
};

class IfcRelAssignsTasks : public IfcRelAssignsToControl {
public:
    /// Whether the optional attribute TimeForTask is defined for this IfcRelAssignsTasks
    bool hasTimeForTask() const;
    IfcScheduleTimeControl* TimeForTask() const;
    void setTimeForTask(IfcScheduleTimeControl* v);
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 7: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcRelAssignsToControl::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 7: return Type::IfcScheduleTimeControl; } return IfcRelAssignsToControl::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 7: return "TimeForTask"; } return IfcRelAssignsToControl::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRelAssignsTasks (IfcAbstractEntity* e);
    IfcRelAssignsTasks (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcTemplatedEntityList< IfcObjectDefinition >::ptr v5_RelatedObjects, boost::optional< IfcObjectTypeEnum::IfcObjectTypeEnum > v6_RelatedObjectsType, IfcControl* v7_RelatingControl, IfcScheduleTimeControl* v8_TimeForTask);
    typedef IfcTemplatedEntityList< IfcRelAssignsTasks > list;
};
/// The flow terminal type IfcSanitaryTerminalType defines commonly shared information for occurrences of sanitary terminals.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a sanitary terminal specification (i.e. the specific product information, that is common to all occurrences of that product type).  Sanitary Terminal types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcSanitaryTerminalType are represented by instances of IfcSanitaryTerminal. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcFlowTerminalType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_SanitaryTerminalTypeCommon 
/// 
/// The following property set definitions are applicable to this entity according to the PredefinedType attribute:  
/// Pset_SanitaryTerminalTypeBath (BATH) 
/// Pset_SanitaryTerminalTypeBidet (BIDET) 
/// Pset_SanitaryTerminalTypeCistern (CISTERN) 
/// Pset_SanitaryTerminalTypeSanitaryFountain (SANITARYFOUNTAIN) 
/// Pset_SanitaryTerminalTypeShower (SHOWER) 
/// Pset_SanitaryTerminalTypeSink (SINK) 
/// Pset_SanitaryTerminalTypeToiletPan (TOILETPAN) 
/// Pset_SanitaryTerminalTypeUrinal (URINAL) 
/// Pset_SanitaryTerminalTypeWashHandBasin (WASHHANDBASIN) 
/// 
/// Material Use Definition 
/// The material of the IfcSanitaryTerminalType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Body': The primary material from which the object is constructed. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcSanitaryTerminalType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcSanitaryTerminal for standard port definitions.
class IfcSanitaryTerminalType : public IfcFlowTerminalType {
public:
    /// Identifies the predefined types of sanitary terminal from which the type required may be set.
    IfcSanitaryTerminalTypeEnum::IfcSanitaryTerminalTypeEnum PredefinedType() const;
    void setPredefinedType(IfcSanitaryTerminalTypeEnum::IfcSanitaryTerminalTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcFlowTerminalType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcSanitaryTerminalTypeEnum; } return IfcFlowTerminalType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcFlowTerminalType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcSanitaryTerminalType (IfcAbstractEntity* e);
    IfcSanitaryTerminalType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcSanitaryTerminalTypeEnum::IfcSanitaryTerminalTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcSanitaryTerminalType > list;
};

class IfcScheduleTimeControl : public IfcControl {
public:
    /// Whether the optional attribute ActualStart is defined for this IfcScheduleTimeControl
    bool hasActualStart() const;
    IfcDateTimeSelect* ActualStart() const;
    void setActualStart(IfcDateTimeSelect* v);
    /// Whether the optional attribute EarlyStart is defined for this IfcScheduleTimeControl
    bool hasEarlyStart() const;
    IfcDateTimeSelect* EarlyStart() const;
    void setEarlyStart(IfcDateTimeSelect* v);
    /// Whether the optional attribute LateStart is defined for this IfcScheduleTimeControl
    bool hasLateStart() const;
    IfcDateTimeSelect* LateStart() const;
    void setLateStart(IfcDateTimeSelect* v);
    /// Whether the optional attribute ScheduleStart is defined for this IfcScheduleTimeControl
    bool hasScheduleStart() const;
    IfcDateTimeSelect* ScheduleStart() const;
    void setScheduleStart(IfcDateTimeSelect* v);
    /// Whether the optional attribute ActualFinish is defined for this IfcScheduleTimeControl
    bool hasActualFinish() const;
    IfcDateTimeSelect* ActualFinish() const;
    void setActualFinish(IfcDateTimeSelect* v);
    /// Whether the optional attribute EarlyFinish is defined for this IfcScheduleTimeControl
    bool hasEarlyFinish() const;
    IfcDateTimeSelect* EarlyFinish() const;
    void setEarlyFinish(IfcDateTimeSelect* v);
    /// Whether the optional attribute LateFinish is defined for this IfcScheduleTimeControl
    bool hasLateFinish() const;
    IfcDateTimeSelect* LateFinish() const;
    void setLateFinish(IfcDateTimeSelect* v);
    /// Whether the optional attribute ScheduleFinish is defined for this IfcScheduleTimeControl
    bool hasScheduleFinish() const;
    IfcDateTimeSelect* ScheduleFinish() const;
    void setScheduleFinish(IfcDateTimeSelect* v);
    /// Whether the optional attribute ScheduleDuration is defined for this IfcScheduleTimeControl
    bool hasScheduleDuration() const;
    double ScheduleDuration() const;
    void setScheduleDuration(double v);
    /// Whether the optional attribute ActualDuration is defined for this IfcScheduleTimeControl
    bool hasActualDuration() const;
    double ActualDuration() const;
    void setActualDuration(double v);
    /// Whether the optional attribute RemainingTime is defined for this IfcScheduleTimeControl
    bool hasRemainingTime() const;
    double RemainingTime() const;
    void setRemainingTime(double v);
    /// Whether the optional attribute FreeFloat is defined for this IfcScheduleTimeControl
    bool hasFreeFloat() const;
    double FreeFloat() const;
    void setFreeFloat(double v);
    /// Whether the optional attribute TotalFloat is defined for this IfcScheduleTimeControl
    bool hasTotalFloat() const;
    double TotalFloat() const;
    void setTotalFloat(double v);
    /// Whether the optional attribute IsCritical is defined for this IfcScheduleTimeControl
    bool hasIsCritical() const;
    bool IsCritical() const;
    void setIsCritical(bool v);
    /// Whether the optional attribute StatusTime is defined for this IfcScheduleTimeControl
    bool hasStatusTime() const;
    IfcDateTimeSelect* StatusTime() const;
    void setStatusTime(IfcDateTimeSelect* v);
    /// Whether the optional attribute StartFloat is defined for this IfcScheduleTimeControl
    bool hasStartFloat() const;
    double StartFloat() const;
    void setStartFloat(double v);
    /// Whether the optional attribute FinishFloat is defined for this IfcScheduleTimeControl
    bool hasFinishFloat() const;
    double FinishFloat() const;
    void setFinishFloat(double v);
    /// Whether the optional attribute Completion is defined for this IfcScheduleTimeControl
    bool hasCompletion() const;
    double Completion() const;
    void setCompletion(double v);
    virtual unsigned int getArgumentCount() const { return 23; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 5: return IfcUtil::Argument_ENTITY_INSTANCE; case 6: return IfcUtil::Argument_ENTITY_INSTANCE; case 7: return IfcUtil::Argument_ENTITY_INSTANCE; case 8: return IfcUtil::Argument_ENTITY_INSTANCE; case 9: return IfcUtil::Argument_ENTITY_INSTANCE; case 10: return IfcUtil::Argument_ENTITY_INSTANCE; case 11: return IfcUtil::Argument_ENTITY_INSTANCE; case 12: return IfcUtil::Argument_ENTITY_INSTANCE; case 13: return IfcUtil::Argument_DOUBLE; case 14: return IfcUtil::Argument_DOUBLE; case 15: return IfcUtil::Argument_DOUBLE; case 16: return IfcUtil::Argument_DOUBLE; case 17: return IfcUtil::Argument_DOUBLE; case 18: return IfcUtil::Argument_BOOL; case 19: return IfcUtil::Argument_ENTITY_INSTANCE; case 20: return IfcUtil::Argument_DOUBLE; case 21: return IfcUtil::Argument_DOUBLE; case 22: return IfcUtil::Argument_DOUBLE; } return IfcControl::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 5: return Type::IfcDateTimeSelect; case 6: return Type::IfcDateTimeSelect; case 7: return Type::IfcDateTimeSelect; case 8: return Type::IfcDateTimeSelect; case 9: return Type::IfcDateTimeSelect; case 10: return Type::IfcDateTimeSelect; case 11: return Type::IfcDateTimeSelect; case 12: return Type::IfcDateTimeSelect; case 13: return Type::IfcTimeMeasure; case 14: return Type::IfcTimeMeasure; case 15: return Type::IfcTimeMeasure; case 16: return Type::IfcTimeMeasure; case 17: return Type::IfcTimeMeasure; case 18: return Type::UNDEFINED; case 19: return Type::IfcDateTimeSelect; case 20: return Type::IfcTimeMeasure; case 21: return Type::IfcTimeMeasure; case 22: return Type::IfcPositiveRatioMeasure; } return IfcControl::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 5: return "ActualStart"; case 6: return "EarlyStart"; case 7: return "LateStart"; case 8: return "ScheduleStart"; case 9: return "ActualFinish"; case 10: return "EarlyFinish"; case 11: return "LateFinish"; case 12: return "ScheduleFinish"; case 13: return "ScheduleDuration"; case 14: return "ActualDuration"; case 15: return "RemainingTime"; case 16: return "FreeFloat"; case 17: return "TotalFloat"; case 18: return "IsCritical"; case 19: return "StatusTime"; case 20: return "StartFloat"; case 21: return "FinishFloat"; case 22: return "Completion"; } return IfcControl::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcRelAssignsTasks >::ptr ScheduleTimeControlAssigned() const; // INVERSE IfcRelAssignsTasks::TimeForTask
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcScheduleTimeControl (IfcAbstractEntity* e);
    IfcScheduleTimeControl (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcDateTimeSelect* v6_ActualStart, IfcDateTimeSelect* v7_EarlyStart, IfcDateTimeSelect* v8_LateStart, IfcDateTimeSelect* v9_ScheduleStart, IfcDateTimeSelect* v10_ActualFinish, IfcDateTimeSelect* v11_EarlyFinish, IfcDateTimeSelect* v12_LateFinish, IfcDateTimeSelect* v13_ScheduleFinish, boost::optional< double > v14_ScheduleDuration, boost::optional< double > v15_ActualDuration, boost::optional< double > v16_RemainingTime, boost::optional< double > v17_FreeFloat, boost::optional< double > v18_TotalFloat, boost::optional< bool > v19_IsCritical, IfcDateTimeSelect* v20_StatusTime, boost::optional< double > v21_StartFloat, boost::optional< double > v22_FinishFloat, boost::optional< double > v23_Completion);
    typedef IfcTemplatedEntityList< IfcScheduleTimeControl > list;
};

class IfcServiceLife : public IfcControl {
public:
    IfcServiceLifeTypeEnum::IfcServiceLifeTypeEnum ServiceLifeType() const;
    void setServiceLifeType(IfcServiceLifeTypeEnum::IfcServiceLifeTypeEnum v);
    double ServiceLifeDuration() const;
    void setServiceLifeDuration(double v);
    virtual unsigned int getArgumentCount() const { return 7; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 5: return IfcUtil::Argument_ENUMERATION; case 6: return IfcUtil::Argument_DOUBLE; } return IfcControl::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 5: return Type::IfcServiceLifeTypeEnum; case 6: return Type::IfcTimeMeasure; } return IfcControl::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 5: return "ServiceLifeType"; case 6: return "ServiceLifeDuration"; } return IfcControl::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcServiceLife (IfcAbstractEntity* e);
    IfcServiceLife (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcServiceLifeTypeEnum::IfcServiceLifeTypeEnum v6_ServiceLifeType, double v7_ServiceLifeDuration);
    typedef IfcTemplatedEntityList< IfcServiceLife > list;
};
/// Definition from ISO 6707-1:1989: Area where construction
/// works are undertaken.
/// A site is a defined area of land, possibly
/// covered with water, on which the project construction is to be
/// completed. A site may be used to erect building(s) or other AEC
/// products.
/// A site (IfcSite) may include a definition of the single
/// geographic reference point for this site (global position using
/// WGS84 with Longitude, Latitude and Elevation).
/// The precision is provided up to millionth of a second and it
/// provides an absolute placement in relation to the real world as
/// used in exchange with geospational information systems. If
/// asserted, the Longitude, Latitude and
/// Elevation establish the point in WGS84 where the point
/// 0.,0.,0. of the LocalPlacement of IfcSite is
/// situated.
/// The geometrical placement of the site, defined by the
/// IfcLocalPlacement, shall be always relative to the spatial
/// structure element, in which this site is included, or absolute,
/// i.e. to the world coordinate system, as established by the
/// geometric representation context of the project. The world
/// coordinate system, established at the
/// IfcProject.RepresentationContexts, may include a definition
/// of the true north within the XY plane of the world coordinate
/// system, if provided, it can be obtained at
/// IfcGeometricRepresentationContext.TrueNorth.
/// A project may span over several connected or disconnected sites.
/// Therefore site complex provides for a collection of sites included
/// in a project. A site can also be decomposed in parts, where each
/// part defines a site section. This is defined by the composition
/// type attribute of the supertype IfcSpatialStructureElements
/// which is interpreted as follow:
/// 
/// COMPLEX = site complex
/// ELEMENT = site
/// PARTIAL = site section
/// 
/// HISTORY  New entity in IFC Release 1.0.
/// 
/// Property Set Use Definition
/// The property sets relating to the IfcSite are defined by
/// the IfcPropertySet and attached by the
/// IfcRelDefinesByProperties relationship. It is accessible by
/// the inverse IsDefinedBy relationship. The following property
/// set definitions specific to the IfcSite are part of this IFC
/// release:
/// 
/// Pset_SiteCommon: common property set for all
/// types of site
/// 
/// Quantity Use Definition
/// The quantities relating to the IfcSite are defined by the
/// IfcElementQuantity and attached by the
/// IfcRelDefinesByProperties relationship. It is accessible by
/// the inverse IsDefinedBy relationship. The following base
/// quantities are defined and should be exchanged with the
/// IfcElementQuantity.Name = 'BaseQuantities'. Other
/// quantities, being subjected to local standard of measurement, can
/// be defined with another string value assigned to Name. In
/// this case a valid value for MethodOfMeasurement has to be
/// provided.
/// 
/// Qto_SiteBaseQuantities: base quantities for all site
/// occurrences.
/// 
/// Spatial Structure Use Definition
/// The IfcSite is used to build the spatial structure of a
/// building (that serves as the primary project breakdown and is
/// required to be hierarchical). The spatial structure elements are
/// linked together by using the objectified relationship
/// IfcRelAggregates. The IfcSite references them by its
/// inverse relationships:
/// 
/// IfcSite.Decomposes -- referencing (IfcProject ||
/// IfcSite) by IfcRelAggregates.RelatingObject, If it
/// refers to another instance of IfcSite, the referenced
/// IfcSite needs to have a different and higher
/// CompositionType, i.e. COMPLEX (if the other IfcSite
/// has ELEMENT), or ELEMENT (if the other IfcSite has
/// PARTIAL).
/// IfcSite.IsDecomposedBy -- referencing (IfcSite ||
/// IfcBuilding || IfcSpace) by
/// IfcRelAggregates.RelatedObjects. If it refers to another
/// instance of IfcSite, the referenced IfcSite needs to
/// have a different and lower CompositionType, i.e. ELEMENT (if the
/// other IfcSite has COMPLEX), or PARTIAL (if the other
/// IfcSite has ELEMENT).
/// 
/// If there are building elements and/or other elements directly
/// related to the IfcSite (like a fence, or a shear wall), they
/// are associated with the IfcSite by using the objectified
/// relationship IfcRelContainedInSpatialStructure. The
/// IfcIfcSite references them by its inverse relationship:
/// 
/// IfcSite.ContainsElements -- referencing any subtype of
/// IfcProduct (with the exception of other spatial structure
/// element) by
/// IfcRelContainedInSpatialStructure.RelatedElements.
/// 
/// Figure 51 shows the IfcSite as part of the spatial structure. In addition to the logical spatial structure, also the placement hierarchy is shown. In this example the spatial structure hierarchy and the placement hierarchy are identical.
/// NOTE Detailed requirements on mandatory element containment and placement structure relationships are given in view definitions and implementer agreements.
/// 
/// Figure 51 — Site composition
/// 
/// Attribute Use Definition
/// Figure 52 describes the heights and elevations of the IfcSite. It is used to provide the geographic longitude, latitude, and height above sea level for the origin of the site. The origin of the site is the local placement.
/// The provision of longitude, latitude, height at the IfcSite for georeferencing is provided for upward compatibility reasons. It requires a single instance of IfcSite and WGS84 as coordinate reference system.
/// For exact georeferencing the new entities IfcCoordinateReferenceSystem and IfcMapConversion should be used.
/// 
/// reference height of site is provided by: IfcSite.RefElevation, it is given according to the height datum used at this location.
/// the reference height of each building situated at the site is given againt the same height datum used at this location.
/// the elevations of each storey belonging to each building are given as local height relative to the reference height of the building.
/// 
///  
/// Figure 52 — Site elevations
/// 
/// Geometry Use Definitions
/// The geometric representation of IfcSite is given by the
/// IfcProductDefinitionShape and IfcLocalPlacement
/// allowing multiple geometric representations.
/// Local placement
/// The local placement for IfcSite is defined in its
/// supertype IfcProduct. It is defined by the
/// IfcLocalPlacement, which defines the local coordinate system
/// that is referenced by all geometric representations.
/// 
/// The PlacementRelTo relationship of
/// IfcLocalPlacement shall point to the
/// IfcSpatialStructureElement of type "IfcSite", if
/// relative placement is used (e.g. to position a site relative a a
/// site complex, or a site section to a site).
/// If the relative placement is not used, the absolute placement
/// is defined within the world coordinate system. If there is only one
/// site object, then this is the default situation.
/// 
/// Foot Print Representation
/// The foot print representation of IfcSite is given by
/// either a single 2D curve (such as IfcPolyline or
/// IfcCompositeCurve), or by a list of 2D curves (in case of
/// inner boundaries).
/// The representation identifier and type of this geometric
/// representation of IfcSite is:
/// 
/// IfcShapeRepresentation.RepresentationIdentifier =
/// 'FootPrint'
/// IfcShapeRepresentation.RepresentationType =
/// 'GeometricCurveSet', or 'Annotation2D'
/// 
/// Survey Points Representation
/// The survey point representation of IfcSite is defined
/// using a set of survey points and optionally breaklines. The
/// breaklines are restricted to only connect points given in the set
/// of survey points. Breaklines, if given, are used to constrain the
/// triangulation.
/// The representation identifier and type of this geometric
/// representation of IfcSite is:
/// 
/// IfcShapeRepresentation.RepresentationIdentifier =
/// 'SurveyPoints'
/// IfcShapeRepresentation.RepresentationType =
/// 'GeometricCurveSet'
/// 
/// Figure 53 shows a set of survey points, given as 3D Cartesian points within the object coordinate system of the site.  Figure 54 shows the result after facetation.
/// The set of IfcCartesianPoint is included in the set of IfcGeometricCurveSet.Elements.
/// 
/// Figure 53 — Site survey points
/// Figure 54 — Site survey points facetation
/// 
/// Figure 55 shows A set of survey points, given as 3D Cartesian points, and a set of break points, given as a set of lines, connecting some survey points, within the object coordinate system of the site.  Figure 56 shows the result after facetation.
/// The set of IfcCartesianPoint and the set of IfcPolyline are included in the set of IfcGeometricCurveSet.Elements.
/// 
/// Figure 55 — Site breaklines
/// Figure 56 — Site breaklines facetation
/// 
/// NOTE  The geometric representation of the site has been based on the ARM level description of the site_shape_representation given within the ISO 10303-225 "Building Elements using explicit shape representation".
/// 
/// Body Representation
/// The body representation of IfcSite is defined using a
/// solid or surface model. Applicable solids are the
/// IfcFacetedBrep or on the IfcFacetedBrepWithVoids,
/// applicable surface models are the IfcFaceBasedSurfaceModel
/// and the IfcShellBasedSurfaceModel.
/// The representation identifier and type of this representation of
/// IfcSite is:
/// 
/// IfcShapeRepresentation.RepresentationIdentifier =
/// 'Body'
/// IfcShapeRepresentation.RepresentationType = 'Brep', or
/// 'SurfaceModel'
class IfcSite : public IfcSpatialStructureElement {
public:
    /// Whether the optional attribute RefLatitude is defined for this IfcSite
    bool hasRefLatitude() const;
    /// World Latitude at reference point (most likely defined in legal description). Defined as integer values for degrees, minutes, seconds, and, optionally, millionths of seconds with respect to the world geodetic system WGS84.
    ///   Latitudes are measured relative to the geodetic equator, north of the equator by positive values - from 0 till +90,   south of the equator by negative values - from 0 till  -90.
    std::vector< int > /*[3:4]*/ RefLatitude() const;
    void setRefLatitude(std::vector< int > /*[3:4]*/ v);
    /// Whether the optional attribute RefLongitude is defined for this IfcSite
    bool hasRefLongitude() const;
    /// World Longitude at reference point (most likely defined in legal description). Defined as integer values for degrees, minutes, seconds, and, optionally, millionths of seconds with respect to the world geodetic system WGS84.
    ///   Longitudes are measured relative to the geodetic zero meridian, nominally the same as the Greenwich prime meridian: longitudes west of the zero meridian have negative values - from 0 till -180, longitudes east of the zero meridian have positive values - from 0 till -180.
    /// Example: Chicago Harbor Light has according to WGS84 a longitude -87.35.40 (or 87.35.40W) and a latitude 41.53.30 (or 41.53.30N).
    std::vector< int > /*[3:4]*/ RefLongitude() const;
    void setRefLongitude(std::vector< int > /*[3:4]*/ v);
    /// Whether the optional attribute RefElevation is defined for this IfcSite
    bool hasRefElevation() const;
    /// Datum elevation relative to sea level.
    double RefElevation() const;
    void setRefElevation(double v);
    /// Whether the optional attribute LandTitleNumber is defined for this IfcSite
    bool hasLandTitleNumber() const;
    /// The land title number (designation of the site within a regional system).
    std::string LandTitleNumber() const;
    void setLandTitleNumber(std::string v);
    /// Whether the optional attribute SiteAddress is defined for this IfcSite
    bool hasSiteAddress() const;
    /// Address given to the site for postal purposes.
    IfcPostalAddress* SiteAddress() const;
    void setSiteAddress(IfcPostalAddress* v);
    virtual unsigned int getArgumentCount() const { return 14; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_AGGREGATE_OF_INT; case 10: return IfcUtil::Argument_AGGREGATE_OF_INT; case 11: return IfcUtil::Argument_DOUBLE; case 12: return IfcUtil::Argument_STRING; case 13: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcSpatialStructureElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcCompoundPlaneAngleMeasure; case 10: return Type::IfcCompoundPlaneAngleMeasure; case 11: return Type::IfcLengthMeasure; case 12: return Type::IfcLabel; case 13: return Type::IfcPostalAddress; } return IfcSpatialStructureElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "RefLatitude"; case 10: return "RefLongitude"; case 11: return "RefElevation"; case 12: return "LandTitleNumber"; case 13: return "SiteAddress"; } return IfcSpatialStructureElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcSite (IfcAbstractEntity* e);
    IfcSite (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_LongName, IfcElementCompositionEnum::IfcElementCompositionEnum v9_CompositionType, boost::optional< std::vector< int > /*[3:4]*/ > v10_RefLatitude, boost::optional< std::vector< int > /*[3:4]*/ > v11_RefLongitude, boost::optional< double > v12_RefElevation, boost::optional< std::string > v13_LandTitleNumber, IfcPostalAddress* v14_SiteAddress);
    typedef IfcTemplatedEntityList< IfcSite > list;
};
/// The element type IfcSlabType defines commonly shared
/// information for occurrences of slabs. The set of shared information
/// may include:
/// 
/// common properties within shared property sets
/// common material information
/// common material layer definitions
/// common shape representations
/// 
/// NOTE It is illegal to share shape
/// representations as representation maps for occurrences of
/// IfcSlabStandardCase.
/// 
/// It is used to define a slab specification (i.e. the specific
/// product information, that is common to all occurrences of that
/// product type). Slab types may be exchanged without being already
/// assigned to occurrences.
/// NOTE The product representations are defined as
/// representation maps (at the level of the supertype
/// IfcTypeProduct, which gets assigned by an element occurrence
/// instance through the IfcShapeRepresentation.Item[1] being an
/// IfcMappedItem.
/// The occurrences of the IfcSlabType within building models
/// are represented by instances of IfcSlabStandardCase if the
/// IfcSlabType has a single associated
/// IfcMaterialLayerSet; otherwise they are represented by
/// instances of IfcSlab, or IfcSlabElementedCase.
/// 
/// HISTORY  New
/// entity in Release IFC2x2.
/// 
/// Informal proposition:
/// 
/// The material assignment, if provided using the
/// IfcRelAssociatesMaterial relationship, shall not reference
/// the IfcMaterialLayerSetUsage.
/// 
/// Material Use Definition
/// The material of the IfcSlabType is defined by the
/// IfcMaterialLayerSet or as fall back by IfcMaterial
/// and attached by the
/// IfcRelAssociatesMaterial.RelatingMaterial. It is
/// accessible by the inverse HasAssociations relationship.
/// Note: It is illegal to assign an
/// IfcMaterial to an IfcSlabType, if there is at least
/// one occurrences. of IfcSlabStandardCase for this
/// type.
/// Layer Set Use Definition:
/// The shared material layer set definition is defined by assigning
/// an IfcMaterialLayerSet (see material use definition above).
/// The IfcMaterialLayer refers to one or several of
/// IfcMaterial that is the common for all slab occurrence, if
/// used. It is only applicable if the IfcSlabType has only
/// occurrences of type IfcSlabStandardCase (see definition of
/// IfcSlabStandardCase for further information).
/// NOTE Since each individual instance of
/// IfcSlabStandardCase defines its own
/// IfcMaterialLayerSetUsage including the offset from the
/// reference plane, the same IfcSlabType can be used
/// independently of the reference plane alignment of its
/// occurrences.
/// Property Set Use Definition:
/// The shared property sets relating to the IfcSlabType are
/// defined by the IfcPropertySet and are attached by the
/// HasPropertySets attribute. The following property set
/// definitions specific to the IfcWallType are part of this IFC
/// release:
/// NOTE There is no differentiation between
/// properties within the property set that are only assignable to
/// IfcSlabType and those that are only assignable to
/// IfcSlab. If the same property is assigned to the
/// IfcSlabType and the IfcSlab being an occurrence of
/// the IfcSlabType, then the occurrence property overrides the
/// type property.
/// 
/// Pset_SlabCommon: common property set for all
/// slab types.
class IfcSlabType : public IfcBuildingElementType {
public:
    /// Identifies the predefined types of a slab element from which the type required may be set.
    IfcSlabTypeEnum::IfcSlabTypeEnum PredefinedType() const;
    void setPredefinedType(IfcSlabTypeEnum::IfcSlabTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcBuildingElementType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcSlabTypeEnum; } return IfcBuildingElementType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcBuildingElementType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcSlabType (IfcAbstractEntity* e);
    IfcSlabType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcSlabTypeEnum::IfcSlabTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcSlabType > list;
};
/// A space represents an area or volume
/// bounded actually or theoretically. Spaces are areas or volumes that
/// provide for certain functions within a building.
/// A space is associated to a building storey (or in case of
/// exterior spaces to a site). A space may span over several connected
/// spaces. Therefore a space group provides for a collection of spaces
/// included in a storey. A space can also be decomposed in parts,
/// where each part defines a partial space. This is defined by the
/// CompositionType attribute of the supertype
/// IfcSpatialStructureElement which is interpreted as
/// follow:
/// 
/// COMPLEX = space group
/// ELEMENT = space
/// PARTIAL = partial space
/// 
/// NOTE View definitions and implementation
/// agreements may restrict spaces with CompositionType=ELEMENT
/// to be non-overlapping.
/// The following guidelines should apply for using the Name,
/// Description, LongName and ObjectType
/// attributes.
/// 
/// Name holds the unique name (or space number) from the
/// plan.
/// Description holds any additional information field the
/// user may have specified, there are no further recommendations.
/// LongName holds the full name of the space, it is often
/// used in addition to the Name, if a number is assigned to the
/// room, then the descriptive name is exchanged as
/// LongName.
/// ObjectType holds the space type, i.e. usually the
/// functional category of the space .
/// 
/// HISTORY New Entity in IFC Release 1.0
/// 
/// Property Set Use Definition
/// The property sets relating to the IfcSpace are defined by
/// the IfcPropertySet and attached by the
/// IfcRelDefinesByProperties relationship. It is accessible by
/// the inverse IsDefinedBy relationship. The following property
/// set definitions specific to the IfcSpace are part of this
/// IFC release:
/// 
/// Pset_SpaceCommon: common property set for all
/// types of spaces
/// 
/// Pset_SpaceParking: specific property set for
/// only those spaces that are used to define parking spaces by
/// PredefinedType: PARKING
/// 
/// Pset_SpaceFireSafetyRequirements: common
/// property set for all types of spaces to capture the fire safety
/// requirements
/// Pset_SpaceLightingRequirements: common property
/// set for all types of spaces to capture the lighting
/// requirements
/// Pset_SpaceOccupancyRequirements: common
/// property set for all types of spaces to capture the occupancy
/// requirements
/// Pset_SpaceThermalRequirements: common property
/// set for all types of spaces to capture the thermal
/// requirements
/// Pset_SpaceThermalDesign: common property set
/// for all all types of spaces to capture building service design
/// values
/// 
/// Quantity Use Definition
/// The quantities relating to the IfcSpace are defined by
/// the IfcElementQuantity and attached by the
/// IfcRelDefinesByProperties relationship. It is accessible by
/// the inverse IsDefinedBy relationship. The following base
/// quantities are defined and should be exchanged with the
/// IfcElementQuantity.Name = 'BaseQuantities'. Other
/// quantities, being subjected to local standard of measurement, can
/// be defined with another string value assigned to Name. In
/// this case a valid value for MethodOfMeasurement has to be
/// provided.
/// 
/// Qto_SpaceBaseQuantities: base quantities for all space
/// occurrences.
/// 
/// Spatial Structure Use Definition
/// The IfcSpace is used to build the spatial structure of a
/// building (that serves as the primary project breakdown and is
/// required to be hierarchical). The spatial structure elements are
/// linked together by using the objectified relationship
/// IfcRelAggregates. The IfcSpace references them by its
/// inverse relationships:
/// 
/// IfcSpace.Decomposes -- referencing (IfcSite ||
/// IfcBuildingStorey || IfcSpace) by
/// IfcRelAggregates.RelatingObject, If it refers to another
/// instance of IfcSpace, the referenced IfcSpace
/// needs to have a different and higher CompositionType, i.e.
/// COMPLEX (if the other IfcSpace has ELEMENT), or ELEMENT (if
/// the other IfcSpace has PARTIAL).
/// IfcSpace.IsDecomposedBy -- referencing (IfcSpace)
/// by IfcRelAggregates.RelatedObjects. If it refers to another
/// instance of IfcSpace, the referenced IfcSpace needs
/// to have a different and lower CompositionType, i.e. ELEMENT
/// (if the other IfcSpace has COMPLEX), or PARTIAL (if the
/// other IfcSpace has ELEMENT).
/// 
/// If there are building elements and/or other elements directly
/// related to the IfcSpace (like most furniture and
/// distribution elements), they are associated with the
/// IfcSpace by using the objectified relationship
/// IfcRelContainedInSpatialStructure. The IfcSpace
/// references them by its inverse relationship:
/// 
/// IfcSpace.ContainsElements -- referencing any subtype of
/// IfcProduct (with the exception of other spatial structure
/// element) by
/// IfcRelContainedInSpatialStructure.RelatedElements.
/// 
/// Figure 57 shows the IfcSpace as part of the spatial structure. It also serves as the spatial container for space related elements.
/// NOTE Detailed requirements on mandatory element containment and placement structure relationships are given in view definitions and implementer agreements.
/// 
/// Figure 57 — Space composition
/// 
/// Attribute Use Definition
/// 
/// Figure 58 describes the heights and elevations of the IfcSpace.
/// 
/// elevation of the space (top of construction slab) equals elevation of storey: provided by IfcBuildingStorey.Elevation relative to IfcBuilding.ElevationOfRefHeight
/// elevation of the space flooring (top of flooring on top of slab): provided by IfcSpace.ElevationWithFlooring relative to IfcBuilding.ElevationOfRefHeight
/// height of space (top of slab below to bottom of slab above): provided by BaseQuantity with Name="Height"
/// floor height of space (top of slab below to top of flooring): provided by BaseQuantity with Name="FinishFloorHeight"
/// net height of space (top of flooring to bottom of suspended ceiling): provided by BaseQuantity with Name="FinishCeilingHeight"
/// 
/// Figure 58 — Space elevations
/// 
/// Geometry Use Definition
/// The geometric representation of IfcSpace is given by the
/// IfcProductDefinitionShape and IfcLocalPlacement
/// allowing multiple geometric representations.
/// NOTE In cases of inconsistency between the
/// geometric representation of the IfcSpace and the combined
/// geometric representations of the surrounding
/// IfcRelSpaceBoundary, the geometric representation of the
/// space should take priority over the geometric representation of the
/// surrounding space boundaries.
/// Local Placement
/// The local placement for IfcSpace is defined in its
/// supertype IfcProduct. It is defined by the
/// IfcLocalPlacement, which defines the local coordinate system
/// that is referenced by all geometric representations.
/// 
/// The PlacementRelTo relationship of
/// IfcLocalPlacement shall point to the local placement of the
/// IfcSpatialStructureElement of type "IfcBuildingStorey", if
/// relative placement is used, or of type "IfcSpace" (e.g. to position
/// a space relative to a space group, or a partial space to a
/// space).
/// If the relative placement is not used, the absolute placement
/// is defined within the world coordinate system.
/// 
/// Geometric Representations
/// Currently, the use of a 2D 'FootPrint' representation of type
/// 'Curve2D' or 'GeometricCurveSet' and a 3D 'Body' representation of
/// type 'SweptSolid, 'Clipping' and 'Brep' is supported.
/// 'Foot Print' Representation
/// The 2D geometric representation of IfcSpace is defined
/// using the 'Curve2D' or 'GeometricCurveSet' geometry. The following
/// attribute values should be inserted
/// 
/// IfcShapeRepresentation.RepresentationIdentifier =
/// 'FootPrint'.
/// IfcShapeRepresentation.RepresentationType = 'Curve2D' or
/// 'GeometricCurveSet' .
/// 
/// The following constraints apply to the 2D representation:
/// 
/// Profile: IfcBoundedCurve is required, using
/// IfcPolyline for faceted space contours or
/// IfcCompositeCurve for space contours with arc segments. For
/// spaces with inner boundaries, a set of IfcBoundedCurve's is
/// used, that should be grouped into an
/// IfcGeometricCurveSet.
/// 
/// Figure 59 shows a two-dimensional bounded curve representing the
/// foot print of IfcSpace.
/// 
/// Figure 59 — Space footprint
/// 
/// 'Swept Solid' Representation
/// The standard geometric representation of IfcSpace is
/// defined using the swept area solid geometry. The following
/// attribute values should be inserted
/// 
/// IfcShapeRepresentation.RepresentationIdentifier =
/// 'Body'.
/// IfcShapeRepresentation.RepresentationType =
/// 'SweptSolid'.
/// 
/// The following constraints apply to the standard
/// representation:
/// 
/// Solid: IfcExtrudedAreaSolid is required,
/// Profile: IfcArbitraryClosedProfileDef is
/// required, IfcArbitraryProfileDefWithVoids shall be
/// supported.
/// Extrusion: The extrusion direction shall be vertically,
/// i.e., along the positive Z Axis of the co-ordinate system of the
/// containing spatial structure element.
/// 
/// Figure 60 shows an extrusion of an arbitrary profile definition with voids into the swept area solid of IfcSpace.
/// 
/// Figure 60 — Space body swept solid
/// 
/// 'Clipping' representation
/// The advanced geometric representation of IfcSpace is
/// defined using the swept area solid geometry that can be subjected
/// to a Boolean expression. The following attribute values should be
/// inserted.
/// 
/// IfcShapeRepresentation.RepresentationIdentifier =
/// 'Body'.
/// IfcShapeRepresentation.RepresentationType =
/// 'Clipping'.
/// 
/// The following additional constraints apply to the advanced
/// representation:
/// 
/// Solid: see standard geometric representation,
/// Profile: see standard geometric representation,
/// Extrusion: see standard geometric representation,
/// Boolean result: The difference operation with the second
/// operand being of type IfcHalfSpaceSolid (or one of its
/// subtypes) shall be supported.
/// 
/// Figure 61 shows an extrusion of an arbitrary profile definition into the swept area solid. The solid and an half space solid are operands of the Boolean result of IfcSpace.
/// 
/// Figure 61 — Space body clipping
/// 
/// 'Brep' representation
/// The fallback advanced geometric representation of
/// IfcSpace is defined using the Brep solid geometry. may
/// be represented as a single or multiple instances of
/// IfcFacetedBrep or IfcFacetedBrepWithVoids. The Brep
/// representation allows for the representation of complex element
/// shape. The following attribute values for the
/// IfcShapeRepresentation holding this geometric representation
/// shall be used:
/// 
/// IfcShapeRepresentation.RepresentationIdentifier :
/// 'Body'
/// IfcShapeRepresentation.RepresentationType :
/// 'Brep'
class IfcSpace : public IfcSpatialStructureElement {
public:
    IfcInternalOrExternalEnum::IfcInternalOrExternalEnum InteriorOrExteriorSpace() const;
    void setInteriorOrExteriorSpace(IfcInternalOrExternalEnum::IfcInternalOrExternalEnum v);
    /// Whether the optional attribute ElevationWithFlooring is defined for this IfcSpace
    bool hasElevationWithFlooring() const;
    /// Level of flooring of this space; the average shall be taken, if the space ground surface is sloping or if there are level differences within this space.
    double ElevationWithFlooring() const;
    void setElevationWithFlooring(double v);
    virtual unsigned int getArgumentCount() const { return 11; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; case 10: return IfcUtil::Argument_DOUBLE; } return IfcSpatialStructureElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcInternalOrExternalEnum; case 10: return Type::IfcLengthMeasure; } return IfcSpatialStructureElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "InteriorOrExteriorSpace"; case 10: return "ElevationWithFlooring"; } return IfcSpatialStructureElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcRelCoversSpaces >::ptr HasCoverings() const; // INVERSE IfcRelCoversSpaces::RelatedSpace
    IfcTemplatedEntityList< IfcRelSpaceBoundary >::ptr BoundedBy() const; // INVERSE IfcRelSpaceBoundary::RelatingSpace
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcSpace (IfcAbstractEntity* e);
    IfcSpace (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_LongName, IfcElementCompositionEnum::IfcElementCompositionEnum v9_CompositionType, IfcInternalOrExternalEnum::IfcInternalOrExternalEnum v10_InteriorOrExteriorSpace, boost::optional< double > v11_ElevationWithFlooring);
    typedef IfcTemplatedEntityList< IfcSpace > list;
};
/// The energy conversion device type IfcSpaceHeaterType defines commonly shared information for occurrences of space heaters.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a space heater specification (i.e. the specific product information, that is common to all occurrences of that product type).  Space Heater types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcSpaceHeaterType are represented by instances of IfcSpaceHeater. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcEnergyConversionDeviceType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_SpaceHeaterTypeCommon 
/// 
/// The following property set definitions are applicable to this entity according to the PredefinedType attribute:  
/// Pset_SpaceHeaterTypeConvector (CONVECTOR) 
/// Pset_SpaceHeaterTypeRadiator (RADIATOR) 
/// 
/// Material Use Definition 
/// The material of the IfcSpaceHeaterType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Body': The primary material from which the object is constructed. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcSpaceHeaterType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcSpaceHeater for standard port definitions.
class IfcSpaceHeaterType : public IfcEnergyConversionDeviceType {
public:
    /// Enumeration of possible types of space heater (e.g., baseboard heater, convector, radiator, etc.).
    IfcSpaceHeaterTypeEnum::IfcSpaceHeaterTypeEnum PredefinedType() const;
    void setPredefinedType(IfcSpaceHeaterTypeEnum::IfcSpaceHeaterTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcEnergyConversionDeviceType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcSpaceHeaterTypeEnum; } return IfcEnergyConversionDeviceType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcEnergyConversionDeviceType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcSpaceHeaterType (IfcAbstractEntity* e);
    IfcSpaceHeaterType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcSpaceHeaterTypeEnum::IfcSpaceHeaterTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcSpaceHeaterType > list;
};

class IfcSpaceProgram : public IfcControl {
public:
    std::string SpaceProgramIdentifier() const;
    void setSpaceProgramIdentifier(std::string v);
    /// Whether the optional attribute MaxRequiredArea is defined for this IfcSpaceProgram
    bool hasMaxRequiredArea() const;
    double MaxRequiredArea() const;
    void setMaxRequiredArea(double v);
    /// Whether the optional attribute MinRequiredArea is defined for this IfcSpaceProgram
    bool hasMinRequiredArea() const;
    double MinRequiredArea() const;
    void setMinRequiredArea(double v);
    /// Whether the optional attribute RequestedLocation is defined for this IfcSpaceProgram
    bool hasRequestedLocation() const;
    IfcSpatialStructureElement* RequestedLocation() const;
    void setRequestedLocation(IfcSpatialStructureElement* v);
    double StandardRequiredArea() const;
    void setStandardRequiredArea(double v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 5: return IfcUtil::Argument_STRING; case 6: return IfcUtil::Argument_DOUBLE; case 7: return IfcUtil::Argument_DOUBLE; case 8: return IfcUtil::Argument_ENTITY_INSTANCE; case 9: return IfcUtil::Argument_DOUBLE; } return IfcControl::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 5: return Type::IfcIdentifier; case 6: return Type::IfcAreaMeasure; case 7: return Type::IfcAreaMeasure; case 8: return Type::IfcSpatialStructureElement; case 9: return Type::IfcAreaMeasure; } return IfcControl::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 5: return "SpaceProgramIdentifier"; case 6: return "MaxRequiredArea"; case 7: return "MinRequiredArea"; case 8: return "RequestedLocation"; case 9: return "StandardRequiredArea"; } return IfcControl::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcRelInteractionRequirements >::ptr HasInteractionReqsFrom() const; // INVERSE IfcRelInteractionRequirements::RelatedSpaceProgram
    IfcTemplatedEntityList< IfcRelInteractionRequirements >::ptr HasInteractionReqsTo() const; // INVERSE IfcRelInteractionRequirements::RelatingSpaceProgram
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcSpaceProgram (IfcAbstractEntity* e);
    IfcSpaceProgram (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, std::string v6_SpaceProgramIdentifier, boost::optional< double > v7_MaxRequiredArea, boost::optional< double > v8_MinRequiredArea, IfcSpatialStructureElement* v9_RequestedLocation, double v10_StandardRequiredArea);
    typedef IfcTemplatedEntityList< IfcSpaceProgram > list;
};
/// Definition from IAI: A space represents an area or
/// volume bounded actually or theoretically. Spaces are areas or
/// volumes that provide for certain functions within a building.
/// The IfcSpaceType defines a list of commonly shared
/// defines commonly shared information for occurrences of spaces.
/// The set of shared information may include:
/// 
/// common properties within shared property sets
/// common shape representations
/// 
/// It is used to define an space specification (i.e. the specific
/// space information, that is common to all occurrences of that
/// space type. Space types may be exchanged without being already
/// assigned to occurrences.
/// NOTE ÿThe space types are often used to
/// represent space catalogues, less so for sharing a common
/// representation map. Space types in a space catalogue share same
/// space classification and a common set of space requirement
/// properties.
/// The occurrences of IfcSpaceType are represented by
/// instances of IfcSpace.
/// 
/// HISTORY ÿNew entity in
/// IFC2x3.
/// 
/// Property Set Use Definition:
/// The shared property sets relating to the IfcSpaceType
/// are defined by the IfcPropertySet and are attached by the
/// HasPropertySets attribute. The following property set
/// definitions specific to the IfcSpaceType are part of this
/// IFC release:
/// NOTE There is no differentiation between
/// properties within the property set that are only assignable to
/// IfcSpaceType and those that are only assignable to
/// IfcSpace. If the same property is assigned to the
/// IfcSpaceType and the IfcSpace being an occurrence
/// of the IfcSpaceType, then the occurrence property
/// overrides the type property.
/// 
/// Pset_SpaceCommon: common property set for all
/// types of spaces
/// 
/// Pset_SpaceParking: specific property set for
/// only those spaces that are used to define parking spaces by
/// PredefinedType: PARKING
/// 
/// Pset_SpaceFireSafetyRequirements: common
/// property set for all types of spaces to capture the fire safety
/// requirements
/// Pset_SpaceLightingRequirements: common
/// property set for all types of spaces to capture the lighting
/// requirements
/// Pset_SpaceOccupancyRequirements: common
/// property set for all types of spaces to capture the occupancy
/// requirements
/// Pset_SpaceThermalRequirements: common
/// property set for all types of spaces to capture the thermal
/// requirements
/// Pset_SpaceThermalDesign: common property set
/// for allÿall types of spaces to capture building service design
/// values
/// 
/// Geometry Use Definition:
/// The IfcSpaceType may define the shared geometric
/// representation for all space occurrences. The
/// RepresentationMaps attribute refers to a list of
/// IfcRepresentationMap's, that allow for multiple geometric
/// representations (e.g. with IfcShaperepresentation's having
/// an RepresentationIdentifier 'Box', 'FootPrint', or 'Body').
/// 
/// NOTE ÿThe product representations are defined as
/// representation maps (at the level of the supertype
/// IfcTypeProduct, which gets assigned by an element
/// occurrence instance through the
/// IfcShapeRepresentation.Item[1] being an
/// IfcMappedItem.
/// 
/// However view definitions and implementer
/// agreements may prevent the usage of shared geometry for
/// spaces.
/// .
class IfcSpaceType : public IfcSpatialStructureElementType {
public:
    /// Predefined types to define the particular type of space. There may be property set definitions available for each predefined type.
    IfcSpaceTypeEnum::IfcSpaceTypeEnum PredefinedType() const;
    void setPredefinedType(IfcSpaceTypeEnum::IfcSpaceTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcSpatialStructureElementType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcSpaceTypeEnum; } return IfcSpatialStructureElementType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcSpatialStructureElementType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcSpaceType (IfcAbstractEntity* e);
    IfcSpaceType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcSpaceTypeEnum::IfcSpaceTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcSpaceType > list;
};
/// The flow terminal type IfcStackTerminalType defines commonly shared information for occurrences of stack terminals.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a stack terminal specification (i.e. the specific product information, that is common to all occurrences of that product type).  Stack Terminal types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcStackTerminalType are represented by instances of IfcStackTerminal. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcFlowTerminalType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_StackTerminalTypeCommon 
/// 
/// Material Use Definition 
/// The material of the IfcStackTerminalType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Body': The primary material from which the object is constructed. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcStackTerminalType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcStackTerminal for standard port definitions.
class IfcStackTerminalType : public IfcFlowTerminalType {
public:
    /// Identifies the predefined types of stack terminal from which the type required may be set.
    IfcStackTerminalTypeEnum::IfcStackTerminalTypeEnum PredefinedType() const;
    void setPredefinedType(IfcStackTerminalTypeEnum::IfcStackTerminalTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcFlowTerminalType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcStackTerminalTypeEnum; } return IfcFlowTerminalType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcFlowTerminalType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcStackTerminalType (IfcAbstractEntity* e);
    IfcStackTerminalType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcStackTerminalTypeEnum::IfcStackTerminalTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcStackTerminalType > list;
};
/// Definition from IAI: The element type (IfcStairFlightType)
///   defines a list of commonly shared property set definitions of a stair flight
///   and an optional set of product representations. It is used to define an stair
///   flight specification (i.e. the specific product information, that is common to
///   all occurrences of that product type). 
/// 
/// NOTE: The product representations are defined as
///   representation maps (at the level of the supertype IfcTypeProduct, which
///   gets assigned by an element occurrence instance through the
///   IfcShapeRepresentation.Item[1] being an
///   IfcMappedItem. 
///   A stair flight type is used to define the common properties of a certain
///   type of a stair flight that may be applied to many instances of that type to
///   assign a specific style. Stair flight types may be exchanged without being
///   already assigned to occurrences. 
///   The occurrences of the IfcStairFlightType are represented by
///   instances of IfcStairFlight. 
/// 
/// HISTORY: New entity in Release IFC2x
///   Edition 2.
class IfcStairFlightType : public IfcBuildingElementType {
public:
    /// Identifies the predefined types of a stair flight element from which the type required may be set.
    IfcStairFlightTypeEnum::IfcStairFlightTypeEnum PredefinedType() const;
    void setPredefinedType(IfcStairFlightTypeEnum::IfcStairFlightTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcBuildingElementType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcStairFlightTypeEnum; } return IfcBuildingElementType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcBuildingElementType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcStairFlightType (IfcAbstractEntity* e);
    IfcStairFlightType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcStairFlightTypeEnum::IfcStairFlightTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcStairFlightType > list;
};
/// Definition from IAI: A structural action is a structural activity that acts upon
/// a structural item or building element.
/// 
/// HISTORY  New entity in IFC 2x2.
/// IFC 2x4 change:  Attribute DestabilizingLoad made optional.  Attribute CausedBy deleted; use IfcRelAssignsToProduct via ReferencedBy instead.
/// 
/// Structural actions are grouped into either an IfcStructuralLoadGroup of predefined
/// type LOAD_GROUP or, more often, an IfcStructuralLoadCase.  This is accomplished via the
/// inverse relationship HasAssignments and an IfcRelAssignsToGroup relationship object.
/// IfcStructuralLoadGroup.LoadGroupFor or IfcStructuralLoadCase.LoadGroupFor respectively
/// refers to the structural analysis model(s) in which the loads are used.
/// 
/// It is furthermore possible to establish relationships between actions in one analysis model
/// and reactions in another analysis model which cause the actions.  For example, a support reaction
/// from one structural system may be taken over as a load onto another supporting structural system.
/// This is expressed by means of the inverse relationship ReferencedBy of the action and an
/// IfcRelAssignsToProduct relationship object.  IfcRelAssignsToProduct.Name is set to
/// 'Causes' and IfcRelAssignsToProduct.RelatedObjects refers to an instance of a subtype of
/// IfcStructuralReaction.
class IfcStructuralAction : public IfcStructuralActivity {
public:
    /// Indicates if this action may cause a stability problem. If it is 'FALSE', no further investigations regarding stability problems are necessary.
    bool DestabilizingLoad() const;
    void setDestabilizingLoad(bool v);
    /// Whether the optional attribute CausedBy is defined for this IfcStructuralAction
    bool hasCausedBy() const;
    IfcStructuralReaction* CausedBy() const;
    void setCausedBy(IfcStructuralReaction* v);
    virtual unsigned int getArgumentCount() const { return 11; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_BOOL; case 10: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcStructuralActivity::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::UNDEFINED; case 10: return Type::IfcStructuralReaction; } return IfcStructuralActivity::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "DestabilizingLoad"; case 10: return "CausedBy"; } return IfcStructuralActivity::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcStructuralAction (IfcAbstractEntity* e);
    IfcStructuralAction (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, IfcStructuralLoad* v8_AppliedLoad, IfcGlobalOrLocalEnum::IfcGlobalOrLocalEnum v9_GlobalOrLocal, bool v10_DestabilizingLoad, IfcStructuralReaction* v11_CausedBy);
    typedef IfcTemplatedEntityList< IfcStructuralAction > list;
};
/// Definition from IAI: An IfcStructuralConnection represents a structural connection object (node i.e. vertex connection, or edge connection, or surface connection) or supports.
/// 
/// HISTORY: New entity in IFC 2x2.
class IfcStructuralConnection : public IfcStructuralItem {
public:
    /// Whether the optional attribute AppliedCondition is defined for this IfcStructuralConnection
    bool hasAppliedCondition() const;
    /// Optional boundary conditions which define support conditions of this connection object, given in local coordinate directions of the connection object.  If left unspecified, the connection object is assumed to have no supports besides being connected with members.
    IfcBoundaryCondition* AppliedCondition() const;
    void setAppliedCondition(IfcBoundaryCondition* v);
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 7: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcStructuralItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 7: return Type::IfcBoundaryCondition; } return IfcStructuralItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 7: return "AppliedCondition"; } return IfcStructuralItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcRelConnectsStructuralMember >::ptr ConnectsStructuralMembers() const; // INVERSE IfcRelConnectsStructuralMember::RelatedStructuralConnection
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcStructuralConnection (IfcAbstractEntity* e);
    IfcStructuralConnection (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, IfcBoundaryCondition* v8_AppliedCondition);
    typedef IfcTemplatedEntityList< IfcStructuralConnection > list;
};
/// Definition from IAI: Instances of IfcStructuralCurveConnection describe edge 'nodes', i.e. edges where two or more surface members are joined, or edge supports.  Edge curves may be straight or curved.
/// 
/// HISTORY: New entity in IFC 2x2.
/// 
/// IFC 2x4 change:  Attribute Axis added, allowing for skewed supports.  Use definitions added.
/// 
/// Coordinate Systems:
/// 
/// See definitions at IfcStructuralItem.  The local coordinate system is established by the reference curve given by topology representation and by the attribute Axis.  The local x axis is parallel with the tangent on the reference curve.  The local z axis is located in the surface which is created by sweeping Axis along the reference curve and is directed according to Axis.  The local y axis is directed such that x,y,z form a right-handed Cartesian coordinate system.
/// 
/// Topology Use Definitions:
/// 
/// Instances of IfcStructuralCurveConnection shall have a topology representation which consists of one instance of IfcEdge or a subtype, representing the reference curve of the curve connection.  See definitions at IfcStructuralItem for further specifications.
/// 
/// Informal propositions:
/// 
/// The reference curve must not be parallel with Axis at any point within the curve connections's domain.
class IfcStructuralCurveConnection : public IfcStructuralConnection {
public:
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcStructuralConnection::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcStructuralConnection::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcStructuralConnection::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcStructuralCurveConnection (IfcAbstractEntity* e);
    IfcStructuralCurveConnection (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, IfcBoundaryCondition* v8_AppliedCondition);
    typedef IfcTemplatedEntityList< IfcStructuralCurveConnection > list;
};
/// Definition from IAI: Instances of IfcStructuralCurveMember describe edge members, i.e. structural analysis idealizations of beams, columns, rods etc..  Curve members may be straight or curved.
/// 
/// HISTORY: New entity in IFC 2x2.
/// 
/// IFC 2x4 change:  Attribute Axis and WHERE rule added.  Use definitions changed.
/// 
/// Coordinate Systems:
/// 
/// See definitions at IfcStructuralItem.  The local coordinate system is established by the reference curve given by topology representation and by the attribute Axis.  The local x axis is parallel with the tangent on the reference curve.  The local z axis is located in the surface which is created by sweeping Axis along the reference curve and is directed according to Axis.  The local y axis is directed such that x,y,z form a right-handed Cartesian coordinate system.
/// 
/// Material Use Definition
/// 
/// The material of direct instances IfcStructuralCurveMember (in contrast to instances of the subtype IfcStructuralCurveMemberVarying) is defined by IfcMaterialProfileSetUsage and attached by the IfcRelAssociatesMaterial.RelatingMaterial.  It is accessible by the inverse HasAssociations relationship.  Composite profile beams can be represented by refering to several IfcMaterialProfiles within the IfcMaterialProfileSet that is referenced from the IfcMaterialProfileSetUsage.  In case of tapered members, the material profile usage subtype IfcMaterialProfileSetUsageDual is used which specifies IfcMaterialProfileSets separately at the start and the end of the tapered member.
/// 
/// The material (IfcMaterial) in each IfcMaterialProfile(Set) is specified minimally by a name which corresponds with an agreed upon standardized structural material designation.  An external reference to the source which specifies the material designation should be provided.  Alternatively, structural material properties may be provided by means of IfcMechanicalMaterialProperties and IfcExtendedMaterialProperties.
/// 
/// The profile (IfcProfileDef) in each IfcMaterialProfile(Set) is specified minimally by a name which corresponds with an agreed upon standardized structural profile designation.  An external reference to the source which specifies the profile designation should be provided.  Alternatively or additionally, explicit profile geometry should be provided by using respective subtypes of IfcProfileDef.  Alternatively or additionally, structural profile properties may be provided by means of subtypes of IfcProfileProperties.
/// 
/// An IfcProfileDef is a two-dimensional geometric object with a xp,yp coordinate system.  The profile is inserted into the curve member model thus that the origin of xp,yp is located at the member's reference curve and that xp,yp are parallel with and directed like the local y,z.
/// 
/// NOTE   Due to convention in structural mechanics, axis names of IfcStructuralCurveMember differ from axis names of building elements like IfcBeamStandardCase:  The extrusion axis of IfcStructuralCurveMember is called x while the extrusion axis of IfcBeamStandardCase is called z.  Hence x,y,z of IfcStructuralCurveMember correspond with z,x,y of IfcBeamStandardCase.
/// 
/// If the profile is meant to be inserted centrically in terms of structural section properties, it is necessary that the origin of xp,yp is identical with the geometric centroid of the profile (commonly also called centre of gravity).  If subtypes of IfcParameterizedProfileDef are used which are only singly symmetric or are asymmetric, an explicit translation by IfcParameterizedProfileDef.Position.Location is required then.
/// 
/// If the profile is inserted at its geometric centroid, IfcMaterialProfileSetUsage.CardinalPoint shall be set to 10.
/// 
/// Otherwise, the profile is inserted eccentrically and a different cardinal point should be set accordingly.
/// 
/// NOTE   Another eccentricity model is available independently of eccentric profile specification:  The reference curve of the member may be located eccentrically relative to the reference points of the connected IfcStructuralPointConnections.  The connection relationship is then established by IfcRelConnectsWithEccentricity.  Whether one or the other or both eccentricity models may be used is subject to information requirements and local agreements.
/// 
/// Topology Use Definitions:
/// 
/// Direct instances of IfcStructuralCurveMember shall have a topology representation which consists of one instance of IfcEdge or a subtype, representing the reference curve of the curve member.  See definitions at IfcStructuralItem for further specifications.
/// 
/// Informal propositions:
/// 
/// The reference curve must not be parallel with Axis at any point within the curve member's domain.
class IfcStructuralCurveMember : public IfcStructuralMember {
public:
    /// Type of member with respect to its load carrying behavior in this analysis idealization.
    IfcStructuralCurveTypeEnum::IfcStructuralCurveTypeEnum PredefinedType() const;
    void setPredefinedType(IfcStructuralCurveTypeEnum::IfcStructuralCurveTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 7: return IfcUtil::Argument_ENUMERATION; } return IfcStructuralMember::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 7: return Type::IfcStructuralCurveTypeEnum; } return IfcStructuralMember::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 7: return "PredefinedType"; } return IfcStructuralMember::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcStructuralCurveMember (IfcAbstractEntity* e);
    IfcStructuralCurveMember (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, IfcStructuralCurveTypeEnum::IfcStructuralCurveTypeEnum v8_PredefinedType);
    typedef IfcTemplatedEntityList< IfcStructuralCurveMember > list;
};
/// Definition from IAI: Describes edge members with varying profile properties.  Each instance of IfcStructuralCurveMemberVarying is composed of two or more instances of IfcStructuralCurveMember with differing profile properties.  These subordinate members relate to the instance of IfcStructuralCurveMemberVarying by IfcRelAggregates.
/// 
/// NOTE   A curve member whose variation of profile properties can be sufficiently described by a start profile and an end profile (e.g. tapers) shall be modeled as a single direct instance of the supertype IfcStructuralCurveMember.
/// 
/// NOTE   It is recommended that structural activities (actions or reactions) are not connected with aggregated IfcStructuralCurveMemberVarying but only with the IfcStructuralCurveMembers in the aggregation.  That way, difficulties in interpretation of local coordinates are avoided.
/// 
/// HISTORY: New entity in IFC 2x2.
/// Use definition changed in IFC 2x4.
/// 
/// Coordinate Systems:
/// 
/// See definitions at IfcStructuralItem and IfcStructuralCurveMember.  The local coordinates of the aggregate are derived from those of its parts.  Length measures in local x direction of the aggregate depend on continuity and lengths of the parts.  The Axis of the aggregate shal be the same as the Axis of the part at the start of the aggregate.
/// 
/// Material Use Definition
/// 
/// Only the individual parts (direct instances of IfcStructuralCurveMember) carry material and profile information.
/// 
/// Topology Use Definitions:
/// 
/// Instances of IfcStructuralCurveMemberVarying may have a topology representation which contains a single IfcEdgeLoop, based upon the edges of the parts.
class IfcStructuralCurveMemberVarying : public IfcStructuralCurveMember {
public:
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcStructuralCurveMember::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcStructuralCurveMember::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcStructuralCurveMember::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcStructuralCurveMemberVarying (IfcAbstractEntity* e);
    IfcStructuralCurveMemberVarying (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, IfcStructuralCurveTypeEnum::IfcStructuralCurveTypeEnum v8_PredefinedType);
    typedef IfcTemplatedEntityList< IfcStructuralCurveMemberVarying > list;
};
/// Definition from IAI: Defines an action with constant value which is distributed over a curve.
/// 
/// HISTORY: New entity in IFC 2x2.
/// 
/// IFC 2x4 change:  Intermediate supertype IfcStructuralCurveAction inserted.  Derived attribute PredefinedType added.
/// 
/// NOTE  Like its supertype IfcStructuralCurveAction, this action type may also act on curved edges.
class IfcStructuralLinearAction : public IfcStructuralAction {
public:
    IfcProjectedOrTrueLengthEnum::IfcProjectedOrTrueLengthEnum ProjectedOrTrue() const;
    void setProjectedOrTrue(IfcProjectedOrTrueLengthEnum::IfcProjectedOrTrueLengthEnum v);
    virtual unsigned int getArgumentCount() const { return 12; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 11: return IfcUtil::Argument_ENUMERATION; } return IfcStructuralAction::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 11: return Type::IfcProjectedOrTrueLengthEnum; } return IfcStructuralAction::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 11: return "ProjectedOrTrue"; } return IfcStructuralAction::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcStructuralLinearAction (IfcAbstractEntity* e);
    IfcStructuralLinearAction (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, IfcStructuralLoad* v8_AppliedLoad, IfcGlobalOrLocalEnum::IfcGlobalOrLocalEnum v9_GlobalOrLocal, bool v10_DestabilizingLoad, IfcStructuralReaction* v11_CausedBy, IfcProjectedOrTrueLengthEnum::IfcProjectedOrTrueLengthEnum v12_ProjectedOrTrue);
    typedef IfcTemplatedEntityList< IfcStructuralLinearAction > list;
};

class IfcStructuralLinearActionVarying : public IfcStructuralLinearAction {
public:
    IfcShapeAspect* VaryingAppliedLoadLocation() const;
    void setVaryingAppliedLoadLocation(IfcShapeAspect* v);
    IfcTemplatedEntityList< IfcStructuralLoad >::ptr SubsequentAppliedLoads() const;
    void setSubsequentAppliedLoads(IfcTemplatedEntityList< IfcStructuralLoad >::ptr v);
    virtual unsigned int getArgumentCount() const { return 14; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 12: return IfcUtil::Argument_ENTITY_INSTANCE; case 13: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } return IfcStructuralLinearAction::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 12: return Type::IfcShapeAspect; case 13: return Type::IfcStructuralLoad; } return IfcStructuralLinearAction::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 12: return "VaryingAppliedLoadLocation"; case 13: return "SubsequentAppliedLoads"; } return IfcStructuralLinearAction::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcStructuralLinearActionVarying (IfcAbstractEntity* e);
    IfcStructuralLinearActionVarying (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, IfcStructuralLoad* v8_AppliedLoad, IfcGlobalOrLocalEnum::IfcGlobalOrLocalEnum v9_GlobalOrLocal, bool v10_DestabilizingLoad, IfcStructuralReaction* v11_CausedBy, IfcProjectedOrTrueLengthEnum::IfcProjectedOrTrueLengthEnum v12_ProjectedOrTrue, IfcShapeAspect* v13_VaryingAppliedLoadLocation, IfcTemplatedEntityList< IfcStructuralLoad >::ptr v14_SubsequentAppliedLoads);
    typedef IfcTemplatedEntityList< IfcStructuralLinearActionVarying > list;
};
/// Definition from IAI: The entity IfcStructuralLoadGroup is used to structure the
/// physical impacts.  By using the grouping features inherited from IfcGroup, instances of
/// IfcStructuralAction (or its subclasses) and of IfcStructuralLoadGroup can be used to
/// define load groups, load cases and load combinations.  (See also IfcLoadGroupTypeEnum.)
/// 
/// NOTE: Important functionality for the description of a load-bearing system
/// is derived from the existing IFC entity IfcGroup.  This class provides, via the relationship
/// class IfcRelAssignsToGroup, the needed grouping mechanism.  In this way, instances of
/// IfcStructuralAction belonging to a specific load group can be unambiguously determined.
/// 
/// NOTE: The relationship class IfcRelAssignsToGroupByFactor is
/// used to group load cases into load combinations.  The factor provided in this assignment relationship
/// is to applied together with the optional IfcStructuralLoadGroup.Coefficient.  Unlike this
/// coefficient which always affects the load group, the IfcRelAssignsToGroupByFactor.Factor is
/// specific for a load case—load combination pair.  As many instances of
/// IfcRelAssignsToGroupByFactor are used within one load combination as there are different
/// Factors to be applied to load cases in the load combination.
/// 
/// On the other hand, a load case may appear in more than one load combination
/// and can have a different Factor in each assignment by IfcRelAssignsToGroupByFactor.
/// 
/// HISTORY: New entity in IFC 2x2.
/// IFC 2x4 change: Subtype IfcStructuralLoadCase added.  Informal propositions and WHERE rule added.
/// Predefined type LOAD_COMBINATION_GROUP made obsolete and removed.
/// 
/// Informal propositions:
/// 
/// Load groups of type LOAD_GROUP shall only contain instances of IfcStructuralAction.
///   Load groups of type LOAD_CASE shall always be instantiated from the subtype IfcStructuralLoadCase,
///   not directly from the generic type IfcStructuralLoadGroup itself.
///   Instances of IfcStructuralLoadCase shall only contain instances of IfcStructuralAction
///   or/ and instances of IfcStructuralLoadGroup of type LOAD_GROUP.
///   Load groups of type LOAD_COMBINATION shall only contain instances of IfcStructuralLoadCase.
class IfcStructuralLoadGroup : public IfcGroup {
public:
    /// Selects a predefined type for the load group.  It can be differentiated between load groups, load cases, load combinations, or userdefined grouping levels.
    IfcLoadGroupTypeEnum::IfcLoadGroupTypeEnum PredefinedType() const;
    void setPredefinedType(IfcLoadGroupTypeEnum::IfcLoadGroupTypeEnum v);
    /// Type of actions in the group. Normally needed if 'PredefinedType' specifies a LOAD_CASE.
    IfcActionTypeEnum::IfcActionTypeEnum ActionType() const;
    void setActionType(IfcActionTypeEnum::IfcActionTypeEnum v);
    /// Source of actions in the group. Normally needed if 'PredefinedType' specifies a LOAD_CASE.
    IfcActionSourceTypeEnum::IfcActionSourceTypeEnum ActionSource() const;
    void setActionSource(IfcActionSourceTypeEnum::IfcActionSourceTypeEnum v);
    /// Whether the optional attribute Coefficient is defined for this IfcStructuralLoadGroup
    bool hasCoefficient() const;
    /// Load factor. If omitted, a factor is not yet known or not specified. A load factor of 1.0 shall be explicitly exported as Coefficient = 1.0.
    double Coefficient() const;
    void setCoefficient(double v);
    /// Whether the optional attribute Purpose is defined for this IfcStructuralLoadGroup
    bool hasPurpose() const;
    /// Description of the purpose of this instance. Among else, possible values of the Purpose of load combinations are 'SLS', 'ULS', 'ALS' to indicate serviceability, ultimate, or accidental limit state.
    std::string Purpose() const;
    void setPurpose(std::string v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 5: return IfcUtil::Argument_ENUMERATION; case 6: return IfcUtil::Argument_ENUMERATION; case 7: return IfcUtil::Argument_ENUMERATION; case 8: return IfcUtil::Argument_DOUBLE; case 9: return IfcUtil::Argument_STRING; } return IfcGroup::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 5: return Type::IfcLoadGroupTypeEnum; case 6: return Type::IfcActionTypeEnum; case 7: return Type::IfcActionSourceTypeEnum; case 8: return Type::IfcRatioMeasure; case 9: return Type::IfcLabel; } return IfcGroup::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 5: return "PredefinedType"; case 6: return "ActionType"; case 7: return "ActionSource"; case 8: return "Coefficient"; case 9: return "Purpose"; } return IfcGroup::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcStructuralResultGroup >::ptr SourceOfResultGroup() const; // INVERSE IfcStructuralResultGroup::ResultForLoadGroup
    IfcTemplatedEntityList< IfcStructuralAnalysisModel >::ptr LoadGroupFor() const; // INVERSE IfcStructuralAnalysisModel::LoadedBy
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcStructuralLoadGroup (IfcAbstractEntity* e);
    IfcStructuralLoadGroup (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcLoadGroupTypeEnum::IfcLoadGroupTypeEnum v6_PredefinedType, IfcActionTypeEnum::IfcActionTypeEnum v7_ActionType, IfcActionSourceTypeEnum::IfcActionSourceTypeEnum v8_ActionSource, boost::optional< double > v9_Coefficient, boost::optional< std::string > v10_Purpose);
    typedef IfcTemplatedEntityList< IfcStructuralLoadGroup > list;
};
/// Definition from IAI: Defines an action with constant value which is distributed over a surface.
/// 
/// HISTORY: New entity in IFC 2x2.
/// 
/// IFC 2x4 change:  Intermediate supertype IfcStructuralSurfaceAction inserted.  Derived attribute PredefinedType added.
/// 
/// NOTE  Like its supertype IfcStructuralSurfaceAction, this action type may also act on curved faces.
class IfcStructuralPlanarAction : public IfcStructuralAction {
public:
    IfcProjectedOrTrueLengthEnum::IfcProjectedOrTrueLengthEnum ProjectedOrTrue() const;
    void setProjectedOrTrue(IfcProjectedOrTrueLengthEnum::IfcProjectedOrTrueLengthEnum v);
    virtual unsigned int getArgumentCount() const { return 12; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 11: return IfcUtil::Argument_ENUMERATION; } return IfcStructuralAction::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 11: return Type::IfcProjectedOrTrueLengthEnum; } return IfcStructuralAction::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 11: return "ProjectedOrTrue"; } return IfcStructuralAction::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcStructuralPlanarAction (IfcAbstractEntity* e);
    IfcStructuralPlanarAction (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, IfcStructuralLoad* v8_AppliedLoad, IfcGlobalOrLocalEnum::IfcGlobalOrLocalEnum v9_GlobalOrLocal, bool v10_DestabilizingLoad, IfcStructuralReaction* v11_CausedBy, IfcProjectedOrTrueLengthEnum::IfcProjectedOrTrueLengthEnum v12_ProjectedOrTrue);
    typedef IfcTemplatedEntityList< IfcStructuralPlanarAction > list;
};

class IfcStructuralPlanarActionVarying : public IfcStructuralPlanarAction {
public:
    IfcShapeAspect* VaryingAppliedLoadLocation() const;
    void setVaryingAppliedLoadLocation(IfcShapeAspect* v);
    IfcTemplatedEntityList< IfcStructuralLoad >::ptr SubsequentAppliedLoads() const;
    void setSubsequentAppliedLoads(IfcTemplatedEntityList< IfcStructuralLoad >::ptr v);
    virtual unsigned int getArgumentCount() const { return 14; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 12: return IfcUtil::Argument_ENTITY_INSTANCE; case 13: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } return IfcStructuralPlanarAction::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 12: return Type::IfcShapeAspect; case 13: return Type::IfcStructuralLoad; } return IfcStructuralPlanarAction::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 12: return "VaryingAppliedLoadLocation"; case 13: return "SubsequentAppliedLoads"; } return IfcStructuralPlanarAction::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcStructuralPlanarActionVarying (IfcAbstractEntity* e);
    IfcStructuralPlanarActionVarying (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, IfcStructuralLoad* v8_AppliedLoad, IfcGlobalOrLocalEnum::IfcGlobalOrLocalEnum v9_GlobalOrLocal, bool v10_DestabilizingLoad, IfcStructuralReaction* v11_CausedBy, IfcProjectedOrTrueLengthEnum::IfcProjectedOrTrueLengthEnum v12_ProjectedOrTrue, IfcShapeAspect* v13_VaryingAppliedLoadLocation, IfcTemplatedEntityList< IfcStructuralLoad >::ptr v14_SubsequentAppliedLoads);
    typedef IfcTemplatedEntityList< IfcStructuralPlanarActionVarying > list;
};
/// Definition from IAI: Defines an action which acts on a point.
/// A point action is typically connected with a point connection.
/// It may also be connected with a curve member or curve connection,
/// or surface member or surface connection.
/// 
/// HISTORY: New entity in IFC 2x2.
/// 
/// IFC 2x4 change:  Attributes in the supertypes
/// IfcStructuralActivity and IfcStructuralAction changed.  Use definitions changed,
/// informal propositions added.
/// 
/// Coordinate Systems:
/// 
/// See definitions at IfcStructuralActivity.
/// 
/// Topology Use Definitions:
/// 
/// Standard Case:
/// If connected with a point item, instances of IfcStructuralPointAction
/// shall not have an ObjectPlacement nor a Representation.
/// It is implied that the placement and representation of the action is the same
/// as the structural item.
/// 
/// Special Case 1:
/// If connected with a curve item or surface item, instances of IfcStructuralPointAction
/// shall have an ObjectPlacement and Representation, containing an IfcVertexPoint.
/// See IfcStructuralActivity for further definitions.
/// 
/// NOTE In order to model concentrated actions on a curve or surface item,
/// IfcStructuralCurveAction or IfcStructuralSurfaceAction of type DISCRETE is
/// preferable since they do not require an extra topology representation in this case.
/// An IfcStructuralPointAction should be used for a concentrated action on a curve or surface
/// item only when an explicit vertex point representation is actually desired.
/// 
/// Special Case 2:
/// If not connected with a structural item (which may happen in an incomplete or
/// conceptual model), a point action should have an ObjectPlacement and
/// Representation, containing an IfcVertexPoint.
/// See IfcStructuralActivity for further definitions.
/// 
/// Informal propositions:
/// 
/// SELF\IfcStructuralActivity.AppliedLoad shall be of type
///   IfcStructuralLoadSingleForce or
///   IfcStructuralLoadSingleDisplacement.
class IfcStructuralPointAction : public IfcStructuralAction {
public:
    virtual unsigned int getArgumentCount() const { return 11; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcStructuralAction::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcStructuralAction::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcStructuralAction::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcStructuralPointAction (IfcAbstractEntity* e);
    IfcStructuralPointAction (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, IfcStructuralLoad* v8_AppliedLoad, IfcGlobalOrLocalEnum::IfcGlobalOrLocalEnum v9_GlobalOrLocal, bool v10_DestabilizingLoad, IfcStructuralReaction* v11_CausedBy);
    typedef IfcTemplatedEntityList< IfcStructuralPointAction > list;
};
/// Definition from IAI: Instances of IfcStructuralPointConnection describe structural nodes or point supports.
/// 
/// HISTORY: New entity in IFC 2x2.
/// 
/// IFC 2x4 change:  Attribute ConditionCoordinateSystem added, allowing for skewed supports.  Use definitions added.
/// 
/// Coordinate Systems:
/// 
/// See definitions at IfcStructuralItem.  The local coordinate system is established by the reference point given by topology representation and by the attribute ConditionCoordinateSystem.
/// 
/// Topology Use Definitions:
/// 
/// Instances of IfcStructuralPointConnection shall have a topology representation which consists of one IfcVertexPoint, representing the reference point of the point connection.  See definitions at IfcStructuralItem for further specifications.
class IfcStructuralPointConnection : public IfcStructuralConnection {
public:
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcStructuralConnection::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcStructuralConnection::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcStructuralConnection::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcStructuralPointConnection (IfcAbstractEntity* e);
    IfcStructuralPointConnection (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, IfcBoundaryCondition* v8_AppliedCondition);
    typedef IfcTemplatedEntityList< IfcStructuralPointConnection > list;
};
/// Definition from IAI: Defines a reaction which occurs at a point.
/// A point reaction is typically connected with a point connection.
/// It may also be connected with a curve member or curve connection,
/// or surface member or surface connection.
/// 
/// HISTORY: New entity in IFC 2x2.
/// 
/// IFC 2x4 change:  Attributes in the supertypes IfcStructuralActivity and IfcStructuralReaction changed.  Use definitions changed, informal propositions added.
/// 
/// Coordinate Systems:
/// 
/// See definitions at IfcStructuralActivity.
/// 
/// Topology Use Definitions:
/// 
/// Standard Case:
/// If connected with a point item, instances of IfcStructuralPointReaction
/// shall not have an ObjectPlacement nor a Representation.
/// It is implied that the placement and representation of the reaction is the same
/// as the structural item.
/// 
/// Special Case 1:
/// If connected with a curve item or surface item, instances of IfcStructuralPointReaction
/// shall have an ObjectPlacement and Representation, containing an IfcVertexPoint.
/// See IfcStructuralActivity for further definitions.
/// 
/// NOTE In order to model concentrated reactions on a curve or surface item,
/// IfcStructuralCurveReaction or IfcStructuralSurfaceAction of type DISCRETE is
/// preferable since they do not require an extra topology representation in this case.
/// An IfcStructuralPointReaction should be used for a concentrated reaction on a curve or surface
/// item only when an explicit vertex point representation is actually desired.
/// 
/// Special Case 2:
/// If not connected with a structural item (which may happen in an incomplete or
/// conceptual model), a point action should have an ObjectPlacement and
/// Representation, containing an IfcVertexPoint.
/// See IfcStructuralActivity for further definitions.
/// 
/// Informal propositions:
/// 
/// SELF\IfcStructuralActivity.AppliedLoad shall be of type
///   IfcStructuralLoadSingleForce or
///   IfcStructuralLoadSingleDisplacement.
class IfcStructuralPointReaction : public IfcStructuralReaction {
public:
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcStructuralReaction::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcStructuralReaction::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcStructuralReaction::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcStructuralPointReaction (IfcAbstractEntity* e);
    IfcStructuralPointReaction (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, IfcStructuralLoad* v8_AppliedLoad, IfcGlobalOrLocalEnum::IfcGlobalOrLocalEnum v9_GlobalOrLocal);
    typedef IfcTemplatedEntityList< IfcStructuralPointReaction > list;
};
/// Definition from IAI: Instances of the entity IfcStructuralResultGroup are used to group results of structural analysis calculations and to capture the connection to the underlying basic load group.  The basic functionality for grouping inherited from IfcGroup is used to collect instances from IfcStructuralReaction or its respective subclasses.
/// 
/// HISTORY: New entity in IFC 2x2.
/// IFC 2x4 change: WHERE rule added.
class IfcStructuralResultGroup : public IfcGroup {
public:
    /// Specifies the analysis theory used to obtain the respective results.
    IfcAnalysisTheoryTypeEnum::IfcAnalysisTheoryTypeEnum TheoryType() const;
    void setTheoryType(IfcAnalysisTheoryTypeEnum::IfcAnalysisTheoryTypeEnum v);
    /// Whether the optional attribute ResultForLoadGroup is defined for this IfcStructuralResultGroup
    bool hasResultForLoadGroup() const;
    /// Reference to an instance of IfcStructuralLoadGroup for which this instance represents the result.
    IfcStructuralLoadGroup* ResultForLoadGroup() const;
    void setResultForLoadGroup(IfcStructuralLoadGroup* v);
    /// This value allows to easily recognize whether a linear analysis has been applied (allowing the superposition of analysis results).
    bool IsLinear() const;
    void setIsLinear(bool v);
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 5: return IfcUtil::Argument_ENUMERATION; case 6: return IfcUtil::Argument_ENTITY_INSTANCE; case 7: return IfcUtil::Argument_BOOL; } return IfcGroup::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 5: return Type::IfcAnalysisTheoryTypeEnum; case 6: return Type::IfcStructuralLoadGroup; case 7: return Type::UNDEFINED; } return IfcGroup::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 5: return "TheoryType"; case 6: return "ResultForLoadGroup"; case 7: return "IsLinear"; } return IfcGroup::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcStructuralAnalysisModel >::ptr ResultGroupFor() const; // INVERSE IfcStructuralAnalysisModel::HasResults
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcStructuralResultGroup (IfcAbstractEntity* e);
    IfcStructuralResultGroup (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcAnalysisTheoryTypeEnum::IfcAnalysisTheoryTypeEnum v6_TheoryType, IfcStructuralLoadGroup* v7_ResultForLoadGroup, bool v8_IsLinear);
    typedef IfcTemplatedEntityList< IfcStructuralResultGroup > list;
};
/// Definition from IAI: Instances of IfcStructuralSurfaceConnection describe face 'nodes', i.e. faces where two or more surface members are joined, or face supports.  Face surfaces may be planar or curved.
/// 
/// HISTORY: New entity in IFC 2x2.
/// IFC 2x4 change:  Use definitions added.
/// 
/// Coordinate Systems:
/// 
/// See definitions at IfcStructuralItem.  The local coordinate system is established by the reference surface given by topology representation.
/// 
/// Topology Use Definitions:
/// 
/// Instances of IfcStructuralSurfaceConnection shall have a topology representation which consists of one IfcFaceSurface, representing the reference surface of the surface connection.  See definitions at IfcStructuralItem for further specifications.
class IfcStructuralSurfaceConnection : public IfcStructuralConnection {
public:
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcStructuralConnection::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcStructuralConnection::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcStructuralConnection::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcStructuralSurfaceConnection (IfcAbstractEntity* e);
    IfcStructuralSurfaceConnection (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, IfcBoundaryCondition* v8_AppliedCondition);
    typedef IfcTemplatedEntityList< IfcStructuralSurfaceConnection > list;
};
/// IfcSubContractResource is a construction resource needed in a construction process that represents a sub-contractor.  
/// 
/// HISTORY: New Entity in IFC Release 2.0.  Base type and documentation extended in IFC 2x4.
/// 
/// IFC2x4 CHANGE: The attribute SubContractor has been deleted; use IfcRelAssignsToResource to assign an IfcActor to fulfill the role as the subcontractor.  The attribute JobDescription has been deleted; use LongDescription to describe the job.
/// 
/// An IfcSubContractResource can be used in cost estimating and work planning with or without specifying the subcontractor and contract agreement. 
/// The purpose of an IfcSubContractResource is to indicate work of a particular type that is that is to be engaged through the use of a sub-contract. It's aim is to identify the description of the sub-contract work required. It can be used to identify the generic type of sub-contract resource that is required for a purpose without having to be specific about the actor (person or organization) providing the resource occurrence. It may be particularly useful when creating an overall plan for a process or processes. For instance, within maintenance or work planning there may be a known task that needs to be done which is planned to require an 'insulation specialist'. 
/// A subcontract resource may be described at various stages and levels of detail through its assignments:
/// 
/// Subcontract resource designated for particular tasks
/// Actors identified to request bids
/// Cost schedules (bids) received from actors
/// Project order (work order, change order, etc.) executed
/// 
/// Use definitions for composition, assignment, constraints, time series, and baselines are described at the base type IfcConstructionResource.
/// 
/// Type use definition
/// IfcSubContractResource defines the occurrence of any subcontract resource; common information about subcontract resource types is handled by IfcSubContractResourceType.  The IfcSubContractResourceType (if present) may establish the common type name, common properties, and common productivities for various task types using IfcRelAssignsToProcess.  The IfcSubContractResourceType is attached using the IfcRelDefinesByType.RelatingType objectified relationship and is accessible by the inverse IsTypedBy attribute.
/// 
/// Assignment use definition
/// In addition to assignments specified at the base class IfcConstructionResource, a subcontract resource may have assignments of its own using IfcRelAssignsToResource where RelatingResource refers to the IfcSubContractResource and RelatedObjects contains one or more IfcActor, IfcCostSchedule, and/or IfcWorkOrder objects as shown in Figure 195.  An IfcActor indicates a specific organization to be considered to fulfill the resource or invited to bid on the resource.  An IfcCostSchedule indicates a bid or price quote made on behalf of an organization.  An IfcProjectOrder indicates a specific work order committed to fulfill the resource.
/// 
/// Figure 195 — Subcontract assignment use
class IfcSubContractResource : public IfcConstructionResource {
public:
    /// Whether the optional attribute SubContractor is defined for this IfcSubContractResource
    bool hasSubContractor() const;
    IfcActorSelect* SubContractor() const;
    void setSubContractor(IfcActorSelect* v);
    /// Whether the optional attribute JobDescription is defined for this IfcSubContractResource
    bool hasJobDescription() const;
    std::string JobDescription() const;
    void setJobDescription(std::string v);
    virtual unsigned int getArgumentCount() const { return 11; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENTITY_INSTANCE; case 10: return IfcUtil::Argument_STRING; } return IfcConstructionResource::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcActorSelect; case 10: return Type::IfcText; } return IfcConstructionResource::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "SubContractor"; case 10: return "JobDescription"; } return IfcConstructionResource::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcSubContractResource (IfcAbstractEntity* e);
    IfcSubContractResource (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, boost::optional< std::string > v6_ResourceIdentifier, boost::optional< std::string > v7_ResourceGroup, boost::optional< IfcResourceConsumptionEnum::IfcResourceConsumptionEnum > v8_ResourceConsumption, IfcMeasureWithUnit* v9_BaseQuantity, IfcActorSelect* v10_SubContractor, boost::optional< std::string > v11_JobDescription);
    typedef IfcTemplatedEntityList< IfcSubContractResource > list;
};
/// The flow controller type IfcSwitchingDeviceType defines commonly shared information for occurrences of switching devices.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a switching device specification (i.e. the specific product information, that is common to all occurrences of that product type).  Switching Device types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcSwitchingDeviceType are represented by instances of IfcSwitchingDevice. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcFlowControllerType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_SwitchingDeviceTypeCommon 
/// 
/// The following property set definitions are applicable to this entity according to the PredefinedType attribute:  
/// Pset_ElectricalDeviceCommon 
/// Pset_SwitchingDeviceTypeContactor (CONTACTOR) 
/// Pset_SwitchingDeviceTypeDimmerSwitch (DIMMERSWITCH) 
/// Pset_SwitchingDeviceTypeEmergencyStop (EMERGENCYSTOP) 
/// Pset_SwitchingDeviceTypeKeypad (KEYPAD) 
/// Pset_SwitchingDeviceTypeMomentarySwitch (MOMENTARYSWITCH) 
/// Pset_SwitchingDeviceTypeSelectorSwitch (SELECTORSWITCH) 
/// Pset_SwitchingDeviceTypeStarter (STARTER) 
/// Pset_SwitchingDeviceTypeSwitchDisconnector (SWITCHDISCONNECTOR) 
/// Pset_SwitchingDeviceTypeToggleSwitch (TOGGLESWITCH) 
/// 
/// Material Use Definition 
/// The material of the IfcSwitchingDeviceType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Casing': Material from which the casing is constructed. 
/// 'Conductor': Material from which the conductors are constructed. 
/// 'Surface': Material from which the switch surface is constructed. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcSwitchingDeviceType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcSwitchingDevice for standard port definitions.
class IfcSwitchingDeviceType : public IfcFlowControllerType {
public:
    /// Identifies the predefined types of switch from which the type required may be set.
    IfcSwitchingDeviceTypeEnum::IfcSwitchingDeviceTypeEnum PredefinedType() const;
    void setPredefinedType(IfcSwitchingDeviceTypeEnum::IfcSwitchingDeviceTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcFlowControllerType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcSwitchingDeviceTypeEnum; } return IfcFlowControllerType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcFlowControllerType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcSwitchingDeviceType (IfcAbstractEntity* e);
    IfcSwitchingDeviceType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcSwitchingDeviceTypeEnum::IfcSwitchingDeviceTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcSwitchingDeviceType > list;
};
/// Definition from IAI: Organized combination of
///   related parts within an AEC product, composed for a common
///   purpose or function or to provide a service. System is
///   essentially a functionally related aggregation of products.
///   The grouping relationship to one or several instances of
///   IfcProduct (the system members) is handled by
///   IfcRelAssignsToGroup.
/// 
/// NOTE: The use of IfcSystem often
///   applies to the representation of building services related
///   systems, such as the piping system, cold water system, etc.
///   Members within such a system may or may not be connected
///   using the connectivity related entities (e.g. through
///   IfcPort).
/// 
/// HISTORY: New entity in
///   IFC Release 1.0
class IfcSystem : public IfcGroup {
public:
    virtual unsigned int getArgumentCount() const { return 5; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcGroup::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcGroup::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcGroup::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcRelServicesBuildings >::ptr ServicesBuildings() const; // INVERSE IfcRelServicesBuildings::RelatingSystem
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcSystem (IfcAbstractEntity* e);
    IfcSystem (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType);
    typedef IfcTemplatedEntityList< IfcSystem > list;
};
/// The flow storage device type IfcTankType defines commonly shared information for occurrences of tanks.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a tank specification (i.e. the specific product information, that is common to all occurrences of that product type).  Tank types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcTankType are represented by instances of IfcTank. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcFlowStorageDeviceType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_TankTypeCommon 
/// 
/// The following property set definitions are applicable to this entity according to the PredefinedType attribute:  
/// Pset_TankTypeExpansion (EXPANSION) 
/// Pset_TankTypePreformed (PREFORMED) 
/// Pset_TankTypePressureVessel (PRESSUREVESSEL) 
/// Pset_TankTypeSectional (SECTIONAL) 
/// 
/// Material Use Definition 
/// The material of the IfcTankType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Body': The primary material from which the object is constructed. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcTankType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcTank for standard port definitions.
class IfcTankType : public IfcFlowStorageDeviceType {
public:
    /// Defines the type of tank.
    IfcTankTypeEnum::IfcTankTypeEnum PredefinedType() const;
    void setPredefinedType(IfcTankTypeEnum::IfcTankTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcFlowStorageDeviceType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcTankTypeEnum; } return IfcFlowStorageDeviceType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcFlowStorageDeviceType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcTankType (IfcAbstractEntity* e);
    IfcTankType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcTankTypeEnum::IfcTankTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcTankType > list;
};

class IfcTimeSeriesSchedule : public IfcControl {
public:
    /// Whether the optional attribute ApplicableDates is defined for this IfcTimeSeriesSchedule
    bool hasApplicableDates() const;
    IfcEntityList::ptr ApplicableDates() const;
    void setApplicableDates(IfcEntityList::ptr v);
    IfcTimeSeriesScheduleTypeEnum::IfcTimeSeriesScheduleTypeEnum TimeSeriesScheduleType() const;
    void setTimeSeriesScheduleType(IfcTimeSeriesScheduleTypeEnum::IfcTimeSeriesScheduleTypeEnum v);
    IfcTimeSeries* TimeSeries() const;
    void setTimeSeries(IfcTimeSeries* v);
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 5: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 6: return IfcUtil::Argument_ENUMERATION; case 7: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcControl::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 5: return Type::IfcDateTimeSelect; case 6: return Type::IfcTimeSeriesScheduleTypeEnum; case 7: return Type::IfcTimeSeries; } return IfcControl::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 5: return "ApplicableDates"; case 6: return "TimeSeriesScheduleType"; case 7: return "TimeSeries"; } return IfcControl::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcTimeSeriesSchedule (IfcAbstractEntity* e);
    IfcTimeSeriesSchedule (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, boost::optional< IfcEntityList::ptr > v6_ApplicableDates, IfcTimeSeriesScheduleTypeEnum::IfcTimeSeriesScheduleTypeEnum v7_TimeSeriesScheduleType, IfcTimeSeries* v8_TimeSeries);
    typedef IfcTemplatedEntityList< IfcTimeSeriesSchedule > list;
};
/// The energy conversion device type IfcTransformerType defines commonly shared information for occurrences of transformers.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a transformer specification (i.e. the specific product information, that is common to all occurrences of that product type).  Transformer types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcTransformerType are represented by instances of IfcTransformer. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcEnergyConversionDeviceType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_ElectricalDeviceCommon 
/// Pset_TransformerTypeCommon 
/// 
/// Material Use Definition 
/// The material of the IfcTransformerType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Casing': Material from which the casing is constructed. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcTransformerType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcTransformer for standard port definitions.
class IfcTransformerType : public IfcEnergyConversionDeviceType {
public:
    /// Identifies the predefined types of transformer from which the type required may be set.
    IfcTransformerTypeEnum::IfcTransformerTypeEnum PredefinedType() const;
    void setPredefinedType(IfcTransformerTypeEnum::IfcTransformerTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcEnergyConversionDeviceType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcTransformerTypeEnum; } return IfcEnergyConversionDeviceType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcEnergyConversionDeviceType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcTransformerType (IfcAbstractEntity* e);
    IfcTransformerType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcTransformerTypeEnum::IfcTransformerTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcTransformerType > list;
};
/// Definition from IAI: Generalization of all transport
/// related objects that move people, animals or goods within a
/// building or building complex. The IfcTransportElement
/// defines the occurrence of a transport element, that (if given),
/// is expressed by the IfcTransportElementType.
/// EXAMPLE Transportation elements include
/// elevator (lift), escalator, moving walkway, etc.
/// NOTE More detailed equipment that may be a part of a
/// transportation device, like a lifting hook, is defined as
/// IfcDiscreteAccessory
/// Depending on local classification systems transport elements
/// and transportation systems in buildings are either considered as
/// part of a building system, or as part of a building service
/// system. Within IFC they are considered as part of a building
/// system and may have to be mapped appropriately.
/// HISTORY New entity in
/// IFC Release 2x.
/// IFC2x PLATFORM CHANGE The attribute
/// PredefinedType (previously OperationType) is made
/// optional.
/// Type Use Definition
/// IfcTransportElement defines the occuurence of any
/// transportation device, common information about transportation
/// device types (or styles) is handled by
/// IfcTransportElementType. The
/// IfcTransportElementType (if present) may establish the
/// commonÿtype name, usage (or predefined) type, common material
/// layer set, common set of properties and common shape
/// representations (using IfcRepresentationMap). The
/// IfcTransportElementType is attached using the
/// IfcRelDefinedByType.RelatingType objectified relationship
/// and is accessible by the inverse IsTypedBy attribute.
/// If no IfcTransportElementType is attachedÿ(i.e. if only
/// occurrence information is given) the PredefinedType should
/// be provided. If set to .USERDEFINED. a user defined value can be
/// provided by the ObjectType attribute.
/// Property Set Use Definition:
/// The property sets relating to the IfcTransportElement
/// are defined by the IfcPropertySet and attached by the
/// IfcRelDefinesByProperties relationship. It is accessible
/// by the inverse IsDefinedBy relationship. The following
/// property set definitions specific to the
/// IfcTransportElement are part of this IFC release:
/// 
/// Pset_TransportElementCommon: common property
/// set for all transport element occurrences
/// 
/// Pset_TransportElementElevator: specific
/// property set for all occurrences of transport elements with the
/// PredefinedType: ELEVATOR
/// 
/// Containment Use Definition
/// The IfcTransportElement, as any subtype of
/// IfcElement, may have a hierarchical spatial containment
/// relationships that is mandatory in most implementation
/// scenarios.
/// 
/// The IfcTransportElement is placed within the project
/// spatial hierarchy using the objectified relationship
/// IfcRelContainedInSpatialStructure, refering to it by its
/// inverse attribute SELF\IfcElement.ContainedInStructure.
/// Subtypes ofÿIfcSpatialStructureElement are valid spatial
/// containers, with IfcBuilding being the default
/// container.
/// 
/// Geometry Use Definitions:
/// The geometric representation of IfcTransportElement is
/// given by the IfcProductDefinitionShape, allowing multiple
/// geometric representation.
/// Local Placement
/// The local placement for IfcTransportElement is defined
/// in its supertype IfcProduct. It is defined by the
/// IfcLocalPlacement, which defines the local coordinate
/// system that is referenced by all geometric representations.
/// 
/// The PlacementRelTo relationship of
/// IfcLocalPlacement shall point (if given) to the local
/// placement of the same IfcSpatialStructureElement , which
/// is used in the ContainedInStructure inverse attribute, or
/// to a spatial structure element at a higher level, referenced by
/// that.
/// If the relative placement is not used, the absolute placement
/// is defined within the world coordinate system.
/// 
/// SurfaceModel Representation
/// Any IfcTransportElement (so far no further constraints
/// are defined at the level of its subtypes) may be represented as a
/// single or multiple surface models, based on either shell or face
/// based models. Then the following attribute values for the
/// IfcShapeRepresentation holding this geometric
/// representation shall be used:
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'SurfaceModel'
/// 
/// Brep Representation
/// Any IfcTransportElement (so far no further constraints
/// are defined at the level of its subtypes) may be represented as a
/// single or multiple Boundary Representation elements (which are
/// restricted to faceted Brep with or without voids). Then the
/// following attribute values for the IfcShapeRepresentation
/// holding this geometric representation shall be used:
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'Brep'
/// 
/// MappedRepresentation
/// The mapped item, IfcMappedItem, should be used if
/// appropriate as it allows for reusing the geometry definition of
/// the property element type at occurrences of the same equipement
/// type. Then the following attribute values for the
/// IfcShapeRepresentation holding this geometric
/// representation shall be used:
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'MappedRepresentation'
class IfcTransportElement : public IfcElement {
public:
    /// Whether the optional attribute OperationType is defined for this IfcTransportElement
    bool hasOperationType() const;
    IfcTransportElementTypeEnum::IfcTransportElementTypeEnum OperationType() const;
    void setOperationType(IfcTransportElementTypeEnum::IfcTransportElementTypeEnum v);
    /// Whether the optional attribute CapacityByWeight is defined for this IfcTransportElement
    bool hasCapacityByWeight() const;
    /// Capacity of the transport element measured by weight.
    double CapacityByWeight() const;
    void setCapacityByWeight(double v);
    /// Whether the optional attribute CapacityByNumber is defined for this IfcTransportElement
    bool hasCapacityByNumber() const;
    /// Capacity of the transportation element measured in numbers of person.
    double CapacityByNumber() const;
    void setCapacityByNumber(double v);
    virtual unsigned int getArgumentCount() const { return 11; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; case 9: return IfcUtil::Argument_DOUBLE; case 10: return IfcUtil::Argument_DOUBLE; } return IfcElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcTransportElementTypeEnum; case 9: return Type::IfcMassMeasure; case 10: return Type::IfcCountMeasure; } return IfcElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "OperationType"; case 9: return "CapacityByWeight"; case 10: return "CapacityByNumber"; } return IfcElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcTransportElement (IfcAbstractEntity* e);
    IfcTransportElement (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcTransportElementTypeEnum::IfcTransportElementTypeEnum > v9_OperationType, boost::optional< double > v10_CapacityByWeight, boost::optional< double > v11_CapacityByNumber);
    typedef IfcTemplatedEntityList< IfcTransportElement > list;
};
/// Definition from ISO/CD 10303-42:1992:
/// A trimmed curve is a bounded curve which is created by taking a selected
/// portion, between two identified points, of the associated basis curve.
/// The basis curve itself is unaltered and more than one trimmed curve may
/// reference the same basis curve. Trimming points for the curve may be
/// identified by:
///   parametric value  geometric
/// position  both of the above 
/// At least one of these shall be specified at each
/// end of the
/// curve. The SenseAgreement makes it possible to
/// unambiguously define any segment of a closed curve such as a circle.
/// The combinations of sense and ordered end points make it possible to
/// define four distinct directed segments connecting two different points
/// on a circle or other closed curve. For this purpose cyclic properties
/// of the parameter range are assumed; for example, 370 degrees is
/// equivalent to 10 degrees. 
/// The IfcTrimmedCurve has a parameterization
/// which is inherited from the particular basis curve reference. More
/// precisely the parameter s of the trimmed curve is derived from the
/// parameter of the basis curve as follows: 
///   if SenseAgreement is TRUE: s
/// = t - t1  if SenseAgreement
/// is FALSE: s
/// = t2 - t 
/// In the above equations t1 is
/// the value
/// given by Trim1 or the parameter value corresponding
/// to point 1 and t2 is the value given by Trim2
/// or the parameter value corresponding to point 2. The resultant IfcTrimmedCurve
/// has a parameter ranging from 0 at the first trimming point to |t2
/// - t1| at the second trimming point. 
///   NOTE In case
/// of a closed curve,
/// it may be necessary to increment t1 or t2 by the parametric length for
/// consistency with the sense flag.
/// 
/// NOTE Corresponding ISO 10303 entity: trimmed_curve; As a further IFC restriction, an IfcTrimmedCurve should only trim a IfcLine or IfcConic. Please refer to ISO/IS 10303-42:1994, p. 54 for the final definition of the formal standard.
/// 
/// HISTORY New class in IFC Release 1.0
/// 
/// Informal Propositions:
///   Where both the parameter value and the Cartesian
/// point
/// exist for Trim1 and Trim2 they
/// shall be consistent. (i.e., the BasisCurve
/// evaluated at the parameter value shall coincide with the specified
/// point). When a Cartesian point is specified by Trim1
/// or by Trim2 it shall lie on the BasisCurve.
/// Except the case of a closed BasisCurve
/// where both parameter 1 and parameter 2 exist, they shall be consistent
/// with the sense flag, i.e., (sense = parameter 1 < parameter 2). Or, for every open curve where both
/// parameter 1 and parameter 2 exist, they shall be consistent with the SenseAgreement,
/// i.e., SenseAgreement = (parameter 1 <
/// parameter 2). If both parameter 1
/// and parameter 2 exist, then parameter 1
/// <> parameter 2. For a
/// closed base curve, e.g. IfcCircle or IfcEllipse,
/// this also applies to the cyclic properties, as 360' is equal to 0',
/// parameter 1 = 360' and parameter 2 = 0' are treated as being equal and
/// therefore violating this proposition. When
/// a parameter value is specified by Trim1
/// or Trim2 it shall lie within the parametric range
/// of the BasisCurve.
/// Additional illustration from IAI:
///   The
/// figure above shows the four arcs (dashed blue and
/// green lines with arrow showing different orientations) that can be
/// defined by the same BasisCurve (of type IfcCircle)
/// and the same trimming points (given by Cartesian points and parameter
/// values) by using different assignments to Trim1 and
/// Trim2 and SenseAgreement.  
/// Note: Since the BasisCurve is closed (type IfcCircle),
/// the exception of the informal proposition IP3 applies, i.e. the sense
/// flag is not
/// required to be consistent with the parameter values of Trim1
/// and Trim1, so the rule (sense = parameter 1
/// < parameter 2) may not be fulfilled.
class IfcTrimmedCurve : public IfcBoundedCurve {
public:
    /// The curve to be trimmed. For curves with multiple representations any parameter values given as Trim1 or Trim2 refer to the master representation of the BasisCurve only.
    IfcCurve* BasisCurve() const;
    void setBasisCurve(IfcCurve* v);
    /// The first trimming point which may be specified as a Cartesian point, as a real parameter or both.
    IfcEntityList::ptr Trim1() const;
    void setTrim1(IfcEntityList::ptr v);
    /// The second trimming point which may be specified as a Cartesian point, as a real parameter or both.
    IfcEntityList::ptr Trim2() const;
    void setTrim2(IfcEntityList::ptr v);
    /// Flag to indicate whether the direction of the trimmed curve agrees with or is opposed to the direction of the basis curve.
    bool SenseAgreement() const;
    void setSenseAgreement(bool v);
    /// Where both parameter and point are present at either end of the curve this indicates the preferred form.
    IfcTrimmingPreference::IfcTrimmingPreference MasterRepresentation() const;
    void setMasterRepresentation(IfcTrimmingPreference::IfcTrimmingPreference v);
    virtual unsigned int getArgumentCount() const { return 5; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 2: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 3: return IfcUtil::Argument_BOOL; case 4: return IfcUtil::Argument_ENUMERATION; } return IfcBoundedCurve::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcCurve; case 1: return Type::IfcTrimmingSelect; case 2: return Type::IfcTrimmingSelect; case 3: return Type::UNDEFINED; case 4: return Type::IfcTrimmingPreference; } return IfcBoundedCurve::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "BasisCurve"; case 1: return "Trim1"; case 2: return "Trim2"; case 3: return "SenseAgreement"; case 4: return "MasterRepresentation"; } return IfcBoundedCurve::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcTrimmedCurve (IfcAbstractEntity* e);
    IfcTrimmedCurve (IfcCurve* v1_BasisCurve, IfcEntityList::ptr v2_Trim1, IfcEntityList::ptr v3_Trim2, bool v4_SenseAgreement, IfcTrimmingPreference::IfcTrimmingPreference v5_MasterRepresentation);
    typedef IfcTemplatedEntityList< IfcTrimmedCurve > list;
};
/// The energy conversion device type IfcTubeBundleType defines commonly shared information for occurrences of tube bundles.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a tube bundle specification (i.e. the specific product information, that is common to all occurrences of that product type).  Tube Bundle types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcTubeBundleType are represented by instances of IfcTubeBundle. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcEnergyConversionDeviceType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_TubeBundleTypeCommon 
/// 
/// The following property set definitions are applicable to this entity according to the PredefinedType attribute:  
/// Pset_TubeBundleTypeFinned (FINNED) 
/// 
/// Material Use Definition 
/// The material of the IfcTubeBundleType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Body': Material used for construction of the tubes. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcTubeBundleType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcTubeBundle for standard port definitions.
class IfcTubeBundleType : public IfcEnergyConversionDeviceType {
public:
    /// Defines the type of tube bundle.
    IfcTubeBundleTypeEnum::IfcTubeBundleTypeEnum PredefinedType() const;
    void setPredefinedType(IfcTubeBundleTypeEnum::IfcTubeBundleTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcEnergyConversionDeviceType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcTubeBundleTypeEnum; } return IfcEnergyConversionDeviceType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcEnergyConversionDeviceType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcTubeBundleType (IfcAbstractEntity* e);
    IfcTubeBundleType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcTubeBundleTypeEnum::IfcTubeBundleTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcTubeBundleType > list;
};
/// The energy conversion device type IfcUnitaryEquipmentType defines commonly shared information for occurrences of unitary equipments.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a unitary equipment specification (i.e. the specific product information, that is common to all occurrences of that product type).  Unitary Equipment types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcUnitaryEquipmentType are represented by instances of IfcUnitaryEquipment. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcEnergyConversionDeviceType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_UnitaryEquipmentTypeCommon 
/// 
/// Material Use Definition 
/// The material of the IfcUnitaryEquipmentType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.   
/// Composition Use Definition 
/// The IfcUnitaryEquipmentType may be aggregated into components using IfcRelAggregates where RelatingObject refers to the enclosing IfcUnitaryEquipmentType and RelatedObjects contains one or more components.  Components are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Aggregation use is defined for the following predefined types:
/// 
/// (All Types): May contain IfcDistributionElement components.  Unitary equipment (air handlers in particular) may elaborate contained elements such as dampers, fans, coils, sensors, actuators, and controllers.  Such breakdown provides access to component information and tracking of performance history for embedded elements. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcUnitaryEquipmentType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcUnitaryEquipment for standard port definitions.
class IfcUnitaryEquipmentType : public IfcEnergyConversionDeviceType {
public:
    /// The type of unitary equipment.
    IfcUnitaryEquipmentTypeEnum::IfcUnitaryEquipmentTypeEnum PredefinedType() const;
    void setPredefinedType(IfcUnitaryEquipmentTypeEnum::IfcUnitaryEquipmentTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcEnergyConversionDeviceType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcUnitaryEquipmentTypeEnum; } return IfcEnergyConversionDeviceType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcEnergyConversionDeviceType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcUnitaryEquipmentType (IfcAbstractEntity* e);
    IfcUnitaryEquipmentType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcUnitaryEquipmentTypeEnum::IfcUnitaryEquipmentTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcUnitaryEquipmentType > list;
};
/// The flow controller type IfcValveType defines commonly shared information for occurrences of valves.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a valve specification (i.e. the specific product information, that is common to all occurrences of that product type).  Valve types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcValveType are represented by instances of IfcValve. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcFlowControllerType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_ValveTypeCommon 
/// 
/// The following property set definitions are applicable to this entity according to the PredefinedType attribute:  
/// Pset_ValveTypeAirRelease (AIRRELEASE) 
/// Pset_ValveTypeDrawOffCock (DRAWOFFCOCK) 
/// Pset_ValveTypeFaucet (FAUCET) 
/// Pset_ValveTypeFlushing (FLUSHING) 
/// Pset_ValveTypeGasTap (GASTAP) 
/// Pset_ValveTypeIsolating (ISOLATING) 
/// Pset_ValveTypeMixing (MIXING) 
/// Pset_ValveTypePressureReducing (PRESSUREREDUCING) 
/// Pset_ValveTypePressureRelief (PRESSURERELIEF) 
/// 
/// Material Use Definition 
/// The material of the IfcValveType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Body': The primary material from which the object is constructed. 
/// 'Operation': Material from which the operating mechanism (gate, globe, plug, needle, clack etc.) of the valve is constructed. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcValveType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcValve for standard port definitions.
class IfcValveType : public IfcFlowControllerType {
public:
    /// The type of valve.
    IfcValveTypeEnum::IfcValveTypeEnum PredefinedType() const;
    void setPredefinedType(IfcValveTypeEnum::IfcValveTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcFlowControllerType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcValveTypeEnum; } return IfcFlowControllerType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcFlowControllerType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcValveType (IfcAbstractEntity* e);
    IfcValveType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcValveTypeEnum::IfcValveTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcValveType > list;
};
/// A virtual element is a special element used to provide imaginary boundaries, such as between two adjacent, but not separated, spaces. Virtual elements are usually not displayed and does not have quantities and other measures. Therefore IfcVirtualElement does not have material information and quantities attached.
/// 
/// NOTE The main purpose of IfcVirtualElement is the provision of a virtual space boundary. The IfcVirtualElement may provide the 2D curve or 3D surface representation of the virtual space connection and is referenced by two instances of IfcRelSpaceBoundary, each pointing to one of the two adjacent IfcSpaces.
/// 
/// HISTORY New entity in IFC Release 2x2 Addendum.
/// IFC2x2 CHANGE: The entity IfcVirtualElement has been added. Upward compatibility for file based exchange is guaranteed.
/// 
/// Space Boundary Use Definition
/// The IfcVirtualElement is mainly used to define a virtual boundary between two spaces. Figure 63 describes how to use IfcRelSpaceBoundary in conjunction with IfcVirtualElement to define space boundaries.
/// 
/// Figure 63 — Virtual element space boundaries
/// 
/// Geometry Use Definition
/// The geometric representation of any IfcVirtualElement
/// is given by the IfcProductDefinitionShape and
/// IfcLocalPlacement allowing multiple geometric
/// representations. Included are:
/// Local Placement
/// The local placement for IfcVirtualElement is defined in
/// its supertype IfcProduct. It is defined by the
/// IfcLocalPlacement, which defines the local coordinate
/// system that is referenced by all geometric representations.
/// 
/// The PlacementRelTo relationship of
/// IfcLocalPlacement shall point (if given) to the local
/// placement of the same IfcSpatialStructureElement that is
/// used in the ContainedInStructure inverse attribute or to a
/// referenced spatial structure element at a higher level.
/// If the relative placement is not used, the absolute placement
/// is defined within the world coordinate system.
/// 
/// Geometric Representation
/// Currently, the use of 'FootPrint' and 'Surface' representation
/// is supported.
/// FootPrint Representation
/// The 2D geometric representation of IfcVirtualElement is
/// defined using the 'FootPrint' representation.
/// 
/// IfcShapeRepresentation.RepresentationIdentifier =
/// 'FootPrint'.
/// IfcShapeRepresentation.RepresentationType = 'Curve2D'
/// or 'GeometricCurveSet' .
/// 
/// The following constraints apply to the 2D FootPrint
/// representation:
/// 
/// 'Curve2D': IfcPolyline, IfcTrimmedCurve or
/// IfcCompositeCurve
/// 'GeometricCurveSet': a list of 2D curves within the
/// constraints shown above.
/// 
/// Surface Representation
/// The 3D geometric representation of IfcVirtualElement is
/// defined using a surface geometry.
/// 
/// IfcShapeRepresentation.RepresentationIdentifier =
/// 'Surface'.
/// IfcShapeRepresentation.RepresentationType =
/// 'Surface3D' or 'GeometricSet .
/// 
/// The following constraints apply to the 3D surface
/// representation:
/// 
/// 'Surface3D': IfcSurfaceOfLinearExtrusion,
/// IfcCurveBoundedPlane, IfcCurveBoundedSurface,
/// IfcRectangularTrimmedSurface
/// in case of an
/// IfcSurfaceOfLinearExtrusion
/// 
/// Profile:
/// IfcArbitraryOpenProfileDef
/// Extrusion: The extrusion direction shall be
/// vertically, i.e., along the positive Z Axis of the co-ordinate
/// system of the containing spatial structure element.
/// 
/// in case of an
/// IfcCurveBoundedPlane, IfcCurveBoundedSurface,
/// IfcRectangularTrimmedSurface
/// 
/// Extrusion: The BasisSurface shall be a
/// surface that is upright, i.e. standing perpendicular to the xy
/// place of the co-ordinate system of the containing spatial
/// structure element.
/// 
/// 'GeometricSet': a list of 3D surfaces within the constraints
/// shown above.
class IfcVirtualElement : public IfcElement {
public:
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcVirtualElement (IfcAbstractEntity* e);
    IfcVirtualElement (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag);
    typedef IfcTemplatedEntityList< IfcVirtualElement > list;
};
/// Definition from IAI: The element type
/// IfcWallType defines commonly shared information for
/// occurrences of walls. The set of shared information may
/// include:
/// 
/// common properties within shared property sets
/// common material information
/// common material layer definitions
/// common shape representations
/// 
/// NOTE It is illegal to share shape
/// representations as representation maps for occurrences of
/// IfcWallStandardcase.
/// 
/// It is used to define a wall specification (i.e. the specific
/// product information, that is common to all occurrences of that
/// product type). Wall types may be exchanged without being already
/// assigned to occurrences.
/// 
/// NOTE: The product representations are defined
/// as representation maps (at the level of the supertype
/// IfcTypeProduct, which gets assigned by an element
/// occurrence instance through the
/// IfcShapeRepresentation.Item[1] being an
/// IfcMappedItem.
/// 
/// Occurrences of the IfcWallType within building models
/// are represented by instances of IfcWallStandardCase if the
/// IfcBeamType has a single associated
/// IfcMaterialLayerSet; otherwise they are represented by
/// instances of IfcWall, or IfcWallElementedCase.
/// Occurrences of the IfcWallType within structural analysis
/// models are represented by instances of
/// IfcStructuralSurfaceMember, or its applicable
/// subtypes.
/// HISTORY: New entity in
/// Release IFC2x Editon 2.
/// Informal proposition:
/// 
/// The material assignment, if provided using the
/// IfcRelAssociatesMaterial relationship, shall not reference
/// the IfcMaterialLayerSetUsage.
/// 
/// Material Use Definition
/// The material of the IfcWallType is defined by the
/// IfcMaterialLayerSet or as fall back by IfcMaterial
/// and attached by the
/// IfcRelAssociatesMaterial.RelatingMaterial. It is
/// accessible by the inverse HasAssociations
/// relationship.
/// Note: It is illegal to assign an
/// IfcMaterial to an IfcWallType, if there is at least
/// one occurrences. of IfcWallStandardCase for this
/// type.
/// Layer Set Use Definition:
/// The shared material layer set definition is defined by
/// assigning an IfcMaterialLayerSet (see material use
/// definition above). The IfcMaterialLayer refers to one or
/// several of IfcMaterialLayer that is the common for all
/// wall occurrence, if used. It is only applicable if the
/// IfcWallType has only occurrences of type
/// IfcWallStandardCase (see definition of
/// IfcWallStandardCase for further information).
/// NOTE Since each individual instance of
/// IfcWallStandardCase defines its own
/// IfcMaterialLayerSetUsage including the offset from the
/// wall axis, the same IfcWallType can be used independently
/// of the axis alignment of its occurrences.
/// Property Set Use Definition:
/// The shared property sets relating to the IfcWallType
/// are defined by the IfcPropertySet and are attached by the
/// HasPropertySets attribute. The following property set
/// definitions specific to the IfcWallType are part of this
/// IFC release:
/// NOTE There is no differentiation between
/// properties within the property set that are only assignable to
/// IfcWallType and those that are only assignable to
/// IfcWall. If the same property is assigned to the
/// IfcWallType and the IfcWall being an occurrence of
/// the IfcWallType, then the occurrence property overrides
/// the type property.
/// 
/// Pset_WallCommon: common property set for all
/// wall types.
class IfcWallType : public IfcBuildingElementType {
public:
    /// Identifies the predefined types of a wall element from which the type required may be set.
    IfcWallTypeEnum::IfcWallTypeEnum PredefinedType() const;
    void setPredefinedType(IfcWallTypeEnum::IfcWallTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcBuildingElementType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcWallTypeEnum; } return IfcBuildingElementType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcBuildingElementType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcWallType (IfcAbstractEntity* e);
    IfcWallType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcWallTypeEnum::IfcWallTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcWallType > list;
};
/// The flow terminal type IfcWasteTerminalType defines commonly shared information for occurrences of waste terminals.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a waste terminal specification (i.e. the specific product information, that is common to all occurrences of that product type).  Waste Terminal types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcWasteTerminalType are represented by instances of IfcWasteTerminal. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcFlowTerminalType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_WasteTerminalTypeCommon 
/// 
/// The following property set definitions are applicable to this entity according to the PredefinedType attribute:  
/// Pset_WasteTerminalTypeFloorTrap (FLOORTRAP) 
/// Pset_WasteTerminalTypeFloorWaste (FLOORWASTE) 
/// Pset_WasteTerminalTypeGullySump (GULLYSUMP) 
/// Pset_WasteTerminalTypeGullyTrap (GULLYTRAP) 
/// Pset_WasteTerminalTypeRoofDrain (ROOFDRAIN) 
/// Pset_WasteTerminalTypeWasteDisposalUnit (WASTEDISPOSALUNIT) 
/// Pset_WasteTerminalTypeWasteTrap (WASTETRAP) 
/// 
/// Material Use Definition 
/// The material of the IfcWasteTerminalType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Body': The primary material from which the object is constructed. 
/// 'Cover': Material from which the cover or grating is constructed. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcWasteTerminalType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcWasteTerminal for standard port definitions.
class IfcWasteTerminalType : public IfcFlowTerminalType {
public:
    /// Identifies the predefined types of waste terminal from which the type required may be set.
    IfcWasteTerminalTypeEnum::IfcWasteTerminalTypeEnum PredefinedType() const;
    void setPredefinedType(IfcWasteTerminalTypeEnum::IfcWasteTerminalTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcFlowTerminalType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcWasteTerminalTypeEnum; } return IfcFlowTerminalType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcFlowTerminalType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcWasteTerminalType (IfcAbstractEntity* e);
    IfcWasteTerminalType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcWasteTerminalTypeEnum::IfcWasteTerminalTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcWasteTerminalType > list;
};
/// An IfcWorkControl is an abstract supertype which captures information that is common to both IfcWorkPlan and IfcWorkSchedule.
/// 
/// HISTORY  New class in IFC 2x
/// 
/// CHANGE IFC2x4  Corrected assignment of resources to work control in documentation. Assignment of tasks to work control updated based on changes of task time definitions and the introduction of a summary task. Identifier has been renamed (now Identification) and promoted to supertype IfcControl
/// 
/// A work control may have resources assigned to it, this is
///   handled by the IfcRelAssignsToControl relationship.
///   A work control should also define a context that gives
///   further information about its usage. If no special context
///   information is required then the IfcProject instance
///   as a global context should be used instead. An explicit
///   link between the work control and the IfcProject via
///   IfcRelDeclares should then be provided.
/// 
/// From IFC2x4 onwards the assignment of tasks to the work
///   control is handled by the IfcRelAssignsToControl
///   relationship. IfcRelAssignsTasks as used in previous
///   IFC releases has been deleted and can not be used any
///   longer. Another change in IFC2x4 is that it is not
///   necessary to assign each task to a work control as it is
///   regarded to be sufficient if the summary task (root task in
///   the task hierarchy defined through IfcRelNests
///   relationships) is assigned to a work control.
/// 
/// The attribute IfcWorkControl.Purpose is used to
///   define the purpose of either a work schedule or a work
///   plan. In the case of IfcWorkPlan, the purpose
///   attribute can be used to determine if the work plan is for
///   cost estimating, task scheduling or some other defined
///   purpose.
/// 
/// Property set use definition
/// 
/// The property sets relating to the IfcWorkControl are
///   defined by IfcPropertySet and attached by the
///   IfcRelDefinesByProperties relationship. It is
///   accessible by the inverse IsDefinedBy relationship.
///   The following property set definition specific to the
///   IfcWorkControl and its subtype are part of this IFC
///   release:
/// 
/// Pset_WorkControlCommon: common
///   property set for work control
class IfcWorkControl : public IfcControl {
public:
    std::string Identifier() const;
    void setIdentifier(std::string v);
    /// The date that the plan is created.
    IfcDateTimeSelect* CreationDate() const;
    void setCreationDate(IfcDateTimeSelect* v);
    /// Whether the optional attribute Creators is defined for this IfcWorkControl
    bool hasCreators() const;
    /// The authors of the work plan.
    IfcTemplatedEntityList< IfcPerson >::ptr Creators() const;
    void setCreators(IfcTemplatedEntityList< IfcPerson >::ptr v);
    /// Whether the optional attribute Purpose is defined for this IfcWorkControl
    bool hasPurpose() const;
    /// A description of the purpose of the work schedule.
    std::string Purpose() const;
    void setPurpose(std::string v);
    /// Whether the optional attribute Duration is defined for this IfcWorkControl
    bool hasDuration() const;
    /// The total duration of the entire work schedule.
    double Duration() const;
    void setDuration(double v);
    /// Whether the optional attribute TotalFloat is defined for this IfcWorkControl
    bool hasTotalFloat() const;
    /// The total time float of the entire work schedule.
    double TotalFloat() const;
    void setTotalFloat(double v);
    /// The start time of the schedule.
    IfcDateTimeSelect* StartTime() const;
    void setStartTime(IfcDateTimeSelect* v);
    /// Whether the optional attribute FinishTime is defined for this IfcWorkControl
    bool hasFinishTime() const;
    /// The finish time of the schedule.
    IfcDateTimeSelect* FinishTime() const;
    void setFinishTime(IfcDateTimeSelect* v);
    /// Whether the optional attribute WorkControlType is defined for this IfcWorkControl
    bool hasWorkControlType() const;
    IfcWorkControlTypeEnum::IfcWorkControlTypeEnum WorkControlType() const;
    void setWorkControlType(IfcWorkControlTypeEnum::IfcWorkControlTypeEnum v);
    /// Whether the optional attribute UserDefinedControlType is defined for this IfcWorkControl
    bool hasUserDefinedControlType() const;
    std::string UserDefinedControlType() const;
    void setUserDefinedControlType(std::string v);
    virtual unsigned int getArgumentCount() const { return 15; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 5: return IfcUtil::Argument_STRING; case 6: return IfcUtil::Argument_ENTITY_INSTANCE; case 7: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 8: return IfcUtil::Argument_STRING; case 9: return IfcUtil::Argument_DOUBLE; case 10: return IfcUtil::Argument_DOUBLE; case 11: return IfcUtil::Argument_ENTITY_INSTANCE; case 12: return IfcUtil::Argument_ENTITY_INSTANCE; case 13: return IfcUtil::Argument_ENUMERATION; case 14: return IfcUtil::Argument_STRING; } return IfcControl::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 5: return Type::IfcIdentifier; case 6: return Type::IfcDateTimeSelect; case 7: return Type::IfcPerson; case 8: return Type::IfcLabel; case 9: return Type::IfcTimeMeasure; case 10: return Type::IfcTimeMeasure; case 11: return Type::IfcDateTimeSelect; case 12: return Type::IfcDateTimeSelect; case 13: return Type::IfcWorkControlTypeEnum; case 14: return Type::IfcLabel; } return IfcControl::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 5: return "Identifier"; case 6: return "CreationDate"; case 7: return "Creators"; case 8: return "Purpose"; case 9: return "Duration"; case 10: return "TotalFloat"; case 11: return "StartTime"; case 12: return "FinishTime"; case 13: return "WorkControlType"; case 14: return "UserDefinedControlType"; } return IfcControl::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcWorkControl (IfcAbstractEntity* e);
    IfcWorkControl (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, std::string v6_Identifier, IfcDateTimeSelect* v7_CreationDate, boost::optional< IfcTemplatedEntityList< IfcPerson >::ptr > v8_Creators, boost::optional< std::string > v9_Purpose, boost::optional< double > v10_Duration, boost::optional< double > v11_TotalFloat, IfcDateTimeSelect* v12_StartTime, IfcDateTimeSelect* v13_FinishTime, boost::optional< IfcWorkControlTypeEnum::IfcWorkControlTypeEnum > v14_WorkControlType, boost::optional< std::string > v15_UserDefinedControlType);
    typedef IfcTemplatedEntityList< IfcWorkControl > list;
};
/// An IfcWorkPlan represents work plans in a construction or a facilities management project.
/// 
/// HISTORY: New Entity in IFC 2.0
/// 
/// A work plan contains a set of work schedules for different
///   purposes (including construction and facilities
///   management). Contained work schedules are defined through
///   the IfcRelAggregates relationship. Through
///   inheritance from IfcWorkControl it is also possible
///   to define references to activities (for example, IfcTask)
///   and resources used in the work plan.
/// 
/// A work plan has information such as start date, finish
///   date, total free float, and so on. IfcWorkPlan can
///   also refer to the construction project represented by the
///   single IfcProject instance (please also check the
///   definition of IfcWorkControl).
/// 
/// Figure 18 shows the backbone structure of a work plan that
///   defines (1) contained work schedules through
///   IfcRelAggregates and (2), if not assigned otherwise
///   to contained work schedules, assigned tasks and resources
///   through IfcRelAssignsToControl.
/// 
/// Figure 18 — Work plan relationships
class IfcWorkPlan : public IfcWorkControl {
public:
    virtual unsigned int getArgumentCount() const { return 15; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcWorkControl::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcWorkControl::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcWorkControl::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcWorkPlan (IfcAbstractEntity* e);
    IfcWorkPlan (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, std::string v6_Identifier, IfcDateTimeSelect* v7_CreationDate, boost::optional< IfcTemplatedEntityList< IfcPerson >::ptr > v8_Creators, boost::optional< std::string > v9_Purpose, boost::optional< double > v10_Duration, boost::optional< double > v11_TotalFloat, IfcDateTimeSelect* v12_StartTime, IfcDateTimeSelect* v13_FinishTime, boost::optional< IfcWorkControlTypeEnum::IfcWorkControlTypeEnum > v14_WorkControlType, boost::optional< std::string > v15_UserDefinedControlType);
    typedef IfcTemplatedEntityList< IfcWorkPlan > list;
};
/// An IfcWorkSchedule
///   represents a task schedule of a work plan, which in turn
///   can contain a set of schedules for different purposes.
/// 
/// HISTORY: New Entity in IFC
///   Release 2.0
/// 
/// Assignment Use Definition
/// 
/// An IfcWorkSchedule controls a set of tasks and
///   resources defined through IfcRelAssignsToControl.
///   Additionally, through the IfcWorkControl abstract
///   supertype, the actors creating the schedule can be
///   specified and schedule time information such as start time,
///   finish time, and total float of the schedule can also be
///   specified.
/// 
/// Declaration Use Definition
/// 
/// IfcWorkSchedule can reference a project (the
///   single IfcProject instance) via
///   IfcRelDeclares. The documents of the
///   IfcWorkSchedule can be referenced by the
///   IfcRelAssociatesDocuments relationship. 
/// 
/// Composition Use Definition
///   A work schedule can include other work schedules as sub-items
///   through IfcRelNests relationship. If not included in
///   another work schedule it might be a part of a work plan
///   (IfcWorkPlan) defined through
///   IfcRelAggregates relationship.
/// 
/// Figure 19 shows the backbone structure of a work schedule
///   that defines (1) a context through IfcRelDeclares
///   (not necessarily the project) and (2) controls tasks
///   (typically the schedule summary task) and resources. Please
///   note that a work calendar shall be assigned to the summary
///   task and not the work schedule.
/// 
/// Figure 19 — Work schedule relationships
class IfcWorkSchedule : public IfcWorkControl {
public:
    virtual unsigned int getArgumentCount() const { return 15; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcWorkControl::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcWorkControl::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcWorkControl::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcWorkSchedule (IfcAbstractEntity* e);
    IfcWorkSchedule (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, std::string v6_Identifier, IfcDateTimeSelect* v7_CreationDate, boost::optional< IfcTemplatedEntityList< IfcPerson >::ptr > v8_Creators, boost::optional< std::string > v9_Purpose, boost::optional< double > v10_Duration, boost::optional< double > v11_TotalFloat, IfcDateTimeSelect* v12_StartTime, IfcDateTimeSelect* v13_FinishTime, boost::optional< IfcWorkControlTypeEnum::IfcWorkControlTypeEnum > v14_WorkControlType, boost::optional< std::string > v15_UserDefinedControlType);
    typedef IfcTemplatedEntityList< IfcWorkSchedule > list;
};
/// Definition from IAI: A zone isÿa group of spaces,
/// partial spaces or other zones. Zone structures may not be
/// hierarchical (in contrary to the spatial structure of a project -
/// see IfcSpatialStructureElement), i.e. one individual
/// IfcSpace may be associated with zero, one, or several
/// IfcZone's. IfcSpace's are grouped into an
/// IfcZone by using the objectified relationship
/// IfcRelAssignsToGroup as specified at the supertype
/// IfcGroup.
/// NOTE ÿCertain use cases may restrict the
/// freedom of non hierarchical relationships. In some building
/// service use cases the zone denotes aÿview based delimited volume
/// for the purpose of analysis and calculation. This type of zone
/// cannot overlap with respect to that analysis, but may overlap
/// otherwise.
/// An IfcZone is a spatial system under which individual
/// IfcSpace's (and other IfcZone's) are grouped. In
/// contrary to the IfcSpatialZone entity, IfcZone is a
/// mere grouping, it can not define an own geometric representation
/// and placement. Therefore it cannot be used for spatial zones
/// having a different shape and size compared to the shape and size
/// of aggregated spaces.
/// NOTEÿ The IfcZone is regarded as the
/// spatial system (as compared to the building service, electrical,
/// or analytical system), the name remains IfcZone for
/// compatibility reasons, instead of using a proper naming
/// convention, like IfcSpatialSystem.
/// NOTE ÿOne of the purposes of a zone is to
/// define a fire compartmentation. In this case it defines the
/// geometric information about the fire compartment (through the
/// contained spaces) and information, whether this compartment is
/// ventilated or sprinkler protected. In addition the fire risk code
/// and the hazard type can be added, the coding is normally defined
/// within a national fire regulation. All that information is
/// available within the relevant property sets. Again, if an
/// independent shape has to be provided to the fire compartment,
/// then the entity IfcSpatialZone shall be
/// used.
/// RECOMMENDATIONÿ In case of a zone denoting a
/// (fire) compartment, the following types should be used, if
/// applicable, as values of the ObjectType attribute:
/// 
/// FireCompartment - a zone of spaces, collected to
/// represent a single fire compartment.
/// ElevatorShaft - a collection of spaces within an
/// elevator, potentially going through many storeys.
/// RisingDuct
/// RunningDuct
/// 
/// Additional classifications of the IfcZone, as provided
/// by a national classification system, can be assigned by using the
/// IfcRelAssociatesClassification relationship, accessible
/// via the inverse attribute HasAssociations. The
/// IfcZone can be assigned to a spatial structure element, it
/// refers to, e.g. to a particular IfcBuildingStorey by using
/// the IfcRelServicesBuildings relationship, accessible via
/// the inverse attribute ServicesBuilding.
/// HISTORYÿ New entity in
/// IFC Release 1.0
/// IFC2x4 CHANGEÿ The entity is now
/// subtyped from IfcSystem (not its supertype
/// IfcGroup) with upward compatibility for file based
/// exchange.
/// Property Set Use Definition:
/// The property sets relating to the IfcZone are defined
/// by the IfcPropertySet and attached by the
/// IfcRelDefinesByProperties relationship. It is accessible
/// by the inverse IsDefinedBy relationship. The following
/// property set definitions specific to the IfcZone are part
/// of this IFC release:
/// 
/// Pset_ZoneCommon: common property set for all
/// types of zone
/// Pset_SpaceFireSafetyRequirements: common
/// property set for all types of zones to capture the fire safety
/// requirements
/// Pset_SpaceLightingRequirements: common
/// property set for all types of zones to capture the lighting
/// requirements
/// Pset_SpaceOccupancyRequirements: common
/// property set for all types of zones to capture the occupancy
/// requirements
/// Pset_SpaceThermalRequirements: common
/// property set for all types of zones to capture the thermal
/// requirements
class IfcZone : public IfcGroup {
public:
    virtual unsigned int getArgumentCount() const { return 5; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcGroup::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcGroup::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcGroup::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcZone (IfcAbstractEntity* e);
    IfcZone (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType);
    typedef IfcTemplatedEntityList< IfcZone > list;
};

class Ifc2DCompositeCurve : public IfcCompositeCurve {
public:
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcCompositeCurve::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcCompositeCurve::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcCompositeCurve::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    Ifc2DCompositeCurve (IfcAbstractEntity* e);
    Ifc2DCompositeCurve (IfcTemplatedEntityList< IfcCompositeCurveSegment >::ptr v1_Segments, bool v2_SelfIntersect);
    typedef IfcTemplatedEntityList< Ifc2DCompositeCurve > list;
};
/// A request is the act or instance of asking for something, such as a request for information, bid submission, or performance of work. 
/// 
/// Requests may take many forms depending on the need including fault reports for maintenance, requests for small works, and purchase requests (where these are to be made through a help desk or buying function). 
/// 
/// HISTORY: New entity in IFC2x2 
/// IFC2x4 CHANGE  RequestID renamed to Identification and promoted to supertype IfcControl, attributes PredefinedType, Status, and LongDescription added.
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the IfcRelDefinesByProperties relationship. They are accessible by the IsDefinedBy inverse attribute.  Refer to the documentation at the supertype IfcControl and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_ActionRequest 
/// 
/// Declaration Use Definition 
/// The IfcActionRequest may be declared within the project using the IfcRelDeclares relationship where RelatingContext refers to the single IfcProject and RelatedDefinitions contains the IfcActionRequest.  Alternatively, if the IfcActionRequest is aggregated within an IfcWorkPlan, then it shall not have a direct declaration relationship (whereas the containing work plan may have a declaration relationship). 
/// 
/// Composition Use Definition 
/// As shown in Figure 155, an IfcActionRequest may be aggregated into components using IfcRelAggregates where RelatingObject refers to the enclosing IfcActionRequest and RelatedObjects contains one or more components.  Aggregation use is defined for the following predefined types:
/// 
/// (All Types): May contain IfcCostSchedule components.  A cost schedule may indicate costs and quantities where the cost schedule type may designate whether rates and/or quantities are estimated or final.  Such cost schedule may have assigned cost items indicating detail, where each cost item may have assigned products, processes, or resources. 
/// 
/// The IfcActionRequest may be nested into sub-items using IfcRelNests where RelatingObject refers to the enclosing IfcActionRequest and RelatedObjects contains one or more sub-items.  Nesting use is defined for the following predefined types:
/// 
/// (All Types): May contain IfcActionRequest sub-items.  A request may be nested into follow-up requests, in order of issue. 
/// 
/// Figure 155 — Action request composition
/// 
/// Assignment Use Definition 
/// As shown in Figure 156, an IfcActionRequest may be assigned to the following entities using relationships as indicated: 
/// 
/// IfcActor (IfcRelAssignsToActor): Person or organization issuing the request such as a tenant or owner. 
/// 
/// The IfcActionRequest may have assignments of its own using the IfcRelAssignsToControl relationship where RelatingControl refers to the IfcActionRequest and RelatedObjects contains one or more objects of the following types:  
/// IfcActor: Person or organization(s) fulfilling the request such as a facilities manager or contractor.
/// 
/// Figure 156 — Action request assignment
/// 
/// Approval Use Definition 
/// Approvals may be associated to indicate the status of acceptance or rejection using the IfcRelAssociatesApproval relationship where RelatingApproval refers to an IfcApproval and RelatedObjects contains the IfcActionRequest.  Approvals may be split into sub-approvals using IfcApprovalRelationship to track approval status separately for each party where RelatingApproval refers to the higher-level approval and RelatedApprovals contains one or more lower-level approvals.  The hierarchy of approvals implies sequencing such that a higher-level approval is not executed until all of its lower-level approvals have been accepted.
class IfcActionRequest : public IfcControl {
public:
    std::string RequestID() const;
    void setRequestID(std::string v);
    virtual unsigned int getArgumentCount() const { return 6; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 5: return IfcUtil::Argument_STRING; } return IfcControl::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 5: return Type::IfcIdentifier; } return IfcControl::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 5: return "RequestID"; } return IfcControl::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcActionRequest (IfcAbstractEntity* e);
    IfcActionRequest (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, std::string v6_RequestID);
    typedef IfcTemplatedEntityList< IfcActionRequest > list;
};
/// The flow controller type IfcAirTerminalBoxType defines commonly shared information for occurrences of air boxes.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a air box specification (i.e. the specific product information, that is common to all occurrences of that product type).  Air Box types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcAirTerminalBoxType are represented by instances of IfcAirTerminalBox. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcFlowControllerType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_AirTerminalBoxTypeCommon 
/// 
/// Material Use Definition 
/// The material of the IfcAirTerminalBoxType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Body': The primary material from which the object is constructed. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcAirTerminalBoxType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcAirTerminalBox for standard port definitions.
class IfcAirTerminalBoxType : public IfcFlowControllerType {
public:
    /// The air terminal box type.
    IfcAirTerminalBoxTypeEnum::IfcAirTerminalBoxTypeEnum PredefinedType() const;
    void setPredefinedType(IfcAirTerminalBoxTypeEnum::IfcAirTerminalBoxTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcFlowControllerType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcAirTerminalBoxTypeEnum; } return IfcFlowControllerType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcFlowControllerType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcAirTerminalBoxType (IfcAbstractEntity* e);
    IfcAirTerminalBoxType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcAirTerminalBoxTypeEnum::IfcAirTerminalBoxTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcAirTerminalBoxType > list;
};
/// The flow terminal type IfcAirTerminalType defines commonly shared information for occurrences of air terminals.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a air terminal specification (i.e. the specific product information, that is common to all occurrences of that product type).  Air Terminal types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcAirTerminalType are represented by instances of IfcAirTerminal. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcFlowTerminalType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_AirTerminalTypeCommon 
/// 
/// Material Use Definition 
/// The material of the IfcAirTerminalType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Body': The primary material from which the object is constructed. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcAirTerminalType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcAirTerminal for standard port definitions.
class IfcAirTerminalType : public IfcFlowTerminalType {
public:
    IfcAirTerminalTypeEnum::IfcAirTerminalTypeEnum PredefinedType() const;
    void setPredefinedType(IfcAirTerminalTypeEnum::IfcAirTerminalTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcFlowTerminalType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcAirTerminalTypeEnum; } return IfcFlowTerminalType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcFlowTerminalType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcAirTerminalType (IfcAbstractEntity* e);
    IfcAirTerminalType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcAirTerminalTypeEnum::IfcAirTerminalTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcAirTerminalType > list;
};
/// The energy conversion device type IfcAirToAirHeatRecoveryType defines commonly shared information for occurrences of air-to-air heat recovery devices.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a air-to-air heat recovery device specification (i.e. the specific product information, that is common to all occurrences of that product type).  Air-To-Air Heat Recovery Device types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcAirToAirHeatRecoveryType are represented by instances of IfcAirToAirHeatRecovery. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcEnergyConversionDeviceType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_AirToAirHeatRecoveryTypeCommon 
/// 
/// Material Use Definition 
/// The material of the IfcAirToAirHeatRecoveryType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Media': The primary media material used for heat transfer. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcAirToAirHeatRecoveryType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcAirToAirHeatRecovery for standard port definitions.
class IfcAirToAirHeatRecoveryType : public IfcEnergyConversionDeviceType {
public:
    /// Defines the type of air to air heat recovery device.
    IfcAirToAirHeatRecoveryTypeEnum::IfcAirToAirHeatRecoveryTypeEnum PredefinedType() const;
    void setPredefinedType(IfcAirToAirHeatRecoveryTypeEnum::IfcAirToAirHeatRecoveryTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcEnergyConversionDeviceType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcAirToAirHeatRecoveryTypeEnum; } return IfcEnergyConversionDeviceType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcEnergyConversionDeviceType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcAirToAirHeatRecoveryType (IfcAbstractEntity* e);
    IfcAirToAirHeatRecoveryType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcAirToAirHeatRecoveryTypeEnum::IfcAirToAirHeatRecoveryTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcAirToAirHeatRecoveryType > list;
};

class IfcAngularDimension : public IfcDimensionCurveDirectedCallout {
public:
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcDimensionCurveDirectedCallout::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcDimensionCurveDirectedCallout::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcDimensionCurveDirectedCallout::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcAngularDimension (IfcAbstractEntity* e);
    IfcAngularDimension (IfcEntityList::ptr v1_Contents);
    typedef IfcTemplatedEntityList< IfcAngularDimension > list;
};
/// An asset is a uniquely identifiable grouping of elements acting as a single entity that has a financial value or that can be operated on as a single unit. 
/// 
/// An asset is generally the level of granularity at which maintenance operations are undertaken. An asset is a group that can contain one or more elements. Whilst the financial value of a component or element can be defined, financial value is also defined for accounting purposes at the level of the asset.  There are a number of actors that can be associated with an asset, each actor having a role. Actors within the scope of the project are indicated using the IfcRelAssignsToActor relationship in which case roles should be defined through the IfcActorRole class; otherwise principal actors are identified as attributes of the class. In the existence of both, direct attributes take precedence.  There are a number of costs that can be associated with an asset, each cost having a role. These are specified through the OriginalValue, CurrentValue, TotalReplacementCost and DepreciatedValue attributes.
/// 
/// HISTORY: New entity in IFC2x.  In IFC2x4, all attributes made optional and date values changed to use IfcDate.
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the IfcRelDefinesByProperties relationship. They are accessible by the IsDefinedBy inverse attribute.  Refer to the documentation at the supertype IfcGroup and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_Asset 
/// 
/// Classification Use Definition 
/// Classifications may be applied using IfcRelAssociatesClassification where RelatedObjects contains the  IfcAsset and RelatingClassification refers to an IfcClassification or IfcClassificationReference. 
/// 
/// IfcClassificationReference: The operating function of an asset within an organization may be particularly valuable in situations where one organization provides and maintains core services and another organization adds and maintains terminal services. It can classify who owns and is responsible for the asset. Operating function can be designated through the use of one or more classification references. 
/// 
/// Assignment Use Definition 
///   The IfcAsset may be assigned to the following entities using relationships as indicated: 
/// 
/// IfcActor (IfcRelAssignsToActor): Indicates the actor who owns, uses, or is responsible for the asset (as indicated by role in relationship), if such actor is within the scope of the project.   
/// IfcCostItem (IfcRelAssignsToControl): Indicates a cost item encompassing the asset. 
/// 
/// The IfcAsset may have assignments of its own using the IfcRelAssignsToGroup relationship where RelatingGroup refers to the IfcAsset and RelatedObjects contains one or more objects of the following types:  
/// IfcElement: Physical elements that comprise the asset.
class IfcAsset : public IfcGroup {
public:
    std::string AssetID() const;
    void setAssetID(std::string v);
    /// The cost value of the asset at the time of purchase.
    IfcCostValue* OriginalValue() const;
    void setOriginalValue(IfcCostValue* v);
    /// The current cost value of the asset.
    IfcCostValue* CurrentValue() const;
    void setCurrentValue(IfcCostValue* v);
    /// The total cost of replacement of the asset.
    IfcCostValue* TotalReplacementCost() const;
    void setTotalReplacementCost(IfcCostValue* v);
    /// The name of the person or organization that 'owns' the asset.
    IfcActorSelect* Owner() const;
    void setOwner(IfcActorSelect* v);
    /// The name of the person or organization that 'uses' the asset.
    IfcActorSelect* User() const;
    void setUser(IfcActorSelect* v);
    /// The person designated to be responsible for the asset.
    /// NOTE: In some regulations (for example, UK Health and Safety at Work Act, Electricity at Work Regulations), management of assets must have a person identified as being responsible and to whom regulatory, insurance and other organizations communicate. In places where there is not a legal requirement, the responsible person would be the asset manager but would not have a legal status.
    IfcPerson* ResponsiblePerson() const;
    void setResponsiblePerson(IfcPerson* v);
    /// The date on which an asset was incorporated into the works, installed, constructed, erected or completed.
    /// NOTE: This is the date on which an asset is considered to start depreciating.
    /// 
    /// IFC2x4 CHANGE Type changed from IfcDateTimeSelect.
    IfcCalendarDate* IncorporationDate() const;
    void setIncorporationDate(IfcCalendarDate* v);
    /// The current value of an asset within the accounting rules and procedures of an organization.
    IfcCostValue* DepreciatedValue() const;
    void setDepreciatedValue(IfcCostValue* v);
    virtual unsigned int getArgumentCount() const { return 14; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 5: return IfcUtil::Argument_STRING; case 6: return IfcUtil::Argument_ENTITY_INSTANCE; case 7: return IfcUtil::Argument_ENTITY_INSTANCE; case 8: return IfcUtil::Argument_ENTITY_INSTANCE; case 9: return IfcUtil::Argument_ENTITY_INSTANCE; case 10: return IfcUtil::Argument_ENTITY_INSTANCE; case 11: return IfcUtil::Argument_ENTITY_INSTANCE; case 12: return IfcUtil::Argument_ENTITY_INSTANCE; case 13: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcGroup::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 5: return Type::IfcIdentifier; case 6: return Type::IfcCostValue; case 7: return Type::IfcCostValue; case 8: return Type::IfcCostValue; case 9: return Type::IfcActorSelect; case 10: return Type::IfcActorSelect; case 11: return Type::IfcPerson; case 12: return Type::IfcCalendarDate; case 13: return Type::IfcCostValue; } return IfcGroup::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 5: return "AssetID"; case 6: return "OriginalValue"; case 7: return "CurrentValue"; case 8: return "TotalReplacementCost"; case 9: return "Owner"; case 10: return "User"; case 11: return "ResponsiblePerson"; case 12: return "IncorporationDate"; case 13: return "DepreciatedValue"; } return IfcGroup::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcAsset (IfcAbstractEntity* e);
    IfcAsset (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, std::string v6_AssetID, IfcCostValue* v7_OriginalValue, IfcCostValue* v8_CurrentValue, IfcCostValue* v9_TotalReplacementCost, IfcActorSelect* v10_Owner, IfcActorSelect* v11_User, IfcPerson* v12_ResponsiblePerson, IfcCalendarDate* v13_IncorporationDate, IfcCostValue* v14_DepreciatedValue);
    typedef IfcTemplatedEntityList< IfcAsset > list;
};
/// Definition from ISO/CD 10303-42:1992: A B-spline curve is a piecewise parametric polynomial or rational curve described in terms of control points and basis functions. The B-spline curve has been selected as the most stable format to represent all types of polynomial or rational parametric curves. With appropriate attribute values it is capable of representing single span or spline curves of explicit polynomial, rational, Bezier or B-spline type. 
/// 
/// Interpretation of the data is as follows: 
/// 
/// All weights shall be positive and the curve is given by 
/// 
/// k+1 
///   = number of control points 
/// 
/// Pi 
///   = control points 
/// 
/// wi 
///   = weights 
/// 
/// d 
///   = degree 
/// 
/// The knot array is an array of (k+d+2) real numbers
///   [u-d ... uk+1], such that for
///   all indices j in [-d,k], uj <=
///   uj+1. This array is obtained from the knot data list by
///   repeating each multiple knot according to the multiplicity. N
///   di, the ith normalized B-spline basis function
///   of degree d, is defined on the subset [ui-d, ... ,
///   ui+1] of this array. 
/// 
/// Let L denote the number of distinct values among the
///   d+k+2 knots in the knot array; L will be referred to as
///   the 'upper index on knots'. Let mj denote the multiplicity
///   (number of repetitions) of the jth distinct knot. Then
/// 
/// All knot multiplicities except the first and the last shall be in
///   the range 1 ... degree; the first and last may have a maximum value of degree +
///   1. In evaluating the basis functions, a knot u of e.g. multiplicity 3 is
///   interpreted as a string u, u, u, in the knot array. The B-spline curve
///   has 3 special subtypes (Note: only 1, Bezier curve, included in this IFC
///   release) where the knots and knot multiplicities are derived to provide
///   simple default capabilities. 
///   Logical flag is provided to indicate whether the curve self
///   intersects or not. 
/// 
/// Figure 277 (from ISO 10303-42) illustrates a B-spline curve.
/// 
/// Figure 277 — B-spline curve
/// 
/// NOTE  Corresponding ISO 10303 entity: b_spline_curve. Please refer to ISO/IS 10303-42:1994, p. 45 for the final definition of the formal standard.
/// 
/// HISTORY  New entity in Release IFC2x2.
class IfcBSplineCurve : public IfcBoundedCurve {
public:
    /// The algebraic degree of the basis functions.
    int Degree() const;
    void setDegree(int v);
    /// The list of control points for the curve.
    IfcTemplatedEntityList< IfcCartesianPoint >::ptr ControlPointsList() const;
    void setControlPointsList(IfcTemplatedEntityList< IfcCartesianPoint >::ptr v);
    /// Used to identify particular types of curve; it is for information only.
    IfcBSplineCurveForm::IfcBSplineCurveForm CurveForm() const;
    void setCurveForm(IfcBSplineCurveForm::IfcBSplineCurveForm v);
    /// Indication of whether the curve is closed; it is for information only.
    bool ClosedCurve() const;
    void setClosedCurve(bool v);
    /// Indication whether the curve self-intersects or not; it is for information only.
    bool SelfIntersect() const;
    void setSelfIntersect(bool v);
    virtual unsigned int getArgumentCount() const { return 5; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_INT; case 1: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 2: return IfcUtil::Argument_ENUMERATION; case 3: return IfcUtil::Argument_BOOL; case 4: return IfcUtil::Argument_BOOL; } return IfcBoundedCurve::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::UNDEFINED; case 1: return Type::IfcCartesianPoint; case 2: return Type::IfcBSplineCurveForm; case 3: return Type::UNDEFINED; case 4: return Type::UNDEFINED; } return IfcBoundedCurve::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Degree"; case 1: return "ControlPointsList"; case 2: return "CurveForm"; case 3: return "ClosedCurve"; case 4: return "SelfIntersect"; } return IfcBoundedCurve::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcBSplineCurve (IfcAbstractEntity* e);
    IfcBSplineCurve (int v1_Degree, IfcTemplatedEntityList< IfcCartesianPoint >::ptr v2_ControlPointsList, IfcBSplineCurveForm::IfcBSplineCurveForm v3_CurveForm, bool v4_ClosedCurve, bool v5_SelfIntersect);
    typedef IfcTemplatedEntityList< IfcBSplineCurve > list;
};
/// Definition from IAI: The element type
/// IfcBeamType defines commonly shared information for
/// occurrences of beams. The set of shared information may
/// include:
/// 
/// common properties within shared property sets
/// common material information
/// common profile definitions
/// common shape representations
/// 
/// It is used to define a beam specification, or beam style (i.e.
/// the specific product information that is common to all
/// occurrences of that beam type). Beam types may be exchanged
/// without being already assigned to occurrences.
/// Occurrences of the IfcBeamType within building models
/// are represented by instances of IfcBeamStandardCase if the
/// IfcBeamType has a single associated
/// IfcMaterialProfileSet; otherwise they are represented by
/// instances of IfcBeam. Occurrences of the
/// IfcBeamType within structural analysis models are
/// represented by instances of IfcStructuralCurveMember, or
/// its applicable subtypes.
/// HISTORY New entity in
/// Release IFC2x Edition 2.
/// Material Use Definition
/// The material of the IfcBeamType is defined by the
/// IfcMaterialProfileSet or as fall back by
/// IfcMaterial and attached by the
/// IfcRelAssociatesMaterial.RelatingMaterial. It is
/// accessible by the inverse HasAssociations
/// relationship.
/// Note: It is illegal to assign an
/// IfcMaterial to an IfcBeamType, if there is at least
/// one occurrences. of IfcBeamStandardCase for this
/// type.
/// Property Set Use Definition:
/// The shared property sets relating to the IfcBeamType
/// are defined by the IfcPropertySet and are attached by the
/// HasPropertySets attribute. The following property set
/// definitions specific to the IfcBeamType are part of this
/// IFC release:
/// NOTE There is no differentiation between
/// properties within the property set that are only assignable to
/// IfcBeamType and those that are only assignable to
/// IfcBeam. If the same property is assigned to the
/// IfcBeamType and the IfcBeam being an occurrence of
/// the IfcBeamType, then the occurrence property overrides
/// the type property.
/// 
/// Pset_BeamCommon: common property set for all
/// beam types.
/// 
/// Profile Use Definition:
/// The shared profile definition is defined by assigning an
/// IfcMaterialProfileSet (see material use definition above).
/// The IfcMaterialProfile refers to the subtype of
/// IfcProfileDef that is the common profile for all beam
/// occurrence, if used. It is only applicable if the
/// IfcBeamType has only occurrences of type
/// IfcBeamStandardCase (see definition of
/// IfcBeamStandardCase for further information).
/// NOTE The attribute ProfileName of the
/// IfcProfileDef subtype, referenced in
/// IfcMaterialProfile should contain a standardized profile
/// name according to local standards. However, an additional
/// geometric representation of the profile is necessary (e.g. as
/// IfcExtrudedAreaSolid). An importing application is allowed
/// to check for the existence of the profile name: in case of
/// identifying it as a standardized name, the corresponding profile
/// geometry and possibly other cross sectional properties can be
/// read from a library. Otherwise the geometric representation and
/// possible non geometric IfcProfileProperties have to be
/// used.
/// Geometry Use Definition:
/// The IfcBeamType may define the shared geometric
/// representation for all beam occurrences. The
/// RepresentationMaps attribute refers to a list of
/// IfcRepresentationMap's, that allow for multiple geometric
/// representations (e.g. with IfcShaperepresentation's having
/// an RepresentationIdentifier 'Box', 'Axis', or 'Body'). It
/// is only applicable if the IfcBeamType has only occurrences
/// of type IfcBeam (See geometric use definition of
/// IfcBeam for further information).
/// NOTE If the IfcBeamType has an
/// associated IfcMaterialProfileSet, then no shared geometric
/// representation shall be provided.
/// NOTE The product shape representations are
/// defined as RepresentationMaps (attribute of the supertype
/// IfcTypeProduct), which get assigned by an element
/// occurrence instance through the
/// IfcShapeRepresentation.Item[n] being an
/// IfcMappedItem. See IfcTypeProduct for further
/// information.
/// NOTE The values of attributes
/// RepresentationIdentifier and RepresentationType of
/// IfcShapeRepresentation are restricted in the same way as
/// those for IfcBeam and
/// IfcBeamStandardCase
class IfcBeamType : public IfcBuildingElementType {
public:
    /// Identifies the predefined types of a beam element from which the type required may be set.
    IfcBeamTypeEnum::IfcBeamTypeEnum PredefinedType() const;
    void setPredefinedType(IfcBeamTypeEnum::IfcBeamTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcBuildingElementType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcBeamTypeEnum; } return IfcBuildingElementType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcBuildingElementType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcBeamType (IfcAbstractEntity* e);
    IfcBeamType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcBeamTypeEnum::IfcBeamTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcBeamType > list;
};

class IfcBezierCurve : public IfcBSplineCurve {
public:
    virtual unsigned int getArgumentCount() const { return 5; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcBSplineCurve::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcBSplineCurve::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcBSplineCurve::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcBezierCurve (IfcAbstractEntity* e);
    IfcBezierCurve (int v1_Degree, IfcTemplatedEntityList< IfcCartesianPoint >::ptr v2_ControlPointsList, IfcBSplineCurveForm::IfcBSplineCurveForm v3_CurveForm, bool v4_ClosedCurve, bool v5_SelfIntersect);
    typedef IfcTemplatedEntityList< IfcBezierCurve > list;
};
/// The energy conversion device type IfcBoilerType defines commonly shared information for occurrences of boilers.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a boiler specification (i.e. the specific product information, that is common to all occurrences of that product type).  Boiler types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcBoilerType are represented by instances of IfcBoiler. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcEnergyConversionDeviceType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_BoilerTypeCommon 
/// 
/// The following property set definitions are applicable to this entity according to the PredefinedType attribute:  
/// Pset_BoilerTypeSteam (STEAM) 
/// 
/// Material Use Definition 
/// The material of the IfcBoilerType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Body': The primary material from which the object is constructed. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcBoilerType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcBoiler for standard port definitions.
class IfcBoilerType : public IfcEnergyConversionDeviceType {
public:
    /// Defines types of boilers.
    IfcBoilerTypeEnum::IfcBoilerTypeEnum PredefinedType() const;
    void setPredefinedType(IfcBoilerTypeEnum::IfcBoilerTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcEnergyConversionDeviceType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcBoilerTypeEnum; } return IfcEnergyConversionDeviceType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcEnergyConversionDeviceType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcBoilerType (IfcAbstractEntity* e);
    IfcBoilerType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcBoilerTypeEnum::IfcBoilerTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcBoilerType > list;
};
/// Definition from ISO 6707-1:1989: Major functional part
/// of a building, examples are foundation, floor, roof, wall.
/// The building element comprises all
/// elements that are primarily part of the construction of a
/// building, i.e., its structural and space separating system.
/// EXAMPLEs of building elements are walls,
/// beams, or doors, they are all physically existent and tangible
/// things.
/// The IfcBuildingElement utilizes the following
/// capabilities mainly through inverse attributes referencing
/// objectified relationships:
/// NOTE View definitions and implementer
/// agreements will determine those relationships that have to be
/// supported in actual exchange.
/// 
/// Grouping - being part of a logical group of objects
/// 
/// objectified relationship: IfcRelAssignsToGroup
/// object referenced by relationship: IfcGroup (and
/// subtypes)
/// inverse attribute: HasAssignment
/// 
/// Work processes - reference to work tasks, in which this
/// building element is used
/// 
/// objectified relationship: IfcRelAssignsToProcess
/// object referenced by relationship: IfcProcess (and
/// subtypes)
/// inverse attribute: HasAssignments
/// 
/// Structural member reference - information whether the
/// building element is represented in a structural analysis model by
/// a structural member
/// 
/// objectified relationship: IfcRelAssignsToProduct
/// object referenced by relationship: IfcStructuralMember
/// (and by default IfcStructuralCurveMember)
/// inverse attribute: HasAssignments
/// 
/// Aggregation - aggregated together with other elements to form
/// an aggregate
/// 
/// objectified relationship: IfcRelAggregates
/// object referenced by relationship: IfcElement (and
/// subtypes)
/// inverse attribute (for container): IsDecomposedBy
/// inverse attribute (for contained parts):
/// Decomposes
/// 
/// Material - assignment of material used by this building
/// element
/// 
/// objectified relationship:
/// IfcRelAssociatesMaterial
/// object referenced by relationship: IfcMaterialSelect
/// (and selected items)
/// inverse attribute: HasAssociations
/// 
/// Classification - assigned reference to an external
/// classification
/// 
/// objectified relationship:
/// IfcRelAssociatesClassification
/// object referenced by relationship:
/// IfcClassificationNotationSelect (and selected items,
/// default IfcClassificationReference)
/// inverse attribute: HasAssociations
/// 
/// Library - assigned reference to an external library item
/// reference
/// 
/// objectified relationship:
/// IfcRelAssociatesClassification
/// object referenced by relationship: IfcLibrarySelect
/// (and selected items, default IfcLibraryReference)
/// inverse attribute: HasAssociations
/// 
/// Documentation - assigned reference to an external
/// documentation
/// 
/// objectified relationship:
/// IfcRelAssociatesDocumentation
/// object referenced by relationship: IfcDocumentSelect
/// (and selected items, default IfcDocumentReference)
/// inverse attribute: HasAssociations
/// 
/// Type - reference to the common product type information for
/// the element occurrence
/// 
/// objectified relationship: IfcRelDefinesByType
/// object referenced by relationship:
/// IfcBuildingElementType (and subtypes)
/// inverse attribute: IsTypedBy
/// 
/// Properties - reference to all attached properties, including
/// quantities
/// 
/// objectified relationship:
/// IfcRelDefinesByProperties
/// object referenced by relationship:
/// IfcPropertySetDefinition (default
/// IfcPropertySet)
/// inverse attribute: IsDefinedBy
/// 
/// Connection - connectivity to other elements, including the
/// definition of the joint
/// 
/// objectified relationship: IfcRelConnectsElements
/// object referenced by relationship: IfcElement
/// inverse attribute: ConnectedTo
/// inverse attribute: ConnectedFrom
/// 
/// Realization - information, whether the building element is
/// used to realize a connection (e.g. as a weld in a connection
/// between two members)
/// 
/// objectified relationship:
/// IfcRelConnectsWithRealizingElements
/// object referenced by relationship: IfcElement
/// inverse attribute: IsConnectionRealization
/// 
/// Assignment to spatial structure - hierarchical assignment to
/// the right level within the spatial structure
/// 
/// objectified relationship:
/// IfcRelContainedInSpatialStructure
/// object referenced by relationship:
/// IfcSpatialStructureElement
/// inverse attribute: ContainedInStructure
/// 
/// Reference to spatial structure(s) - non hierarchical
/// reference to one or more elements within the spatial structure
/// (e.g. a curtain wall, being contained in the building, references
/// several stories)
/// 
/// objectified relationship:
/// IfcRelContainedInSpatialStructure
/// object referenced by relationship:
/// IfcSpatialElement
/// inverse attribute: ContainedInStructure
/// 
/// Boundary - provision of space boundaries by this building
/// element
/// 
/// objectified relationship: IfcRelSpaceBoundary
/// object referenced by relationship: IfcSpace
/// inverse attribute: ProvidesBoundaries
/// 
/// Coverings - assignment of covering elements to this building
/// element (note: normally covering elements are assigned to the
/// space, only used for special cases)
/// 
/// objectified relationship:
/// IfcRelCoversBldgElements
/// object referenced by relationship: IfcCovering
/// inverse attribute: HasCoverings
/// 
/// Voids - information, whether the building element includes
/// openings, recesses or other voids
/// 
/// objectified relationship: IfcRelVoidsElement
/// object referenced by relationship:
/// IfcFeatureElementSubtraction (default
/// IfcOpeningElement)
/// inverse attribute: HasOpenings
/// 
/// Projection - information, whether the building element has
/// projections (such as a fascia)
/// 
/// objectified relationship: IfcRelProjectsElement
/// object referenced by relationship:
/// IfcFeatureElementAddition (default
/// IfcProjectionElement)
/// inverse attribute: HasProjections
/// 
/// Filling - information whether the building element is used to
/// fill openings
/// 
/// objectified relationship: IfcRelFillsElement
/// object referenced by relationship:
/// IfcOpeningElement
/// inverse attribute: FillsVoids
/// 
/// HISTORY New entity in IFC Release 1.0
/// 
/// Property Set Use Definition
/// The properties relating to the IfcBuildingElement are
/// defined by the IfcPropertySet and attached by the
/// IfcRelDefinesByProperties. A detailed specification for
/// individual property sets applicable is introduced at the level of
/// subtypes of IfcBuildingElement.
/// NOTE The applicable property sets are provided
/// by an xml property set definition that includes multilingual
/// translations for each property. The xml definition file format,
/// psdXML, can be used to automatically configure the properties for
/// each building element.
/// Quantity Use Definition:
/// The quantities relating to the IfcBuildingElement are
/// defined by the IfcElementQuantity and attached by the
/// IfcRelDefinesByProperties. A detailed specification for
/// individual quantities is introduced at the level of subtypes of
/// IfcBuildingElement.
/// NOTE The applicable element quantities are
/// provided by an xml quantity definition that includes multilingual
/// translations for each quantity. The xml definition file format,
/// qdXML, can be used to automatically configure the quantities for
/// each building element.
/// 
/// Geometry Use Definitions
/// The geometric representation of any IfcBuildingElement
/// is given by the IfcProductDefinitionShape and
/// IfcLocalPlacement allowing multiple geometric
/// representations.
/// Local Placement
/// The local placement for any IfcBuildingElement is
/// defined in its supertype IfcProduct. It is defined by the
/// IfcLocalPlacement, which defines the local coordinate
/// system that is referenced by all geometric representations.
/// Further constraints are defined at the level of its subtypes.
/// Geometric Representations
/// An IfcBuildingElement can be represented by one or
/// several geometric representations. The following representation
/// identifiers are used for building elements 'Box', 'Axis',
/// 'FootPrint', 'Surface', and 'Body'. A detailed specification is
/// introduced at the level of subtypes.
/// NOTE Some subtypes of
/// IfcBuildingElement may exclude one or several geometric
/// representation types, e.g. standard case elements, such as
/// IfcWallStandardCase, do not allow the use of
/// 'SurfaceModel', 'Brep', 'AdvancedBrep', and
/// 'MappedRepresentation'. In addition view definitions and
/// implementer agreements may restrict the use of geometric
/// representation types, e.g. the use of
/// 'AdvancedBrep'.
/// Box Representation
/// Any IfcBuildingElement may be represented as a bounding
/// box, which shows the maximum extend of the body within the
/// coordinated system established by the IfcLocalPlacement.
/// The bounding box representation is the simplest geometric
/// representation available. The following attribute values for the
/// IfcShapeRepresentation holding this geometric
/// representation shall be used:
/// 
/// RepresentationIdentifier : 'Box'
/// RepresentationType : 'BoundingBox'
/// 
/// As shown in Figure 22, the bounding box representation is given by an
/// IfcShapeRepresentation that includes a single item, an
/// IfcBoundingBox.
/// 
/// Figure 22 — Building element box representation
/// 
/// Axis Representation
/// Some IfcBuildingElement may be represented by an axis
/// as an abstract geometric representation. See each subtype for
/// specific guidance. The following attribute values for the
/// IfcShapeRepresentation holding this geometric
/// representation are used:
/// 
/// RepresentationIdentifier : 'Axis'
/// RepresentationType : 'Curve2D', 'Curve3D'
/// 
/// Surface Representation
/// Some IfcBuildingElement may be represented by an
/// surface as an abstract geometric representation. See each subtype
/// for specific guidance. The following attribute values for the
/// IfcShapeRepresentation holding this geometric
/// representation are used:
/// 
/// RepresentationIdentifier : 'Surface'
/// RepresentationType : 'Surface2D', 'Surface3D'
/// 
/// FootPrint Representation
/// Any IfcBuildingElement may be represented by a
/// footprint as a specific floor plan geometric representation. See
/// each subtype for specific guidance. The following attribute
/// values for the IfcShapeRepresentation holding this
/// geometric representation are used:
/// 
/// RepresentationIdentifier : 'FootPrint'
/// RepresentationType : 'GeometricCurveSet',
/// 'Annotation2D'
/// 
/// Body Representation
/// The body representation of any IfcBuildingElement can
/// have the following representation types: 'SurfaceModel', 'Brep',
/// 'AdvancedBrep', and 'MappedRepresentation'. Other representation
/// types might be specified at the level of subtypes.
/// SurfaceModel Representation Type
/// Any IfcBuildingElement (so far no further constraints
/// are defined at the level of its subtypes) may be represented as a
/// single or multiple surface models, based on either shell or face
/// based models. The following attribute values for the
/// IfcShapeRepresentation holding this geometric
/// representation shall be used:
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'SurfaceModel'
/// 
/// In some cases it may be useful to also expose a simple
/// representation as a bounding box representation of the same
/// complex shape.
/// 
/// As shown in Figure 23, the surface model representation is given by an IfcShapeRepresentation, which includes a single item which is either:
/// 
/// IfcShellBasedSurfaceModel, or
/// IfcFaceBasedSurfaceModel.
/// 
/// Figure 23 — Building element surface model representation
/// 
/// Brep Representation Type
/// Any IfcBuildingElement (so far no further constraints
/// are defined at the level of its subtypes) may be represented as a
/// single or multiple Boundary Representation elements (which are
/// restricted to faceted Brep with or without voids). The Brep
/// representation allows for the representation of complex element
/// shape. The following attribute values for the
/// IfcShapeRepresentation holding this geometric
/// representation shall be used:
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'Brep'
/// 
/// In some cases it may be useful to also expose a simple
/// representation as a bounding box representation of the same
/// complex shape.
/// As shown in Figure 24, the Brep representation is given by an IfcShapeRepresentation, which includes one or more items, all of type IfcFacetedBrep.
/// 
/// Figure 24 — Building element body boundary representation
/// 
/// AdvancedBrep Representation Type
/// An IfcBuildingElement (so far no further constraints
/// are defined at the level of its subtypes or by view definitions)
/// may be represented as a single or multiple Boundary
/// Representation elements (which are based on advanced surfaces,
/// usually refered to as NURBS surfaces). The AdvancedBrep
/// representation allows for the representation of complex free-form
/// element shape. The following attribute values for the
/// IfcShapeRepresentation holding this geometric
/// representation shall be used:
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'AdvancedBrep'
/// 
/// In some cases it may be useful to also expose a simple
/// representation as a bounding box representation of the same
/// complex shape.
/// MappedRepresentation Representation Type
/// Any IfcBuildingElement (so far no further constraints
/// are defined at the level of its subtypes) may be represented
/// using the MappedRepresentation. This shall be supported as it
/// allows for reusing the geometry definition of a type at all
/// occurrences of the same type. The following attribute values for
/// the IfcShapeRepresentation holding this geometric
/// representation shall be used:
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'MappedRepresentation'
/// 
/// The same constraints, as given for 'SurfaceModel', 'Brep', and
/// 'AdvancedBrep' geometric representation, shall apply to the
/// MappedRepresentation of the
/// IfcRepresentationMap.
class IfcBuildingElement : public IfcElement {
public:
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcBuildingElement (IfcAbstractEntity* e);
    IfcBuildingElement (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag);
    typedef IfcTemplatedEntityList< IfcBuildingElement > list;
};

class IfcBuildingElementComponent : public IfcBuildingElement {
public:
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcBuildingElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcBuildingElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcBuildingElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcBuildingElementComponent (IfcAbstractEntity* e);
    IfcBuildingElementComponent (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag);
    typedef IfcTemplatedEntityList< IfcBuildingElementComponent > list;
};
/// Definition from IAI: Layers or major components as subordinate
/// parts of a building element. Typical usage examples include precast concrete
/// sandwich walls, where the layers may have different geometry representations.
/// In this case the layered material representation does not sufficiently describe
/// the element. Each layer is represented by an own instance of the
/// IfcBuildingElementPart with its own geometry description.
/// 
/// The kind of building element part is further specified by a
/// corresponding instance of IfcBuildingElementPartType,
/// referred to by IfcRelDefinesByType.
/// 
/// HISTORY New entity in IFC Release 2x2
/// 
/// IFC 2x4 change:
/// Moved from from IfcStructuralElementsDomain schema to
/// IfcSharedComponentElements schema, compatible change of supertype,
/// attribute PredefinedType added.
class IfcBuildingElementPart : public IfcBuildingElementComponent {
public:
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcBuildingElementComponent::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcBuildingElementComponent::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcBuildingElementComponent::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcBuildingElementPart (IfcAbstractEntity* e);
    IfcBuildingElementPart (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag);
    typedef IfcTemplatedEntityList< IfcBuildingElementPart > list;
};
/// Definition from IAI: The IfcBuildingElementProxy
/// is a proxy definition that provides the same functionality as an
/// IfcBuildingElement, but without having a predefined meaning
/// of the special type of building element, it represents. Proxies can
/// also be used as spatial place holders or provisions, that maybe
/// later replaced by special types of elements.
/// One use of the proxy object is a provision for voids, i.e. where
/// a particular volume of space is requested by some engineering
/// function that might later be accepted or rejected and if accepted
/// potentially transformed into a void within a building element, like
/// a wall opening, or a slab opening. The provision for voids is
/// exchanged as an IfcBuildingElementProxy with the
/// PredefinedType = ProvisionForVoid.
/// Other usages of IfcBuildingElementProxy include:
/// 
/// The IfcBuildingElementProxy can be used to exchange
/// special types of building elements for which the current IFC
/// Release does not yet provide a semantic definition.
/// The IfcBuildingElementProxy can also be used to
/// represent building elements for which the participating
/// applications can not provide additional semantic
/// classification.
/// 
/// HISTORY  New entity
/// in IFC Release 2x.
/// IFC2x4 CHANGE  The attribute
/// CompositionType has been replaced by PredefinedType,
/// being a superset of the enumerators.
/// Type Use Definition
/// The IfcBuildingElementProxy defines the occuurence of any
/// building element, common information about the types (or styles) is
/// handled by IfcBuildingElementProxyType.
/// The IfcBuildingElementProxyType (if present) may
/// establish the common type name, usage (or predefined) type, common
/// material, common set of properties and common shape representations
/// (using IfcRepresentationMap). The
/// IfcBuildingElementProxyType is attached using the
/// IfcRelDefinedByType.RelatingType objectified relationship
/// and is accessible by the inverse IsTypedBy attribute.
/// 
/// NOTE The IfcBuildingElementProxyType can be used
/// to share common information among many occurrences of the same
/// proxy without establishing a particular semantic meaning of the
/// type.
/// 
/// If no IfcBuildingElementProxyType is attached (i.e. if
/// only occurrence information is given) the PredefinedType
/// should be provided. If set to .USERDEFINED. a user defined value
/// can be provided by the ObjectType attribute.
/// Material Use Definition
/// The material of the IfcBuildingElementProxy is defined by
/// IfcMaterial and attached by the
/// IfcRelAssociatesMaterial.RelatingMaterial. It is
/// accessible by the inverse HasAssociations relationship.
/// Note It is illegal to assign an
/// IfcMaterial to an IfcBuildingElementProxy with the
/// PredefinedType = ProvisionForVoid.
/// Material information can also be given at the
/// IfcBuildingElementProxyType, defining the common attribute
/// data for all occurrences of the same type. It is then
/// accessible by the inverse IsTypedBy relationship pointing to
/// IfcBuildingElementProxyType.HasAssociations and via
/// IfcRelAssociatesMaterial.RelatingMaterial to
/// IfcMaterial. If both are given, then the material directly
/// assigned to IfcBuildingElementProxy overrides the material
/// assigned to IfcBuildingElementProxyType.
/// Property Set Use Definition:
/// The property sets relating to the IfcBuildingElementProxy
/// are defined by the IfcPropertySet and attached by the
/// IfcRelDefinesByProperties relationship. It is accessible by
/// the inverse IsDefinedBy relationship. The following property
/// set definitions specific to the IfcBuildingElementProxy are
/// part of this IFC release:
/// 
/// Pset_BuildingElementProxyCommon: common
/// property set for all occurrences of building element proxies.
/// Pset_BuildingElementProxyProvisionForVoid:
/// specific property set for all occurrences of building element proxy
/// with the PredefinedType: PROVISIONFORVOID.
/// 
/// Property sets can also be given at the
/// IfcBuildingElementProxyType, defining the common property
/// data for all occurrences of the same type. It is then
/// accessible by the inverse IsTypedBy relationship pointing to
/// IfcBuildingElementProxyType.HasPropertySets. If both are
/// given, then the properties directly assigned to
/// IfcBuildingElementProxy overrides the properties assigned to
/// IfcBuildingElementProxyType.
/// Containment Use Definition
/// The IfcBuildingElementProxy, as any subtype of
/// IfcBuildingElement, may participate in two different
/// containment relationships. The first (and in most implementation
/// scenarios mandatory) relationship is the hierachical spatial
/// containment, the second (optional) relationship is the aggregation
/// within an element assembly.
/// 
/// The IfcBuildingElementProxy is places within the project
/// spatial hierarchy using the objectified relationship
/// IfcRelContainedInSpatialStructure, refering to it by its
/// inverse attribute SELF\IfcElement.ContainedInStructure.
/// Subtypes of IfcSpatialStructureElement are valid
/// spatial containers, with IfcBuildingStorey being the default
/// container.
/// The IfcBuildingElementProxy may be aggregated into an
/// element assembly using the objectified relationship
/// IfcRelAggregates, refering to it by its inverse attribute
/// SELF\IfcObjectDefinition.Decomposes. Any subtype of
/// IfcElement can be an element assembly, with
/// IfcElementAssembly as a special focus subtype. In this case
/// it should not be additionally contained in the project spatial
/// hierarchy, i.e. SELF\IfcElement.ContainedInStructure
/// should be NIL.
/// 
/// Geometry Use Definition
/// The geometric representation of IfcBuildingElementProxy
/// is given by the IfcProductDefinitionShape, allowing multiple
/// geometric representations. Included are:
/// Local Placement
/// The local placement for any IfcBuildingElementProxy is
/// defined in its supertype IfcProduct. It is defined by the
/// IfcLocalPlacement, which defines the local coordinate system
/// that is referenced by all geometric representations. The local
/// placement can be given relativly.
/// 
/// The PlacementRelTo relationship of
/// IfcLocalPlacement shall point (if given) to the local
/// placement of the same IfcSpatialStructureElement, which is
/// used in the ContainedInStructure inverse attribute, or to a
/// spatial structure element at a higher level, referenced by
/// that.
/// If the relative placement is not used, the absolute placement
/// is defined within the world coordinate system.
/// 
/// Geometric Representation
/// Currently, the 'FootPrint', 'Body', and 'Box' representations
/// are supported. The 'Box' representation includes the representation
/// type 'BoundingBox' and is explained at
/// IfcBuildingElement.
/// FootPrint Representation
/// Any building element proxy may be represented by a geometric
/// curve set, given by a collection of 2D points and curves. The foot
/// pring geometric representation of IfcBuildingElementProxy is
/// defined using the 'FootPrint' representation.
/// 
/// RepresentationIdentifier: 'FootPrint'
/// RepresentationType: 'GeometricCurveSet',
/// 'Annotation2D'
/// 
/// Body Representation
/// The body representation of IfcBuildingElementProxy can be
/// represented using the representation types 'GeometricSet',
/// 'SweptSolid', 'CSG' 'SurfaceModel', 'Brep', and
/// 'MappedRepresentation'. The representation types 'SurfaceModel',
/// 'Brep', and 'MappedRepresentation' are explained at
/// IfcBuildingElement.
/// GeometricSet Representation Type
/// Any building element proxy may be represented by a geometric
/// set, given by a collection of 2D and 3D points, curves, and
/// surfaces. It represents the body of the proxy object, when no
/// topological structure is available. The following attribute values
/// for the IfcShapeRepresentation holding this geometric
/// representation shall be used:
/// 
/// RepresentationIdentifier: 'Body'
/// RepresentationType: 'GeometricSet'
/// 
/// SweptSolid Representation Type
/// Any building element proxy may be represented by swept solid
/// geometry (either by extrusion or by revolution). The following
/// attribute values for the IfcShapeRepresentation holding this
/// geometric representation shall be used:
/// 
/// RepresentationIdentifier: 'Body'
/// RepresentationType: 'SweptSolid'
/// 
/// No further restrictions (e.g., for the profile or extrusion
/// direction) are defined at this level. A single or multiple swept
/// area solid(s) can be the Items of the
/// IfcShapeRepresentation.
/// CSG Representation Type
/// Any building element proxy may be represented by a CSG primitive
/// or CSG tree. The following attribute values for the
/// IfcShapeRepresentation holding this geometric representation
/// shall be used:
/// 
/// RepresentationIdentifier: 'Body'
/// RepresentationType: 'CSG'
/// 
/// No further restrictions (e.g., for the depths of the CSG tree)
/// are defined at this level.
class IfcBuildingElementProxy : public IfcBuildingElement {
public:
    /// Whether the optional attribute CompositionType is defined for this IfcBuildingElementProxy
    bool hasCompositionType() const;
    IfcElementCompositionEnum::IfcElementCompositionEnum CompositionType() const;
    void setCompositionType(IfcElementCompositionEnum::IfcElementCompositionEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcBuildingElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcElementCompositionEnum; } return IfcBuildingElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "CompositionType"; } return IfcBuildingElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcBuildingElementProxy (IfcAbstractEntity* e);
    IfcBuildingElementProxy (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcElementCompositionEnum::IfcElementCompositionEnum > v9_CompositionType);
    typedef IfcTemplatedEntityList< IfcBuildingElementProxy > list;
};
/// Definition from IAI:
///   TheÿIfcBuildingElementProxyType defines a list of
///   commonly shared property set definitions of a building
///   element proxy and an optional set of product
///   representations. It is used to define an element
///   specification (i.e. the specific product information, that
///   is common to all occurrences of that product type).
/// 
/// NOTEÿ The product representations are defined as
///   representation maps (at the level of the supertype
///   IfcTypeProduct, which gets assigned by an element
///   occurrence instance through the
///   IfcShapeRepresentation.Item[1] being an
///   IfcMappedItem.
/// 
/// A building element proxy type is used to define the common
///   properties of a certain type of a building element proxy
///   that may be applied to many instances of thatÿtype to
///   assign a specific style. Building element proxy typesÿmay
///   be exchanged without being already assigned to occurrences.
/// 
/// NOTE  Although an building element proxy does not have
///   a predefined ontological meaning the provision of a type may be
///   helpful in sharing information among multiple occurrences. Applications 
///   that provide type information for element types not yet included in the
///   current IFC specification can use the IfcBuildingElementProxyType
///   to exchange such types.
/// 
/// The occurrences of the IfcBuildingElementProxyType
///   are represented by instances of
///   IfcBuildingElementProxy.
/// 
/// HISTORYÿ New entity in
///   Release IFC2x Edition 3.
class IfcBuildingElementProxyType : public IfcBuildingElementType {
public:
    /// Predefined types to define the particular type of an building element proxy. There may be property set definitions available for each predefined or user defined type.
    IfcBuildingElementProxyTypeEnum::IfcBuildingElementProxyTypeEnum PredefinedType() const;
    void setPredefinedType(IfcBuildingElementProxyTypeEnum::IfcBuildingElementProxyTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcBuildingElementType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcBuildingElementProxyTypeEnum; } return IfcBuildingElementType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcBuildingElementType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcBuildingElementProxyType (IfcAbstractEntity* e);
    IfcBuildingElementProxyType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcBuildingElementProxyTypeEnum::IfcBuildingElementProxyTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcBuildingElementProxyType > list;
};
/// The flow fitting type IfcCableCarrierFittingType defines commonly shared information for occurrences of cable carrier fittings.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a cable carrier fitting specification (i.e. the specific product information, that is common to all occurrences of that product type).  Cable Carrier Fitting types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcCableCarrierFittingType are represented by instances of IfcCableCarrierFitting. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcFlowFittingType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_CableCarrierFittingTypeCommon 
/// 
/// Material Use Definition 
/// The material of the IfcCableCarrierFittingType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Body': The primary material from which the object is constructed. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcCableCarrierFittingType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcCableCarrierFitting for standard port definitions.
class IfcCableCarrierFittingType : public IfcFlowFittingType {
public:
    /// Identifies the predefined types of cable carrier fitting from which the type required may be set.
    IfcCableCarrierFittingTypeEnum::IfcCableCarrierFittingTypeEnum PredefinedType() const;
    void setPredefinedType(IfcCableCarrierFittingTypeEnum::IfcCableCarrierFittingTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcFlowFittingType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcCableCarrierFittingTypeEnum; } return IfcFlowFittingType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcFlowFittingType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCableCarrierFittingType (IfcAbstractEntity* e);
    IfcCableCarrierFittingType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcCableCarrierFittingTypeEnum::IfcCableCarrierFittingTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcCableCarrierFittingType > list;
};
/// The flow segment type IfcCableCarrierSegmentType defines commonly shared information for occurrences of cable carrier segments.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a cable carrier segment specification (i.e. the specific product information, that is common to all occurrences of that product type).  Cable Carrier Segment types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcCableCarrierSegmentType are represented by instances of IfcCableCarrierSegment. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcFlowSegmentType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_CableCarrierSegmentTypeCommon 
/// 
/// The following property set definitions are applicable to this entity according to the PredefinedType attribute:  
/// Pset_CableCarrierSegmentTypeCableLadderSegment (CABLELADDERSEGMENT) 
/// Pset_CableCarrierSegmentTypeCableTraySegment (CABLETRAYSEGMENT) 
/// Pset_CableCarrierSegmentTypeCableTrunkingSegment (CABLETRUNKINGSEGMENT) 
/// Pset_CableCarrierSegmentTypeConduitSegment (CONDUITSEGMENT) 
/// 
/// Material Use Definition 
/// The material of the IfcCableCarrierSegmentType is defined by IfcMaterialProfileSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialProfileSet.MaterialProfiles[n].Name shall be used: 
/// 
/// 'Body': Material from which the object is constructed. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcCableCarrierSegmentType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcCableCarrierSegment for standard port definitions.
class IfcCableCarrierSegmentType : public IfcFlowSegmentType {
public:
    /// Identifies the predefined types of cable carrier segment from which the type required may be set.
    IfcCableCarrierSegmentTypeEnum::IfcCableCarrierSegmentTypeEnum PredefinedType() const;
    void setPredefinedType(IfcCableCarrierSegmentTypeEnum::IfcCableCarrierSegmentTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcFlowSegmentType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcCableCarrierSegmentTypeEnum; } return IfcFlowSegmentType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcFlowSegmentType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCableCarrierSegmentType (IfcAbstractEntity* e);
    IfcCableCarrierSegmentType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcCableCarrierSegmentTypeEnum::IfcCableCarrierSegmentTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcCableCarrierSegmentType > list;
};
/// The flow segment type IfcCableSegmentType defines commonly shared information for occurrences of cable segments.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a cable segment specification (i.e. the specific product information, that is common to all occurrences of that product type).  Cable Segment types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcCableSegmentType are represented by instances of IfcCableSegment. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcFlowSegmentType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_CableSegmentTypeCommon 
/// Pset_ElectricalDeviceCommon 
/// 
/// The following property set definitions are applicable to this entity according to the PredefinedType attribute:  
/// Pset_CableSegmentTypeBusbarSegment (BUSBARSEGMENT) 
/// Pset_CableSegmentTypeCableSegment (CABLESEGMENT) 
/// Pset_CableSegmentTypeConductorSegment (CONDUCTORSEGMENT) 
/// 
/// Material Use Definition 
/// The material of the IfcCableSegmentType is defined by IfcMaterialProfileSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialProfileSet.MaterialProfiles[n].Name shall be used: 
/// 
/// 'Conductor': The material from which the conductor is constructed such as Aluminium or Copper. 
/// 'Insulation': The material from which the insulation is constructed such as PVC, PEX, EPR, etc. 
/// 'Screen': The material from which the screen that covers the sheath is constructed (mantel) such as Aluminium, Copper, Steel , Lead. 
/// 'Sheath': The outer sheathing of the cable which may be color-coded. 
/// 
/// Composition Use Definition 
/// The IfcCableSegmentType may be aggregated into components using IfcRelAggregates where RelatingObject refers to the enclosing IfcCableSegmentType and RelatedObjects contains one or more components.  Components are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Aggregation use is defined for the following predefined types:
/// 
/// CABLESEGMENT: May contain IfcCableSegment components having PredefinedType CORESEGMENT.  Cable segments may be aggregated into cable cores. 
/// CORESEGMENT: May contain IfcCableSegment components having PredefinedType CONDUCTORSEGMENT.  Cable cores may be aggregated into cable conductors. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcCableSegmentType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcCableSegment for standard port definitions.
class IfcCableSegmentType : public IfcFlowSegmentType {
public:
    /// Identifies the predefined types of cable segment from which the type required may be set.
    IfcCableSegmentTypeEnum::IfcCableSegmentTypeEnum PredefinedType() const;
    void setPredefinedType(IfcCableSegmentTypeEnum::IfcCableSegmentTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcFlowSegmentType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcCableSegmentTypeEnum; } return IfcFlowSegmentType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcFlowSegmentType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCableSegmentType (IfcAbstractEntity* e);
    IfcCableSegmentType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcCableSegmentTypeEnum::IfcCableSegmentTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcCableSegmentType > list;
};
/// The energy conversion device type IfcChillerType defines commonly shared information for occurrences of chillers.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a chiller specification (i.e. the specific product information, that is common to all occurrences of that product type).  Chiller types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcChillerType are represented by instances of IfcChiller. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcEnergyConversionDeviceType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_ChillerTypeCommon 
/// 
/// Material Use Definition 
/// The material of the IfcChillerType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Casing': Material from which the casing is constructed. 
/// 'Refrigerant': Refrigerant material. 
/// 
/// Composition Use Definition 
/// The IfcChillerType may be aggregated into components using IfcRelAggregates where RelatingObject refers to the enclosing IfcChillerType and RelatedObjects contains one or more components.  Components are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Aggregation use is defined for the following predefined types:
/// 
/// (All Types): May contain IfcDistributionElement components.  Chillers may aggregate distribution flow elements forming a refrigeration cycle (compressor, condenser, valve, evaporator), as well as control elements. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcChillerType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcChiller for standard port definitions.
class IfcChillerType : public IfcEnergyConversionDeviceType {
public:
    /// Defines the typical types of chillers (e.g., air-cooled, water-cooled, etc.).
    IfcChillerTypeEnum::IfcChillerTypeEnum PredefinedType() const;
    void setPredefinedType(IfcChillerTypeEnum::IfcChillerTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcEnergyConversionDeviceType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcChillerTypeEnum; } return IfcEnergyConversionDeviceType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcEnergyConversionDeviceType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcChillerType (IfcAbstractEntity* e);
    IfcChillerType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcChillerTypeEnum::IfcChillerTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcChillerType > list;
};
/// Definition from ISO/CD 10303-42:1992: An IfcCircle is defined by a radius and the location and orientation of the circle. Interpretation of data should be as follows: 
/// 
/// C = SELF\IfcConic.Position.Location 
///   x = SELF\IfcConic.Position.P[1] 
///   y = SELF\IfcConic.Position.P[2] 
///   z = SELF\IfcConic.Position.P[3] 
///   R = Radius
/// 
/// and the circle is parameterized as  
/// 
/// The parameterization range is 0 £
///   u £2p (or 0
///   £u £
///   360 degree). In the placement coordinate system defined above, the circle is
///   the equation C = 0, where 
/// 
/// The positive sense of the circle at any point is in the tangent direction, T, to the curve at the point, where 
/// 
/// NOTE  A circular arc is defined by using the trimmed curve (IfcTrimmedCurve) entity in conjunction with the circle (IfcCircle) entity as the BasisCurve.
/// 
/// NOTE  Corresponding ISO 10303 entity: circle, please refer to ISO/IS 10303-42:1994, p. 38 for the final definition of the formal standard.
/// 
/// HISTORY  New class in IFC Release 1.0
/// 
/// Figure 278 illustrates the definition of the IfcCircle within the (in this case three-dimensional) position coordinate system. 
/// 
/// Figure 278 — Circle geometry
class IfcCircle : public IfcConic {
public:
    /// The radius of the circle, which shall be greater than zero.
    double Radius() const;
    void setRadius(double v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 1: return IfcUtil::Argument_DOUBLE; } return IfcConic::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 1: return Type::IfcPositiveLengthMeasure; } return IfcConic::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 1: return "Radius"; } return IfcConic::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCircle (IfcAbstractEntity* e);
    IfcCircle (IfcAxis2Placement* v1_Position, double v2_Radius);
    typedef IfcTemplatedEntityList< IfcCircle > list;
};
/// The energy conversion device type IfcCoilType defines commonly shared information for occurrences of coils.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a coil specification (i.e. the specific product information, that is common to all occurrences of that product type).  Coil types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcCoilType are represented by instances of IfcCoil. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcEnergyConversionDeviceType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_CoilTypeCommon 
/// Pset_CoilTypeHydronic 
/// 
/// Material Use Definition 
/// The material of the IfcCoilType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Body': The primary material from which the object is constructed. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcCoilType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcCoil for standard port definitions.
class IfcCoilType : public IfcEnergyConversionDeviceType {
public:
    /// Defines typical types of coils (e.g., Cooling, Heating, etc.)
    IfcCoilTypeEnum::IfcCoilTypeEnum PredefinedType() const;
    void setPredefinedType(IfcCoilTypeEnum::IfcCoilTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcEnergyConversionDeviceType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcCoilTypeEnum; } return IfcEnergyConversionDeviceType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcEnergyConversionDeviceType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCoilType (IfcAbstractEntity* e);
    IfcCoilType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcCoilTypeEnum::IfcCoilTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcCoilType > list;
};
/// Definition from ISO 6707-1:1989: Structural member of
/// slender form, usually vertical, that transmits to its base the
/// forces, primarily in compression, that are applied to it.
/// <An IfcColumn is a vertical
/// structural member which often is aligned with a structural grid
/// intersection. It represents a vertical, or nearly vertical,
/// structural member that transmits, through compression, the weight
/// of the structure above to other structural elements below. It
/// represents such a member from an architectural point of view. It
/// is not required to be load bearing.
/// NOTE The representation of a column in a
/// structural analysis model is provided by
/// IfcStructuralCurveMember being part of an
/// IfcStructuralAnalysisModel.
/// 
/// NOTE ÿFor any longitudial structural member, not
/// constrained to be predominately horizontal nor vertical, or where
/// this semantic information is irrelevant, the entity
/// IfcMember exists.
/// The IFC specification provides two entities for column
/// occurrences:
/// 
/// IfcColumnStandardCase used for all occurrences of
/// columns, tthat have a profile defined that is swept along a
/// directrix. The profile might be changed uniformly by a taper
/// definition along the directrix. The profile parameter and its
/// cardinal point of insertion can be fully described by the
/// IfcMaterialProfileSetUsage. These beams are always
/// represented geometricly by an 'Axis' and a 'SweptSolid' or
/// 'AdvancedSweptSolid' shape representation (or by a 'Clipping'
/// geometry based on the swept solid), if a 3D geometric
/// representation is assigned. In addition they have to have a
/// corresponding IfcMaterialProfileSetUsage assigned.
/// NOTEÿ View definitions and implementer
/// agreements may further constrain the applicable geometry types,
/// e.g. by excluding tapering from an IfcColumnStandardCase
/// implementation.
/// 
/// IfcColumn used for all other occurrences of columns,
/// particularly for columns with changing profile sizes along the
/// extrusion, or columns defined by non-linear extrusion, or columns
/// having only 'Brep', or 'SurfaceModel' geometry.
/// 
/// HISTORY New entity in IFC Release 1.0
/// 
/// Type Use Definition
/// IfcColumn defines the occuurence of any column, common
/// information about column types (or styles) is handled by
/// IfcColumnType. The IfcColumnType (if present) may
/// establish the commonÿtype name, usage (or predefined) type,
/// common material layer set, common set of properties and common
/// shape representations (using IfcRepresentationMap). The
/// IfcColumnType is attached using the
/// IfcRelDefinedByType.RelatingType objectified relationship
/// and is accessible by the inverse IsTypedBy attribute.
/// If no IfcColumnType is attachedÿ(i.e. if only
/// occurrence information is given) the PredefinedType should
/// be provided. If set to .USERDEFINED. a user defined value can be
/// provided by the ObjectType attribute.
/// Material Use Definition
/// The material of the IfcColumn is defined by the
/// IfcMaterialProfileSet or as fallback by IfcMaterial
/// and attached by the
/// IfcRelAssociatesMaterial.RelatingMaterial. It is
/// accessible by the inverse HasAssociations
/// relationship.
/// Note: It is illegal to assign an
/// IfcMaterialProfileSetUsage to an IfcColumn. Only
/// the subtype IfcColumnStandardCase supports this
/// concept.
/// Material information can also be given at the
/// IfcColumnType, defining the common attribute data for all
/// occurrences of the same type.ÿIt is then accessible by the
/// inverse IsTypedBy
/// relationship pointing to
/// IfcColumnType.HasAssociations and via
/// IfcRelAssociatesMaterial.RelatingMaterial to
/// IfcMaterialProfileSet or IfcMaterial. If both are
/// given, then the material directly assigned to IfcColumn
/// overrides the material assigned to IfcColumnType.
/// Property Set Use Definition:
/// The property sets relating to the IfcColumn are defined
/// by the IfcPropertySet and attached by the
/// IfcRelDefinesByProperties relationship. It is accessible
/// by the inverse IsDefinedBy relationship. The following
/// property set definitions specific to the IfcColumn are
/// part of this IFC release:
/// 
/// Pset_ColumnCommon: common property set for all
/// column occurrences
/// 
/// Property sets can also be given at the IfcColumnType,
/// defining the common property data for all occurrences of the same
/// type.ÿIt is then accessible by the inverse IsTypedBy relationship pointing to
/// IfcColumnType.HasPropertySets. If both are given, then the
/// properties directly assigned to IfcColumn overrides the
/// properties assigned to IfcColumnType.
/// Quantity Use Definition:
/// The quantities relating to the IfcColumn are defined by
/// the IfcElementQuantity and attached by the
/// IfcRelDefinesByProperties. It is accessible by the inverse
/// IsDefinedBy relationship. The following base quantities
/// are defined and should be exchanged with the
/// IfcElementQuantity.MethodOfMeasurement = 'BaseQuantities'.
/// Other quantities can be defined being subjected to local standard
/// of measurement with another string value assigned to Name
/// and a value provided for MethodOfMeasurement. Quanties
/// shall be never assigned to the IfcColumnType.
/// 
/// Qto_ColumnBaseQuantities: base quantities for
/// all column occurrences.
/// 
/// Containment Use Definition
/// The IfcColumn, as any subtype of
/// IfcBuildingElement, may participate in two different
/// containment relationships. The first (and in most implementation
/// scenarios mandatory) relationship is the hierachical spatial
/// containment, the second (optional) relationship is the
/// aggregation within anÿelement assembly.
/// 
/// The IfcColumn, is places within the project spatial
/// hierarchy using the objectified relationship
/// IfcRelContainedInSpatialStructure, refering to it by its
/// inverse attribute SELF\IfcElement.ContainedInStructure.
/// Subtypes ofÿIfcSpatialStructureElement are valid spatial
/// containers, with IfcBuildingStorey being the default
/// container.
/// The IfcColumn, may be aggregated into an element
/// assembly using the objectified relationship
/// IfcRelAggregates, refering to it by its inverse attribute
/// SELF\IfcObjectDefinition.Decomposes. Any subtype of
/// IfcElement can be an element assembly, with
/// IfcElementAssembly as a special focus subtype. In this
/// case it should not be additionally contained in the project
/// spatial hierarchy,
/// i.e.ÿSELF\IfcElement.ContainedInStructure should be
/// NIL.
/// 
/// Geometry Use Definition
/// The geometric representation of IfcColumn is given by
/// the IfcProductDefinitionShape, allowing multiple geometric
/// representations. Included are:
/// Local Placement
/// The local placement for IfcColumn is defined in its
/// supertype IfcProduct. It is defined by the
/// IfcLocalPlacement, which defines the local coordinate
/// system that is referenced by all geometric representations.
/// 
/// The PlacementRelTo relationship of
/// IfcLocalPlacement shall point (if given) to the local
/// placement of the same IfcSpatialStructureElement, which is
/// used in the ContainedInStructure inverse attribute, or to
/// a spatial structure element at a higher level, referenced by
/// that.
/// If the relative placement is not used, the absolute placement
/// is defined within the world coordinate system.
/// 
/// Geometric Representation
/// Currently, the 'Axis', 'Body',
/// and 'Box' representations are supported. The 'Box' representation
/// includes the representation type 'BoundingBox' and is explained
/// at IfcBuildingElement.
/// Axis Representation
/// The axis geometric representation of IfcColumn is
/// defined using the 'Axis' representation. The following attribute
/// values for the IfcShapeRepresentation holding this
/// geometric representation shall be used:
/// 
/// RepresentationIdentifier : 'Axis'
/// RepresentationType : 'Curve2D', 'Curve3D'
/// 
/// The axis representation can be used to represent the system
/// length of a column that may extent the body length of the
/// column.
/// Body Representation
/// The body representation of IfcColumn can be represented
/// using the representation types 'SweptSolid', 'Clipping',
/// 'AdvancedSweptSolid', 'MappedRepresentation', 'SurfaceModel', and
/// 'Brep'. The representation types 'SurfaceModel' and 'Brep' are
/// explained at IfcBuildingElement.
/// SweptSolid Representation Type
/// The following attribute values for the
/// IfcShapeRepresentation holding this geometric
/// representation shall be used:
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'SweptSolid'
/// 
/// The following additional constraints apply to the 'SweptSolid'
/// representation:
/// 
/// Solid: IfcExtrudedAreaSolid,
/// IfcRevolvedAreaSolid shall be supported
/// Profile: all subtypes of IfcProfileDef (with
/// exception of IfcArbitraryOpenProfileDef)ÿ
/// Extrusion:ÿAll extrusion directions shall be
/// supported
/// 
/// Figure 81 illustrates a 'SweptSolid' geometric representation. There are no restrictions or conventions on
/// how to use the local placement (black), solid of extrusion placement (red) and profile placement (green).
/// 
/// Figure 81 — Column swept solid
/// 
/// Figure 82 illustrates use of a special profile type (here IfcIShapeProfileDef) for the definition of the IfcExtrudedAreaSolid.
/// 
/// Figure 82 — Column extrusion of I-Shape
/// 
/// Clipping Representation Type
/// The following attribute values for the
/// IfcShapeRepresentation holding this geometric
/// representation shall be used:
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'Clipping'
/// 
/// The following constraints apply to the advanced
/// representation:
/// 
/// Solid: see 'SweptSolid' geometric representation
/// Profile: see 'SweptSolid' geometric
/// representation
/// Extrusion: see 'SweptSolid' geometric
/// representation
/// Boolean result: The IfcBooleanClippingResult
/// shall be supported, allowing for Boolean differences between the
/// swept solid (here IfcExtrudedAreaSolid) and one or several
/// IfcHalfSpaceSolid.
/// 
/// Figure 83 illustrates a 'Clipping' geometric representation with use of IfcBooleanClippingResult between
/// an IfcExtrudedAreaSolid and an IfcHalfSpaceSolid to create a clipped body.
/// 
/// Figure 83 — Column clipping
/// 
/// AdvancedSweptSolid Representation Type
/// The following attribute values for the
/// IfcShapeRepresentation holding this geometric
/// representation shall be used:
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'AdvancedSweptSolid'
/// 
/// The following additional constraints apply to the
/// 'AdvancedSweptSolid' representation type:
/// 
/// Solid: IfcSurfaceCurveSweptAreaSolid,
/// IfcFixedReferenceSweptAreaSolid,
/// IfcExtrudedAreaSolidTapered,
/// IfcRevolvedAreaSolidTapered shall be supported.
/// NOTE View definitions and implementer
/// agreements can further constrain the allowed swept solid
/// types.
/// 
/// Profile: see 'SweptSolid' geometric
/// representation
/// Extrusion:ÿnot applicable
/// 
/// MappedRepresentation Representation Type
/// The 'MappedRepresentation' representation type is supported as
/// it allows for reusing the geometry definition of the beam type at
/// all occurrences of the same type. The following attribute values
/// for the IfcShapeRepresentation holding this geometric
/// representation shall be used:
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'MappedRepresentation'
/// 
/// The same constraints, as given for theÿ 'SweptSolid',
/// 'Clipping', 'AdvancedSweptSolid', 'SurfaceModel' and 'Bre'
/// geometric representation, shall apply to the
/// MappedRepresentation of the
/// IfcRepresentationMap.
class IfcColumn : public IfcBuildingElement {
public:
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcBuildingElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcBuildingElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcBuildingElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcColumn (IfcAbstractEntity* e);
    IfcColumn (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag);
    typedef IfcTemplatedEntityList< IfcColumn > list;
};
/// The flow moving device type IfcCompressorType defines commonly shared information for occurrences of compressors.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a compressor specification (i.e. the specific product information, that is common to all occurrences of that product type).  Compressor types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcCompressorType are represented by instances of IfcCompressor. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcFlowMovingDeviceType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_CompressorTypeCommon 
/// 
/// Material Use Definition 
/// The material of the IfcCompressorType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Body': The primary material from which the object is constructed. 
/// 'Refrigerant': Refrigerant material. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcCompressorType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcCompressor for standard port definitions.
class IfcCompressorType : public IfcFlowMovingDeviceType {
public:
    /// Defines the type of compressor (e.g., hermetic, reciprocating, etc.).
    IfcCompressorTypeEnum::IfcCompressorTypeEnum PredefinedType() const;
    void setPredefinedType(IfcCompressorTypeEnum::IfcCompressorTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcFlowMovingDeviceType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcCompressorTypeEnum; } return IfcFlowMovingDeviceType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcFlowMovingDeviceType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCompressorType (IfcAbstractEntity* e);
    IfcCompressorType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcCompressorTypeEnum::IfcCompressorTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcCompressorType > list;
};
/// The energy conversion device type IfcCondenserType defines commonly shared information for occurrences of condensers.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a condenser specification (i.e. the specific product information, that is common to all occurrences of that product type).  Condenser types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcCondenserType are represented by instances of IfcCondenser. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcEnergyConversionDeviceType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_CondenserTypeCommon 
/// 
/// Material Use Definition 
/// The material of the IfcCondenserType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Casing': Material from which the casing is constructed. 
/// 'Refrigerant': Refrigerant material. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcCondenserType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcCondenser for standard port definitions.
class IfcCondenserType : public IfcEnergyConversionDeviceType {
public:
    /// Defines the type of condenser.
    IfcCondenserTypeEnum::IfcCondenserTypeEnum PredefinedType() const;
    void setPredefinedType(IfcCondenserTypeEnum::IfcCondenserTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcEnergyConversionDeviceType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcCondenserTypeEnum; } return IfcEnergyConversionDeviceType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcEnergyConversionDeviceType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCondenserType (IfcAbstractEntity* e);
    IfcCondenserType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcCondenserTypeEnum::IfcCondenserTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcCondenserType > list;
};

class IfcCondition : public IfcGroup {
public:
    virtual unsigned int getArgumentCount() const { return 5; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcGroup::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcGroup::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcGroup::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCondition (IfcAbstractEntity* e);
    IfcCondition (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType);
    typedef IfcTemplatedEntityList< IfcCondition > list;
};

class IfcConditionCriterion : public IfcControl {
public:
    IfcConditionCriterionSelect* Criterion() const;
    void setCriterion(IfcConditionCriterionSelect* v);
    IfcDateTimeSelect* CriterionDateTime() const;
    void setCriterionDateTime(IfcDateTimeSelect* v);
    virtual unsigned int getArgumentCount() const { return 7; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 5: return IfcUtil::Argument_ENTITY_INSTANCE; case 6: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcControl::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 5: return Type::IfcConditionCriterionSelect; case 6: return Type::IfcDateTimeSelect; } return IfcControl::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 5: return "Criterion"; case 6: return "CriterionDateTime"; } return IfcControl::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcConditionCriterion (IfcAbstractEntity* e);
    IfcConditionCriterion (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcConditionCriterionSelect* v6_Criterion, IfcDateTimeSelect* v7_CriterionDateTime);
    typedef IfcTemplatedEntityList< IfcConditionCriterion > list;
};
/// IfcConstructionEquipmentResource is usage of construction equipment to assist in the performance of construction. Construction Equipment resources are wholly or partially consumed or occupied in the performance of construction.
/// 
/// HISTORY: New Entity in IFC Release 2.0.  Base type and documentation extended in IFC2x4.
/// 
/// Occurrences of IfcConstructionEquipmentResource are products that are used as resources to assist the process of construction. More specifically, they are products that are standalone items brought to a project to fulfil a particular purpose. Examples might be a tower crane or other mobile crane, a screwing machine, a lifting hoist etc. They are explicitly instances of IfcProduct  and may be drawn from various of the subtype, for instance IfcTransportElement, IfcDiscreteAccessory, IfcProxy (for particular cases where more precise usage details are not available).
/// 
/// A product that is used as an IfcConstructionEquipmentResource is referenced using the IfcRelAssignsToResource.RelatedObjects relationship.
/// 
/// Use definitions for composition, assignment, constraints, time series, and baselines are described at the base type IfcConstructionResource.
/// 
/// Type use definition
/// IfcConstructionEquipmentResource defines the occurrence of any construction equipment resource; common information about construction equipment resource types is handled by IfcConstructionEquipmentResourceType.  The IfcConstructionEquipmentResourceType (if present) may establish the common type name, common properties, and common productivities for various task types using IfcRelAssignsToProcess.  The IfcConstructionEquipmentResourceType is attached using the IfcRelDefinesByType.RelatingType objectified relationship and is accessible by the inverse IsTypedBy attribute.
/// 
/// Quantity use definition
/// The quantities relating to the IfcConstructionEquipmentResource are defined by IfcElementQuantity and attached by the IfcRelDefinesByProperties relationship. It is accessible by the inverse IsDefinedBy relationship. The following base quantities are defined and should be exchanged with the IfcElementQuantity.Name = 'BaseQuantities'. Other quantities can be defined being subjected to local standard of measurement with another string value assigned to Name and a value provided for MethodOfMeasurement.
/// 
/// Qto_ConstructionEquipmentResourceBaseQuantities: base quantities for all construction equipment resources.
/// 
/// Assignment use definition
/// In addition to assignments specified at the base class IfcConstructionResource, a construction equipment resource may have assignments of its own using IfcRelAssignsToResource where RelatingResource refers to the IfcConstructionEquipmentResource and RelatedObjects contains one or more IfcProduct subtypes as shown in Figure 183.  Such relationship indicates the equipment used as input for the resource.  Such products are not contained within a building structure but are referenced within a construction spatial zone, specifically IfcSpatialZone with PredefinedType=CONSTRUCTION, which is aggregated within the IfcProject.  There may be multiple chains of production such that the assigned equipment may have their own task and resource assignments for assembling such equipment.
/// 
/// Figure 183 — Construction equipment resource assignment
class IfcConstructionEquipmentResource : public IfcConstructionResource {
public:
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcConstructionResource::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcConstructionResource::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcConstructionResource::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcConstructionEquipmentResource (IfcAbstractEntity* e);
    IfcConstructionEquipmentResource (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, boost::optional< std::string > v6_ResourceIdentifier, boost::optional< std::string > v7_ResourceGroup, boost::optional< IfcResourceConsumptionEnum::IfcResourceConsumptionEnum > v8_ResourceConsumption, IfcMeasureWithUnit* v9_BaseQuantity);
    typedef IfcTemplatedEntityList< IfcConstructionEquipmentResource > list;
};
/// IfcConstructionMaterialResource identifies a material resource type in a construction project. 
/// 
/// HISTORY: New Entity in IFC Release 2.0. Base type and documentation extended in IFC2x4.
/// 
/// IFC2x4 NOTE: The attribute Suppliers has been deleted; use IfcRelAssignsToResource to assign an IfcActor to fulfill the role as a supplier.  The attribute UsageRatio has been deleted; use BaseQuantityConsumed and BaseQuantityProduced to indicate material usage.
/// 
/// Occurrences of IfcConstructionMaterialResource are consumed (wholly or partially), or occupied during a construction work task (IfcTask). 
/// 
/// Similar to IfcConstructionProductResource, sometimes things such as 5000kg of gravel are already instantiated as an IfcProduct because it is a result of a work task (for example, &#145;transporting gravel&#146;). In this case, the instance of IfcConstructionMaterialResource can be associated with the product instance &#145;5000kg of gravel&#146; to provide more information for resource uses. Nevertheless, IfcConstructionMaterialResource should only be used to represent resource usage (for example &#145;gravel&#146;), but not product substances (for example, &#145;5000kg of gravel&#146;). 
/// Note: This class is not the same as IfcMaterial; the former can typically represent the type of bulk materials such as sand, gravels, nails and so on (note these can be instantiated from IfcProduct as well depending their uses in the system) used in a construction process. The latter is about physical materials used in a physical building element typically with detailed positioning (e.g. offset) and layering information.
/// Quantities for an IfcConstructionMaterialResource are defined through IfcRelDefinesByProperty and use IfcElementQuantity.
/// 
/// Use definitions for composition, assignment, constraints, time series, and baselines are described at the base type IfcConstructionResource.
/// 
/// Type use definition
/// IfcConstructionMaterialResource defines the occurrence of any material resource; common information about material resource types is handled by IfcConstructionMaterialResourceType.  The IfcConstructionMaterialResourceType (if present) may establish the common type name, common properties, and common productivities for various task types using IfcRelAssignsToProcess.  The IfcConstructionMaterialResourceType is attached using the IfcRelDefinesByType.RelatingType objectified relationship and is accessible by the inverse IsTypedBy attribute.
/// 
/// Quantity use definition
/// The quantities relating to the IfcConstructionMaterialResource are defined by IfcElementQuantity and attached by the IfcRelDefinesByProperties relationship. It is accessible by the inverse IsDefinedBy relationship. The following base quantities are defined and should be exchanged with the IfcElementQuantity.Name = 'BaseQuantities'. Other quantities can be defined being subjected to local standard of measurement with another string value assigned to Name and a value provided for MethodOfMeasurement.
/// 
/// Qto_ConstructionMaterialResourceBaseQuantities: base quantities for all construction material resources.
/// 
/// Assignment use definition
/// In addition to assignments specified at the base class IfcConstructionResource, a construction material resource may have assignments of its own using IfcRelAssignsToResource where RelatingResource refers to the IfcConstructionMaterialResource and RelatedObjects contains one or more IfcProduct subtypes as shown in Figure 184.  Such relationship indicates the physical material used as input for the resource.  Such products are not contained within a building structure but are referenced within a construction spatial zone, specifically IfcSpatialZone with PredefinedType=CONSTRUCTION, which is aggregated within the IfcProject.  The IfcGeographicElement object is used to represent the physical material occurrence, which may optionally have placement and representation indicating intended storage on the construction site.  There may be multiple chains of production such that the assigned product material(s) may have their own task and resource assignments for transporting or extracting such material.
/// 
/// Figure 184 — Construction material resource assignment
class IfcConstructionMaterialResource : public IfcConstructionResource {
public:
    /// Whether the optional attribute Suppliers is defined for this IfcConstructionMaterialResource
    bool hasSuppliers() const;
    IfcEntityList::ptr Suppliers() const;
    void setSuppliers(IfcEntityList::ptr v);
    /// Whether the optional attribute UsageRatio is defined for this IfcConstructionMaterialResource
    bool hasUsageRatio() const;
    double UsageRatio() const;
    void setUsageRatio(double v);
    virtual unsigned int getArgumentCount() const { return 11; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 10: return IfcUtil::Argument_DOUBLE; } return IfcConstructionResource::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcActorSelect; case 10: return Type::IfcRatioMeasure; } return IfcConstructionResource::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "Suppliers"; case 10: return "UsageRatio"; } return IfcConstructionResource::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcConstructionMaterialResource (IfcAbstractEntity* e);
    IfcConstructionMaterialResource (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, boost::optional< std::string > v6_ResourceIdentifier, boost::optional< std::string > v7_ResourceGroup, boost::optional< IfcResourceConsumptionEnum::IfcResourceConsumptionEnum > v8_ResourceConsumption, IfcMeasureWithUnit* v9_BaseQuantity, boost::optional< IfcEntityList::ptr > v10_Suppliers, boost::optional< double > v11_UsageRatio);
    typedef IfcTemplatedEntityList< IfcConstructionMaterialResource > list;
};
/// IfcConstructionProductResource defines the role of a product that is consumed (wholly or partially), or occupied in the performance of construction. 
/// 
/// HISTORY: New Entity in IFC Release 2.0. Renamed from IfcProductResource in IFC 2x.  Base type and documentation extended in IFC2x4.
/// 
/// Occurrences of IfcConstructionProductResource are usage of products to assist the process of construction. More specifically, they are usage of products that result from some construction processes and that are then used as resources to facilitate further construction. For instance, formworks can be instantiated as products resulting from the process &#145;constructing formwork&#146;. However, they are used as resources in the process &#145;pouring concrete&#146; in a later stage of the project. IfcConstructionProductResource occurrences  are explicitly instances of IfcProduct and may be drawn from various of the subtypes, for instance IfcElementComponent, IfcElementAssembly, IfcProxy (for particular cases where more precise usage details are not available).  The product that is used as a construction resource is referenced using the IfcRelAssignsToResource.RelatedObjects relationship. 
/// 
/// Use definitions for composition, assignment, constraints, time series, and baselines are described at the base type IfcConstructionResource.
/// 
/// Type use definition
/// IfcConstructionProductResource defines the occurrence of any product resource; common information about product resource types is handled by IfcConstructionProductResourceType.  The IfcConstructionProductResourceType (if present) may establish the common type name, common properties, and common productivities for various task types using IfcRelAssignsToProcess.  The IfcConstructionProductResourceType is attached using the IfcRelDefinesByType.RelatingType objectified relationship and is accessible by the inverse IsTypedBy attribute.
/// 
/// Assignment use definition
/// In addition to assignments specified at the base class IfcConstructionResource, a construction product resource may have assignments of its own using IfcRelAssignsToResource where RelatingResource refers to the IfcConstructionProductResource and RelatedObjects contains one or more IfcProduct subtypes as shown in Figure 185.  Such relationship indicates the products used as input for the resource.  Such products are not contained within a building structure but are referenced within a construction spatial zone, specifically IfcSpatialZone with PredefinedType=CONSTRUCTION, which is aggregated within the IfcProject.  There may be multiple chains of production such that the assigned products may have their own task and resource assignments.
/// 
/// Figure 185 — Construction product resource assignment
class IfcConstructionProductResource : public IfcConstructionResource {
public:
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcConstructionResource::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcConstructionResource::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcConstructionResource::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcConstructionProductResource (IfcAbstractEntity* e);
    IfcConstructionProductResource (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, boost::optional< std::string > v6_ResourceIdentifier, boost::optional< std::string > v7_ResourceGroup, boost::optional< IfcResourceConsumptionEnum::IfcResourceConsumptionEnum > v8_ResourceConsumption, IfcMeasureWithUnit* v9_BaseQuantity);
    typedef IfcTemplatedEntityList< IfcConstructionProductResource > list;
};
/// The energy conversion device type IfcCooledBeamType defines commonly shared information for occurrences of cooled beams.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a cooled beam specification (i.e. the specific product information, that is common to all occurrences of that product type).  Cooled Beam types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcCooledBeamType are represented by instances of IfcCooledBeam. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcEnergyConversionDeviceType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_CooledBeamTypeCommon 
/// 
/// The following property set definitions are applicable to this entity according to the PredefinedType attribute:  
/// Pset_CooledBeamTypeActive (ACTIVE) 
/// 
/// Material Use Definition 
/// The material of the IfcCooledBeamType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Body': The primary material from which the object is constructed. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcCooledBeamType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcCooledBeam for standard port definitions.
class IfcCooledBeamType : public IfcEnergyConversionDeviceType {
public:
    /// Defines the type of cooled beam.
    IfcCooledBeamTypeEnum::IfcCooledBeamTypeEnum PredefinedType() const;
    void setPredefinedType(IfcCooledBeamTypeEnum::IfcCooledBeamTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcEnergyConversionDeviceType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcCooledBeamTypeEnum; } return IfcEnergyConversionDeviceType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcEnergyConversionDeviceType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCooledBeamType (IfcAbstractEntity* e);
    IfcCooledBeamType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcCooledBeamTypeEnum::IfcCooledBeamTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcCooledBeamType > list;
};
/// The energy conversion device type IfcCoolingTowerType defines commonly shared information for occurrences of cooling towers.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a cooling tower specification (i.e. the specific product information, that is common to all occurrences of that product type).  Cooling Tower types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcCoolingTowerType are represented by instances of IfcCoolingTower. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcEnergyConversionDeviceType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_CoolingTowerTypeCommon 
/// 
/// Material Use Definition 
/// The material of the IfcCoolingTowerType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Casing': Material from which the casing is constructed. 
/// 'Fill': Fill material. 
/// 
/// Composition Use Definition 
/// The IfcCoolingTowerType may be aggregated into components using IfcRelAggregates where RelatingObject refers to the enclosing IfcCoolingTowerType and RelatedObjects contains one or more components.  Components are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Aggregation use is defined for the following predefined types:
/// 
/// MECHANICALFORCEDDRAFT: May contain IfcFan components.  Forces air into the cooling tower. 
/// MECHANICALINDUCEDDRAFT: May contain IfcFan components.  Induces air out of the cooling tower. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcCoolingTowerType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcCoolingTower for standard port definitions.
class IfcCoolingTowerType : public IfcEnergyConversionDeviceType {
public:
    /// Defines the typical types of cooling towers (e.g., OpenTower, ClosedTower, CrossFlow, etc.).
    IfcCoolingTowerTypeEnum::IfcCoolingTowerTypeEnum PredefinedType() const;
    void setPredefinedType(IfcCoolingTowerTypeEnum::IfcCoolingTowerTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcEnergyConversionDeviceType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcCoolingTowerTypeEnum; } return IfcEnergyConversionDeviceType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcEnergyConversionDeviceType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCoolingTowerType (IfcAbstractEntity* e);
    IfcCoolingTowerType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcCoolingTowerTypeEnum::IfcCoolingTowerTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcCoolingTowerType > list;
};
/// Definition from ISO 6707-1:1989: term used: Finishing -
/// final coverings and treatments of surfaces and their
/// intersections.
/// A covering is an element which
/// covers some part of another element and is fully dependent on
/// that other element. The IfcCovering defines the occurrence
/// of a covering type, that (if given) is expressed by the
/// IfcCoveringType. Examples of coverings include wall
/// claddings, floorings and suspended ceilings. Coverings are
/// elements with relationships to the covered element and the space
/// on the other side, they may contain openings, assigned by
/// IfcRelVoidsElement, material information, assigned by
/// IfcRelAssociatesMaterial, and others.
/// NOTE A more basic information about claddings,
/// floorings, and ceilings of a space can be attached to
/// IfcSpace's using the Pset_SpaceCommon properties. Then
/// only a name can be provided and the covering quantities would be
/// interpreted from the space quantities.
/// Coverings can be assigned to
/// 
/// a space represented by IfcSpace
/// 
/// using the inverse relationship CoversSpaces pointing
/// to IfcRelCoversSpaces. The space is then accessible via
/// IfcRelCoversSpaces.RelatedSpace. It defines to which space
/// a covering is facing towards.
/// 
/// NOTE The mere containment relationship between an
/// IfcCovering and an IfcSpace is
/// created by using
/// IfcRelContainedInSpatialStructure
/// 
/// a space boundary represented by IfcRelSpaceBoundary
/// 
/// using the inverse relationship ProvidesBoundaries
/// pointing to IfcRelSpaceBoundary. The space is then
/// accessible via IfcRelSpaceBoundary.RelatingSpace.
/// 
/// a building element represented by IfcBuildingElement
/// 
/// using the inverse relationship Covers pointing to
/// IfcRelCoversBldgElements. The building element is then
/// accessible via
/// IfcRelCoversBldgElements.RelatingBuildingElement.
/// 
/// The following guideline shall apply:
/// 
/// (default) if the space has coverings that may not have an own
/// shape representation and no defined relationships to the building
/// elements they cover, then the IfcCovering shall be
/// assigned to IfcSpace using the IfcRelCoversSpaces
/// relationship,
/// if the space has coverings that have an own shape
/// representation and the space has defined space boundaries, then
/// the covering, which relates to that space, may be assigned to the
/// space boundaries using the link
/// toÿIfcRelSpaceBoundary,
/// if the covering does not relate to a space, then the covering
/// should be assigned to the building element or a distribution
/// element using the IfcRelCoversBldgElements
/// relationship.
/// 
/// HISTORY New entity in IFC Release 1.0.
/// IFC2x CHANGE The attribute PredefinedType is now optional and should only be inserted when no type information, given by IfcCoveringType, is assigned to the IfcCovering occurrence by IfcRelDefinesByType.
/// IFC2x4 CHANGE The IfcCovering is restricted to coverings of building elements by having
/// RelatingBuildingElement pointing to IfcBuildingElement.
/// 
/// Type Use Definition
/// The IfcCovering defines the occuurence of any covering,
/// common information about covering types (or styles) is handled by
/// IfcCoveringType. The IfcCoveringType (if present)
/// may establish the commonÿtype name, usage (or predefined) type,
/// common set of properties, common material layer set, and common
/// shape representations (using IfcRepresentationMap). The
/// IfcCoveringType is attached using the
/// IfcRelDefinedByType.RelatingType objectified relationship
/// and is accessible by the inverse IsDefinedBy
/// attribute.
/// As an additional use agreement for standard coverings (i.e.
/// slabs with constant thickness along the extrusion direction), the
/// IfcCoveringType should have a unique
/// IfcMaterialLayerSet, that is referenced by
/// theÿIfcMaterialLayerSetUsage assigned to all occurrences
/// of this covering type.
/// 
/// Figure 91 illustrates assignment of IfcMaterialLayerSetUsage and IfcMaterialLayerSet to the covering type and the covering occurrence.
/// 
/// Figure 91 — Covering material usage
/// 
/// If an IfcCoveringType is assigned to the
/// IfcCovering, the attribute PredefinedType shall not
/// be assigned, or shall be identical to
/// IfcCoveringType.PredefinedType.
/// Property Set Use Definition:
/// The property sets relating to the IfcCovering are
/// defined by the IfcPropertySet and attached by the
/// IfcRelDefinesByProperties relationship. It is accessible
/// by the inverse IsDefinedBy relationship. The following
/// property set definitions specific to the IfcCovering are
/// part of this IFC release:
/// 
/// Pset_CoveringCommon: common property set for all
/// covering occurrences
/// 
/// Pset_CoveringCeiling: specific property set
/// for all occurrences of coverings with the PredefinedType:
/// CEILING
/// Pset_CoveringFlooring: specific property set
/// for all occurrences of coverings with the PredefinedType:
/// FLOORING
/// 
/// Quantity Use Definition:
/// The quantities relating to the IfcCovering are defined
/// by the IfcElementQuantity and attached by the
/// IfcRelDefinesByProperties relationship. It is accessible
/// by the inverse IsDefinedBy relationship. The following
/// base quantities are defined and should be exchanged with the
/// IfcElementQuantity.Name = 'BaseQuantities'. Other
/// quantities can be defined being subjected to local standard of
/// measurement with another string value assigned to Name and
/// a value provided for MethodOfMeasurement. Quantities shall
/// never be assigned to the IfcCoveringType.
/// 
/// Qto_CoveringBaseQuantities: base quantities
/// for all covering occurrences.
/// 
/// Containment Use Definition
/// The IfcCovering has a containment relationship within
/// the hierarchical spatial structure.
/// 
/// The IfcCovering is places within the project spatial
/// hierarchy using the objectified relationship
/// IfcRelContainedInSpatialStructure, referring to it by its
/// inverse attribute SELF\IfcElement.ContainedInStructure.
/// Subtypes of IfcSpatialStructureElement are valid spatial
/// containers, with IfcSpace being the default
/// container.
/// 
/// Geometry Use Definitions
/// The geometric representation of IfcCovering is given by
/// the IfcProductDefinitionShape, allowing multiple geometric
/// representation. Included are:
/// Local Placement
/// The local placement for IfcCovering is defined in its
/// supertype IfcProduct. It is defined by the
/// IfcLocalPlacement, which defines the local coordinate
/// system that is referenced by all geometric representations.
/// 
/// The PlacementRelTo relationship of
/// IfcLocalPlacement shall point (if given) to the same
/// IfcSpatialStructureElement , which is used in the
/// ContainedInStructure inverse attribute, or to a spatial
/// structure element at a higher level, referenced by that.
/// If the IfcCovering, however, is assigned to an
/// IfcBuildingElement, and this element defines its own local
/// placement, than the PlacementRelTo relationship of
/// IfcLocalPlacement shall point (if given) to the local
/// placement of the IfcBuildingElement.
/// If the relative placement is not used, the absolute placement
/// is defined within the world coordinate system.
/// 
/// Geometric Representations
/// The geometric representation of the IfcCovering depends
/// on two criteria:
/// 
/// Does it define an area or a volume?
/// Is the base surface (either the IfcRelSpaceBoundary or
/// the surface of the IfcBuildingElement it relates to) a
/// planar surface or a cylindrical surface?
/// 
/// GeometricSet Representation
/// The 'GeometricSet' geometric representation of
/// IfcCovering supports area definitions as 3D surfaces.ÿ
/// 
/// RepresentationIdentifier : 'Surface'
/// RepresentationType : 'GeometricSet'
/// 
/// The following additional constraints apply to the
/// 'GeometricSet' representation of IfcCovering:
/// 
/// for planar base surfaces - bounded surface
/// representation
/// for cylindrical base surfaces - swept surface
/// representation
/// 
/// Figure 92 illustrates a planar surface representation where the area of IfcCovering is given by an IfcPolyLoop for planar base surfaces (here given by the IfcRelSpaceBoundary).
/// 
/// The implicit planar surface of the IfcPolyLoop shall be identical with the planar surface defined by the IfcRelSpaceBoundary.
/// 
/// Figure 92 — Covering surface planar
/// 
/// Figure 93 illustrates a cylindrical surface representation where the area of the IfcCovering is given by an IfcSurfaceOfLinearExtrusion for cylindrical base surfaces (here given by the IfcRelSpaceBoundary - such as caused by a round wall).
/// 
/// The geometry representation of the IfcCovering is given by the IfcTrimmedCurved (the Curve parameter of the
/// IfcArbitraryOpenProfileDef - in cases of faceted representation also an IfcPolyline). It is extruded within the plane of the base surface using the Depth parameter of the IfcSurfaceOfLinearExtrusion.
/// 
/// Figure 93 — Covering surface cylindrical
/// 
/// SweptSolid Representation
/// The 'SweptSolid' geometric representation of
/// IfcCovering supports volume definitions as 3D solids.ÿ
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'SweptSolid'
/// 
/// The following additional constraints apply to the 'SweptSolid'
/// representation of IfcCovering:
/// 
/// for planar base surfaces - swept area representation
/// for cylindrical base surfaces - swept area
/// representation
/// 
/// Figure 94 illustrates a body representation where the volume of IfcCovering is given by an IfcExtrudedAreaSolid for planar base surfaces (here given by the IfcRelSpaceBoundary).
/// 
/// The extruded area (IfcArbitraryClosedProfileDef) shall be coplanar to the surface defined by the IfcRelSpaceBoundary.
/// 
/// Figure 94 — Covering body planar
/// 
/// Figure 95 illustrates a body representation where the volume of the IfcCovering is given by an IfcExtrudedAreaSolid for cylindrical base surfaces (here given by the IfcRelSpaceBoundary - such as caused by a round wall).
/// 
/// The geometry representation of the IfcCovering is given by the IfcCompositeCurve (the OuterCurve parameter of the
/// IfcArbitraryClosedProfileDef - in cases of faceted representation also a closed IfcPolyline). It is extruded along the plane of the base surface using the Depth parameter of the IfcSurfaceOfLinearExtrusion.
/// 
/// Figure 95 — Covering body circular
class IfcCovering : public IfcBuildingElement {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcCovering
    bool hasPredefinedType() const;
    /// Predefined types to define the particular type of the covering. There may be property set definitions available for each predefined type.
    IfcCoveringTypeEnum::IfcCoveringTypeEnum PredefinedType() const;
    void setPredefinedType(IfcCoveringTypeEnum::IfcCoveringTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcBuildingElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcCoveringTypeEnum; } return IfcBuildingElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "PredefinedType"; } return IfcBuildingElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcRelCoversSpaces >::ptr CoversSpaces() const; // INVERSE IfcRelCoversSpaces::RelatedCoverings
    IfcTemplatedEntityList< IfcRelCoversBldgElements >::ptr Covers() const; // INVERSE IfcRelCoversBldgElements::RelatedCoverings
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCovering (IfcAbstractEntity* e);
    IfcCovering (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcCoveringTypeEnum::IfcCoveringTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcCovering > list;
};
/// Definition from ISO 6707-1:1989: Non load bearing wall
/// positioned on the outside of a building and enclosing it.
/// A curtain wall is an exterior wall of a building which is
/// an assembly of components, hung from the edge of the floor/roof
/// structure rather than bearing on a floor. Curtain wall is
/// represented as a building element assembly and implemented as a
/// subtype of IfcBuildingElement that uses an
/// IfcRelAggregates relationship.
/// HISTORY New Entity in IFC Release 2.0
/// 
/// Type Use Definition
/// IfcCurtainWall defines the occuurence of any curtain
/// wall, common information about curtain wall types (or styles) is
/// handled by IfcCurtainWallType. The
/// IfcCurtainWallType (if present) may establish the
/// commonÿtype name, usage (or predefined) type, common material
/// information, common set of properties and common shape
/// representations (using IfcRepresentationMap). The
/// IfcCurtainWallType is attached using the
/// IfcRelDefinedByType.RelatingType objectified relationship
/// and is accessible by the inverse IsDefinedBy
/// attribute.
/// If no IfcCurtainWallType is attachedÿ(i.e. if only
/// occurrence information is given) the predefined type may be given
/// by using the ObjectType attribute.
/// NOTE Since the IfcCurtainWall might be
/// represented as an aggregate of parts, e.g. represented by
/// IfcMember, or IfcPlate, these individual parts may
/// have type information attached (represented e.g. by
/// IfcMemberType, or
/// IfcPlateType).
/// Property Set Use Definition:
/// The property sets relating to the IfcCurtainWall are
/// defined by the IfcPropertySet and attached by the
/// IfcRelDefinesByProperties relationship. It is accessible
/// by the inverse IsDefinedBy relationship. The following
/// property set definitions specific to the IfcCurtainWall
/// are part of this IFC release:
/// 
/// Pset_CurtainWallCommon: common property set
/// for all curtain wall occurrences
/// 
/// Quantity Use Definition
/// The quantities relating to the IfcCurtainWall are
/// defined by the IfcElementQuantity and attached by the
/// IfcRelDefinesByProperties relationship. It is accessible
/// by the inverse IsDefinedBy relationship. The following
/// base quantities are defined and should be exchanged with the
/// IfcElementQuantity.Name = 'BaseQuantities'. Other
/// quantities can be defined being subjected to local standard of
/// measurement with another string value assigned to Name and
/// a value provided for MethodOfMeasurement. Quantities shall
/// never be assigned to the IfcCurtainWallType.
/// 
/// Qto_CurtainWallBaseQuantities: base
/// quantities for all curtain wall occurrences.
/// 
/// Geometry Use Definitions:
/// The geometric representation of IfcCurtainWall is given
/// by the IfcProductDefinitionShape, allowing multiple
/// geometric representations. Independent geometric representations,
/// as described below, should only be used when the
/// IfcCurtainWall is not defined as an aggregate. If defined
/// as an aggregate, the geometric representation is the sum of the
/// representations of the components within the aggregate.
/// Local placement
/// The local placement for IfcCurtainWall is defined in
/// its supertype IfcProduct. It is defined by the
/// IfcLocalPlacement, which defines the local coordinate
/// system that is referenced by all geometric representations.
/// 
/// The PlacementRelTo relationship of
/// IfcLocalPlacement shall point (if given) to the same
/// IfcSpatialStructureElement that is used in the
/// ContainedInStructure inverse attribute or to a referenced
/// spatial structure element at a higher level.
/// If the relative placement is not used, the absolute placement
/// is defined within the world coordinate system.
/// 
/// If the IfcCurtainWall establishes an aggregate, then
/// all contained elements (defined by the IsDecomposedBy
/// inverse attribute) shall be placed relative to the
/// IfcCurtainWall.ObjectPlacement.
/// Geometric Representation
/// The geometric representation of IfcCurtainWall is
/// defined using the following multiple shape representations for
/// its definition:
/// 
/// Axis: A two-dimensional open curve (for restrictions see
/// below) defining the axis for the curtain wall.
/// 
/// This is an optional representation for curtain walls.
/// 
/// Body: A surface model or boundary representation model
/// representation defining the 3D shape of the curtain wall.
/// 
/// If the IfcCurtainWall has components (referenced by
/// SELF\IfcObject.IsDecomposedBy) then no independent shape
/// representation with RepresentationType = 'Body' shall be
/// defined. The body of IfcCurtainWall is then geometrically
/// represented by the shape representation of its components. The
/// components are accessed via
/// SELF\IfcObject.IsDecomposedBy[1].RelatedObjects.
/// 
/// If the IfcCurtainWall has no components defined (empty
/// set of SELF\IfcObject.IsDecomposedBy) then the
/// IfcCurtainWall may be represented by an shape
/// representation with the RepresentationIdentifier =
/// 'Body'.
/// 
/// Axis Representation
/// The axis geometric representation of IfcCurtainWall is
/// defined using the 'Axis' representation. The following attribute
/// values for the IfcShapeRepresentation holding this
/// geometric representation shall be used:
/// 
/// RepresentationIdentifier : 'Axis'
/// RepresentationType : 'Curve2D'
/// 
/// The following additional constraints apply to the 'Axis'
/// representation:
/// 
/// Axis : IfcPolyline having two Points, or
/// IfcTrimmedCurve with BasisCurve of Type
/// IfcLine or IfcCircle.
/// 
/// Body Representation
/// The body shape representation of IfcCurtainWall is
/// defined using the 'Body' representation. The following attribute
/// values for the IfcShapeRepresentation holding this
/// geometric representation shall be used:
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'SurfaceModel', 'Brep' and
/// 'MappedRepresentation'
/// 
/// An own 'Body' representation shall only be included if no
/// components of the curtain wall are defined.
class IfcCurtainWall : public IfcBuildingElement {
public:
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcBuildingElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcBuildingElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcBuildingElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCurtainWall (IfcAbstractEntity* e);
    IfcCurtainWall (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag);
    typedef IfcTemplatedEntityList< IfcCurtainWall > list;
};
/// The flow controller type IfcDamperType defines commonly shared information for occurrences of dampers.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a damper specification (i.e. the specific product information, that is common to all occurrences of that product type).  Damper types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcDamperType are represented by instances of IfcDamper. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcFlowControllerType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_DamperTypeCommon 
/// 
/// The following property set definitions are applicable to this entity according to the PredefinedType attribute:  
/// Pset_DamperTypeControlDamper (CONTROLDAMPER) 
/// Pset_DamperTypeFireDamper (FIREDAMPER) 
/// Pset_DamperTypeFireSmokeDamper (FIRESMOKEDAMPER) 
/// Pset_DamperTypeSmokeDamper (SMOKEDAMPER) 
/// 
/// Material Use Definition 
/// The material of the IfcDamperType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Blade': The material from which the damper blades are constructed. 
/// 'Frame': The material from which the damper frame is constructed. 
/// 'Seal': The material from which the damper seals are constructed. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcDamperType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcDamper for standard port definitions.
class IfcDamperType : public IfcFlowControllerType {
public:
    /// Type of damper.
    IfcDamperTypeEnum::IfcDamperTypeEnum PredefinedType() const;
    void setPredefinedType(IfcDamperTypeEnum::IfcDamperTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcFlowControllerType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcDamperTypeEnum; } return IfcFlowControllerType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcFlowControllerType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcDamperType (IfcAbstractEntity* e);
    IfcDamperType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcDamperTypeEnum::IfcDamperTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcDamperType > list;
};

class IfcDiameterDimension : public IfcDimensionCurveDirectedCallout {
public:
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcDimensionCurveDirectedCallout::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcDimensionCurveDirectedCallout::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcDimensionCurveDirectedCallout::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcDiameterDimension (IfcAbstractEntity* e);
    IfcDiameterDimension (IfcEntityList::ptr v1_Contents);
    typedef IfcTemplatedEntityList< IfcDiameterDimension > list;
};
/// Definition from IAI: Representation of different kinds of
///   accessories included in or added to elements.  
///   HISTORY New entity in IFC
///   Release 2x2 
/// 
/// IFC 2x4 change:
/// Attribute PredefinedType added.
/// 
/// General usage 
///   The exact type information of the IfcDiscreteAccessory is given
///   in the ObjectType attribute inherited from IfcObject. Standard
///   type designations are provided for guideline below. The list is not exhaustive
///   and the list of definitions may be extended based on local national extensions.
/// 
/// Accessory type 
///   Standard type designation 
///   Description 
/// 
/// Shading devices:
///   'Shading device'
///   Elements specifically designed to provide shading, often fixed
///   externally and sometimes moving (e.g. by rotation)
/// 
/// Corbels as separate components: 
///   'Hidden steel corbel' 
///   Corbel system made from steel components embedded into the master
///   element 
/// 
/// 'Visible steel corbel' 
///   Corbel system made from steel components protruding from the master
///   element 
/// 
/// 'Visible concrete corbel' 
///   Corbel system made as a separate precast concrete component added
///   to the master element 
/// 
/// 'Ladder truss connector' 
///   A fixing device in truss form with straight cross bars in ladder
///   form holding two precast conrete panels together in a sandwich wall panel.
/// 
/// 'Panel suspender' 
///   A straight fixing device holding two precast conrete panels
///   together in a sandwich wall panel. 
/// 
/// Electrical accessories for precast concrete elements: 
///   'Protective plug' 
///   Protective plug used in element for protecting electrical
///   accessories during manufacturing, transportation and assembly. 
/// 
/// Fixing parts: 
///   'Standard fixing plate' 
///   Standard fixing plate. 
/// 
/// 'Edge fixing plate' 
///   Fixing plate attached to the edge of an element. 
/// 
/// 'Corner fixing plate' 
///   Fixing plate attached to the corner of an element. 
/// 
/// 'Slab fixing plate' 
///   Fixing plate for slabs. 
/// 
/// 'Balcony hinge' 
///   Accessory supporting and fixing balconies. 
/// 
/// 'Frame shoe' 
///   Fixing shoe for frames. 
/// 
/// 'Thermo frame' 
///   Thermo frame. 
/// 
/// 'Column shoe' 
///   Fixing shoe for columns. 
/// 
/// 'Wall shoe' 
///   Fixing shoe for walls. 
/// 
/// 'Fixing socket' 
///   Fixing socket. 
/// 
/// Joint accessories: 
///   'Neoprene bearing plate' 
///   Rubber plate used as a bearing in, for example, joints between
///   column corbels and beams. 
/// 
/// 'Working joint reinforcement' 
///   Reinforcement accessory used in working joints. 
/// 
/// 'Expansion joint reinforcement' 
///   Reinforcement accessory used in expansion joints. 
/// 
/// 'Ribbed steel bar extension' 
///   Extension accessory made of a ribbed (reinforcement) bar used in
///   joints. 
/// 
/// 'Steel pin bolt' 
///   Pin bolt used to join together, for example, columns and
///   beams. 
/// 
/// 'Concrete dowel' 
///   Dowel pin used in joints. 
/// 
/// 'Concrete groove' 
///   A groove made in a joint. 
/// 
/// 'Steel plate' 
///   A steel plate used as an accessory in a joint. 
/// 
/// 'Wire loop' 
///   A joint connector accessory made from a wire loop. 
/// 
/// 'Steel loop' 
///   A joint connector accessory made from a steel bar loop. 
/// 
/// 'Sealing strip' 
///   A strip sealing the joint. 
/// 
/// 'Sealing compound' 
///   Sealing compound protecting and sealing the joint. 
/// 
/// Lifting accessories: 
///   'Wire lifting hook' 
///   A lifting aid in the form of a wire loop. 
/// 
/// 'Steel lifting hook' 
///   A lifting aid in the form of a steel bar loop. 
/// 
/// 'Lifting socket' 
///   A lifting aid in the form of a socket. 
/// 
/// 'Steel lifting anchor' 
///   A lifting aid in the form of a steel lifting anchor. 
/// 
/// 'Lifting hole' 
///   A lifting aid in the form of a hole. 
/// 
/// Accessories mainly used in the building services domain: 
///   'Antivibration' 
///   An isolating device to prevent other elements to be effected by
///   vibrations. 
/// 
/// 'Drop rod' 
///   A length of material providing a hanging support to a bracket. Note
///   that a drop rod is considered to include nuts and washers required for
///   securing. 
/// 
/// 'Duct foot' 
///   A base support used to receive a vertical pipe (BS6100 330 3309 -
///   duct foot). 
/// 
/// 'Framing' 
///   A frame placed around a penetration to prevent scraping against the
///   building surface or structure. 
/// 
/// 'Grommet' 
///   An element placed within a penetration that seals the penetration
///   for a particular reason. 
/// 
/// 'Rack' 
///   A set of shelving for the purposes of storage that may be
///   freestanding or bolted to a structure. 
/// 
/// 'Safety part' 
///   A part, typically installed in vertical shafts at each level, to
///   ensure safety from falling when entering the shaft. 
/// 
/// 'Sleeve' 
///   A thin barrier placed between a penetration and a penetrating
///   element. 
/// 
/// 'Support section' 
///   A section of material that is used as an intermediate support upon
///   which multiple brackets can be mounted.
class IfcDiscreteAccessory : public IfcElementComponent {
public:
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcElementComponent::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcElementComponent::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcElementComponent::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcDiscreteAccessory (IfcAbstractEntity* e);
    IfcDiscreteAccessory (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag);
    typedef IfcTemplatedEntityList< IfcDiscreteAccessory > list;
};
/// Definition from IAI: The element type
///   (IfcDiscreteAccessoryType) defines a list of commonly shared property
///   set definitions of a discrete accessory and an optional set of product
///   representations. It is used to define a supporting element mainly within
///   structural and building services domains (i.e. the specific type information
///   common to all occurrences of that type). 
///   The occurrences of the IfcDiscreteAccessoryType are represented
///   by instances of IfcDiscreteAccessory. 
///   The IfcDiscreteAccessoryType is a specialization of the general
///   building element component type to represent different type of structural and
///   building service related auxiliary elements. 
///   HISTORY New entity in IFC
///   Release 2x2 
/// 
/// IFC 2x4 change:
/// Attribute PredefinedType added.
/// 
/// General usage 
///   The exact type information of the IfcDiscreteAccessoryType is
///   given in the ElementType attribute inherited from IfcElementType.
///   Standard type designations are provided for guideline below. The list is not
///   exhaustive and the list of definitions may be extended based on local national
///   extensions.  
/// 
/// Accessory type 
///   Standard type designation 
///   Description 
/// 
/// Shading devices: 
///   'Shading device' 
///   Elements specifically designed to provide shading, often fixed
///   externally and sometimes moving (e.g. by rotation) 
/// 
/// Corbels as separate components: 
///   'Hidden steel corbel' 
///   Corbel system made from steel components embedded into the master
///   element 
/// 
/// 'Visible steel corbel' 
///   Corbel system made from steel components protruding from the master
///   element 
/// 
/// 'Visible concrete corbel' 
///   Corbel system made as a separate precast concrete component added
///   to the master element 
/// 
/// Connecting accessories, for example for sandwich wall panels: 
///   'Diagonal truss connector' 
///   A fixing device in truss form with diagonal cross bars holding two
///   precast conrete panels together in a sandwich wall panel. 
/// 
/// 'Ladder truss connector' 
///   A fixing device in truss form with straight cross bars in ladder
///   form holding two precast conrete panels together in a sandwich wall panel.
/// 
/// 'Panel suspender' 
///   A straight fixing device holding two precast conrete panels
///   together in a sandwich wall panel. 
/// 
/// Electrical accessories for precast concrete elements: 
///   'Protective plug' 
///   Protective plug used in element for protecting electrical
///   accessories during manufacturing, transportation and assembly. 
/// 
/// Fixing parts: 
///   'Standard fixing plate' 
///   Standard fixing plate. 
/// 
/// 'Edge fixing plate' 
///   Fixing plate attached to the edge of an element. 
/// 
/// 'Corner fixing plate' 
///   Fixing plate attached to the corner of an element. 
/// 
/// 'Slab fixing plate' 
///   Fixing plate for slabs. 
/// 
/// 'Balcony hinge' 
///   Accessory supporting and fixing balconies. 
/// 
/// 'Frame shoe' 
///   Fixing shoe for frames. 
/// 
/// 'Thermo frame' 
///   Thermo frame. 
/// 
/// 'Column shoe' 
///   Fixing shoe for columns. 
/// 
/// 'Wall shoe' 
///   Fixing shoe for walls. 
/// 
/// 'Fixing socket' 
///   Fixing socket. 
/// 
/// Joint accessories: 
///   'Neoprene bearing plate' 
///   Rubber plate used as a bearing in, for example, joints between
///   column corbels and beams. 
/// 
/// 'Working joint reinforcement' 
///   Reinforcement accessory used in working joints. 
/// 
/// 'Expansion joint reinforcement' 
///   Reinforcement accessory used in expansion joints. 
/// 
/// 'Ribbed steel bar extension' 
///   Extension accessory made of a ribbed (reinforcement) bar used in
///   joints. 
/// 
/// 'Steel pin bolt' 
///   Pin bolt used to join together, for example, columns and
///   beams. 
/// 
/// 'Concrete dowel' 
///   Dowel pin used in joints. 
/// 
/// 'Concrete groove' 
///   A groove made in a joint. 
/// 
/// 'Steel plate' 
///   A steel plate used as an accessory in a joint. 
/// 
/// 'Wire loop' 
///   A joint connector accessory made from a wire loop. 
/// 
/// 'Steel loop' 
///   A joint connector accessory made from a steel bar loop. 
/// 
/// 'Sealing strip' 
///   A strip sealing the joint. 
/// 
/// 'Sealing compound' 
///   Sealing compound protecting and sealing the joint. 
/// 
/// Lifting accessories: 
///   'Wire lifting hook' 
///   A lifting aid in the form of a wire loop. 
/// 
/// 'Steel lifting hook' 
///   A lifting aid in the form of a steel bar loop. 
/// 
/// 'Lifting socket' 
///   A lifting aid in the form of a socket. 
/// 
/// 'Steel lifting anchor' 
///   A lifting aid in the form of a steel lifting anchor. 
/// 
/// 'Lifting hole' 
///   A lifting aid in the form of a hole. 
/// 
/// Accessories mainly used in the building services domain: 
///   'Antivibration' 
///   An isolating device to prevent other elements to be effected by
///   vibrations. 
/// 
/// 'Drop rod' 
///   A length of material providing a hanging support to a bracket. Note
///   that a drop rod is considered to include nuts and washers required for
///   securing. 
/// 
/// 'Duct foot' 
///   A base support used to receive a vertical pipe (BS6100 330 3309 -
///   duct foot). 
/// 
/// 'Framing' 
///   A frame placed around a penetration to prevent scraping against the
///   building surface or structure. 
/// 
/// 'Grommet' 
///   An element placed within a penetration that seals the penetration
///   for a particular reason. 
/// 
/// 'Rack' 
///   A set of shelving for the purposes of storage that may be
///   freestanding or bolted to a structure. 
/// 
/// 'Safety part' 
///   A part, typically installed in vertical shafts at each level, to
///   ensure safety from falling when entering the shaft. 
/// 
/// 'Sleeve' 
///   A thin barrier placed between a penetration and a penetrating
///   element. 
/// 
/// 'Support section' 
///   A section of material that is used as an intermediate support upon
///   which multiple brackets can be mounted.
class IfcDiscreteAccessoryType : public IfcElementComponentType {
public:
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcElementComponentType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcElementComponentType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcElementComponentType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcDiscreteAccessoryType (IfcAbstractEntity* e);
    IfcDiscreteAccessoryType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType);
    typedef IfcTemplatedEntityList< IfcDiscreteAccessoryType > list;
};
/// The distribution flow element type IfcDistributionChamberElementType defines commonly shared information for occurrences of distribution chamber elements.  The set of shared information may include:
/// 
/// common properties with shared property sets
/// common materials
/// common ports
/// common composition of elements
/// common assignment of process types
/// common representations of shape and style
/// 
/// It is used to define a distribution chamber element specification (i.e. the specific product information, that is common to all occurrences of that product type).  Distribution Chamber Element types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcDistributionChamberElementType are represented by instances of IfcDistributionChamberElement.
/// 
/// HISTORY: New entity in IFC2x2
/// 
/// Property Set Use Definition
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcDistributionFlowElementType and ancestors for inherited property set definitions.
/// The following property set definitions are applicable to this entity:
/// Pset_DistributionChamberElementCommon
/// 
/// The following property set definitions are applicable to this entity according to the PredefinedType attribute: 
/// 
/// Pset_DistributionChamberElementTypeFormedDuct (FORMEDDUCT)
/// Pset_DistributionChamberElementTypeInspectionChamber (INSPECTIONCHAMBER)
/// Pset_DistributionChamberElementTypeInspectionPit (INSPECTIONPIT)
/// Pset_DistributionChamberElementTypeManhole (MANHOLE)
/// Pset_DistributionChamberElementTypeMeterChamber (METERCHAMBER)
/// Pset_DistributionChamberElementTypeSump (SUMP)
/// Pset_DistributionChamberElementTypeTrench (TRENCH)
/// Pset_DistributionChamberElementTypeValveChamber (VALVECHAMBER)
/// 
/// Material Use Definition
/// The material of the IfcDistributionChamberElementType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used:
/// 
/// 'Base': The material from which the base of the duct is constructed.
/// 'Cover': The material from which the access cover to the chamber is constructed.
/// 'Fill': The material that is used to fill the duct (where used).
/// 'Wall': The material from which the wall of the duct is constructed.
class IfcDistributionChamberElementType : public IfcDistributionFlowElementType {
public:
    /// Predefined types of distribution chambers.
    IfcDistributionChamberElementTypeEnum::IfcDistributionChamberElementTypeEnum PredefinedType() const;
    void setPredefinedType(IfcDistributionChamberElementTypeEnum::IfcDistributionChamberElementTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcDistributionFlowElementType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcDistributionChamberElementTypeEnum; } return IfcDistributionFlowElementType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcDistributionFlowElementType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcDistributionChamberElementType (IfcAbstractEntity* e);
    IfcDistributionChamberElementType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcDistributionChamberElementTypeEnum::IfcDistributionChamberElementTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcDistributionChamberElementType > list;
};
/// The element type IfcDistributionControlElementType defines a list of commonly shared property set definitions of an element and an optional set of product representations.  It is used to define an element specification (the specific product information that is common to all occurrences of that product type). 
/// 
/// Distribution control element types (or the instantiable subtypes) may be exchanged without being already assigned to occurrences. 
/// 
/// The occurrences of the IfcDistributionControlElementType are represented by instances of IfcDistributionControlElement or its subtypes. 
/// 
/// HISTORY: New entity in IFC Release 2x2.
/// 
/// Declaration Use Definition
/// The IfcDistributionControlElementType may be declared within a project or project library using IfcRelDeclares where RelatingContext refers to the project or library and RelatedDefinitions includes the element type.  Inclusion within IfcProject indicates the type is editable within the direct project and may be available to other referencing projects that may incorporate the type.  Inclusion within IfcProjectLibrary indicates the type is incorporated from a referenced project.  Default units and coordinate systems (used for representations, materials, and property sets) are indicated by the declaring project or library.
/// 
/// Classification Use Definition
/// The IfcDistributionControlElementType may be classified using IfcRelAssociatesClassification where RelatingClassification refers to an IfcClassificationReference indicating a classification notation. Classifications may refer to industry standards such as MasterFormat, OmniFormat, or UniFormat.  Classifications may also refer to organization-specific, project-specific, or system-specific designations.  Classification reference identification schemes are described by IfcClassification.ReferenceTokens.
/// 
/// Document Use Definition
/// The IfcDistributionControlElementType may be documented using IfcRelAssociatesDocument where RelatingDocument refers to an IfcDocumentReference indicating content within a document, or IfcDocumentInformation indicating an entire document. Document information may refer to arbitrary attachments such as text or multimedia, while document references may refer to items within particular formats (such as XML element IDs) where there is need to synchronize document information with model information.  Document reference identification schemes depend on the particular document format.
/// 
/// Library Use Definition
/// The IfcDistributionControlElementType may be published to a model server using IfcRelAssociatesLibrary where RelatingLibrary refers to an IfcLibraryReference indicating the unique identification within the published project.  If the published project is IFC format, then IfcLibraryReference.Identification shall match IfcRoot.GlobalID of the published (master) project, using the same encoding as described for IfcGloballyUniqueId.  Multiple library references may be provided to indicate alternate names and descriptions for particular languages.  If the element type is declared within IfcProject, then IfcLibraryInformation.Location and IfcLibraryInformation.Version indicate the URL and version as last published.  If the element type is declared within IfcProjectLibrary, then the library information indicates the location and version of the definition as last retrieved.
/// 
/// Composition Use Definition
/// The IfcDistributionControlElementType may be decomposed into components using IfcRelAggregates where RelatingObject refers to the enclosing IfcDistributionFlowElementType and RelatedObjects contains one or more components.  For example, a thermostat type may be decomposed into temperature sensors.  Standard types for composition are defined at occurrences for subtypes.
/// 
/// Connection Use Definition
/// The IfcDistributionControlElementType may be connected to other objects as follows using the indicated relationship:
/// 
/// IfcDistributionPort (IfcRelConnectsPortToElement) : Indicates port definitions on the element to be instantiated at occurrences.  Standard port names, types, and directions are defined at occurrences for subtypes.
/// 
/// Assignment Use Definition
///   The IfcDistributionControlElementType may have assignments of its own using the IfcRelAssignsToProduct relationship where RelatingProduct refers to the IfcDistributionControlElementType and RelatedObjects contains one or more objects of the following types: 
/// 
/// IfcTaskType: Indicates task types available to purchase, install, renovate, demolish, operate, or otherwise act upon occurrences of the element type.  Such task types may be instantiated as task occurrences assigned to occurrences of the element type.  Prices (such as for purchasing or shipping) may be established by resource types assigned to task types.
/// IfcProcedureType: Indicates procedure types available to operate occurrences of the element type.  Such procedure types may be instantiated as procedure occurrences assigned to occurrences of the element type.
/// IfcEventType: Indicates event types available to be raised by occurrences of the element, sequenced by procedures to be followed.  Such event types may be instantiated as event occurrences assigned to occurrences of the element type.
/// 
/// Material Use Definition
/// The material of the IfcDistributionControlElementType is defined using one of the following entities:
/// 
/// IfcMaterialConstituentSet: For elements containing multiple materials, this indicates materials at named aspects.
/// 
/// IfcMaterial: For elements comprised of a single material, this indicates the material.
/// 
/// The material is attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.
/// 
/// Representation Use Definition
/// The following shape representations are supported for subtypes of IfcDistributionControlElementType, distinguished by IfcShapeRepresentation.RepresentationIdentifier:
/// 
/// 'Footprint': Represents the 2D footprint outline of the item having IfcShapeRepresentation.RepresentationType of 'GeometricCurveSet' and containing a single IfcGeometricCurveSet consisting of one or more IfcCurve subtypes such as IfcPolyline, IfcTrimmedCurve, IfcCompositeCurve, or IfcCircle.
/// 
/// 'Body': Represents the 3D shape of the item having IfcShapeRepresentation.RepresentationType of 'SurfaceModel', 'SolidModel', or any solid model specializations including 'Brep', 'AdvancedBrep', 'SweptSolid', 'AdvancedSweptSolid', 'CSG', 'Clipping', or 'SectionedSpine').
/// 
/// 'Clearance': Represents the 3D clearance volume of the item having RepresentationType of 'Surface3D'.  Such clearance region indicates space that should not intersect with the 'Body' representation between element occurrences, though may intersect with the 'Clearance' representation of other element occurrences.  The particular use of clearance space may be for safety, maintenance, or other purpose.
/// 
/// NOTE: The product representations are defined as representation maps (at the level of the supertype IfcTypeProduct, which get assigned by an element occurrence instance through the IfcShapeRepresentation.Item[1] being an IfcMappedItem.
class IfcDistributionControlElementType : public IfcDistributionElementType {
public:
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcDistributionElementType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcDistributionElementType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcDistributionElementType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcDistributionControlElementType (IfcAbstractEntity* e);
    IfcDistributionControlElementType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType);
    typedef IfcTemplatedEntityList< IfcDistributionControlElementType > list;
};
/// Definition from IAI: Generalization of all elements
/// that participate in a distribution system. Typical examples of
/// IfcDistributionElement are (among others):
/// 
/// building service elements within a heating systems
/// building service elements within a cooling system
/// building service elements within a ventilation system
/// building service elements within a plumbing system
/// 
/// e.g. sanitary elements, fire suppression elements
/// 
/// electrical elements
/// elements within a communication network
/// 
/// The IfcDistributionElement is further specialized in
/// the IFC model. Direct instantiation of
/// IfcDistributionElement without an assigned subtype of
/// IfcDistributionElementType provides the meaning of an
/// distribution element proxy.
/// HISTORY New entity in
/// IFC Release 1.5.
/// IFC2x4 CHANGE The entity is marked
/// as deprecated for instantiation - will be made ABSTRACT after
/// IFC2x4.
/// Relationship Use Definition
/// 
/// Ports - information, whether the distribution element has
/// ports for system connections
/// 
/// objectified relationship:
/// IfcRelConnectsPortToElement
/// object referenced by relationship: IfcPort
/// inverse attribute: HasPorts
/// 
/// Type Use Definition
/// The IfcDistributionElement defines the occurrence of
/// any HVAC, electrical, sanitary or other element within a
/// distribution system. Common information about distribution
/// element types (or styles) is handled by subtypes of
/// IfcDistributionElementType. The
/// IfcDistributionElementType (if present) may establish the
/// common type name, usage (or predefined) type, common material,
/// common set of properties and common shape representations (using
/// IfcRepresentationMap). The
/// IfcDistributionElementType is attached using the
/// IfcRelDefinedByType.RelatingType objectified relationship
/// and is accessible by the inverse IsDefinedBy
/// attribute.
/// The assignment of types to distribution element occurrences is
/// vital for providing the additional meaning, or ontology, of the
/// distribution element. Many specialized type are defined in other
/// schemas of the IFC specification.
/// Quantity Use Definition
/// The quantities relating to the IfcDistributionElement
/// are defined by the IfcElementQuantity and attached by the
/// IfcRelDefinesByProperties. A detailed specification for
/// individual quantities is introduced at the level of subtypes of
/// IfcDistributionElement.
/// Containment Use Definition
/// The IfcDistributionElement may participate in two
/// different containment relationships. The first (and in most
/// implementation scenarios mandatory) relationship is the
/// hierachical spatial containment, the second (optional)
/// relationship is the aggregation within anÿelement assembly.
/// 
/// The IfcDistributionElement is places within the
/// project spatial hierarchy using the objectified relationship
/// IfcRelContainedInSpatialStructure, referring to it by its
/// inverse attribute SELF\IfcElement.ContainedInStructure.
/// Subtypes ofÿIfcSpatialStructureElement are valid spatial
/// containers, with IfcSpace being the default
/// container.
/// The IfcDistributionElement may be aggregated into an
/// element assembly using the objectified relationship
/// IfcRelAggregates, referring to it by its inverse attribute
/// SELF\IfcObjectDefinition.Decomposes. Any subtype of
/// IfcElement can be an element assembly, with
/// IfcElementAssembly as a special focus subtype. In this
/// case it should not be additionally contained in the project
/// spatial hierarchy,
/// i.e.ÿSELF\IfcElement.ContainedInStructure should be
/// NIL.
/// 
/// Geometry Use Definitions
/// The geometric representation of IfcDistributionElement
/// is given by the IfcProductDefinitionShape, allowing
/// multiple geometric representation.
/// Local Placement
/// The local placement for IfcDistributionElement is
/// defined in its supertype IfcProduct. It is defined by the
/// IfcLocalPlacement, which defines the local coordinate
/// system that is referenced by all geometric representations.
/// 
/// The PlacementRelTo relationship of
/// IfcLocalPlacement shall point (if given) to the local
/// placement of the same IfcSpatialStructureElement , which
/// is used in the ContainedInStructure inverse attribute, or
/// to a spatial structure element at a higher level, referenced by
/// that.
/// If the relative placement is not used, the absolute placement
/// is defined within the world coordinate system.
/// 
/// Geometric Representations
/// The geometric representation of IfcDistributionElement
/// is defined using different geometric representation types for the
/// various subtypes. Only general recommendations are given at the
/// level of the supertype, further constraints are defined at the
/// level of its subtypes.
/// 
/// all occurrences of IfcDistributionElement (and its
/// subtypes) should (whenever possible) share a representation map
/// established by the assigned type. The geometric representation of
/// the occurrence is then an IfcMappedItem. The
/// IfcShapeRepresentation has:
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'MappedRepresentation'
/// 
/// The shared geometric representation of the distribution
/// element type (or in some cases of the distribution element)
/// should follow (if applicable) the the following guidelines:
/// 
/// all fixtures (all non distribution flow elements, i.e.
/// everything which is not a duct, a pipe, a cable, or a cable
/// carrier) should be defined by an b-rep geometry. This includes
/// also the complex flow fitting elements (e.g. Y branch or T
/// branch) or distribution flow elements with size changes (e.g.
/// reducer). The IfcShapeRepresentation has:
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'Brep'
/// 
/// if the geometric model consistency of a b-rep shape
/// representation can not be guaranteed (arcwise connected volume
/// bounded by faces, each being connected, oriented, finite, closed
/// 2-manifold), a surface representation based on open shells should
/// be used. The IfcShapeRepresentation then has:
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'SurfaceModel'
/// 
/// all "simple" distribution flow elements (general ducts and
/// pipes) are defined by sweep geometry. The
/// IfcShapeRepresentation has:
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'SweptSolid'
/// 
/// an additional representation type for all "simple"
/// distribution flow elements (general ducts and pipes) is the
/// ability to have a simple line based representation. The
/// IfcShapeRepresentation has:
/// 
/// RepresentationIdentifier : 'FootPrint'
/// RepresentationType : 'GeometricCurveSet'
/// 
/// if only the analytical shape is required for which the exact
/// interpolation between the cross sections is not required, a
/// sectioned spine can be used.
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'SectionedSpine'
class IfcDistributionElement : public IfcElement {
public:
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcDistributionElement (IfcAbstractEntity* e);
    IfcDistributionElement (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag);
    typedef IfcTemplatedEntityList< IfcDistributionElement > list;
};
/// The distribution element IfcDistributionFlowElement defines occurrence elements of a distribution system that facilitate the distribution of energy or matter, such as air, water or power.
/// 
/// EXAMPLEs of distribution flow elements are ducts, pipes, wires, fittings, and equipment.
/// 
/// HISTORY: New entity in IFC R2.0.
/// 
/// Type Use Definition
/// IfcDistributionFlowElement defines the occurrence of any distribution flow element; common information about distribution flow element types is handled by IfcDistributionFlowElementType.  The IfcDistributionFlowElementType (if present) may establish the common type name, usage (predefined type), properties, materials, ports, composition, assignments, and representations.  The IfcDistributionFlowElementType is attached using the IfcRelDefinesByType objectified relationship and is accessible by the IsTypedBy inverse attribute.  If the IfcDistributionFlowElementType has ports or aggregated elements, such objects are reflected at the IfcDistributionFlowElement occurrence using the IfcRelDefinesByObject relationship.  Direct instantiation of IfcDistributionFlowElement with IfcObject.ObjectType asserted provides the meaning of a distribution flow element proxy.
/// 
/// Property Set Use Definition
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the IfcRelDefinesByProperties relationship. They are accessible by the IsDefinedBy inverse attribute.  Property sets may also be specified at the IfcDistributionFlowElementType, defining the common property data for all occurrences of the same type.  They are then accessible by the IsTypedBy inverse attribute pointing to IfcDistributionFlowElementType.HasPropertySets. If both are given, then the properties directly defined at IfcDistributionFlowElement override the properties defined at IfcDistributionFlowElementType.  Refer to the documentation at the supertype IfcDistributionElement and ancestors for inherited property set definitions.
/// 
/// Composition Use Definition
/// The IfcDistributionFlowElement may be decomposed into components using IfcRelAggregates where RelatingObject refers to the enclosing IfcDistributionFlowElement and RelatedObjects contains one or more components.  For example, a cable may be decomposed into wires.  Standard types for composition are defined at subtypes.
/// 
/// Connection Use Definition
/// The IfcDistributionFlowElement may be connected to other objects as follows using the indicated relationship:
/// 
/// IfcSpatialStructureElement (IfcRelContainedInSpatialStructure) : Indicates the spatial location containing the element.
/// IfcElement (IfcRelConnectsElements) : Indicates physical connectivity with another element (but not embedding or flow transmission), such as a light fixture hanging from a ceiling (IfcCovering), or a junction box having a cover plate (IfcDiscreteAccessory).  IfcRelConnectsElements.RelatingElement refers to the anchored side (ceiling for fixture, junction box for cover).
/// IfcElement (IfcRelInterferesElements) : Indicates interference with another element and precedence, such as a pipe going through a wall.
/// IfcOpening (IfcRelFillsElement) : Indicates embedding an element within another element (implying a cutout), such as an air terminal or junction box embedded within a wall.
/// IfcDistributionPort (IfcRelConnectsPortToElement) : Indicates ports on the element which may be connected to other elements for flow distribution of solids, liquids, gas, or electricity.  Standard port names, types, and directions are defined at subtypes.
/// IfcDistributionControlElement (IfcRelFlowControlElements) : Indicates a control element that senses or controls some aspect of the flow element, such as a level sensor for a tank or an actuator for a valve.
/// 
/// Assignment Use Definition
/// The IfcDistributionFlowElement may be assigned to the following entities using relationships as indicated:
/// 
/// IfcDistributionSystem (IfcRelAssignsToGroup): Indicates a system containing interconnected devices.
/// IfcPerformanceHistory (IfcRelAssignsToControl): Indicates realtime or historical infomation captured for the device.
/// 
/// The IfcDistributionFlowElement may have assignments of its own using the IfcRelAssignsToProduct relationship where RelatingProduct refers to the IfcDistributionFlowElement and RelatedObjects contains one or more objects of the following types: 
/// 
/// IfcTask: Indicates tasks used to purchase, install, renovate, demolish, operate, or otherwise act upon the element.  If the element has a type, available task types are assigned to the element type.
/// IfcProcedure: Indicates procedures used to operate the element.  If the element has a type, available procedure types are assigned to the element type.
/// IfcEvent: Indicates events raised by the element, sequenced by procedures to be followed.  If the element has a type, available event types are assigned to the element type.
/// 
/// Material Use Definition
/// The material of the IfcDistributionFlowElement is defined using one of the following entities:
/// 
/// IfcMaterialProfileSetUsage: For parametric segments, this defines the cross section and alignment to the 'Axis' representation, from which the 'Body' representation may be generated.
/// 
/// IfcMaterialProfileSet: For non-parametric segments (having fixed length or path), this may define the cross section for analysis purposes, however the 'Body' representation is independently generated.
/// 
/// IfcMaterialConstituentSet: For elements containing multiple materials, this indicates materials at named aspects.
/// 
/// IfcMaterial: For elements comprised of a single material, this indicates the material.
/// 
/// The material is attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.  Material information can also be given at the IfcDistributionFlowElementType, defining the common attribute data for all occurrences of the same type.  Standard names and material types are defined at subtypes.
/// 
/// Representation Use Definition
/// The following shape representations are supported for subtypes of IfcDistributionFlowElement, distinguished by IfcShapeRepresentation.RepresentationIdentifier:
/// 
/// 'Axis': Represents the 3D flow path of the item having IfcShapeRepresentation.RepresentationType of 'Curve3D' and containing a single IfcBoundedCurve subtype such as IfcPolyline, IfcTrimmedCurve, or IfcCompositeCurve.  For elements containing directional ports (IfcDistributionPort with FlowDirection of SOURCE or SINK), the direction of the curve indicates direction of flow where a SINK port is positioned at the start of the curve and a SOURCE port is positioned at the end of the curve.  This representation is most applicable to flow segments (pipes, ducts, cables), however may be used at other elements to define a primary flow path if applicable. 
/// 
/// 'Footprint': Represents the 2D footprint outline of the item having IfcShapeRepresentation.RepresentationType of  'GeometricCurveSet' and containing a single IfcGeometricCurveSet consisting of one or more IfcCurve subtypes such as IfcPolyline, IfcTrimmedCurve, IfcCompositeCurve, or IfcCircle.
/// 
/// 'Body': Represents the 3D shape of the item having IfcShapeRepresentation.RepresentationType of 'SurfaceModel', 'SolidModel', or any solid model specializations including 'Brep', 'AdvancedBrep', 'SweptSolid', 'AdvancedSweptSolid', 'CSG', 'Clipping', or 'SectionedSpine').
/// 
/// 'Clearance': Represents the 3D clearance volume of the item having RepresentationType of 'Surface3D'.  Such clearance region indicates space that should not intersect with the 'Body' representation of other elements, though may intersect with the 'Clearance' representation of other elements.  The particular use of clearance space may be for safety, maintenance, or other purpose.
/// 
/// 'Lighting': Represents the light emission of the item having IfcShapeRepresentation.RepresentationType of 'LightSource' and containing one or more IfcLightSource subtypes.  This representation is most applicable to lamps and light fixtures, however may be used at other elements that emit light.
/// 
/// For all representations, if a IfcDistributionFlowElement occurrence is defined by a IfcDistributionFlowElementType having a representation of the same identifier, then 'MappedRepresentation' should be used at the occurrence unless overridden.
/// 
/// If materials are defined, geometry of each representation (most typically the 'Body' representation) may be organized into shape aspects where styles may be derived by correlating IfcShapeAspect.Name to a corresponding material (IfcMaterialConstituent.Name or IfcMaterialProfile.Name).
/// 
/// Representations are further defined at subtypes; for example, parametric flow segments align material profiles with the 'Axis' representation.
class IfcDistributionFlowElement : public IfcDistributionElement {
public:
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcDistributionElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcDistributionElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcDistributionElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcRelFlowControlElements >::ptr HasControlElements() const; // INVERSE IfcRelFlowControlElements::RelatingFlowElement
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcDistributionFlowElement (IfcAbstractEntity* e);
    IfcDistributionFlowElement (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag);
    typedef IfcTemplatedEntityList< IfcDistributionFlowElement > list;
};
/// A distribution port is an inlet or outlet of a product through which a particular substance may flow.
/// 
/// Distribution ports are used for passage of solid, liquid, or gas substances, as well as electricity for power or communications.  Flow segments (pipes, ducts, cables) may be used to connect ports across products.  Distribution ports are defined by system type and flow direction such that for two ports to be connected, they must share the same system type and have opposite flow directions (one side being a SOURCE and the other being a SINK).  Ports are similar to openings in that they do not have any visible geometry; such geometry is captured at the shape representation of the enclosing element or element type.  Ports may have shape representations that indicate the position, orientation, and cross-section of the connection.
/// 
/// HISTORY: New entity in IFC2x2
/// 
/// Property Set Use Definition
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the IfcRelDefinesByProperties relationship. They are accessible by the IsDefinedBy inverse attribute.  Refer to the documentation at the supertype IfcPort and ancestors for inherited property set definitions.
/// The following property set definitions are applicable to this entity:
/// 
/// Pset_DistributionPortCommon
/// 
/// The following property set definitions are applicable to this entity according to the PredefinedType attribute: 
/// 
/// Pset_DistributionPortTypeAirConditioning (AIRCONDITIONING)
/// Pset_DistributionPortTypeAudioVisual (AUDIOVISUAL)
/// Pset_DistributionPortTypeData (DATA)
/// Pset_DistributionPortTypeDomesticColdWater (DOMESTICCOLDWATER)
/// Pset_DistributionPortTypeDomesticHotWater (DOMESTICHOTWATER)
/// Pset_DistributionPortTypeDrainage (DRAINAGE)
/// Pset_DistributionPortTypeElectrical (ELECTRICAL)
/// Pset_DistributionPortTypeFireProtection (FIREPROTECTION)
/// Pset_DistributionPortTypeGas (GAS)
/// Pset_DistributionPortTypeHeating (HEATING)
/// Pset_DistributionPortTypeOil (OIL)
/// Pset_DistributionPortTypeSewage (SEWAGE)
/// Pset_DistributionPortTypeSignal (SIGNAL)
/// Pset_DistributionPortTypeTelephone (TELEPHONE)
/// 
/// The following property set definitions are applicable to IfcPerformanceHistory, for which objects are assigned:
/// 
/// Pset_DistributionPortPHistoryAirConditioning (AIRCONDITIONING)
/// Pset_DistributionPortPHistoryControl (CONTROL)
/// Pset_DistributionPortPHistoryData (DATA)
/// Pset_DistributionPortPHistoryElectrical (ELECTRICAL)
/// Pset_DistributionPortPHistoryGas (GAS)
/// Pset_DistributionPortPHistoryHeating (HEATING)
/// Pset_DistributionPortPHistoryOil (OIL)
/// Pset_DistributionPortPHistorySignal (SIGNAL)
/// 
/// Material Use Definition
/// The material of the IfcDistributionPort is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used:
/// 
/// 'Media': The solid, liquid, or gas media passing through the port.
/// 
/// Composition Use Definition
/// The IfcDistributionPort may be decomposed into components using IfcRelAggregates where RelatingObject refers to the enclosing IfcDistributionPort and RelatedObjects contains one or more components.  Composition use is defined for the following predefined types:
/// 
/// AUDIOVISUAL: May contain IfcDistributionPort components having PredefinedType AUDIOVISUAL.  If needed, audio-visual ports may be aggregated into specific streams (channels).CONTROL: May contain IfcDistributionPort components having PredefinedType SIGNAL.  If needed, control ports may be aggregated into signal lines for indicating pinout specification.DATA: May contain IfcDistributionPort components having PredefinedType SIGNAL.  If needed, data ports may be aggregated into signal lines for indicating pinout specification.ELECTRICAL: May contain IfcDistributionPort components having PredefinedType SIGNAL.  If needed, electrical ports may be aggregated into modulated signals for data or lighting control.ELECTROACCOUSTIC: May contain IfcDistributionPort components having PredefinedType ELECTROACCOUSTIC.  If needed, speaker ports may be aggregated into streams (channels) for each speaker.TELEPHONE: May contain IfcDistributionPort components having PredefinedType TELEPHONE.  If needed, telephone ports may be aggregated for each line.
/// 
/// Connection Use Definition
/// The IfcDistributionPort may be connected to other objects as follows using the indicated relationship:
/// 
/// IfcDistributionElement (IfcRelConnectsPortToElement) : Indicates the host element or element type containing the port.
/// IfcDistributionPort (IfcRelConnectsPorts) : Indicates a connection to another port having the same type and opposite flow direction.  
/// For port connections between elements, 
/// the RelatingPort is set to a port having FlowDirection=SOURCE and 
/// the RelatedPort is set to a port having FlowDirection=SINK.  
/// For aggregation scenarios, ports on a device may be mapped to aggregated devices within, 
/// in which case ports on the outer device indicate a single FlowDirection but have an additional connection internally 
/// to a port on an aggregated inner device.  
/// Refer to IfcUnitaryEquipment for an example.
/// 
/// Figure 149 illustrates distribution port connectivity.
/// 
/// Figure 149 — Distribution port connectivity
/// 
/// Assignment Use Definition
///   The IfcDistributionPort may be assigned to the following entities using relationships as indicated:
/// 
/// IfcDistributionSystem (IfcRelAssignsToGroup): Indicates a system containing interconnected devices.
/// IfcPerformanceHistory (IfcRelAssignsToControl): Indicates realtime or historical infomation captured for the device.
/// 
/// The IfcDistributionPort may have assignments of its own using the IfcRelAssignsToProduct relationship where RelatingProduct refers to the IfcDistributionPort and RelatedObjects contains one or more objects of the following types: 
/// IfcDistributionSystem: Indicates a system that is hosted by the port, as the origination.
/// 
/// Representation Use Definition
/// The representation of IfcDistributionPort is given by IfcProductDefinitionShape, allowing multiple shape and topology representations.  Included are:
/// 
/// IfcShapeRepresentation: The optional shape representation describes the connection volume and supports indication of the port position and orientation.  The position is typically the midpoint of the physical connection, and the orientation points in the flow direction normal to the physical connection. Upon connecting elements through ports with rigid connections, each object is aligned such that the effective Location, Axis, and RefDirection of each port is aligned to be equal.
/// 
/// 'Body': The shape of the port.
class IfcDistributionPort : public IfcPort {
public:
    /// Whether the optional attribute FlowDirection is defined for this IfcDistributionPort
    bool hasFlowDirection() const;
    /// Enumeration that identifies if this port is a Sink (inlet), a Source (outlet) or both a SinkAndSource.
    IfcFlowDirectionEnum::IfcFlowDirectionEnum FlowDirection() const;
    void setFlowDirection(IfcFlowDirectionEnum::IfcFlowDirectionEnum v);
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 7: return IfcUtil::Argument_ENUMERATION; } return IfcPort::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 7: return Type::IfcFlowDirectionEnum; } return IfcPort::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 7: return "FlowDirection"; } return IfcPort::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcDistributionPort (IfcAbstractEntity* e);
    IfcDistributionPort (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcFlowDirectionEnum::IfcFlowDirectionEnum > v8_FlowDirection);
    typedef IfcTemplatedEntityList< IfcDistributionPort > list;
};
/// Definition from ISO 6707-1:1989: Construction for
/// closing an opening, intended primarily for access with hinged,
/// pivoted or sliding operation.
/// The door is a building element
/// that is predominately used to provide controlled access for
/// people and goods. It includes constructions with hinged, pivoted,
/// sliding, and additionally revolving and folding operations. A
/// door consists of a lining and one or several panels.
/// The IfcDoor defines a particular occurrence of a door
/// inserted in the spatial context of a project. A door can:
/// 
/// be inserted as a filler in an opening using the
/// IfcRelFillsElement relationship, then the IfcDoor
/// has an inverse attribute FillsVoids provided,
/// 
/// NOTEÿ View definitions or
/// implementer agreements may restrict the relationship to only
/// include one window (or door) into one opening.
/// 
/// be part of an element assembly, in general an
/// IfcCurtainWall, using the IfcRelAggregates
/// relationship, then the inverse attribute Decomposes is
/// provided.
/// or be a "free standing" door, then the IfcDoor has no
/// inverse attributes FillsVoids or Decomposes
/// provided.
/// 
/// The IFC specification provides two entities for door
/// occurrences:
/// 
/// IfcDoorStandardCase used for all occurrences of doors,
/// that have a 'Profile' shape representation defined to which a set
/// of shape parameters for lining and framing properties apply.
/// Additionally it requires the provision of an IfcDoorType
/// that references one IfcDoorLiningProperties and on to many
/// IfcDoorPanelProperties.
/// 
/// NOTEÿ see
/// IfcDoorStandardCase for all specific constraints imposed
/// by this subtype.
/// 
/// IfcDoor used for all other occurrences of doors,
/// particularly for doors having only 'Brep', or 'SurfaceModel'
/// geometry without applying shape parameters.
/// 
/// The actual parameter of the door and/or its shape are defined
/// by the IfcDoor as the occurrence definition (or project
/// instance), or by the IfcDoorType as the specific definition (or
/// project type). The following parameters are given:
/// 
/// at the IfcDoor or IfcDoorStandardCase for
/// occurrence specific parameters. The IfcDoor
/// specifies:
/// 
/// the door width and height
/// the door opening direction (by the y-axis of the
/// ObjectPlacement)
/// 
/// at the IfcDoorType, to
/// which the IfcDoor is related by the inverse relationship
/// IsDefinedBy pointing to IfcRelDefinesByType, for
/// type parameters common to all occurrences of the same type.
/// 
/// the operation type (single swing, double swing, revolving,
/// etc.)
/// the door hinge side (by using two different styles for right
/// and left opening doors)
/// the construction material type
/// the particular attributes for the lining by the
/// IfcDoorLiningProperties
/// the particular attributes for the panels by theÿ
/// IfcDoorPanelProperties
/// 
/// HISTORY New entity in IFC Release 1.0.
/// IFC2x4 CHANGE The attributes PredefinedType and OperationType are added, the applicable type object has been changed to IfcDoorType.
/// 
/// Material Use Definition
/// The material of the IfcDoor is defined by the
/// IfcMaterialConstituentSet or as fall back by
/// IfcMaterial and attached by the
/// IfcRelAssociatesMaterial.RelatingMaterial. It is
/// accessible by the inverse HasAssociations
/// relationship.
/// The following keywords for
/// IfcMaterialConstituentSet.MaterialConstituents[n].Name
/// shall be used:
/// 
/// 'Lining' - to indicate that the material constituent applies
/// to to the door lining
/// 'Framing' - to indicate that the material constituent applies
/// to to the door panel(s), if not provided, the 'Lining' material
/// information applied to panel(s) as well
/// 'Glazing' - to indicate that the material constituent applies
/// to to the glazing part
/// 
/// If the fall back single IfcMaterial is referenced, it
/// applies to the lining and framing of the door.
/// Property Set Use Definition:
/// The property sets relating to the IfcDoor are defined
/// by the IfcPropertySet and attached by the
/// IfcRelDefinesByProperties relationship. It is accessible
/// by the inverse IsDefinedBy relationship. The following
/// property set definitions specific to the IfcDoor are part
/// of this IFC release:
/// 
/// Pset_DoorCommon: common property set for all
/// door occurrences
/// Pset_DoorWindowGlazingType: specific property
/// set for the glazing properties of the door glazing, if
/// available
/// Pset_DoorWindowShadingType: specific property
/// set for the shading properties of the door glazing, if
/// available
/// 
/// Quantity Use Definition
/// The quantities relating to the IfcDoor are defined by
/// the IfcElementQuantity and attached by the
/// IfcRelDefinesByProperties relationship. It is accessible
/// by the inverse IsDefinedBy relationship. The following
/// base quantities are defined and should be exchanged with the
/// IfcElementQuantity.Name = 'BaseQuantities'. Other
/// quantities can be defined being subjected to local standard of
/// measurement with another string value assigned to
/// MethodOfMeasurement. Quanties shall be never assigned to
/// the IfcDoorType.
/// 
/// Qto_DoorBaseQuantities: base quantities for
/// all door occurrences.
/// 
/// Containment Use Definition
/// The IfcDoor, as any subtype of
/// IfcBuildingElement, may participate in two different
/// containment relationships as shown in Figure 96. The first (and in most implementation
/// scenarios mandatory) relationship is the hierachical spatial
/// containment, the second (optional) relationship is the
/// aggregation within anÿelement assembly.
/// 
/// The IfcDoor is places within the project spatial
/// hierarchy using the objectified relationship
/// IfcRelContainedInSpatialStructure, refering to it by its
/// inverse attribute SELF\IfcElement.ContainedInStructure.
/// Subtypes ofÿIfcSpatialStructureElement are valid spatial
/// containers, with IfcBuildingStorey being the default
/// container.
/// The IfcDoor may be aggregated into an element assembly
/// using the objectified relationship IfcRelAggregates,
/// refering to it by its inverse attribute
/// SELF\IfcObjectDefinition.Decomposes. Doors may be part of
/// an IfcCurtainWall as a special focus subtype. In this case
/// it should not be additionally contained in the project spatial
/// hierarchy, i.e.ÿSELF\IfcElement.ContainedInStructure
/// should be NIL.
/// 
/// NOTE The containment shall be defined independently of the
/// filling relationship, that is, even if the IfcDoor is a
/// filling of an opening established by IfcRelFillsElement,
/// it is also contained in the spatial structure by an
/// IfcRelContainedInSpatialStructure.
/// 
/// Figure 96 — Door containment
/// 
/// Geometry Use Definitions:
/// The geometric representation of IfcDoor is given by the
/// IfcProductDefinitionShape, allowing multiple geometric
/// representations. The IfcDoor, in case of an occurrance
/// object, gets its parameter and shape from the IfcDoorType.
/// If an IfcRepresentationMap (a block definition) is defined
/// for the IfcDoorType, then the IfcDoor inserts it
/// through the IfcMappedItem.
/// Local Placement
/// The local placement for IfcDoor is defined in its
/// supertype IfcProduct. It is defined by the
/// IfcLocalPlacement, which defines the local coordinate
/// system that is referenced by all geometric representations.
/// 
/// The PlacementRelTo relationship of
/// IfcLocalPlacement shall point to the local placement of
/// the same element (if given), in which the IfcDoor is used
/// as a filling (normally an IfcOpeningElement), as provided
/// by the IfcRelFillsElement relationship.
/// If the IfcDoor is not inserted into an
/// IfcOpeningElement, then the PlacementRelTo
/// relationship of IfcLocalPlacement shall point (if given)
/// to the local placement of the same
/// IfcSpatialStructureElement that is used in the
/// ContainedInStructure inverse attribute or to a referenced
/// spatial structure element at a higher level.
/// If the relative placement is not used, the absolute placement
/// is defined within the world coordinate system.
/// 
/// Geometric Representation
/// Theÿgeometric representation of IfcDoor is defined
/// using the following (potentiallyÿmultiple)
/// IfcShapeRepresentation's for its
/// IfcProductDefinitionShape:
/// 
/// Profile: Aÿ'Curve3D'
/// consisting of a single losed curve defining the outer boundary of
/// the door (lining). The door parametric representation uses this
/// profile in order to apply the door lining and panel parameter. If
/// not provided, the profile of the IfcOpeningElement is
/// taken.
/// FootPrint: A 'GeometricCurveSet', or 'Annotation2D'
/// representation defining the 2D shape of the door
/// Body: A 'SweptSolid', 'SurfaceModel', or 'Brep'
/// representation defining the 3D shape of the door.
/// 
/// In addition the parametric representation of a (limited) door
/// shape is available by applying the parameters from
/// IfcDoorType referencing IfcDoorLiningProperties and
/// IfcDoorPanelProperties. The purpose of the parameter is
/// described at those entities and below (door opening operation by
/// door type).
/// Profile -ÿ'Curve3D' representation
/// The door profile is represented by a three-dimensional closed
/// curve within a particular shape representation. The profile is
/// used to apply the parameter of the parametric door
/// representation.ÿThe following attribute values for the
/// IfcShapeRepresentation holding this geometric
/// representation shall be used:
/// 
/// RepresentationIdentifier : 'Profile'
/// RepresentationType : 'Curve3D', only a single closed
/// curve shall be contained in the set of
/// IfcShapeRepresentation.Items.
/// 
/// A 'Profile' representation has to be provided if:
/// 
/// a parametric representation shall be applied to the door
/// AND
/// 
/// theÿdoor is 'free standing', or
/// the opening into which theÿdoor is inserted is not extruded
/// horizontally (i.e. where the opening profile does not match
/// theÿdoor profile)
/// 
/// FootPrint -ÿ'GeometricCurveSet' or 'Annotation2D'
/// representation
/// The door foot print is represented by a set of
/// two-dimensionalÿcurves (or in case of 'Annotation2D' additional
/// hatching and text) within a particular shape representation. The
/// foot print is used for the planview representation of the
/// door.ÿThe following attribute values for the
/// IfcShapeRepresentation holding this geometric
/// representation shall be used:
/// 
/// RepresentationIdentifier : 'FootPrint'
/// RepresentationType : 'GeometricCurveSet', or
/// 'Annotation2D'
/// 
/// Body - 'SweptSolid', 'SurfaceModel', or 'Brep'
/// representation
/// The door body is either represented parameterically (see
/// parametric representation) or by explicit 3D shape. The 3D shape
/// is given by using extrusion geometry, or surface models, or Brep
/// models within a particular shape representation. The body is used
/// for the model view representation of the door.ÿThe following
/// attribute values for the IfcShapeRepresentation holding
/// this geometric representation shall be used:
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'SweptSolid', 'SurfaceModel', or
/// 'Brep'
/// 
/// MappedRepresentation
/// The 'FootPrint' and 'Body' geometric representation of
/// IfcDoor can be shared among several identical doors using
/// the 'MappedRepresentation'. The following attribute values for
/// the IfcShapeRepresentation holding this geometric
/// representation shall be used:
/// 
/// RepresentationIdentifier : 'FootPrint', 'Body'
/// RepresentationType : 'MappedRepresentation'
/// 
/// The same constraints, as given for theÿ 'FootPrint', 'Body'
/// representation identifiers, shall apply to the
/// MappedRepresentation of the
/// IfcRepresentationMap.
/// Parameteric Representation using parameters at
/// IfcDoorType
/// The parameters that defines the shape of the IfcDoor,
/// are given at the IfcDoorType and the property sets, which
/// are included in the IfcDoorType. The IfcDoor only
/// defines the local placement which determines the opening
/// direction of the door. The overall size of
/// the IfcDoor to be used to apply the lining or panel
/// parameter provided by the IfcDoorType is determined by the
/// IfcShapeRepresentation with the RepresentationIdentifier =
/// 'Profile'. Only in case of an IfcDoor inserted into an
/// IfcOpeningElement using the IfcRelFillsElement
/// relatioship, having a horizontal extrusion (along the y-axis of
/// the IfcDoor), the overall size is determined by the
/// extrusion profile of the IfcOpeningElement.
/// NOTE ÿThe OverallWidth and
/// OverallHeight parameters are for informational purpose
/// only.
/// The opening direction is determined by the local placement of
/// IfcDoor and the OperationType of the door
/// style as shown in Figure 97.
/// NOTE ÿThere are different definitions in
/// various countries on what a left opening or left hung or left
/// swing door is (same for right). Therefore the IFC definition may
/// derivate from the local standard and need to be mapped
/// appropriately.
/// 
/// Opening
/// directions
/// 
/// Definitions
/// Reference to other
/// standards
/// 
/// The door panel (for swinging doors) opens
/// always into the direction of the positive Y axis of the local
/// placement. The determination of whether the door opens to the
/// left or to the right is done at the level of the
/// IfcDoorType. Here it is a left side opening door given
/// byÿIfcDoorType.OperationType =
/// SingleSwingLeft
/// refered to as LEFT HAND (LH) in US *
/// 
/// refered to as DIN-R (right hung) in Germany
/// 
/// If the door should open to the other
/// side, then the local placement has to be changed. It is still a
/// left side opening door, given by IfcDoorType.OperationType
/// = SingleSwingLeft
/// refered to as RIGHT HAND REVERSE (RHR) in
/// US *
/// 
/// refered to as DIN-R (right hung) in Germany
/// 
/// If the door panel (for swinging doors)
/// opens to the right, a separate door style needs to be used (here
/// IfcDoorTypee.OperationType = SingleSwingRight) and it
/// always opens into the direction of the positive Y axis of the
/// local placement.ÿ
/// refered to as RIGHT HAND (RH) in US *
/// 
/// refered to as DIN-L (left hung) in Germany
/// 
/// If the door panel (for swinging doors)
/// opens to the right, and into the opposite directions, the local
/// placement of the door need to change. The door style is given by
/// IfcDoorType.OperationType = SingleSwingRight.
/// refered to as LEFT HAND REVERSE (LHR) in
/// US *
/// 
/// refered to as DIN-L (left hung) in Germany
/// 
/// * it assumes that the
/// 'inside/private/primary' space is above (top in the pictures) and
/// the 'outside/public/secondary' space is below (bottom in the
/// pictures).
/// 
/// Figure 97 — Door swing
class IfcDoor : public IfcBuildingElement {
public:
    /// Whether the optional attribute OverallHeight is defined for this IfcDoor
    bool hasOverallHeight() const;
    /// Overall measure of the height, it reflects the Z Dimension of a bounding box, enclosing the body of the door opening. If omitted, the OverallHeight should be taken from the geometric representation of the IfcOpening in which the door is inserted. 
    /// 
    /// NOTE  The body of the door might be taller then the door opening (e.g. in cases where the door lining includes a casing). In these cases the OverallHeight shall still be given as the door opening height, and not as the total height of the door lining.
    double OverallHeight() const;
    void setOverallHeight(double v);
    /// Whether the optional attribute OverallWidth is defined for this IfcDoor
    bool hasOverallWidth() const;
    /// Overall measure of the width, it reflects the X Dimension of a bounding box, enclosing the body of the door opening. If omitted, the OverallWidth should be taken from the geometric representation of the IfcOpening in which the door is inserted. 
    /// 
    /// NOTE  The body of the door might be wider then the door opening (e.g. in cases where the door lining includes a casing). In these cases the OverallWidth shall still be given as the door opening width, and not as the total width of the door lining.
    double OverallWidth() const;
    void setOverallWidth(double v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_DOUBLE; case 9: return IfcUtil::Argument_DOUBLE; } return IfcBuildingElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcPositiveLengthMeasure; case 9: return Type::IfcPositiveLengthMeasure; } return IfcBuildingElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "OverallHeight"; case 9: return "OverallWidth"; } return IfcBuildingElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcDoor (IfcAbstractEntity* e);
    IfcDoor (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< double > v9_OverallHeight, boost::optional< double > v10_OverallWidth);
    typedef IfcTemplatedEntityList< IfcDoor > list;
};
/// The flow fitting type IfcDuctFittingType defines commonly shared information for occurrences of duct fittings.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a duct fitting specification (i.e. the specific product information, that is common to all occurrences of that product type).  Duct Fitting types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcDuctFittingType are represented by instances of IfcDuctFitting. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcFlowFittingType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_DuctFittingTypeCommon 
/// 
/// Material Use Definition 
/// The material of the IfcDuctFittingType is defined by IfcMaterialProfileSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialProfileSet.MaterialProfiles[n].Name shall be used: 
/// 
/// 'Body': Material from which the duct fitting is constructed. 
/// 'Coating': The outer coating, if applicable. 
/// 'Insulation': The insulating wrapping, if applicable. 
/// 'Lining': The inner lining, if applicable. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcDuctFittingType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcDuctFitting for standard port definitions.
class IfcDuctFittingType : public IfcFlowFittingType {
public:
    /// The type of duct fitting.
    IfcDuctFittingTypeEnum::IfcDuctFittingTypeEnum PredefinedType() const;
    void setPredefinedType(IfcDuctFittingTypeEnum::IfcDuctFittingTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcFlowFittingType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcDuctFittingTypeEnum; } return IfcFlowFittingType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcFlowFittingType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcDuctFittingType (IfcAbstractEntity* e);
    IfcDuctFittingType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcDuctFittingTypeEnum::IfcDuctFittingTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcDuctFittingType > list;
};
/// The flow segment type IfcDuctSegmentType defines commonly shared information for occurrences of duct segments.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a duct segment specification (i.e. the specific product information, that is common to all occurrences of that product type).  Duct Segment types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcDuctSegmentType are represented by instances of IfcDuctSegment. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcFlowSegmentType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_DuctSegmentTypeCommon 
/// 
/// Material Use Definition 
/// The material of the IfcDuctSegmentType is defined by IfcMaterialProfileSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialProfileSet.MaterialProfiles[n].Name shall be used: 
/// 
/// 'Body': Material from which the duct segment is constructed. 
/// 'Coating': The outer coating, if applicable. 
/// 'Insulation': The insulating wrapping, if applicable. 
/// 'Lining': The inner lining, if applicable. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcDuctSegmentType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcDuctSegment for standard port definitions.
class IfcDuctSegmentType : public IfcFlowSegmentType {
public:
    /// The type of duct segment.
    IfcDuctSegmentTypeEnum::IfcDuctSegmentTypeEnum PredefinedType() const;
    void setPredefinedType(IfcDuctSegmentTypeEnum::IfcDuctSegmentTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcFlowSegmentType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcDuctSegmentTypeEnum; } return IfcFlowSegmentType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcFlowSegmentType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcDuctSegmentType (IfcAbstractEntity* e);
    IfcDuctSegmentType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcDuctSegmentTypeEnum::IfcDuctSegmentTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcDuctSegmentType > list;
};
/// The flow treatment device type IfcDuctSilencerType defines commonly shared information for occurrences of duct silencers.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a duct silencer specification (i.e. the specific product information, that is common to all occurrences of that product type).  Duct Silencer types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcDuctSilencerType are represented by instances of IfcDuctSilencer. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcFlowTreatmentDeviceType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_DuctSilencerTypeCommon 
/// 
/// Material Use Definition 
/// The material of the IfcDuctSilencerType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Body': The primary material from which the object is constructed. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcDuctSilencerType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcDuctSilencer for standard port definitions.
class IfcDuctSilencerType : public IfcFlowTreatmentDeviceType {
public:
    /// The type of duct silencer.
    IfcDuctSilencerTypeEnum::IfcDuctSilencerTypeEnum PredefinedType() const;
    void setPredefinedType(IfcDuctSilencerTypeEnum::IfcDuctSilencerTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcFlowTreatmentDeviceType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcDuctSilencerTypeEnum; } return IfcFlowTreatmentDeviceType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcFlowTreatmentDeviceType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcDuctSilencerType (IfcAbstractEntity* e);
    IfcDuctSilencerType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcDuctSilencerTypeEnum::IfcDuctSilencerTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcDuctSilencerType > list;
};

class IfcEdgeFeature : public IfcFeatureElementSubtraction {
public:
    /// Whether the optional attribute FeatureLength is defined for this IfcEdgeFeature
    bool hasFeatureLength() const;
    double FeatureLength() const;
    void setFeatureLength(double v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_DOUBLE; } return IfcFeatureElementSubtraction::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcPositiveLengthMeasure; } return IfcFeatureElementSubtraction::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "FeatureLength"; } return IfcFeatureElementSubtraction::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcEdgeFeature (IfcAbstractEntity* e);
    IfcEdgeFeature (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< double > v9_FeatureLength);
    typedef IfcTemplatedEntityList< IfcEdgeFeature > list;
};
/// The flow terminal type IfcElectricApplianceType defines commonly shared information for occurrences of electric appliances.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a electric appliance specification (i.e. the specific product information, that is common to all occurrences of that product type).  Electric Appliance types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcElectricApplianceType are represented by instances of IfcElectricAppliance. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcFlowTerminalType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity according to the PredefinedType attribute:  
/// Pset_ElectricalDeviceCommon 
/// Pset_ElectricApplianceTypeCommon 
/// Pset_ElectricApplianceTypeDishwasher (DISHWASHER) 
/// Pset_ElectricApplianceTypeElectricCooker (ELECTRICCOOKER) 
/// 
/// Material Use Definition 
/// The material of the IfcElectricApplianceType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Casing': Material from which the casing is constructed. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcElectricApplianceType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcElectricAppliance for standard port definitions.
class IfcElectricApplianceType : public IfcFlowTerminalType {
public:
    /// Identifies the predefined types of electrical appliance from which the type required may be set.
    IfcElectricApplianceTypeEnum::IfcElectricApplianceTypeEnum PredefinedType() const;
    void setPredefinedType(IfcElectricApplianceTypeEnum::IfcElectricApplianceTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcFlowTerminalType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcElectricApplianceTypeEnum; } return IfcFlowTerminalType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcFlowTerminalType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcElectricApplianceType (IfcAbstractEntity* e);
    IfcElectricApplianceType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcElectricApplianceTypeEnum::IfcElectricApplianceTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcElectricApplianceType > list;
};
/// The flow storage device type IfcElectricFlowStorageDeviceType defines commonly shared information for occurrences of electric flow storage devices.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a electric flow storage device specification (i.e. the specific product information, that is common to all occurrences of that product type).  Electric Flow Storage Device types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcElectricFlowStorageDeviceType are represented by instances of IfcElectricFlowStorageDevice. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcFlowStorageDeviceType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_ElectricalDeviceCommon 
/// Pset_ElectricFlowStorageDeviceTypeCommon 
/// 
/// Material Use Definition 
/// The material of the IfcElectricFlowStorageDeviceType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Casing': Material from which the casing is constructed. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcElectricFlowStorageDeviceType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcElectricFlowStorageDevice for standard port definitions.
class IfcElectricFlowStorageDeviceType : public IfcFlowStorageDeviceType {
public:
    /// Identifies the predefined types of electric flow storage devices from which the type required may be set.
    IfcElectricFlowStorageDeviceTypeEnum::IfcElectricFlowStorageDeviceTypeEnum PredefinedType() const;
    void setPredefinedType(IfcElectricFlowStorageDeviceTypeEnum::IfcElectricFlowStorageDeviceTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcFlowStorageDeviceType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcElectricFlowStorageDeviceTypeEnum; } return IfcFlowStorageDeviceType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcFlowStorageDeviceType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcElectricFlowStorageDeviceType (IfcAbstractEntity* e);
    IfcElectricFlowStorageDeviceType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcElectricFlowStorageDeviceTypeEnum::IfcElectricFlowStorageDeviceTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcElectricFlowStorageDeviceType > list;
};
/// The energy conversion device type IfcElectricGeneratorType defines commonly shared information for occurrences of electric generators.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a electric generator specification (i.e. the specific product information, that is common to all occurrences of that product type).  Electric Generator types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcElectricGeneratorType are represented by instances of IfcElectricGenerator. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcEnergyConversionDeviceType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_ElectricalDeviceCommon 
/// Pset_ElectricGeneratorTypeCommon 
/// 
/// Material Use Definition 
/// The material of the IfcElectricGeneratorType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Casing': Material from which the casing is constructed. 
/// 
/// Composition Use Definition 
/// The IfcElectricGeneratorType may be aggregated into components using IfcRelAggregates where RelatingObject refers to the enclosing IfcElectricGeneratorType and RelatedObjects contains one or more components.  Components are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Aggregation use is defined for the following predefined types:
/// 
/// ENGINEGENERATOR: May contain IfcEngine components.  Engine-Generator sets may optionally include an engine to indicate specific detail. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcElectricGeneratorType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcElectricGenerator for standard port definitions.
class IfcElectricGeneratorType : public IfcEnergyConversionDeviceType {
public:
    /// Identifies the predefined types of electric generators from which the type required may be set.
    IfcElectricGeneratorTypeEnum::IfcElectricGeneratorTypeEnum PredefinedType() const;
    void setPredefinedType(IfcElectricGeneratorTypeEnum::IfcElectricGeneratorTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcEnergyConversionDeviceType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcElectricGeneratorTypeEnum; } return IfcEnergyConversionDeviceType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcEnergyConversionDeviceType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcElectricGeneratorType (IfcAbstractEntity* e);
    IfcElectricGeneratorType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcElectricGeneratorTypeEnum::IfcElectricGeneratorTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcElectricGeneratorType > list;
};

class IfcElectricHeaterType : public IfcFlowTerminalType {
public:
    IfcElectricHeaterTypeEnum::IfcElectricHeaterTypeEnum PredefinedType() const;
    void setPredefinedType(IfcElectricHeaterTypeEnum::IfcElectricHeaterTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcFlowTerminalType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcElectricHeaterTypeEnum; } return IfcFlowTerminalType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcFlowTerminalType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcElectricHeaterType (IfcAbstractEntity* e);
    IfcElectricHeaterType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcElectricHeaterTypeEnum::IfcElectricHeaterTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcElectricHeaterType > list;
};
/// The energy conversion device type IfcElectricMotorType defines commonly shared information for occurrences of electric motors.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a electric motor specification (i.e. the specific product information, that is common to all occurrences of that product type).  Electric Motor types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcElectricMotorType are represented by instances of IfcElectricMotor. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcEnergyConversionDeviceType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_ElectricalDeviceCommon 
/// Pset_ElectricMotorTypeCommon 
/// 
/// Material Use Definition 
/// The material of the IfcElectricMotorType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Casing': Material from which the casing is constructed. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcElectricMotorType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcElectricMotor for standard port definitions.
class IfcElectricMotorType : public IfcEnergyConversionDeviceType {
public:
    /// Identifies the predefined types of electric motor from which the type required may be set.
    IfcElectricMotorTypeEnum::IfcElectricMotorTypeEnum PredefinedType() const;
    void setPredefinedType(IfcElectricMotorTypeEnum::IfcElectricMotorTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcEnergyConversionDeviceType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcElectricMotorTypeEnum; } return IfcEnergyConversionDeviceType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcEnergyConversionDeviceType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcElectricMotorType (IfcAbstractEntity* e);
    IfcElectricMotorType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcElectricMotorTypeEnum::IfcElectricMotorTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcElectricMotorType > list;
};
/// The flow controller type IfcElectricTimeControlType defines commonly shared information for occurrences of electric time controls.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a electric time control specification (i.e. the specific product information, that is common to all occurrences of that product type).  Electric Time Control types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcElectricTimeControlType are represented by instances of IfcElectricTimeControl. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcFlowControllerType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_ElectricalDeviceCommon 
/// Pset_ElectricTimeControlTypeCommon 
/// 
/// Material Use Definition 
/// The material of the IfcElectricTimeControlType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Casing': Material from which the casing is constructed. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcElectricTimeControlType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcElectricTimeControl for standard port definitions.
class IfcElectricTimeControlType : public IfcFlowControllerType {
public:
    /// Identifies the predefined types of electrical time control from which the type required may be set.
    IfcElectricTimeControlTypeEnum::IfcElectricTimeControlTypeEnum PredefinedType() const;
    void setPredefinedType(IfcElectricTimeControlTypeEnum::IfcElectricTimeControlTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcFlowControllerType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcElectricTimeControlTypeEnum; } return IfcFlowControllerType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcFlowControllerType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcElectricTimeControlType (IfcAbstractEntity* e);
    IfcElectricTimeControlType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcElectricTimeControlTypeEnum::IfcElectricTimeControlTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcElectricTimeControlType > list;
};

class IfcElectricalCircuit : public IfcSystem {
public:
    virtual unsigned int getArgumentCount() const { return 5; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcSystem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcSystem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcSystem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcElectricalCircuit (IfcAbstractEntity* e);
    IfcElectricalCircuit (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType);
    typedef IfcTemplatedEntityList< IfcElectricalCircuit > list;
};

class IfcElectricalElement : public IfcElement {
public:
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcElectricalElement (IfcAbstractEntity* e);
    IfcElectricalElement (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag);
    typedef IfcTemplatedEntityList< IfcElectricalElement > list;
};
/// The distribution flow element IfcEnergyConversionDevice defines 
///   the occurrence of a device used to perform
///   energy conversion or heat transfer and typically participates
///   in a flow distribution system. Its type is defined by IfcEnergyConversionDeviceType 
///   or its subtypes.
/// 
/// HISTORY: New entity in IFC R2.0.
/// 
/// IFC 2x4 NOTE: This entity has been deprecated for instantiation and will become ABSTRACT in a future release; new subtypes should now be used instead.
class IfcEnergyConversionDevice : public IfcDistributionFlowElement {
public:
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcDistributionFlowElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcDistributionFlowElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcDistributionFlowElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcEnergyConversionDevice (IfcAbstractEntity* e);
    IfcEnergyConversionDevice (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag);
    typedef IfcTemplatedEntityList< IfcEnergyConversionDevice > list;
};
/// The flow moving device type IfcFanType defines commonly shared information for occurrences of fans.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a fan specification (i.e. the specific product information, that is common to all occurrences of that product type).  Fan types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcFanType are represented by instances of IfcFan. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcFlowMovingDeviceType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_FanTypeCommon 
/// Pset_FanTypeSmokeControl 
/// 
/// Material Use Definition 
/// The material of the IfcFanType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Housing': The material used to construct the fan housing. 
/// 'Wheel': The material used to construct the fan wheel. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcFanType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcFan for standard port definitions.
class IfcFanType : public IfcFlowMovingDeviceType {
public:
    /// Defines the type of fan typically used in building services.
    IfcFanTypeEnum::IfcFanTypeEnum PredefinedType() const;
    void setPredefinedType(IfcFanTypeEnum::IfcFanTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcFlowMovingDeviceType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcFanTypeEnum; } return IfcFlowMovingDeviceType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcFlowMovingDeviceType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcFanType (IfcAbstractEntity* e);
    IfcFanType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcFanTypeEnum::IfcFanTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcFanType > list;
};
/// The flow treatment device type IfcFilterType defines commonly shared information for occurrences of filters.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a filter specification (i.e. the specific product information, that is common to all occurrences of that product type).  Filter types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcFilterType are represented by instances of IfcFilter. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcFlowTreatmentDeviceType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_FilterTypeCommon 
/// 
/// The following property set definitions are applicable to this entity according to the PredefinedType attribute:  
/// Pset_FilterTypeAirParticleFilter (AIRPARTICLEFILTER) 
/// 
/// Material Use Definition 
/// The material of the IfcFilterType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Media': The material that is used for filtering particulates from the fluid. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcFilterType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcFilter for standard port definitions.
class IfcFilterType : public IfcFlowTreatmentDeviceType {
public:
    /// The type of air filter.
    IfcFilterTypeEnum::IfcFilterTypeEnum PredefinedType() const;
    void setPredefinedType(IfcFilterTypeEnum::IfcFilterTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcFlowTreatmentDeviceType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcFilterTypeEnum; } return IfcFlowTreatmentDeviceType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcFlowTreatmentDeviceType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcFilterType (IfcAbstractEntity* e);
    IfcFilterType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcFilterTypeEnum::IfcFilterTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcFilterType > list;
};
/// The flow terminal type IfcFireSuppressionTerminalType defines commonly shared information for occurrences of fire suppression terminals.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a fire suppression terminal specification (i.e. the specific product information, that is common to all occurrences of that product type).  Fire Suppression Terminal types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcFireSuppressionTerminalType are represented by instances of IfcFireSuppressionTerminal. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcFlowTerminalType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_FireSuppressionTerminalTypeCommon 
/// 
/// The following property set definitions are applicable to this entity according to the PredefinedType attribute:  
/// Pset_FireSuppressionTerminalTypeBreechingInlet (BREECHINGINLET) 
/// Pset_FireSuppressionTerminalTypeFireHydrant (FIREHYDRANT) 
/// Pset_FireSuppressionTerminalTypeHoseReel (HOSEREEL) 
/// Pset_FireSuppressionTerminalTypeSprinkler (SPRINKLER) 
/// 
/// Material Use Definition 
/// The material of the IfcFireSuppressionTerminalType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Body': The primary material from which the object is constructed. 
/// 'Deflector': The material used to construct the deflector plate. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcFireSuppressionTerminalType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcFireSuppressionTerminal for standard port definitions.
class IfcFireSuppressionTerminalType : public IfcFlowTerminalType {
public:
    /// Identifies the predefined types of fire suppression terminal from which the type required may be set.
    IfcFireSuppressionTerminalTypeEnum::IfcFireSuppressionTerminalTypeEnum PredefinedType() const;
    void setPredefinedType(IfcFireSuppressionTerminalTypeEnum::IfcFireSuppressionTerminalTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcFlowTerminalType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcFireSuppressionTerminalTypeEnum; } return IfcFlowTerminalType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcFlowTerminalType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcFireSuppressionTerminalType (IfcAbstractEntity* e);
    IfcFireSuppressionTerminalType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcFireSuppressionTerminalTypeEnum::IfcFireSuppressionTerminalTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcFireSuppressionTerminalType > list;
};
/// The distribution flow element IfcFlowController defines
///   the occurrence of elements of a distribution system that 
///   are used to regulate flow through a distribution system. 
///   Examples include dampers, valves, switches, and relays. Its type is defined by 
///   IfcFlowControllerType or subtypes.
/// 
/// HISTORY: New entity in IFC R2.0.
/// 
/// IFC 2x4 NOTE: This entity has been deprecated for instantiation and will become ABSTRACT in a future release; new subtypes should now be used instead.
class IfcFlowController : public IfcDistributionFlowElement {
public:
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcDistributionFlowElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcDistributionFlowElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcDistributionFlowElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcFlowController (IfcAbstractEntity* e);
    IfcFlowController (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag);
    typedef IfcTemplatedEntityList< IfcFlowController > list;
};
/// The distribution flow element IfcFlowFitting defines the occurrence of a junction or transition in a flow distribution system, such as an elbow or tee. Its type is defined by IfcFlowFittingType or its subtypes.
/// 
/// HISTORY: New entity in IFC R2.0.
/// 
/// IFC 2x4 NOTE: This entity has been deprecated for instantiation and will become ABSTRACT in a future release; new subtypes should now be used instead.
class IfcFlowFitting : public IfcDistributionFlowElement {
public:
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcDistributionFlowElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcDistributionFlowElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcDistributionFlowElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcFlowFitting (IfcAbstractEntity* e);
    IfcFlowFitting (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag);
    typedef IfcTemplatedEntityList< IfcFlowFitting > list;
};
/// The distribution control element type IfcFlowInstrumentType defines commonly shared information for occurrences of flow instruments.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a flow instrument specification (i.e. the specific product information, that is common to all occurrences of that product type).  Flow Instrument types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcFlowInstrumentType are represented by instances of IfcFlowInstrument. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcDistributionControlElementType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_FlowInstrumentTypeCommon 
/// 
/// The following property set definitions are applicable to this entity according to the PredefinedType attribute:  
/// Pset_FlowInstrumentTypePressureGauge (PRESSUREGAUGE) 
/// Pset_FlowInstrumentTypeThermometer (THERMOMETER) 
/// 
/// Material Use Definition 
/// The material of the IfcFlowInstrumentType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Casing': Material from which the casing is constructed. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcFlowInstrumentType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcFlowInstrument for standard port definitions.
class IfcFlowInstrumentType : public IfcDistributionControlElementType {
public:
    /// Identifies the predefined types of flow instrument from which the type required may be set.
    IfcFlowInstrumentTypeEnum::IfcFlowInstrumentTypeEnum PredefinedType() const;
    void setPredefinedType(IfcFlowInstrumentTypeEnum::IfcFlowInstrumentTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcDistributionControlElementType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcFlowInstrumentTypeEnum; } return IfcDistributionControlElementType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcDistributionControlElementType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcFlowInstrumentType (IfcAbstractEntity* e);
    IfcFlowInstrumentType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcFlowInstrumentTypeEnum::IfcFlowInstrumentTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcFlowInstrumentType > list;
};
/// The distribution flow element IfcFlowMovingDevice defines the occurrence of an apparatus used to distribute, circulate or perform conveyance of fluids, including liquids and gases (such as a pump or fan), and typically participates in a flow distribution system. Its type is defined by IfcFlowMovingDeviceType or its subtypes.
/// 
/// HISTORY: New entity in IFC R2x.
/// 
/// IFC 2x4 NOTE: This entity has been deprecated for instantiation and will become ABSTRACT in a future release; new subtypes should now be used instead.
class IfcFlowMovingDevice : public IfcDistributionFlowElement {
public:
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcDistributionFlowElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcDistributionFlowElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcDistributionFlowElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcFlowMovingDevice (IfcAbstractEntity* e);
    IfcFlowMovingDevice (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag);
    typedef IfcTemplatedEntityList< IfcFlowMovingDevice > list;
};
/// The distribution flow element IfcFlowSegment defines the occurrence of a segment of a flow distribution system.
/// 
/// HISTORY: New entity in IFC R2.0.
/// IFC 2x4 NOTE: This entity has been deprecated for instantiation and will become ABSTRACT in a future release; new subtypes should now be used instead.        
/// 
/// The IfcFlowSegment defines a particular occurrence of a segment inserted in the spatial context of a project. The parameters defining the type of the segment and/or its shape are defined by the IfcFlowSegmentType, which is related by the inverse relationship IsDefinedBy pointing to IfcRelDefinesByType.
/// 
/// Material Use Definition
/// The material of the IfcFlowSegment is defined using one of the following entities:
/// 
/// IfcMaterialProfileSetUsage : for parametric segments, this defines the cross section and alignment to the 'Axis' representation, from which the 'Body' representation may be generated.
/// 
/// IfcMaterialProfileSet : for non-parametric segments (having fixed length or path), this may define the cross section for analysis purposes, however the 'Body' representation is independently generated.
/// 
/// IfcMaterialConstituentSet : for elements containing multiple materials where profiles are not applicable, this indicates materials at named parts.
/// 
/// IfcMaterial : for elements comprised of a single material where profiles are not applicable, this indicates the material.
/// 
/// The material is attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.  Material information can also be given at the IfcFlowSegmentType, defining the common attribute data for all occurrences of the same type.  Standard names and material types are defined at subtypes.
/// 
/// Representation Use Definition
/// 
/// Standard representations are defined at the supertype IfcDistrubutionFlowElement.  For parametric flow segments where IfcMaterialProfileSetUsage is defined and an 'Axis' representation is defined, then the 'Body' representation may be generated using the 'SweptSolid' or 'AdvancedSweptSolid' representation types by sweeping the profile(s) along the axis.
class IfcFlowSegment : public IfcDistributionFlowElement {
public:
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcDistributionFlowElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcDistributionFlowElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcDistributionFlowElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcFlowSegment (IfcAbstractEntity* e);
    IfcFlowSegment (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag);
    typedef IfcTemplatedEntityList< IfcFlowSegment > list;
};
/// The distribution flow element IfcFlowStorageDevice defines
///   the occurrence of a device that participates in a distribution
///   system and is used for temporary storage of a fluid
///   such as a liquid or a gas (e.g., tank). Its type is defined by 
/// 
/// IfcFlowStorageDeviceType or its subtypes.
/// 
/// HISTORY: New entity in IFC R2x.
/// 
/// IFC 2x4 NOTE: This entity has been deprecated for instantiation and will become ABSTRACT in a future release; new subtypes should now be used instead.
class IfcFlowStorageDevice : public IfcDistributionFlowElement {
public:
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcDistributionFlowElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcDistributionFlowElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcDistributionFlowElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcFlowStorageDevice (IfcAbstractEntity* e);
    IfcFlowStorageDevice (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag);
    typedef IfcTemplatedEntityList< IfcFlowStorageDevice > list;
};
/// The distribution flow element IfcFlowTerminal defines the
///   occurrence of a permanently attached element that acts as a terminus or 
///   beginning of a distribution system (e.g., air outlet, drain, 
///   water closet, sink, etc.). A terminal is typically a point
///   at which a system interfaces with an external environment.
///   Its type is defined by IfcFlowTerminalType or
///   its subtypes.
/// 
/// HISTORY: New entity in IFC R2.0.
/// 
/// IFC 2x4 NOTE: This entity has been deprecated for instantiation and will become ABSTRACT in a future release; new subtypes should now be used instead.
class IfcFlowTerminal : public IfcDistributionFlowElement {
public:
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcDistributionFlowElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcDistributionFlowElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcDistributionFlowElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcFlowTerminal (IfcAbstractEntity* e);
    IfcFlowTerminal (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag);
    typedef IfcTemplatedEntityList< IfcFlowTerminal > list;
};
/// The distribution flow element IfcFlowTreatmentDevice defines the occurrence of a device typically used to remove unwanted matter from a fluid, either liquid or gas, and typically participates in a flow distribution system.  Its type is defined by IfcFlowTreatmentDeviceType or its subtypes.
/// 
/// HISTORY: New entity in IFC R2x.
/// 
/// IFC 2x4 NOTE: This entity has been deprecated for instantiation and will become ABSTRACT in a future release; new subtypes should now be used instead.
class IfcFlowTreatmentDevice : public IfcDistributionFlowElement {
public:
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcDistributionFlowElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcDistributionFlowElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcDistributionFlowElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcFlowTreatmentDevice (IfcAbstractEntity* e);
    IfcFlowTreatmentDevice (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag);
    typedef IfcTemplatedEntityList< IfcFlowTreatmentDevice > list;
};
/// A footing is a part of the foundation of a structure that spreads and transmits the load to the soil, either directly or via piles.
/// 
/// HISTORY New entity in IFC2x2
/// 
/// Note, slab foundations are not instantiated as IfcFooting but as IfcSlab or IfcSlabStandardCase with a predefined type of IfcSlabTypeEnum.BASESLAB.
/// 
/// Property Set Use Definition
/// 
/// The following property set definitions are part of this IFC release:
/// 
/// Pset_FootingCommon: common property set for all footing occurrences.
///   Pset_ReinforcementBarCountOfIndependentFooting: property set for independent IfcFooting occurrences.
///   Pset_ReinforcementBarPitchOfContinuousFooting: property set for continuous IfcFooting occurrences.
/// 
/// Quantity Use Definition 
///   The quantities relating to this entity are defined by IfcElementQuantity and attached by the IfcRelDefinesByProperties relationship. They are accessible by the IsDefinedBy inverse attribute. The following base quantities are defined and should be exchanged with the IfcElementQuantity.Name = 'BaseQuantities'. Other quantities, being subjected to local standard of measurement, can be defined with another string value assigned to Name. In this case a valid value for MethodOfMeasurement has to be provided.  
/// 
/// Qto_FootingBaseQuantities 
/// 
/// Geometry Use Definition
/// 
/// Local placement and product representations are defined by the supertype IfcBuildingElement.  Standard representations as defined at IfcBeamStandardCase or IfcSlabStandardCase should be used when applicable.
class IfcFooting : public IfcBuildingElement {
public:
    /// The generic type of the footing.
    /// 
    /// IFC 2x4 change:  Attribute made optional.  Type information can be provided by IfcRelDefinesByType and IfcFootingType.
    IfcFootingTypeEnum::IfcFootingTypeEnum PredefinedType() const;
    void setPredefinedType(IfcFootingTypeEnum::IfcFootingTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcBuildingElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcFootingTypeEnum; } return IfcBuildingElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "PredefinedType"; } return IfcBuildingElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcFooting (IfcAbstractEntity* e);
    IfcFooting (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, IfcFootingTypeEnum::IfcFootingTypeEnum v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcFooting > list;
};
/// An IfcMember is a
/// structural member designed to carry loads between or beyond
/// points of support. It is not required to be load bearing. The
/// orientation of the member (being horizontal, vertical or sloped)
/// is not relevant to its definition (in contrary to IfcBeam
/// and IfcColumn). An IfcMember represents a linear
/// structural element from an architectural or structural modeling
/// point of view and shall be used if it cannot be expressed more
/// specifically as either an IfcBeam or an
/// IfcColumn.
/// NOTE The representation of a member in a
/// structural analysis model is provided by
/// IfcStructuralCurveMember being part of an
/// IfcStructuralAnalysisModel.
/// The IFC specification provides two entities for member
/// occurrences:
/// 
/// IfcMemberStandardCase used for all occurrences of
/// members, that have a profile defined that is swept along a
/// directrix. The profile might be changed uniformly by a taper
/// definition along the directrix. The profile parameter and its
/// cardinal point of insertion can be fully described by the
/// IfcMaterialProfileSetUsage. These beams are always
/// represented geometricly by an 'Axis' and a 'SweptSolid' or
/// 'AdvancedSweptSolid' shape representation (or by a 'Clipping'
/// geometry based on the swept solid), if a 3D geometric
/// representation is assigned. In addition they have to have a
/// corresponding IfcMaterialProfileSetUsage assigned.
/// NOTEÿ View definitions and implementer
/// agreements may further constrain the applicable geometry types,
/// e.g. by excluding tapering from an IfcMemberStandardCase
/// implementation.
/// 
/// IfcMember used for all other occurrences of members,
/// particularly for members with changing profile sizes along the
/// extrusion, or members defined by non-linear extrusion, or members
/// having only 'Brep', or 'SurfaceModel' geometry.
/// 
/// HISTORY New entity in
/// IFC Release 2x2 Addendum.
/// Type Use Definition
/// IfcMember defines the occuurence of any member, common
/// information about member types (or styles) is handled by
/// IfcMemberType. The IfcMemberType (if present) may
/// establish the commonÿtype name, usage (or predefined) type,
/// common material profile set, common set of properties and common
/// shape representations (using IfcRepresentationMap). The
/// IfcMemberType is attached using the
/// IfcRelDefinedByType.RelatingType objectified relationship
/// and is accessible by the inverse IsTypedBy attribute.
/// If no IfcMemberType is attachedÿ(i.e. if only
/// occurrence information is given) the PredefinedType should
/// be provided. If set to .USERDEFINED. a user defined value can be
/// provided by the ObjectType attribute.
/// Material Use Definition
/// The material of the IfcMember is defined by the
/// IfcMaterialProfileSet or as fallback by IfcMaterial
/// and attached by the
/// IfcRelAssociatesMaterial.RelatingMaterial. It is
/// accessible by the inverse HasAssociations relationship.
/// Material information can also be given at
/// theÿIfcMemberType, defining the common attribute data for
/// all occurrences of the same type.ÿIt is then accessible by the
/// inverse <IsTypedBy
/// relationship pointing to IfcMemberType.HasAssociations and
/// via IfcRelAssociatesMaterial.RelatingMaterial to
/// IfcMaterialProfileSet or IfcMaterial. If both are
/// given, then the material directly assigned to IfcMember
/// overrides the material assigned toÿIfcMemberType.
/// Property Set Use Definition
/// The property sets relating to the IfcMember are defined
/// by the IfcPropertySet and attached by the
/// IfcRelDefinesByProperties relationship. It is accessible
/// by the inverse IsDefinedBy relationship. The following
/// property set definitions specific to the IfcMember are
/// part of this IFC release:
/// 
/// Pset_MemberCommon: common property set for all
/// member occurrences
/// 
/// Quantity Use Definition
/// The quantities relating to the IfcMember and
/// IfcMemberStandardCase are defined by the
/// IfcElementQuantity and attached by the
/// IfcRelDefinesByProperties relationship. It is accessible
/// by the inverse IsDefinedBy relationship. The following
/// base quantities are defined and should be exchanged with the
/// IfcElementQuantity.Name = 'BaseQuantities'. Other
/// quantities can be defined being subjected to local standard of
/// measurement with another string value assigned to Name and
/// a value provided for MethodOfMeasurement. Quanties shall
/// be never assigned to the IfcMemberType.
/// 
/// Qto_MemberBaseQuantities: base quantities for
/// all member occurrences.
/// 
/// Containment Use Definition
/// The IfcMember, as any subtype of
/// IfcBuildingElement, may participate in two different
/// containment relationships. The first (and in most implementation
/// scenarios mandatory) relationship is the hierachical spatial
/// containment, the second (optional) relationship is the
/// aggregation within anÿelement assembly.
/// 
/// The IfcMember is places within the project spatial
/// hierarchy using the objectified relationship
/// IfcRelContainedInSpatialStructure, refering to it by its
/// inverse attribute SELF\IfcElement.ContainedInStructure.
/// Subtypes ofÿIfcSpatialStructureElement are valid spatial
/// containers, with IfcBuildingStorey being the default
/// container.
/// The IfcMember may be aggregated into an element
/// assembly using the objectified relationship
/// IfcRelAggregates, refering to it by its inverse attribute
/// SELF\IfcObjectDefinition.Decomposes. Any subtype of
/// IfcElement can be an element assembly, with
/// IfcElementAssembly as a special focus subtype. In this
/// case it should not be additionally contained in the project
/// spatial hierarchy, i.e.
/// SELF\IfcElement.ContainedInStructure should be
/// NIL.
/// 
/// Geometry Use Definition
/// The geometric representation of IfcMember is given by
/// the IfcProductDefinitionShape, allowing multiple geometric
/// representations. Included are:
/// Local Placement
/// The local placement for IfcMember is defined in its
/// supertype IfcProduct. It is defined by the
/// IfcLocalPlacement, which defines the local coordinate
/// system that is referenced by all geometric representations.
/// 
/// The PlacementRelTo relationship of
/// IfcLocalPlacement shall point (if given) to the local
/// placement of the same IfcSpatialStructureElement, which is
/// used in the ContainedInStructure inverse attribute, or to
/// a spatial structure element at a higher level, referenced by
/// that.
/// If the relative placement is not used, the absolute placement
/// is defined within the world coordinate system.
/// 
/// Geometric Representation
/// Currently, the 'Axis', 'Body',
/// and 'Box' representations are supported. The 'Box' representation
/// includes the representation type 'BoundingBox' and is explained
/// at IfcBuildingElement.
/// Axis Representation
/// The axis geometric representation of IfcMember is
/// defined using the 'Axis' representation. The following attribute
/// values for the IfcShapeRepresentation holding this
/// geometric representation shall be used:
/// 
/// RepresentationIdentifier : 'Axis'
/// RepresentationType : 'Curve2D', 'Curve3D'
/// 
/// The axis representation can be used to represent the system
/// length of a member that may extent the body length of the
/// member.
/// Body Representation
/// The body representation of IfcBeam can be represented
/// using the representation types 'SweptSolid', 'Clipping',
/// 'AdvancedSweptSolid', 'MappedRepresentation', 'SurfaceModel', and
/// 'Brep'. The representation types 'SurfaceModel' and 'Brep' are
/// explained at IfcBuildingElement.
/// SweptSolid Representation Type
/// The following attribute values for the
/// IfcShapeRepresentation holding this geometric
/// representation shall be used:
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'SweptSolid'
/// 
/// The following additional constraints apply to the 'SweptSolid'
/// representation:
/// 
/// Solid: IfcExtrudedAreaSolid,
/// IfcRevolvedAreaSolid shall be supported
/// Profile: all subtypes of IfcProfileDef (with
/// exception of IfcArbitraryOpenProfileDef)ÿ
/// Extrusion: All extrusion directions shall be
/// supported.
/// 
/// Figure 99 illustrates a 'SweptSolid' geometric representation.  There are no restrictions or conventions on
/// how to use the local placement (black), solid of extrusion placement (red) and profile placement (green).
/// 
/// Figure 99 — Member swept solid
/// 
/// Clipping Representation Type
/// The following attribute values for the
/// IfcShapeRepresentation holding this geometric
/// representation shall be used:
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'Clipping'
/// 
/// The following constraints apply to the advanced
/// representation:
/// 
/// Solid: see 'SweptSolid' geometric representation
/// Profile: see 'SweptSolid' geometric
/// representation
/// Extrusion:ÿsee 'SweptSolid' geometric
/// representation
/// Boolean result: The IfcBooleanClippingResult
/// shall be supported, allowing for Boolean differences between the
/// swept solid (here IfcExtrudedAreaSolid) and one or several
/// IfcHalfSpaceSolid (or its subtypes).
/// 
/// Figure 100 illustrates a 'Clipping' geometric representation with use of IfcBooleanClippingResult between an IfcExtrudedAreaSolid and an IfcHalfSpaceSolid to create a clipped body.
/// 
/// Figure 100 — Member clipping
/// 
/// AdvancedSweptSolid Representation Type
/// The following attribute values for the
/// IfcShapeRepresentation holding this geometric
/// representation shall be used:
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'AdvancedSweptSolid'
/// 
/// The following additional constraints apply to the
/// 'AdvancedSweptSolid' representation type:
/// 
/// Solid: IfcSurfaceCurveSweptAreaSolid,
/// IfcFixedReferenceSweptAreaSolid,
/// IfcExtrudedAreaSolidTapered,
/// IfcRevolvedAreaSolidTapered shall be supported.
/// NOTE View definitions and implementer
/// agreements can further constrain the allowed swept solid
/// types.
/// 
/// Profile: see 'SweptSolid' geometric
/// representation
/// Extrusion:ÿnot applicable
/// 
/// MappedRepresentation Representation Type
/// The 'MappedRepresentation' representation type is supported as
/// it allows for reusing the geometry definition of the beam type at
/// all occurrences of the same type. The following attribute values
/// for the IfcShapeRepresentation holding this geometric
/// representation shall be used:
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'MappedRepresentation'
/// 
/// The same constraints, as given for theÿ 'SweptSolid',
/// 'Clipping', 'AdvancedSweptSolid', 'SurfaceModel' and 'Bre'
/// geometric representation, shall apply to the
/// MappedRepresentation of the
/// IfcRepresentationMap.
class IfcMember : public IfcBuildingElement {
public:
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcBuildingElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcBuildingElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcBuildingElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcMember (IfcAbstractEntity* e);
    IfcMember (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag);
    typedef IfcTemplatedEntityList< IfcMember > list;
};
/// A pile is a slender timber, concrete, or steel structural element, driven, jetted, or otherwise embedded on end in the ground for the purpose of supporting a load.
/// 
/// HISTORY New entity in IFC2x2
/// 
/// Property Set Use Definition
/// 
/// The following property set definitions are part of this IFC release:
/// 
/// Pset_PileCommon: common property set for all pile occurrences.
/// 
/// Quantity Use Definition 
///   The quantities relating to this entity are defined by IfcElementQuantity and attached by the IfcRelDefinesByProperties relationship. They are accessible by the IsDefinedBy inverse attribute. The following base quantities are defined and should be exchanged with the IfcElementQuantity.Name = 'BaseQuantities'. Other quantities, being subjected to local standard of measurement, can be defined with another string value assigned to Name. In this case a valid value for MethodOfMeasurement has to be provided.  
/// 
/// Qto_PileBaseQuantities 
/// 
/// Geometry Use Definition
/// 
/// Local placement and product representations are defined by the supertype IfcBuildingElement.  Standard representations as defined at IfcColumnStandardCase should be used when applicable.
class IfcPile : public IfcBuildingElement {
public:
    /// The predefined generic type of the pile according to function.
    /// 
    /// IFC 2x4 change:  Attribute made optional.  Type information can be provided by IfcRelDefinesByType and IfcPileType.
    IfcPileTypeEnum::IfcPileTypeEnum PredefinedType() const;
    void setPredefinedType(IfcPileTypeEnum::IfcPileTypeEnum v);
    /// Whether the optional attribute ConstructionType is defined for this IfcPile
    bool hasConstructionType() const;
    /// General designator for how the pile is constructed.
    /// 
    /// IFC 2x4 change:  Material profile association capability by means of IfcRelAssociatesMaterial has been added.  The attribute ConstructionType should not be used whenever its information can be provided by a material profile set, either associated with the IfcPile object or, if present, with a corresponding instance of IfcPileType.
    IfcPileConstructionEnum::IfcPileConstructionEnum ConstructionType() const;
    void setConstructionType(IfcPileConstructionEnum::IfcPileConstructionEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; case 9: return IfcUtil::Argument_ENUMERATION; } return IfcBuildingElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcPileTypeEnum; case 9: return Type::IfcPileConstructionEnum; } return IfcBuildingElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "PredefinedType"; case 9: return "ConstructionType"; } return IfcBuildingElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPile (IfcAbstractEntity* e);
    IfcPile (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, IfcPileTypeEnum::IfcPileTypeEnum v9_PredefinedType, boost::optional< IfcPileConstructionEnum::IfcPileConstructionEnum > v10_ConstructionType);
    typedef IfcTemplatedEntityList< IfcPile > list;
};
/// Definition from IAI: An IfcPlate is a planar and
/// often flat part with constant thickness. A plate can be a
/// structural part carrying loads between or beyond points of
/// support, however it is not required to be load bearing.ÿThe
/// location of the plate (being horizontal, vertical or sloped) is
/// not relevant to its definition (in contrary to IfcWall and
/// IfcSlab (as floor slab)).ÿ
/// NOTE ÿPlates areÿnormally made of steel, other
/// metallic material, or by glass panels. However the definition of
/// IfcPlate is material independent and specific material
/// information shall be handled by using
/// IfcAssociatesMaterial to assign a material specification
/// to the IfcPlate.ÿ
/// 
/// NOTE ÿAlthough not necessarily, plates are often add-on
/// parts. This is represented by the IfcRelAggregates
/// decomposition mechanism used to aggregate parts, such as
/// IfcPlate, into a container element, e.g.
/// IfcElementAssembly, or IfcCurtainWall.ÿ
/// 
/// NOTE The representation of a plate in a structural
/// analysis model is provided by IfcStructuralSurfaceMember
/// being part of an
/// IfcStructuralAnalysisModel.
/// An instance IfcPlate should preferably get its
/// geometric representation and material assignment through the type
/// definition by IfcPlateType assigned using the
/// IfcRelDefinesByType relationship. This allows identical
/// plates in a construction to be represented by the same instance
/// of IfcPlateType.
/// A plate may have openings, such as voids or recesses. They are
/// defined by an IfcOpeningElement attached to the plate
/// using the inverse relationship HasOpenings pointing to
/// IfcRelVoidsElement. The position number of a plate as
/// often used in steel construction is assigned through the
/// attribute IfcElement.Tag
/// The IFC specification provides two entities for plate
/// occurrences:
/// 
/// IfcPlateStandardCase used for all occurrences of
/// plates, that are prismatic and where the thickness parameter can
/// be fully described by the IfcMaterialLayerSetUsage. These
/// plates are always represented geometrically by a 'SweptSolid'
/// geometry (or by a 'Clipping' geometry based on 'SweptSolid'), if
/// a 3D geometric representation is assigned. In addition they have
/// to have a corresponding IfcMaterialLayerSetUsage
/// assigned.
/// IfcPlate used for all other occurrences of plates,
/// particularly for plates with changing thickness, or plates with
/// non planar surfaces, and plates having only 'SurfaceModel' or
/// 'Brep' geometry.
/// 
/// HISTORY New entity in
/// IFC Release 2x2
/// Type Use Definition
/// The IfcPlate defines the occuurence of any plate,
/// common information about plate types (or styles) is handled by
/// IfcPlateType. The IfcPlateType (if present) may
/// establish the commonÿtype name, usage (or predefined) type,
/// common set of properties, common material layer set, and common
/// shape representations (using IfcRepresentationMap). The
/// IfcPlateType is attached using the
/// IfcRelDefinedByType.RelatingType objectified relationship
/// and is accessible by the inverse IsTypedBy attribute.
/// If no IfcPlateType is attachedÿ(i.e. if only occurrence
/// information is given) the PredefinedType should be
/// provided. If set to .USERDEFINED. a user defined value can be
/// provided by the ObjectType attribute.
/// Material Use Definition
/// The material of the IfcPlate is defined by
/// IfcMaterialLayerSet, or IfcMaterial and attached by
/// the IfcRelAssociatesMaterial.RelatingMaterial. It
/// is accessible by the inverse HasAssociations
/// relationship.
/// NOTE It is illegal to assign an
/// IfcMaterialLayerSetUsage to an IfcPlate. Only the
/// subtype IfcPlateStandardCase supports this
/// concept.
/// Material information can also be given at the
/// IfcPlateType, defining the common attribute data for all
/// occurrences of the same type.ÿIt is then accessible by the
/// inverse IsTypedBy
/// relationship pointing to IfcPlateType.HasAssociations and
/// via IfcRelAssociatesMaterial.RelatingMaterial.
/// Property Set Use Definition
/// The property sets relating to the IfcPlate are defined
/// by the IfcPropertySet and attached by the
/// IfcRelDefinesByProperties relationship. It is accessible
/// by the inverse IsDefinedBy relationship. The following
/// property set definitions specific to the IfcPlate are part
/// of this IFC release:
/// 
/// Pset_PlateCommon: common property set for all plate
/// occurrences
/// 
/// Quantity Use Definition
/// The quantities relating to the IfcPlate and
/// IfcPlateStandardCase are defined by the
/// IfcElementQuantity and attached by the
/// IfcRelDefinesByProperties relationship. It is accessible
/// by the inverse IsDefinedBy relationship. The following
/// base quantities are defined and should be exchanged with the
/// IfcElementQuantity.Name = 'BaseQuantities'. Other
/// quantities can be defined being subjected to local standard of
/// measurement with another string value assigned to Name and
/// a value provided for MethodOfMeasurement. Quanties shall
/// be never assigned to the IfcPlateType.
/// 
/// Qto_PlateBaseQuantities: base quantities for
/// all plate occurrences.
/// 
/// Containment Use Definitions
/// The IfcPlate, as any subtype of
/// IfcBuildingElement, may participate in two different
/// containment relationships. The first (and in most implementation
/// scenarios mandatory) relationship is the hierachical spatial
/// containment, the second relationship is the aggregation within
/// anÿelement assembly.
/// 
/// TheÿIfcPlate is places within the project spatial
/// hierarchy using the objectified relationship
/// IfcRelContainedInSpatialStructure, referring to it by its
/// inverse attribute SELF\IfcElement.ContainedInStructure.
/// Subtypes ofÿIfcSpatialStructureElement are valid spatial
/// containers, with IfcBuildingStorey being the default
/// container.
/// TheÿIfcPlate may be aggregated into an element
/// assembly using the objectified relationship
/// IfcRelAggregates, referring to it by its inverse attribute
/// SELF\IfcObjectDefinition.Decomposes. Any subtype of
/// IfcElement can be an element assembly, with
/// IfcElementAssembly as a special focus subtype. In this
/// case, no additional relationship to the spatial hierarchy shall
/// be given (i.e.ÿSELF\IfcElement.ContainedInStructure =
/// NIL), the relationship to the spatial container is handled by the
/// element assembly.
/// 
/// Geometry Use Definition
/// The geometric representation of IfcPlate is
/// given by the IfcProductDefinitionShape, allowing multiple
/// geometric representations. Included are:
/// Local Placement
/// The local placement for IfcPlate is defined in
/// its supertype IfcProduct. It is defined by the
/// IfcLocalPlacement, which defines the local coordinate
/// system that is referenced by all geometric representations.
/// 
/// The PlacementRelTo relationship of
/// IfcLocalPlacement shall point (if given) to the local
/// placement of the same IfcSpatialStructureElement, which is
/// used in the ContainedInStructure inverse attribute, or to
/// a spatial structure element at a higher level, referenced by
/// that.
/// 
/// If the IfcPlate is part of an assembly, the
/// PlacementRelTo relationship of IfcLocalPlacement
/// shall point to the local placement of the container element, e.g.
/// IfcElementAssembly,
/// 
/// If the relative placement is not used, the absolute placement
/// is defined within the world coordinate system.
/// 
/// Geometric Representation
/// Currently, the 'Surface',
/// 'FootPrint', 'Body', and 'Box'
/// representations are supported. The 'Box' representation includes
/// the representation type 'BoundingBox' and is explained at
/// IfcBuildingElement.
/// Surface Representation
/// The surfacic geometric representation of IfcPlate is
/// defined using the 'Surface' representation.
/// 
/// RepresentationIdentifier : 'Surface'
/// RepresentationType : 'Surface3D'
/// 
/// NOTE The 'Surface' can be used to define a
/// surfacic model of the building (e.g. for analytical purposes, or
/// for reduced Level of Detail representation).
/// Body Representation
/// The body representation of IfcPlate can be represented
/// using the representation types 'SweptSolid', 'Clipping',
/// 'MappedRepresentation', 'SurfaceModel', and 'Brep'. The
/// representation types 'SurfaceModel' and 'Brep' are explained at
/// IfcBuildingElement.
/// SweptSolid Representation Type
/// The following attribute values for the
/// IfcShapeRepresentation holding this geometric
/// representation shall be used:
/// If a corresponding material definition using
/// IfcMaterialLayerSetUsage can be assigned, the subtype
/// IfcPlateStandardCase shall be used.
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'SweptSolid'
/// 
/// The following additional constraints apply to the swept solid
/// representation:
/// 
/// Solid: IfcExtrudedAreaSolid is required,
/// Profile: IfcArbitraryClosedProfileDef,
/// IfcArbitraryProfileDefWithVoids, IfcRectangleProfileDef,
/// IfcCircleProfileDef, IfcEllipseProfileDef shall be
/// supported.
/// Extrusion: The profile can be extruded perpendicularly
/// or non-perpendicularly to the plane of the swept profile.
/// 
/// Clipping Representation Type
/// The following attribute values for the
/// IfcShapeRepresentation holding this geometric
/// representation shall be used:
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'Clipping'
/// 
/// MappedRepresentation Representation Type
/// The 'MappedRepresentation' shall be supported as it allows for
/// reusing the geometry definition of the member type at all
/// occurrences of the same type. The following attribute values for
/// the IfcShapeRepresentation holding this geometric
/// representation shall be used:
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'MappedRepresentation'
/// 
/// The same constraints, as given for the 'SweptSolid',
/// 'Clipping', 'SurfaceModel', and 'Brep' geometric representation,
/// shall apply to the MappedRepresentation of the
/// IfcRepresentationMap.
class IfcPlate : public IfcBuildingElement {
public:
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcBuildingElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcBuildingElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcBuildingElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPlate (IfcAbstractEntity* e);
    IfcPlate (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag);
    typedef IfcTemplatedEntityList< IfcPlate > list;
};
/// Definition of IAI: The railing is a frame assembly
/// adjacent to human circulation spaces and at some space boundaries
/// where it is used in lieu of walls or to compliment walls.
/// Designed to aid humans, either as an optional physical support,
/// or to prevent injury by falling.
/// HISTORY New Entity in
/// IFC Release 2.0
/// Type Use Definition
/// IfcRailing defines the occuurence of any railing,
/// common information about railing types (or styles) is handled by
/// IfcRailingType. The IfcRailingType (if present) may
/// establish the commonÿtype name, usage (or predefined) type,
/// common material, common set of properties and common shape
/// representations (using IfcRepresentationMap). The
/// IfcRailingType is attached using the
/// IfcRelDefinedByType.RelatingType objectified relationship
/// and is accessible by the inverse IsDefinedBy
/// attribute.
/// Material Use Definition
/// The material of the IfcRailing is defined by the
/// IfcMaterial and attached by the
/// IfcRelAssociatesMaterial.RelatingMaterial. It is
/// accessible by the inverse HasAssociations
/// relationship.
/// Material information can also be given at the
/// IfcRailingType, defining the common attribute data for all
/// occurrences of the same type.ÿIt is then accessible by the
/// inverse IsDefinedBy relationship pointing to
/// IfcRailingType.HasAssociations and via
/// IfcRelAssociatesMaterial.RelatingMaterial to
/// IfcMaterial. If both are given, then the material directly
/// assigned to IfcRailing overrides the material assigned to
/// IfcRailingType.
/// Property Set Use Definition
/// The property sets relating to the IfcRailing are
/// defined by the IfcPropertySet and attached by the
/// IfcRelDefinesByProperties relationship. It is accessible
/// by the inverse IsDefinedBy relationship. The following
/// property set definitions specific to the IfcRailing are
/// part of this IFC release:
/// 
/// Pset_RailingCommon: common property set for all
/// railing occurrences
/// 
/// Quantity Use Definition
/// The quantities relating to the IfcRailing are defined
/// by the IfcElementQuantity and attached by the
/// IfcRelDefinesByProperties relationship. It is accessible
/// by the inverse IsDefinedBy relationship. The following
/// base quantities are defined and should be exchanged with the
/// IfcElementQuantity.MethodOfMeasurement = 'BaseQuantities'.
/// Other quantities can be defined being subjected to local standard
/// of measurement with another string value assigned to
/// MethodOfMeasurement.
/// 
/// Qto_RailingBaseQuantities: base quantities
/// for all railing occurrences.
/// 
/// Containment Use Definition
/// The IfcRailing, as any subtype of
/// IfcBuildingElement, may participate in two different
/// containment relationships. The first (and in most implementation
/// scenarios mandatory) relationship is the hierachical spatial
/// containment, the second (optional) relationship is the
/// aggregation within anÿelement assembly.
/// 
/// The IfcRailing is places within the project spatial
/// hierarchy using the objectified relationship
/// IfcRelContainedInSpatialStructure, refering to it by its
/// inverse attribute SELF\IfcElement.ContainedInStructure.
/// Subtypes ofÿIfcSpatialStructureElement are valid spatial
/// containers, with IfcBuildingStorey being the default
/// container.
/// The IfcRailing may be aggregated into an element
/// assembly using the objectified relationship
/// IfcRelAggregates, refering to it by its inverse attribute
/// SELF\IfcObjectDefinition.Decomposes. Any subtype of
/// IfcElement can be an element assembly, with
/// IfcStair, or IfcRamp as a special focus subtypes.
/// In this case it should not be additionally contained in the
/// project spatial hierarchy,
/// i.e.ÿSELF\IfcElement.ContainedInStructure should be
/// NIL.
/// 
/// Geometry Use Definition
/// The geometric representation of IfcRailing is given by
/// the IfcProductDefinitionShape, allowing multiple geometric
/// representations. Included are:
/// Local placement
/// The local placement for IfcRailing is defined in its
/// supertype IfcProduct. It is defined by the
/// IfcLocalPlacement, which defines the local coordinate
/// system that is referenced by all geometric representations.
/// 
/// The PlacementRelTo relationship of
/// IfcLocalPlacement shall point (if given) to the same
/// IfcSpatialStructureElement that is used in the
/// ContainedInStructure inverse attribute or to a referenced
/// spatial structure element at a higher level
/// If the IfcRailing, however, is used by an
/// IfcStair or IfcRamp, and this container class
/// defines its own local placement, then the PlacementRelTo
/// relationship of IfcLocalPlacement shall point to the local
/// placement of IfcStair or IfcRamp.
/// If the relative placement is not used, the absolute placement
/// is defined within the world coordinate system.
/// 
/// Geometric Representation
/// Currently, the 'Axis', 'Body',
/// and 'Box' representations are supported. The 'Box' representation
/// includes the representation type 'BoundingBox' and is explained
/// at IfcBuildingElement.
/// Axis Representation
/// The axis geometric representation of IfcRailing is
/// defined using the 'Axis' representation. The following attribute
/// values for the IfcShapeRepresentation holding this
/// geometric representation shall be used:
/// 
/// RepresentationIdentifier : 'Axis'
/// RepresentationType : 'Curve2D', 'Curve3D'
/// 
/// Body Representation
/// Currently the use of 'SurfaceModel', 'Brep' and
/// 'MappedRepresentation' representations of IfcRailing are
/// supported. The conventions to use these representations are given
/// at the level of the supertype, IfcBuildingElement. No
/// further constraints or provisions on how to use the
/// representation types are defined for IfcRailing.
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'SurfaceModel', 'Brep',
/// 'MappedRepresentation'
class IfcRailing : public IfcBuildingElement {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcRailing
    bool hasPredefinedType() const;
    /// Predefined generic types for a railing that are specified in an enumeration. There may be a property set given for the predefined types.
    ///   NOTE: The use of the predefined type directly at the occurrence object level of IfcRailing is only permitted, if no type object IfcRailingType is assigned.
    ///   IFC2x PLATFORM CHANGE: The attribute has been changed into an OPTIONAL attribute.
    IfcRailingTypeEnum::IfcRailingTypeEnum PredefinedType() const;
    void setPredefinedType(IfcRailingTypeEnum::IfcRailingTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcBuildingElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcRailingTypeEnum; } return IfcBuildingElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "PredefinedType"; } return IfcBuildingElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRailing (IfcAbstractEntity* e);
    IfcRailing (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcRailingTypeEnum::IfcRailingTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcRailing > list;
};
/// Definition from ISO 6707-1:1989: Inclined way or floor
/// joining two surfaces at different levels.
/// A ramp is a vertical passageway which
/// provides a human circulation link between one floor level and
/// another floor level at a different elevation. It may include a
/// landing as an intermediate floor slab. A ramp normally does not
/// include steps (stepped ramps are out of scope for this IFC
/// Release).
/// The ramp is a container entity that aggregates all components
/// of the ramp, it represents. The aggregation is handled via the
/// IfcRelAggregates relationship, relating an IfcRamp
/// with the related flights (IfcRampFlight) and landings
/// (IfcSlab with type 'Landing'). Railings belonging to the
/// ramp may be included into the aggregation as
/// IfcRailing.
/// 
/// HISTORY New Entity in IFC Release 2.0.
/// IFC2x4 CHANGE Attribute ShapeType renamed to PredefinedType
/// 
/// Type Use Definition
/// IfcRamp defines the occuurence of any ramp, common
/// information about ramp types (or styles) is handled by
/// IfcRampType. The IfcRampType (if present) may
/// establish the commonÿtype name, usage (or predefined) type,
/// common material, common set of properties and common shape
/// representations (using IfcRepresentationMap). The
/// IfcRampType is attached using the
/// IfcRelDefinedByType.RelatingType objectified relationship
/// and is accessible by the inverse IsDefinedBy
/// attribute.
/// NOTE Since the IfcRamp might be
/// represented as an aggregate of parts, e.g. represented by
/// IfcRampFlight, or IfcSlab, these individual parts
/// may have type information attached (represented e.g. by
/// IfcRampFlightType, or
/// IfcSlabType).
/// Material Use Definition
/// The material of the IfcRamp is defined by the
/// IfcMaterial and attached by the
/// IfcRelAssociatesMaterial.RelatingMaterial. It is
/// accessible by the inverse HasAssociations
/// relationship.
/// Material information can also be given at the
/// IfcRampType, defining the common attribute data for all
/// occurrences of the same type.ÿIt is then accessible by the
/// inverse IsDefinedBy relationship pointing to
/// IfcRampType.HasAssociations and via
/// IfcRelAssociatesMaterial.RelatingMaterial to
/// IfcMaterial. If both are given, then the material directly
/// assigned to IfcRamp overrides the material assigned to
/// IfcRampType.
/// Property Set Use Definition:
/// The property sets relating to the IfcRamp are defined
/// by the IfcPropertySet and attached by the
/// IfcRelDefinesByProperties relationship. It is accessible
/// by the inverse IsDefinedBy relationship. The following
/// property set definitions specific to the IfcRamp are part
/// of this IFC release:
/// 
/// Pset_RampCommon: common property set for all
/// ramp occurrences
/// 
/// Quantity Use Definition
/// The quantities relating to the IfcRamp are defined by
/// the IfcElementQuantity and attached by the
/// IfcRelDefinesByProperties relationship. It is accessible
/// by the inverse IsDefinedBy relationship. The following
/// base quantities are defined and should be exchanged with the
/// IfcElementQuantity.MethodOfMeasurement = 'BaseQuantities'.
/// Other quantities can be defined being subjected to local standard
/// of measurement with another string value assigned to Name
/// and a value provided for MethodOfMeasurement. Quantities
/// shall never be assigned to the IfcRampType.
/// The individual quantities shall only be given at
/// IfcRamp, it is not decomposed into the individual parts,
/// IfcRampFlight and IfcSlab.
/// 
/// Qto_RampBaseQuantities: base quantities for
/// all ramp occurrences.
/// 
/// Geometry Use Definitions:
/// The geometric representation of IfcRamp is given by the
/// IfcProductDefinitionShape, allowing multiple geometric
/// representations. Independent geometric representations should
/// only be used when the IfcRamp is not defined as an
/// aggregate. If defined as an aggregate, the geometric
/// representation is the sum of the representation of the components
/// within the aggregate.
/// Local placement
/// The local placement for IfcRamp is defined in its
/// supertype IfcProduct. It is defined by the
/// IfcLocalPlacement, which defines the local coordinate
/// system that is referenced by all geometric representations.
/// 
/// The PlacementRelTo relationship of
/// IfcLocalPlacement shall point (if given) to the local
/// placement of the same IfcSpatialStructureElement that is
/// used in the ContainedInStructure inverse attribute or to a
/// referenced spatial structure element at a higher level.
/// If the relative placement is not used, the absolute placement
/// is defined within the world coordinate system.
/// 
/// If the LocalPlacement is given for the IfcRamp,
/// then all components, which are aggregated to the ramp should use
/// this placement as their relative placement.
/// Geometric representations
/// Geometric representation by own shape
/// representation
/// If the IfcRamp has no components defined (empty set of
/// SELF\IfcProduct.IsDecomposedBy) then the IfcRamp
/// may be represented by an own IfcShapeRepresentation with
/// the following values:
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'SweptSolid', 'Clipping',
/// 'SurfaceModel', or 'Brep'
/// 
/// The conventions to use these representations are provided at
/// IfcBuildingElement. No further constraints or provisions
/// on how to use the representation types are defined for
/// IfcRamp.
/// Geometric representation by aggregated elements
/// If the IfcRamp has components (referenced by
/// SELF\IfcProduct.IsDecomposedBy) then no independent
/// geometric representation shall be defined for the IfcRamp.
/// The IfcRamp is then geometrically represented by the
/// geometric representation of its components. The components are
/// accessed via
/// SELF\IfcProduct.IsDecomposedBy[1].RelatedObjects.
/// 
/// Figure 111 illustrates IfcRamp defining the local placement for all components.
/// 
/// Figure 111 — Ramp placement
class IfcRamp : public IfcBuildingElement {
public:
    IfcRampTypeEnum::IfcRampTypeEnum ShapeType() const;
    void setShapeType(IfcRampTypeEnum::IfcRampTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcBuildingElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcRampTypeEnum; } return IfcBuildingElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "ShapeType"; } return IfcBuildingElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRamp (IfcAbstractEntity* e);
    IfcRamp (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, IfcRampTypeEnum::IfcRampTypeEnum v9_ShapeType);
    typedef IfcTemplatedEntityList< IfcRamp > list;
};
/// A ramp is an inclined slab segment, normally
/// providing a human circulation link between two landings, floors or
/// slabs at different elevations.
/// An IfcRampFlight is normally aggregated by an
/// IfcRamp through the IfcRelAggregates relationship,
/// the ramp flight is then included in the set of
/// IfcRelAggregates.RelatedObjects. An IfcRampFlight
/// normally connects the floor slab of zero to two different storeys
/// (or partial storeys or landings) within a building. The connection
/// relationship between the IfcRampFlight and the
/// IfcSlab is expressed using the IfcRelConnectsElements
/// relationship.
/// HISTORY New Entity in IFC Release 2.0.
/// 
/// Type Use Definition
/// IfcRampFlight defines the occurrence of any ramp flight,
/// common information about ramp flight types (or styles) is handled
/// by IfcRampFlightType. The IfcRampFlightType (if
/// present) may establish the common type name, usage (or
/// predefined) type, common material layer set, common set of
/// properties and common shape representations (using
/// IfcRepresentationMap). The IfcRampFlightType is
/// attached using the IfcRelDefinedByType.RelatingType
/// objectified relationship and is accessible by the inverse
/// IsDefinedBy attribute.
/// Material Use Definition
/// The material of the IfcRampFlight is defined by the
/// IfcMaterial and attached by the
/// IfcRelAssociatesMaterial.RelatingMaterial. It is
/// accessible by the inverse HasAssociations relationship.
/// Property Set Use Definition:
/// The property sets relating to the IfcRampFlight are
/// defined by the IfcPropertySet and attached by the
/// IfcRelDefinesByProperties relationship. It is accessible by
/// the inverse IsDefinedBy relationship. The following property
/// set definitions specific to the IfcRampFlight are part of
/// this IFC release:
/// 
/// Pset_RampFlightCommon: common property set for all
/// ramp flight occurrences
/// 
/// Quantity Use Definition
/// The quantities relating to the IfcRampFlight are defined
/// by the IfcElementQuantity and attached by the
/// IfcRelDefinesByProperties relationship. It is accessible by
/// the inverse IsDefinedBy relationship. The following base
/// quantities are defined and should be exchanged with the
/// IfcElementQuantity.Name = 'BaseQuantities'. Other quantities
/// can be defined being subjected to local standard of measurement
/// with another string value assigned to Name and a value
/// provided for MethodOfMeasurement. Quantities shall never be
/// assigned to the IfcRampFlightType.
/// 
/// Qto_RampFlightBaseQuantities: base quantities
/// for all ramp flight occurrences.
/// 
/// Containment Use Definition
/// The IfcRampFlight, as any subtype of
/// IfcBuildingElement, may participate in two different
/// containment relationships. The first relationship is the
/// hierachical spatial containment, the second relationship is the
/// aggregation within an element assembly.
/// 
/// The IfcRampFlight is placed within the project spatial
/// hierarchy using the objectified relationship
/// IfcRelContainedInSpatialStructure, refering to it by its
/// inverse attribute SELF\IfcElement.ContainedInStructure.
/// Subtypes of IfcSpatialStructureElement are valid
/// spatial containers, with IfcBuildingStorey being the default
/// container.
/// The IfcRampFlight may be aggregated into an element
/// assembly using the objectified relationship
/// IfcRelAggregates, refering to it by its inverse attribute
/// SELF\IfcObjectDefinition.Decomposes. Any subtype of
/// IfcElement can be an element assembly, with IfcRamp
/// as a special focus subtype. In this case it should not be
/// additionally contained in the project spatial hierarchy,
/// i.e. SELF\IfcElement.ContainedInStructure should be
/// NIL.
/// 
/// Geometry Use Definition
/// The geometric representation of IfcRampFlight is given by
/// the IfcProductDefinitionShape, allowing multiple geometric
/// representations. Included are:
/// Local placement
/// The local placement for IfcRampFlight is defined in its
/// supertype IfcProduct. It is defined by the
/// IfcLocalPlacement, which defines the local coordinate system
/// that is referenced by all geometric representations.
/// 
/// The PlacementRelTo relationship of
/// IfcLocalPlacement shall point (if given) to the local
/// placement of the same IfcSpatialStructureElement that is
/// used in the ContainedInStructure inverse attribute or to a
/// referenced spatial structure element at a higher level.
/// If the IfcRampFlight, however, is used by an
/// IfcRamp, and this container class defines its own local
/// placement, then the PlacementRelTo relationship of
/// IfcLocalPlacement shall point to the local placement of the
/// IfcRamp.
/// 
/// Geometric Representations
/// Currently, the 'Axis', 'FootPrint', 'Body', and 'Box'
/// representations are supported. The 'Box' representation includes
/// the representation type 'BoundingBox' and is explained at
/// IfcBuildingElement.
/// 
/// Axis: A two-dimensional open curve
/// IfcBoundedCurve defining the walking line for the ramp
/// flight.
/// FootPrint: A geometric curve set defining the footing
/// print, including the boundary of the ramp flight.
/// Body: A solid representation defining the 3D shape of
/// the ramp flight
/// 
/// Axis Representation
/// The walking line is represented by a two-dimensional open curve
/// as the axis. The curve is directed into the upward direction
/// (direction has to be interpreted as specified at the subtypes of
/// IfcCurve). The following attribute values for the
/// IfcShapeRepresentation holding this geometric representation
/// shall be used:
/// 
/// RepresentationIdentifier : 'Axis'
/// RepresentationType : 'Curve2D'
/// 
/// Figure 112 illustrates the axis representation which has the following constraints:
/// 
/// In case of straight flights the curve shall be a single item of type IfcPolyline.
/// In case of winding flights the curve shall be a single item of type IfcCompositeCurve.
/// In case of a curved flight or a spiral flight the curve shall be a single item of type IfcTrimmedCurve.
/// 
/// Figure 112 — Ramp flight axis
/// 
/// FootPrint Representation
/// The flight foot print, including the flight boundary is represented by a two-dimensional geometric curve set. The following attribute values for the IfcShapeRepresentation holding this geometric representation shall be used:
/// 
/// RepresentationIdentifier : 'FootPrint'
/// RepresentationType : 'GeometricCurveSet'
/// 
/// Figure 113 illustrates the footprint representation which has the following constraints:
/// 
/// In case of straight flights the curve set shall consist of a single item of type IfcPolyline.
/// In case of winding flights or curved flights the curve set shall consists of a single item of type
/// IfcCompositeCurve.
/// In case of a spiral flight the curve set shall consists of a single item of type IfcConic or
/// IfcPolyline.
/// 
/// Figure 113 — Ramp flight footprint
/// 
/// Body Representation
/// The body representation of IfcRampFlight can be
/// represented using the representation types 'SweptSolid',
/// 'SurfaceModel', 'Brep', and 'MappedRepresentation'. The general
/// usage of representation is are explained at
/// IfcBuildingElement. For further constraints on the
/// 'SweptSolid' the representation types see below..
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'SweptSolid', 'SurfaceModel',
/// 'Brep', 'MappedRepresentation'
/// 
/// SweptSolid Representation Type
/// The 'SweptSolid' representation type is a valid body
/// representation of IfcRampFlight is defined using the swept
/// area geometry. The following attribute values for the
/// IfcShapeRepresentation holding this geometric representation
/// shall be used:
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'SweptSolid'
/// 
/// The following additional constraints apply to the 'SweptSolid'
/// representation type:
/// 
/// Solid: IfcExtrudedAreaSolid is required,
/// Profile: IfcRectangleProfileDef and
/// IfcArbitraryClosedProfileDef shall be supported.
/// Extrusion: The profile shall be extruded in any
/// direction relative to the XY plane of the position coordinate
/// system of the IfcExtrudedAreaSolid. Therefore
/// non-perpendicular sweep operation has to be supported. It might be
/// further constrained to be in the direction of the global z-axis in
/// implementers agreements.
/// 
/// Figure 114 illustrates the body representation.
/// 
/// Figure 114 — Ramp flight body
class IfcRampFlight : public IfcBuildingElement {
public:
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcBuildingElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcBuildingElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcBuildingElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRampFlight (IfcAbstractEntity* e);
    IfcRampFlight (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag);
    typedef IfcTemplatedEntityList< IfcRampFlight > list;
};

class IfcRationalBezierCurve : public IfcBezierCurve {
public:
    std::vector< double > /*[2:?]*/ WeightsData() const;
    void setWeightsData(std::vector< double > /*[2:?]*/ v);
    virtual unsigned int getArgumentCount() const { return 6; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 5: return IfcUtil::Argument_AGGREGATE_OF_DOUBLE; } return IfcBezierCurve::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 5: return Type::UNDEFINED; } return IfcBezierCurve::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 5: return "WeightsData"; } return IfcBezierCurve::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRationalBezierCurve (IfcAbstractEntity* e);
    IfcRationalBezierCurve (int v1_Degree, IfcTemplatedEntityList< IfcCartesianPoint >::ptr v2_ControlPointsList, IfcBSplineCurveForm::IfcBSplineCurveForm v3_CurveForm, bool v4_ClosedCurve, bool v5_SelfIntersect, std::vector< double > /*[2:?]*/ v6_WeightsData);
    typedef IfcTemplatedEntityList< IfcRationalBezierCurve > list;
};
/// Definition from IAI: Bars, wires, strands, meshes, tendons, and other components embedded in concrete in such a manner that the reinforcement and the concrete act together in resisting forces.
/// 
/// HISTORY New entity in IFC Release 2x2
/// 
/// IFC 2x4 CHANGE Entity made non-abstract.
/// Subtypes IfcTendon and IfcTendonAnchor removed.
/// Attribute SteelGrade removed.
/// Attributes PredefinedType and Role added.
class IfcReinforcingElement : public IfcBuildingElementComponent {
public:
    /// Whether the optional attribute SteelGrade is defined for this IfcReinforcingElement
    bool hasSteelGrade() const;
    std::string SteelGrade() const;
    void setSteelGrade(std::string v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_STRING; } return IfcBuildingElementComponent::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcLabel; } return IfcBuildingElementComponent::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "SteelGrade"; } return IfcBuildingElementComponent::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcReinforcingElement (IfcAbstractEntity* e);
    IfcReinforcingElement (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_SteelGrade);
    typedef IfcTemplatedEntityList< IfcReinforcingElement > list;
};
/// Definition from IAI: A series of longitudinal and transverse wires or bars of various gauges, arranged at right angles to each other and welded at all points of intersection; usually used for concrete slab reinforcement. Also known as welded wire fabric.
/// 
/// HISTORY New entity in IFC Release 2x2
/// 
/// IFC 2x4 CHANGE All attributes removed; information now provided by IfcReinforcingMeshType.
/// 
/// Geometry Use Definition
/// 
/// The geometric representation of IfcReinforcingBar is given by the IfcProductDefinitionShape,
/// allowing multiple geometric representations. Included are:
/// 
/// Local Placement
/// The use of local placement is defined at the supertype IfcElementComponent.
/// 
/// Multiple Mapped Representation
/// See supertype IfcElementComponent.  This method of representation allows for several meshes
/// represented by a single instance of IfcReinforcingMesh.
/// 
/// An IfcElementQuantity,
/// attached via IfcRelDefinesByProperties, should contain an IfcQuantityCount named 'Count'
/// with the number of meshes represented by this instance.
/// 
/// Simplified Geometric Representation
/// Simplified geometric representations may be used based on local agreements.
class IfcReinforcingMesh : public IfcReinforcingElement {
public:
    /// Whether the optional attribute MeshLength is defined for this IfcReinforcingMesh
    bool hasMeshLength() const;
    double MeshLength() const;
    void setMeshLength(double v);
    /// Whether the optional attribute MeshWidth is defined for this IfcReinforcingMesh
    bool hasMeshWidth() const;
    double MeshWidth() const;
    void setMeshWidth(double v);
    double LongitudinalBarNominalDiameter() const;
    void setLongitudinalBarNominalDiameter(double v);
    double TransverseBarNominalDiameter() const;
    void setTransverseBarNominalDiameter(double v);
    double LongitudinalBarCrossSectionArea() const;
    void setLongitudinalBarCrossSectionArea(double v);
    double TransverseBarCrossSectionArea() const;
    void setTransverseBarCrossSectionArea(double v);
    double LongitudinalBarSpacing() const;
    void setLongitudinalBarSpacing(double v);
    double TransverseBarSpacing() const;
    void setTransverseBarSpacing(double v);
    virtual unsigned int getArgumentCount() const { return 17; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_DOUBLE; case 10: return IfcUtil::Argument_DOUBLE; case 11: return IfcUtil::Argument_DOUBLE; case 12: return IfcUtil::Argument_DOUBLE; case 13: return IfcUtil::Argument_DOUBLE; case 14: return IfcUtil::Argument_DOUBLE; case 15: return IfcUtil::Argument_DOUBLE; case 16: return IfcUtil::Argument_DOUBLE; } return IfcReinforcingElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcPositiveLengthMeasure; case 10: return Type::IfcPositiveLengthMeasure; case 11: return Type::IfcPositiveLengthMeasure; case 12: return Type::IfcPositiveLengthMeasure; case 13: return Type::IfcAreaMeasure; case 14: return Type::IfcAreaMeasure; case 15: return Type::IfcPositiveLengthMeasure; case 16: return Type::IfcPositiveLengthMeasure; } return IfcReinforcingElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "MeshLength"; case 10: return "MeshWidth"; case 11: return "LongitudinalBarNominalDiameter"; case 12: return "TransverseBarNominalDiameter"; case 13: return "LongitudinalBarCrossSectionArea"; case 14: return "TransverseBarCrossSectionArea"; case 15: return "LongitudinalBarSpacing"; case 16: return "TransverseBarSpacing"; } return IfcReinforcingElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcReinforcingMesh (IfcAbstractEntity* e);
    IfcReinforcingMesh (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_SteelGrade, boost::optional< double > v10_MeshLength, boost::optional< double > v11_MeshWidth, double v12_LongitudinalBarNominalDiameter, double v13_TransverseBarNominalDiameter, double v14_LongitudinalBarCrossSectionArea, double v15_TransverseBarCrossSectionArea, double v16_LongitudinalBarSpacing, double v17_TransverseBarSpacing);
    typedef IfcTemplatedEntityList< IfcReinforcingMesh > list;
};
/// Definition from ISO 6707-1:1989: Construction enclosing the building from above.
/// The IfcRoof is a description of the total roof. It acts as a container entity, that aggregates all components of the roof, it represents. The aggregation is handled via the IfcRelAggregates relationship, relating an IfcRoof with the related roof elements, like slabs (represented by IfcSlab), rafters and purlins (represented by IfcBeam), or other included roofs, such as dormers (represented by IfcRoof).
/// 
/// HISTORY New Entity in IFC Release 2.0.
/// IFC2x4 CHANGE Attribute ShapeType renamed to PredefinedType.
/// 
/// Property Set Use Definition:
/// The property sets relating to the IfcRoof are defined
/// by the IfcPropertySet and attached by the
/// IfcRelDefinesByProperties relationship. It is accessible
/// by the inverse IsDefinedBy relationship. The following
/// property set definitions specific to the IfcRoof are part
/// of this IFC release:
/// 
/// Pset_RoofCommon: common property set for all
/// roof occurrences
/// 
/// The quantities relating to the IfcRoof are defined by
/// the IfcElementQuantity and attached by the
/// IfcRelDefinesByProperties relationship. It is accessible
/// by the inverse IsDefinedBy relationship. The following
/// base quantities are defined and should be exchanged with the
/// IfcElementQuantity.MethodOfMeasurement = 'BaseQuantities'.
/// Other quantities can be defined being subjected to local standard
/// of measurement with another string value assigned to Name
/// and a value provided for MethodOfMeasurement. Quantities
/// shall never be assigned to the IfcRoofType.
/// The individual quantities shall only be given at
/// IfcRoof, it is not decomposed into the individual parts,
/// e.g. IfcSlab as roof slabs.
/// 
/// Qto_RoofBaseQuantities: base quantities for
/// all roof occurrences.
/// 
/// Containment Use Definition
/// The IfcRoof, as any subtype of
/// IfcBuildingElement, may participate in two different
/// containment relationships. The first (and in most implementation
/// scenarios mandatory) relationship is the hierachical spatial
/// containment, the second (optional) relationship is the
/// aggregation within an element assembly.
/// 
/// The IfcRoof is placed within the project spatial
/// hierarchy using the objectified relationship
/// IfcRelContainedInSpatialStructure, referring to it by its
/// inverse attribute SELF\IfcElement.ContainedInStructure.
/// Subtypes of IfcSpatialStructureElement are valid spatial
/// containers, with IfcBuildingStorey being the default
/// container.
/// The IfcRoof may be aggregated into an element assembly
/// using the objectified relationship IfcRelAggregates,
/// referring to it by its inverse attribute
/// SELF\IfcObjectDefinition.Decomposes. Any subtype of
/// IfcElement can be an element assembly, with
/// IfcRoof, the overall roof, as a special focus subtype. In
/// this case it should not be additionally contained in the project
/// spatial hierarchy, i.e.
/// SELF\IfcElement.ContainedInStructure should be NIL.
/// 
/// NOTEÿ A roof contained in another roof could
/// be the representation of a dormer.
/// The IfcRoof may be an aggregate i.e. being composed by
/// other elements and acting as an assembly using the objectified
/// relationship IfcRelAggregates, referring to it by its
/// inverse attribute SELF\IfcObjectDefinition.IsDecomposedBy.
/// Components of a roof are described by instances of subtypes of
/// IfcBuildingElement (e.g. IfcSlab, IfcBeam,
/// IfcColumn, IfcBuildingElementPart) that are
/// aggregated to form a complex roof. In this case, the contained
/// elements should not be additionally contained in the project
/// spatial hierarchy, i.e. the inverse attribute
/// SELF\IfcElement.ContainedInStructure of the aggregated
/// elements should be NIL.
/// 
/// Figure 118 illustrates roof containment, where only the IfcRoof as the aggregate
/// is included in the spatial structure.
/// 
/// Figure 118 — Roof containment
/// 
/// Geometry Use Definitions:
/// The geometric representation of IfcRoof is given by the
/// IfcProductDefinitionShape, allowing multiple geometric
/// representations. Independent geometric representations should
/// only be used when the IfcRoof is not defined as an
/// aggregate. If defined as an aggregate, the geometric
/// representation is the sum of the representation of the components
/// within the aggregate.
/// NOTEÿ View definitions and implementer
/// agreements may restrict the IfcRoof to not have an
/// independent geometry, but to always require aggregated elements
/// to represent the shape of the roof.
/// NOTE If the IfcRoof has aggregated elements to
/// represent the shape of the roof, then only those elements shall
/// have openings, not the IfcRoof
/// itself.
/// Local Position
/// The local placement for IfcRoof is defined in its
/// supertype IfcProduct. It is defined by the
/// IfcLocalPlacement, which defines the local coordinate
/// system that is referenced by all geometric representations.
/// 
/// The PlacementRelTo relationship of
/// IfcLocalPlacement shall point (if given) to the local
/// placement of the same IfcSpatialStructureElement that is
/// used in the ContainedInStructure inverse attribute or to a
/// referenced spatial structure element at a higher level..
/// If the relative placement is not used, the absolute placement
/// is defined within the world coordinate system.
/// 
/// If the LocalPlacement is given for the IfcRoof,
/// then all components, which are aggregated to the roof should use
/// this placement as their relative placement.
/// Geometric Representation
/// The IfcRoof may have an independent geometric representation
/// or may be an aggregate with elements holding the geometric
/// representation of the roof.
/// Geometric representation by own shape
/// representation
/// If the IfcRoof has no components defined (empty set of
/// SELF\IfcObject.IsDecomposedBy) then the IfcRoof may
/// be represented by an independent IfcShapeRepresentation.
/// The following attribute values for the IfcShapeRepresentation
/// holding this geometric representation shall be used:
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'SweptSolid', 'Clipping',
/// 'SurfaceModel', or 'Brep'
/// 
/// Geometric representation by aggregated elements
/// If the IfcRoof has components (referenced by
/// SELF\IfcObject.IsDecomposedBy) then no independent
/// geometric representation shall defined for the IfcRoof.
/// The IfcRoof is then geometrically represented by the
/// geometric representation of its components. The components are
/// accessed via
/// SELF\IfcObject.IsDecomposedBy[1].RelatedObjects. The
/// geometric representations that are supported for the aggregated
/// elements are defined with each element. See geometric use
/// definition for IfcSlab, IfcBeam, IfcColumn,
/// IfcBuildingElementPart and other subtypes of
/// IfcBuildingElement.
/// 
/// Figure 119 illustrates roof placement, with an IfcRoof defining the local placement for all aggregated elements.
/// 
/// Figure 119 — Roof placement
class IfcRoof : public IfcBuildingElement {
public:
    IfcRoofTypeEnum::IfcRoofTypeEnum ShapeType() const;
    void setShapeType(IfcRoofTypeEnum::IfcRoofTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcBuildingElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcRoofTypeEnum; } return IfcBuildingElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "ShapeType"; } return IfcBuildingElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRoof (IfcAbstractEntity* e);
    IfcRoof (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, IfcRoofTypeEnum::IfcRoofTypeEnum v9_ShapeType);
    typedef IfcTemplatedEntityList< IfcRoof > list;
};

class IfcRoundedEdgeFeature : public IfcEdgeFeature {
public:
    /// Whether the optional attribute Radius is defined for this IfcRoundedEdgeFeature
    bool hasRadius() const;
    double Radius() const;
    void setRadius(double v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_DOUBLE; } return IfcEdgeFeature::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcPositiveLengthMeasure; } return IfcEdgeFeature::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "Radius"; } return IfcEdgeFeature::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRoundedEdgeFeature (IfcAbstractEntity* e);
    IfcRoundedEdgeFeature (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< double > v9_FeatureLength, boost::optional< double > v10_Radius);
    typedef IfcTemplatedEntityList< IfcRoundedEdgeFeature > list;
};
/// The distribution control element type IfcSensorType defines commonly shared information for occurrences of sensors.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a sensor specification (i.e. the specific product information, that is common to all occurrences of that product type).  Sensor types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcSensorType are represented by instances of IfcSensor. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcDistributionControlElementType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_SensorTypeCommon 
/// 
/// The following property set definitions are applicable to this entity according to the PredefinedType attribute:  
/// Pset_SensorTypeConductanceSensor (CONDUCTANCESENSOR) 
/// Pset_SensorTypeContactSensor (CONTACTSENSOR) 
/// Pset_SensorTypeFireSensor (FIRESENSOR) 
/// Pset_SensorTypeFlowSensor (FLOWSENSOR) 
/// Pset_SensorTypeGasSensor (GASSENSOR) 
/// Pset_SensorTypeHeatSensor (HEATSENSOR) 
/// Pset_SensorTypeHumiditySensor (HUMIDITYSENSOR) 
/// Pset_SensorTypeIonConcentrationSensor (IONCONCENTRATIONSENSOR) 
/// Pset_SensorTypeLevelSensor (LEVELSENSOR) 
/// Pset_SensorTypeLightSensor (LIGHTSENSOR) 
/// Pset_SensorTypeMoistureSensor (MOISTURESENSOR) 
/// Pset_SensorTypeMovementSensor (MOVEMENTSENSOR) 
/// Pset_SensorTypePHSensor (PHSENSOR) 
/// Pset_SensorTypePressureSensor (PRESSURESENSOR) 
/// Pset_SensorTypeRadiationSensor (RADIATIONSENSOR) 
/// Pset_SensorTypeRadioactivitySensor (RADIOACTIVITYSENSOR) 
/// Pset_SensorTypeSmokeSensor (SMOKESENSOR) 
/// Pset_SensorTypeSoundSensor (SOUNDSENSOR) 
/// Pset_SensorTypeTemperatureSensor (TEMPERATURESENSOR) 
/// Pset_SensorTypeWindSensor (WINDSENSOR) 
/// 
/// Material Use Definition 
/// The material of the IfcSensorType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Casing': Material from which the casing is constructed. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcSensorType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcSensor for standard port definitions.
class IfcSensorType : public IfcDistributionControlElementType {
public:
    /// Identifies the predefined types of sensor from which the type required may be set.
    IfcSensorTypeEnum::IfcSensorTypeEnum PredefinedType() const;
    void setPredefinedType(IfcSensorTypeEnum::IfcSensorTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcDistributionControlElementType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcSensorTypeEnum; } return IfcDistributionControlElementType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcDistributionControlElementType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcSensorType (IfcAbstractEntity* e);
    IfcSensorType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcSensorTypeEnum::IfcSensorTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcSensorType > list;
};
/// A slab is a component of the
/// construction that normally encloses a space vertically. The slab
/// may provide the lower support (floor) or upper construction (roof
/// slab) in any space in a building. It shall be noted, that only
/// the core or constructional part of this construction is
/// considered to be a slap. The upper finish (flooring, roofing) and
/// the lower finish (ceiling, suspended ceiling) are considered to
/// be coverings. A special type of slab is the landing, described as
/// a floor section to which one or more stair flights or ramp
/// flights connect.
/// NOTE There is a representation of slabs for
/// structural analysis provided by a proper subtype of
/// IfcStructuralMember being part of the
/// IfcStructuralAnalysisModel.
/// 
/// NOTE ÿAn arbitrary planar element to which this semantic
/// information is not applicable or irrelevant shall be modeled as
/// IfcPlate.
/// A slab may have openings, such as floor openings, or recesses.
/// They are defined by an IfcOpeningElement attached to the
/// slab using the inverse relationship HasOpenings pointing
/// to IfcRelVoidsElement.
/// The IFC specification provides three entities for slab
/// occurrences:
/// 
/// IfcSlabStandardCase used for all occurrences of slabs,
/// that are prismatic and where the thickness parameter can be fully
/// described by the IfcMaterialLayerSetUsage. These slabs are
/// always represented geometrically by a 'SweptSolid' geometry (or
/// by a 'Clipping' geometry based on 'SweptSolid'), if a 3D
/// geometric representation is assigned. In addition they have to
/// have a corresponding IfcMaterialLayerSetUsage
/// assigned.
/// IfcSlabElementedCase used for occurrences of slabs
/// which are aggregated from subordinate elements, following
/// specific decomposition rules expressed by the mandatory use of
/// IfcRelAggregates relationship.
/// IfcSlab used for all other occurrences of slabs,
/// particularly for slabs with changing thickness, or slabs with non
/// planar surfaces, and slabs having only 'SweptSolid' or 'Brep'
/// geometry.
/// 
/// HISTORY New entity in IFC Release 2.0, it is a merger of the two previous entities
/// IfcFloor, IfcRoofSlab, introduced in IFC Release 1.0
/// 
/// Type Use Definition
/// The IfcSlab defines the occurrence of any slab, common
/// information about slab types (or styles) is handled by
/// IfcSlabType. The IfcSlabType (if present) may
/// establish the commonÿtype name, usage (or predefined) type,
/// common set of properties, common material layer set, and common
/// shape representations (using IfcRepresentationMap). The
/// IfcSlabType is attached using the
/// IfcRelDefinedByType.RelatingType objectified relationship
/// and is accessible by the inverse IsTypedBy attribute.
/// If no IfcSlabType is attachedÿ(i.e. if only occurrence
/// information is given) the PredefinedType should be
/// provided. Values of the enumeration are .FLOOR. (the default),
/// .ROOF., .LANDING., .BASESLAB. If set to .USERDEFINED. a user
/// defined value can be provided by the ObjectType
/// attribute.
/// Material Use Definition
/// The material of the IfcSlab is defined by
/// IfcMaterialLayerSet, or IfcMaterial and attached by
/// the IfcRelAssociatesMaterial.RelatingMaterial. It
/// is accessible by the inverse HasAssociations relationship.
/// Multi-layer slabs can be represented by referring to several
/// IfcMaterialLayer's within the
/// IfcMaterialLayerSet.
/// NOTE It is illegal to assign an
/// IfcMaterialLayerSetUsage to an IfcSlab. Only the
/// subtype IfcSlabStandardCase supports this
/// concept.
/// NOTE Prismatic slabs, where the main face of
/// the slab is extruded along the slab thickness, are exchanged as
/// IfcSlabStandardCase, The material for
/// IfcSlabStandardCase shall be defined
/// byÿIfcMaterialLayerSetUsage. Multi-layer slabs can be
/// represented by referring to several IfcMaterialLayer's
/// within the IfcMaterialLayerSet.ÿ
/// Material information can also be given at the
/// IfcSlabType, defining the common attribute data for all
/// occurrences of the same type.ÿIt is then accessible by the
/// inverse IsTypedBy
/// relationship pointing to IfcSlabType.HasAssociations and
/// via IfcRelAssociatesMaterial.RelatingMaterial.
/// Property Set Use Definition:
/// The property sets relating to the IfcSlab are defined
/// by the IfcPropertySet and attached by the
/// IfcRelDefinesByProperties relationship. It is accessible
/// by the inverse IsDefinedBy relationship. The following
/// property set definitions specific to the IfcSlab are part
/// of this IFC release:
/// 
/// Pset_SlabCommon: common property set for all
/// slab occurrences
/// 
/// Property sets can also be given at the IfcSlabType,
/// defining the common property data for all occurrences of the same
/// type.ÿIt is then accessible by the inverse IsTypedBy relationship pointing to
/// IfcSlabType.HasPropertySets. If both are given, then the
/// properties directly assigned to IfcSlab overrides the
/// properties assigned to IfcSlabType.
/// Quantity Use Definition
/// The quantities relating to the IfcSlab and
/// IfcSlabStandardCase are defined by the
/// IfcElementQuantity and attached by the
/// IfcRelDefinesByProperties relationship. It is accessible
/// by the inverse IsDefinedBy relationship. The following
/// base quantities are defined and should be exchanged with the
/// IfcElementQuantity.Name = 'BaseQuantities'. Other
/// quantities can be defined being subjected to local standard of
/// measurement with another string value assigned to Name and
/// a value provided for MethodOfMeasurement. Quantities shall
/// never be assigned to the IfcSlabType.
/// 
/// Qto_SlabBaseQuantities: base quantities for
/// all slab occurrences.
/// 
/// Containment Use Definition
/// The IfcSlab, as any subtype of
/// IfcBuildingElement, may participate in two different
/// containment relationships. The first (and in most implementation
/// scenarios mandatory) relationship is the hierarchical spatial
/// containment, the second (optional) relationship is the
/// aggregation within anÿelement assembly.
/// 
/// TheÿIfcSlab is places within the project spatial
/// hierarchy using the objectified relationship
/// IfcRelContainedInSpatialStructure, referring to it by its
/// inverse attribute SELF\IfcElement.ContainedInStructure.
/// Subtypes ofÿIfcSpatialStructureElement are valid spatial
/// containers, with IfcBuildingStorey being the default
/// container.
/// TheÿIfcSlab may be aggregated into an element assembly
/// using the objectified relationship IfcRelAggregates,
/// referring to it by its inverse attribute
/// SELF\IfcObjectDefinition.Decomposes. Any subtype of
/// IfcElement can be an element assembly, with
/// IfcElementAssembly as a special focus subtype.
/// In this case it should not be additionally contained in the
/// project spatial hierarchy,
/// i.e.ÿSELF\IfcElement.ContainedInStructure should be
/// NIL.
/// 
/// The IfcSlabÿmay also be an aggregate i.e. being
/// composed by other elements and acting as an assembly using the
/// objectified relationship IfcRelAggregates, referring to it
/// by its inverse attribute
/// SELF\IfcObjectDefinition.IsDecomposedBy. Components of a
/// slab are described by instances of subtypes of
/// IfcBuildingElement, with IfcBuildingElementPart as
/// a special focus subtype that are aggregated to form a complex
/// slab. In this case, the contained elements should not be
/// additionally contained in the project spatial hierarchy, i.e. the
/// inverse attribute SELF\IfcElement.ContainedInStructure of
/// IfcBuildingElementPart (or other subtypes of
/// IfcBuildingElement) should be NIL.
/// Geometry Use Definition
/// The geometric representation of IfcSlab is given by the
/// IfcProductDefinitionShape, allowing multiple geometric
/// representation. Included are:
/// NOTE. If the IfcSlab is of type Landing
/// and is used within an IfcStair or IfcRamp, the
/// special agreements to handle stair and ramp geometry will also
/// affect the geometric representation of the
/// IfcSlab.
/// Local Placement
/// The local placement for IfcSlab is defined in its
/// supertype IfcProduct. It is defined by the
/// IfcLocalPlacement, which defines the local coordinate
/// system that is referenced by all geometric representations.
/// 
/// The PlacementRelTo relationship of
/// IfcLocalPlacement shall point (if given) to the placement
/// of the local placement of the same
/// IfcSpatialStructureElement that is used in the
/// ContainedInStructure inverse attribute or to a referenced
/// spatial structure element at a higher level.
/// If the IfcSlab is of type Landing and is used by an
/// IfcStair or IfcRamp, and this container class
/// defines its own local placement, then the PlacementRelTo
/// relationship of IfcLocalPlacement shall point (if given)
/// to the local placement of the aggregate.
/// If the relative placement is not used, the absolute placement
/// is defined within the world coordinate system.
/// 
/// Geometric Representation
/// Currently, the 'Surface',
/// 'FootPrint', 'Body', and 'Box'
/// representations are supported. The 'Box' representation includes
/// the representation type 'BoundingBox' and is explained at
/// IfcBuildingElement.
/// Surface Representation
/// The surfacic geometric representation of IfcSlab is
/// defined using the 'Surface' representation.
/// 
/// RepresentationIdentifier : 'Surface'
/// RepresentationType : 'Surface3D'
/// 
/// NOTE The 'Surface' can be used to define a
/// surfacic model of the building (e.g. for analytical purposes, or
/// for reduced Level of Detail representation).
/// Body Representation
/// The body representation of IfcSlab can be represented
/// using the representation types 'SweptSolid', 'Clipping',
/// 'SurfaceModel', and 'Brep'. The representation types
/// 'SurfaceModel' and 'Brep' are explained at
/// IfcBuildingElement.
/// SweptSolid Representation Type
/// The following attribute values for the
/// IfcShapeRepresentation holding this geometric
/// representation shall be used:
/// If a corresponding material definition using
/// IfcMaterialLayerSetUsage can be assigned, the subtype
/// IfcSlabStandardCase shall be used.
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'SweptSolid'
/// 
/// The following additional constraints apply to the swept solid
/// representation:
/// 
/// Solid: IfcExtrudedAreaSolid is required,
/// Profile: IfcArbitraryClosedProfileDef,
/// IfcRectangleProfileDef, IfcCircleProfileDef,
/// IfcEllipseProfileDef shall be supported.
/// Extrusion: The profile can be extruded perpendicularly
/// or non-perpendicularly to the plane of the swept profile.
/// 
/// Figure 120 illustrates a 'SweptSolid' geometric representation.
/// NOTE The following interpretation of dimension parameter applies for polygonal slabs (in ground floor view):
/// 
/// IfcArbitraryClosedProfileDef.OuterCurve: closed bounded curve interpreted as area (or foot print) of the slab.
/// 
/// Figure 120 — Slab body extrusion
/// 
/// Clipping Representation Type
/// The following attribute values for the
/// IfcShapeRepresentation holding this geometric
/// representation shall be used:
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'Clipping'
/// 
/// The following constraints apply to the 'Clipping'
/// representation:
/// 
/// Solid: see 'SweptSolid' shape representation,
/// Profile:ÿsee 'SweptSolid' shape representation,
/// Extrusion:ÿsee 'SweptSolid' shape representation,
/// Boolean result: The IfcBooleanClippingResult
/// shall be supported, allowing for Boolean differences between the
/// swept solid (here IfcExtrudedAreaSolid) and one or several
/// IfcHalfSpaceSolid.
/// 
/// Figure 121 illustrates a 'Clipping' geometric representation with definition of a roof slab using advanced
/// geometric representation. The profile is extruded non-perpendicular and the slab body is clipped at the eave.
/// 
/// Figure 121 — Slab body clipping
class IfcSlab : public IfcBuildingElement {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcSlab
    bool hasPredefinedType() const;
    /// Predefined generic type for a slab that is specified in an enumeration. There may be a property set given specifically for the predefined types.
    ///   NOTE The PredefinedType shall only be used, if no type object IfcSlabType is assigned, providing its own IfcSlabType.PredefinedType.
    /// 
    /// FC2x PLATFORM CHANGE: The attribute has been changed into an OPTIONAL attribute.
    IfcSlabTypeEnum::IfcSlabTypeEnum PredefinedType() const;
    void setPredefinedType(IfcSlabTypeEnum::IfcSlabTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcBuildingElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcSlabTypeEnum; } return IfcBuildingElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "PredefinedType"; } return IfcBuildingElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcSlab (IfcAbstractEntity* e);
    IfcSlab (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcSlabTypeEnum::IfcSlabTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcSlab > list;
};
/// Definition from ISO 6707-1:1989: Construction comprising
/// a succession of horizontal stages (steps or landings) that make it
/// possible to pass on foot to other levels.
/// A stair is a vertical passageway allowing
/// occupants to walk (step) from one floor level to another floor
/// level at a different elevation. It may include a landing as an
/// intermediate floor slab. The stair should either be
/// represented:
/// 
/// as a stair assembly entity that aggregates all components
/// (stair flight, landing, etc. with own representations), or
/// as a single stair entity without decomposition including all
/// representation directly at the stair entity.
/// 
/// In case of a stair container, the aggregation is handled via the
/// IfcRelAggregates relationship, relating an IfcStair
/// with the related IfcStairFlight's and landings (represented
/// by IfcSlab with IfcSlab.PredefinedType = 'LANDING').
/// IfcRailing's belonging to the stair may be included into the
/// aggregation as well.
/// 
/// HISTORY New Entity in IFC Release 2.0.
/// IFC2x4 CHANGE Attribute ShapeType renamed to PredefinedType.
/// 
/// Type Use Definition
/// IfcStair defines the occurrence of any stair, common
/// information about stair types (or styles) is handled by
/// IfcStairType. The IfcStairType (if present) may
/// establish the common type name, usage (or predefined) type, common
/// material, common set of properties and common shape representations
/// (using IfcRepresentationMap). The IfcStairType is
/// attached using the IfcRelDefinedByType.RelatingType
/// objectified relationship and is accessible by the inverse
/// IsDefinedBy attribute.
/// NOTE Since the IfcStair might be
/// represented as an aggregate of parts, e.g. represented by
/// IfcStairFlight, or IfcSlab, these individual parts
/// may have type information attached (represented e.g. by
/// IfcStairFlightType, or
/// IfcSlabType).
/// Material Use Definition
/// The material of the IfcStair is defined by the
/// IfcMaterial and attached by the
/// IfcRelAssociatesMaterial.RelatingMaterial. It is
/// accessible by the inverse HasAssociations relationship.
/// Material information can also be given at the
/// IfcStairType, defining the common attribute data for all
/// occurrences of the same type. It is then accessible by the inverse
/// IsDefinedBy relationship pointing to
/// IfcStair.HasAssociations and via
/// IfcRelAssociatesMaterial.RelatingMaterial to
/// IfcMaterial. If both are given, then the material directly
/// assigned to IfcStair overrides the material assigned to
/// IfcStairType.
/// 
/// Property Set Use Definition:
/// The property sets relating to the IfcStair are defined by
/// the IfcPropertySet and attached by the
/// IfcRelDefinesByProperties relationship. It is accessible by
/// the inverse IsDefinedBy relationship. The following property
/// set definitions specific to the IfcStair are part of this
/// IFC release:
/// 
/// Pset_StairCommon: common property set for all
/// stair occurrences
/// 
/// Figure 127 shows the use of property sets Pset_StairCommon and
/// Pset_StairFlightCommon for the various stair properties.
/// 
/// Figure 127 — Stair properties
/// 
/// Geometry Use Definitions:
/// The geometric representation of IfcStair is given by the
/// IfcProductDefinitionShape, allowing multiple geometric
/// representation. Independent geometric representations should only
/// be used when the IfcStair is not defined as an aggregate. If
/// defined as an aggregate, the geometric representation is the sum of
/// the representation of the components within the aggregate.
/// Local placement
/// The local placement for IfcStair is defined in its
/// supertype IfcProduct. It is defined by the
/// IfcLocalPlacement, which defines the local coordinate system
/// that is referenced by all geometric representations.
/// 
/// The PlacementRelTo relationship of
/// IfcLocalPlacement shall point (if given) to the local
/// placement of the same IfcSpatialStructureElement that is
/// used in the ContainedInStructure inverse attribute or to a
/// referenced spatial structure element at a higher level.
/// If the relative placement is not used, the absolute placement
/// is defined within the world coordinate system.
/// 
/// If the LocalPlacement is given for the IfcStair,
/// then all components, which are aggregated to the stair should use
/// this placement as their relative placement.
/// Geometric Representation
/// Currently, the 'Axis', 'FootPrint', 'Body', and 'Box'
/// representations are supported. The 'Box' representation includes
/// the representation type 'BoundingBox' and is explained at
/// IfcBuildingElement.
/// 
/// Axis: A two-dimensional open curve
/// IfcBoundedCurve defining the walking line for the
/// stair.
/// FootPrint: A geometric curve set defining the footing
/// print, including the boundary of the stair.
/// Body: A solid representation defining the 3D shape of
/// the stair.
/// 
/// Axis Representation
/// The walking line is represented by a two-dimensional open curve
/// as the axis. The curve is directed into the upward direction
/// (direction has to be interpreted as specified at the subtypes of
/// IfcCurve). The following attribute values for the
/// IfcShapeRepresentation holding this geometric representation
/// shall be used:
/// 
/// RepresentationIdentifier : 'Axis'
/// RepresentationType : 'Curve2D'
/// 
/// NOTE  The 'Axis' representation of IfcStair
/// may be provided even if the IfcStair has components with own
/// shape representations.
/// 
/// FootPrint Representation
/// The stair foot print, including the stair boundary is
/// represented by a two-dimensional geometric curve set. The following
/// attribute values for the IfcShapeRepresentation holding this
/// geometric representation shall be used:
/// 
/// RepresentationIdentifier : 'FootPrint'
/// RepresentationType : 'GeometricCurveSet'
/// 
/// NOTE  The 'Footprint' representation of
/// IfcStair may be provided even if the IfcStair has
/// components with own shape representations.
/// 
/// Body Representation
/// The body representation of IfcStair can be represented
/// using the representation types 'SweptSolid', 'SurfaceModel',
/// 'Brep', and 'MappedRepresentation'. The general usage of
/// representation is are explained at IfcBuildingElement. No
/// further constraints or provisions on how to use the representation
/// types are defined for IfcStairFlight.
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'SweptSolid', 'SurfaceModel',
/// 'Brep', 'MappedRepresentation'
/// 
/// The 'Body' representation shall only be provided if the
/// IfcStair has no components defined (empty set of
/// SELF\IfcObject.IsDecomposedBy) or if the components defined
/// no not carry an own 'Body' representation.
/// Geometric representation by aggregated elements
/// If the IfcStair has components (referenced by
/// SELF\IfcObject.IsDecomposedBy) with own 'Body'
/// representation, then no 'Body' representation shall defined for the
/// IfcStair. The IfcStair shape is then represented by
/// the geometric representation of its components. The components are
/// accessed via
/// SELF\IfcObject.IsDecomposedBy[1].RelatedObjects.
/// 
/// Figure 128 illustrates stair placement, where the IfcStair defines the local placement for all components and the common 'Axis' representation, and each component has its own 'Body' representation.
/// 
/// Figure 128 — Stair placement
class IfcStair : public IfcBuildingElement {
public:
    IfcStairTypeEnum::IfcStairTypeEnum ShapeType() const;
    void setShapeType(IfcStairTypeEnum::IfcStairTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcBuildingElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcStairTypeEnum; } return IfcBuildingElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "ShapeType"; } return IfcBuildingElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcStair (IfcAbstractEntity* e);
    IfcStair (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, IfcStairTypeEnum::IfcStairTypeEnum v9_ShapeType);
    typedef IfcTemplatedEntityList< IfcStair > list;
};
/// A stair flight is an assembly of
/// building components in a single "run" of stair steps (not
/// interrupted by a landing). The stair steps and any stringers are
/// included in the stair flight. A winder is also regarded a part of
/// a stair flight.
/// An IfcStairFlight is normally aggregated by an
/// IfcStair through the IfcRelAggregates relationship,
/// the stair flight is then included in the set of
/// IfcRelAggregates.RelatedObjects. An IfcStairFlight
/// normally connects the floor slab of zero to two different storeys
/// (or partial storeys, or landings) within a building. The
/// connection relationship between the IfcStairFlight and the
/// IfcSlab is expressed using the
/// IfcRelConnectsElements relationship.
/// 
/// HISTORY: New Entity in IFC Release 2.0.
/// 
/// Type Use Definition
/// IfcStairFlight defines the occurrence of any stair
/// flight, common information about stair flight types (or styles)
/// is handled by IfcStairFlightType. The
/// IfcStairFlightType (if present) may establish the
/// commonÿtype name, usage (or predefined) type, common material
/// layer set, common set of properties and common shape
/// representations (using IfcRepresentationMap). The
/// IfcStairFlightType is attached using the
/// IfcRelDefinedByType.RelatingType objectified relationship
/// and is accessible by the inverse IsDefinedBy
/// attribute.
/// Material Use Definition
/// The material of the IfcStairFlight is defined by the
/// IfcMaterial and attached by the
/// IfcRelAssociatesMaterial.RelatingMaterial. It is
/// accessible by the inverse HasAssociations
/// relationship.
/// Property Set Use Definition:
/// The property sets relating to the IfcStairFlight are
/// defined by the IfcPropertySet and attached by the
/// IfcRelDefinesByProperties relationship. It is accessible
/// by the inverse IsDefinedBy relationship. The following
/// property set definitions specific to the IfcStairFlight
/// are part of this IFC release:
/// 
/// Pset_StairFlightCommon: common property set
/// for all stair flight occurrences
/// 
/// Quantity Use Definition
/// The quantities relating to the IfcStairFlight are
/// defined by the IfcElementQuantity and attached by the
/// IfcRelDefinesByProperties relationship. It is accessible
/// by the inverse IsDefinedBy relationship. The following
/// base quantities are defined and should be exchanged with the
/// IfcElementQuantity.Name = 'BaseQuantities'. Other
/// quantities can be defined being subjected to local standard of
/// measurement with another string value assigned to Name and
/// a value provided for MethodOfMeasurement. Quantities shall
/// never be assigned to the IfcStairFlightType.
/// 
/// Qto_StairFlightBaseQuantities: base
/// quantities for all stair flight occurrences.
/// 
/// Containment Use Definition
/// The IfcStairFlight, as any subtype of
/// IfcBuildingElement, may participate in two different
/// containment relationships. The first relationship is the
/// hierachical spatial containment, the second relationship is the
/// aggregation within anÿelement assembly.
/// 
/// The IfcStairFlight is placed within the project
/// spatial hierarchy using the objectified relationship
/// IfcRelContainedInSpatialStructure, refering to it by its
/// inverse attribute SELF\IfcElement.ContainedInStructure.
/// Subtypes ofÿIfcSpatialStructureElement are valid spatial
/// containers, with IfcBuildingStorey being the default
/// container.
/// The IfcStairFlight may be aggregated into an element
/// assembly using the objectified relationship
/// IfcRelAggregates, refering to it by its inverse attribute
/// SELF\IfcObjectDefinition.Decomposes. Any subtype of
/// IfcElement can be an element assembly, with
/// IfcStair as a special focus subtype. In this case it
/// shall not be additionally contained in the project spatial
/// hierarchy, i.e.ÿSELF\IfcElement.ContainedInStructure
/// shall be NIL.
/// 
/// Geometry Use Definition
/// The geometric representation of IfcStairFlight is given
/// by the IfcProductDefinitionShape, allowing multiple
/// geometric representation. Included are:
/// Local placement
/// The local placement for IfcStairFlight is defined in
/// its supertype IfcProduct. It is defined by the
/// IfcLocalPlacement, which defines the local coordinate
/// system that is referenced by all geometric representations.
/// 
/// The PlacementRelTo relationship of
/// IfcLocalPlacement shall point (if given) to the local
/// placement of the same IfcSpatialStructureElement that is
/// used in the ContainedInStructure inverse attribute or to a
/// referenced spatial structure element at a higher level.
/// If the IfcStairFlight, however, is used by an
/// IfcStair, and this container class defines its own local
/// placement, then the PlacementRelTo relationship of
/// IfcLocalPlacement shall point to the local placement of
/// the IfcStair.
/// 
/// Geometric Representations
/// Currently, the 'Axis', 'FootPrint', 'Body', and 'Box'
/// representations are supported. The 'Box' representation includes
/// the representation type 'BoundingBox' and is explained at
/// IfcBuildingElement.
/// 
/// Axis: A two-dimensional open curve
/// IfcBoundedCurve defining the walking line for the stair
/// flight.
/// FootPrint: A geometric curve set defining the footing
/// print, including the boundary of the stair flight.
/// Body: A solid representation defining the 3D shape of
/// the stair flight
/// 
/// Axis Representation
/// The walking line is represented by a two-dimensional open
/// curve as the axis. The curve is directed into the upward
/// direction (direction has to be interpreted as specified at the
/// subtypes of IfcCurve). The following attribute values for
/// the IfcShapeRepresentation holding this geometric
/// representation shall be used:
/// 
/// RepresentationIdentifier : 'Axis'
/// RepresentationType : 'Curve2D'
/// 
/// Figure 129 illustrates the axis representation which has the following constraints:
/// 
/// In case of straight flights the curve shall be a single item of type IfcPolyline.
/// In case of winding flights the curve shall be a single item of type IfcCompositeCurve.
/// In case of a curved flight or a spiral flight the curve shall be a single item of type IfcTrimmedCurve.
/// 
/// Figure 129 — Stair flight axis
/// 
/// FootPrint Representation
/// The flight foot print, including the flight boundary is
/// represented by a two-dimensional geometric curve set. The
/// following attribute values for the IfcShapeRepresentation
/// holding this geometric representation shall be used:
/// 
/// RepresentationIdentifier : 'FootPrint'
/// RepresentationType : 'GeometricCurveSet'
/// 
/// Figure 130 illustrates the footprint representation which has the following constraints:
/// 
/// In case of straight flights the curve set shall consists of a single item of type IfcPolyline.
/// In case of winding flights or curved flights the curve set shall consists of a single item of type IfcCompositeCurve.
/// In case of a spiral flight the curve set shall consists of a single item of type IfcConic or IfcPolyline.
/// 
/// Figure 130 — Stair flight footprint
/// 
/// Body Representation
/// The body representation of IfcStairFlight can be represented using the representation types 'SweptSolid', 'SurfaceModel', 'Brep', and 'MappedRepresentation'. The general usage of representation is are explained at
/// IfcBuildingElement. No further constraints or provisions on how to use the representation types are defined for
/// IfcStairFlight.
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'SweptSolid', 'SurfaceModel', 'Brep', 'MappedRepresentation'
/// 
/// Figure 131 illustrates the body representation.
/// 
/// Figure 131 — Stair flight body
class IfcStairFlight : public IfcBuildingElement {
public:
    /// Whether the optional attribute NumberOfRiser is defined for this IfcStairFlight
    bool hasNumberOfRiser() const;
    /// Number of the risers included in the stair flight
    /// 
    /// IFC2x4 CHANGE  The attribute has been deprecated it shall only be exposed with a NIL value. Use Pset_StairFlightCommon.NumberOfRisers instead.
    int NumberOfRiser() const;
    void setNumberOfRiser(int v);
    /// Whether the optional attribute NumberOfTreads is defined for this IfcStairFlight
    bool hasNumberOfTreads() const;
    /// Number of treads included in the stair flight.
    /// 
    /// IFC2x4 CHANGE  The attribute has been deprecated it shall only be exposed with a NIL value. Use Pset_StairFlightCommon.NumberOfTreads instead.
    int NumberOfTreads() const;
    void setNumberOfTreads(int v);
    /// Whether the optional attribute RiserHeight is defined for this IfcStairFlight
    bool hasRiserHeight() const;
    /// Vertical distance from tread to tread. The riser height is supposed to be equal for all stairs in a stair flight.
    /// 
    /// IFC2x4 CHANGE  The attribute has been deprecated it shall only be exposed with a NIL value. Use Pset_StairFlightCommon.RiserHeight instead.
    double RiserHeight() const;
    void setRiserHeight(double v);
    /// Whether the optional attribute TreadLength is defined for this IfcStairFlight
    bool hasTreadLength() const;
    /// Horizontal distance from the front to the back of the tread. The tread length is supposed to be equal for all steps of the stair flight.
    /// 
    /// IFC2x4 CHANGE  The attribute has been deprecated it shall only be exposed with a NIL value. Use Pset_StairFlightCommon.TreadLength instead.
    double TreadLength() const;
    void setTreadLength(double v);
    virtual unsigned int getArgumentCount() const { return 12; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_INT; case 9: return IfcUtil::Argument_INT; case 10: return IfcUtil::Argument_DOUBLE; case 11: return IfcUtil::Argument_DOUBLE; } return IfcBuildingElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::UNDEFINED; case 9: return Type::UNDEFINED; case 10: return Type::IfcPositiveLengthMeasure; case 11: return Type::IfcPositiveLengthMeasure; } return IfcBuildingElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "NumberOfRiser"; case 9: return "NumberOfTreads"; case 10: return "RiserHeight"; case 11: return "TreadLength"; } return IfcBuildingElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcStairFlight (IfcAbstractEntity* e);
    IfcStairFlight (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< int > v9_NumberOfRiser, boost::optional< int > v10_NumberOfTreads, boost::optional< double > v11_RiserHeight, boost::optional< double > v12_TreadLength);
    typedef IfcTemplatedEntityList< IfcStairFlight > list;
};
/// Definition from IAI: The IfcStructuralAnalysisModel is used to assemble all information needed to represent a structural analysis model.  It encompasses certain general properties (such as analysis type), references to all contained structural members, structural supports or connections, as well as loads and the respective load results.
/// 
/// Important functionalities for the description of an analysis model are derived from existing IFC entities:
/// 
/// From IfcSystem it inherits the ability to couple the analysis model via IfcRelServicesBuildings to one or more IfcBuildings as necessary.
///   From IfcGroup it inherits the inverse attribute IsGroupedBy, pointing to the relationship class IfcRelAssignsToGroup.  This allows to group structural members (instances of IfcStructuralMember), and supports (instances of IfcStructuralConnection) which belong to a specific analysis model.
///   NOTE:  Loads (as instances of IfcStructuralAction) are not included through IsGroupedBy.  Loads are assigned through the LoadedBy attribute relationship, using load groups as a grouping mechanism.  Only top-level load groups should be referenced via LoadedBy, i.e. load combinations if any load combinations exist, or load cases if no load combinations exist in this analysis model.
///   NOTE:  Results (as instances of IfcStructuralReaction) are not included through IsGroupedBy.  Results are assigned through the HasResults attribute relationship, using result groups as a grouping mechanism.
/// 
/// From IfcObject it inherits the inverse attribute IsDecomposedBy pointing to the relationship class IfcRelNests. It provides the hierarchy between the separate (partial) analysis models.
/// 
/// HISTORY: New entity in IFC 2x2.
/// 
/// IFC 2x4 change:  Attribute SharedPlacement and informal propositions added, allowing for easy retrieval of the common object placement and for specification of the analysis model's coordiante system before any structural item is instantiated.  WHERE rule added.
/// 
/// Informal propositions:
/// 
/// If one or more structural item (instance of a subtype of IfcStructuralItem) is grouped into an IfcStructuralAnalysisModel, the attribute SharedPlacement shall be provided with a value.
///   The ObjectPlacements of all structural items which are grouped into the same instance of IfcStructuralAnalysisModel shall refer to the same instance of IfcObjectPlacement as IfcStructuralAnalysisModel.SharedPlacement.
/// 
/// NOTE  This rule is necessary to achieve consistent topology representations.  The topology representations of structural items in an analysis model are meant to share vertices and edges und must therefore have the same object placement.
/// 
/// NOTE  A structural item may be grouped into more than one analysis model.  In this case, all these models must use the same instance of IfcObjectPlacement.
class IfcStructuralAnalysisModel : public IfcSystem {
public:
    /// Defines the type of the structural analysis model.
    IfcAnalysisModelTypeEnum::IfcAnalysisModelTypeEnum PredefinedType() const;
    void setPredefinedType(IfcAnalysisModelTypeEnum::IfcAnalysisModelTypeEnum v);
    /// Whether the optional attribute OrientationOf2DPlane is defined for this IfcStructuralAnalysisModel
    bool hasOrientationOf2DPlane() const;
    /// If the selected model type (PredefinedType) describes a 2D system, the orientation defines
    /// the analysis plane (P[1], P[2]) and the normal to the analysis plane (P[3]).  This is needed because
    /// structural items and activities are always defined in three-dimensional space even if they are
    /// meant to be analysed in a two-dimensional manner.
    /// 
    /// In case of predefined type IN_PLANE_LOADING_2D, the analysis is to be performed within the
    /// projection into the P[1], P[2] plane.
    /// In case of predefined type OUT_PLANE_LOADING_2D, only the P[3] component of loads and their
    /// effects is meant to be analyzed.  This is used for beam grids and for typical slab analyses.
    /// In case of predefined type LOADING_3D, OrientationOf2DPlane shall be omitted.
    IfcAxis2Placement3D* OrientationOf2DPlane() const;
    void setOrientationOf2DPlane(IfcAxis2Placement3D* v);
    /// Whether the optional attribute LoadedBy is defined for this IfcStructuralAnalysisModel
    bool hasLoadedBy() const;
    /// References to all load groups to be analyzed.
    IfcTemplatedEntityList< IfcStructuralLoadGroup >::ptr LoadedBy() const;
    void setLoadedBy(IfcTemplatedEntityList< IfcStructuralLoadGroup >::ptr v);
    /// Whether the optional attribute HasResults is defined for this IfcStructuralAnalysisModel
    bool hasHasResults() const;
    /// References to all result groups available for this structural analysis model.
    IfcTemplatedEntityList< IfcStructuralResultGroup >::ptr HasResults() const;
    void setHasResults(IfcTemplatedEntityList< IfcStructuralResultGroup >::ptr v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 5: return IfcUtil::Argument_ENUMERATION; case 6: return IfcUtil::Argument_ENTITY_INSTANCE; case 7: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 8: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } return IfcSystem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 5: return Type::IfcAnalysisModelTypeEnum; case 6: return Type::IfcAxis2Placement3D; case 7: return Type::IfcStructuralLoadGroup; case 8: return Type::IfcStructuralResultGroup; } return IfcSystem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 5: return "PredefinedType"; case 6: return "OrientationOf2DPlane"; case 7: return "LoadedBy"; case 8: return "HasResults"; } return IfcSystem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcStructuralAnalysisModel (IfcAbstractEntity* e);
    IfcStructuralAnalysisModel (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcAnalysisModelTypeEnum::IfcAnalysisModelTypeEnum v6_PredefinedType, IfcAxis2Placement3D* v7_OrientationOf2DPlane, boost::optional< IfcTemplatedEntityList< IfcStructuralLoadGroup >::ptr > v8_LoadedBy, boost::optional< IfcTemplatedEntityList< IfcStructuralResultGroup >::ptr > v9_HasResults);
    typedef IfcTemplatedEntityList< IfcStructuralAnalysisModel > list;
};

class IfcTendon : public IfcReinforcingElement {
public:
    IfcTendonTypeEnum::IfcTendonTypeEnum PredefinedType() const;
    void setPredefinedType(IfcTendonTypeEnum::IfcTendonTypeEnum v);
    double NominalDiameter() const;
    void setNominalDiameter(double v);
    double CrossSectionArea() const;
    void setCrossSectionArea(double v);
    /// Whether the optional attribute TensionForce is defined for this IfcTendon
    bool hasTensionForce() const;
    double TensionForce() const;
    void setTensionForce(double v);
    /// Whether the optional attribute PreStress is defined for this IfcTendon
    bool hasPreStress() const;
    double PreStress() const;
    void setPreStress(double v);
    /// Whether the optional attribute FrictionCoefficient is defined for this IfcTendon
    bool hasFrictionCoefficient() const;
    double FrictionCoefficient() const;
    void setFrictionCoefficient(double v);
    /// Whether the optional attribute AnchorageSlip is defined for this IfcTendon
    bool hasAnchorageSlip() const;
    double AnchorageSlip() const;
    void setAnchorageSlip(double v);
    /// Whether the optional attribute MinCurvatureRadius is defined for this IfcTendon
    bool hasMinCurvatureRadius() const;
    double MinCurvatureRadius() const;
    void setMinCurvatureRadius(double v);
    virtual unsigned int getArgumentCount() const { return 17; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; case 10: return IfcUtil::Argument_DOUBLE; case 11: return IfcUtil::Argument_DOUBLE; case 12: return IfcUtil::Argument_DOUBLE; case 13: return IfcUtil::Argument_DOUBLE; case 14: return IfcUtil::Argument_DOUBLE; case 15: return IfcUtil::Argument_DOUBLE; case 16: return IfcUtil::Argument_DOUBLE; } return IfcReinforcingElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcTendonTypeEnum; case 10: return Type::IfcPositiveLengthMeasure; case 11: return Type::IfcAreaMeasure; case 12: return Type::IfcForceMeasure; case 13: return Type::IfcPressureMeasure; case 14: return Type::IfcNormalisedRatioMeasure; case 15: return Type::IfcPositiveLengthMeasure; case 16: return Type::IfcPositiveLengthMeasure; } return IfcReinforcingElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; case 10: return "NominalDiameter"; case 11: return "CrossSectionArea"; case 12: return "TensionForce"; case 13: return "PreStress"; case 14: return "FrictionCoefficient"; case 15: return "AnchorageSlip"; case 16: return "MinCurvatureRadius"; } return IfcReinforcingElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcTendon (IfcAbstractEntity* e);
    IfcTendon (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_SteelGrade, IfcTendonTypeEnum::IfcTendonTypeEnum v10_PredefinedType, double v11_NominalDiameter, double v12_CrossSectionArea, boost::optional< double > v13_TensionForce, boost::optional< double > v14_PreStress, boost::optional< double > v15_FrictionCoefficient, boost::optional< double > v16_AnchorageSlip, boost::optional< double > v17_MinCurvatureRadius);
    typedef IfcTemplatedEntityList< IfcTendon > list;
};

class IfcTendonAnchor : public IfcReinforcingElement {
public:
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcReinforcingElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcReinforcingElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcReinforcingElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcTendonAnchor (IfcAbstractEntity* e);
    IfcTendonAnchor (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_SteelGrade);
    typedef IfcTemplatedEntityList< IfcTendonAnchor > list;
};
/// The element component type IfcVibrationIsolatorType defines commonly shared information for occurrences of vibration isolators.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// applicable assignment of process types 
/// 
/// It is used to define a vibration isolator specification (i.e. the specific product information, that is common to all occurrences of that product type).  Vibration Isolator types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcVibrationIsolatorType are represented by instances of IfcVibrationIsolator. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcElementComponentType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_VibrationIsolatorTypeCommon 
/// 
/// Material Use Definition 
/// The material of the IfcVibrationIsolatorType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Damping': Material from which the damping element of the vibration isolator is constructed.
class IfcVibrationIsolatorType : public IfcDiscreteAccessoryType {
public:
    /// Defines the type of vibration isolator.
    IfcVibrationIsolatorTypeEnum::IfcVibrationIsolatorTypeEnum PredefinedType() const;
    void setPredefinedType(IfcVibrationIsolatorTypeEnum::IfcVibrationIsolatorTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcDiscreteAccessoryType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcVibrationIsolatorTypeEnum; } return IfcDiscreteAccessoryType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcDiscreteAccessoryType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcVibrationIsolatorType (IfcAbstractEntity* e);
    IfcVibrationIsolatorType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcVibrationIsolatorTypeEnum::IfcVibrationIsolatorTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcVibrationIsolatorType > list;
};
/// Definition from ISO 6707-1:1989: Vertical construction
/// usually in masonry or in concrete which bounds or subdivides a
/// construction works and fulfils a load bearing or retaining
/// function.
/// Definition from IAI: The wall represents a vertical
/// construction that bounds or subdivides spaces. Wall are usually
/// vertical, or nearly vertical, planar elements, often designed to
/// bear structural loads. A wall is howeverÿnot required to be load
/// bearing.
/// NOTE NOTE There is a representation of walls
/// for structural analysis provided by a proper subtype of
/// IfcStructuralMember being part of the
/// IfcStructuralAnalysisModel.
/// 
/// NOTE An arbitrary planar element to which this semantic
/// information is not applicable, e.g. is not predominantly
/// vertical, shall be modeled as
/// IfcPlate
/// A wall may have openings, such as wall openings, openings used
/// for windows or doors, or niches and recesses. They are defined by
/// an IfcOpeningElement attached to the wall using the
/// inverse relationship HasOpenings pointing to
/// IfcRelVoidsElement.
/// The IFC specification provides two entities for wall
/// occurrences:
/// 
/// IfcWallStandardCase ÿused for all occurrences of
/// walls, that have a non-changing thickness along the wall path and
/// where the thickness parameter can be fully described by a
/// material layer set. These walls are always represented
/// geometrically by an 'Axis' and a 'SweptSolid' shape
/// representation (or by a 'Clipping' geometry based on
/// 'SweptSolid'), if a 3D geometric representation is assigned. In
/// addition they have to have a corresponding
/// IfcMaterialProfileSetUsage assigned.
/// IfcWallElementedCase used for occurrences of walls
/// which are aggregated from subordinate elements, following
/// specific decomposition rules expressed by the mandatory use of
/// IfcRelAggregates relationship.
/// IfcWall ÿused for all other occurrences of wall,
/// particularly for walls with changing thickness along the wall
/// path (e.g. polygonal walls), or walls with a non-rectangular
/// cross sections (e.g. L-shaped retaining walls), and walls having
/// an extrusion axis that is unequal to the global Z axis of the
/// project (i.e. non-vertical walls), or walls having only 'Brep',
/// or 'SurfaceModel' geometry.
/// 
/// HISTORY New entity in
/// IFC Release 1.0
/// Type Use Definition
/// IfcWall defines the occurrence of any wall, common
/// information aboutÿwall types (or styles) is handled by
/// IfcWallType. The IfcWallType (if present) may
/// establish the commonÿtype name, usage (or predefined) type,
/// common material layer set, common set of properties and common
/// shape representations (using IfcRepresentationMap). The
/// IfcWallType is attached using the
/// IfcRelDefinedByType.RelatingType objectified relationship
/// and is accessible by the inverse IsTypedBy attribute.
/// If no IfcWallType is attachedÿ(i.e. if only occurrence
/// information is given) the PredefinedType should be
/// provided. If set to .USERDEFINED. a user defined value can be
/// provided by the ObjectType attribute.
/// Material Use Definition
/// The material of the IfcWall is defined by
/// IfcMaterialLayerSet and attached by the
/// IfcRelAssociatesMaterial.RelatingMaterial. It is
/// accessible by the inverse HasAssociations relationship.
/// Multi-layer walls can be represented by referring to several
/// IfcMaterialLayer's within the
/// IfcMaterialLayerSet.ÿ
/// Note: It is illegal to assign an
/// IfcMaterialLayerSetUsage to an IfcWall. Only the
/// subtype IfcWallStandardCase supports this
/// concept.
/// Material information can also be given at the
/// IfcWallType, defining the common attribute data for all
/// occurrences of the same type.ÿIt is then in addition accessible
/// by the inverse IsTypedBy
/// relationship pointing to IfcWallType.HasAssociations and
/// via IfcRelAssociatesMaterial.RelatingMaterial.
/// Property Set Use Definition
/// The property sets relating to the IfcWall are defined
/// by the IfcPropertySet and attached by the
/// IfcRelDefinesByProperties relationship. It is accessible
/// by the inverse IsDefinedBy relationship. The following
/// property set definitions specific to the IfcWall are part
/// of this IFC release:
/// 
/// Pset_WallCommon: common property set for all
/// wall occurrences
/// 
/// Property sets can also be given at the IfcWallType,
/// defining the common property data for all occurrences of the same
/// type.ÿIt is then accessible by the inverse IsTypedBy relationship pointing to
/// IfcWallType.HasPropertySets. If both are given, then the
/// properties directly assigned to IfcWall overrides the
/// properties assigned to IfcWallType.
/// Quantity Use Definition
/// The quantities relating to the IfcWall and
/// IfcWallStandardCase are defined by the
/// IfcElementQuantity and attached by the
/// IfcRelDefinesByProperties relationship. It is accessible
/// by the inverse IsDefinedBy relationship. The following
/// base quantities are defined and should be exchanged with the
/// IfcElementQuantity.Name = 'BaseQuantities'. Other
/// quantities can be defined being subjected to local standard of
/// measurement with another string value assigned to Name and
/// a value provided for MethodOfMeasurement. Quantities shall
/// never be assigned to the IfcWallType.
/// 
/// Qto_WallBaseQuantities: base quantities for
/// all wall occurrences.
/// 
/// Containment Use Definition
/// The IfcWall (and the subtype
/// IfcWallStandardCase) as any subtype of
/// IfcBuildingElement, may participate in two different
/// containment relationships. The first (and in most implementation
/// scenarios mandatory) relationship is the hierarchical spatial
/// containment, the second (optional) relationship is the
/// aggregation within anÿelement assembly.
/// 
/// The IfcWall is places within the project spatial
/// hierarchy using the objectified relationship
/// IfcRelContainedInSpatialStructure, referring to it by its
/// inverse attribute SELF\IfcElement.ContainedInStructure.
/// Subtypes ofÿIfcSpatialStructureElement are valid spatial
/// containers, with IfcBuildingStorey being the default
/// container.
/// TheÿIfcWall may be aggregated into an element assembly
/// using the objectified relationship IfcRelAggregates,
/// referring to it by its inverse attribute
/// SELF\IfcObjectDefinition.Decomposes. Any subtype of
/// IfcElement can be an element assembly, with
/// IfcElementAssembly as a special focus subtype.
/// In this case the wall should not be additionally contained in the
/// project spatial hierarchy,
/// i.e.ÿSELF\IfcElement.ContainedInStructure should be
/// NIL.
/// 
/// TheÿIfcWallÿmay also be an aggregate i.e. being
/// composed by other elements and acting as an assembly using the
/// objectified relationship IfcRelAggregates, referring to it
/// by its inverse attribute
/// SELF\IfcObjectDefinition.IsDecomposedBy. Components of a
/// wall are described by instances of IfcBuildingElementPart
/// that are aggregated to form a complex wall.
/// In this case, the containedÿIfcBuildingElementPart's
/// should not be additionally contained in the project spatial
/// hierarchy, i.e. the inverse attribute
/// SELF\IfcElement.ContainedInStructure of
/// IfcBuildingElementPart should be NIL.
/// Geometry Use Definition
/// The geometric representation of IfcWall is given by the
/// IfcProductDefinitionShape, allowing multiple geometric
/// representation. Included are:
/// Local Placement
/// The local placement for IfcWall is defined in its
/// supertype IfcProduct. It is defined by the
/// IfcLocalPlacement, which defines the local coordinate
/// system that is referenced by all geometric representations.
/// 
/// The PlacementRelTo relationship of
/// IfcLocalPlacement shall point (if given) to the local
/// placement of the same IfcSpatialStructureElement that is
/// used in the ContainedInStructure inverse attribute or to a
/// referenced spatial structure element at a higher level.
/// If the relative placement is not used, the absolute placement
/// is defined within the world coordinate system.
/// 
/// Geometric Representation
/// Currently, the 'Axis', 'Surface',
/// 'FootPrint', 'Body', and 'Box'
/// representations are supported. The 'Box' representation includes
/// the representation type 'BoundingBox' and is explained at
/// IfcBuildingElement.
/// Axis Representation
/// The axis geometric representation of IfcWall is defined
/// using the 'Axis' representation.
/// 
/// RepresentationIdentifier : 'Axis'
/// RepresentationType : 'Curve2D'
/// 
/// NOTE The 'Axis' is not used to locate the
/// material layer set, only the subtype IfcWallStandardCase
/// provides this capability.
/// Surface Representation
/// The surfacic geometric representation of IfcWall is
/// defined using the 'Surface' representation.
/// 
/// RepresentationIdentifier : 'Surface'
/// RepresentationType : 'Surface3D'
/// 
/// NOTE The 'Surface' can be used to define a
/// surfacic model of the building (e.g. for analytical purposes, or
/// for reduced Level of Detail representation).
/// Body Representation
/// The body representation of IfcWall can be represented
/// using the representation types 'SweptSolid', 'Clipping',
/// 'SurfaceModel', and 'Brep'. The representation types
/// 'SurfaceModel' and 'Brep' are explained at
/// IfcBuildingElement.
/// SweptSolid Representation Type
/// The following attribute values for the
/// IfcShapeRepresentation holding this geometric
/// representation shall be used:
/// If the wall body can be described by a
/// vertical extrusion of a polygonal footprint with constant
/// thickness along the axis (where vertical = into the direction of
/// the global Z axis), the subtype IfcWallStandardCase should
/// be used. If the extrusion is not equal to global Z, then the
/// IfcWall should be used.
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'SweptSolid'
/// 
/// The following additional constraints apply to the 'SweptSolid'
/// representation:
/// 
/// Solid: IfcExtrudedAreaSolid is required,
/// Profile: IfcArbitraryClosedProfileDef is
/// required.
/// Extrusion:ÿAll extrusion directions shall be
/// supported.
/// 
/// Clipping Representation Type
/// The following attribute values for the
/// IfcShapeRepresentation holding this geometric
/// representation shall be used:
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'Clipping'
/// 
/// The same additional constraints apply as defined for the
/// 'SweptSolid' representation.
/// Connection Geometry
/// The connection between two walls is represented by the
/// IfcRelConnectsPathElements. The use of the parameter of
/// that relationship object is defined at the level of the subtypes
/// of IfcWall and at the
/// IfcRelConnectsPathElements.
class IfcWall : public IfcBuildingElement {
public:
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcBuildingElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcBuildingElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcBuildingElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcWall (IfcAbstractEntity* e);
    IfcWall (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag);
    typedef IfcTemplatedEntityList< IfcWall > list;
};
/// The IfcWallStandardCase defines a wall with certain
/// constraints for the provision of parameters and with certain
/// constraints for the geometric representation. The
/// IfcWallStandardCase handles all cases of walls, that are
/// extruded vertically:
/// 
/// along the positive z axis of the wall object coordinate system,
/// and
/// along the positve z axis of the global (world) coordinate
/// system
/// 
/// and have a single thickness along the path for each wall layer,
/// i.e.:
/// 
/// parallel sides for straight walls
/// co-centric sides for curved walls.
/// 
/// and have either:
/// 
/// a straight line axis (straight wall), or
/// a circular arc axis (round wall).
/// 
/// and shall not have
/// 
/// aggregated components, that is, parts aggregated to a wall by IfcRelAggregates
/// shape representation for 'Body' not being an extrusion, or clipped extrusion
/// 
/// The following parameter have to be provided:
/// 
/// Wall height, taken from the depth of extrusion, provided by the geometric representation.
/// Wall thickness, taken from the material layer set usage, attached to the wall
/// Wall offset from axis, taken from the material layer set usage, attached to the wall
/// 
/// The IfcWallStandardCase requires the provision of the
/// wall axis either a straight line that is parallel to the x-axis of
/// the object coordinate system, or a circular arc where the tangent
/// at start is parallel to the x-axis of the object coordinate system.
/// The direction of the wall axis shall be the positive direction of
/// that x-axis.
/// The material of the wall is defined by the
/// IfcMaterialLayerSetUsage and is attached by the
/// IfcRelAssociatesMaterial objectified relationship. It is
/// accessible by the inverse HasAssociations relationship.
/// The material layer set usage has to be given (enforced by where
/// rule).
/// HISTORY New entity in IFC Release 2x.
/// 
/// Type Use Definition
/// The type information relating to the
/// IfcWallStandardCase is defined at the supertype
/// IfcWall. As an additional use agreement for standard
/// walls, the IfcWallType should have a unique
/// IfcMaterialLayerSet, that is referenced by
/// the IfcMaterialLayerSetUsage assigned to all
/// occurrences of this IfcWallType.
/// 
/// Figure 134 illustrates assignment of IfcMaterialLayerSetUsage and IfcMaterialLayerSet to the wall type and the wall occurrence.
/// 
/// Figure 134
/// 
/// Material Use Definition
/// The material of the IfcWallStandardCase is defined by
/// IfcMaterialLayerSetUsage and attached by the
/// IfcRelAssociatesMaterial.RelatingMaterial. It is
/// accessible by the inverse HasAssociations relationship.
/// Multi-layer walls can be represented by refering to several
/// IfcMaterialLayer's within the IfcMaterialLayerSet
/// that is referenced from the
/// IfcMaterialLayerSetUsage. 
/// Material information can also be given at the
/// IfcWallType, defining the common attribute data for all
/// occurrences of the same type. It is then accessible by the
/// inverse IsDefinedBy relationship pointing to
/// IfcSlabType.HasAssociations and via
/// IfcRelAssociatesMaterial.RelatingMaterial. See Type Use
/// Definition for additional agreements for standard slabs.
/// 
/// Figure 134 illustrates material layer usage, where the following conventions shall be met:
/// 
/// The reference coordinate system is the local coordinate system established by the ObjectPlacement of the IfcWallStandardCase.
/// The reference axis is the axis defined by the IfcShapeRepresentation with RepresentationType='Axis' as one of the
/// Representation.Representations of the IfcWallStandardCase.
/// The IfcMaterialLayerSetUsage.OffsetFromReferenceLine is given as a distance from this axis.
/// The IfcMaterialLayerSetUsage.OffsetFromReferenceLine is the distance parallel to the reference axis and always within the base
/// (XY) plane of the reference coordinate system. A positve value of IfcMaterialLayerSetUsage.OffsetFromReferenceLine would
/// then point into the positive y-axis of the reference coordinate system.
/// The IfcMaterialLayerSetUsage.DirectionSense defines how the IfcMaterialLayer's are assigned to the reference axis. POSITIVE means in direction to the positive y-axis of the reference coordinate system.
/// The Thickness of each IfcMaterialLayer is provided starting from the OffsetFromReferenceLine and in the direction given by DirectionSense. It is applied without any gap or overlap between two consecutive layers. The TotalThickness of the IfcMaterialLayerSet is the sum of all layer thicknesses.
/// The IfcMaterialLayerSetUsage.LayerSetDirection is always AXIS2.
/// 
/// Figure 134 — Wall material layers
/// 
/// Property Set Use Definition:
/// The property sets relating to the IfcWallStandardCase
/// are defined at the supertype IfcWall.
/// Quantity Use Definition:
/// The quantities relating to the IfcWallStandardCase are
/// defined at the supertype IfcWall.
/// Geometry Use Definitions:
/// The geometric representation of IfcWallStandardCase is
/// given by the IfcProductDefinitionShape, allowing multiple
/// geometric representation. Included are:
/// Local Placement
/// The use of local placement defining the wall object coordinate
/// system is defined at the supertype IfcWall.
/// Geometric Representation
/// The standard geometric representation of
/// IfcWallStandardCase is defined using the following
/// multiple shape representations for its definition:
/// 
/// Axis: A two-dimensional open curve
/// (IfcBoundedCurve) defining the axis for the standard wall.
/// The material layer offset is measured from the wall axis.
/// Body: A Swept Solid Representation or a CSG
/// representation defining the 3D shape of the standard wall
/// 
/// NOTE  It is invalid to exhange a
/// 'SurfaceModel', or 'Brep' or 'MappedRepresentation' representation
/// for the 'Body' shape representation of an
/// IfcWallStandardCase.
/// Axis Representation
/// The wall axis is represented by a two-dimensional open curve
/// within a particular shape representation. The wall axis is used to
/// apply the material layer set usage parameter to the wall geometry.
/// The following attribute values shall be used
/// 
/// RepresentationIdentifier : 'Axis'
/// RepresentationType : 'Curve2D'
/// 
/// Figure 135 illustrates an axis representation for a straight wall. In case of a straight wall, the set of items shall
/// include a single geometric representation item of type IfcPolyline or IfcTrimmedCurve with the BasisCurve being an IfcLine. The IfcPolyline or IfcTrimmedCurve shall be parallel (here in a special case co-linear) to the x-axis
/// of the object coordinate system. The direction shall be identical to the direction of the x-axis.
/// 
/// Figure 136 illustrates an axis representation for a curved wall. In case of a curved wall, the set of items shall include
/// a single geometric representation item of type IfcTrimmedCurve. The curve shall have a BasisCurve of type IfcCircle. The tangent of the IfcTrimmedCurve shall be parallel at start to the x-axis of the object coordinate system. The direction shall be identical to the direction of the x-axis.
/// 
/// Figure 135 — Wall axis straight
/// Figure 136 — Wall axis curved
/// 
/// Body Representation
/// The body representation of IfcWallStandardCase is
/// defined by using 'SweptSolid' representation for walls without
/// clippings or 'Clipping' representation for walls with clippings
/// (e.g. under sloped roof slabs).
/// SweptSolid Representation Type
/// The following attribute values for the
/// IfcShapeRepresentation holding this geometric
/// representation shall be used:
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'SweptSolid'
/// 
/// The following additional constraints apply to the 'SweptSolid'
/// representation:
/// 
/// Solid: IfcExtrudedAreaSolid is required,
/// Profile: IfcArbitraryClosedProfileDef and
/// IfcRectangleProfileDef shall be supported.
/// Extrusion: The profile shall be extruded vertically,
/// i.e., in the direction of the z-axis of the co-ordinate system of
/// the referred spatial structure element. It might be further
/// constraint to be in the direction of the global z-axis in
/// implementers agreements. The extrusion axis shall be perpendicular
/// to the swept profile, i.e. pointing into the direction of the
/// z-axis of the Position of the IfcExtrudedAreaSolid.
/// 
/// The profile of a wall is described in the ground view and extruded vertically. The profile (also identical with the foot print of the wall) is defined by the IfcArbitraryClosedProfileDef (excluding its subtypes). The profile is given with all wall connections already resolved.
/// 
/// Figure 137 illustrates a body representation for a straight wall. In case of a straight wall, the two sides of the profile shall be parallel to the wall axis, that is, the wall has a single unchanged thickness.
/// 
/// Figure 138 illustrates a body representation for a curved wall. In case of a curved wall, the two sides of the profile shall be parallel (with defined offset) to the wall axis, that is, the wall has a single unchanged thickness.
/// 
/// Figure 137 — Wall body extrusion straight
/// Figure 138 — Wall body extrusion curved
/// 
/// Clipping Representation Type
/// The following attribute values for the
/// IfcShapeRepresentation holding this geometric
/// representation shall be used:
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'Clipping'
/// 
/// The following constraints apply to the 'Clipping'
/// representation:
/// 
/// Solid: see standard geometric representation
/// Profile: see standard geometric representation
/// Extrusion: see standard geometric representation
/// Boolean result: The IfcBooleanClippingResult
/// shall be supported, allowing for Boolean differences between the
/// swept solid (here IfcExtrudedAreaSolid) and one or several
/// IfcHalfSpaceSolid (or subtypes).
/// 
/// Figure 139 illustrates a clipping for a straight wall using an IfcPolygonalBoundedHalfSpace as SecondOperand in
/// the IfcBooleanClippingResult.
/// 
/// Figure 140 illustrates a clipping for a curved wall using an IfcHalfSpaceSolid as SecondOperand in the
/// IfcBooleanClippingResult.
/// 
/// Figure 139 — Wall body clipping straight
/// Figure 140 — Wall body clipping curved
class IfcWallStandardCase : public IfcWall {
public:
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcWall::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcWall::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcWall::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcWallStandardCase (IfcAbstractEntity* e);
    IfcWallStandardCase (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag);
    typedef IfcTemplatedEntityList< IfcWallStandardCase > list;
};
/// Definition form ISO 6707-1:1989: Construction for
/// closing a vertical or near vertical opening in a wall or pitched
/// roof that will admit light and may admit fresh air.
/// The window is a building element
/// that is predominately used to provide natural light and fresh
/// air. It includes vertical and horizontal opening (e.g. skylights
/// or light domes). It includes constructions with swinging,
/// pivoting, sliding, or revolving panels and fixed panels. A window
/// consists of a lining and one or several panels.
/// The IfcWindow defines a particular occurrence of a
/// window inserted in the spatial context of a project. A window
/// can:
/// 
/// be inserted into an IfcOpeningElement using the
/// IfcRelFillsElement relationship, , then the IfcDoor
/// has an inverse attribute FillsVoids provided,
/// 
/// NOTEÿ View definitions or
/// implementer agreements may restrict the relationship to only
/// include one window (or door) into one opening.
/// 
/// be part of an element assembly, often an
/// IfcCurtainWall, using the IfcRelAggregates
/// relationship, then the inverse attribute Decomposes is
/// provided.
/// or be a "free standing" window, then the IfcWindow has
/// no inverse attributes FillsVoids or Decomposes
/// provided.
/// 
/// The IFC specification provides two entities for window
/// occurrences:
/// 
/// IfcWindowStandardCase used for all occurrences of
/// windows, that have a 'Profile' shape representation defined to
/// which a set of shape parameters for lining and framing properties
/// apply. Additionally it requires the provision of an
/// IfcWindowType that references one
/// IfcWindowLiningProperties and on to many
/// IfcWindowPanelProperties.
/// 
/// NOTEÿ see
/// IfcWindowStandardCase for all specific constraints imposed
/// by this subtype.
/// 
/// IfcWindow used for all other occurrences of windows,
/// particularly for windows having only 'Brep', or 'SurfaceModel'
/// geometry without applying shape parameters.
/// 
/// The actual parameter of the window and/or its shape is defined
/// at the IfcWindow as the occurrence definition (or project
/// instance), or by the IfcWindowType as the specific definition (or
/// project type). The following parameters are given:
/// 
/// at the IfcWindow or IfcWindowStandardCase for
/// occurrence specific parameters. The IfcWindow
/// specifies:
/// 
/// the window width and height
/// the window opening direction (by the y-axis of the
/// ObjectPlacement)
/// 
/// at the IfcWindowType to
/// which the IfcWindow is related by the inverse relationship
/// IsDefinedBy pointing to IfcRelDefinesByType, for
/// type parameters common to all occurrences of the same type.
/// 
/// the partitioning type (single panel, double panel, tripel
/// panel, more panels)
/// the operation type (swing, tilt and turn, pivot revolve,
/// fixed case ment, etc.)
/// the window panel hinge side (by using two different styles
/// for right and left opening windows)
/// the construction material type
/// the particular attributes for the lining by the
/// IfcWindowLiningProperties
/// the particular attributes for the panels by theÿ
/// IfcWindowPanelProperties
/// 
/// HISTORY New entity in IFC Release 1.0.
/// IFC2x4 CHANGE The attributes PredefinedType and OperationType are added, the applicable type object has been changed to IfcDoorType.
/// 
/// Material Use Definition
/// The material of the IfcWindow is defined by the
/// IfcMaterialConstituentSet or as fall back by
/// IfcMaterial and attached by the
/// IfcRelAssociatesMaterial.RelatingMaterial. It is
/// accessible by the inverse HasAssociations
/// relationship.
/// The following keywords for
/// IfcMaterialConstituentSet.MaterialConstituents[n].Name
/// shall be used:
/// 
/// 'Lining' - to indicate that the material constituent applies
/// to to the window lining
/// 'Framing' - to indicate that the material constituent applies
/// to to the window panel(s), if not provided, the 'Lining' material
/// information applied to panel(s) as well
/// 'Glazing' - to indicate that the material constituent applies
/// to to the glazing part
/// 
/// If the fall back single IfcMaterial is referenced, it
/// applies to the lining and framing of the window.
/// Property Set Use Definition:
/// The property sets relating to the IfcWindow are defined
/// by the IfcPropertySet and attached by the
/// IfcRelDefinesByProperties relationship. It is accessible
/// by the inverse IsDefinedBy relationship. The following
/// property set definitions specific to the IfcWindow are
/// part of this IFC release:
/// 
/// Pset_WindowCommon: common property set for all
/// window occurrences
/// Pset_DoorWindowGlazingType: specific property
/// set for the glazing properties of the window glazing, if
/// available
/// Pset_DoorWindowShadingType: specific property
/// set for the shading properties of the window glazing, if
/// available
/// 
/// Quantity Use Definition
/// The quantities relating to the IfcWindow are defined by
/// the IfcElementQuantity and attached by the
/// IfcRelDefinesByProperties relationship. It is accessible
/// by the inverse IsDefinedBy relationship. The following
/// base quantities are defined and should be exchanged with the
/// IfcElementQuantity.Name = 'BaseQuantities'. Other
/// quantities can be defined being subjected to local standard of
/// measurement with another string value assigned to
/// MethodOfMeasurement. Quanties shall be never assigned to
/// the IfcWindowStyle.
/// 
/// Qto_WindowBaseQuantities: base quantities for
/// all window occurrences.
/// 
/// Containment Use Definition
/// 
/// The IfcWindow, as any subtype of
/// IfcBuildingElement, may participate in two different
/// containment relationships. The first (and in most implementation
/// scenarios mandatory) relationship is the hierachical spatial
/// containment, the second (optional) relationship is the
/// aggregation within anÿelement assembly.
/// 
/// The IfcWindow is placed within the project spatial
/// hierarchy using the objectified relationship
/// IfcRelContainedInSpatialStructure, refering to it by its
/// inverse attribute SELF\IfcElement.ContainedInStructure.
/// Subtypes ofÿIfcSpatialStructureElement are valid spatial
/// containers, with IfcBuildingStorey being the default
/// container.
/// The IfcWindow may be aggregated into an element
/// assembly using the objectified relationship
/// IfcRelAggregates, refering to it by its inverse attribute
/// SELF\IfcObjectDefinition.Decomposes. Windows may be part
/// of an IfcCurtainWall as a special focus subtype. In this
/// case it should not be additionally contained in the project
/// spatial hierarchy,
/// i.e.ÿSELF\IfcElement.ContainedInStructure should be
/// NIL.
/// 
/// Figure 141 illustrates window containment.
/// NOTE The containment shall be defined independently of the filling relationship, that is, even if the IfcWindow is a filling of an opening established by IfcRelFillsElement, it is also contained in the spatial structure by an IfcRelContainedInSpatialStructure.
/// 
/// Figure 141 — Window containment
/// 
/// Geometry Use Definitions:
/// The geometric representation of IfcWindow is given by
/// the IfcProductDefinitionShape, allowing multiple geometric
/// representation. The IfcWindow, in case of an occurrence
/// object, gets its parameter and shape from the
/// IfcWindowType. If an IfcRepresentationMap (a block
/// definition) is defined for the IfcWindowType, then the
/// IfcWindow inserts it through the IfcMappedItem
/// (refered to by IfcShapeRepresentation.Items).
/// Local Placement
/// The local placement for IfcWindow is defined in its
/// supertype IfcProduct. It is defined by the
/// IfcLocalPlacement, which defines the local coordinate
/// system that is referenced by all geometric representations.
/// 
/// The PlacementRelTo relationship of
/// IfcLocalPlacement shall point to the local placement of
/// the same element (if given), in which the IfcWindow is
/// used as a filling (normally an IfcOpeningElement), as
/// provided by the IfcRelFillsElement relationship.
/// If the IfcWindow is not inserted into an
/// IfcOpeningElement, then the PlacementRelTo
/// relationship of IfcLocalPlacement shall point (if given)
/// to the local placement of the same
/// IfcSpatialStructureElement that is used in the
/// ContainedInStructure inverse attribute or to a referenced
/// spatial structure element at a higher level.
/// If the relative placement is not used, the absolute placement
/// is defined within the world coordinate system.
/// 
/// Geometric Representation
/// Theÿgeometric representation of IfcWindow is defined
/// using the following (potentiallyÿmultiple)
/// IfcShapeRepresentation's for its
/// IfcProductDefinitionShape:
/// 
/// Profile: Aÿ'Curve3D'
/// consisting of a single losed curve defining the outer boundary of
/// the window (lining). Theÿwindow parametric representation uses
/// this profile in order to apply theÿwindow lining and panel
/// parameter. If not provided, the profile of the
/// IfcOpeningElement is taken.
/// FootPrint: A 'GeometricCurveSet', or 'Annotation2D'
/// representation defining the 2D shape of theÿwindow
/// Body: A 'SweptSolid', 'SurfaceModel', or 'Brep'
/// representation defining the 3D shape of theÿwindow.
/// 
/// In addition the parametric representation of a
/// (limited)ÿwindow shape is available by applying the parameters
/// fromÿIfcWindowType
/// referencingÿIfcWindowLiningProperties
/// andÿIfcWindowPanelProperties. The purpose of the parameter
/// is described at those entities and below (parametric
/// representation).
/// Profile -ÿ'Curve3D' representation
/// Theÿwindow profile is represented by a three-dimensional
/// closed curve within a particular shape representation. The
/// profile is used to apply the parameter of the parametricÿwindow
/// representation.ÿThe following attribute values for the
/// IfcShapeRepresentation holding this geometric
/// representation shall be used:
/// 
/// RepresentationIdentifier : 'Profile'
/// RepresentationType : 'Curve3D', only a single closed
/// curve shall be contained in the set of
/// IfcShapeRepresentation.Items.
/// 
/// A 'Profile' representation has to be provided if:
/// 
/// a parametric representation shall be applied to the
/// windowÿAND
/// 
/// the window is 'free standing', or
/// the opening into which the window is inserted is not extruded
/// horizontally (i.e. where the opening profile does not match the
/// window profile)
/// 
/// FootPrint -ÿ'GeometricCurveSet' or 'Annotation2D'
/// representation
/// Theÿwindow foot print is represented by a set of
/// two-dimensionalÿcurves (or in case of 'Annotation2D' additional
/// hatching and text) within a particular shape representation. The
/// foot print is used for the plan view representation of
/// theÿwindow.ÿThe following attribute values for the
/// IfcShapeRepresentation holding this geometric
/// representation shall be used:
/// 
/// RepresentationIdentifier : 'FootPrint'
/// RepresentationType : 'GeometricCurveSet', or
/// 'Annotation2D'
/// 
/// Body - 'SweptSolid', 'SurfaceModel', or 'Brep'
/// representation
/// Theÿwindow body is either represented parameterically (see
/// parametric representation) or by explicit 3D shape. The 3D shape
/// is given by using extrusion geometry, or surface models, or Brep
/// models within a particular shape representation. The body is used
/// for the model view representation of theÿwindow.ÿThe following
/// attribute values for the IfcShapeRepresentation holding
/// this geometric representation shall be used:
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'SweptSolid', 'SurfaceModel', or
/// 'Brep'
/// 
/// MappedRepresentation
/// The 'FootPrint' and 'Body' geometric representation
/// ofÿIfcWindow can be shared among several identicalÿwindows
/// using the 'MappedRepresentation'. The following attribute values
/// for the IfcShapeRepresentation holding this geometric
/// representation shall be used:
/// 
/// RepresentationIdentifier : 'FootPrint', 'Body'
/// RepresentationType : 'MappedRepresentation'
/// 
/// The same constraints, as given for theÿ 'FootPrint', 'Body'
/// representation identifiers, shall apply to the
/// MappedRepresentation of the
/// IfcRepresentationMap.
/// Parameteric Representation using parameters at
/// IfcWindowType
/// The parameters, which define the shape of the
/// IfcWindow, are given at the IfcWindowType and the
/// property sets, which are included in the IfcWindowType.
/// The IfcWindow only defines the local placement.
/// The overall size of the IfcWindow to
/// be used to apply the lining or panel parameter provided by the
/// IfcWindowType is determined by the IfcShapeRepresentation
/// with the RepresentationIdentifier = 'Profile'. Only in case of an
/// IfcWindow inserted into an IfcOpeningElement using
/// the IfcRelFillsElement relatioship, having a horizontal
/// extrusion (along the y-axis of the IfcDoor), the overall
/// size is determined by the extrusion profile of the
/// IfcOpeningElement.
/// 
/// Figure 142 illustrates the insertion of a window into the IfcOpeningElement by creating an instance of
/// IfcWindow with PartitioningType = DoublePanelHorizontal. The parameters OverallHeight and OverallWidth show the extent of the window in the positive Z and X axis of the local placement of the window. The lining and the transom are created by the given parameters.
/// 
/// Figure 142 — Window placement
/// 
/// Figure 143 illustrates the final window (DoublePanelHorizontal) with first panel having PanelPosition = TOP, OperationType = BOTTOMHUNG and second panel having PanelPosition = BOTTOM and OperationType = TILTANDTURNLEFTHAND.
/// 
/// Figure 143 — Window planes
/// 
/// Window opening operation by window type
/// The parameters that defines the shape of the IfcWindow,
/// are given at the IfcWindowType and the property sets,
/// which are included in the IfcWindowType. The
/// IfcWindow only defines the local placement which
/// determines the opening direction of the window. The overall
/// layout of the IfcWindow is determined by
/// itsÿIfcWindowType.PartitioningType. Each window panel has
/// its own operation type, provided by
/// IfcWindowPanelProperties.OperationType. All window panels
/// are assumed to open into the same direction (if relevant for the
/// particular window panel operation. The hindge side (whether a
/// window opens to the left or to the right) is determined by the
/// IfcWindowPanelProperties.OperationType.
/// NOTE ÿThere are different conventions in
/// different countries on how to show the symbolic presentation of
/// the window panel operation (the "triangles"). Either as seen from
/// the exterior, or from the interior side. The following figures
/// show the symbolics from the exterior side (the convention as used
/// predominately in Europe).
/// 
/// Figure 144 illustrates window operation types.
/// 
/// The window panel (for side hung windows) opens always
/// into the direction of the positive Y axis of the local placement.
/// The determination of whether the window opens to the left or to
/// the right is done at
/// IfcWindowPanelProperties.OperationType. Here it is a left
/// side opening window given byÿOperationType =
/// SideHungLeftHand.
/// 
/// If the window should open to the other side, then the
/// local placement has to be changed. It is still a left hung
/// window, given by IfcWindowPanelProperties.OperationType
/// =ÿSideHungLeftHand.
/// 
/// If the window panel (for side hung windows) opens to
/// the right, a separate window panel style needs to be used (here
/// IfcWindowPanelProperties.OperationType
/// =ÿSideHungRightHand) and it always opens into the direction of
/// the positive Y axis of the local placement.ÿ
/// 
/// If the window should open to the other side, then the
/// local placement has to be changed. It is still a right hung
/// window, given by IfcWindowPanelProperties.OperationType
/// =ÿSideHungRightHand.
/// .
/// 
/// Figure 144 — Window operations
class IfcWindow : public IfcBuildingElement {
public:
    /// Whether the optional attribute OverallHeight is defined for this IfcWindow
    bool hasOverallHeight() const;
    /// Overall measure of the height, it reflects the Z Dimension of a bounding box, enclosing the body of the window opening. If omitted, the OverallHeight should be taken from the geometric representation of the IfcOpening in which the window is inserted. 
    /// 
    /// NOTE  The body of the window might be taller then the window opening (e.g. in cases where the window lining includes a casing). In these cases the OverallHeight shall still be given as the window opening height, and not as the total height of the window lining.
    double OverallHeight() const;
    void setOverallHeight(double v);
    /// Whether the optional attribute OverallWidth is defined for this IfcWindow
    bool hasOverallWidth() const;
    /// Overall measure of the width, it reflects the X Dimension of a bounding box, enclosing the body of the window opening. If omitted, the OverallWidth should be taken from the geometric representation of the IfcOpening in which the window is inserted. 
    /// 
    /// NOTE  The body of the window might be wider then the window opening (e.g. in cases where the window lining includes a casing). In these cases the OverallWidth shall still be given as the window opening width, and not as the total width of the window lining.
    double OverallWidth() const;
    void setOverallWidth(double v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_DOUBLE; case 9: return IfcUtil::Argument_DOUBLE; } return IfcBuildingElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcPositiveLengthMeasure; case 9: return Type::IfcPositiveLengthMeasure; } return IfcBuildingElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "OverallHeight"; case 9: return "OverallWidth"; } return IfcBuildingElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcWindow (IfcAbstractEntity* e);
    IfcWindow (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< double > v9_OverallHeight, boost::optional< double > v10_OverallWidth);
    typedef IfcTemplatedEntityList< IfcWindow > list;
};
/// The distribution control element type IfcActuatorType defines commonly shared information for occurrences of actuators.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a actuator specification (i.e. the specific product information, that is common to all occurrences of that product type).  Actuator types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcActuatorType are represented by instances of IfcActuator. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcDistributionControlElementType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity according to the PredefinedType attribute:  
/// Pset_ActuatorTypeCommon 
/// Pset_ActuatorTypeElectricActuator (ELECTRICACTUATOR) 
/// Pset_ActuatorTypeHydraulicActuator (HYDRAULICACTUATOR) 
/// Pset_ActuatorTypeLinearActuation 
/// Pset_ActuatorTypePneumaticActuator (PNEUMATICACTUATOR) 
/// Pset_ActuatorTypeRotationalActuation 
/// 
/// Material Use Definition 
/// The material of the IfcActuatorType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Casing': Material from which the casing is constructed. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcActuatorType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcActuator for standard port definitions.
class IfcActuatorType : public IfcDistributionControlElementType {
public:
    /// Identifies the predefined types of actuator from which the type required may be set.
    IfcActuatorTypeEnum::IfcActuatorTypeEnum PredefinedType() const;
    void setPredefinedType(IfcActuatorTypeEnum::IfcActuatorTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcDistributionControlElementType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcActuatorTypeEnum; } return IfcDistributionControlElementType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcDistributionControlElementType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcActuatorType (IfcAbstractEntity* e);
    IfcActuatorType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcActuatorTypeEnum::IfcActuatorTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcActuatorType > list;
};
/// The distribution control element type IfcAlarmType defines commonly shared information for occurrences of alarms.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a alarm specification (i.e. the specific product information, that is common to all occurrences of that product type).  Alarm types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcAlarmType are represented by instances of IfcAlarm. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcDistributionControlElementType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_AlarmTypeCommon 
/// 
/// Material Use Definition 
/// The material of the IfcAlarmType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Casing': Material from which the casing is constructed. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcAlarmType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcAlarm for standard port definitions.
class IfcAlarmType : public IfcDistributionControlElementType {
public:
    /// Identifies the predefined types of alarm from which the type required may be set.
    IfcAlarmTypeEnum::IfcAlarmTypeEnum PredefinedType() const;
    void setPredefinedType(IfcAlarmTypeEnum::IfcAlarmTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcDistributionControlElementType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcAlarmTypeEnum; } return IfcDistributionControlElementType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcDistributionControlElementType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcAlarmType (IfcAbstractEntity* e);
    IfcAlarmType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcAlarmTypeEnum::IfcAlarmTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcAlarmType > list;
};
/// Definition from ISO 6707-1:1989: Structural member designed to carry loads between or beyond points of support, usually narrow in relation to its length and horizontal or nearly so.
/// 
/// An IfcBeam is a horizontal, or nearly horizontal, structural member that is capable of withstanding load primarily by resisting bending. It represents such a member from an architectural point of view. It is not required to be load bearing.
/// 
/// NOTE  The representation of a beam in a structural analysis model is provided by
/// IfcStructuralCurveMember being part of an IfcStructuralAnalysisModel.
/// 
/// NOTE  For any longitudial structural member, not constrained to be predominately horizontal nor vertical, or where this semantic information is irrelevant, the entity IfcMember should be used.
/// 
/// The IFC specification provides two entities for beam occurrences:
/// 
/// IfcBeamStandardCase used for all occurrences of beams, that have a profile defined that is swept along a directrix. The profile might be changed uniformly by a taper definition along the directrix. The profile parameter and its cardinal point of insertion can be fully described by the IfcMaterialProfileSetUsage. These beams are always represented geometricly by an 'Axis' and a 'SweptSolid' or 'AdvancedSweptSolid' shape representation (or by a 'Clipping' geometry based on the swept solid), if a 3D geometric representation is assigned. In addition they have to have a corresponding IfcMaterialProfileSetUsage assigned.
/// NOTE  View definitions and implementer agreements may further constrain the applicable geometry types, for example, by excluding tapering from an IfcBeamStandardCase implementation.
/// 
/// IfcBeam used for all other occurrences of beams, particularly for beams with changing profile sizes along the extrusion, or beams defined by non-linear extrusion, or beams having only 'Brep', or 'SurfaceModel' geometry.
/// 
/// HISTORY New entity in IFC Release 1.0
/// 
/// Type Use Definition
/// IfcBeam defines the occuurence of any beam, common
/// information about beam types (or styles) is handled by
/// IfcBeamType. The IfcBeamType (if present) may
/// establish the common type name, usage (or predefined) type,
/// common material layer set, common set of properties and common
/// shape representations (using IfcRepresentationMap). The
/// IfcBeamType is attached using the
/// IfcRelDefinedByType.RelatingType objectified relationship
/// and is accessible by the inverse IsTypedBy attribute.
/// If no IfcBeamType is attached (i.e. if only occurrence
/// information is given) the PredefinedType should be provided.
/// If set to .USERDEFINED. a user defined value can be provided by the
/// ObjectType attribute.
/// Material Use Definition
/// The material of the IfcBeam is defined by the
/// IfcMaterialProfileSet or as fallback by IfcMaterial
/// and attached by the
/// IfcRelAssociatesMaterial.RelatingMaterial. It is
/// accessible by the inverse HasAssociations relationship.
/// Note It is illegal to assign an
/// IfcMaterialProfileSetUsage to an IfcBeam. Only the
/// subtype IfcBeamStandardCase supports this
/// concept.
/// Material information can also be given at the
/// IfcBeamType, defining the common attribute data for all
/// occurrences of the same type. It is then accessible by the inverse
/// IsTypedBy relationship pointing
/// to IfcBeamType.HasAssociations and via
/// IfcRelAssociatesMaterial.RelatingMaterial to
/// IfcMaterialProfileSet or IfcMaterial. If both are
/// given, then the material directly assigned to IfcBeam
/// overrides the material assigned to IfcBeamType.
/// Property Set Use Definition
/// The property sets relating to the IfcBeam are defined by
/// the IfcPropertySet and attached by the
/// IfcRelDefinesByProperties relationship. It is accessible by
/// the inverse IsDefinedBy relationship. The following property
/// set definitions specific to the IfcBeam are part of this IFC
/// release:
/// 
/// Pset_BeamCommon: common property set for all
/// beam occurrences
/// 
/// Property sets can also be given at the IfcBeamType,
/// defining the common property data for all occurrences of the same
/// type. It is then accessible by the inverse IsTypedBy relationship pointing to
/// IfcBeamType.HasPropertySets. If both are given, then the
/// properties directly assigned to IfcBeam overrides the
/// properties assigned to IfcBeamType.
/// Quantity Use Definition
/// The quantities relating to the IfcBeam are defined by the
/// IfcElementQuantity and attached by the
/// IfcRelDefinesByProperties relationship. It is accessible by
/// the inverse IsDefinedBy relationship. The following base
/// quantities are defined and should be exchanged with the
/// IfcElementQuantity.Name = 'BaseQuantities'. Other quantities
/// can be defined being subjected to local standard of measurement
/// with another string value assigned to MethodOfMeasurement.
/// Quanties shall be never assigned to the IfcBeamType.
/// 
/// Qto_BeamBaseQuantities: base quantities for all
/// beam occurrences.
/// 
/// Containment Use Definition
/// The IfcBeam, as any subtype of IfcBuildingElement,
/// may participate in two different containment relationships. The
/// first (and in most implementation scenarios mandatory) relationship
/// is the hierachical spatial containment, the second (optional)
/// relationship is the aggregation within an element assembly.
/// 
/// The IfcBeam is places within the project spatial
/// hierarchy using the objectified relationship
/// IfcRelContainedInSpatialStructure, refering to it by its
/// inverse attribute SELF\IfcElement.ContainedInStructure.
/// Subtypes of IfcSpatialStructureElement are valid spatial
/// containers, with IfcBuildingStorey being the default
/// container.
/// The IfcBeam may be aggregated into an element assembly
/// using the objectified relationship IfcRelAggregates,
/// refering to it by its inverse attribute
/// SELF\IfcObjectDefinition.Decomposes. Any subtype of
/// IfcElement can be an element assembly, with
/// IfcElementAssembly as a special focus subtype. In this case
/// it should not be additionally contained in the project spatial
/// hierarchy, i.e. SELF\IfcElement.ContainedInStructure should
/// be NIL.
/// 
/// Geometry Use Definition
/// The geometric representation of IfcBeam is given by the
/// IfcProductDefinitionShape, allowing multiple geometric
/// representations. Included are:
/// Local Placement
/// The local placement for IfcBeam is defined in its
/// supertype IfcProduct. It is defined by the
/// IfcLocalPlacement, which defines the local coordinate system
/// that is referenced by all geometric representations.
/// 
/// The PlacementRelTo relationship of
/// IfcLocalPlacement shall point (if given) to the local
/// placement of the same IfcSpatialStructureElement, which is
/// used in the ContainedInStructure inverse attribute, or to a
/// spatial structure element at a higher level, referenced by that.
/// 
/// Exception: If the IfcBeam is part of an assembly, the
/// PlacementRelTo relationship of IfcLocalPlacement
/// shall point to the local placement of the container element, e.g.
/// IfcElementAssembly,
/// 
/// If the relative placement is not used, the absolute placement
/// is defined within the world coordinate system.
/// 
/// Geometric Representation
/// Currently, the 'Axis', 'Body', and
/// 'Box' representations are supported. The 'Box' representation
/// includes the representation type 'BoundingBox' and is explained at
/// IfcBuildingElement.
/// Axis Representation
/// The axis geometric representation of IfcBeam is defined
/// using the 'Axis' representation.
/// 
/// RepresentationIdentifier : 'Axis'
/// RepresentationType : 'Curve2D', 'Curve3D'
/// 
/// The 'Axis' can be used to represent the system
/// axis and length of a beam that may extent the body
/// length.
/// Body Representation
/// The body representation of IfcBeam can be represented
/// using the representation types 'SweptSolid', 'Clipping',
/// 'AdvancedSweptSolid', 'MappedRepresentation', 'SurfaceModel', and
/// 'Brep'. The representation types 'SurfaceModel' and 'Brep' are
/// explained at IfcBuildingElement.
/// SweptSolid Representation Type
/// The following attribute values for the
/// IfcShapeRepresentation holding this geometric representation
/// shall be used:
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'SweptSolid'
/// 
/// The following additional constraints apply to the 'SweptSolid'
/// representation type:
/// 
/// Solid: IfcExtrudedAreaSolid,
/// IfcRevolvedAreaSolid shall be supported
/// Profile: all subtypes of IfcProfileDef (with
/// exception of IfcArbitraryOpenProfileDef)
/// Extrusion:  All extrusion directions shall be
/// supported.
/// 
/// Figure 71 illustrates the 'SweptSolid' geometric representation.  There are no restrictions or conventions on how to use the local placement (black), solid of extrusion placement (red) and profile placement (green).
/// 
/// Figure 71 — Beam swept solid
/// 
/// Figure 72 illustrates the use of non-perpendicular extrusion to create the IfcExtrudedAreaSolid.
/// 
/// Figure 72 — Beam non-perpendicular extrusion
/// 
/// Clipping Representation Type
/// The following attribute values for the
/// IfcShapeRepresentation holding this geometric representation
/// shall be used:
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'Clipping'
/// 
/// The following constraints apply to the advanced
/// representation:
/// 
/// Solid: see 'SweptSolid' geometric representation
/// Profile: see 'SweptSolid' geometric representation
/// Extrusion: see 'SweptSolid' geometric
/// representation
/// Boolean result: The IfcBooleanClippingResult
/// shall be supported, allowing for Boolean differences between the
/// swept solid (here IfcExtrudedAreaSolid) and one or several
/// IfcHalfSpaceSolid (or its subtypes).
/// 
/// Figure 73 illustrates use of IfcBooleanClippingResult between an IfcExtrudedAreaSolid and an IfcHalfSpaceSolid to create a clipped body.
/// 
/// Figure 73 — Beam clipping
/// 
/// AdvancedSweptSolid Representation Type
/// The following attribute values for the
/// IfcShapeRepresentation holding this geometric representation
/// shall be used:
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'AdvancedSweptSolid'
/// 
/// The following additional constraints apply to the
/// 'AdvancedSweptSolid' representation type:
/// 
/// Solid: IfcSurfaceCurveSweptAreaSolid,
/// IfcFixedReferenceSweptAreaSolid,
/// IfcExtrudedAreaSolidTapered,
/// IfcRevolvedAreaSolidTapered shall be supported.
/// NOTE View definitions and implementer agreement
/// can further constrain the allowed swept solid
/// types.
/// 
/// Profile: see 'SweptSolid' geometric representation
/// Extrusion: not applicable
/// 
/// MappedRepresentation Representation Type
/// The 'MappedRepresentation' representation is supported as it
/// allows for reusing the geometry definition of the beam type at all
/// occurrences of the same type. The following attribute values for
/// the IfcShapeRepresentation holding this geometric
/// representation shall be used:
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'MappedRepresentation'
/// 
/// The same constraints, as given for the 'SweptSolid', 'Clipping',
/// 'AdvancedSweptSolid', 'SurfaceModel', and 'Brep' geometric
/// representation, shall apply to the MappedRepresentation of
/// the IfcRepresentationMap.
class IfcBeam : public IfcBuildingElement {
public:
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcBuildingElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcBuildingElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcBuildingElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcBeam (IfcAbstractEntity* e);
    IfcBeam (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag);
    typedef IfcTemplatedEntityList< IfcBeam > list;
};

class IfcChamferEdgeFeature : public IfcEdgeFeature {
public:
    /// Whether the optional attribute Width is defined for this IfcChamferEdgeFeature
    bool hasWidth() const;
    double Width() const;
    void setWidth(double v);
    /// Whether the optional attribute Height is defined for this IfcChamferEdgeFeature
    bool hasHeight() const;
    double Height() const;
    void setHeight(double v);
    virtual unsigned int getArgumentCount() const { return 11; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_DOUBLE; case 10: return IfcUtil::Argument_DOUBLE; } return IfcEdgeFeature::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcPositiveLengthMeasure; case 10: return Type::IfcPositiveLengthMeasure; } return IfcEdgeFeature::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "Width"; case 10: return "Height"; } return IfcEdgeFeature::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcChamferEdgeFeature (IfcAbstractEntity* e);
    IfcChamferEdgeFeature (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< double > v9_FeatureLength, boost::optional< double > v10_Width, boost::optional< double > v11_Height);
    typedef IfcTemplatedEntityList< IfcChamferEdgeFeature > list;
};
/// The distribution control element type IfcControllerType defines commonly shared information for occurrences of controllers.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a controller specification (i.e. the specific product information, that is common to all occurrences of that product type).  Controller types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcControllerType are represented by instances of IfcController. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcDistributionControlElementType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity according to the PredefinedType attribute:  
/// Pset_ControllerTypeCommon 
/// Pset_ControllerTypeFloating (FLOATING) 
/// Pset_ControllerTypeMultiPosition (MULTIPOSITION) 
/// Pset_ControllerTypeProgrammable (PROGRAMMABLE) 
/// Pset_ControllerTypeProportional (PROPORTIONAL) 
/// Pset_ControllerTypeTwoPosition (TWOPOSITION) 
/// 
/// Material Use Definition 
/// The material of the IfcControllerType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Casing': Material from which the casing is constructed. 
/// 
/// Composition Use Definition 
/// The IfcControllerType may be aggregated into components using IfcRelAggregates where RelatingObject refers to the enclosing IfcControllerType and RelatedObjects contains one or more components.  Components are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Aggregation use is defined for the following predefined types:
/// 
/// PROGRAMMABLE: May contain IfcController components.  Programmable Logic Controllers may be decomposed into logical elements for values and operations. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcControllerType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcController for standard port definitions.
class IfcControllerType : public IfcDistributionControlElementType {
public:
    /// Identifies the predefined types of controller from which the type required may be set.
    IfcControllerTypeEnum::IfcControllerTypeEnum PredefinedType() const;
    void setPredefinedType(IfcControllerTypeEnum::IfcControllerTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcDistributionControlElementType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcControllerTypeEnum; } return IfcDistributionControlElementType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcDistributionControlElementType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcControllerType (IfcAbstractEntity* e);
    IfcControllerType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcControllerTypeEnum::IfcControllerTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcControllerType > list;
};
/// A distribution chamber element defines a place at which distribution systems and their constituent elements may be inspected or through which they may travel.
/// 
/// An IfcDistributionChamberElement is a formed volume used in a distribution system, such as a sump, trench or manhole. Instances of IfcDistributionSystem or IfcDistributionFlowElement may be related to the IfcDistributionChamberElement enabling their location in or at the chamber to be determined.
/// 
/// HISTORY: New entity in IFC2x2
/// 
/// Type Use Definition
/// IfcDistributionChamberElement defines the occurrence of any distribution chamber element; common information about distribution chamber element types is handled by IfcDistributionChamberElementType.  The IfcDistributionChamberElementType (if present) may establish the common type name, usage (predefined type), properties, materials, ports, composition, assignments, and representations.  The IfcDistributionChamberElementType is attached using the IfcRelDefinesByType objectified relationship and is accessible by the IsTypedBy inverse attribute.  If the IfcDistributionChamberElementType has ports or aggregated elements, such objects are reflected at the IfcDistributionChamberElement occurrence using the IfcRelDefinesByObject relationship.
/// 
/// Property Set Use Definition
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the IfcRelDefinesByProperties relationship. They are accessible by the IsDefinedBy inverse attribute.  Property sets may also be specified at the IfcDistributionChamberElementType, defining the common property data for all occurrences of the same type.  They are then accessible by the IsTypedBy inverse attribute pointing to IfcDistributionChamberElementType.HasPropertySets. If both are given, then the properties directly defined at IfcDistributionChamberElement override the properties defined at IfcDistributionChamberElementType.  Refer to the documentation at the supertype IfcDistributionFlowElement and ancestors for inherited property set definitions.
/// The following property set definitions are applicable to this entity:
/// Pset_DistributionChamberElementCommon
/// 
/// The following property set definitions are applicable to this entity according to the PredefinedType attribute: 
/// Pset_DistributionChamberElementTypeFormedDuct (FORMEDDUCT)
/// Pset_DistributionChamberElementTypeInspectionChamber (INSPECTIONCHAMBER)
/// Pset_DistributionChamberElementTypeInspectionPit (INSPECTIONPIT)
/// Pset_DistributionChamberElementTypeManhole (MANHOLE)
/// Pset_DistributionChamberElementTypeMeterChamber (METERCHAMBER)
/// Pset_DistributionChamberElementTypeSump (SUMP)
/// Pset_DistributionChamberElementTypeTrench (TRENCH)
/// Pset_DistributionChamberElementTypeValveChamber (VALVECHAMBER)
/// 
/// Material Use Definition
/// The material of the IfcDistributionChamberElement is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.  Material information can also be given at the IfcDistributionChamberElementType, defining the common attribute data for all occurrences of the same type.  The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used:
/// 
/// 'Base': The material from which the base of the duct is constructed.
/// 'Cover': The material from which the access cover to the chamber is constructed.
/// 'Fill': The material that is used to fill the duct (where used).
/// 'Wall': The material from which the wall of the duct is constructed.
class IfcDistributionChamberElement : public IfcDistributionFlowElement {
public:
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcDistributionFlowElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcDistributionFlowElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcDistributionFlowElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcDistributionChamberElement (IfcAbstractEntity* e);
    IfcDistributionChamberElement (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag);
    typedef IfcTemplatedEntityList< IfcDistributionChamberElement > list;
};
/// The distribution element IfcDistributionControlElement defines occurrence elements of a building automation control system that are used to impart control over elements of a distribution system.
/// 
/// This class defines elements of a building automation control system. These are typically used to control distribution system elements to maintain  variables such as temperature, humidity, pressure, flow, power, or lighting levels, through the modulation, staging or sequencing of mechanical or electrical devices. The three general functional categories of control elements are as follows:
/// 
/// Impart control over flow control elements (IfcFlowController) in a distribution system such as dampers, valves, or relays, typically through the use of actuation (IfcActuator).
/// Sensing elements (IfcSensor) that measure changes in the controlled variable such as temperature, humidity, pressure, or flow.
/// Controllers (IfcController) typically classified according to the control action they seek to perform and generally responsible for making decisions about the elements under control.
/// 
/// Since this class and its subtypes typically relate to many different distribution flow elements (IfcDistributionFlowElement), the objectified relationship IfcRelFlowControlElements has been provided to relate control and flow elements as required.
/// 
/// IFC2x4 CHANGE: ControlElementId attribute deleted; replaced by classification usage.
/// HISTORY: New entity in IFC R2.0.
/// 
/// Type Use Definition
/// IfcDistributionControlElement defines the occurrence of any distribution control element; common information about distribution control element types is handled by IfcDistributionControlElementType.  The IfcDistributionControlElementType (if present) may establish the common type name, usage (predefined type), properties, materials, ports, composition, assignments, and representations.  The IfcDistributionControlElementType is attached using the IfcRelDefinesByType objectified relationship and is accessible by the IsTypedBy inverse attribute.  If the IfcDistributionControlElementType has ports or aggregated elements, such objects are reflected at the IfcDistributionControlElement occurrence using the IfcRelDefinesByObject relationship.  Direct instantiation of IfcDistributionControlElement with IfcObject.ObjectType asserted provides the meaning of a distribution control element proxy.
/// 
/// Property Set Use Definition
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the IfcRelDefinesByProperties relationship. They are accessible by the IsDefinedBy inverse attribute.  Property sets may also be specified at the IfcDistributionControlElementType, defining the common property data for all occurrences of the same type.  They are then accessible by the IsTypedBy inverse attribute pointing to IfcDistributionControlElementType.HasPropertySets. If both are given, then the properties directly defined at IfcDistributionControlElement override the properties defined at IfcDistributionControlElementType.  Refer to the documentation at the supertype IfcDistributionElement and ancestors for inherited property set definitions.
/// 
/// Classification Use Definition
/// In addition to general product and project classification (UniFormat, etc.), classifications may also be applied to indicate a device address or addressing scheme using IfcRelAssociatesClassification where RelatedObjects contains the  IfcDistributionControlElement and RelatingClassification refers to an IfcClassification or IfcClassificationReference.
/// 
/// IfcClassification: Indicates an addressing scheme managed by the device where ReferenceTokens defines the format of the address to be specified at IfcClassificationReference.ItemReference.  A classification hierarchy may optionally be provided indicating detected or provisioned device addresses.
/// IfcClassificationReference: Indicates the address of the control element where Identification uniquely identifies the element within the control system as determined by the ClassificationSource.  Several examples are illustrated:
/// 
/// 'BACnet': BACnetObjectIdentifier in the decimal form '12.15' (Digital Input #15) indicating type ID and instance ID.
/// 'IP': IP Address in the decimal form '192.168.1.2' such as for an IPv4 network.
/// 'OPC': Hierarchical ItemID in the alphanumeric form 'B204.Tank2.Temperature'
/// 'X-10': Alphabetic and numeric code in the form 'B12' (House B, Device 12) indicating House Code and Device Code.
/// 
/// Figure 147 illustrates classification usage.
/// 
/// Figure 147 — Distribution control classification
/// 
/// Composition Use Definition
/// The IfcDistributionControlElement may be decomposed into components using IfcRelAggregates where RelatingObject refers to the enclosing IfcDistributionControlElement and RelatedObjects contains one or more components.  Likewise, a control element may be aggregated within another element.  For example, a thermostat may contain temperature sensors, and a programmable logic controller may contain virtual (software-based) control elements.  Standard types for composition are defined at subtypes.
/// 
/// Connection Use Definition
/// The IfcDistributionControlElement may be connected to other objects as follows using the indicated relationship:
/// 
/// IfcSpatialStructureElement (IfcRelContainedInSpatialStructure) : Indicates the spatial location containing the element.  If an element is aggregated within another element, then only the top-level element participates in this relationship.
/// IfcElement (IfcRelConnectsElements) : Indicates physical connectivity with another element (but not embedding or flow control), such as a sensor attached to a wall.  IfcRelConnectsElements.RelatingElement refers to the anchored side (for example, wall hosting sensor).
/// IfcDistributionPort (IfcRelConnectsPortToElement) : Indicates ports on the element which may be connected to other elements for control signal transmission or electric power.  Standard port names, types, and directions are defined at subtypes.
/// IfcDistributionFlowElement (IfcRelFlowControlElements) : Indicates a flow element is sensed or controlled by the control element, such as a tank for a level sensor or a valve for an actuator.
/// 
/// Assignment Use Definition
/// The IfcDistributionControlElement may be assigned to the following entities using relationships as indicated:
/// 
/// IfcDistributionSystem (IfcRelAssignsToGroup): Indicates a system containing interconnected devices, where control elements are typically part of a control system having PredefinedType=CONTROL.
/// IfcPerformanceHistory (IfcRelAssignsToControl): Indicates realtime or historical infomation captured for the device.
/// 
/// The IfcDistributionControlElement may have assignments of its own using the IfcRelAssignsToProduct relationship where RelatingProduct refers to the IfcDistributionControlElement and RelatedObjects contains one or more objects of the following types: 
/// 
/// IfcTask: Indicates tasks used to purchase, install, renovate, demolish, operate, or otherwise act upon the element.  If the element has a type, available task types are assigned to the element type.
/// IfcProcedure: Indicates procedures used to operate the element.  If the element has a type, available procedure types are assigned to the element type.
/// IfcEvent: Indicates events raised by the element, sequenced by procedures to be followed.  If the element has a type, available event types are assigned to the element type.
/// 
/// Material Use Definition
/// The material of the IfcDistributionControlElement is defined using one of the following entities:
/// 
/// IfcMaterialConstituentSet: For elements containing multiple materials, this indicates materials at named aspects.
/// 
/// IfcMaterial: For elements comprised of a single material, this indicates the material.
/// 
/// The material is attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.  Material information can also be given at the IfcDistributionControlElementType, defining the common attribute data for all occurrences of the same type.  Standard names and material types are defined at subtypes.
/// 
/// Representation Use Definition
/// The following shape representations are supported for subtypes of IfcDistributionControlElement, distinguished by IfcShapeRepresentation.RepresentationIdentifier:
/// 
/// 'Footprint': Represents the 2D footprint outline of the item having IfcShapeRepresentation.RepresentationType of 'GeometricCurveSet' and containing a single IfcGeometricCurveSet consisting of one or more IfcCurve subtypes such as IfcPolyline, IfcTrimmedCurve, IfcCompositeCurve, or IfcCircle.
/// 
/// 'Body': Represents the 3D shape of the item having IfcShapeRepresentation.RepresentationType of 'SurfaceModel', 'SolidModel', or any solid model specializations including 'Brep', 'AdvancedBrep', 'SweptSolid', 'AdvancedSweptSolid', 'CSG', 'Clipping', or 'SectionedSpine').
/// 
/// 'Clearance': Represents the 3D clearance volume of the item having RepresentationType of 'Surface3D'.  Such clearance region indicates space that should not intersect with the 'Body' representation of other elements, though may intersect with the 'Clearance' representation of other elements.  The particular use of clearance space may be for safety, maintenance, or other purpose.
/// 
/// For all representations, if a IfcDistributionControlElement occurrence is defined by a IfcDistributionControlElementType having a representation of the same identifier, then 'MappedRepresentation' should be used at the occurrence unless overridden.
/// 
/// If materials are defined, geometry of each representation (most typically the 'Body' representation) may be organized into shape aspects where styles may be derived by correlating IfcShapeAspect.Name to a corresponding material (IfcMaterialConstituent.Name).
class IfcDistributionControlElement : public IfcDistributionElement {
public:
    /// Whether the optional attribute ControlElementId is defined for this IfcDistributionControlElement
    bool hasControlElementId() const;
    std::string ControlElementId() const;
    void setControlElementId(std::string v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_STRING; } return IfcDistributionElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcIdentifier; } return IfcDistributionElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "ControlElementId"; } return IfcDistributionElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcRelFlowControlElements >::ptr AssignedToFlowElement() const; // INVERSE IfcRelFlowControlElements::RelatedControlElements
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcDistributionControlElement (IfcAbstractEntity* e);
    IfcDistributionControlElement (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ControlElementId);
    typedef IfcTemplatedEntityList< IfcDistributionControlElement > list;
};

class IfcElectricDistributionPoint : public IfcFlowController {
public:
    IfcElectricDistributionPointFunctionEnum::IfcElectricDistributionPointFunctionEnum DistributionPointFunction() const;
    void setDistributionPointFunction(IfcElectricDistributionPointFunctionEnum::IfcElectricDistributionPointFunctionEnum v);
    /// Whether the optional attribute UserDefinedFunction is defined for this IfcElectricDistributionPoint
    bool hasUserDefinedFunction() const;
    std::string UserDefinedFunction() const;
    void setUserDefinedFunction(std::string v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; case 9: return IfcUtil::Argument_STRING; } return IfcFlowController::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcElectricDistributionPointFunctionEnum; case 9: return Type::IfcLabel; } return IfcFlowController::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "DistributionPointFunction"; case 9: return "UserDefinedFunction"; } return IfcFlowController::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcElectricDistributionPoint (IfcAbstractEntity* e);
    IfcElectricDistributionPoint (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, IfcElectricDistributionPointFunctionEnum::IfcElectricDistributionPointFunctionEnum v9_DistributionPointFunction, boost::optional< std::string > v10_UserDefinedFunction);
    typedef IfcTemplatedEntityList< IfcElectricDistributionPoint > list;
};
/// Definition from IAI: A steel bar, usually with manufactured deformations in the surface,
/// used in concrete and masonry construction to provide additional strength.  A single instance
/// of this class may represent one or many of actual rebars, for example a row of rebars.
/// 
/// HISTORY New entity in IFC Release 2x2
/// 
/// IFC 2x4 CHANGE All attributes removed; information now provided by IfcReinforcingBarType.
/// 
/// Geometry Use Definition
/// 
/// The geometric representation of IfcReinforcingBar is given by the IfcProductDefinitionShape,
/// allowing multiple geometric representations. Included are:
/// 
/// Local Placement
/// The use of local placement is defined at the supertype IfcElementComponent.
/// 
/// Multiple Mapped Representation
/// See supertype IfcElementComponent.  This method of representation allows for several rebars
/// represented by a single instance of IfcReinforcingBar.  The representation map should contain
/// one IfcSweptDiskSolidPolygonal.
/// 
/// An IfcElementQuantity,
/// attached via IfcRelDefinesByProperties, should contain an IfcQuantityCount named 'Count'
/// with the number rebars and, if this is a regularly spaced arrangement of rebars, an
/// IfcQuantityLength named 'Spacing' which expresses the center-to-center distances of bars.
/// 
/// Simplified Geometric Representation
/// Simplified geometric representations may be used based on local agreements.
class IfcReinforcingBar : public IfcReinforcingElement {
public:
    double NominalDiameter() const;
    void setNominalDiameter(double v);
    double CrossSectionArea() const;
    void setCrossSectionArea(double v);
    /// Whether the optional attribute BarLength is defined for this IfcReinforcingBar
    bool hasBarLength() const;
    double BarLength() const;
    void setBarLength(double v);
    IfcReinforcingBarRoleEnum::IfcReinforcingBarRoleEnum BarRole() const;
    void setBarRole(IfcReinforcingBarRoleEnum::IfcReinforcingBarRoleEnum v);
    /// Whether the optional attribute BarSurface is defined for this IfcReinforcingBar
    bool hasBarSurface() const;
    IfcReinforcingBarSurfaceEnum::IfcReinforcingBarSurfaceEnum BarSurface() const;
    void setBarSurface(IfcReinforcingBarSurfaceEnum::IfcReinforcingBarSurfaceEnum v);
    virtual unsigned int getArgumentCount() const { return 14; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_DOUBLE; case 10: return IfcUtil::Argument_DOUBLE; case 11: return IfcUtil::Argument_DOUBLE; case 12: return IfcUtil::Argument_ENUMERATION; case 13: return IfcUtil::Argument_ENUMERATION; } return IfcReinforcingElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcPositiveLengthMeasure; case 10: return Type::IfcAreaMeasure; case 11: return Type::IfcPositiveLengthMeasure; case 12: return Type::IfcReinforcingBarRoleEnum; case 13: return Type::IfcReinforcingBarSurfaceEnum; } return IfcReinforcingElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "NominalDiameter"; case 10: return "CrossSectionArea"; case 11: return "BarLength"; case 12: return "BarRole"; case 13: return "BarSurface"; } return IfcReinforcingElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcReinforcingBar (IfcAbstractEntity* e);
    IfcReinforcingBar (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_SteelGrade, double v10_NominalDiameter, double v11_CrossSectionArea, boost::optional< double > v12_BarLength, IfcReinforcingBarRoleEnum::IfcReinforcingBarRoleEnum v13_BarRole, boost::optional< IfcReinforcingBarSurfaceEnum::IfcReinforcingBarSurfaceEnum > v14_BarSurface);
    typedef IfcTemplatedEntityList< IfcReinforcingBar > list;
};

void InitStringMap();
IfcUtil::IfcBaseClass* SchemaEntity(IfcAbstractEntity* e = 0);
}

#endif
