/********************************************************************************
 *                                                                              *
 * This file is part of IfcOpenShell.                                           *
 *                                                                              *
 * IfcOpenShell is free software: you can redistribute it and/or modify         *
 * it under the terms of the Lesser GNU General Public License as published by  *
 * the Free Software Foundation, either version 3.0 of the License, or          *
 * (at your option) any later version.                                          *
 *                                                                              *
 * IfcOpenShell is distributed in the hope that it will be useful,              *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of               *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the                 *
 * Lesser GNU General Public License for more details.                          *
 *                                                                              *
 * You should have received a copy of the Lesser GNU General Public License     *
 * along with this program. If not, see <http://www.gnu.org/licenses/>.         *
 *                                                                              *
 ********************************************************************************/

/********************************************************************************
 *                                                                              *
 * This file has been generated from IFC4.exp. Do not make modifications        *
 * but instead modify the python script that has been used to generate this.    *
 *                                                                              *
 ********************************************************************************/

#ifdef USE_IFC4

#include <set>

#include "../ifcparse/Ifc4.h"
#include "../ifcparse/Ifc4-latebound.h"
#include "../ifcparse/IfcException.h"
#include "../ifcparse/IfcWrite.h"
#include "../ifcparse/IfcBaseClass.h"
#include "../ifcparse/IfcEntityDescriptor.h"

using namespace Ifc4;
using namespace IfcParse;
using namespace IfcWrite;
using namespace IfcUtil;

typedef std::map<Type::Enum,IfcEntityDescriptor*> entity_descriptor_map_t;
typedef std::map<Type::Enum,IfcEnumerationDescriptor*> enumeration_descriptor_map_t;
typedef std::map<Type::Enum, std::map<std::string, std::pair<Type::Enum, int> > > inverse_map_t;
typedef std::map<Type::Enum,std::set<int> > derived_map_t;

entity_descriptor_map_t entity_descriptor_map;
enumeration_descriptor_map_t enumeration_descriptor_map;
inverse_map_t inverse_map;
derived_map_t derived_map;


#ifdef _MSC_VER
#  pragma optimize( "", off )
#endif

void InitDescriptorMap() {
    IfcEntityDescriptor* current;
    current = entity_descriptor_map[Type::IfcAbsorbedDoseMeasure] = new IfcEntityDescriptor(Type::IfcAbsorbedDoseMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcAccelerationMeasure] = new IfcEntityDescriptor(Type::IfcAccelerationMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcAmountOfSubstanceMeasure] = new IfcEntityDescriptor(Type::IfcAmountOfSubstanceMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcAngularVelocityMeasure] = new IfcEntityDescriptor(Type::IfcAngularVelocityMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcArcIndex] = new IfcEntityDescriptor(Type::IfcArcIndex,0);
    current->add("wrappedValue",false,IfcUtil::Argument_AGGREGATE_OF_INT);
    current = entity_descriptor_map[Type::IfcAreaDensityMeasure] = new IfcEntityDescriptor(Type::IfcAreaDensityMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcAreaMeasure] = new IfcEntityDescriptor(Type::IfcAreaMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcBinary] = new IfcEntityDescriptor(Type::IfcBinary,0);
    current->add("wrappedValue",false,IfcUtil::Argument_BINARY);
    current = entity_descriptor_map[Type::IfcBoolean] = new IfcEntityDescriptor(Type::IfcBoolean,0);
    current->add("wrappedValue",false,IfcUtil::Argument_BOOL);
    current = entity_descriptor_map[Type::IfcBoxAlignment] = new IfcEntityDescriptor(Type::IfcBoxAlignment,0);
    current->add("wrappedValue",false,IfcUtil::Argument_STRING);
    current = entity_descriptor_map[Type::IfcCardinalPointReference] = new IfcEntityDescriptor(Type::IfcCardinalPointReference,0);
    current->add("wrappedValue",false,IfcUtil::Argument_INT);
    current = entity_descriptor_map[Type::IfcComplexNumber] = new IfcEntityDescriptor(Type::IfcComplexNumber,0);
    current->add("wrappedValue",false,IfcUtil::Argument_AGGREGATE_OF_DOUBLE);
    current = entity_descriptor_map[Type::IfcCompoundPlaneAngleMeasure] = new IfcEntityDescriptor(Type::IfcCompoundPlaneAngleMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_AGGREGATE_OF_INT);
    current = entity_descriptor_map[Type::IfcContextDependentMeasure] = new IfcEntityDescriptor(Type::IfcContextDependentMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcCountMeasure] = new IfcEntityDescriptor(Type::IfcCountMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcCurvatureMeasure] = new IfcEntityDescriptor(Type::IfcCurvatureMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcDate] = new IfcEntityDescriptor(Type::IfcDate,0);
    current->add("wrappedValue",false,IfcUtil::Argument_STRING);
    current = entity_descriptor_map[Type::IfcDateTime] = new IfcEntityDescriptor(Type::IfcDateTime,0);
    current->add("wrappedValue",false,IfcUtil::Argument_STRING);
    current = entity_descriptor_map[Type::IfcDayInMonthNumber] = new IfcEntityDescriptor(Type::IfcDayInMonthNumber,0);
    current->add("wrappedValue",false,IfcUtil::Argument_INT);
    current = entity_descriptor_map[Type::IfcDayInWeekNumber] = new IfcEntityDescriptor(Type::IfcDayInWeekNumber,0);
    current->add("wrappedValue",false,IfcUtil::Argument_INT);
    current = entity_descriptor_map[Type::IfcDescriptiveMeasure] = new IfcEntityDescriptor(Type::IfcDescriptiveMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_STRING);
    current = entity_descriptor_map[Type::IfcDimensionCount] = new IfcEntityDescriptor(Type::IfcDimensionCount,0);
    current->add("wrappedValue",false,IfcUtil::Argument_INT);
    current = entity_descriptor_map[Type::IfcDoseEquivalentMeasure] = new IfcEntityDescriptor(Type::IfcDoseEquivalentMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcDuration] = new IfcEntityDescriptor(Type::IfcDuration,0);
    current->add("wrappedValue",false,IfcUtil::Argument_STRING);
    current = entity_descriptor_map[Type::IfcDynamicViscosityMeasure] = new IfcEntityDescriptor(Type::IfcDynamicViscosityMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcElectricCapacitanceMeasure] = new IfcEntityDescriptor(Type::IfcElectricCapacitanceMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcElectricChargeMeasure] = new IfcEntityDescriptor(Type::IfcElectricChargeMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcElectricConductanceMeasure] = new IfcEntityDescriptor(Type::IfcElectricConductanceMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcElectricCurrentMeasure] = new IfcEntityDescriptor(Type::IfcElectricCurrentMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcElectricResistanceMeasure] = new IfcEntityDescriptor(Type::IfcElectricResistanceMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcElectricVoltageMeasure] = new IfcEntityDescriptor(Type::IfcElectricVoltageMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcEnergyMeasure] = new IfcEntityDescriptor(Type::IfcEnergyMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcFontStyle] = new IfcEntityDescriptor(Type::IfcFontStyle,0);
    current->add("wrappedValue",false,IfcUtil::Argument_STRING);
    current = entity_descriptor_map[Type::IfcFontVariant] = new IfcEntityDescriptor(Type::IfcFontVariant,0);
    current->add("wrappedValue",false,IfcUtil::Argument_STRING);
    current = entity_descriptor_map[Type::IfcFontWeight] = new IfcEntityDescriptor(Type::IfcFontWeight,0);
    current->add("wrappedValue",false,IfcUtil::Argument_STRING);
    current = entity_descriptor_map[Type::IfcForceMeasure] = new IfcEntityDescriptor(Type::IfcForceMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcFrequencyMeasure] = new IfcEntityDescriptor(Type::IfcFrequencyMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcGloballyUniqueId] = new IfcEntityDescriptor(Type::IfcGloballyUniqueId,0);
    current->add("wrappedValue",false,IfcUtil::Argument_STRING);
    current = entity_descriptor_map[Type::IfcHeatFluxDensityMeasure] = new IfcEntityDescriptor(Type::IfcHeatFluxDensityMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcHeatingValueMeasure] = new IfcEntityDescriptor(Type::IfcHeatingValueMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcIdentifier] = new IfcEntityDescriptor(Type::IfcIdentifier,0);
    current->add("wrappedValue",false,IfcUtil::Argument_STRING);
    current = entity_descriptor_map[Type::IfcIlluminanceMeasure] = new IfcEntityDescriptor(Type::IfcIlluminanceMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcInductanceMeasure] = new IfcEntityDescriptor(Type::IfcInductanceMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcInteger] = new IfcEntityDescriptor(Type::IfcInteger,0);
    current->add("wrappedValue",false,IfcUtil::Argument_INT);
    current = entity_descriptor_map[Type::IfcIntegerCountRateMeasure] = new IfcEntityDescriptor(Type::IfcIntegerCountRateMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_INT);
    current = entity_descriptor_map[Type::IfcIonConcentrationMeasure] = new IfcEntityDescriptor(Type::IfcIonConcentrationMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcIsothermalMoistureCapacityMeasure] = new IfcEntityDescriptor(Type::IfcIsothermalMoistureCapacityMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcKinematicViscosityMeasure] = new IfcEntityDescriptor(Type::IfcKinematicViscosityMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcLabel] = new IfcEntityDescriptor(Type::IfcLabel,0);
    current->add("wrappedValue",false,IfcUtil::Argument_STRING);
    current = entity_descriptor_map[Type::IfcLanguageId] = new IfcEntityDescriptor(Type::IfcLanguageId,0);
    current->add("wrappedValue",false,IfcUtil::Argument_STRING);
    current = entity_descriptor_map[Type::IfcLengthMeasure] = new IfcEntityDescriptor(Type::IfcLengthMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcLineIndex] = new IfcEntityDescriptor(Type::IfcLineIndex,0);
    current->add("wrappedValue",false,IfcUtil::Argument_AGGREGATE_OF_INT);
    current = entity_descriptor_map[Type::IfcLinearForceMeasure] = new IfcEntityDescriptor(Type::IfcLinearForceMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcLinearMomentMeasure] = new IfcEntityDescriptor(Type::IfcLinearMomentMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcLinearStiffnessMeasure] = new IfcEntityDescriptor(Type::IfcLinearStiffnessMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcLinearVelocityMeasure] = new IfcEntityDescriptor(Type::IfcLinearVelocityMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcLogical] = new IfcEntityDescriptor(Type::IfcLogical,0);
    current->add("wrappedValue",false,IfcUtil::Argument_BOOL);
    current = entity_descriptor_map[Type::IfcLuminousFluxMeasure] = new IfcEntityDescriptor(Type::IfcLuminousFluxMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcLuminousIntensityDistributionMeasure] = new IfcEntityDescriptor(Type::IfcLuminousIntensityDistributionMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcLuminousIntensityMeasure] = new IfcEntityDescriptor(Type::IfcLuminousIntensityMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcMagneticFluxDensityMeasure] = new IfcEntityDescriptor(Type::IfcMagneticFluxDensityMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcMagneticFluxMeasure] = new IfcEntityDescriptor(Type::IfcMagneticFluxMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcMassDensityMeasure] = new IfcEntityDescriptor(Type::IfcMassDensityMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcMassFlowRateMeasure] = new IfcEntityDescriptor(Type::IfcMassFlowRateMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcMassMeasure] = new IfcEntityDescriptor(Type::IfcMassMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcMassPerLengthMeasure] = new IfcEntityDescriptor(Type::IfcMassPerLengthMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcModulusOfElasticityMeasure] = new IfcEntityDescriptor(Type::IfcModulusOfElasticityMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcModulusOfLinearSubgradeReactionMeasure] = new IfcEntityDescriptor(Type::IfcModulusOfLinearSubgradeReactionMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcModulusOfRotationalSubgradeReactionMeasure] = new IfcEntityDescriptor(Type::IfcModulusOfRotationalSubgradeReactionMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcModulusOfSubgradeReactionMeasure] = new IfcEntityDescriptor(Type::IfcModulusOfSubgradeReactionMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcMoistureDiffusivityMeasure] = new IfcEntityDescriptor(Type::IfcMoistureDiffusivityMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcMolecularWeightMeasure] = new IfcEntityDescriptor(Type::IfcMolecularWeightMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcMomentOfInertiaMeasure] = new IfcEntityDescriptor(Type::IfcMomentOfInertiaMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcMonetaryMeasure] = new IfcEntityDescriptor(Type::IfcMonetaryMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcMonthInYearNumber] = new IfcEntityDescriptor(Type::IfcMonthInYearNumber,0);
    current->add("wrappedValue",false,IfcUtil::Argument_INT);
    current = entity_descriptor_map[Type::IfcNonNegativeLengthMeasure] = new IfcEntityDescriptor(Type::IfcNonNegativeLengthMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcNormalisedRatioMeasure] = new IfcEntityDescriptor(Type::IfcNormalisedRatioMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcNumericMeasure] = new IfcEntityDescriptor(Type::IfcNumericMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcPHMeasure] = new IfcEntityDescriptor(Type::IfcPHMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcParameterValue] = new IfcEntityDescriptor(Type::IfcParameterValue,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcPlanarForceMeasure] = new IfcEntityDescriptor(Type::IfcPlanarForceMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcPlaneAngleMeasure] = new IfcEntityDescriptor(Type::IfcPlaneAngleMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcPositiveInteger] = new IfcEntityDescriptor(Type::IfcPositiveInteger,0);
    current->add("wrappedValue",false,IfcUtil::Argument_INT);
    current = entity_descriptor_map[Type::IfcPositiveLengthMeasure] = new IfcEntityDescriptor(Type::IfcPositiveLengthMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcPositivePlaneAngleMeasure] = new IfcEntityDescriptor(Type::IfcPositivePlaneAngleMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcPositiveRatioMeasure] = new IfcEntityDescriptor(Type::IfcPositiveRatioMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcPowerMeasure] = new IfcEntityDescriptor(Type::IfcPowerMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcPresentableText] = new IfcEntityDescriptor(Type::IfcPresentableText,0);
    current->add("wrappedValue",false,IfcUtil::Argument_STRING);
    current = entity_descriptor_map[Type::IfcPressureMeasure] = new IfcEntityDescriptor(Type::IfcPressureMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcPropertySetDefinitionSet] = new IfcEntityDescriptor(Type::IfcPropertySetDefinitionSet,0);
    current->add("wrappedValue",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE);
    current = entity_descriptor_map[Type::IfcRadioActivityMeasure] = new IfcEntityDescriptor(Type::IfcRadioActivityMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcRatioMeasure] = new IfcEntityDescriptor(Type::IfcRatioMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcReal] = new IfcEntityDescriptor(Type::IfcReal,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcRotationalFrequencyMeasure] = new IfcEntityDescriptor(Type::IfcRotationalFrequencyMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcRotationalMassMeasure] = new IfcEntityDescriptor(Type::IfcRotationalMassMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcRotationalStiffnessMeasure] = new IfcEntityDescriptor(Type::IfcRotationalStiffnessMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcSectionModulusMeasure] = new IfcEntityDescriptor(Type::IfcSectionModulusMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcSectionalAreaIntegralMeasure] = new IfcEntityDescriptor(Type::IfcSectionalAreaIntegralMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcShearModulusMeasure] = new IfcEntityDescriptor(Type::IfcShearModulusMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcSolidAngleMeasure] = new IfcEntityDescriptor(Type::IfcSolidAngleMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcSoundPowerLevelMeasure] = new IfcEntityDescriptor(Type::IfcSoundPowerLevelMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcSoundPowerMeasure] = new IfcEntityDescriptor(Type::IfcSoundPowerMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcSoundPressureLevelMeasure] = new IfcEntityDescriptor(Type::IfcSoundPressureLevelMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcSoundPressureMeasure] = new IfcEntityDescriptor(Type::IfcSoundPressureMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcSpecificHeatCapacityMeasure] = new IfcEntityDescriptor(Type::IfcSpecificHeatCapacityMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcSpecularExponent] = new IfcEntityDescriptor(Type::IfcSpecularExponent,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcSpecularRoughness] = new IfcEntityDescriptor(Type::IfcSpecularRoughness,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcStrippedOptional] = new IfcEntityDescriptor(Type::IfcStrippedOptional,0);
    current->add("wrappedValue",false,IfcUtil::Argument_BOOL);
    current = entity_descriptor_map[Type::IfcTemperatureGradientMeasure] = new IfcEntityDescriptor(Type::IfcTemperatureGradientMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcTemperatureRateOfChangeMeasure] = new IfcEntityDescriptor(Type::IfcTemperatureRateOfChangeMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcText] = new IfcEntityDescriptor(Type::IfcText,0);
    current->add("wrappedValue",false,IfcUtil::Argument_STRING);
    current = entity_descriptor_map[Type::IfcTextAlignment] = new IfcEntityDescriptor(Type::IfcTextAlignment,0);
    current->add("wrappedValue",false,IfcUtil::Argument_STRING);
    current = entity_descriptor_map[Type::IfcTextDecoration] = new IfcEntityDescriptor(Type::IfcTextDecoration,0);
    current->add("wrappedValue",false,IfcUtil::Argument_STRING);
    current = entity_descriptor_map[Type::IfcTextFontName] = new IfcEntityDescriptor(Type::IfcTextFontName,0);
    current->add("wrappedValue",false,IfcUtil::Argument_STRING);
    current = entity_descriptor_map[Type::IfcTextTransformation] = new IfcEntityDescriptor(Type::IfcTextTransformation,0);
    current->add("wrappedValue",false,IfcUtil::Argument_STRING);
    current = entity_descriptor_map[Type::IfcThermalAdmittanceMeasure] = new IfcEntityDescriptor(Type::IfcThermalAdmittanceMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcThermalConductivityMeasure] = new IfcEntityDescriptor(Type::IfcThermalConductivityMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcThermalExpansionCoefficientMeasure] = new IfcEntityDescriptor(Type::IfcThermalExpansionCoefficientMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcThermalResistanceMeasure] = new IfcEntityDescriptor(Type::IfcThermalResistanceMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcThermalTransmittanceMeasure] = new IfcEntityDescriptor(Type::IfcThermalTransmittanceMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcThermodynamicTemperatureMeasure] = new IfcEntityDescriptor(Type::IfcThermodynamicTemperatureMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcTime] = new IfcEntityDescriptor(Type::IfcTime,0);
    current->add("wrappedValue",false,IfcUtil::Argument_STRING);
    current = entity_descriptor_map[Type::IfcTimeMeasure] = new IfcEntityDescriptor(Type::IfcTimeMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcTimeStamp] = new IfcEntityDescriptor(Type::IfcTimeStamp,0);
    current->add("wrappedValue",false,IfcUtil::Argument_INT);
    current = entity_descriptor_map[Type::IfcTorqueMeasure] = new IfcEntityDescriptor(Type::IfcTorqueMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcURIReference] = new IfcEntityDescriptor(Type::IfcURIReference,0);
    current->add("wrappedValue",false,IfcUtil::Argument_STRING);
    current = entity_descriptor_map[Type::IfcVaporPermeabilityMeasure] = new IfcEntityDescriptor(Type::IfcVaporPermeabilityMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcVolumeMeasure] = new IfcEntityDescriptor(Type::IfcVolumeMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcVolumetricFlowRateMeasure] = new IfcEntityDescriptor(Type::IfcVolumetricFlowRateMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcWarpingConstantMeasure] = new IfcEntityDescriptor(Type::IfcWarpingConstantMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcWarpingMomentMeasure] = new IfcEntityDescriptor(Type::IfcWarpingMomentMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcActorRole] = new IfcEntityDescriptor(Type::IfcActorRole,0);
    current->add("Role",false,IfcUtil::Argument_ENUMERATION,Type::IfcRoleEnum);
    current->add("UserDefinedRole",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("Description",true,IfcUtil::Argument_STRING,Type::IfcText);
    current = entity_descriptor_map[Type::IfcAddress] = new IfcEntityDescriptor(Type::IfcAddress,0);
    current->add("Purpose",true,IfcUtil::Argument_ENUMERATION,Type::IfcAddressTypeEnum);
    current->add("Description",true,IfcUtil::Argument_STRING,Type::IfcText);
    current->add("UserDefinedPurpose",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current = entity_descriptor_map[Type::IfcApplication] = new IfcEntityDescriptor(Type::IfcApplication,0);
    current->add("ApplicationDeveloper",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcOrganization);
    current->add("Version",false,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("ApplicationFullName",false,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("ApplicationIdentifier",false,IfcUtil::Argument_STRING,Type::IfcIdentifier);
    current = entity_descriptor_map[Type::IfcAppliedValue] = new IfcEntityDescriptor(Type::IfcAppliedValue,0);
    current->add("Name",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("Description",true,IfcUtil::Argument_STRING,Type::IfcText);
    current->add("AppliedValue",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcAppliedValueSelect);
    current->add("UnitBasis",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcMeasureWithUnit);
    current->add("ApplicableDate",true,IfcUtil::Argument_STRING,Type::IfcDate);
    current->add("FixedUntilDate",true,IfcUtil::Argument_STRING,Type::IfcDate);
    current->add("Category",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("Condition",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("ArithmeticOperator",true,IfcUtil::Argument_ENUMERATION,Type::IfcArithmeticOperatorEnum);
    current->add("Components",true,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcAppliedValue);
    current = entity_descriptor_map[Type::IfcApproval] = new IfcEntityDescriptor(Type::IfcApproval,0);
    current->add("Identifier",true,IfcUtil::Argument_STRING,Type::IfcIdentifier);
    current->add("Name",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("Description",true,IfcUtil::Argument_STRING,Type::IfcText);
    current->add("TimeOfApproval",true,IfcUtil::Argument_STRING,Type::IfcDateTime);
    current->add("Status",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("Level",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("Qualifier",true,IfcUtil::Argument_STRING,Type::IfcText);
    current->add("RequestingApproval",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcActorSelect);
    current->add("GivingApproval",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcActorSelect);
    current = entity_descriptor_map[Type::IfcBoundaryCondition] = new IfcEntityDescriptor(Type::IfcBoundaryCondition,0);
    current->add("Name",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current = entity_descriptor_map[Type::IfcBoundaryEdgeCondition] = new IfcEntityDescriptor(Type::IfcBoundaryEdgeCondition,entity_descriptor_map.find(Type::IfcBoundaryCondition)->second);
    current->add("TranslationalStiffnessByLengthX",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcModulusOfTranslationalSubgradeReactionSelect);
    current->add("TranslationalStiffnessByLengthY",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcModulusOfTranslationalSubgradeReactionSelect);
    current->add("TranslationalStiffnessByLengthZ",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcModulusOfTranslationalSubgradeReactionSelect);
    current->add("RotationalStiffnessByLengthX",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcModulusOfRotationalSubgradeReactionSelect);
    current->add("RotationalStiffnessByLengthY",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcModulusOfRotationalSubgradeReactionSelect);
    current->add("RotationalStiffnessByLengthZ",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcModulusOfRotationalSubgradeReactionSelect);
    current = entity_descriptor_map[Type::IfcBoundaryFaceCondition] = new IfcEntityDescriptor(Type::IfcBoundaryFaceCondition,entity_descriptor_map.find(Type::IfcBoundaryCondition)->second);
    current->add("TranslationalStiffnessByAreaX",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcModulusOfSubgradeReactionSelect);
    current->add("TranslationalStiffnessByAreaY",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcModulusOfSubgradeReactionSelect);
    current->add("TranslationalStiffnessByAreaZ",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcModulusOfSubgradeReactionSelect);
    current = entity_descriptor_map[Type::IfcBoundaryNodeCondition] = new IfcEntityDescriptor(Type::IfcBoundaryNodeCondition,entity_descriptor_map.find(Type::IfcBoundaryCondition)->second);
    current->add("TranslationalStiffnessX",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcTranslationalStiffnessSelect);
    current->add("TranslationalStiffnessY",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcTranslationalStiffnessSelect);
    current->add("TranslationalStiffnessZ",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcTranslationalStiffnessSelect);
    current->add("RotationalStiffnessX",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcRotationalStiffnessSelect);
    current->add("RotationalStiffnessY",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcRotationalStiffnessSelect);
    current->add("RotationalStiffnessZ",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcRotationalStiffnessSelect);
    current = entity_descriptor_map[Type::IfcBoundaryNodeConditionWarping] = new IfcEntityDescriptor(Type::IfcBoundaryNodeConditionWarping,entity_descriptor_map.find(Type::IfcBoundaryNodeCondition)->second);
    current->add("WarpingStiffness",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcWarpingStiffnessSelect);
    current = entity_descriptor_map[Type::IfcConnectionGeometry] = new IfcEntityDescriptor(Type::IfcConnectionGeometry,0);

    current = entity_descriptor_map[Type::IfcConnectionPointGeometry] = new IfcEntityDescriptor(Type::IfcConnectionPointGeometry,entity_descriptor_map.find(Type::IfcConnectionGeometry)->second);
    current->add("PointOnRelatingElement",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcPointOrVertexPoint);
    current->add("PointOnRelatedElement",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcPointOrVertexPoint);
    current = entity_descriptor_map[Type::IfcConnectionSurfaceGeometry] = new IfcEntityDescriptor(Type::IfcConnectionSurfaceGeometry,entity_descriptor_map.find(Type::IfcConnectionGeometry)->second);
    current->add("SurfaceOnRelatingElement",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcSurfaceOrFaceSurface);
    current->add("SurfaceOnRelatedElement",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcSurfaceOrFaceSurface);
    current = entity_descriptor_map[Type::IfcConnectionVolumeGeometry] = new IfcEntityDescriptor(Type::IfcConnectionVolumeGeometry,entity_descriptor_map.find(Type::IfcConnectionGeometry)->second);
    current->add("VolumeOnRelatingElement",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcSolidOrShell);
    current->add("VolumeOnRelatedElement",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcSolidOrShell);
    current = entity_descriptor_map[Type::IfcConstraint] = new IfcEntityDescriptor(Type::IfcConstraint,0);
    current->add("Name",false,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("Description",true,IfcUtil::Argument_STRING,Type::IfcText);
    current->add("ConstraintGrade",false,IfcUtil::Argument_ENUMERATION,Type::IfcConstraintEnum);
    current->add("ConstraintSource",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("CreatingActor",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcActorSelect);
    current->add("CreationTime",true,IfcUtil::Argument_STRING,Type::IfcDateTime);
    current->add("UserDefinedGrade",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current = entity_descriptor_map[Type::IfcCoordinateOperation] = new IfcEntityDescriptor(Type::IfcCoordinateOperation,0);
    current->add("SourceCRS",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcCoordinateReferenceSystemSelect);
    current->add("TargetCRS",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcCoordinateReferenceSystem);
    current = entity_descriptor_map[Type::IfcCoordinateReferenceSystem] = new IfcEntityDescriptor(Type::IfcCoordinateReferenceSystem,0);
    current->add("Name",false,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("Description",true,IfcUtil::Argument_STRING,Type::IfcText);
    current->add("GeodeticDatum",true,IfcUtil::Argument_STRING,Type::IfcIdentifier);
    current->add("VerticalDatum",true,IfcUtil::Argument_STRING,Type::IfcIdentifier);
    current = entity_descriptor_map[Type::IfcCostValue] = new IfcEntityDescriptor(Type::IfcCostValue,entity_descriptor_map.find(Type::IfcAppliedValue)->second);

    current = entity_descriptor_map[Type::IfcDerivedUnit] = new IfcEntityDescriptor(Type::IfcDerivedUnit,0);
    current->add("Elements",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcDerivedUnitElement);
    current->add("UnitType",false,IfcUtil::Argument_ENUMERATION,Type::IfcDerivedUnitEnum);
    current->add("UserDefinedType",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current = entity_descriptor_map[Type::IfcDerivedUnitElement] = new IfcEntityDescriptor(Type::IfcDerivedUnitElement,0);
    current->add("Unit",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcNamedUnit);
    current->add("Exponent",false,IfcUtil::Argument_INT,Type::UNDEFINED);
    current = entity_descriptor_map[Type::IfcDimensionalExponents] = new IfcEntityDescriptor(Type::IfcDimensionalExponents,0);
    current->add("LengthExponent",false,IfcUtil::Argument_INT,Type::UNDEFINED);
    current->add("MassExponent",false,IfcUtil::Argument_INT,Type::UNDEFINED);
    current->add("TimeExponent",false,IfcUtil::Argument_INT,Type::UNDEFINED);
    current->add("ElectricCurrentExponent",false,IfcUtil::Argument_INT,Type::UNDEFINED);
    current->add("ThermodynamicTemperatureExponent",false,IfcUtil::Argument_INT,Type::UNDEFINED);
    current->add("AmountOfSubstanceExponent",false,IfcUtil::Argument_INT,Type::UNDEFINED);
    current->add("LuminousIntensityExponent",false,IfcUtil::Argument_INT,Type::UNDEFINED);
    current = entity_descriptor_map[Type::IfcExternalInformation] = new IfcEntityDescriptor(Type::IfcExternalInformation,0);

    current = entity_descriptor_map[Type::IfcExternalReference] = new IfcEntityDescriptor(Type::IfcExternalReference,0);
    current->add("Location",true,IfcUtil::Argument_STRING,Type::IfcURIReference);
    current->add("Identification",true,IfcUtil::Argument_STRING,Type::IfcIdentifier);
    current->add("Name",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current = entity_descriptor_map[Type::IfcExternallyDefinedHatchStyle] = new IfcEntityDescriptor(Type::IfcExternallyDefinedHatchStyle,entity_descriptor_map.find(Type::IfcExternalReference)->second);

    current = entity_descriptor_map[Type::IfcExternallyDefinedSurfaceStyle] = new IfcEntityDescriptor(Type::IfcExternallyDefinedSurfaceStyle,entity_descriptor_map.find(Type::IfcExternalReference)->second);

    current = entity_descriptor_map[Type::IfcExternallyDefinedTextFont] = new IfcEntityDescriptor(Type::IfcExternallyDefinedTextFont,entity_descriptor_map.find(Type::IfcExternalReference)->second);

    current = entity_descriptor_map[Type::IfcGridAxis] = new IfcEntityDescriptor(Type::IfcGridAxis,0);
    current->add("AxisTag",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("AxisCurve",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcCurve);
    current->add("SameSense",false,IfcUtil::Argument_BOOL,Type::IfcBoolean);
    current = entity_descriptor_map[Type::IfcIrregularTimeSeriesValue] = new IfcEntityDescriptor(Type::IfcIrregularTimeSeriesValue,0);
    current->add("TimeStamp",false,IfcUtil::Argument_STRING,Type::IfcDateTime);
    current->add("ListValues",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcValue);
    current = entity_descriptor_map[Type::IfcLibraryInformation] = new IfcEntityDescriptor(Type::IfcLibraryInformation,entity_descriptor_map.find(Type::IfcExternalInformation)->second);
    current->add("Name",false,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("Version",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("Publisher",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcActorSelect);
    current->add("VersionDate",true,IfcUtil::Argument_STRING,Type::IfcDateTime);
    current->add("Location",true,IfcUtil::Argument_STRING,Type::IfcURIReference);
    current->add("Description",true,IfcUtil::Argument_STRING,Type::IfcText);
    current = entity_descriptor_map[Type::IfcLibraryReference] = new IfcEntityDescriptor(Type::IfcLibraryReference,entity_descriptor_map.find(Type::IfcExternalReference)->second);
    current->add("Description",true,IfcUtil::Argument_STRING,Type::IfcText);
    current->add("Language",true,IfcUtil::Argument_STRING,Type::IfcLanguageId);
    current->add("ReferencedLibrary",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcLibraryInformation);
    current = entity_descriptor_map[Type::IfcLightDistributionData] = new IfcEntityDescriptor(Type::IfcLightDistributionData,0);
    current->add("MainPlaneAngle",false,IfcUtil::Argument_DOUBLE,Type::IfcPlaneAngleMeasure);
    current->add("SecondaryPlaneAngle",false,IfcUtil::Argument_AGGREGATE_OF_DOUBLE,Type::IfcPlaneAngleMeasure);
    current->add("LuminousIntensity",false,IfcUtil::Argument_AGGREGATE_OF_DOUBLE,Type::IfcLuminousIntensityDistributionMeasure);
    current = entity_descriptor_map[Type::IfcLightIntensityDistribution] = new IfcEntityDescriptor(Type::IfcLightIntensityDistribution,0);
    current->add("LightDistributionCurve",false,IfcUtil::Argument_ENUMERATION,Type::IfcLightDistributionCurveEnum);
    current->add("DistributionData",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcLightDistributionData);
    current = entity_descriptor_map[Type::IfcMapConversion] = new IfcEntityDescriptor(Type::IfcMapConversion,entity_descriptor_map.find(Type::IfcCoordinateOperation)->second);
    current->add("Eastings",false,IfcUtil::Argument_DOUBLE,Type::IfcLengthMeasure);
    current->add("Northings",false,IfcUtil::Argument_DOUBLE,Type::IfcLengthMeasure);
    current->add("OrthogonalHeight",false,IfcUtil::Argument_DOUBLE,Type::IfcLengthMeasure);
    current->add("XAxisAbscissa",true,IfcUtil::Argument_DOUBLE,Type::IfcReal);
    current->add("XAxisOrdinate",true,IfcUtil::Argument_DOUBLE,Type::IfcReal);
    current->add("Scale",true,IfcUtil::Argument_DOUBLE,Type::IfcReal);
    current = entity_descriptor_map[Type::IfcMaterialClassificationRelationship] = new IfcEntityDescriptor(Type::IfcMaterialClassificationRelationship,0);
    current->add("MaterialClassifications",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcClassificationSelect);
    current->add("ClassifiedMaterial",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcMaterial);
    current = entity_descriptor_map[Type::IfcMaterialDefinition] = new IfcEntityDescriptor(Type::IfcMaterialDefinition,0);

    current = entity_descriptor_map[Type::IfcMaterialLayer] = new IfcEntityDescriptor(Type::IfcMaterialLayer,entity_descriptor_map.find(Type::IfcMaterialDefinition)->second);
    current->add("Material",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcMaterial);
    current->add("LayerThickness",false,IfcUtil::Argument_DOUBLE,Type::IfcNonNegativeLengthMeasure);
    current->add("IsVentilated",true,IfcUtil::Argument_BOOL,Type::IfcLogical);
    current->add("Name",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("Description",true,IfcUtil::Argument_STRING,Type::IfcText);
    current->add("Category",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("Priority",true,IfcUtil::Argument_INT,Type::IfcInteger);
    current = entity_descriptor_map[Type::IfcMaterialLayerSet] = new IfcEntityDescriptor(Type::IfcMaterialLayerSet,entity_descriptor_map.find(Type::IfcMaterialDefinition)->second);
    current->add("MaterialLayers",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcMaterialLayer);
    current->add("LayerSetName",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("Description",true,IfcUtil::Argument_STRING,Type::IfcText);
    current = entity_descriptor_map[Type::IfcMaterialLayerWithOffsets] = new IfcEntityDescriptor(Type::IfcMaterialLayerWithOffsets,entity_descriptor_map.find(Type::IfcMaterialLayer)->second);
    current->add("OffsetDirection",false,IfcUtil::Argument_ENUMERATION,Type::IfcLayerSetDirectionEnum);
    current->add("OffsetValues",false,IfcUtil::Argument_AGGREGATE_OF_DOUBLE,Type::IfcLengthMeasure);
    current = entity_descriptor_map[Type::IfcMaterialList] = new IfcEntityDescriptor(Type::IfcMaterialList,0);
    current->add("Materials",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcMaterial);
    current = entity_descriptor_map[Type::IfcMaterialProfile] = new IfcEntityDescriptor(Type::IfcMaterialProfile,entity_descriptor_map.find(Type::IfcMaterialDefinition)->second);
    current->add("Name",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("Description",true,IfcUtil::Argument_STRING,Type::IfcText);
    current->add("Material",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcMaterial);
    current->add("Profile",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcProfileDef);
    current->add("Priority",true,IfcUtil::Argument_INT,Type::IfcInteger);
    current->add("Category",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current = entity_descriptor_map[Type::IfcMaterialProfileSet] = new IfcEntityDescriptor(Type::IfcMaterialProfileSet,entity_descriptor_map.find(Type::IfcMaterialDefinition)->second);
    current->add("Name",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("Description",true,IfcUtil::Argument_STRING,Type::IfcText);
    current->add("MaterialProfiles",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcMaterialProfile);
    current->add("CompositeProfile",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcCompositeProfileDef);
    current = entity_descriptor_map[Type::IfcMaterialProfileWithOffsets] = new IfcEntityDescriptor(Type::IfcMaterialProfileWithOffsets,entity_descriptor_map.find(Type::IfcMaterialProfile)->second);
    current->add("OffsetValues",false,IfcUtil::Argument_AGGREGATE_OF_DOUBLE,Type::IfcLengthMeasure);
    current = entity_descriptor_map[Type::IfcMaterialUsageDefinition] = new IfcEntityDescriptor(Type::IfcMaterialUsageDefinition,0);

    current = entity_descriptor_map[Type::IfcMeasureWithUnit] = new IfcEntityDescriptor(Type::IfcMeasureWithUnit,0);
    current->add("ValueComponent",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcValue);
    current->add("UnitComponent",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcUnit);
    current = entity_descriptor_map[Type::IfcMetric] = new IfcEntityDescriptor(Type::IfcMetric,entity_descriptor_map.find(Type::IfcConstraint)->second);
    current->add("Benchmark",false,IfcUtil::Argument_ENUMERATION,Type::IfcBenchmarkEnum);
    current->add("ValueSource",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("DataValue",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcMetricValueSelect);
    current->add("ReferencePath",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcReference);
    current = entity_descriptor_map[Type::IfcMonetaryUnit] = new IfcEntityDescriptor(Type::IfcMonetaryUnit,0);
    current->add("Currency",false,IfcUtil::Argument_STRING,Type::IfcLabel);
    current = entity_descriptor_map[Type::IfcNamedUnit] = new IfcEntityDescriptor(Type::IfcNamedUnit,0);
    current->add("Dimensions",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcDimensionalExponents);
    current->add("UnitType",false,IfcUtil::Argument_ENUMERATION,Type::IfcUnitEnum);
    current = entity_descriptor_map[Type::IfcObjectPlacement] = new IfcEntityDescriptor(Type::IfcObjectPlacement,0);

    current = entity_descriptor_map[Type::IfcObjective] = new IfcEntityDescriptor(Type::IfcObjective,entity_descriptor_map.find(Type::IfcConstraint)->second);
    current->add("BenchmarkValues",true,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcConstraint);
    current->add("LogicalAggregator",true,IfcUtil::Argument_ENUMERATION,Type::IfcLogicalOperatorEnum);
    current->add("ObjectiveQualifier",false,IfcUtil::Argument_ENUMERATION,Type::IfcObjectiveEnum);
    current->add("UserDefinedQualifier",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current = entity_descriptor_map[Type::IfcOrganization] = new IfcEntityDescriptor(Type::IfcOrganization,0);
    current->add("Identification",true,IfcUtil::Argument_STRING,Type::IfcIdentifier);
    current->add("Name",false,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("Description",true,IfcUtil::Argument_STRING,Type::IfcText);
    current->add("Roles",true,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcActorRole);
    current->add("Addresses",true,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcAddress);
    current = entity_descriptor_map[Type::IfcOwnerHistory] = new IfcEntityDescriptor(Type::IfcOwnerHistory,0);
    current->add("OwningUser",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcPersonAndOrganization);
    current->add("OwningApplication",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcApplication);
    current->add("State",true,IfcUtil::Argument_ENUMERATION,Type::IfcStateEnum);
    current->add("ChangeAction",true,IfcUtil::Argument_ENUMERATION,Type::IfcChangeActionEnum);
    current->add("LastModifiedDate",true,IfcUtil::Argument_INT,Type::IfcTimeStamp);
    current->add("LastModifyingUser",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcPersonAndOrganization);
    current->add("LastModifyingApplication",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcApplication);
    current->add("CreationDate",false,IfcUtil::Argument_INT,Type::IfcTimeStamp);
    current = entity_descriptor_map[Type::IfcPerson] = new IfcEntityDescriptor(Type::IfcPerson,0);
    current->add("Identification",true,IfcUtil::Argument_STRING,Type::IfcIdentifier);
    current->add("FamilyName",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("GivenName",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("MiddleNames",true,IfcUtil::Argument_AGGREGATE_OF_STRING,Type::IfcLabel);
    current->add("PrefixTitles",true,IfcUtil::Argument_AGGREGATE_OF_STRING,Type::IfcLabel);
    current->add("SuffixTitles",true,IfcUtil::Argument_AGGREGATE_OF_STRING,Type::IfcLabel);
    current->add("Roles",true,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcActorRole);
    current->add("Addresses",true,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcAddress);
    current = entity_descriptor_map[Type::IfcPersonAndOrganization] = new IfcEntityDescriptor(Type::IfcPersonAndOrganization,0);
    current->add("ThePerson",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcPerson);
    current->add("TheOrganization",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcOrganization);
    current->add("Roles",true,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcActorRole);
    current = entity_descriptor_map[Type::IfcPhysicalQuantity] = new IfcEntityDescriptor(Type::IfcPhysicalQuantity,0);
    current->add("Name",false,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("Description",true,IfcUtil::Argument_STRING,Type::IfcText);
    current = entity_descriptor_map[Type::IfcPhysicalSimpleQuantity] = new IfcEntityDescriptor(Type::IfcPhysicalSimpleQuantity,entity_descriptor_map.find(Type::IfcPhysicalQuantity)->second);
    current->add("Unit",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcNamedUnit);
    current = entity_descriptor_map[Type::IfcPostalAddress] = new IfcEntityDescriptor(Type::IfcPostalAddress,entity_descriptor_map.find(Type::IfcAddress)->second);
    current->add("InternalLocation",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("AddressLines",true,IfcUtil::Argument_AGGREGATE_OF_STRING,Type::IfcLabel);
    current->add("PostalBox",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("Town",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("Region",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("PostalCode",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("Country",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current = entity_descriptor_map[Type::IfcPresentationItem] = new IfcEntityDescriptor(Type::IfcPresentationItem,0);

    current = entity_descriptor_map[Type::IfcPresentationLayerAssignment] = new IfcEntityDescriptor(Type::IfcPresentationLayerAssignment,0);
    current->add("Name",false,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("Description",true,IfcUtil::Argument_STRING,Type::IfcText);
    current->add("AssignedItems",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcLayeredItem);
    current->add("Identifier",true,IfcUtil::Argument_STRING,Type::IfcIdentifier);
    current = entity_descriptor_map[Type::IfcPresentationLayerWithStyle] = new IfcEntityDescriptor(Type::IfcPresentationLayerWithStyle,entity_descriptor_map.find(Type::IfcPresentationLayerAssignment)->second);
    current->add("LayerOn",false,IfcUtil::Argument_BOOL,Type::IfcLogical);
    current->add("LayerFrozen",false,IfcUtil::Argument_BOOL,Type::IfcLogical);
    current->add("LayerBlocked",false,IfcUtil::Argument_BOOL,Type::IfcLogical);
    current->add("LayerStyles",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcPresentationStyle);
    current = entity_descriptor_map[Type::IfcPresentationStyle] = new IfcEntityDescriptor(Type::IfcPresentationStyle,0);
    current->add("Name",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current = entity_descriptor_map[Type::IfcPresentationStyleAssignment] = new IfcEntityDescriptor(Type::IfcPresentationStyleAssignment,0);
    current->add("Styles",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcPresentationStyleSelect);
    current = entity_descriptor_map[Type::IfcProductRepresentation] = new IfcEntityDescriptor(Type::IfcProductRepresentation,0);
    current->add("Name",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("Description",true,IfcUtil::Argument_STRING,Type::IfcText);
    current->add("Representations",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcRepresentation);
    current = entity_descriptor_map[Type::IfcProfileDef] = new IfcEntityDescriptor(Type::IfcProfileDef,0);
    current->add("ProfileType",false,IfcUtil::Argument_ENUMERATION,Type::IfcProfileTypeEnum);
    current->add("ProfileName",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current = entity_descriptor_map[Type::IfcProjectedCRS] = new IfcEntityDescriptor(Type::IfcProjectedCRS,entity_descriptor_map.find(Type::IfcCoordinateReferenceSystem)->second);
    current->add("MapProjection",true,IfcUtil::Argument_STRING,Type::IfcIdentifier);
    current->add("MapZone",true,IfcUtil::Argument_STRING,Type::IfcIdentifier);
    current->add("MapUnit",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcNamedUnit);
    current = entity_descriptor_map[Type::IfcPropertyAbstraction] = new IfcEntityDescriptor(Type::IfcPropertyAbstraction,0);

    current = entity_descriptor_map[Type::IfcPropertyEnumeration] = new IfcEntityDescriptor(Type::IfcPropertyEnumeration,entity_descriptor_map.find(Type::IfcPropertyAbstraction)->second);
    current->add("Name",false,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("EnumerationValues",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcValue);
    current->add("Unit",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcUnit);
    current = entity_descriptor_map[Type::IfcQuantityArea] = new IfcEntityDescriptor(Type::IfcQuantityArea,entity_descriptor_map.find(Type::IfcPhysicalSimpleQuantity)->second);
    current->add("AreaValue",false,IfcUtil::Argument_DOUBLE,Type::IfcAreaMeasure);
    current->add("Formula",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current = entity_descriptor_map[Type::IfcQuantityCount] = new IfcEntityDescriptor(Type::IfcQuantityCount,entity_descriptor_map.find(Type::IfcPhysicalSimpleQuantity)->second);
    current->add("CountValue",false,IfcUtil::Argument_DOUBLE,Type::IfcCountMeasure);
    current->add("Formula",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current = entity_descriptor_map[Type::IfcQuantityLength] = new IfcEntityDescriptor(Type::IfcQuantityLength,entity_descriptor_map.find(Type::IfcPhysicalSimpleQuantity)->second);
    current->add("LengthValue",false,IfcUtil::Argument_DOUBLE,Type::IfcLengthMeasure);
    current->add("Formula",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current = entity_descriptor_map[Type::IfcQuantityTime] = new IfcEntityDescriptor(Type::IfcQuantityTime,entity_descriptor_map.find(Type::IfcPhysicalSimpleQuantity)->second);
    current->add("TimeValue",false,IfcUtil::Argument_DOUBLE,Type::IfcTimeMeasure);
    current->add("Formula",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current = entity_descriptor_map[Type::IfcQuantityVolume] = new IfcEntityDescriptor(Type::IfcQuantityVolume,entity_descriptor_map.find(Type::IfcPhysicalSimpleQuantity)->second);
    current->add("VolumeValue",false,IfcUtil::Argument_DOUBLE,Type::IfcVolumeMeasure);
    current->add("Formula",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current = entity_descriptor_map[Type::IfcQuantityWeight] = new IfcEntityDescriptor(Type::IfcQuantityWeight,entity_descriptor_map.find(Type::IfcPhysicalSimpleQuantity)->second);
    current->add("WeightValue",false,IfcUtil::Argument_DOUBLE,Type::IfcMassMeasure);
    current->add("Formula",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current = entity_descriptor_map[Type::IfcRecurrencePattern] = new IfcEntityDescriptor(Type::IfcRecurrencePattern,0);
    current->add("RecurrenceType",false,IfcUtil::Argument_ENUMERATION,Type::IfcRecurrenceTypeEnum);
    current->add("DayComponent",true,IfcUtil::Argument_AGGREGATE_OF_INT,Type::IfcDayInMonthNumber);
    current->add("WeekdayComponent",true,IfcUtil::Argument_AGGREGATE_OF_INT,Type::IfcDayInWeekNumber);
    current->add("MonthComponent",true,IfcUtil::Argument_AGGREGATE_OF_INT,Type::IfcMonthInYearNumber);
    current->add("Position",true,IfcUtil::Argument_INT,Type::IfcInteger);
    current->add("Interval",true,IfcUtil::Argument_INT,Type::IfcInteger);
    current->add("Occurrences",true,IfcUtil::Argument_INT,Type::IfcInteger);
    current->add("TimePeriods",true,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcTimePeriod);
    current = entity_descriptor_map[Type::IfcReference] = new IfcEntityDescriptor(Type::IfcReference,0);
    current->add("TypeIdentifier",true,IfcUtil::Argument_STRING,Type::IfcIdentifier);
    current->add("AttributeIdentifier",true,IfcUtil::Argument_STRING,Type::IfcIdentifier);
    current->add("InstanceName",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("ListPositions",true,IfcUtil::Argument_AGGREGATE_OF_INT,Type::IfcInteger);
    current->add("InnerReference",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcReference);
    current = entity_descriptor_map[Type::IfcRepresentation] = new IfcEntityDescriptor(Type::IfcRepresentation,0);
    current->add("ContextOfItems",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcRepresentationContext);
    current->add("RepresentationIdentifier",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("RepresentationType",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("Items",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcRepresentationItem);
    current = entity_descriptor_map[Type::IfcRepresentationContext] = new IfcEntityDescriptor(Type::IfcRepresentationContext,0);
    current->add("ContextIdentifier",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("ContextType",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current = entity_descriptor_map[Type::IfcRepresentationItem] = new IfcEntityDescriptor(Type::IfcRepresentationItem,0);

    current = entity_descriptor_map[Type::IfcRepresentationMap] = new IfcEntityDescriptor(Type::IfcRepresentationMap,0);
    current->add("MappingOrigin",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcAxis2Placement);
    current->add("MappedRepresentation",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcRepresentation);
    current = entity_descriptor_map[Type::IfcResourceLevelRelationship] = new IfcEntityDescriptor(Type::IfcResourceLevelRelationship,0);
    current->add("Name",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("Description",true,IfcUtil::Argument_STRING,Type::IfcText);
    current = entity_descriptor_map[Type::IfcRoot] = new IfcEntityDescriptor(Type::IfcRoot,0);
    current->add("GlobalId",false,IfcUtil::Argument_STRING,Type::IfcGloballyUniqueId);
    current->add("OwnerHistory",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcOwnerHistory);
    current->add("Name",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("Description",true,IfcUtil::Argument_STRING,Type::IfcText);
    current = entity_descriptor_map[Type::IfcSIUnit] = new IfcEntityDescriptor(Type::IfcSIUnit,entity_descriptor_map.find(Type::IfcNamedUnit)->second);
    current->add("Prefix",true,IfcUtil::Argument_ENUMERATION,Type::IfcSIPrefix);
    current->add("Name",false,IfcUtil::Argument_ENUMERATION,Type::IfcSIUnitName);
    current = entity_descriptor_map[Type::IfcSchedulingTime] = new IfcEntityDescriptor(Type::IfcSchedulingTime,0);
    current->add("Name",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("DataOrigin",true,IfcUtil::Argument_ENUMERATION,Type::IfcDataOriginEnum);
    current->add("UserDefinedDataOrigin",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current = entity_descriptor_map[Type::IfcShapeAspect] = new IfcEntityDescriptor(Type::IfcShapeAspect,0);
    current->add("ShapeRepresentations",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcShapeModel);
    current->add("Name",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("Description",true,IfcUtil::Argument_STRING,Type::IfcText);
    current->add("ProductDefinitional",false,IfcUtil::Argument_BOOL,Type::IfcLogical);
    current->add("PartOfProductDefinitionShape",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcProductRepresentationSelect);
    current = entity_descriptor_map[Type::IfcShapeModel] = new IfcEntityDescriptor(Type::IfcShapeModel,entity_descriptor_map.find(Type::IfcRepresentation)->second);

    current = entity_descriptor_map[Type::IfcShapeRepresentation] = new IfcEntityDescriptor(Type::IfcShapeRepresentation,entity_descriptor_map.find(Type::IfcShapeModel)->second);

    current = entity_descriptor_map[Type::IfcStructuralConnectionCondition] = new IfcEntityDescriptor(Type::IfcStructuralConnectionCondition,0);
    current->add("Name",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current = entity_descriptor_map[Type::IfcStructuralLoad] = new IfcEntityDescriptor(Type::IfcStructuralLoad,0);
    current->add("Name",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current = entity_descriptor_map[Type::IfcStructuralLoadConfiguration] = new IfcEntityDescriptor(Type::IfcStructuralLoadConfiguration,entity_descriptor_map.find(Type::IfcStructuralLoad)->second);
    current->add("Values",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcStructuralLoadOrResult);
    current->add("Locations",true,IfcUtil::Argument_AGGREGATE_OF_AGGREGATE_OF_DOUBLE,Type::IfcLengthMeasure);
    current = entity_descriptor_map[Type::IfcStructuralLoadOrResult] = new IfcEntityDescriptor(Type::IfcStructuralLoadOrResult,entity_descriptor_map.find(Type::IfcStructuralLoad)->second);

    current = entity_descriptor_map[Type::IfcStructuralLoadStatic] = new IfcEntityDescriptor(Type::IfcStructuralLoadStatic,entity_descriptor_map.find(Type::IfcStructuralLoadOrResult)->second);

    current = entity_descriptor_map[Type::IfcStructuralLoadTemperature] = new IfcEntityDescriptor(Type::IfcStructuralLoadTemperature,entity_descriptor_map.find(Type::IfcStructuralLoadStatic)->second);
    current->add("DeltaTConstant",true,IfcUtil::Argument_DOUBLE,Type::IfcThermodynamicTemperatureMeasure);
    current->add("DeltaTY",true,IfcUtil::Argument_DOUBLE,Type::IfcThermodynamicTemperatureMeasure);
    current->add("DeltaTZ",true,IfcUtil::Argument_DOUBLE,Type::IfcThermodynamicTemperatureMeasure);
    current = entity_descriptor_map[Type::IfcStyleModel] = new IfcEntityDescriptor(Type::IfcStyleModel,entity_descriptor_map.find(Type::IfcRepresentation)->second);

    current = entity_descriptor_map[Type::IfcStyledItem] = new IfcEntityDescriptor(Type::IfcStyledItem,entity_descriptor_map.find(Type::IfcRepresentationItem)->second);
    current->add("Item",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcRepresentationItem);
    current->add("Styles",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcStyleAssignmentSelect);
    current->add("Name",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current = entity_descriptor_map[Type::IfcStyledRepresentation] = new IfcEntityDescriptor(Type::IfcStyledRepresentation,entity_descriptor_map.find(Type::IfcStyleModel)->second);

    current = entity_descriptor_map[Type::IfcSurfaceReinforcementArea] = new IfcEntityDescriptor(Type::IfcSurfaceReinforcementArea,entity_descriptor_map.find(Type::IfcStructuralLoadOrResult)->second);
    current->add("SurfaceReinforcement1",true,IfcUtil::Argument_AGGREGATE_OF_DOUBLE,Type::IfcLengthMeasure);
    current->add("SurfaceReinforcement2",true,IfcUtil::Argument_AGGREGATE_OF_DOUBLE,Type::IfcLengthMeasure);
    current->add("ShearReinforcement",true,IfcUtil::Argument_DOUBLE,Type::IfcRatioMeasure);
    current = entity_descriptor_map[Type::IfcSurfaceStyle] = new IfcEntityDescriptor(Type::IfcSurfaceStyle,entity_descriptor_map.find(Type::IfcPresentationStyle)->second);
    current->add("Side",false,IfcUtil::Argument_ENUMERATION,Type::IfcSurfaceSide);
    current->add("Styles",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcSurfaceStyleElementSelect);
    current = entity_descriptor_map[Type::IfcSurfaceStyleLighting] = new IfcEntityDescriptor(Type::IfcSurfaceStyleLighting,entity_descriptor_map.find(Type::IfcPresentationItem)->second);
    current->add("DiffuseTransmissionColour",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcColourRgb);
    current->add("DiffuseReflectionColour",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcColourRgb);
    current->add("TransmissionColour",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcColourRgb);
    current->add("ReflectanceColour",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcColourRgb);
    current = entity_descriptor_map[Type::IfcSurfaceStyleRefraction] = new IfcEntityDescriptor(Type::IfcSurfaceStyleRefraction,entity_descriptor_map.find(Type::IfcPresentationItem)->second);
    current->add("RefractionIndex",true,IfcUtil::Argument_DOUBLE,Type::IfcReal);
    current->add("DispersionFactor",true,IfcUtil::Argument_DOUBLE,Type::IfcReal);
    current = entity_descriptor_map[Type::IfcSurfaceStyleShading] = new IfcEntityDescriptor(Type::IfcSurfaceStyleShading,entity_descriptor_map.find(Type::IfcPresentationItem)->second);
    current->add("SurfaceColour",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcColourRgb);
    current->add("Transparency",true,IfcUtil::Argument_DOUBLE,Type::IfcNormalisedRatioMeasure);
    current = entity_descriptor_map[Type::IfcSurfaceStyleWithTextures] = new IfcEntityDescriptor(Type::IfcSurfaceStyleWithTextures,entity_descriptor_map.find(Type::IfcPresentationItem)->second);
    current->add("Textures",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcSurfaceTexture);
    current = entity_descriptor_map[Type::IfcSurfaceTexture] = new IfcEntityDescriptor(Type::IfcSurfaceTexture,entity_descriptor_map.find(Type::IfcPresentationItem)->second);
    current->add("RepeatS",false,IfcUtil::Argument_BOOL,Type::IfcBoolean);
    current->add("RepeatT",false,IfcUtil::Argument_BOOL,Type::IfcBoolean);
    current->add("Mode",true,IfcUtil::Argument_STRING,Type::IfcIdentifier);
    current->add("TextureTransform",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcCartesianTransformationOperator2D);
    current->add("Parameter",true,IfcUtil::Argument_AGGREGATE_OF_STRING,Type::IfcIdentifier);
    current = entity_descriptor_map[Type::IfcTable] = new IfcEntityDescriptor(Type::IfcTable,0);
    current->add("Name",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("Rows",true,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcTableRow);
    current->add("Columns",true,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcTableColumn);
    current = entity_descriptor_map[Type::IfcTableColumn] = new IfcEntityDescriptor(Type::IfcTableColumn,0);
    current->add("Identifier",true,IfcUtil::Argument_STRING,Type::IfcIdentifier);
    current->add("Name",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("Description",true,IfcUtil::Argument_STRING,Type::IfcText);
    current->add("Unit",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcUnit);
    current->add("ReferencePath",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcReference);
    current = entity_descriptor_map[Type::IfcTableRow] = new IfcEntityDescriptor(Type::IfcTableRow,0);
    current->add("RowCells",true,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcValue);
    current->add("IsHeading",true,IfcUtil::Argument_BOOL,Type::IfcBoolean);
    current = entity_descriptor_map[Type::IfcTaskTime] = new IfcEntityDescriptor(Type::IfcTaskTime,entity_descriptor_map.find(Type::IfcSchedulingTime)->second);
    current->add("DurationType",true,IfcUtil::Argument_ENUMERATION,Type::IfcTaskDurationEnum);
    current->add("ScheduleDuration",true,IfcUtil::Argument_STRING,Type::IfcDuration);
    current->add("ScheduleStart",true,IfcUtil::Argument_STRING,Type::IfcDateTime);
    current->add("ScheduleFinish",true,IfcUtil::Argument_STRING,Type::IfcDateTime);
    current->add("EarlyStart",true,IfcUtil::Argument_STRING,Type::IfcDateTime);
    current->add("EarlyFinish",true,IfcUtil::Argument_STRING,Type::IfcDateTime);
    current->add("LateStart",true,IfcUtil::Argument_STRING,Type::IfcDateTime);
    current->add("LateFinish",true,IfcUtil::Argument_STRING,Type::IfcDateTime);
    current->add("FreeFloat",true,IfcUtil::Argument_STRING,Type::IfcDuration);
    current->add("TotalFloat",true,IfcUtil::Argument_STRING,Type::IfcDuration);
    current->add("IsCritical",true,IfcUtil::Argument_BOOL,Type::IfcBoolean);
    current->add("StatusTime",true,IfcUtil::Argument_STRING,Type::IfcDateTime);
    current->add("ActualDuration",true,IfcUtil::Argument_STRING,Type::IfcDuration);
    current->add("ActualStart",true,IfcUtil::Argument_STRING,Type::IfcDateTime);
    current->add("ActualFinish",true,IfcUtil::Argument_STRING,Type::IfcDateTime);
    current->add("RemainingTime",true,IfcUtil::Argument_STRING,Type::IfcDuration);
    current->add("Completion",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveRatioMeasure);
    current = entity_descriptor_map[Type::IfcTaskTimeRecurring] = new IfcEntityDescriptor(Type::IfcTaskTimeRecurring,entity_descriptor_map.find(Type::IfcTaskTime)->second);
    current->add("Recurrence",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcRecurrencePattern);
    current = entity_descriptor_map[Type::IfcTelecomAddress] = new IfcEntityDescriptor(Type::IfcTelecomAddress,entity_descriptor_map.find(Type::IfcAddress)->second);
    current->add("TelephoneNumbers",true,IfcUtil::Argument_AGGREGATE_OF_STRING,Type::IfcLabel);
    current->add("FacsimileNumbers",true,IfcUtil::Argument_AGGREGATE_OF_STRING,Type::IfcLabel);
    current->add("PagerNumber",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("ElectronicMailAddresses",true,IfcUtil::Argument_AGGREGATE_OF_STRING,Type::IfcLabel);
    current->add("WWWHomePageURL",true,IfcUtil::Argument_STRING,Type::IfcURIReference);
    current->add("MessagingIDs",true,IfcUtil::Argument_AGGREGATE_OF_STRING,Type::IfcURIReference);
    current = entity_descriptor_map[Type::IfcTextStyle] = new IfcEntityDescriptor(Type::IfcTextStyle,entity_descriptor_map.find(Type::IfcPresentationStyle)->second);
    current->add("TextCharacterAppearance",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcTextStyleForDefinedFont);
    current->add("TextStyle",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcTextStyleTextModel);
    current->add("TextFontStyle",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcTextFontSelect);
    current->add("ModelOrDraughting",true,IfcUtil::Argument_BOOL,Type::IfcBoolean);
    current = entity_descriptor_map[Type::IfcTextStyleForDefinedFont] = new IfcEntityDescriptor(Type::IfcTextStyleForDefinedFont,entity_descriptor_map.find(Type::IfcPresentationItem)->second);
    current->add("Colour",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcColour);
    current->add("BackgroundColour",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcColour);
    current = entity_descriptor_map[Type::IfcTextStyleTextModel] = new IfcEntityDescriptor(Type::IfcTextStyleTextModel,entity_descriptor_map.find(Type::IfcPresentationItem)->second);
    current->add("TextIndent",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcSizeSelect);
    current->add("TextAlign",true,IfcUtil::Argument_STRING,Type::IfcTextAlignment);
    current->add("TextDecoration",true,IfcUtil::Argument_STRING,Type::IfcTextDecoration);
    current->add("LetterSpacing",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcSizeSelect);
    current->add("WordSpacing",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcSizeSelect);
    current->add("TextTransform",true,IfcUtil::Argument_STRING,Type::IfcTextTransformation);
    current->add("LineHeight",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcSizeSelect);
    current = entity_descriptor_map[Type::IfcTextureCoordinate] = new IfcEntityDescriptor(Type::IfcTextureCoordinate,entity_descriptor_map.find(Type::IfcPresentationItem)->second);
    current->add("Maps",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcSurfaceTexture);
    current = entity_descriptor_map[Type::IfcTextureCoordinateGenerator] = new IfcEntityDescriptor(Type::IfcTextureCoordinateGenerator,entity_descriptor_map.find(Type::IfcTextureCoordinate)->second);
    current->add("Mode",false,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("Parameter",true,IfcUtil::Argument_AGGREGATE_OF_DOUBLE,Type::IfcReal);
    current = entity_descriptor_map[Type::IfcTextureMap] = new IfcEntityDescriptor(Type::IfcTextureMap,entity_descriptor_map.find(Type::IfcTextureCoordinate)->second);
    current->add("Vertices",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcTextureVertex);
    current->add("MappedTo",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcFace);
    current = entity_descriptor_map[Type::IfcTextureVertex] = new IfcEntityDescriptor(Type::IfcTextureVertex,entity_descriptor_map.find(Type::IfcPresentationItem)->second);
    current->add("Coordinates",false,IfcUtil::Argument_AGGREGATE_OF_DOUBLE,Type::IfcParameterValue);
    current = entity_descriptor_map[Type::IfcTextureVertexList] = new IfcEntityDescriptor(Type::IfcTextureVertexList,entity_descriptor_map.find(Type::IfcPresentationItem)->second);
    current->add("TexCoordsList",false,IfcUtil::Argument_AGGREGATE_OF_AGGREGATE_OF_DOUBLE,Type::IfcParameterValue);
    current = entity_descriptor_map[Type::IfcTimePeriod] = new IfcEntityDescriptor(Type::IfcTimePeriod,0);
    current->add("StartTime",false,IfcUtil::Argument_STRING,Type::IfcTime);
    current->add("EndTime",false,IfcUtil::Argument_STRING,Type::IfcTime);
    current = entity_descriptor_map[Type::IfcTimeSeries] = new IfcEntityDescriptor(Type::IfcTimeSeries,0);
    current->add("Name",false,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("Description",true,IfcUtil::Argument_STRING,Type::IfcText);
    current->add("StartTime",false,IfcUtil::Argument_STRING,Type::IfcDateTime);
    current->add("EndTime",false,IfcUtil::Argument_STRING,Type::IfcDateTime);
    current->add("TimeSeriesDataType",false,IfcUtil::Argument_ENUMERATION,Type::IfcTimeSeriesDataTypeEnum);
    current->add("DataOrigin",false,IfcUtil::Argument_ENUMERATION,Type::IfcDataOriginEnum);
    current->add("UserDefinedDataOrigin",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("Unit",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcUnit);
    current = entity_descriptor_map[Type::IfcTimeSeriesValue] = new IfcEntityDescriptor(Type::IfcTimeSeriesValue,0);
    current->add("ListValues",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcValue);
    current = entity_descriptor_map[Type::IfcTopologicalRepresentationItem] = new IfcEntityDescriptor(Type::IfcTopologicalRepresentationItem,entity_descriptor_map.find(Type::IfcRepresentationItem)->second);

    current = entity_descriptor_map[Type::IfcTopologyRepresentation] = new IfcEntityDescriptor(Type::IfcTopologyRepresentation,entity_descriptor_map.find(Type::IfcShapeModel)->second);

    current = entity_descriptor_map[Type::IfcUnitAssignment] = new IfcEntityDescriptor(Type::IfcUnitAssignment,0);
    current->add("Units",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcUnit);
    current = entity_descriptor_map[Type::IfcVertex] = new IfcEntityDescriptor(Type::IfcVertex,entity_descriptor_map.find(Type::IfcTopologicalRepresentationItem)->second);

    current = entity_descriptor_map[Type::IfcVertexPoint] = new IfcEntityDescriptor(Type::IfcVertexPoint,entity_descriptor_map.find(Type::IfcVertex)->second);
    current->add("VertexGeometry",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcPoint);
    current = entity_descriptor_map[Type::IfcVirtualGridIntersection] = new IfcEntityDescriptor(Type::IfcVirtualGridIntersection,0);
    current->add("IntersectingAxes",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcGridAxis);
    current->add("OffsetDistances",false,IfcUtil::Argument_AGGREGATE_OF_DOUBLE,Type::IfcLengthMeasure);
    current = entity_descriptor_map[Type::IfcWorkTime] = new IfcEntityDescriptor(Type::IfcWorkTime,entity_descriptor_map.find(Type::IfcSchedulingTime)->second);
    current->add("RecurrencePattern",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcRecurrencePattern);
    current->add("Start",true,IfcUtil::Argument_STRING,Type::IfcDate);
    current->add("Finish",true,IfcUtil::Argument_STRING,Type::IfcDate);
    current = entity_descriptor_map[Type::IfcApprovalRelationship] = new IfcEntityDescriptor(Type::IfcApprovalRelationship,entity_descriptor_map.find(Type::IfcResourceLevelRelationship)->second);
    current->add("RelatingApproval",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcApproval);
    current->add("RelatedApprovals",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcApproval);
    current = entity_descriptor_map[Type::IfcArbitraryClosedProfileDef] = new IfcEntityDescriptor(Type::IfcArbitraryClosedProfileDef,entity_descriptor_map.find(Type::IfcProfileDef)->second);
    current->add("OuterCurve",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcCurve);
    current = entity_descriptor_map[Type::IfcArbitraryOpenProfileDef] = new IfcEntityDescriptor(Type::IfcArbitraryOpenProfileDef,entity_descriptor_map.find(Type::IfcProfileDef)->second);
    current->add("Curve",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcBoundedCurve);
    current = entity_descriptor_map[Type::IfcArbitraryProfileDefWithVoids] = new IfcEntityDescriptor(Type::IfcArbitraryProfileDefWithVoids,entity_descriptor_map.find(Type::IfcArbitraryClosedProfileDef)->second);
    current->add("InnerCurves",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcCurve);
    current = entity_descriptor_map[Type::IfcBlobTexture] = new IfcEntityDescriptor(Type::IfcBlobTexture,entity_descriptor_map.find(Type::IfcSurfaceTexture)->second);
    current->add("RasterFormat",false,IfcUtil::Argument_STRING,Type::IfcIdentifier);
    current->add("RasterCode",false,IfcUtil::Argument_BINARY,Type::IfcBinary);
    current = entity_descriptor_map[Type::IfcCenterLineProfileDef] = new IfcEntityDescriptor(Type::IfcCenterLineProfileDef,entity_descriptor_map.find(Type::IfcArbitraryOpenProfileDef)->second);
    current->add("Thickness",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current = entity_descriptor_map[Type::IfcClassification] = new IfcEntityDescriptor(Type::IfcClassification,entity_descriptor_map.find(Type::IfcExternalInformation)->second);
    current->add("Source",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("Edition",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("EditionDate",true,IfcUtil::Argument_STRING,Type::IfcDate);
    current->add("Name",false,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("Description",true,IfcUtil::Argument_STRING,Type::IfcText);
    current->add("Location",true,IfcUtil::Argument_STRING,Type::IfcURIReference);
    current->add("ReferenceTokens",true,IfcUtil::Argument_AGGREGATE_OF_STRING,Type::IfcIdentifier);
    current = entity_descriptor_map[Type::IfcClassificationReference] = new IfcEntityDescriptor(Type::IfcClassificationReference,entity_descriptor_map.find(Type::IfcExternalReference)->second);
    current->add("ReferencedSource",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcClassificationReferenceSelect);
    current->add("Description",true,IfcUtil::Argument_STRING,Type::IfcText);
    current->add("Sort",true,IfcUtil::Argument_STRING,Type::IfcIdentifier);
    current = entity_descriptor_map[Type::IfcColourRgbList] = new IfcEntityDescriptor(Type::IfcColourRgbList,entity_descriptor_map.find(Type::IfcPresentationItem)->second);
    current->add("ColourList",false,IfcUtil::Argument_AGGREGATE_OF_AGGREGATE_OF_DOUBLE,Type::IfcNormalisedRatioMeasure);
    current = entity_descriptor_map[Type::IfcColourSpecification] = new IfcEntityDescriptor(Type::IfcColourSpecification,entity_descriptor_map.find(Type::IfcPresentationItem)->second);
    current->add("Name",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current = entity_descriptor_map[Type::IfcCompositeProfileDef] = new IfcEntityDescriptor(Type::IfcCompositeProfileDef,entity_descriptor_map.find(Type::IfcProfileDef)->second);
    current->add("Profiles",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcProfileDef);
    current->add("Label",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current = entity_descriptor_map[Type::IfcConnectedFaceSet] = new IfcEntityDescriptor(Type::IfcConnectedFaceSet,entity_descriptor_map.find(Type::IfcTopologicalRepresentationItem)->second);
    current->add("CfsFaces",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcFace);
    current = entity_descriptor_map[Type::IfcConnectionCurveGeometry] = new IfcEntityDescriptor(Type::IfcConnectionCurveGeometry,entity_descriptor_map.find(Type::IfcConnectionGeometry)->second);
    current->add("CurveOnRelatingElement",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcCurveOrEdgeCurve);
    current->add("CurveOnRelatedElement",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcCurveOrEdgeCurve);
    current = entity_descriptor_map[Type::IfcConnectionPointEccentricity] = new IfcEntityDescriptor(Type::IfcConnectionPointEccentricity,entity_descriptor_map.find(Type::IfcConnectionPointGeometry)->second);
    current->add("EccentricityInX",true,IfcUtil::Argument_DOUBLE,Type::IfcLengthMeasure);
    current->add("EccentricityInY",true,IfcUtil::Argument_DOUBLE,Type::IfcLengthMeasure);
    current->add("EccentricityInZ",true,IfcUtil::Argument_DOUBLE,Type::IfcLengthMeasure);
    current = entity_descriptor_map[Type::IfcContextDependentUnit] = new IfcEntityDescriptor(Type::IfcContextDependentUnit,entity_descriptor_map.find(Type::IfcNamedUnit)->second);
    current->add("Name",false,IfcUtil::Argument_STRING,Type::IfcLabel);
    current = entity_descriptor_map[Type::IfcConversionBasedUnit] = new IfcEntityDescriptor(Type::IfcConversionBasedUnit,entity_descriptor_map.find(Type::IfcNamedUnit)->second);
    current->add("Name",false,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("ConversionFactor",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcMeasureWithUnit);
    current = entity_descriptor_map[Type::IfcConversionBasedUnitWithOffset] = new IfcEntityDescriptor(Type::IfcConversionBasedUnitWithOffset,entity_descriptor_map.find(Type::IfcConversionBasedUnit)->second);
    current->add("ConversionOffset",false,IfcUtil::Argument_DOUBLE,Type::IfcReal);
    current = entity_descriptor_map[Type::IfcCurrencyRelationship] = new IfcEntityDescriptor(Type::IfcCurrencyRelationship,entity_descriptor_map.find(Type::IfcResourceLevelRelationship)->second);
    current->add("RelatingMonetaryUnit",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcMonetaryUnit);
    current->add("RelatedMonetaryUnit",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcMonetaryUnit);
    current->add("ExchangeRate",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveRatioMeasure);
    current->add("RateDateTime",true,IfcUtil::Argument_STRING,Type::IfcDateTime);
    current->add("RateSource",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcLibraryInformation);
    current = entity_descriptor_map[Type::IfcCurveStyle] = new IfcEntityDescriptor(Type::IfcCurveStyle,entity_descriptor_map.find(Type::IfcPresentationStyle)->second);
    current->add("CurveFont",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcCurveFontOrScaledCurveFontSelect);
    current->add("CurveWidth",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcSizeSelect);
    current->add("CurveColour",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcColour);
    current->add("ModelOrDraughting",true,IfcUtil::Argument_BOOL,Type::IfcBoolean);
    current = entity_descriptor_map[Type::IfcCurveStyleFont] = new IfcEntityDescriptor(Type::IfcCurveStyleFont,entity_descriptor_map.find(Type::IfcPresentationItem)->second);
    current->add("Name",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("PatternList",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcCurveStyleFontPattern);
    current = entity_descriptor_map[Type::IfcCurveStyleFontAndScaling] = new IfcEntityDescriptor(Type::IfcCurveStyleFontAndScaling,entity_descriptor_map.find(Type::IfcPresentationItem)->second);
    current->add("Name",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("CurveFont",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcCurveStyleFontSelect);
    current->add("CurveFontScaling",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveRatioMeasure);
    current = entity_descriptor_map[Type::IfcCurveStyleFontPattern] = new IfcEntityDescriptor(Type::IfcCurveStyleFontPattern,entity_descriptor_map.find(Type::IfcPresentationItem)->second);
    current->add("VisibleSegmentLength",false,IfcUtil::Argument_DOUBLE,Type::IfcLengthMeasure);
    current->add("InvisibleSegmentLength",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current = entity_descriptor_map[Type::IfcDerivedProfileDef] = new IfcEntityDescriptor(Type::IfcDerivedProfileDef,entity_descriptor_map.find(Type::IfcProfileDef)->second);
    current->add("ParentProfile",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcProfileDef);
    current->add("Operator",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcCartesianTransformationOperator2D);
    current->add("Label",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current = entity_descriptor_map[Type::IfcDocumentInformation] = new IfcEntityDescriptor(Type::IfcDocumentInformation,entity_descriptor_map.find(Type::IfcExternalInformation)->second);
    current->add("Identification",false,IfcUtil::Argument_STRING,Type::IfcIdentifier);
    current->add("Name",false,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("Description",true,IfcUtil::Argument_STRING,Type::IfcText);
    current->add("Location",true,IfcUtil::Argument_STRING,Type::IfcURIReference);
    current->add("Purpose",true,IfcUtil::Argument_STRING,Type::IfcText);
    current->add("IntendedUse",true,IfcUtil::Argument_STRING,Type::IfcText);
    current->add("Scope",true,IfcUtil::Argument_STRING,Type::IfcText);
    current->add("Revision",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("DocumentOwner",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcActorSelect);
    current->add("Editors",true,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcActorSelect);
    current->add("CreationTime",true,IfcUtil::Argument_STRING,Type::IfcDateTime);
    current->add("LastRevisionTime",true,IfcUtil::Argument_STRING,Type::IfcDateTime);
    current->add("ElectronicFormat",true,IfcUtil::Argument_STRING,Type::IfcIdentifier);
    current->add("ValidFrom",true,IfcUtil::Argument_STRING,Type::IfcDate);
    current->add("ValidUntil",true,IfcUtil::Argument_STRING,Type::IfcDate);
    current->add("Confidentiality",true,IfcUtil::Argument_ENUMERATION,Type::IfcDocumentConfidentialityEnum);
    current->add("Status",true,IfcUtil::Argument_ENUMERATION,Type::IfcDocumentStatusEnum);
    current = entity_descriptor_map[Type::IfcDocumentInformationRelationship] = new IfcEntityDescriptor(Type::IfcDocumentInformationRelationship,entity_descriptor_map.find(Type::IfcResourceLevelRelationship)->second);
    current->add("RelatingDocument",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcDocumentInformation);
    current->add("RelatedDocuments",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcDocumentInformation);
    current->add("RelationshipType",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current = entity_descriptor_map[Type::IfcDocumentReference] = new IfcEntityDescriptor(Type::IfcDocumentReference,entity_descriptor_map.find(Type::IfcExternalReference)->second);
    current->add("Description",true,IfcUtil::Argument_STRING,Type::IfcText);
    current->add("ReferencedDocument",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcDocumentInformation);
    current = entity_descriptor_map[Type::IfcEdge] = new IfcEntityDescriptor(Type::IfcEdge,entity_descriptor_map.find(Type::IfcTopologicalRepresentationItem)->second);
    current->add("EdgeStart",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcVertex);
    current->add("EdgeEnd",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcVertex);
    current = entity_descriptor_map[Type::IfcEdgeCurve] = new IfcEntityDescriptor(Type::IfcEdgeCurve,entity_descriptor_map.find(Type::IfcEdge)->second);
    current->add("EdgeGeometry",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcCurve);
    current->add("SameSense",false,IfcUtil::Argument_BOOL,Type::IfcBoolean);
    current = entity_descriptor_map[Type::IfcEventTime] = new IfcEntityDescriptor(Type::IfcEventTime,entity_descriptor_map.find(Type::IfcSchedulingTime)->second);
    current->add("ActualDate",true,IfcUtil::Argument_STRING,Type::IfcDateTime);
    current->add("EarlyDate",true,IfcUtil::Argument_STRING,Type::IfcDateTime);
    current->add("LateDate",true,IfcUtil::Argument_STRING,Type::IfcDateTime);
    current->add("ScheduleDate",true,IfcUtil::Argument_STRING,Type::IfcDateTime);
    current = entity_descriptor_map[Type::IfcExtendedProperties] = new IfcEntityDescriptor(Type::IfcExtendedProperties,entity_descriptor_map.find(Type::IfcPropertyAbstraction)->second);
    current->add("Name",true,IfcUtil::Argument_STRING,Type::IfcIdentifier);
    current->add("Description",true,IfcUtil::Argument_STRING,Type::IfcText);
    current->add("Properties",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcProperty);
    current = entity_descriptor_map[Type::IfcExternalReferenceRelationship] = new IfcEntityDescriptor(Type::IfcExternalReferenceRelationship,entity_descriptor_map.find(Type::IfcResourceLevelRelationship)->second);
    current->add("RelatingReference",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcExternalReference);
    current->add("RelatedResourceObjects",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcResourceObjectSelect);
    current = entity_descriptor_map[Type::IfcFace] = new IfcEntityDescriptor(Type::IfcFace,entity_descriptor_map.find(Type::IfcTopologicalRepresentationItem)->second);
    current->add("Bounds",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcFaceBound);
    current = entity_descriptor_map[Type::IfcFaceBound] = new IfcEntityDescriptor(Type::IfcFaceBound,entity_descriptor_map.find(Type::IfcTopologicalRepresentationItem)->second);
    current->add("Bound",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcLoop);
    current->add("Orientation",false,IfcUtil::Argument_BOOL,Type::IfcBoolean);
    current = entity_descriptor_map[Type::IfcFaceOuterBound] = new IfcEntityDescriptor(Type::IfcFaceOuterBound,entity_descriptor_map.find(Type::IfcFaceBound)->second);

    current = entity_descriptor_map[Type::IfcFaceSurface] = new IfcEntityDescriptor(Type::IfcFaceSurface,entity_descriptor_map.find(Type::IfcFace)->second);
    current->add("FaceSurface",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcSurface);
    current->add("SameSense",false,IfcUtil::Argument_BOOL,Type::IfcBoolean);
    current = entity_descriptor_map[Type::IfcFailureConnectionCondition] = new IfcEntityDescriptor(Type::IfcFailureConnectionCondition,entity_descriptor_map.find(Type::IfcStructuralConnectionCondition)->second);
    current->add("TensionFailureX",true,IfcUtil::Argument_DOUBLE,Type::IfcForceMeasure);
    current->add("TensionFailureY",true,IfcUtil::Argument_DOUBLE,Type::IfcForceMeasure);
    current->add("TensionFailureZ",true,IfcUtil::Argument_DOUBLE,Type::IfcForceMeasure);
    current->add("CompressionFailureX",true,IfcUtil::Argument_DOUBLE,Type::IfcForceMeasure);
    current->add("CompressionFailureY",true,IfcUtil::Argument_DOUBLE,Type::IfcForceMeasure);
    current->add("CompressionFailureZ",true,IfcUtil::Argument_DOUBLE,Type::IfcForceMeasure);
    current = entity_descriptor_map[Type::IfcFillAreaStyle] = new IfcEntityDescriptor(Type::IfcFillAreaStyle,entity_descriptor_map.find(Type::IfcPresentationStyle)->second);
    current->add("FillStyles",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcFillStyleSelect);
    current->add("ModelorDraughting",true,IfcUtil::Argument_BOOL,Type::IfcBoolean);
    current = entity_descriptor_map[Type::IfcGeometricRepresentationContext] = new IfcEntityDescriptor(Type::IfcGeometricRepresentationContext,entity_descriptor_map.find(Type::IfcRepresentationContext)->second);
    current->add("CoordinateSpaceDimension",false,IfcUtil::Argument_INT,Type::IfcDimensionCount);
    current->add("Precision",true,IfcUtil::Argument_DOUBLE,Type::IfcReal);
    current->add("WorldCoordinateSystem",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcAxis2Placement);
    current->add("TrueNorth",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcDirection);
    current = entity_descriptor_map[Type::IfcGeometricRepresentationItem] = new IfcEntityDescriptor(Type::IfcGeometricRepresentationItem,entity_descriptor_map.find(Type::IfcRepresentationItem)->second);

    current = entity_descriptor_map[Type::IfcGeometricRepresentationSubContext] = new IfcEntityDescriptor(Type::IfcGeometricRepresentationSubContext,entity_descriptor_map.find(Type::IfcGeometricRepresentationContext)->second);
    current->add("ParentContext",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcGeometricRepresentationContext);
    current->add("TargetScale",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveRatioMeasure);
    current->add("TargetView",false,IfcUtil::Argument_ENUMERATION,Type::IfcGeometricProjectionEnum);
    current->add("UserDefinedTargetView",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current = entity_descriptor_map[Type::IfcGeometricSet] = new IfcEntityDescriptor(Type::IfcGeometricSet,entity_descriptor_map.find(Type::IfcGeometricRepresentationItem)->second);
    current->add("Elements",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcGeometricSetSelect);
    current = entity_descriptor_map[Type::IfcGridPlacement] = new IfcEntityDescriptor(Type::IfcGridPlacement,entity_descriptor_map.find(Type::IfcObjectPlacement)->second);
    current->add("PlacementLocation",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcVirtualGridIntersection);
    current->add("PlacementRefDirection",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcGridPlacementDirectionSelect);
    current = entity_descriptor_map[Type::IfcHalfSpaceSolid] = new IfcEntityDescriptor(Type::IfcHalfSpaceSolid,entity_descriptor_map.find(Type::IfcGeometricRepresentationItem)->second);
    current->add("BaseSurface",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcSurface);
    current->add("AgreementFlag",false,IfcUtil::Argument_BOOL,Type::IfcBoolean);
    current = entity_descriptor_map[Type::IfcImageTexture] = new IfcEntityDescriptor(Type::IfcImageTexture,entity_descriptor_map.find(Type::IfcSurfaceTexture)->second);
    current->add("URLReference",false,IfcUtil::Argument_STRING,Type::IfcURIReference);
    current = entity_descriptor_map[Type::IfcIndexedColourMap] = new IfcEntityDescriptor(Type::IfcIndexedColourMap,entity_descriptor_map.find(Type::IfcPresentationItem)->second);
    current->add("MappedTo",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcTessellatedFaceSet);
    current->add("Opacity",true,IfcUtil::Argument_DOUBLE,Type::IfcNormalisedRatioMeasure);
    current->add("Colours",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcColourRgbList);
    current->add("ColourIndex",false,IfcUtil::Argument_AGGREGATE_OF_INT,Type::IfcPositiveInteger);
    current = entity_descriptor_map[Type::IfcIndexedTextureMap] = new IfcEntityDescriptor(Type::IfcIndexedTextureMap,entity_descriptor_map.find(Type::IfcTextureCoordinate)->second);
    current->add("MappedTo",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcTessellatedFaceSet);
    current->add("TexCoords",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcTextureVertexList);
    current = entity_descriptor_map[Type::IfcIndexedTriangleTextureMap] = new IfcEntityDescriptor(Type::IfcIndexedTriangleTextureMap,entity_descriptor_map.find(Type::IfcIndexedTextureMap)->second);
    current->add("TexCoordIndex",true,IfcUtil::Argument_AGGREGATE_OF_AGGREGATE_OF_INT,Type::IfcPositiveInteger);
    current = entity_descriptor_map[Type::IfcIrregularTimeSeries] = new IfcEntityDescriptor(Type::IfcIrregularTimeSeries,entity_descriptor_map.find(Type::IfcTimeSeries)->second);
    current->add("Values",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcIrregularTimeSeriesValue);
    current = entity_descriptor_map[Type::IfcLagTime] = new IfcEntityDescriptor(Type::IfcLagTime,entity_descriptor_map.find(Type::IfcSchedulingTime)->second);
    current->add("LagValue",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcTimeOrRatioSelect);
    current->add("DurationType",false,IfcUtil::Argument_ENUMERATION,Type::IfcTaskDurationEnum);
    current = entity_descriptor_map[Type::IfcLightSource] = new IfcEntityDescriptor(Type::IfcLightSource,entity_descriptor_map.find(Type::IfcGeometricRepresentationItem)->second);
    current->add("Name",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("LightColour",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcColourRgb);
    current->add("AmbientIntensity",true,IfcUtil::Argument_DOUBLE,Type::IfcNormalisedRatioMeasure);
    current->add("Intensity",true,IfcUtil::Argument_DOUBLE,Type::IfcNormalisedRatioMeasure);
    current = entity_descriptor_map[Type::IfcLightSourceAmbient] = new IfcEntityDescriptor(Type::IfcLightSourceAmbient,entity_descriptor_map.find(Type::IfcLightSource)->second);

    current = entity_descriptor_map[Type::IfcLightSourceDirectional] = new IfcEntityDescriptor(Type::IfcLightSourceDirectional,entity_descriptor_map.find(Type::IfcLightSource)->second);
    current->add("Orientation",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcDirection);
    current = entity_descriptor_map[Type::IfcLightSourceGoniometric] = new IfcEntityDescriptor(Type::IfcLightSourceGoniometric,entity_descriptor_map.find(Type::IfcLightSource)->second);
    current->add("Position",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcAxis2Placement3D);
    current->add("ColourAppearance",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcColourRgb);
    current->add("ColourTemperature",false,IfcUtil::Argument_DOUBLE,Type::IfcThermodynamicTemperatureMeasure);
    current->add("LuminousFlux",false,IfcUtil::Argument_DOUBLE,Type::IfcLuminousFluxMeasure);
    current->add("LightEmissionSource",false,IfcUtil::Argument_ENUMERATION,Type::IfcLightEmissionSourceEnum);
    current->add("LightDistributionDataSource",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcLightDistributionDataSourceSelect);
    current = entity_descriptor_map[Type::IfcLightSourcePositional] = new IfcEntityDescriptor(Type::IfcLightSourcePositional,entity_descriptor_map.find(Type::IfcLightSource)->second);
    current->add("Position",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcCartesianPoint);
    current->add("Radius",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("ConstantAttenuation",false,IfcUtil::Argument_DOUBLE,Type::IfcReal);
    current->add("DistanceAttenuation",false,IfcUtil::Argument_DOUBLE,Type::IfcReal);
    current->add("QuadricAttenuation",false,IfcUtil::Argument_DOUBLE,Type::IfcReal);
    current = entity_descriptor_map[Type::IfcLightSourceSpot] = new IfcEntityDescriptor(Type::IfcLightSourceSpot,entity_descriptor_map.find(Type::IfcLightSourcePositional)->second);
    current->add("Orientation",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcDirection);
    current->add("ConcentrationExponent",true,IfcUtil::Argument_DOUBLE,Type::IfcReal);
    current->add("SpreadAngle",false,IfcUtil::Argument_DOUBLE,Type::IfcPositivePlaneAngleMeasure);
    current->add("BeamWidthAngle",false,IfcUtil::Argument_DOUBLE,Type::IfcPositivePlaneAngleMeasure);
    current = entity_descriptor_map[Type::IfcLocalPlacement] = new IfcEntityDescriptor(Type::IfcLocalPlacement,entity_descriptor_map.find(Type::IfcObjectPlacement)->second);
    current->add("PlacementRelTo",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcObjectPlacement);
    current->add("RelativePlacement",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcAxis2Placement);
    current = entity_descriptor_map[Type::IfcLoop] = new IfcEntityDescriptor(Type::IfcLoop,entity_descriptor_map.find(Type::IfcTopologicalRepresentationItem)->second);

    current = entity_descriptor_map[Type::IfcMappedItem] = new IfcEntityDescriptor(Type::IfcMappedItem,entity_descriptor_map.find(Type::IfcRepresentationItem)->second);
    current->add("MappingSource",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcRepresentationMap);
    current->add("MappingTarget",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcCartesianTransformationOperator);
    current = entity_descriptor_map[Type::IfcMaterial] = new IfcEntityDescriptor(Type::IfcMaterial,entity_descriptor_map.find(Type::IfcMaterialDefinition)->second);
    current->add("Name",false,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("Description",true,IfcUtil::Argument_STRING,Type::IfcText);
    current->add("Category",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current = entity_descriptor_map[Type::IfcMaterialConstituent] = new IfcEntityDescriptor(Type::IfcMaterialConstituent,entity_descriptor_map.find(Type::IfcMaterialDefinition)->second);
    current->add("Name",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("Description",true,IfcUtil::Argument_STRING,Type::IfcText);
    current->add("Material",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcMaterial);
    current->add("Fraction",true,IfcUtil::Argument_DOUBLE,Type::IfcNormalisedRatioMeasure);
    current->add("Category",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current = entity_descriptor_map[Type::IfcMaterialConstituentSet] = new IfcEntityDescriptor(Type::IfcMaterialConstituentSet,entity_descriptor_map.find(Type::IfcMaterialDefinition)->second);
    current->add("Name",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("Description",true,IfcUtil::Argument_STRING,Type::IfcText);
    current->add("MaterialConstituents",true,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcMaterialConstituent);
    current = entity_descriptor_map[Type::IfcMaterialDefinitionRepresentation] = new IfcEntityDescriptor(Type::IfcMaterialDefinitionRepresentation,entity_descriptor_map.find(Type::IfcProductRepresentation)->second);
    current->add("RepresentedMaterial",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcMaterial);
    current = entity_descriptor_map[Type::IfcMaterialLayerSetUsage] = new IfcEntityDescriptor(Type::IfcMaterialLayerSetUsage,entity_descriptor_map.find(Type::IfcMaterialUsageDefinition)->second);
    current->add("ForLayerSet",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcMaterialLayerSet);
    current->add("LayerSetDirection",false,IfcUtil::Argument_ENUMERATION,Type::IfcLayerSetDirectionEnum);
    current->add("DirectionSense",false,IfcUtil::Argument_ENUMERATION,Type::IfcDirectionSenseEnum);
    current->add("OffsetFromReferenceLine",false,IfcUtil::Argument_DOUBLE,Type::IfcLengthMeasure);
    current->add("ReferenceExtent",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current = entity_descriptor_map[Type::IfcMaterialProfileSetUsage] = new IfcEntityDescriptor(Type::IfcMaterialProfileSetUsage,entity_descriptor_map.find(Type::IfcMaterialUsageDefinition)->second);
    current->add("ForProfileSet",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcMaterialProfileSet);
    current->add("CardinalPoint",true,IfcUtil::Argument_INT,Type::IfcCardinalPointReference);
    current->add("ReferenceExtent",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current = entity_descriptor_map[Type::IfcMaterialProfileSetUsageTapering] = new IfcEntityDescriptor(Type::IfcMaterialProfileSetUsageTapering,entity_descriptor_map.find(Type::IfcMaterialProfileSetUsage)->second);
    current->add("ForProfileEndSet",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcMaterialProfileSet);
    current->add("CardinalEndPoint",true,IfcUtil::Argument_INT,Type::IfcCardinalPointReference);
    current = entity_descriptor_map[Type::IfcMaterialProperties] = new IfcEntityDescriptor(Type::IfcMaterialProperties,entity_descriptor_map.find(Type::IfcExtendedProperties)->second);
    current->add("Material",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcMaterialDefinition);
    current = entity_descriptor_map[Type::IfcMaterialRelationship] = new IfcEntityDescriptor(Type::IfcMaterialRelationship,entity_descriptor_map.find(Type::IfcResourceLevelRelationship)->second);
    current->add("RelatingMaterial",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcMaterial);
    current->add("RelatedMaterials",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcMaterial);
    current->add("Expression",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current = entity_descriptor_map[Type::IfcMirroredProfileDef] = new IfcEntityDescriptor(Type::IfcMirroredProfileDef,entity_descriptor_map.find(Type::IfcDerivedProfileDef)->second);

    current = entity_descriptor_map[Type::IfcObjectDefinition] = new IfcEntityDescriptor(Type::IfcObjectDefinition,entity_descriptor_map.find(Type::IfcRoot)->second);

    current = entity_descriptor_map[Type::IfcOpenShell] = new IfcEntityDescriptor(Type::IfcOpenShell,entity_descriptor_map.find(Type::IfcConnectedFaceSet)->second);

    current = entity_descriptor_map[Type::IfcOrganizationRelationship] = new IfcEntityDescriptor(Type::IfcOrganizationRelationship,entity_descriptor_map.find(Type::IfcResourceLevelRelationship)->second);
    current->add("RelatingOrganization",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcOrganization);
    current->add("RelatedOrganizations",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcOrganization);
    current = entity_descriptor_map[Type::IfcOrientedEdge] = new IfcEntityDescriptor(Type::IfcOrientedEdge,entity_descriptor_map.find(Type::IfcEdge)->second);
    current->add("EdgeElement",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcEdge);
    current->add("Orientation",false,IfcUtil::Argument_BOOL,Type::IfcBoolean);
    current = entity_descriptor_map[Type::IfcParameterizedProfileDef] = new IfcEntityDescriptor(Type::IfcParameterizedProfileDef,entity_descriptor_map.find(Type::IfcProfileDef)->second);
    current->add("Position",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcAxis2Placement2D);
    current = entity_descriptor_map[Type::IfcPath] = new IfcEntityDescriptor(Type::IfcPath,entity_descriptor_map.find(Type::IfcTopologicalRepresentationItem)->second);
    current->add("EdgeList",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcOrientedEdge);
    current = entity_descriptor_map[Type::IfcPhysicalComplexQuantity] = new IfcEntityDescriptor(Type::IfcPhysicalComplexQuantity,entity_descriptor_map.find(Type::IfcPhysicalQuantity)->second);
    current->add("HasQuantities",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcPhysicalQuantity);
    current->add("Discrimination",false,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("Quality",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("Usage",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current = entity_descriptor_map[Type::IfcPixelTexture] = new IfcEntityDescriptor(Type::IfcPixelTexture,entity_descriptor_map.find(Type::IfcSurfaceTexture)->second);
    current->add("Width",false,IfcUtil::Argument_INT,Type::IfcInteger);
    current->add("Height",false,IfcUtil::Argument_INT,Type::IfcInteger);
    current->add("ColourComponents",false,IfcUtil::Argument_INT,Type::IfcInteger);
    current->add("Pixel",false,IfcUtil::Argument_AGGREGATE_OF_BINARY,Type::IfcBinary);
    current = entity_descriptor_map[Type::IfcPlacement] = new IfcEntityDescriptor(Type::IfcPlacement,entity_descriptor_map.find(Type::IfcGeometricRepresentationItem)->second);
    current->add("Location",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcCartesianPoint);
    current = entity_descriptor_map[Type::IfcPlanarExtent] = new IfcEntityDescriptor(Type::IfcPlanarExtent,entity_descriptor_map.find(Type::IfcGeometricRepresentationItem)->second);
    current->add("SizeInX",false,IfcUtil::Argument_DOUBLE,Type::IfcLengthMeasure);
    current->add("SizeInY",false,IfcUtil::Argument_DOUBLE,Type::IfcLengthMeasure);
    current = entity_descriptor_map[Type::IfcPoint] = new IfcEntityDescriptor(Type::IfcPoint,entity_descriptor_map.find(Type::IfcGeometricRepresentationItem)->second);

    current = entity_descriptor_map[Type::IfcPointOnCurve] = new IfcEntityDescriptor(Type::IfcPointOnCurve,entity_descriptor_map.find(Type::IfcPoint)->second);
    current->add("BasisCurve",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcCurve);
    current->add("PointParameter",false,IfcUtil::Argument_DOUBLE,Type::IfcParameterValue);
    current = entity_descriptor_map[Type::IfcPointOnSurface] = new IfcEntityDescriptor(Type::IfcPointOnSurface,entity_descriptor_map.find(Type::IfcPoint)->second);
    current->add("BasisSurface",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcSurface);
    current->add("PointParameterU",false,IfcUtil::Argument_DOUBLE,Type::IfcParameterValue);
    current->add("PointParameterV",false,IfcUtil::Argument_DOUBLE,Type::IfcParameterValue);
    current = entity_descriptor_map[Type::IfcPolyLoop] = new IfcEntityDescriptor(Type::IfcPolyLoop,entity_descriptor_map.find(Type::IfcLoop)->second);
    current->add("Polygon",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcCartesianPoint);
    current = entity_descriptor_map[Type::IfcPolygonalBoundedHalfSpace] = new IfcEntityDescriptor(Type::IfcPolygonalBoundedHalfSpace,entity_descriptor_map.find(Type::IfcHalfSpaceSolid)->second);
    current->add("Position",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcAxis2Placement3D);
    current->add("PolygonalBoundary",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcBoundedCurve);
    current = entity_descriptor_map[Type::IfcPreDefinedItem] = new IfcEntityDescriptor(Type::IfcPreDefinedItem,entity_descriptor_map.find(Type::IfcPresentationItem)->second);
    current->add("Name",false,IfcUtil::Argument_STRING,Type::IfcLabel);
    current = entity_descriptor_map[Type::IfcPreDefinedProperties] = new IfcEntityDescriptor(Type::IfcPreDefinedProperties,entity_descriptor_map.find(Type::IfcPropertyAbstraction)->second);

    current = entity_descriptor_map[Type::IfcPreDefinedTextFont] = new IfcEntityDescriptor(Type::IfcPreDefinedTextFont,entity_descriptor_map.find(Type::IfcPreDefinedItem)->second);

    current = entity_descriptor_map[Type::IfcProductDefinitionShape] = new IfcEntityDescriptor(Type::IfcProductDefinitionShape,entity_descriptor_map.find(Type::IfcProductRepresentation)->second);

    current = entity_descriptor_map[Type::IfcProfileProperties] = new IfcEntityDescriptor(Type::IfcProfileProperties,entity_descriptor_map.find(Type::IfcExtendedProperties)->second);
    current->add("ProfileDefinition",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcProfileDef);
    current = entity_descriptor_map[Type::IfcProperty] = new IfcEntityDescriptor(Type::IfcProperty,entity_descriptor_map.find(Type::IfcPropertyAbstraction)->second);
    current->add("Name",false,IfcUtil::Argument_STRING,Type::IfcIdentifier);
    current->add("Description",true,IfcUtil::Argument_STRING,Type::IfcText);
    current = entity_descriptor_map[Type::IfcPropertyDefinition] = new IfcEntityDescriptor(Type::IfcPropertyDefinition,entity_descriptor_map.find(Type::IfcRoot)->second);

    current = entity_descriptor_map[Type::IfcPropertyDependencyRelationship] = new IfcEntityDescriptor(Type::IfcPropertyDependencyRelationship,entity_descriptor_map.find(Type::IfcResourceLevelRelationship)->second);
    current->add("DependingProperty",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcProperty);
    current->add("DependantProperty",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcProperty);
    current->add("Expression",true,IfcUtil::Argument_STRING,Type::IfcText);
    current = entity_descriptor_map[Type::IfcPropertySetDefinition] = new IfcEntityDescriptor(Type::IfcPropertySetDefinition,entity_descriptor_map.find(Type::IfcPropertyDefinition)->second);

    current = entity_descriptor_map[Type::IfcPropertyTemplateDefinition] = new IfcEntityDescriptor(Type::IfcPropertyTemplateDefinition,entity_descriptor_map.find(Type::IfcPropertyDefinition)->second);

    current = entity_descriptor_map[Type::IfcQuantitySet] = new IfcEntityDescriptor(Type::IfcQuantitySet,entity_descriptor_map.find(Type::IfcPropertySetDefinition)->second);

    current = entity_descriptor_map[Type::IfcRectangleProfileDef] = new IfcEntityDescriptor(Type::IfcRectangleProfileDef,entity_descriptor_map.find(Type::IfcParameterizedProfileDef)->second);
    current->add("XDim",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("YDim",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current = entity_descriptor_map[Type::IfcRegularTimeSeries] = new IfcEntityDescriptor(Type::IfcRegularTimeSeries,entity_descriptor_map.find(Type::IfcTimeSeries)->second);
    current->add("TimeStep",false,IfcUtil::Argument_DOUBLE,Type::IfcTimeMeasure);
    current->add("Values",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcTimeSeriesValue);
    current = entity_descriptor_map[Type::IfcReinforcementBarProperties] = new IfcEntityDescriptor(Type::IfcReinforcementBarProperties,entity_descriptor_map.find(Type::IfcPreDefinedProperties)->second);
    current->add("TotalCrossSectionArea",false,IfcUtil::Argument_DOUBLE,Type::IfcAreaMeasure);
    current->add("SteelGrade",false,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("BarSurface",true,IfcUtil::Argument_ENUMERATION,Type::IfcReinforcingBarSurfaceEnum);
    current->add("EffectiveDepth",true,IfcUtil::Argument_DOUBLE,Type::IfcLengthMeasure);
    current->add("NominalBarDiameter",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("BarCount",true,IfcUtil::Argument_DOUBLE,Type::IfcCountMeasure);
    current = entity_descriptor_map[Type::IfcRelationship] = new IfcEntityDescriptor(Type::IfcRelationship,entity_descriptor_map.find(Type::IfcRoot)->second);

    current = entity_descriptor_map[Type::IfcResourceApprovalRelationship] = new IfcEntityDescriptor(Type::IfcResourceApprovalRelationship,entity_descriptor_map.find(Type::IfcResourceLevelRelationship)->second);
    current->add("RelatedResourceObjects",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcResourceObjectSelect);
    current->add("RelatingApproval",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcApproval);
    current = entity_descriptor_map[Type::IfcResourceConstraintRelationship] = new IfcEntityDescriptor(Type::IfcResourceConstraintRelationship,entity_descriptor_map.find(Type::IfcResourceLevelRelationship)->second);
    current->add("RelatingConstraint",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcConstraint);
    current->add("RelatedResourceObjects",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcResourceObjectSelect);
    current = entity_descriptor_map[Type::IfcResourceTime] = new IfcEntityDescriptor(Type::IfcResourceTime,entity_descriptor_map.find(Type::IfcSchedulingTime)->second);
    current->add("ScheduleWork",true,IfcUtil::Argument_STRING,Type::IfcDuration);
    current->add("ScheduleUsage",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveRatioMeasure);
    current->add("ScheduleStart",true,IfcUtil::Argument_STRING,Type::IfcDateTime);
    current->add("ScheduleFinish",true,IfcUtil::Argument_STRING,Type::IfcDateTime);
    current->add("ScheduleContour",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("LevelingDelay",true,IfcUtil::Argument_STRING,Type::IfcDuration);
    current->add("IsOverAllocated",true,IfcUtil::Argument_BOOL,Type::IfcBoolean);
    current->add("StatusTime",true,IfcUtil::Argument_STRING,Type::IfcDateTime);
    current->add("ActualWork",true,IfcUtil::Argument_STRING,Type::IfcDuration);
    current->add("ActualUsage",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveRatioMeasure);
    current->add("ActualStart",true,IfcUtil::Argument_STRING,Type::IfcDateTime);
    current->add("ActualFinish",true,IfcUtil::Argument_STRING,Type::IfcDateTime);
    current->add("RemainingWork",true,IfcUtil::Argument_STRING,Type::IfcDuration);
    current->add("RemainingUsage",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveRatioMeasure);
    current->add("Completion",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveRatioMeasure);
    current = entity_descriptor_map[Type::IfcRoundedRectangleProfileDef] = new IfcEntityDescriptor(Type::IfcRoundedRectangleProfileDef,entity_descriptor_map.find(Type::IfcRectangleProfileDef)->second);
    current->add("RoundingRadius",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current = entity_descriptor_map[Type::IfcSectionProperties] = new IfcEntityDescriptor(Type::IfcSectionProperties,entity_descriptor_map.find(Type::IfcPreDefinedProperties)->second);
    current->add("SectionType",false,IfcUtil::Argument_ENUMERATION,Type::IfcSectionTypeEnum);
    current->add("StartProfile",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcProfileDef);
    current->add("EndProfile",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcProfileDef);
    current = entity_descriptor_map[Type::IfcSectionReinforcementProperties] = new IfcEntityDescriptor(Type::IfcSectionReinforcementProperties,entity_descriptor_map.find(Type::IfcPreDefinedProperties)->second);
    current->add("LongitudinalStartPosition",false,IfcUtil::Argument_DOUBLE,Type::IfcLengthMeasure);
    current->add("LongitudinalEndPosition",false,IfcUtil::Argument_DOUBLE,Type::IfcLengthMeasure);
    current->add("TransversePosition",true,IfcUtil::Argument_DOUBLE,Type::IfcLengthMeasure);
    current->add("ReinforcementRole",false,IfcUtil::Argument_ENUMERATION,Type::IfcReinforcingBarRoleEnum);
    current->add("SectionDefinition",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcSectionProperties);
    current->add("CrossSectionReinforcementDefinitions",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcReinforcementBarProperties);
    current = entity_descriptor_map[Type::IfcSectionedSpine] = new IfcEntityDescriptor(Type::IfcSectionedSpine,entity_descriptor_map.find(Type::IfcGeometricRepresentationItem)->second);
    current->add("SpineCurve",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcCompositeCurve);
    current->add("CrossSections",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcProfileDef);
    current->add("CrossSectionPositions",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcAxis2Placement3D);
    current = entity_descriptor_map[Type::IfcShellBasedSurfaceModel] = new IfcEntityDescriptor(Type::IfcShellBasedSurfaceModel,entity_descriptor_map.find(Type::IfcGeometricRepresentationItem)->second);
    current->add("SbsmBoundary",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcShell);
    current = entity_descriptor_map[Type::IfcSimpleProperty] = new IfcEntityDescriptor(Type::IfcSimpleProperty,entity_descriptor_map.find(Type::IfcProperty)->second);

    current = entity_descriptor_map[Type::IfcSlippageConnectionCondition] = new IfcEntityDescriptor(Type::IfcSlippageConnectionCondition,entity_descriptor_map.find(Type::IfcStructuralConnectionCondition)->second);
    current->add("SlippageX",true,IfcUtil::Argument_DOUBLE,Type::IfcLengthMeasure);
    current->add("SlippageY",true,IfcUtil::Argument_DOUBLE,Type::IfcLengthMeasure);
    current->add("SlippageZ",true,IfcUtil::Argument_DOUBLE,Type::IfcLengthMeasure);
    current = entity_descriptor_map[Type::IfcSolidModel] = new IfcEntityDescriptor(Type::IfcSolidModel,entity_descriptor_map.find(Type::IfcGeometricRepresentationItem)->second);

    current = entity_descriptor_map[Type::IfcStructuralLoadLinearForce] = new IfcEntityDescriptor(Type::IfcStructuralLoadLinearForce,entity_descriptor_map.find(Type::IfcStructuralLoadStatic)->second);
    current->add("LinearForceX",true,IfcUtil::Argument_DOUBLE,Type::IfcLinearForceMeasure);
    current->add("LinearForceY",true,IfcUtil::Argument_DOUBLE,Type::IfcLinearForceMeasure);
    current->add("LinearForceZ",true,IfcUtil::Argument_DOUBLE,Type::IfcLinearForceMeasure);
    current->add("LinearMomentX",true,IfcUtil::Argument_DOUBLE,Type::IfcLinearMomentMeasure);
    current->add("LinearMomentY",true,IfcUtil::Argument_DOUBLE,Type::IfcLinearMomentMeasure);
    current->add("LinearMomentZ",true,IfcUtil::Argument_DOUBLE,Type::IfcLinearMomentMeasure);
    current = entity_descriptor_map[Type::IfcStructuralLoadPlanarForce] = new IfcEntityDescriptor(Type::IfcStructuralLoadPlanarForce,entity_descriptor_map.find(Type::IfcStructuralLoadStatic)->second);
    current->add("PlanarForceX",true,IfcUtil::Argument_DOUBLE,Type::IfcPlanarForceMeasure);
    current->add("PlanarForceY",true,IfcUtil::Argument_DOUBLE,Type::IfcPlanarForceMeasure);
    current->add("PlanarForceZ",true,IfcUtil::Argument_DOUBLE,Type::IfcPlanarForceMeasure);
    current = entity_descriptor_map[Type::IfcStructuralLoadSingleDisplacement] = new IfcEntityDescriptor(Type::IfcStructuralLoadSingleDisplacement,entity_descriptor_map.find(Type::IfcStructuralLoadStatic)->second);
    current->add("DisplacementX",true,IfcUtil::Argument_DOUBLE,Type::IfcLengthMeasure);
    current->add("DisplacementY",true,IfcUtil::Argument_DOUBLE,Type::IfcLengthMeasure);
    current->add("DisplacementZ",true,IfcUtil::Argument_DOUBLE,Type::IfcLengthMeasure);
    current->add("RotationalDisplacementRX",true,IfcUtil::Argument_DOUBLE,Type::IfcPlaneAngleMeasure);
    current->add("RotationalDisplacementRY",true,IfcUtil::Argument_DOUBLE,Type::IfcPlaneAngleMeasure);
    current->add("RotationalDisplacementRZ",true,IfcUtil::Argument_DOUBLE,Type::IfcPlaneAngleMeasure);
    current = entity_descriptor_map[Type::IfcStructuralLoadSingleDisplacementDistortion] = new IfcEntityDescriptor(Type::IfcStructuralLoadSingleDisplacementDistortion,entity_descriptor_map.find(Type::IfcStructuralLoadSingleDisplacement)->second);
    current->add("Distortion",true,IfcUtil::Argument_DOUBLE,Type::IfcCurvatureMeasure);
    current = entity_descriptor_map[Type::IfcStructuralLoadSingleForce] = new IfcEntityDescriptor(Type::IfcStructuralLoadSingleForce,entity_descriptor_map.find(Type::IfcStructuralLoadStatic)->second);
    current->add("ForceX",true,IfcUtil::Argument_DOUBLE,Type::IfcForceMeasure);
    current->add("ForceY",true,IfcUtil::Argument_DOUBLE,Type::IfcForceMeasure);
    current->add("ForceZ",true,IfcUtil::Argument_DOUBLE,Type::IfcForceMeasure);
    current->add("MomentX",true,IfcUtil::Argument_DOUBLE,Type::IfcTorqueMeasure);
    current->add("MomentY",true,IfcUtil::Argument_DOUBLE,Type::IfcTorqueMeasure);
    current->add("MomentZ",true,IfcUtil::Argument_DOUBLE,Type::IfcTorqueMeasure);
    current = entity_descriptor_map[Type::IfcStructuralLoadSingleForceWarping] = new IfcEntityDescriptor(Type::IfcStructuralLoadSingleForceWarping,entity_descriptor_map.find(Type::IfcStructuralLoadSingleForce)->second);
    current->add("WarpingMoment",true,IfcUtil::Argument_DOUBLE,Type::IfcWarpingMomentMeasure);
    current = entity_descriptor_map[Type::IfcSubedge] = new IfcEntityDescriptor(Type::IfcSubedge,entity_descriptor_map.find(Type::IfcEdge)->second);
    current->add("ParentEdge",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcEdge);
    current = entity_descriptor_map[Type::IfcSurface] = new IfcEntityDescriptor(Type::IfcSurface,entity_descriptor_map.find(Type::IfcGeometricRepresentationItem)->second);

    current = entity_descriptor_map[Type::IfcSurfaceStyleRendering] = new IfcEntityDescriptor(Type::IfcSurfaceStyleRendering,entity_descriptor_map.find(Type::IfcSurfaceStyleShading)->second);
    current->add("DiffuseColour",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcColourOrFactor);
    current->add("TransmissionColour",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcColourOrFactor);
    current->add("DiffuseTransmissionColour",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcColourOrFactor);
    current->add("ReflectionColour",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcColourOrFactor);
    current->add("SpecularColour",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcColourOrFactor);
    current->add("SpecularHighlight",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcSpecularHighlightSelect);
    current->add("ReflectanceMethod",false,IfcUtil::Argument_ENUMERATION,Type::IfcReflectanceMethodEnum);
    current = entity_descriptor_map[Type::IfcSweptAreaSolid] = new IfcEntityDescriptor(Type::IfcSweptAreaSolid,entity_descriptor_map.find(Type::IfcSolidModel)->second);
    current->add("SweptArea",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcProfileDef);
    current->add("Position",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcAxis2Placement3D);
    current = entity_descriptor_map[Type::IfcSweptDiskSolid] = new IfcEntityDescriptor(Type::IfcSweptDiskSolid,entity_descriptor_map.find(Type::IfcSolidModel)->second);
    current->add("Directrix",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcCurve);
    current->add("Radius",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("InnerRadius",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("StartParam",true,IfcUtil::Argument_DOUBLE,Type::IfcParameterValue);
    current->add("EndParam",true,IfcUtil::Argument_DOUBLE,Type::IfcParameterValue);
    current = entity_descriptor_map[Type::IfcSweptDiskSolidPolygonal] = new IfcEntityDescriptor(Type::IfcSweptDiskSolidPolygonal,entity_descriptor_map.find(Type::IfcSweptDiskSolid)->second);
    current->add("FilletRadius",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current = entity_descriptor_map[Type::IfcSweptSurface] = new IfcEntityDescriptor(Type::IfcSweptSurface,entity_descriptor_map.find(Type::IfcSurface)->second);
    current->add("SweptCurve",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcProfileDef);
    current->add("Position",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcAxis2Placement3D);
    current = entity_descriptor_map[Type::IfcTShapeProfileDef] = new IfcEntityDescriptor(Type::IfcTShapeProfileDef,entity_descriptor_map.find(Type::IfcParameterizedProfileDef)->second);
    current->add("Depth",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("FlangeWidth",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("WebThickness",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("FlangeThickness",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("FilletRadius",true,IfcUtil::Argument_DOUBLE,Type::IfcNonNegativeLengthMeasure);
    current->add("FlangeEdgeRadius",true,IfcUtil::Argument_DOUBLE,Type::IfcNonNegativeLengthMeasure);
    current->add("WebEdgeRadius",true,IfcUtil::Argument_DOUBLE,Type::IfcNonNegativeLengthMeasure);
    current->add("WebSlope",true,IfcUtil::Argument_DOUBLE,Type::IfcPlaneAngleMeasure);
    current->add("FlangeSlope",true,IfcUtil::Argument_DOUBLE,Type::IfcPlaneAngleMeasure);
    current = entity_descriptor_map[Type::IfcTessellatedItem] = new IfcEntityDescriptor(Type::IfcTessellatedItem,entity_descriptor_map.find(Type::IfcGeometricRepresentationItem)->second);

    current = entity_descriptor_map[Type::IfcTextLiteral] = new IfcEntityDescriptor(Type::IfcTextLiteral,entity_descriptor_map.find(Type::IfcGeometricRepresentationItem)->second);
    current->add("Literal",false,IfcUtil::Argument_STRING,Type::IfcPresentableText);
    current->add("Placement",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcAxis2Placement);
    current->add("Path",false,IfcUtil::Argument_ENUMERATION,Type::IfcTextPath);
    current = entity_descriptor_map[Type::IfcTextLiteralWithExtent] = new IfcEntityDescriptor(Type::IfcTextLiteralWithExtent,entity_descriptor_map.find(Type::IfcTextLiteral)->second);
    current->add("Extent",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcPlanarExtent);
    current->add("BoxAlignment",false,IfcUtil::Argument_STRING,Type::IfcBoxAlignment);
    current = entity_descriptor_map[Type::IfcTextStyleFontModel] = new IfcEntityDescriptor(Type::IfcTextStyleFontModel,entity_descriptor_map.find(Type::IfcPreDefinedTextFont)->second);
    current->add("FontFamily",false,IfcUtil::Argument_AGGREGATE_OF_STRING,Type::IfcTextFontName);
    current->add("FontStyle",true,IfcUtil::Argument_STRING,Type::IfcFontStyle);
    current->add("FontVariant",true,IfcUtil::Argument_STRING,Type::IfcFontVariant);
    current->add("FontWeight",true,IfcUtil::Argument_STRING,Type::IfcFontWeight);
    current->add("FontSize",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcSizeSelect);
    current = entity_descriptor_map[Type::IfcTrapeziumProfileDef] = new IfcEntityDescriptor(Type::IfcTrapeziumProfileDef,entity_descriptor_map.find(Type::IfcParameterizedProfileDef)->second);
    current->add("BottomXDim",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("TopXDim",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("YDim",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("TopXOffset",false,IfcUtil::Argument_DOUBLE,Type::IfcLengthMeasure);
    current = entity_descriptor_map[Type::IfcTypeObject] = new IfcEntityDescriptor(Type::IfcTypeObject,entity_descriptor_map.find(Type::IfcObjectDefinition)->second);
    current->add("ApplicableOccurrence",true,IfcUtil::Argument_STRING,Type::IfcIdentifier);
    current->add("HasPropertySets",true,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcPropertySetDefinition);
    current = entity_descriptor_map[Type::IfcTypeProcess] = new IfcEntityDescriptor(Type::IfcTypeProcess,entity_descriptor_map.find(Type::IfcTypeObject)->second);
    current->add("Identification",true,IfcUtil::Argument_STRING,Type::IfcIdentifier);
    current->add("LongDescription",true,IfcUtil::Argument_STRING,Type::IfcText);
    current->add("ProcessType",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current = entity_descriptor_map[Type::IfcTypeProduct] = new IfcEntityDescriptor(Type::IfcTypeProduct,entity_descriptor_map.find(Type::IfcTypeObject)->second);
    current->add("RepresentationMaps",true,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcRepresentationMap);
    current->add("Tag",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current = entity_descriptor_map[Type::IfcTypeResource] = new IfcEntityDescriptor(Type::IfcTypeResource,entity_descriptor_map.find(Type::IfcTypeObject)->second);
    current->add("Identification",true,IfcUtil::Argument_STRING,Type::IfcIdentifier);
    current->add("LongDescription",true,IfcUtil::Argument_STRING,Type::IfcText);
    current->add("ResourceType",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current = entity_descriptor_map[Type::IfcUShapeProfileDef] = new IfcEntityDescriptor(Type::IfcUShapeProfileDef,entity_descriptor_map.find(Type::IfcParameterizedProfileDef)->second);
    current->add("Depth",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("FlangeWidth",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("WebThickness",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("FlangeThickness",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("FilletRadius",true,IfcUtil::Argument_DOUBLE,Type::IfcNonNegativeLengthMeasure);
    current->add("EdgeRadius",true,IfcUtil::Argument_DOUBLE,Type::IfcNonNegativeLengthMeasure);
    current->add("FlangeSlope",true,IfcUtil::Argument_DOUBLE,Type::IfcPlaneAngleMeasure);
    current = entity_descriptor_map[Type::IfcVector] = new IfcEntityDescriptor(Type::IfcVector,entity_descriptor_map.find(Type::IfcGeometricRepresentationItem)->second);
    current->add("Orientation",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcDirection);
    current->add("Magnitude",false,IfcUtil::Argument_DOUBLE,Type::IfcLengthMeasure);
    current = entity_descriptor_map[Type::IfcVertexLoop] = new IfcEntityDescriptor(Type::IfcVertexLoop,entity_descriptor_map.find(Type::IfcLoop)->second);
    current->add("LoopVertex",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcVertex);
    current = entity_descriptor_map[Type::IfcWindowStyle] = new IfcEntityDescriptor(Type::IfcWindowStyle,entity_descriptor_map.find(Type::IfcTypeProduct)->second);
    current->add("ConstructionType",false,IfcUtil::Argument_ENUMERATION,Type::IfcWindowStyleConstructionEnum);
    current->add("OperationType",false,IfcUtil::Argument_ENUMERATION,Type::IfcWindowStyleOperationEnum);
    current->add("ParameterTakesPrecedence",false,IfcUtil::Argument_BOOL,Type::IfcBoolean);
    current->add("Sizeable",false,IfcUtil::Argument_BOOL,Type::IfcBoolean);
    current = entity_descriptor_map[Type::IfcZShapeProfileDef] = new IfcEntityDescriptor(Type::IfcZShapeProfileDef,entity_descriptor_map.find(Type::IfcParameterizedProfileDef)->second);
    current->add("Depth",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("FlangeWidth",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("WebThickness",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("FlangeThickness",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("FilletRadius",true,IfcUtil::Argument_DOUBLE,Type::IfcNonNegativeLengthMeasure);
    current->add("EdgeRadius",true,IfcUtil::Argument_DOUBLE,Type::IfcNonNegativeLengthMeasure);
    current = entity_descriptor_map[Type::IfcAdvancedFace] = new IfcEntityDescriptor(Type::IfcAdvancedFace,entity_descriptor_map.find(Type::IfcFaceSurface)->second);

    current = entity_descriptor_map[Type::IfcAnnotationFillArea] = new IfcEntityDescriptor(Type::IfcAnnotationFillArea,entity_descriptor_map.find(Type::IfcGeometricRepresentationItem)->second);
    current->add("OuterBoundary",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcCurve);
    current->add("InnerBoundaries",true,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcCurve);
    current = entity_descriptor_map[Type::IfcAsymmetricIShapeProfileDef] = new IfcEntityDescriptor(Type::IfcAsymmetricIShapeProfileDef,entity_descriptor_map.find(Type::IfcParameterizedProfileDef)->second);
    current->add("BottomFlangeWidth",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("OverallDepth",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("WebThickness",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("BottomFlangeThickness",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("BottomFlangeFilletRadius",true,IfcUtil::Argument_DOUBLE,Type::IfcNonNegativeLengthMeasure);
    current->add("TopFlangeWidth",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("TopFlangeThickness",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("TopFlangeFilletRadius",true,IfcUtil::Argument_DOUBLE,Type::IfcNonNegativeLengthMeasure);
    current->add("BottomFlangeEdgeRadius",true,IfcUtil::Argument_DOUBLE,Type::IfcNonNegativeLengthMeasure);
    current->add("BottomFlangeSlope",true,IfcUtil::Argument_DOUBLE,Type::IfcPlaneAngleMeasure);
    current->add("TopFlangeEdgeRadius",true,IfcUtil::Argument_DOUBLE,Type::IfcNonNegativeLengthMeasure);
    current->add("TopFlangeSlope",true,IfcUtil::Argument_DOUBLE,Type::IfcPlaneAngleMeasure);
    current = entity_descriptor_map[Type::IfcAxis1Placement] = new IfcEntityDescriptor(Type::IfcAxis1Placement,entity_descriptor_map.find(Type::IfcPlacement)->second);
    current->add("Axis",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcDirection);
    current = entity_descriptor_map[Type::IfcAxis2Placement2D] = new IfcEntityDescriptor(Type::IfcAxis2Placement2D,entity_descriptor_map.find(Type::IfcPlacement)->second);
    current->add("RefDirection",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcDirection);
    current = entity_descriptor_map[Type::IfcAxis2Placement3D] = new IfcEntityDescriptor(Type::IfcAxis2Placement3D,entity_descriptor_map.find(Type::IfcPlacement)->second);
    current->add("Axis",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcDirection);
    current->add("RefDirection",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcDirection);
    current = entity_descriptor_map[Type::IfcBooleanResult] = new IfcEntityDescriptor(Type::IfcBooleanResult,entity_descriptor_map.find(Type::IfcGeometricRepresentationItem)->second);
    current->add("Operator",false,IfcUtil::Argument_ENUMERATION,Type::IfcBooleanOperator);
    current->add("FirstOperand",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcBooleanOperand);
    current->add("SecondOperand",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcBooleanOperand);
    current = entity_descriptor_map[Type::IfcBoundedSurface] = new IfcEntityDescriptor(Type::IfcBoundedSurface,entity_descriptor_map.find(Type::IfcSurface)->second);

    current = entity_descriptor_map[Type::IfcBoundingBox] = new IfcEntityDescriptor(Type::IfcBoundingBox,entity_descriptor_map.find(Type::IfcGeometricRepresentationItem)->second);
    current->add("Corner",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcCartesianPoint);
    current->add("XDim",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("YDim",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("ZDim",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current = entity_descriptor_map[Type::IfcBoxedHalfSpace] = new IfcEntityDescriptor(Type::IfcBoxedHalfSpace,entity_descriptor_map.find(Type::IfcHalfSpaceSolid)->second);
    current->add("Enclosure",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcBoundingBox);
    current = entity_descriptor_map[Type::IfcCShapeProfileDef] = new IfcEntityDescriptor(Type::IfcCShapeProfileDef,entity_descriptor_map.find(Type::IfcParameterizedProfileDef)->second);
    current->add("Depth",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("Width",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("WallThickness",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("Girth",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("InternalFilletRadius",true,IfcUtil::Argument_DOUBLE,Type::IfcNonNegativeLengthMeasure);
    current = entity_descriptor_map[Type::IfcCartesianPoint] = new IfcEntityDescriptor(Type::IfcCartesianPoint,entity_descriptor_map.find(Type::IfcPoint)->second);
    current->add("Coordinates",false,IfcUtil::Argument_AGGREGATE_OF_DOUBLE,Type::IfcLengthMeasure);
    current = entity_descriptor_map[Type::IfcCartesianPointList] = new IfcEntityDescriptor(Type::IfcCartesianPointList,entity_descriptor_map.find(Type::IfcGeometricRepresentationItem)->second);

    current = entity_descriptor_map[Type::IfcCartesianPointList2D] = new IfcEntityDescriptor(Type::IfcCartesianPointList2D,entity_descriptor_map.find(Type::IfcCartesianPointList)->second);
    current->add("CoordList",false,IfcUtil::Argument_AGGREGATE_OF_AGGREGATE_OF_DOUBLE,Type::IfcLengthMeasure);
    current = entity_descriptor_map[Type::IfcCartesianPointList3D] = new IfcEntityDescriptor(Type::IfcCartesianPointList3D,entity_descriptor_map.find(Type::IfcCartesianPointList)->second);
    current->add("CoordList",false,IfcUtil::Argument_AGGREGATE_OF_AGGREGATE_OF_DOUBLE,Type::IfcLengthMeasure);
    current = entity_descriptor_map[Type::IfcCartesianTransformationOperator] = new IfcEntityDescriptor(Type::IfcCartesianTransformationOperator,entity_descriptor_map.find(Type::IfcGeometricRepresentationItem)->second);
    current->add("Axis1",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcDirection);
    current->add("Axis2",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcDirection);
    current->add("LocalOrigin",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcCartesianPoint);
    current->add("Scale",true,IfcUtil::Argument_DOUBLE,Type::IfcReal);
    current = entity_descriptor_map[Type::IfcCartesianTransformationOperator2D] = new IfcEntityDescriptor(Type::IfcCartesianTransformationOperator2D,entity_descriptor_map.find(Type::IfcCartesianTransformationOperator)->second);

    current = entity_descriptor_map[Type::IfcCartesianTransformationOperator2DnonUniform] = new IfcEntityDescriptor(Type::IfcCartesianTransformationOperator2DnonUniform,entity_descriptor_map.find(Type::IfcCartesianTransformationOperator2D)->second);
    current->add("Scale2",true,IfcUtil::Argument_DOUBLE,Type::IfcReal);
    current = entity_descriptor_map[Type::IfcCartesianTransformationOperator3D] = new IfcEntityDescriptor(Type::IfcCartesianTransformationOperator3D,entity_descriptor_map.find(Type::IfcCartesianTransformationOperator)->second);
    current->add("Axis3",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcDirection);
    current = entity_descriptor_map[Type::IfcCartesianTransformationOperator3DnonUniform] = new IfcEntityDescriptor(Type::IfcCartesianTransformationOperator3DnonUniform,entity_descriptor_map.find(Type::IfcCartesianTransformationOperator3D)->second);
    current->add("Scale2",true,IfcUtil::Argument_DOUBLE,Type::IfcReal);
    current->add("Scale3",true,IfcUtil::Argument_DOUBLE,Type::IfcReal);
    current = entity_descriptor_map[Type::IfcCircleProfileDef] = new IfcEntityDescriptor(Type::IfcCircleProfileDef,entity_descriptor_map.find(Type::IfcParameterizedProfileDef)->second);
    current->add("Radius",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current = entity_descriptor_map[Type::IfcClosedShell] = new IfcEntityDescriptor(Type::IfcClosedShell,entity_descriptor_map.find(Type::IfcConnectedFaceSet)->second);

    current = entity_descriptor_map[Type::IfcColourRgb] = new IfcEntityDescriptor(Type::IfcColourRgb,entity_descriptor_map.find(Type::IfcColourSpecification)->second);
    current->add("Red",false,IfcUtil::Argument_DOUBLE,Type::IfcNormalisedRatioMeasure);
    current->add("Green",false,IfcUtil::Argument_DOUBLE,Type::IfcNormalisedRatioMeasure);
    current->add("Blue",false,IfcUtil::Argument_DOUBLE,Type::IfcNormalisedRatioMeasure);
    current = entity_descriptor_map[Type::IfcComplexProperty] = new IfcEntityDescriptor(Type::IfcComplexProperty,entity_descriptor_map.find(Type::IfcProperty)->second);
    current->add("UsageName",false,IfcUtil::Argument_STRING,Type::IfcIdentifier);
    current->add("HasProperties",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcProperty);
    current = entity_descriptor_map[Type::IfcCompositeCurveSegment] = new IfcEntityDescriptor(Type::IfcCompositeCurveSegment,entity_descriptor_map.find(Type::IfcGeometricRepresentationItem)->second);
    current->add("Transition",false,IfcUtil::Argument_ENUMERATION,Type::IfcTransitionCode);
    current->add("SameSense",false,IfcUtil::Argument_BOOL,Type::IfcBoolean);
    current->add("ParentCurve",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcCurve);
    current = entity_descriptor_map[Type::IfcConstructionResourceType] = new IfcEntityDescriptor(Type::IfcConstructionResourceType,entity_descriptor_map.find(Type::IfcTypeResource)->second);
    current->add("BaseCosts",true,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcAppliedValue);
    current->add("BaseQuantity",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcPhysicalQuantity);
    current = entity_descriptor_map[Type::IfcContext] = new IfcEntityDescriptor(Type::IfcContext,entity_descriptor_map.find(Type::IfcObjectDefinition)->second);
    current->add("ObjectType",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("LongName",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("Phase",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("RepresentationContexts",true,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcRepresentationContext);
    current->add("UnitsInContext",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcUnitAssignment);
    current = entity_descriptor_map[Type::IfcCrewResourceType] = new IfcEntityDescriptor(Type::IfcCrewResourceType,entity_descriptor_map.find(Type::IfcConstructionResourceType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcCrewResourceTypeEnum);
    current = entity_descriptor_map[Type::IfcCsgPrimitive3D] = new IfcEntityDescriptor(Type::IfcCsgPrimitive3D,entity_descriptor_map.find(Type::IfcGeometricRepresentationItem)->second);
    current->add("Position",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcAxis2Placement3D);
    current = entity_descriptor_map[Type::IfcCsgSolid] = new IfcEntityDescriptor(Type::IfcCsgSolid,entity_descriptor_map.find(Type::IfcSolidModel)->second);
    current->add("TreeRootExpression",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcCsgSelect);
    current = entity_descriptor_map[Type::IfcCurve] = new IfcEntityDescriptor(Type::IfcCurve,entity_descriptor_map.find(Type::IfcGeometricRepresentationItem)->second);

    current = entity_descriptor_map[Type::IfcCurveBoundedPlane] = new IfcEntityDescriptor(Type::IfcCurveBoundedPlane,entity_descriptor_map.find(Type::IfcBoundedSurface)->second);
    current->add("BasisSurface",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcPlane);
    current->add("OuterBoundary",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcCurve);
    current->add("InnerBoundaries",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcCurve);
    current = entity_descriptor_map[Type::IfcCurveBoundedSurface] = new IfcEntityDescriptor(Type::IfcCurveBoundedSurface,entity_descriptor_map.find(Type::IfcBoundedSurface)->second);
    current->add("BasisSurface",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcSurface);
    current->add("Boundaries",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcBoundaryCurve);
    current->add("ImplicitOuter",false,IfcUtil::Argument_BOOL,Type::IfcBoolean);
    current = entity_descriptor_map[Type::IfcDirection] = new IfcEntityDescriptor(Type::IfcDirection,entity_descriptor_map.find(Type::IfcGeometricRepresentationItem)->second);
    current->add("DirectionRatios",false,IfcUtil::Argument_AGGREGATE_OF_DOUBLE,Type::IfcReal);
    current = entity_descriptor_map[Type::IfcDoorStyle] = new IfcEntityDescriptor(Type::IfcDoorStyle,entity_descriptor_map.find(Type::IfcTypeProduct)->second);
    current->add("OperationType",false,IfcUtil::Argument_ENUMERATION,Type::IfcDoorStyleOperationEnum);
    current->add("ConstructionType",false,IfcUtil::Argument_ENUMERATION,Type::IfcDoorStyleConstructionEnum);
    current->add("ParameterTakesPrecedence",false,IfcUtil::Argument_BOOL,Type::IfcBoolean);
    current->add("Sizeable",false,IfcUtil::Argument_BOOL,Type::IfcBoolean);
    current = entity_descriptor_map[Type::IfcEdgeLoop] = new IfcEntityDescriptor(Type::IfcEdgeLoop,entity_descriptor_map.find(Type::IfcLoop)->second);
    current->add("EdgeList",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcOrientedEdge);
    current = entity_descriptor_map[Type::IfcElementQuantity] = new IfcEntityDescriptor(Type::IfcElementQuantity,entity_descriptor_map.find(Type::IfcQuantitySet)->second);
    current->add("MethodOfMeasurement",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("Quantities",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcPhysicalQuantity);
    current = entity_descriptor_map[Type::IfcElementType] = new IfcEntityDescriptor(Type::IfcElementType,entity_descriptor_map.find(Type::IfcTypeProduct)->second);
    current->add("ElementType",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current = entity_descriptor_map[Type::IfcElementarySurface] = new IfcEntityDescriptor(Type::IfcElementarySurface,entity_descriptor_map.find(Type::IfcSurface)->second);
    current->add("Position",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcAxis2Placement3D);
    current = entity_descriptor_map[Type::IfcEllipseProfileDef] = new IfcEntityDescriptor(Type::IfcEllipseProfileDef,entity_descriptor_map.find(Type::IfcParameterizedProfileDef)->second);
    current->add("SemiAxis1",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("SemiAxis2",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current = entity_descriptor_map[Type::IfcEventType] = new IfcEntityDescriptor(Type::IfcEventType,entity_descriptor_map.find(Type::IfcTypeProcess)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcEventTypeEnum);
    current->add("EventTriggerType",false,IfcUtil::Argument_ENUMERATION,Type::IfcEventTriggerTypeEnum);
    current->add("UserDefinedEventTriggerType",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current = entity_descriptor_map[Type::IfcExtrudedAreaSolid] = new IfcEntityDescriptor(Type::IfcExtrudedAreaSolid,entity_descriptor_map.find(Type::IfcSweptAreaSolid)->second);
    current->add("ExtrudedDirection",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcDirection);
    current->add("Depth",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current = entity_descriptor_map[Type::IfcExtrudedAreaSolidTapered] = new IfcEntityDescriptor(Type::IfcExtrudedAreaSolidTapered,entity_descriptor_map.find(Type::IfcExtrudedAreaSolid)->second);
    current->add("EndSweptArea",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcProfileDef);
    current = entity_descriptor_map[Type::IfcFaceBasedSurfaceModel] = new IfcEntityDescriptor(Type::IfcFaceBasedSurfaceModel,entity_descriptor_map.find(Type::IfcGeometricRepresentationItem)->second);
    current->add("FbsmFaces",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcConnectedFaceSet);
    current = entity_descriptor_map[Type::IfcFillAreaStyleHatching] = new IfcEntityDescriptor(Type::IfcFillAreaStyleHatching,entity_descriptor_map.find(Type::IfcGeometricRepresentationItem)->second);
    current->add("HatchLineAppearance",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcCurveStyle);
    current->add("StartOfNextHatchLine",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcHatchLineDistanceSelect);
    current->add("PointOfReferenceHatchLine",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcCartesianPoint);
    current->add("PatternStart",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcCartesianPoint);
    current->add("HatchLineAngle",false,IfcUtil::Argument_DOUBLE,Type::IfcPlaneAngleMeasure);
    current = entity_descriptor_map[Type::IfcFillAreaStyleTiles] = new IfcEntityDescriptor(Type::IfcFillAreaStyleTiles,entity_descriptor_map.find(Type::IfcGeometricRepresentationItem)->second);
    current->add("TilingPattern",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcVector);
    current->add("Tiles",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcStyledItem);
    current->add("TilingScale",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveRatioMeasure);
    current = entity_descriptor_map[Type::IfcFixedReferenceSweptAreaSolid] = new IfcEntityDescriptor(Type::IfcFixedReferenceSweptAreaSolid,entity_descriptor_map.find(Type::IfcSweptAreaSolid)->second);
    current->add("Directrix",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcCurve);
    current->add("StartParam",true,IfcUtil::Argument_DOUBLE,Type::IfcParameterValue);
    current->add("EndParam",true,IfcUtil::Argument_DOUBLE,Type::IfcParameterValue);
    current->add("FixedReference",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcDirection);
    current = entity_descriptor_map[Type::IfcFurnishingElementType] = new IfcEntityDescriptor(Type::IfcFurnishingElementType,entity_descriptor_map.find(Type::IfcElementType)->second);

    current = entity_descriptor_map[Type::IfcFurnitureType] = new IfcEntityDescriptor(Type::IfcFurnitureType,entity_descriptor_map.find(Type::IfcFurnishingElementType)->second);
    current->add("AssemblyPlace",false,IfcUtil::Argument_ENUMERATION,Type::IfcAssemblyPlaceEnum);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcFurnitureTypeEnum);
    current = entity_descriptor_map[Type::IfcGeographicElementType] = new IfcEntityDescriptor(Type::IfcGeographicElementType,entity_descriptor_map.find(Type::IfcElementType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcGeographicElementTypeEnum);
    current = entity_descriptor_map[Type::IfcGeometricCurveSet] = new IfcEntityDescriptor(Type::IfcGeometricCurveSet,entity_descriptor_map.find(Type::IfcGeometricSet)->second);

    current = entity_descriptor_map[Type::IfcIShapeProfileDef] = new IfcEntityDescriptor(Type::IfcIShapeProfileDef,entity_descriptor_map.find(Type::IfcParameterizedProfileDef)->second);
    current->add("OverallWidth",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("OverallDepth",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("WebThickness",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("FlangeThickness",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("FilletRadius",true,IfcUtil::Argument_DOUBLE,Type::IfcNonNegativeLengthMeasure);
    current->add("FlangeEdgeRadius",true,IfcUtil::Argument_DOUBLE,Type::IfcNonNegativeLengthMeasure);
    current->add("FlangeSlope",true,IfcUtil::Argument_DOUBLE,Type::IfcPlaneAngleMeasure);
    current = entity_descriptor_map[Type::IfcLShapeProfileDef] = new IfcEntityDescriptor(Type::IfcLShapeProfileDef,entity_descriptor_map.find(Type::IfcParameterizedProfileDef)->second);
    current->add("Depth",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("Width",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("Thickness",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("FilletRadius",true,IfcUtil::Argument_DOUBLE,Type::IfcNonNegativeLengthMeasure);
    current->add("EdgeRadius",true,IfcUtil::Argument_DOUBLE,Type::IfcNonNegativeLengthMeasure);
    current->add("LegSlope",true,IfcUtil::Argument_DOUBLE,Type::IfcPlaneAngleMeasure);
    current = entity_descriptor_map[Type::IfcLaborResourceType] = new IfcEntityDescriptor(Type::IfcLaborResourceType,entity_descriptor_map.find(Type::IfcConstructionResourceType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcLaborResourceTypeEnum);
    current = entity_descriptor_map[Type::IfcLine] = new IfcEntityDescriptor(Type::IfcLine,entity_descriptor_map.find(Type::IfcCurve)->second);
    current->add("Pnt",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcCartesianPoint);
    current->add("Dir",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcVector);
    current = entity_descriptor_map[Type::IfcManifoldSolidBrep] = new IfcEntityDescriptor(Type::IfcManifoldSolidBrep,entity_descriptor_map.find(Type::IfcSolidModel)->second);
    current->add("Outer",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcClosedShell);
    current = entity_descriptor_map[Type::IfcObject] = new IfcEntityDescriptor(Type::IfcObject,entity_descriptor_map.find(Type::IfcObjectDefinition)->second);
    current->add("ObjectType",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current = entity_descriptor_map[Type::IfcOffsetCurve2D] = new IfcEntityDescriptor(Type::IfcOffsetCurve2D,entity_descriptor_map.find(Type::IfcCurve)->second);
    current->add("BasisCurve",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcCurve);
    current->add("Distance",false,IfcUtil::Argument_DOUBLE,Type::IfcLengthMeasure);
    current->add("SelfIntersect",false,IfcUtil::Argument_BOOL,Type::IfcLogical);
    current = entity_descriptor_map[Type::IfcOffsetCurve3D] = new IfcEntityDescriptor(Type::IfcOffsetCurve3D,entity_descriptor_map.find(Type::IfcCurve)->second);
    current->add("BasisCurve",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcCurve);
    current->add("Distance",false,IfcUtil::Argument_DOUBLE,Type::IfcLengthMeasure);
    current->add("SelfIntersect",false,IfcUtil::Argument_BOOL,Type::IfcLogical);
    current->add("RefDirection",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcDirection);
    current = entity_descriptor_map[Type::IfcPcurve] = new IfcEntityDescriptor(Type::IfcPcurve,entity_descriptor_map.find(Type::IfcCurve)->second);
    current->add("BasisSurface",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcSurface);
    current->add("ReferenceCurve",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcCurve);
    current = entity_descriptor_map[Type::IfcPlanarBox] = new IfcEntityDescriptor(Type::IfcPlanarBox,entity_descriptor_map.find(Type::IfcPlanarExtent)->second);
    current->add("Placement",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcAxis2Placement);
    current = entity_descriptor_map[Type::IfcPlane] = new IfcEntityDescriptor(Type::IfcPlane,entity_descriptor_map.find(Type::IfcElementarySurface)->second);

    current = entity_descriptor_map[Type::IfcPreDefinedColour] = new IfcEntityDescriptor(Type::IfcPreDefinedColour,entity_descriptor_map.find(Type::IfcPreDefinedItem)->second);

    current = entity_descriptor_map[Type::IfcPreDefinedCurveFont] = new IfcEntityDescriptor(Type::IfcPreDefinedCurveFont,entity_descriptor_map.find(Type::IfcPreDefinedItem)->second);

    current = entity_descriptor_map[Type::IfcPreDefinedPropertySet] = new IfcEntityDescriptor(Type::IfcPreDefinedPropertySet,entity_descriptor_map.find(Type::IfcPropertySetDefinition)->second);

    current = entity_descriptor_map[Type::IfcProcedureType] = new IfcEntityDescriptor(Type::IfcProcedureType,entity_descriptor_map.find(Type::IfcTypeProcess)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcProcedureTypeEnum);
    current = entity_descriptor_map[Type::IfcProcess] = new IfcEntityDescriptor(Type::IfcProcess,entity_descriptor_map.find(Type::IfcObject)->second);
    current->add("Identification",true,IfcUtil::Argument_STRING,Type::IfcIdentifier);
    current->add("LongDescription",true,IfcUtil::Argument_STRING,Type::IfcText);
    current = entity_descriptor_map[Type::IfcProduct] = new IfcEntityDescriptor(Type::IfcProduct,entity_descriptor_map.find(Type::IfcObject)->second);
    current->add("ObjectPlacement",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcObjectPlacement);
    current->add("Representation",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcProductRepresentation);
    current = entity_descriptor_map[Type::IfcProject] = new IfcEntityDescriptor(Type::IfcProject,entity_descriptor_map.find(Type::IfcContext)->second);

    current = entity_descriptor_map[Type::IfcProjectLibrary] = new IfcEntityDescriptor(Type::IfcProjectLibrary,entity_descriptor_map.find(Type::IfcContext)->second);

    current = entity_descriptor_map[Type::IfcPropertyBoundedValue] = new IfcEntityDescriptor(Type::IfcPropertyBoundedValue,entity_descriptor_map.find(Type::IfcSimpleProperty)->second);
    current->add("UpperBoundValue",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcValue);
    current->add("LowerBoundValue",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcValue);
    current->add("Unit",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcUnit);
    current->add("SetPointValue",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcValue);
    current = entity_descriptor_map[Type::IfcPropertyEnumeratedValue] = new IfcEntityDescriptor(Type::IfcPropertyEnumeratedValue,entity_descriptor_map.find(Type::IfcSimpleProperty)->second);
    current->add("EnumerationValues",true,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcValue);
    current->add("EnumerationReference",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcPropertyEnumeration);
    current = entity_descriptor_map[Type::IfcPropertyListValue] = new IfcEntityDescriptor(Type::IfcPropertyListValue,entity_descriptor_map.find(Type::IfcSimpleProperty)->second);
    current->add("ListValues",true,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcValue);
    current->add("Unit",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcUnit);
    current = entity_descriptor_map[Type::IfcPropertyReferenceValue] = new IfcEntityDescriptor(Type::IfcPropertyReferenceValue,entity_descriptor_map.find(Type::IfcSimpleProperty)->second);
    current->add("UsageName",true,IfcUtil::Argument_STRING,Type::IfcText);
    current->add("PropertyReference",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcObjectReferenceSelect);
    current = entity_descriptor_map[Type::IfcPropertySet] = new IfcEntityDescriptor(Type::IfcPropertySet,entity_descriptor_map.find(Type::IfcPropertySetDefinition)->second);
    current->add("HasProperties",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcProperty);
    current = entity_descriptor_map[Type::IfcPropertySetTemplate] = new IfcEntityDescriptor(Type::IfcPropertySetTemplate,entity_descriptor_map.find(Type::IfcPropertyTemplateDefinition)->second);
    current->add("TemplateType",true,IfcUtil::Argument_ENUMERATION,Type::IfcPropertySetTemplateTypeEnum);
    current->add("ApplicableEntity",true,IfcUtil::Argument_STRING,Type::IfcIdentifier);
    current->add("HasPropertyTemplates",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcPropertyTemplate);
    current = entity_descriptor_map[Type::IfcPropertySingleValue] = new IfcEntityDescriptor(Type::IfcPropertySingleValue,entity_descriptor_map.find(Type::IfcSimpleProperty)->second);
    current->add("NominalValue",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcValue);
    current->add("Unit",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcUnit);
    current = entity_descriptor_map[Type::IfcPropertyTableValue] = new IfcEntityDescriptor(Type::IfcPropertyTableValue,entity_descriptor_map.find(Type::IfcSimpleProperty)->second);
    current->add("DefiningValues",true,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcValue);
    current->add("DefinedValues",true,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcValue);
    current->add("Expression",true,IfcUtil::Argument_STRING,Type::IfcText);
    current->add("DefiningUnit",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcUnit);
    current->add("DefinedUnit",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcUnit);
    current->add("CurveInterpolation",true,IfcUtil::Argument_ENUMERATION,Type::IfcCurveInterpolationEnum);
    current = entity_descriptor_map[Type::IfcPropertyTemplate] = new IfcEntityDescriptor(Type::IfcPropertyTemplate,entity_descriptor_map.find(Type::IfcPropertyTemplateDefinition)->second);

    current = entity_descriptor_map[Type::IfcProxy] = new IfcEntityDescriptor(Type::IfcProxy,entity_descriptor_map.find(Type::IfcProduct)->second);
    current->add("ProxyType",false,IfcUtil::Argument_ENUMERATION,Type::IfcObjectTypeEnum);
    current->add("Tag",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current = entity_descriptor_map[Type::IfcRectangleHollowProfileDef] = new IfcEntityDescriptor(Type::IfcRectangleHollowProfileDef,entity_descriptor_map.find(Type::IfcRectangleProfileDef)->second);
    current->add("WallThickness",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("InnerFilletRadius",true,IfcUtil::Argument_DOUBLE,Type::IfcNonNegativeLengthMeasure);
    current->add("OuterFilletRadius",true,IfcUtil::Argument_DOUBLE,Type::IfcNonNegativeLengthMeasure);
    current = entity_descriptor_map[Type::IfcRectangularPyramid] = new IfcEntityDescriptor(Type::IfcRectangularPyramid,entity_descriptor_map.find(Type::IfcCsgPrimitive3D)->second);
    current->add("XLength",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("YLength",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("Height",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current = entity_descriptor_map[Type::IfcRectangularTrimmedSurface] = new IfcEntityDescriptor(Type::IfcRectangularTrimmedSurface,entity_descriptor_map.find(Type::IfcBoundedSurface)->second);
    current->add("BasisSurface",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcSurface);
    current->add("U1",false,IfcUtil::Argument_DOUBLE,Type::IfcParameterValue);
    current->add("V1",false,IfcUtil::Argument_DOUBLE,Type::IfcParameterValue);
    current->add("U2",false,IfcUtil::Argument_DOUBLE,Type::IfcParameterValue);
    current->add("V2",false,IfcUtil::Argument_DOUBLE,Type::IfcParameterValue);
    current->add("Usense",false,IfcUtil::Argument_BOOL,Type::IfcBoolean);
    current->add("Vsense",false,IfcUtil::Argument_BOOL,Type::IfcBoolean);
    current = entity_descriptor_map[Type::IfcReinforcementDefinitionProperties] = new IfcEntityDescriptor(Type::IfcReinforcementDefinitionProperties,entity_descriptor_map.find(Type::IfcPreDefinedPropertySet)->second);
    current->add("DefinitionType",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("ReinforcementSectionDefinitions",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcSectionReinforcementProperties);
    current = entity_descriptor_map[Type::IfcRelAssigns] = new IfcEntityDescriptor(Type::IfcRelAssigns,entity_descriptor_map.find(Type::IfcRelationship)->second);
    current->add("RelatedObjects",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcObjectDefinition);
    current->add("RelatedObjectsType",true,IfcUtil::Argument_ENUMERATION,Type::IfcObjectTypeEnum);
    current = entity_descriptor_map[Type::IfcRelAssignsToActor] = new IfcEntityDescriptor(Type::IfcRelAssignsToActor,entity_descriptor_map.find(Type::IfcRelAssigns)->second);
    current->add("RelatingActor",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcActor);
    current->add("ActingRole",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcActorRole);
    current = entity_descriptor_map[Type::IfcRelAssignsToControl] = new IfcEntityDescriptor(Type::IfcRelAssignsToControl,entity_descriptor_map.find(Type::IfcRelAssigns)->second);
    current->add("RelatingControl",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcControl);
    current = entity_descriptor_map[Type::IfcRelAssignsToGroup] = new IfcEntityDescriptor(Type::IfcRelAssignsToGroup,entity_descriptor_map.find(Type::IfcRelAssigns)->second);
    current->add("RelatingGroup",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcGroup);
    current = entity_descriptor_map[Type::IfcRelAssignsToGroupByFactor] = new IfcEntityDescriptor(Type::IfcRelAssignsToGroupByFactor,entity_descriptor_map.find(Type::IfcRelAssignsToGroup)->second);
    current->add("Factor",false,IfcUtil::Argument_DOUBLE,Type::IfcRatioMeasure);
    current = entity_descriptor_map[Type::IfcRelAssignsToProcess] = new IfcEntityDescriptor(Type::IfcRelAssignsToProcess,entity_descriptor_map.find(Type::IfcRelAssigns)->second);
    current->add("RelatingProcess",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcProcessSelect);
    current->add("QuantityInProcess",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcMeasureWithUnit);
    current = entity_descriptor_map[Type::IfcRelAssignsToProduct] = new IfcEntityDescriptor(Type::IfcRelAssignsToProduct,entity_descriptor_map.find(Type::IfcRelAssigns)->second);
    current->add("RelatingProduct",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcProductSelect);
    current = entity_descriptor_map[Type::IfcRelAssignsToResource] = new IfcEntityDescriptor(Type::IfcRelAssignsToResource,entity_descriptor_map.find(Type::IfcRelAssigns)->second);
    current->add("RelatingResource",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcResourceSelect);
    current = entity_descriptor_map[Type::IfcRelAssociates] = new IfcEntityDescriptor(Type::IfcRelAssociates,entity_descriptor_map.find(Type::IfcRelationship)->second);
    current->add("RelatedObjects",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcDefinitionSelect);
    current = entity_descriptor_map[Type::IfcRelAssociatesApproval] = new IfcEntityDescriptor(Type::IfcRelAssociatesApproval,entity_descriptor_map.find(Type::IfcRelAssociates)->second);
    current->add("RelatingApproval",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcApproval);
    current = entity_descriptor_map[Type::IfcRelAssociatesClassification] = new IfcEntityDescriptor(Type::IfcRelAssociatesClassification,entity_descriptor_map.find(Type::IfcRelAssociates)->second);
    current->add("RelatingClassification",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcClassificationSelect);
    current = entity_descriptor_map[Type::IfcRelAssociatesConstraint] = new IfcEntityDescriptor(Type::IfcRelAssociatesConstraint,entity_descriptor_map.find(Type::IfcRelAssociates)->second);
    current->add("Intent",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("RelatingConstraint",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcConstraint);
    current = entity_descriptor_map[Type::IfcRelAssociatesDocument] = new IfcEntityDescriptor(Type::IfcRelAssociatesDocument,entity_descriptor_map.find(Type::IfcRelAssociates)->second);
    current->add("RelatingDocument",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcDocumentSelect);
    current = entity_descriptor_map[Type::IfcRelAssociatesLibrary] = new IfcEntityDescriptor(Type::IfcRelAssociatesLibrary,entity_descriptor_map.find(Type::IfcRelAssociates)->second);
    current->add("RelatingLibrary",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcLibrarySelect);
    current = entity_descriptor_map[Type::IfcRelAssociatesMaterial] = new IfcEntityDescriptor(Type::IfcRelAssociatesMaterial,entity_descriptor_map.find(Type::IfcRelAssociates)->second);
    current->add("RelatingMaterial",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcMaterialSelect);
    current = entity_descriptor_map[Type::IfcRelConnects] = new IfcEntityDescriptor(Type::IfcRelConnects,entity_descriptor_map.find(Type::IfcRelationship)->second);

    current = entity_descriptor_map[Type::IfcRelConnectsElements] = new IfcEntityDescriptor(Type::IfcRelConnectsElements,entity_descriptor_map.find(Type::IfcRelConnects)->second);
    current->add("ConnectionGeometry",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcConnectionGeometry);
    current->add("RelatingElement",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcElement);
    current->add("RelatedElement",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcElement);
    current = entity_descriptor_map[Type::IfcRelConnectsPathElements] = new IfcEntityDescriptor(Type::IfcRelConnectsPathElements,entity_descriptor_map.find(Type::IfcRelConnectsElements)->second);
    current->add("RelatingPriorities",false,IfcUtil::Argument_AGGREGATE_OF_INT,Type::IfcInteger);
    current->add("RelatedPriorities",false,IfcUtil::Argument_AGGREGATE_OF_INT,Type::IfcInteger);
    current->add("RelatedConnectionType",false,IfcUtil::Argument_ENUMERATION,Type::IfcConnectionTypeEnum);
    current->add("RelatingConnectionType",false,IfcUtil::Argument_ENUMERATION,Type::IfcConnectionTypeEnum);
    current = entity_descriptor_map[Type::IfcRelConnectsPortToElement] = new IfcEntityDescriptor(Type::IfcRelConnectsPortToElement,entity_descriptor_map.find(Type::IfcRelConnects)->second);
    current->add("RelatingPort",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcPort);
    current->add("RelatedElement",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcDistributionElement);
    current = entity_descriptor_map[Type::IfcRelConnectsPorts] = new IfcEntityDescriptor(Type::IfcRelConnectsPorts,entity_descriptor_map.find(Type::IfcRelConnects)->second);
    current->add("RelatingPort",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcPort);
    current->add("RelatedPort",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcPort);
    current->add("RealizingElement",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcElement);
    current = entity_descriptor_map[Type::IfcRelConnectsStructuralActivity] = new IfcEntityDescriptor(Type::IfcRelConnectsStructuralActivity,entity_descriptor_map.find(Type::IfcRelConnects)->second);
    current->add("RelatingElement",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcStructuralActivityAssignmentSelect);
    current->add("RelatedStructuralActivity",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcStructuralActivity);
    current = entity_descriptor_map[Type::IfcRelConnectsStructuralMember] = new IfcEntityDescriptor(Type::IfcRelConnectsStructuralMember,entity_descriptor_map.find(Type::IfcRelConnects)->second);
    current->add("RelatingStructuralMember",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcStructuralMember);
    current->add("RelatedStructuralConnection",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcStructuralConnection);
    current->add("AppliedCondition",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcBoundaryCondition);
    current->add("AdditionalConditions",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcStructuralConnectionCondition);
    current->add("SupportedLength",true,IfcUtil::Argument_DOUBLE,Type::IfcLengthMeasure);
    current->add("ConditionCoordinateSystem",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcAxis2Placement3D);
    current = entity_descriptor_map[Type::IfcRelConnectsWithEccentricity] = new IfcEntityDescriptor(Type::IfcRelConnectsWithEccentricity,entity_descriptor_map.find(Type::IfcRelConnectsStructuralMember)->second);
    current->add("ConnectionConstraint",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcConnectionGeometry);
    current = entity_descriptor_map[Type::IfcRelConnectsWithRealizingElements] = new IfcEntityDescriptor(Type::IfcRelConnectsWithRealizingElements,entity_descriptor_map.find(Type::IfcRelConnectsElements)->second);
    current->add("RealizingElements",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcElement);
    current->add("ConnectionType",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current = entity_descriptor_map[Type::IfcRelContainedInSpatialStructure] = new IfcEntityDescriptor(Type::IfcRelContainedInSpatialStructure,entity_descriptor_map.find(Type::IfcRelConnects)->second);
    current->add("RelatedElements",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcProduct);
    current->add("RelatingStructure",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcSpatialElement);
    current = entity_descriptor_map[Type::IfcRelCoversBldgElements] = new IfcEntityDescriptor(Type::IfcRelCoversBldgElements,entity_descriptor_map.find(Type::IfcRelConnects)->second);
    current->add("RelatingBuildingElement",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcElement);
    current->add("RelatedCoverings",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcCovering);
    current = entity_descriptor_map[Type::IfcRelCoversSpaces] = new IfcEntityDescriptor(Type::IfcRelCoversSpaces,entity_descriptor_map.find(Type::IfcRelConnects)->second);
    current->add("RelatingSpace",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcSpace);
    current->add("RelatedCoverings",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcCovering);
    current = entity_descriptor_map[Type::IfcRelDeclares] = new IfcEntityDescriptor(Type::IfcRelDeclares,entity_descriptor_map.find(Type::IfcRelationship)->second);
    current->add("RelatingContext",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcContext);
    current->add("RelatedDefinitions",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcDefinitionSelect);
    current = entity_descriptor_map[Type::IfcRelDecomposes] = new IfcEntityDescriptor(Type::IfcRelDecomposes,entity_descriptor_map.find(Type::IfcRelationship)->second);

    current = entity_descriptor_map[Type::IfcRelDefines] = new IfcEntityDescriptor(Type::IfcRelDefines,entity_descriptor_map.find(Type::IfcRelationship)->second);

    current = entity_descriptor_map[Type::IfcRelDefinesByObject] = new IfcEntityDescriptor(Type::IfcRelDefinesByObject,entity_descriptor_map.find(Type::IfcRelDefines)->second);
    current->add("RelatedObjects",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcObject);
    current->add("RelatingObject",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcObject);
    current = entity_descriptor_map[Type::IfcRelDefinesByProperties] = new IfcEntityDescriptor(Type::IfcRelDefinesByProperties,entity_descriptor_map.find(Type::IfcRelDefines)->second);
    current->add("RelatedObjects",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcObjectDefinition);
    current->add("RelatingPropertyDefinition",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcPropertySetDefinitionSelect);
    current = entity_descriptor_map[Type::IfcRelDefinesByTemplate] = new IfcEntityDescriptor(Type::IfcRelDefinesByTemplate,entity_descriptor_map.find(Type::IfcRelDefines)->second);
    current->add("RelatedPropertySets",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcPropertySetDefinition);
    current->add("RelatingTemplate",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcPropertySetTemplate);
    current = entity_descriptor_map[Type::IfcRelDefinesByType] = new IfcEntityDescriptor(Type::IfcRelDefinesByType,entity_descriptor_map.find(Type::IfcRelDefines)->second);
    current->add("RelatedObjects",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcObject);
    current->add("RelatingType",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcTypeObject);
    current = entity_descriptor_map[Type::IfcRelFillsElement] = new IfcEntityDescriptor(Type::IfcRelFillsElement,entity_descriptor_map.find(Type::IfcRelConnects)->second);
    current->add("RelatingOpeningElement",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcOpeningElement);
    current->add("RelatedBuildingElement",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcElement);
    current = entity_descriptor_map[Type::IfcRelFlowControlElements] = new IfcEntityDescriptor(Type::IfcRelFlowControlElements,entity_descriptor_map.find(Type::IfcRelConnects)->second);
    current->add("RelatedControlElements",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcDistributionControlElement);
    current->add("RelatingFlowElement",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcDistributionFlowElement);
    current = entity_descriptor_map[Type::IfcRelInterferesElements] = new IfcEntityDescriptor(Type::IfcRelInterferesElements,entity_descriptor_map.find(Type::IfcRelConnects)->second);
    current->add("RelatingElement",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcElement);
    current->add("RelatedElement",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcElement);
    current->add("InterferenceGeometry",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcConnectionGeometry);
    current->add("InterferenceType",true,IfcUtil::Argument_STRING,Type::IfcIdentifier);
    current->add("ImpliedOrder",false,IfcUtil::Argument_BOOL,Type::UNDEFINED);
    current = entity_descriptor_map[Type::IfcRelNests] = new IfcEntityDescriptor(Type::IfcRelNests,entity_descriptor_map.find(Type::IfcRelDecomposes)->second);
    current->add("RelatingObject",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcObjectDefinition);
    current->add("RelatedObjects",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcObjectDefinition);
    current = entity_descriptor_map[Type::IfcRelProjectsElement] = new IfcEntityDescriptor(Type::IfcRelProjectsElement,entity_descriptor_map.find(Type::IfcRelDecomposes)->second);
    current->add("RelatingElement",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcElement);
    current->add("RelatedFeatureElement",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcFeatureElementAddition);
    current = entity_descriptor_map[Type::IfcRelReferencedInSpatialStructure] = new IfcEntityDescriptor(Type::IfcRelReferencedInSpatialStructure,entity_descriptor_map.find(Type::IfcRelConnects)->second);
    current->add("RelatedElements",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcProduct);
    current->add("RelatingStructure",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcSpatialElement);
    current = entity_descriptor_map[Type::IfcRelSequence] = new IfcEntityDescriptor(Type::IfcRelSequence,entity_descriptor_map.find(Type::IfcRelConnects)->second);
    current->add("RelatingProcess",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcProcess);
    current->add("RelatedProcess",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcProcess);
    current->add("TimeLag",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcLagTime);
    current->add("SequenceType",true,IfcUtil::Argument_ENUMERATION,Type::IfcSequenceEnum);
    current->add("UserDefinedSequenceType",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current = entity_descriptor_map[Type::IfcRelServicesBuildings] = new IfcEntityDescriptor(Type::IfcRelServicesBuildings,entity_descriptor_map.find(Type::IfcRelConnects)->second);
    current->add("RelatingSystem",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcSystem);
    current->add("RelatedBuildings",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcSpatialElement);
    current = entity_descriptor_map[Type::IfcRelSpaceBoundary] = new IfcEntityDescriptor(Type::IfcRelSpaceBoundary,entity_descriptor_map.find(Type::IfcRelConnects)->second);
    current->add("RelatingSpace",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcSpaceBoundarySelect);
    current->add("RelatedBuildingElement",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcElement);
    current->add("ConnectionGeometry",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcConnectionGeometry);
    current->add("PhysicalOrVirtualBoundary",false,IfcUtil::Argument_ENUMERATION,Type::IfcPhysicalOrVirtualEnum);
    current->add("InternalOrExternalBoundary",false,IfcUtil::Argument_ENUMERATION,Type::IfcInternalOrExternalEnum);
    current = entity_descriptor_map[Type::IfcRelSpaceBoundary1stLevel] = new IfcEntityDescriptor(Type::IfcRelSpaceBoundary1stLevel,entity_descriptor_map.find(Type::IfcRelSpaceBoundary)->second);
    current->add("ParentBoundary",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcRelSpaceBoundary1stLevel);
    current = entity_descriptor_map[Type::IfcRelSpaceBoundary2ndLevel] = new IfcEntityDescriptor(Type::IfcRelSpaceBoundary2ndLevel,entity_descriptor_map.find(Type::IfcRelSpaceBoundary1stLevel)->second);
    current->add("CorrespondingBoundary",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcRelSpaceBoundary2ndLevel);
    current = entity_descriptor_map[Type::IfcRelVoidsElement] = new IfcEntityDescriptor(Type::IfcRelVoidsElement,entity_descriptor_map.find(Type::IfcRelDecomposes)->second);
    current->add("RelatingBuildingElement",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcElement);
    current->add("RelatedOpeningElement",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcFeatureElementSubtraction);
    current = entity_descriptor_map[Type::IfcReparametrisedCompositeCurveSegment] = new IfcEntityDescriptor(Type::IfcReparametrisedCompositeCurveSegment,entity_descriptor_map.find(Type::IfcCompositeCurveSegment)->second);
    current->add("ParamLength",false,IfcUtil::Argument_DOUBLE,Type::IfcParameterValue);
    current = entity_descriptor_map[Type::IfcResource] = new IfcEntityDescriptor(Type::IfcResource,entity_descriptor_map.find(Type::IfcObject)->second);
    current->add("Identification",true,IfcUtil::Argument_STRING,Type::IfcIdentifier);
    current->add("LongDescription",true,IfcUtil::Argument_STRING,Type::IfcText);
    current = entity_descriptor_map[Type::IfcRevolvedAreaSolid] = new IfcEntityDescriptor(Type::IfcRevolvedAreaSolid,entity_descriptor_map.find(Type::IfcSweptAreaSolid)->second);
    current->add("Axis",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcAxis1Placement);
    current->add("Angle",false,IfcUtil::Argument_DOUBLE,Type::IfcPlaneAngleMeasure);
    current = entity_descriptor_map[Type::IfcRevolvedAreaSolidTapered] = new IfcEntityDescriptor(Type::IfcRevolvedAreaSolidTapered,entity_descriptor_map.find(Type::IfcRevolvedAreaSolid)->second);
    current->add("EndSweptArea",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcProfileDef);
    current = entity_descriptor_map[Type::IfcRightCircularCone] = new IfcEntityDescriptor(Type::IfcRightCircularCone,entity_descriptor_map.find(Type::IfcCsgPrimitive3D)->second);
    current->add("Height",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("BottomRadius",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current = entity_descriptor_map[Type::IfcRightCircularCylinder] = new IfcEntityDescriptor(Type::IfcRightCircularCylinder,entity_descriptor_map.find(Type::IfcCsgPrimitive3D)->second);
    current->add("Height",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("Radius",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current = entity_descriptor_map[Type::IfcSimplePropertyTemplate] = new IfcEntityDescriptor(Type::IfcSimplePropertyTemplate,entity_descriptor_map.find(Type::IfcPropertyTemplate)->second);
    current->add("TemplateType",true,IfcUtil::Argument_ENUMERATION,Type::IfcSimplePropertyTemplateTypeEnum);
    current->add("PrimaryMeasureType",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("SecondaryMeasureType",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("Enumerators",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcPropertyEnumeration);
    current->add("PrimaryUnit",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcUnit);
    current->add("SecondaryUnit",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcUnit);
    current->add("Expression",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("AccessState",true,IfcUtil::Argument_ENUMERATION,Type::IfcStateEnum);
    current = entity_descriptor_map[Type::IfcSpatialElement] = new IfcEntityDescriptor(Type::IfcSpatialElement,entity_descriptor_map.find(Type::IfcProduct)->second);
    current->add("LongName",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current = entity_descriptor_map[Type::IfcSpatialElementType] = new IfcEntityDescriptor(Type::IfcSpatialElementType,entity_descriptor_map.find(Type::IfcTypeProduct)->second);
    current->add("ElementType",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current = entity_descriptor_map[Type::IfcSpatialStructureElement] = new IfcEntityDescriptor(Type::IfcSpatialStructureElement,entity_descriptor_map.find(Type::IfcSpatialElement)->second);
    current->add("CompositionType",true,IfcUtil::Argument_ENUMERATION,Type::IfcElementCompositionEnum);
    current = entity_descriptor_map[Type::IfcSpatialStructureElementType] = new IfcEntityDescriptor(Type::IfcSpatialStructureElementType,entity_descriptor_map.find(Type::IfcSpatialElementType)->second);

    current = entity_descriptor_map[Type::IfcSpatialZone] = new IfcEntityDescriptor(Type::IfcSpatialZone,entity_descriptor_map.find(Type::IfcSpatialElement)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcSpatialZoneTypeEnum);
    current = entity_descriptor_map[Type::IfcSpatialZoneType] = new IfcEntityDescriptor(Type::IfcSpatialZoneType,entity_descriptor_map.find(Type::IfcSpatialElementType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcSpatialZoneTypeEnum);
    current->add("LongName",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current = entity_descriptor_map[Type::IfcSphere] = new IfcEntityDescriptor(Type::IfcSphere,entity_descriptor_map.find(Type::IfcCsgPrimitive3D)->second);
    current->add("Radius",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current = entity_descriptor_map[Type::IfcStructuralActivity] = new IfcEntityDescriptor(Type::IfcStructuralActivity,entity_descriptor_map.find(Type::IfcProduct)->second);
    current->add("AppliedLoad",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcStructuralLoad);
    current->add("GlobalOrLocal",false,IfcUtil::Argument_ENUMERATION,Type::IfcGlobalOrLocalEnum);
    current = entity_descriptor_map[Type::IfcStructuralItem] = new IfcEntityDescriptor(Type::IfcStructuralItem,entity_descriptor_map.find(Type::IfcProduct)->second);

    current = entity_descriptor_map[Type::IfcStructuralMember] = new IfcEntityDescriptor(Type::IfcStructuralMember,entity_descriptor_map.find(Type::IfcStructuralItem)->second);

    current = entity_descriptor_map[Type::IfcStructuralReaction] = new IfcEntityDescriptor(Type::IfcStructuralReaction,entity_descriptor_map.find(Type::IfcStructuralActivity)->second);

    current = entity_descriptor_map[Type::IfcStructuralSurfaceMember] = new IfcEntityDescriptor(Type::IfcStructuralSurfaceMember,entity_descriptor_map.find(Type::IfcStructuralMember)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcStructuralSurfaceMemberTypeEnum);
    current->add("Thickness",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current = entity_descriptor_map[Type::IfcStructuralSurfaceMemberVarying] = new IfcEntityDescriptor(Type::IfcStructuralSurfaceMemberVarying,entity_descriptor_map.find(Type::IfcStructuralSurfaceMember)->second);

    current = entity_descriptor_map[Type::IfcStructuralSurfaceReaction] = new IfcEntityDescriptor(Type::IfcStructuralSurfaceReaction,entity_descriptor_map.find(Type::IfcStructuralReaction)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcStructuralSurfaceActivityTypeEnum);
    current = entity_descriptor_map[Type::IfcSubContractResourceType] = new IfcEntityDescriptor(Type::IfcSubContractResourceType,entity_descriptor_map.find(Type::IfcConstructionResourceType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcSubContractResourceTypeEnum);
    current = entity_descriptor_map[Type::IfcSurfaceCurveSweptAreaSolid] = new IfcEntityDescriptor(Type::IfcSurfaceCurveSweptAreaSolid,entity_descriptor_map.find(Type::IfcSweptAreaSolid)->second);
    current->add("Directrix",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcCurve);
    current->add("StartParam",true,IfcUtil::Argument_DOUBLE,Type::IfcParameterValue);
    current->add("EndParam",true,IfcUtil::Argument_DOUBLE,Type::IfcParameterValue);
    current->add("ReferenceSurface",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcSurface);
    current = entity_descriptor_map[Type::IfcSurfaceOfLinearExtrusion] = new IfcEntityDescriptor(Type::IfcSurfaceOfLinearExtrusion,entity_descriptor_map.find(Type::IfcSweptSurface)->second);
    current->add("ExtrudedDirection",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcDirection);
    current->add("Depth",false,IfcUtil::Argument_DOUBLE,Type::IfcLengthMeasure);
    current = entity_descriptor_map[Type::IfcSurfaceOfRevolution] = new IfcEntityDescriptor(Type::IfcSurfaceOfRevolution,entity_descriptor_map.find(Type::IfcSweptSurface)->second);
    current->add("AxisPosition",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcAxis1Placement);
    current = entity_descriptor_map[Type::IfcSystemFurnitureElementType] = new IfcEntityDescriptor(Type::IfcSystemFurnitureElementType,entity_descriptor_map.find(Type::IfcFurnishingElementType)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcSystemFurnitureElementTypeEnum);
    current = entity_descriptor_map[Type::IfcTask] = new IfcEntityDescriptor(Type::IfcTask,entity_descriptor_map.find(Type::IfcProcess)->second);
    current->add("Status",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("WorkMethod",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("IsMilestone",false,IfcUtil::Argument_BOOL,Type::IfcBoolean);
    current->add("Priority",true,IfcUtil::Argument_INT,Type::IfcInteger);
    current->add("TaskTime",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcTaskTime);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcTaskTypeEnum);
    current = entity_descriptor_map[Type::IfcTaskType] = new IfcEntityDescriptor(Type::IfcTaskType,entity_descriptor_map.find(Type::IfcTypeProcess)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcTaskTypeEnum);
    current->add("WorkMethod",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current = entity_descriptor_map[Type::IfcTessellatedFaceSet] = new IfcEntityDescriptor(Type::IfcTessellatedFaceSet,entity_descriptor_map.find(Type::IfcTessellatedItem)->second);
    current->add("Coordinates",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcCartesianPointList3D);
    current->add("Normals",true,IfcUtil::Argument_AGGREGATE_OF_AGGREGATE_OF_DOUBLE,Type::IfcParameterValue);
    current->add("Closed",true,IfcUtil::Argument_BOOL,Type::IfcBoolean);
    current = entity_descriptor_map[Type::IfcTransportElementType] = new IfcEntityDescriptor(Type::IfcTransportElementType,entity_descriptor_map.find(Type::IfcElementType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcTransportElementTypeEnum);
    current = entity_descriptor_map[Type::IfcTriangulatedFaceSet] = new IfcEntityDescriptor(Type::IfcTriangulatedFaceSet,entity_descriptor_map.find(Type::IfcTessellatedFaceSet)->second);
    current->add("CoordIndex",false,IfcUtil::Argument_AGGREGATE_OF_AGGREGATE_OF_INT,Type::IfcPositiveInteger);
    current->add("NormalIndex",true,IfcUtil::Argument_AGGREGATE_OF_AGGREGATE_OF_INT,Type::IfcPositiveInteger);
    current = entity_descriptor_map[Type::IfcWindowLiningProperties] = new IfcEntityDescriptor(Type::IfcWindowLiningProperties,entity_descriptor_map.find(Type::IfcPreDefinedPropertySet)->second);
    current->add("LiningDepth",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("LiningThickness",true,IfcUtil::Argument_DOUBLE,Type::IfcNonNegativeLengthMeasure);
    current->add("TransomThickness",true,IfcUtil::Argument_DOUBLE,Type::IfcNonNegativeLengthMeasure);
    current->add("MullionThickness",true,IfcUtil::Argument_DOUBLE,Type::IfcNonNegativeLengthMeasure);
    current->add("FirstTransomOffset",true,IfcUtil::Argument_DOUBLE,Type::IfcNormalisedRatioMeasure);
    current->add("SecondTransomOffset",true,IfcUtil::Argument_DOUBLE,Type::IfcNormalisedRatioMeasure);
    current->add("FirstMullionOffset",true,IfcUtil::Argument_DOUBLE,Type::IfcNormalisedRatioMeasure);
    current->add("SecondMullionOffset",true,IfcUtil::Argument_DOUBLE,Type::IfcNormalisedRatioMeasure);
    current->add("ShapeAspectStyle",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcShapeAspect);
    current->add("LiningOffset",true,IfcUtil::Argument_DOUBLE,Type::IfcLengthMeasure);
    current->add("LiningToPanelOffsetX",true,IfcUtil::Argument_DOUBLE,Type::IfcLengthMeasure);
    current->add("LiningToPanelOffsetY",true,IfcUtil::Argument_DOUBLE,Type::IfcLengthMeasure);
    current = entity_descriptor_map[Type::IfcWindowPanelProperties] = new IfcEntityDescriptor(Type::IfcWindowPanelProperties,entity_descriptor_map.find(Type::IfcPreDefinedPropertySet)->second);
    current->add("OperationType",false,IfcUtil::Argument_ENUMERATION,Type::IfcWindowPanelOperationEnum);
    current->add("PanelPosition",false,IfcUtil::Argument_ENUMERATION,Type::IfcWindowPanelPositionEnum);
    current->add("FrameDepth",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("FrameThickness",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("ShapeAspectStyle",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcShapeAspect);
    current = entity_descriptor_map[Type::IfcActor] = new IfcEntityDescriptor(Type::IfcActor,entity_descriptor_map.find(Type::IfcObject)->second);
    current->add("TheActor",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcActorSelect);
    current = entity_descriptor_map[Type::IfcAdvancedBrep] = new IfcEntityDescriptor(Type::IfcAdvancedBrep,entity_descriptor_map.find(Type::IfcManifoldSolidBrep)->second);

    current = entity_descriptor_map[Type::IfcAdvancedBrepWithVoids] = new IfcEntityDescriptor(Type::IfcAdvancedBrepWithVoids,entity_descriptor_map.find(Type::IfcAdvancedBrep)->second);
    current->add("Voids",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcClosedShell);
    current = entity_descriptor_map[Type::IfcAnnotation] = new IfcEntityDescriptor(Type::IfcAnnotation,entity_descriptor_map.find(Type::IfcProduct)->second);

    current = entity_descriptor_map[Type::IfcBSplineSurface] = new IfcEntityDescriptor(Type::IfcBSplineSurface,entity_descriptor_map.find(Type::IfcBoundedSurface)->second);
    current->add("UDegree",false,IfcUtil::Argument_INT,Type::IfcInteger);
    current->add("VDegree",false,IfcUtil::Argument_INT,Type::IfcInteger);
    current->add("ControlPointsList",false,IfcUtil::Argument_AGGREGATE_OF_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcCartesianPoint);
    current->add("SurfaceForm",false,IfcUtil::Argument_ENUMERATION,Type::IfcBSplineSurfaceForm);
    current->add("UClosed",false,IfcUtil::Argument_BOOL,Type::IfcLogical);
    current->add("VClosed",false,IfcUtil::Argument_BOOL,Type::IfcLogical);
    current->add("SelfIntersect",false,IfcUtil::Argument_BOOL,Type::IfcLogical);
    current = entity_descriptor_map[Type::IfcBSplineSurfaceWithKnots] = new IfcEntityDescriptor(Type::IfcBSplineSurfaceWithKnots,entity_descriptor_map.find(Type::IfcBSplineSurface)->second);
    current->add("UMultiplicities",false,IfcUtil::Argument_AGGREGATE_OF_INT,Type::IfcInteger);
    current->add("VMultiplicities",false,IfcUtil::Argument_AGGREGATE_OF_INT,Type::IfcInteger);
    current->add("UKnots",false,IfcUtil::Argument_AGGREGATE_OF_DOUBLE,Type::IfcParameterValue);
    current->add("VKnots",false,IfcUtil::Argument_AGGREGATE_OF_DOUBLE,Type::IfcParameterValue);
    current->add("KnotSpec",false,IfcUtil::Argument_ENUMERATION,Type::IfcKnotType);
    current = entity_descriptor_map[Type::IfcBlock] = new IfcEntityDescriptor(Type::IfcBlock,entity_descriptor_map.find(Type::IfcCsgPrimitive3D)->second);
    current->add("XLength",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("YLength",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("ZLength",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current = entity_descriptor_map[Type::IfcBooleanClippingResult] = new IfcEntityDescriptor(Type::IfcBooleanClippingResult,entity_descriptor_map.find(Type::IfcBooleanResult)->second);

    current = entity_descriptor_map[Type::IfcBoundedCurve] = new IfcEntityDescriptor(Type::IfcBoundedCurve,entity_descriptor_map.find(Type::IfcCurve)->second);

    current = entity_descriptor_map[Type::IfcBuilding] = new IfcEntityDescriptor(Type::IfcBuilding,entity_descriptor_map.find(Type::IfcSpatialStructureElement)->second);
    current->add("ElevationOfRefHeight",true,IfcUtil::Argument_DOUBLE,Type::IfcLengthMeasure);
    current->add("ElevationOfTerrain",true,IfcUtil::Argument_DOUBLE,Type::IfcLengthMeasure);
    current->add("BuildingAddress",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcPostalAddress);
    current = entity_descriptor_map[Type::IfcBuildingElementType] = new IfcEntityDescriptor(Type::IfcBuildingElementType,entity_descriptor_map.find(Type::IfcElementType)->second);

    current = entity_descriptor_map[Type::IfcBuildingStorey] = new IfcEntityDescriptor(Type::IfcBuildingStorey,entity_descriptor_map.find(Type::IfcSpatialStructureElement)->second);
    current->add("Elevation",true,IfcUtil::Argument_DOUBLE,Type::IfcLengthMeasure);
    current = entity_descriptor_map[Type::IfcChimneyType] = new IfcEntityDescriptor(Type::IfcChimneyType,entity_descriptor_map.find(Type::IfcBuildingElementType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcChimneyTypeEnum);
    current = entity_descriptor_map[Type::IfcCircleHollowProfileDef] = new IfcEntityDescriptor(Type::IfcCircleHollowProfileDef,entity_descriptor_map.find(Type::IfcCircleProfileDef)->second);
    current->add("WallThickness",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current = entity_descriptor_map[Type::IfcCivilElementType] = new IfcEntityDescriptor(Type::IfcCivilElementType,entity_descriptor_map.find(Type::IfcElementType)->second);

    current = entity_descriptor_map[Type::IfcColumnType] = new IfcEntityDescriptor(Type::IfcColumnType,entity_descriptor_map.find(Type::IfcBuildingElementType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcColumnTypeEnum);
    current = entity_descriptor_map[Type::IfcComplexPropertyTemplate] = new IfcEntityDescriptor(Type::IfcComplexPropertyTemplate,entity_descriptor_map.find(Type::IfcPropertyTemplate)->second);
    current->add("UsageName",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("TemplateType",true,IfcUtil::Argument_ENUMERATION,Type::IfcComplexPropertyTemplateTypeEnum);
    current->add("HasPropertyTemplates",true,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcPropertyTemplate);
    current = entity_descriptor_map[Type::IfcCompositeCurve] = new IfcEntityDescriptor(Type::IfcCompositeCurve,entity_descriptor_map.find(Type::IfcBoundedCurve)->second);
    current->add("Segments",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcCompositeCurveSegment);
    current->add("SelfIntersect",false,IfcUtil::Argument_BOOL,Type::IfcLogical);
    current = entity_descriptor_map[Type::IfcCompositeCurveOnSurface] = new IfcEntityDescriptor(Type::IfcCompositeCurveOnSurface,entity_descriptor_map.find(Type::IfcCompositeCurve)->second);

    current = entity_descriptor_map[Type::IfcConic] = new IfcEntityDescriptor(Type::IfcConic,entity_descriptor_map.find(Type::IfcCurve)->second);
    current->add("Position",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcAxis2Placement);
    current = entity_descriptor_map[Type::IfcConstructionEquipmentResourceType] = new IfcEntityDescriptor(Type::IfcConstructionEquipmentResourceType,entity_descriptor_map.find(Type::IfcConstructionResourceType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcConstructionEquipmentResourceTypeEnum);
    current = entity_descriptor_map[Type::IfcConstructionMaterialResourceType] = new IfcEntityDescriptor(Type::IfcConstructionMaterialResourceType,entity_descriptor_map.find(Type::IfcConstructionResourceType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcConstructionMaterialResourceTypeEnum);
    current = entity_descriptor_map[Type::IfcConstructionProductResourceType] = new IfcEntityDescriptor(Type::IfcConstructionProductResourceType,entity_descriptor_map.find(Type::IfcConstructionResourceType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcConstructionProductResourceTypeEnum);
    current = entity_descriptor_map[Type::IfcConstructionResource] = new IfcEntityDescriptor(Type::IfcConstructionResource,entity_descriptor_map.find(Type::IfcResource)->second);
    current->add("Usage",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcResourceTime);
    current->add("BaseCosts",true,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcAppliedValue);
    current->add("BaseQuantity",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcPhysicalQuantity);
    current = entity_descriptor_map[Type::IfcControl] = new IfcEntityDescriptor(Type::IfcControl,entity_descriptor_map.find(Type::IfcObject)->second);
    current->add("Identification",true,IfcUtil::Argument_STRING,Type::IfcIdentifier);
    current = entity_descriptor_map[Type::IfcCostItem] = new IfcEntityDescriptor(Type::IfcCostItem,entity_descriptor_map.find(Type::IfcControl)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcCostItemTypeEnum);
    current->add("CostValues",true,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcCostValue);
    current->add("CostQuantities",true,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcPhysicalQuantity);
    current = entity_descriptor_map[Type::IfcCostSchedule] = new IfcEntityDescriptor(Type::IfcCostSchedule,entity_descriptor_map.find(Type::IfcControl)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcCostScheduleTypeEnum);
    current->add("Status",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("SubmittedOn",true,IfcUtil::Argument_STRING,Type::IfcDateTime);
    current->add("UpdateDate",true,IfcUtil::Argument_STRING,Type::IfcDateTime);
    current = entity_descriptor_map[Type::IfcCoveringType] = new IfcEntityDescriptor(Type::IfcCoveringType,entity_descriptor_map.find(Type::IfcBuildingElementType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcCoveringTypeEnum);
    current = entity_descriptor_map[Type::IfcCrewResource] = new IfcEntityDescriptor(Type::IfcCrewResource,entity_descriptor_map.find(Type::IfcConstructionResource)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcCrewResourceTypeEnum);
    current = entity_descriptor_map[Type::IfcCurtainWallType] = new IfcEntityDescriptor(Type::IfcCurtainWallType,entity_descriptor_map.find(Type::IfcBuildingElementType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcCurtainWallTypeEnum);
    current = entity_descriptor_map[Type::IfcCylindricalSurface] = new IfcEntityDescriptor(Type::IfcCylindricalSurface,entity_descriptor_map.find(Type::IfcElementarySurface)->second);
    current->add("Radius",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current = entity_descriptor_map[Type::IfcDistributionElementType] = new IfcEntityDescriptor(Type::IfcDistributionElementType,entity_descriptor_map.find(Type::IfcElementType)->second);

    current = entity_descriptor_map[Type::IfcDistributionFlowElementType] = new IfcEntityDescriptor(Type::IfcDistributionFlowElementType,entity_descriptor_map.find(Type::IfcDistributionElementType)->second);

    current = entity_descriptor_map[Type::IfcDoorLiningProperties] = new IfcEntityDescriptor(Type::IfcDoorLiningProperties,entity_descriptor_map.find(Type::IfcPreDefinedPropertySet)->second);
    current->add("LiningDepth",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("LiningThickness",true,IfcUtil::Argument_DOUBLE,Type::IfcNonNegativeLengthMeasure);
    current->add("ThresholdDepth",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("ThresholdThickness",true,IfcUtil::Argument_DOUBLE,Type::IfcNonNegativeLengthMeasure);
    current->add("TransomThickness",true,IfcUtil::Argument_DOUBLE,Type::IfcNonNegativeLengthMeasure);
    current->add("TransomOffset",true,IfcUtil::Argument_DOUBLE,Type::IfcLengthMeasure);
    current->add("LiningOffset",true,IfcUtil::Argument_DOUBLE,Type::IfcLengthMeasure);
    current->add("ThresholdOffset",true,IfcUtil::Argument_DOUBLE,Type::IfcLengthMeasure);
    current->add("CasingThickness",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("CasingDepth",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("ShapeAspectStyle",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcShapeAspect);
    current->add("LiningToPanelOffsetX",true,IfcUtil::Argument_DOUBLE,Type::IfcLengthMeasure);
    current->add("LiningToPanelOffsetY",true,IfcUtil::Argument_DOUBLE,Type::IfcLengthMeasure);
    current = entity_descriptor_map[Type::IfcDoorPanelProperties] = new IfcEntityDescriptor(Type::IfcDoorPanelProperties,entity_descriptor_map.find(Type::IfcPreDefinedPropertySet)->second);
    current->add("PanelDepth",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("PanelOperation",false,IfcUtil::Argument_ENUMERATION,Type::IfcDoorPanelOperationEnum);
    current->add("PanelWidth",true,IfcUtil::Argument_DOUBLE,Type::IfcNormalisedRatioMeasure);
    current->add("PanelPosition",false,IfcUtil::Argument_ENUMERATION,Type::IfcDoorPanelPositionEnum);
    current->add("ShapeAspectStyle",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcShapeAspect);
    current = entity_descriptor_map[Type::IfcDoorType] = new IfcEntityDescriptor(Type::IfcDoorType,entity_descriptor_map.find(Type::IfcBuildingElementType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcDoorTypeEnum);
    current->add("OperationType",false,IfcUtil::Argument_ENUMERATION,Type::IfcDoorTypeOperationEnum);
    current->add("ParameterTakesPrecedence",true,IfcUtil::Argument_BOOL,Type::IfcBoolean);
    current->add("UserDefinedOperationType",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current = entity_descriptor_map[Type::IfcDraughtingPreDefinedColour] = new IfcEntityDescriptor(Type::IfcDraughtingPreDefinedColour,entity_descriptor_map.find(Type::IfcPreDefinedColour)->second);

    current = entity_descriptor_map[Type::IfcDraughtingPreDefinedCurveFont] = new IfcEntityDescriptor(Type::IfcDraughtingPreDefinedCurveFont,entity_descriptor_map.find(Type::IfcPreDefinedCurveFont)->second);

    current = entity_descriptor_map[Type::IfcElement] = new IfcEntityDescriptor(Type::IfcElement,entity_descriptor_map.find(Type::IfcProduct)->second);
    current->add("Tag",true,IfcUtil::Argument_STRING,Type::IfcIdentifier);
    current = entity_descriptor_map[Type::IfcElementAssembly] = new IfcEntityDescriptor(Type::IfcElementAssembly,entity_descriptor_map.find(Type::IfcElement)->second);
    current->add("AssemblyPlace",true,IfcUtil::Argument_ENUMERATION,Type::IfcAssemblyPlaceEnum);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcElementAssemblyTypeEnum);
    current = entity_descriptor_map[Type::IfcElementAssemblyType] = new IfcEntityDescriptor(Type::IfcElementAssemblyType,entity_descriptor_map.find(Type::IfcElementType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcElementAssemblyTypeEnum);
    current = entity_descriptor_map[Type::IfcElementComponent] = new IfcEntityDescriptor(Type::IfcElementComponent,entity_descriptor_map.find(Type::IfcElement)->second);

    current = entity_descriptor_map[Type::IfcElementComponentType] = new IfcEntityDescriptor(Type::IfcElementComponentType,entity_descriptor_map.find(Type::IfcElementType)->second);

    current = entity_descriptor_map[Type::IfcEllipse] = new IfcEntityDescriptor(Type::IfcEllipse,entity_descriptor_map.find(Type::IfcConic)->second);
    current->add("SemiAxis1",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("SemiAxis2",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current = entity_descriptor_map[Type::IfcEnergyConversionDeviceType] = new IfcEntityDescriptor(Type::IfcEnergyConversionDeviceType,entity_descriptor_map.find(Type::IfcDistributionFlowElementType)->second);

    current = entity_descriptor_map[Type::IfcEngineType] = new IfcEntityDescriptor(Type::IfcEngineType,entity_descriptor_map.find(Type::IfcEnergyConversionDeviceType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcEngineTypeEnum);
    current = entity_descriptor_map[Type::IfcEvaporativeCoolerType] = new IfcEntityDescriptor(Type::IfcEvaporativeCoolerType,entity_descriptor_map.find(Type::IfcEnergyConversionDeviceType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcEvaporativeCoolerTypeEnum);
    current = entity_descriptor_map[Type::IfcEvaporatorType] = new IfcEntityDescriptor(Type::IfcEvaporatorType,entity_descriptor_map.find(Type::IfcEnergyConversionDeviceType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcEvaporatorTypeEnum);
    current = entity_descriptor_map[Type::IfcEvent] = new IfcEntityDescriptor(Type::IfcEvent,entity_descriptor_map.find(Type::IfcProcess)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcEventTypeEnum);
    current->add("EventTriggerType",true,IfcUtil::Argument_ENUMERATION,Type::IfcEventTriggerTypeEnum);
    current->add("UserDefinedEventTriggerType",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("EventOccurenceTime",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcEventTime);
    current = entity_descriptor_map[Type::IfcExternalSpatialStructureElement] = new IfcEntityDescriptor(Type::IfcExternalSpatialStructureElement,entity_descriptor_map.find(Type::IfcSpatialElement)->second);

    current = entity_descriptor_map[Type::IfcFacetedBrep] = new IfcEntityDescriptor(Type::IfcFacetedBrep,entity_descriptor_map.find(Type::IfcManifoldSolidBrep)->second);

    current = entity_descriptor_map[Type::IfcFacetedBrepWithVoids] = new IfcEntityDescriptor(Type::IfcFacetedBrepWithVoids,entity_descriptor_map.find(Type::IfcFacetedBrep)->second);
    current->add("Voids",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcClosedShell);
    current = entity_descriptor_map[Type::IfcFastener] = new IfcEntityDescriptor(Type::IfcFastener,entity_descriptor_map.find(Type::IfcElementComponent)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcFastenerTypeEnum);
    current = entity_descriptor_map[Type::IfcFastenerType] = new IfcEntityDescriptor(Type::IfcFastenerType,entity_descriptor_map.find(Type::IfcElementComponentType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcFastenerTypeEnum);
    current = entity_descriptor_map[Type::IfcFeatureElement] = new IfcEntityDescriptor(Type::IfcFeatureElement,entity_descriptor_map.find(Type::IfcElement)->second);

    current = entity_descriptor_map[Type::IfcFeatureElementAddition] = new IfcEntityDescriptor(Type::IfcFeatureElementAddition,entity_descriptor_map.find(Type::IfcFeatureElement)->second);

    current = entity_descriptor_map[Type::IfcFeatureElementSubtraction] = new IfcEntityDescriptor(Type::IfcFeatureElementSubtraction,entity_descriptor_map.find(Type::IfcFeatureElement)->second);

    current = entity_descriptor_map[Type::IfcFlowControllerType] = new IfcEntityDescriptor(Type::IfcFlowControllerType,entity_descriptor_map.find(Type::IfcDistributionFlowElementType)->second);

    current = entity_descriptor_map[Type::IfcFlowFittingType] = new IfcEntityDescriptor(Type::IfcFlowFittingType,entity_descriptor_map.find(Type::IfcDistributionFlowElementType)->second);

    current = entity_descriptor_map[Type::IfcFlowMeterType] = new IfcEntityDescriptor(Type::IfcFlowMeterType,entity_descriptor_map.find(Type::IfcFlowControllerType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcFlowMeterTypeEnum);
    current = entity_descriptor_map[Type::IfcFlowMovingDeviceType] = new IfcEntityDescriptor(Type::IfcFlowMovingDeviceType,entity_descriptor_map.find(Type::IfcDistributionFlowElementType)->second);

    current = entity_descriptor_map[Type::IfcFlowSegmentType] = new IfcEntityDescriptor(Type::IfcFlowSegmentType,entity_descriptor_map.find(Type::IfcDistributionFlowElementType)->second);

    current = entity_descriptor_map[Type::IfcFlowStorageDeviceType] = new IfcEntityDescriptor(Type::IfcFlowStorageDeviceType,entity_descriptor_map.find(Type::IfcDistributionFlowElementType)->second);

    current = entity_descriptor_map[Type::IfcFlowTerminalType] = new IfcEntityDescriptor(Type::IfcFlowTerminalType,entity_descriptor_map.find(Type::IfcDistributionFlowElementType)->second);

    current = entity_descriptor_map[Type::IfcFlowTreatmentDeviceType] = new IfcEntityDescriptor(Type::IfcFlowTreatmentDeviceType,entity_descriptor_map.find(Type::IfcDistributionFlowElementType)->second);

    current = entity_descriptor_map[Type::IfcFootingType] = new IfcEntityDescriptor(Type::IfcFootingType,entity_descriptor_map.find(Type::IfcBuildingElementType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcFootingTypeEnum);
    current = entity_descriptor_map[Type::IfcFurnishingElement] = new IfcEntityDescriptor(Type::IfcFurnishingElement,entity_descriptor_map.find(Type::IfcElement)->second);

    current = entity_descriptor_map[Type::IfcFurniture] = new IfcEntityDescriptor(Type::IfcFurniture,entity_descriptor_map.find(Type::IfcFurnishingElement)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcFurnitureTypeEnum);
    current = entity_descriptor_map[Type::IfcGeographicElement] = new IfcEntityDescriptor(Type::IfcGeographicElement,entity_descriptor_map.find(Type::IfcElement)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcGeographicElementTypeEnum);
    current = entity_descriptor_map[Type::IfcGrid] = new IfcEntityDescriptor(Type::IfcGrid,entity_descriptor_map.find(Type::IfcProduct)->second);
    current->add("UAxes",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcGridAxis);
    current->add("VAxes",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcGridAxis);
    current->add("WAxes",true,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcGridAxis);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcGridTypeEnum);
    current = entity_descriptor_map[Type::IfcGroup] = new IfcEntityDescriptor(Type::IfcGroup,entity_descriptor_map.find(Type::IfcObject)->second);

    current = entity_descriptor_map[Type::IfcHeatExchangerType] = new IfcEntityDescriptor(Type::IfcHeatExchangerType,entity_descriptor_map.find(Type::IfcEnergyConversionDeviceType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcHeatExchangerTypeEnum);
    current = entity_descriptor_map[Type::IfcHumidifierType] = new IfcEntityDescriptor(Type::IfcHumidifierType,entity_descriptor_map.find(Type::IfcEnergyConversionDeviceType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcHumidifierTypeEnum);
    current = entity_descriptor_map[Type::IfcIndexedPolyCurve] = new IfcEntityDescriptor(Type::IfcIndexedPolyCurve,entity_descriptor_map.find(Type::IfcBoundedCurve)->second);
    current->add("Points",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcCartesianPointList);
    current->add("Segments",true,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcSegmentIndexSelect);
    current->add("SelfIntersect",true,IfcUtil::Argument_BOOL,Type::IfcBoolean);
    current = entity_descriptor_map[Type::IfcInterceptorType] = new IfcEntityDescriptor(Type::IfcInterceptorType,entity_descriptor_map.find(Type::IfcFlowTreatmentDeviceType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcInterceptorTypeEnum);
    current = entity_descriptor_map[Type::IfcInventory] = new IfcEntityDescriptor(Type::IfcInventory,entity_descriptor_map.find(Type::IfcGroup)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcInventoryTypeEnum);
    current->add("Jurisdiction",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcActorSelect);
    current->add("ResponsiblePersons",true,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcPerson);
    current->add("LastUpdateDate",true,IfcUtil::Argument_STRING,Type::IfcDate);
    current->add("CurrentValue",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcCostValue);
    current->add("OriginalValue",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcCostValue);
    current = entity_descriptor_map[Type::IfcJunctionBoxType] = new IfcEntityDescriptor(Type::IfcJunctionBoxType,entity_descriptor_map.find(Type::IfcFlowFittingType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcJunctionBoxTypeEnum);
    current = entity_descriptor_map[Type::IfcLaborResource] = new IfcEntityDescriptor(Type::IfcLaborResource,entity_descriptor_map.find(Type::IfcConstructionResource)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcLaborResourceTypeEnum);
    current = entity_descriptor_map[Type::IfcLampType] = new IfcEntityDescriptor(Type::IfcLampType,entity_descriptor_map.find(Type::IfcFlowTerminalType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcLampTypeEnum);
    current = entity_descriptor_map[Type::IfcLightFixtureType] = new IfcEntityDescriptor(Type::IfcLightFixtureType,entity_descriptor_map.find(Type::IfcFlowTerminalType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcLightFixtureTypeEnum);
    current = entity_descriptor_map[Type::IfcMechanicalFastener] = new IfcEntityDescriptor(Type::IfcMechanicalFastener,entity_descriptor_map.find(Type::IfcElementComponent)->second);
    current->add("NominalDiameter",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("NominalLength",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcMechanicalFastenerTypeEnum);
    current = entity_descriptor_map[Type::IfcMechanicalFastenerType] = new IfcEntityDescriptor(Type::IfcMechanicalFastenerType,entity_descriptor_map.find(Type::IfcElementComponentType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcMechanicalFastenerTypeEnum);
    current->add("NominalDiameter",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("NominalLength",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current = entity_descriptor_map[Type::IfcMedicalDeviceType] = new IfcEntityDescriptor(Type::IfcMedicalDeviceType,entity_descriptor_map.find(Type::IfcFlowTerminalType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcMedicalDeviceTypeEnum);
    current = entity_descriptor_map[Type::IfcMemberType] = new IfcEntityDescriptor(Type::IfcMemberType,entity_descriptor_map.find(Type::IfcBuildingElementType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcMemberTypeEnum);
    current = entity_descriptor_map[Type::IfcMotorConnectionType] = new IfcEntityDescriptor(Type::IfcMotorConnectionType,entity_descriptor_map.find(Type::IfcEnergyConversionDeviceType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcMotorConnectionTypeEnum);
    current = entity_descriptor_map[Type::IfcOccupant] = new IfcEntityDescriptor(Type::IfcOccupant,entity_descriptor_map.find(Type::IfcActor)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcOccupantTypeEnum);
    current = entity_descriptor_map[Type::IfcOpeningElement] = new IfcEntityDescriptor(Type::IfcOpeningElement,entity_descriptor_map.find(Type::IfcFeatureElementSubtraction)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcOpeningElementTypeEnum);
    current = entity_descriptor_map[Type::IfcOpeningStandardCase] = new IfcEntityDescriptor(Type::IfcOpeningStandardCase,entity_descriptor_map.find(Type::IfcOpeningElement)->second);

    current = entity_descriptor_map[Type::IfcOutletType] = new IfcEntityDescriptor(Type::IfcOutletType,entity_descriptor_map.find(Type::IfcFlowTerminalType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcOutletTypeEnum);
    current = entity_descriptor_map[Type::IfcPerformanceHistory] = new IfcEntityDescriptor(Type::IfcPerformanceHistory,entity_descriptor_map.find(Type::IfcControl)->second);
    current->add("LifeCyclePhase",false,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcPerformanceHistoryTypeEnum);
    current = entity_descriptor_map[Type::IfcPermeableCoveringProperties] = new IfcEntityDescriptor(Type::IfcPermeableCoveringProperties,entity_descriptor_map.find(Type::IfcPreDefinedPropertySet)->second);
    current->add("OperationType",false,IfcUtil::Argument_ENUMERATION,Type::IfcPermeableCoveringOperationEnum);
    current->add("PanelPosition",false,IfcUtil::Argument_ENUMERATION,Type::IfcWindowPanelPositionEnum);
    current->add("FrameDepth",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("FrameThickness",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("ShapeAspectStyle",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcShapeAspect);
    current = entity_descriptor_map[Type::IfcPermit] = new IfcEntityDescriptor(Type::IfcPermit,entity_descriptor_map.find(Type::IfcControl)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcPermitTypeEnum);
    current->add("Status",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("LongDescription",true,IfcUtil::Argument_STRING,Type::IfcText);
    current = entity_descriptor_map[Type::IfcPileType] = new IfcEntityDescriptor(Type::IfcPileType,entity_descriptor_map.find(Type::IfcBuildingElementType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcPileTypeEnum);
    current = entity_descriptor_map[Type::IfcPipeFittingType] = new IfcEntityDescriptor(Type::IfcPipeFittingType,entity_descriptor_map.find(Type::IfcFlowFittingType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcPipeFittingTypeEnum);
    current = entity_descriptor_map[Type::IfcPipeSegmentType] = new IfcEntityDescriptor(Type::IfcPipeSegmentType,entity_descriptor_map.find(Type::IfcFlowSegmentType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcPipeSegmentTypeEnum);
    current = entity_descriptor_map[Type::IfcPlateType] = new IfcEntityDescriptor(Type::IfcPlateType,entity_descriptor_map.find(Type::IfcBuildingElementType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcPlateTypeEnum);
    current = entity_descriptor_map[Type::IfcPolyline] = new IfcEntityDescriptor(Type::IfcPolyline,entity_descriptor_map.find(Type::IfcBoundedCurve)->second);
    current->add("Points",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcCartesianPoint);
    current = entity_descriptor_map[Type::IfcPort] = new IfcEntityDescriptor(Type::IfcPort,entity_descriptor_map.find(Type::IfcProduct)->second);

    current = entity_descriptor_map[Type::IfcProcedure] = new IfcEntityDescriptor(Type::IfcProcedure,entity_descriptor_map.find(Type::IfcProcess)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcProcedureTypeEnum);
    current = entity_descriptor_map[Type::IfcProjectOrder] = new IfcEntityDescriptor(Type::IfcProjectOrder,entity_descriptor_map.find(Type::IfcControl)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcProjectOrderTypeEnum);
    current->add("Status",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("LongDescription",true,IfcUtil::Argument_STRING,Type::IfcText);
    current = entity_descriptor_map[Type::IfcProjectionElement] = new IfcEntityDescriptor(Type::IfcProjectionElement,entity_descriptor_map.find(Type::IfcFeatureElementAddition)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcProjectionElementTypeEnum);
    current = entity_descriptor_map[Type::IfcProtectiveDeviceType] = new IfcEntityDescriptor(Type::IfcProtectiveDeviceType,entity_descriptor_map.find(Type::IfcFlowControllerType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcProtectiveDeviceTypeEnum);
    current = entity_descriptor_map[Type::IfcPumpType] = new IfcEntityDescriptor(Type::IfcPumpType,entity_descriptor_map.find(Type::IfcFlowMovingDeviceType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcPumpTypeEnum);
    current = entity_descriptor_map[Type::IfcRailingType] = new IfcEntityDescriptor(Type::IfcRailingType,entity_descriptor_map.find(Type::IfcBuildingElementType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcRailingTypeEnum);
    current = entity_descriptor_map[Type::IfcRampFlightType] = new IfcEntityDescriptor(Type::IfcRampFlightType,entity_descriptor_map.find(Type::IfcBuildingElementType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcRampFlightTypeEnum);
    current = entity_descriptor_map[Type::IfcRampType] = new IfcEntityDescriptor(Type::IfcRampType,entity_descriptor_map.find(Type::IfcBuildingElementType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcRampTypeEnum);
    current = entity_descriptor_map[Type::IfcRationalBSplineSurfaceWithKnots] = new IfcEntityDescriptor(Type::IfcRationalBSplineSurfaceWithKnots,entity_descriptor_map.find(Type::IfcBSplineSurfaceWithKnots)->second);
    current->add("WeightsData",false,IfcUtil::Argument_AGGREGATE_OF_AGGREGATE_OF_DOUBLE,Type::IfcReal);
    current = entity_descriptor_map[Type::IfcReinforcingElement] = new IfcEntityDescriptor(Type::IfcReinforcingElement,entity_descriptor_map.find(Type::IfcElementComponent)->second);
    current->add("SteelGrade",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current = entity_descriptor_map[Type::IfcReinforcingElementType] = new IfcEntityDescriptor(Type::IfcReinforcingElementType,entity_descriptor_map.find(Type::IfcElementComponentType)->second);

    current = entity_descriptor_map[Type::IfcReinforcingMesh] = new IfcEntityDescriptor(Type::IfcReinforcingMesh,entity_descriptor_map.find(Type::IfcReinforcingElement)->second);
    current->add("MeshLength",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("MeshWidth",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("LongitudinalBarNominalDiameter",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("TransverseBarNominalDiameter",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("LongitudinalBarCrossSectionArea",true,IfcUtil::Argument_DOUBLE,Type::IfcAreaMeasure);
    current->add("TransverseBarCrossSectionArea",true,IfcUtil::Argument_DOUBLE,Type::IfcAreaMeasure);
    current->add("LongitudinalBarSpacing",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("TransverseBarSpacing",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcReinforcingMeshTypeEnum);
    current = entity_descriptor_map[Type::IfcReinforcingMeshType] = new IfcEntityDescriptor(Type::IfcReinforcingMeshType,entity_descriptor_map.find(Type::IfcReinforcingElementType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcReinforcingMeshTypeEnum);
    current->add("MeshLength",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("MeshWidth",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("LongitudinalBarNominalDiameter",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("TransverseBarNominalDiameter",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("LongitudinalBarCrossSectionArea",true,IfcUtil::Argument_DOUBLE,Type::IfcAreaMeasure);
    current->add("TransverseBarCrossSectionArea",true,IfcUtil::Argument_DOUBLE,Type::IfcAreaMeasure);
    current->add("LongitudinalBarSpacing",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("TransverseBarSpacing",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("BendingShapeCode",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("BendingParameters",true,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcBendingParameterSelect);
    current = entity_descriptor_map[Type::IfcRelAggregates] = new IfcEntityDescriptor(Type::IfcRelAggregates,entity_descriptor_map.find(Type::IfcRelDecomposes)->second);
    current->add("RelatingObject",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcObjectDefinition);
    current->add("RelatedObjects",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcObjectDefinition);
    current = entity_descriptor_map[Type::IfcRoofType] = new IfcEntityDescriptor(Type::IfcRoofType,entity_descriptor_map.find(Type::IfcBuildingElementType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcRoofTypeEnum);
    current = entity_descriptor_map[Type::IfcSanitaryTerminalType] = new IfcEntityDescriptor(Type::IfcSanitaryTerminalType,entity_descriptor_map.find(Type::IfcFlowTerminalType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcSanitaryTerminalTypeEnum);
    current = entity_descriptor_map[Type::IfcShadingDeviceType] = new IfcEntityDescriptor(Type::IfcShadingDeviceType,entity_descriptor_map.find(Type::IfcBuildingElementType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcShadingDeviceTypeEnum);
    current = entity_descriptor_map[Type::IfcSite] = new IfcEntityDescriptor(Type::IfcSite,entity_descriptor_map.find(Type::IfcSpatialStructureElement)->second);
    current->add("RefLatitude",true,IfcUtil::Argument_AGGREGATE_OF_INT,Type::IfcCompoundPlaneAngleMeasure);
    current->add("RefLongitude",true,IfcUtil::Argument_AGGREGATE_OF_INT,Type::IfcCompoundPlaneAngleMeasure);
    current->add("RefElevation",true,IfcUtil::Argument_DOUBLE,Type::IfcLengthMeasure);
    current->add("LandTitleNumber",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("SiteAddress",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcPostalAddress);
    current = entity_descriptor_map[Type::IfcSlabType] = new IfcEntityDescriptor(Type::IfcSlabType,entity_descriptor_map.find(Type::IfcBuildingElementType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcSlabTypeEnum);
    current = entity_descriptor_map[Type::IfcSolarDeviceType] = new IfcEntityDescriptor(Type::IfcSolarDeviceType,entity_descriptor_map.find(Type::IfcEnergyConversionDeviceType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcSolarDeviceTypeEnum);
    current = entity_descriptor_map[Type::IfcSpace] = new IfcEntityDescriptor(Type::IfcSpace,entity_descriptor_map.find(Type::IfcSpatialStructureElement)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcSpaceTypeEnum);
    current->add("ElevationWithFlooring",true,IfcUtil::Argument_DOUBLE,Type::IfcLengthMeasure);
    current = entity_descriptor_map[Type::IfcSpaceHeaterType] = new IfcEntityDescriptor(Type::IfcSpaceHeaterType,entity_descriptor_map.find(Type::IfcFlowTerminalType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcSpaceHeaterTypeEnum);
    current = entity_descriptor_map[Type::IfcSpaceType] = new IfcEntityDescriptor(Type::IfcSpaceType,entity_descriptor_map.find(Type::IfcSpatialStructureElementType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcSpaceTypeEnum);
    current->add("LongName",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current = entity_descriptor_map[Type::IfcStackTerminalType] = new IfcEntityDescriptor(Type::IfcStackTerminalType,entity_descriptor_map.find(Type::IfcFlowTerminalType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcStackTerminalTypeEnum);
    current = entity_descriptor_map[Type::IfcStairFlightType] = new IfcEntityDescriptor(Type::IfcStairFlightType,entity_descriptor_map.find(Type::IfcBuildingElementType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcStairFlightTypeEnum);
    current = entity_descriptor_map[Type::IfcStairType] = new IfcEntityDescriptor(Type::IfcStairType,entity_descriptor_map.find(Type::IfcBuildingElementType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcStairTypeEnum);
    current = entity_descriptor_map[Type::IfcStructuralAction] = new IfcEntityDescriptor(Type::IfcStructuralAction,entity_descriptor_map.find(Type::IfcStructuralActivity)->second);
    current->add("DestabilizingLoad",true,IfcUtil::Argument_BOOL,Type::IfcBoolean);
    current = entity_descriptor_map[Type::IfcStructuralConnection] = new IfcEntityDescriptor(Type::IfcStructuralConnection,entity_descriptor_map.find(Type::IfcStructuralItem)->second);
    current->add("AppliedCondition",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcBoundaryCondition);
    current = entity_descriptor_map[Type::IfcStructuralCurveAction] = new IfcEntityDescriptor(Type::IfcStructuralCurveAction,entity_descriptor_map.find(Type::IfcStructuralAction)->second);
    current->add("ProjectedOrTrue",true,IfcUtil::Argument_ENUMERATION,Type::IfcProjectedOrTrueLengthEnum);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcStructuralCurveActivityTypeEnum);
    current = entity_descriptor_map[Type::IfcStructuralCurveConnection] = new IfcEntityDescriptor(Type::IfcStructuralCurveConnection,entity_descriptor_map.find(Type::IfcStructuralConnection)->second);
    current->add("Axis",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcDirection);
    current = entity_descriptor_map[Type::IfcStructuralCurveMember] = new IfcEntityDescriptor(Type::IfcStructuralCurveMember,entity_descriptor_map.find(Type::IfcStructuralMember)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcStructuralCurveMemberTypeEnum);
    current->add("Axis",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcDirection);
    current = entity_descriptor_map[Type::IfcStructuralCurveMemberVarying] = new IfcEntityDescriptor(Type::IfcStructuralCurveMemberVarying,entity_descriptor_map.find(Type::IfcStructuralCurveMember)->second);

    current = entity_descriptor_map[Type::IfcStructuralCurveReaction] = new IfcEntityDescriptor(Type::IfcStructuralCurveReaction,entity_descriptor_map.find(Type::IfcStructuralReaction)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcStructuralCurveActivityTypeEnum);
    current = entity_descriptor_map[Type::IfcStructuralLinearAction] = new IfcEntityDescriptor(Type::IfcStructuralLinearAction,entity_descriptor_map.find(Type::IfcStructuralCurveAction)->second);

    current = entity_descriptor_map[Type::IfcStructuralLoadGroup] = new IfcEntityDescriptor(Type::IfcStructuralLoadGroup,entity_descriptor_map.find(Type::IfcGroup)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcLoadGroupTypeEnum);
    current->add("ActionType",false,IfcUtil::Argument_ENUMERATION,Type::IfcActionTypeEnum);
    current->add("ActionSource",false,IfcUtil::Argument_ENUMERATION,Type::IfcActionSourceTypeEnum);
    current->add("Coefficient",true,IfcUtil::Argument_DOUBLE,Type::IfcRatioMeasure);
    current->add("Purpose",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current = entity_descriptor_map[Type::IfcStructuralPointAction] = new IfcEntityDescriptor(Type::IfcStructuralPointAction,entity_descriptor_map.find(Type::IfcStructuralAction)->second);

    current = entity_descriptor_map[Type::IfcStructuralPointConnection] = new IfcEntityDescriptor(Type::IfcStructuralPointConnection,entity_descriptor_map.find(Type::IfcStructuralConnection)->second);
    current->add("ConditionCoordinateSystem",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcAxis2Placement3D);
    current = entity_descriptor_map[Type::IfcStructuralPointReaction] = new IfcEntityDescriptor(Type::IfcStructuralPointReaction,entity_descriptor_map.find(Type::IfcStructuralReaction)->second);

    current = entity_descriptor_map[Type::IfcStructuralResultGroup] = new IfcEntityDescriptor(Type::IfcStructuralResultGroup,entity_descriptor_map.find(Type::IfcGroup)->second);
    current->add("TheoryType",false,IfcUtil::Argument_ENUMERATION,Type::IfcAnalysisTheoryTypeEnum);
    current->add("ResultForLoadGroup",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcStructuralLoadGroup);
    current->add("IsLinear",false,IfcUtil::Argument_BOOL,Type::IfcBoolean);
    current = entity_descriptor_map[Type::IfcStructuralSurfaceAction] = new IfcEntityDescriptor(Type::IfcStructuralSurfaceAction,entity_descriptor_map.find(Type::IfcStructuralAction)->second);
    current->add("ProjectedOrTrue",true,IfcUtil::Argument_ENUMERATION,Type::IfcProjectedOrTrueLengthEnum);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcStructuralSurfaceActivityTypeEnum);
    current = entity_descriptor_map[Type::IfcStructuralSurfaceConnection] = new IfcEntityDescriptor(Type::IfcStructuralSurfaceConnection,entity_descriptor_map.find(Type::IfcStructuralConnection)->second);

    current = entity_descriptor_map[Type::IfcSubContractResource] = new IfcEntityDescriptor(Type::IfcSubContractResource,entity_descriptor_map.find(Type::IfcConstructionResource)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcSubContractResourceTypeEnum);
    current = entity_descriptor_map[Type::IfcSurfaceFeature] = new IfcEntityDescriptor(Type::IfcSurfaceFeature,entity_descriptor_map.find(Type::IfcFeatureElement)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcSurfaceFeatureTypeEnum);
    current = entity_descriptor_map[Type::IfcSwitchingDeviceType] = new IfcEntityDescriptor(Type::IfcSwitchingDeviceType,entity_descriptor_map.find(Type::IfcFlowControllerType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcSwitchingDeviceTypeEnum);
    current = entity_descriptor_map[Type::IfcSystem] = new IfcEntityDescriptor(Type::IfcSystem,entity_descriptor_map.find(Type::IfcGroup)->second);

    current = entity_descriptor_map[Type::IfcSystemFurnitureElement] = new IfcEntityDescriptor(Type::IfcSystemFurnitureElement,entity_descriptor_map.find(Type::IfcFurnishingElement)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcSystemFurnitureElementTypeEnum);
    current = entity_descriptor_map[Type::IfcTankType] = new IfcEntityDescriptor(Type::IfcTankType,entity_descriptor_map.find(Type::IfcFlowStorageDeviceType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcTankTypeEnum);
    current = entity_descriptor_map[Type::IfcTendon] = new IfcEntityDescriptor(Type::IfcTendon,entity_descriptor_map.find(Type::IfcReinforcingElement)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcTendonTypeEnum);
    current->add("NominalDiameter",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("CrossSectionArea",true,IfcUtil::Argument_DOUBLE,Type::IfcAreaMeasure);
    current->add("TensionForce",true,IfcUtil::Argument_DOUBLE,Type::IfcForceMeasure);
    current->add("PreStress",true,IfcUtil::Argument_DOUBLE,Type::IfcPressureMeasure);
    current->add("FrictionCoefficient",true,IfcUtil::Argument_DOUBLE,Type::IfcNormalisedRatioMeasure);
    current->add("AnchorageSlip",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("MinCurvatureRadius",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current = entity_descriptor_map[Type::IfcTendonAnchor] = new IfcEntityDescriptor(Type::IfcTendonAnchor,entity_descriptor_map.find(Type::IfcReinforcingElement)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcTendonAnchorTypeEnum);
    current = entity_descriptor_map[Type::IfcTendonAnchorType] = new IfcEntityDescriptor(Type::IfcTendonAnchorType,entity_descriptor_map.find(Type::IfcReinforcingElementType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcTendonAnchorTypeEnum);
    current = entity_descriptor_map[Type::IfcTendonType] = new IfcEntityDescriptor(Type::IfcTendonType,entity_descriptor_map.find(Type::IfcReinforcingElementType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcTendonTypeEnum);
    current->add("NominalDiameter",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("CrossSectionArea",true,IfcUtil::Argument_DOUBLE,Type::IfcAreaMeasure);
    current->add("SheethDiameter",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current = entity_descriptor_map[Type::IfcTransformerType] = new IfcEntityDescriptor(Type::IfcTransformerType,entity_descriptor_map.find(Type::IfcEnergyConversionDeviceType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcTransformerTypeEnum);
    current = entity_descriptor_map[Type::IfcTransportElement] = new IfcEntityDescriptor(Type::IfcTransportElement,entity_descriptor_map.find(Type::IfcElement)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcTransportElementTypeEnum);
    current = entity_descriptor_map[Type::IfcTrimmedCurve] = new IfcEntityDescriptor(Type::IfcTrimmedCurve,entity_descriptor_map.find(Type::IfcBoundedCurve)->second);
    current->add("BasisCurve",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcCurve);
    current->add("Trim1",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcTrimmingSelect);
    current->add("Trim2",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcTrimmingSelect);
    current->add("SenseAgreement",false,IfcUtil::Argument_BOOL,Type::IfcBoolean);
    current->add("MasterRepresentation",false,IfcUtil::Argument_ENUMERATION,Type::IfcTrimmingPreference);
    current = entity_descriptor_map[Type::IfcTubeBundleType] = new IfcEntityDescriptor(Type::IfcTubeBundleType,entity_descriptor_map.find(Type::IfcEnergyConversionDeviceType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcTubeBundleTypeEnum);
    current = entity_descriptor_map[Type::IfcUnitaryEquipmentType] = new IfcEntityDescriptor(Type::IfcUnitaryEquipmentType,entity_descriptor_map.find(Type::IfcEnergyConversionDeviceType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcUnitaryEquipmentTypeEnum);
    current = entity_descriptor_map[Type::IfcValveType] = new IfcEntityDescriptor(Type::IfcValveType,entity_descriptor_map.find(Type::IfcFlowControllerType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcValveTypeEnum);
    current = entity_descriptor_map[Type::IfcVibrationIsolator] = new IfcEntityDescriptor(Type::IfcVibrationIsolator,entity_descriptor_map.find(Type::IfcElementComponent)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcVibrationIsolatorTypeEnum);
    current = entity_descriptor_map[Type::IfcVibrationIsolatorType] = new IfcEntityDescriptor(Type::IfcVibrationIsolatorType,entity_descriptor_map.find(Type::IfcElementComponentType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcVibrationIsolatorTypeEnum);
    current = entity_descriptor_map[Type::IfcVirtualElement] = new IfcEntityDescriptor(Type::IfcVirtualElement,entity_descriptor_map.find(Type::IfcElement)->second);

    current = entity_descriptor_map[Type::IfcVoidingFeature] = new IfcEntityDescriptor(Type::IfcVoidingFeature,entity_descriptor_map.find(Type::IfcFeatureElementSubtraction)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcVoidingFeatureTypeEnum);
    current = entity_descriptor_map[Type::IfcWallType] = new IfcEntityDescriptor(Type::IfcWallType,entity_descriptor_map.find(Type::IfcBuildingElementType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcWallTypeEnum);
    current = entity_descriptor_map[Type::IfcWasteTerminalType] = new IfcEntityDescriptor(Type::IfcWasteTerminalType,entity_descriptor_map.find(Type::IfcFlowTerminalType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcWasteTerminalTypeEnum);
    current = entity_descriptor_map[Type::IfcWindowType] = new IfcEntityDescriptor(Type::IfcWindowType,entity_descriptor_map.find(Type::IfcBuildingElementType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcWindowTypeEnum);
    current->add("PartitioningType",false,IfcUtil::Argument_ENUMERATION,Type::IfcWindowTypePartitioningEnum);
    current->add("ParameterTakesPrecedence",true,IfcUtil::Argument_BOOL,Type::IfcBoolean);
    current->add("UserDefinedPartitioningType",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current = entity_descriptor_map[Type::IfcWorkCalendar] = new IfcEntityDescriptor(Type::IfcWorkCalendar,entity_descriptor_map.find(Type::IfcControl)->second);
    current->add("WorkingTimes",true,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcWorkTime);
    current->add("ExceptionTimes",true,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcWorkTime);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcWorkCalendarTypeEnum);
    current = entity_descriptor_map[Type::IfcWorkControl] = new IfcEntityDescriptor(Type::IfcWorkControl,entity_descriptor_map.find(Type::IfcControl)->second);
    current->add("CreationDate",false,IfcUtil::Argument_STRING,Type::IfcDateTime);
    current->add("Creators",true,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcPerson);
    current->add("Purpose",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("Duration",true,IfcUtil::Argument_STRING,Type::IfcDuration);
    current->add("TotalFloat",true,IfcUtil::Argument_STRING,Type::IfcDuration);
    current->add("StartTime",false,IfcUtil::Argument_STRING,Type::IfcDateTime);
    current->add("FinishTime",true,IfcUtil::Argument_STRING,Type::IfcDateTime);
    current = entity_descriptor_map[Type::IfcWorkPlan] = new IfcEntityDescriptor(Type::IfcWorkPlan,entity_descriptor_map.find(Type::IfcWorkControl)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcWorkPlanTypeEnum);
    current = entity_descriptor_map[Type::IfcWorkSchedule] = new IfcEntityDescriptor(Type::IfcWorkSchedule,entity_descriptor_map.find(Type::IfcWorkControl)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcWorkScheduleTypeEnum);
    current = entity_descriptor_map[Type::IfcZone] = new IfcEntityDescriptor(Type::IfcZone,entity_descriptor_map.find(Type::IfcSystem)->second);
    current->add("LongName",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current = entity_descriptor_map[Type::IfcActionRequest] = new IfcEntityDescriptor(Type::IfcActionRequest,entity_descriptor_map.find(Type::IfcControl)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcActionRequestTypeEnum);
    current->add("Status",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("LongDescription",true,IfcUtil::Argument_STRING,Type::IfcText);
    current = entity_descriptor_map[Type::IfcAirTerminalBoxType] = new IfcEntityDescriptor(Type::IfcAirTerminalBoxType,entity_descriptor_map.find(Type::IfcFlowControllerType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcAirTerminalBoxTypeEnum);
    current = entity_descriptor_map[Type::IfcAirTerminalType] = new IfcEntityDescriptor(Type::IfcAirTerminalType,entity_descriptor_map.find(Type::IfcFlowTerminalType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcAirTerminalTypeEnum);
    current = entity_descriptor_map[Type::IfcAirToAirHeatRecoveryType] = new IfcEntityDescriptor(Type::IfcAirToAirHeatRecoveryType,entity_descriptor_map.find(Type::IfcEnergyConversionDeviceType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcAirToAirHeatRecoveryTypeEnum);
    current = entity_descriptor_map[Type::IfcAsset] = new IfcEntityDescriptor(Type::IfcAsset,entity_descriptor_map.find(Type::IfcGroup)->second);
    current->add("Identification",true,IfcUtil::Argument_STRING,Type::IfcIdentifier);
    current->add("OriginalValue",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcCostValue);
    current->add("CurrentValue",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcCostValue);
    current->add("TotalReplacementCost",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcCostValue);
    current->add("Owner",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcActorSelect);
    current->add("User",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcActorSelect);
    current->add("ResponsiblePerson",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcPerson);
    current->add("IncorporationDate",true,IfcUtil::Argument_STRING,Type::IfcDate);
    current->add("DepreciatedValue",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcCostValue);
    current = entity_descriptor_map[Type::IfcAudioVisualApplianceType] = new IfcEntityDescriptor(Type::IfcAudioVisualApplianceType,entity_descriptor_map.find(Type::IfcFlowTerminalType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcAudioVisualApplianceTypeEnum);
    current = entity_descriptor_map[Type::IfcBSplineCurve] = new IfcEntityDescriptor(Type::IfcBSplineCurve,entity_descriptor_map.find(Type::IfcBoundedCurve)->second);
    current->add("Degree",false,IfcUtil::Argument_INT,Type::IfcInteger);
    current->add("ControlPointsList",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcCartesianPoint);
    current->add("CurveForm",false,IfcUtil::Argument_ENUMERATION,Type::IfcBSplineCurveForm);
    current->add("ClosedCurve",false,IfcUtil::Argument_BOOL,Type::IfcLogical);
    current->add("SelfIntersect",false,IfcUtil::Argument_BOOL,Type::IfcLogical);
    current = entity_descriptor_map[Type::IfcBSplineCurveWithKnots] = new IfcEntityDescriptor(Type::IfcBSplineCurveWithKnots,entity_descriptor_map.find(Type::IfcBSplineCurve)->second);
    current->add("KnotMultiplicities",false,IfcUtil::Argument_AGGREGATE_OF_INT,Type::IfcInteger);
    current->add("Knots",false,IfcUtil::Argument_AGGREGATE_OF_DOUBLE,Type::IfcParameterValue);
    current->add("KnotSpec",false,IfcUtil::Argument_ENUMERATION,Type::IfcKnotType);
    current = entity_descriptor_map[Type::IfcBeamType] = new IfcEntityDescriptor(Type::IfcBeamType,entity_descriptor_map.find(Type::IfcBuildingElementType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcBeamTypeEnum);
    current = entity_descriptor_map[Type::IfcBoilerType] = new IfcEntityDescriptor(Type::IfcBoilerType,entity_descriptor_map.find(Type::IfcEnergyConversionDeviceType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcBoilerTypeEnum);
    current = entity_descriptor_map[Type::IfcBoundaryCurve] = new IfcEntityDescriptor(Type::IfcBoundaryCurve,entity_descriptor_map.find(Type::IfcCompositeCurveOnSurface)->second);

    current = entity_descriptor_map[Type::IfcBuildingElement] = new IfcEntityDescriptor(Type::IfcBuildingElement,entity_descriptor_map.find(Type::IfcElement)->second);

    current = entity_descriptor_map[Type::IfcBuildingElementPart] = new IfcEntityDescriptor(Type::IfcBuildingElementPart,entity_descriptor_map.find(Type::IfcElementComponent)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcBuildingElementPartTypeEnum);
    current = entity_descriptor_map[Type::IfcBuildingElementPartType] = new IfcEntityDescriptor(Type::IfcBuildingElementPartType,entity_descriptor_map.find(Type::IfcElementComponentType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcBuildingElementPartTypeEnum);
    current = entity_descriptor_map[Type::IfcBuildingElementProxy] = new IfcEntityDescriptor(Type::IfcBuildingElementProxy,entity_descriptor_map.find(Type::IfcBuildingElement)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcBuildingElementProxyTypeEnum);
    current = entity_descriptor_map[Type::IfcBuildingElementProxyType] = new IfcEntityDescriptor(Type::IfcBuildingElementProxyType,entity_descriptor_map.find(Type::IfcBuildingElementType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcBuildingElementProxyTypeEnum);
    current = entity_descriptor_map[Type::IfcBuildingSystem] = new IfcEntityDescriptor(Type::IfcBuildingSystem,entity_descriptor_map.find(Type::IfcSystem)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcBuildingSystemTypeEnum);
    current->add("LongName",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current = entity_descriptor_map[Type::IfcBurnerType] = new IfcEntityDescriptor(Type::IfcBurnerType,entity_descriptor_map.find(Type::IfcEnergyConversionDeviceType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcBurnerTypeEnum);
    current = entity_descriptor_map[Type::IfcCableCarrierFittingType] = new IfcEntityDescriptor(Type::IfcCableCarrierFittingType,entity_descriptor_map.find(Type::IfcFlowFittingType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcCableCarrierFittingTypeEnum);
    current = entity_descriptor_map[Type::IfcCableCarrierSegmentType] = new IfcEntityDescriptor(Type::IfcCableCarrierSegmentType,entity_descriptor_map.find(Type::IfcFlowSegmentType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcCableCarrierSegmentTypeEnum);
    current = entity_descriptor_map[Type::IfcCableFittingType] = new IfcEntityDescriptor(Type::IfcCableFittingType,entity_descriptor_map.find(Type::IfcFlowFittingType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcCableFittingTypeEnum);
    current = entity_descriptor_map[Type::IfcCableSegmentType] = new IfcEntityDescriptor(Type::IfcCableSegmentType,entity_descriptor_map.find(Type::IfcFlowSegmentType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcCableSegmentTypeEnum);
    current = entity_descriptor_map[Type::IfcChillerType] = new IfcEntityDescriptor(Type::IfcChillerType,entity_descriptor_map.find(Type::IfcEnergyConversionDeviceType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcChillerTypeEnum);
    current = entity_descriptor_map[Type::IfcChimney] = new IfcEntityDescriptor(Type::IfcChimney,entity_descriptor_map.find(Type::IfcBuildingElement)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcChimneyTypeEnum);
    current = entity_descriptor_map[Type::IfcCircle] = new IfcEntityDescriptor(Type::IfcCircle,entity_descriptor_map.find(Type::IfcConic)->second);
    current->add("Radius",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current = entity_descriptor_map[Type::IfcCivilElement] = new IfcEntityDescriptor(Type::IfcCivilElement,entity_descriptor_map.find(Type::IfcElement)->second);

    current = entity_descriptor_map[Type::IfcCoilType] = new IfcEntityDescriptor(Type::IfcCoilType,entity_descriptor_map.find(Type::IfcEnergyConversionDeviceType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcCoilTypeEnum);
    current = entity_descriptor_map[Type::IfcColumn] = new IfcEntityDescriptor(Type::IfcColumn,entity_descriptor_map.find(Type::IfcBuildingElement)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcColumnTypeEnum);
    current = entity_descriptor_map[Type::IfcColumnStandardCase] = new IfcEntityDescriptor(Type::IfcColumnStandardCase,entity_descriptor_map.find(Type::IfcColumn)->second);

    current = entity_descriptor_map[Type::IfcCommunicationsApplianceType] = new IfcEntityDescriptor(Type::IfcCommunicationsApplianceType,entity_descriptor_map.find(Type::IfcFlowTerminalType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcCommunicationsApplianceTypeEnum);
    current = entity_descriptor_map[Type::IfcCompressorType] = new IfcEntityDescriptor(Type::IfcCompressorType,entity_descriptor_map.find(Type::IfcFlowMovingDeviceType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcCompressorTypeEnum);
    current = entity_descriptor_map[Type::IfcCondenserType] = new IfcEntityDescriptor(Type::IfcCondenserType,entity_descriptor_map.find(Type::IfcEnergyConversionDeviceType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcCondenserTypeEnum);
    current = entity_descriptor_map[Type::IfcConstructionEquipmentResource] = new IfcEntityDescriptor(Type::IfcConstructionEquipmentResource,entity_descriptor_map.find(Type::IfcConstructionResource)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcConstructionEquipmentResourceTypeEnum);
    current = entity_descriptor_map[Type::IfcConstructionMaterialResource] = new IfcEntityDescriptor(Type::IfcConstructionMaterialResource,entity_descriptor_map.find(Type::IfcConstructionResource)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcConstructionMaterialResourceTypeEnum);
    current = entity_descriptor_map[Type::IfcConstructionProductResource] = new IfcEntityDescriptor(Type::IfcConstructionProductResource,entity_descriptor_map.find(Type::IfcConstructionResource)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcConstructionProductResourceTypeEnum);
    current = entity_descriptor_map[Type::IfcCooledBeamType] = new IfcEntityDescriptor(Type::IfcCooledBeamType,entity_descriptor_map.find(Type::IfcEnergyConversionDeviceType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcCooledBeamTypeEnum);
    current = entity_descriptor_map[Type::IfcCoolingTowerType] = new IfcEntityDescriptor(Type::IfcCoolingTowerType,entity_descriptor_map.find(Type::IfcEnergyConversionDeviceType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcCoolingTowerTypeEnum);
    current = entity_descriptor_map[Type::IfcCovering] = new IfcEntityDescriptor(Type::IfcCovering,entity_descriptor_map.find(Type::IfcBuildingElement)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcCoveringTypeEnum);
    current = entity_descriptor_map[Type::IfcCurtainWall] = new IfcEntityDescriptor(Type::IfcCurtainWall,entity_descriptor_map.find(Type::IfcBuildingElement)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcCurtainWallTypeEnum);
    current = entity_descriptor_map[Type::IfcDamperType] = new IfcEntityDescriptor(Type::IfcDamperType,entity_descriptor_map.find(Type::IfcFlowControllerType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcDamperTypeEnum);
    current = entity_descriptor_map[Type::IfcDiscreteAccessory] = new IfcEntityDescriptor(Type::IfcDiscreteAccessory,entity_descriptor_map.find(Type::IfcElementComponent)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcDiscreteAccessoryTypeEnum);
    current = entity_descriptor_map[Type::IfcDiscreteAccessoryType] = new IfcEntityDescriptor(Type::IfcDiscreteAccessoryType,entity_descriptor_map.find(Type::IfcElementComponentType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcDiscreteAccessoryTypeEnum);
    current = entity_descriptor_map[Type::IfcDistributionChamberElementType] = new IfcEntityDescriptor(Type::IfcDistributionChamberElementType,entity_descriptor_map.find(Type::IfcDistributionFlowElementType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcDistributionChamberElementTypeEnum);
    current = entity_descriptor_map[Type::IfcDistributionControlElementType] = new IfcEntityDescriptor(Type::IfcDistributionControlElementType,entity_descriptor_map.find(Type::IfcDistributionElementType)->second);

    current = entity_descriptor_map[Type::IfcDistributionElement] = new IfcEntityDescriptor(Type::IfcDistributionElement,entity_descriptor_map.find(Type::IfcElement)->second);

    current = entity_descriptor_map[Type::IfcDistributionFlowElement] = new IfcEntityDescriptor(Type::IfcDistributionFlowElement,entity_descriptor_map.find(Type::IfcDistributionElement)->second);

    current = entity_descriptor_map[Type::IfcDistributionPort] = new IfcEntityDescriptor(Type::IfcDistributionPort,entity_descriptor_map.find(Type::IfcPort)->second);
    current->add("FlowDirection",true,IfcUtil::Argument_ENUMERATION,Type::IfcFlowDirectionEnum);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcDistributionPortTypeEnum);
    current->add("SystemType",true,IfcUtil::Argument_ENUMERATION,Type::IfcDistributionSystemEnum);
    current = entity_descriptor_map[Type::IfcDistributionSystem] = new IfcEntityDescriptor(Type::IfcDistributionSystem,entity_descriptor_map.find(Type::IfcSystem)->second);
    current->add("LongName",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcDistributionSystemEnum);
    current = entity_descriptor_map[Type::IfcDoor] = new IfcEntityDescriptor(Type::IfcDoor,entity_descriptor_map.find(Type::IfcBuildingElement)->second);
    current->add("OverallHeight",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("OverallWidth",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcDoorTypeEnum);
    current->add("OperationType",true,IfcUtil::Argument_ENUMERATION,Type::IfcDoorTypeOperationEnum);
    current->add("UserDefinedOperationType",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current = entity_descriptor_map[Type::IfcDoorStandardCase] = new IfcEntityDescriptor(Type::IfcDoorStandardCase,entity_descriptor_map.find(Type::IfcDoor)->second);

    current = entity_descriptor_map[Type::IfcDuctFittingType] = new IfcEntityDescriptor(Type::IfcDuctFittingType,entity_descriptor_map.find(Type::IfcFlowFittingType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcDuctFittingTypeEnum);
    current = entity_descriptor_map[Type::IfcDuctSegmentType] = new IfcEntityDescriptor(Type::IfcDuctSegmentType,entity_descriptor_map.find(Type::IfcFlowSegmentType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcDuctSegmentTypeEnum);
    current = entity_descriptor_map[Type::IfcDuctSilencerType] = new IfcEntityDescriptor(Type::IfcDuctSilencerType,entity_descriptor_map.find(Type::IfcFlowTreatmentDeviceType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcDuctSilencerTypeEnum);
    current = entity_descriptor_map[Type::IfcElectricApplianceType] = new IfcEntityDescriptor(Type::IfcElectricApplianceType,entity_descriptor_map.find(Type::IfcFlowTerminalType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcElectricApplianceTypeEnum);
    current = entity_descriptor_map[Type::IfcElectricDistributionBoardType] = new IfcEntityDescriptor(Type::IfcElectricDistributionBoardType,entity_descriptor_map.find(Type::IfcFlowControllerType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcElectricDistributionBoardTypeEnum);
    current = entity_descriptor_map[Type::IfcElectricFlowStorageDeviceType] = new IfcEntityDescriptor(Type::IfcElectricFlowStorageDeviceType,entity_descriptor_map.find(Type::IfcFlowStorageDeviceType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcElectricFlowStorageDeviceTypeEnum);
    current = entity_descriptor_map[Type::IfcElectricGeneratorType] = new IfcEntityDescriptor(Type::IfcElectricGeneratorType,entity_descriptor_map.find(Type::IfcEnergyConversionDeviceType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcElectricGeneratorTypeEnum);
    current = entity_descriptor_map[Type::IfcElectricMotorType] = new IfcEntityDescriptor(Type::IfcElectricMotorType,entity_descriptor_map.find(Type::IfcEnergyConversionDeviceType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcElectricMotorTypeEnum);
    current = entity_descriptor_map[Type::IfcElectricTimeControlType] = new IfcEntityDescriptor(Type::IfcElectricTimeControlType,entity_descriptor_map.find(Type::IfcFlowControllerType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcElectricTimeControlTypeEnum);
    current = entity_descriptor_map[Type::IfcEnergyConversionDevice] = new IfcEntityDescriptor(Type::IfcEnergyConversionDevice,entity_descriptor_map.find(Type::IfcDistributionFlowElement)->second);

    current = entity_descriptor_map[Type::IfcEngine] = new IfcEntityDescriptor(Type::IfcEngine,entity_descriptor_map.find(Type::IfcEnergyConversionDevice)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcEngineTypeEnum);
    current = entity_descriptor_map[Type::IfcEvaporativeCooler] = new IfcEntityDescriptor(Type::IfcEvaporativeCooler,entity_descriptor_map.find(Type::IfcEnergyConversionDevice)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcEvaporativeCoolerTypeEnum);
    current = entity_descriptor_map[Type::IfcEvaporator] = new IfcEntityDescriptor(Type::IfcEvaporator,entity_descriptor_map.find(Type::IfcEnergyConversionDevice)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcEvaporatorTypeEnum);
    current = entity_descriptor_map[Type::IfcExternalSpatialElement] = new IfcEntityDescriptor(Type::IfcExternalSpatialElement,entity_descriptor_map.find(Type::IfcExternalSpatialStructureElement)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcExternalSpatialElementTypeEnum);
    current = entity_descriptor_map[Type::IfcFanType] = new IfcEntityDescriptor(Type::IfcFanType,entity_descriptor_map.find(Type::IfcFlowMovingDeviceType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcFanTypeEnum);
    current = entity_descriptor_map[Type::IfcFilterType] = new IfcEntityDescriptor(Type::IfcFilterType,entity_descriptor_map.find(Type::IfcFlowTreatmentDeviceType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcFilterTypeEnum);
    current = entity_descriptor_map[Type::IfcFireSuppressionTerminalType] = new IfcEntityDescriptor(Type::IfcFireSuppressionTerminalType,entity_descriptor_map.find(Type::IfcFlowTerminalType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcFireSuppressionTerminalTypeEnum);
    current = entity_descriptor_map[Type::IfcFlowController] = new IfcEntityDescriptor(Type::IfcFlowController,entity_descriptor_map.find(Type::IfcDistributionFlowElement)->second);

    current = entity_descriptor_map[Type::IfcFlowFitting] = new IfcEntityDescriptor(Type::IfcFlowFitting,entity_descriptor_map.find(Type::IfcDistributionFlowElement)->second);

    current = entity_descriptor_map[Type::IfcFlowInstrumentType] = new IfcEntityDescriptor(Type::IfcFlowInstrumentType,entity_descriptor_map.find(Type::IfcDistributionControlElementType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcFlowInstrumentTypeEnum);
    current = entity_descriptor_map[Type::IfcFlowMeter] = new IfcEntityDescriptor(Type::IfcFlowMeter,entity_descriptor_map.find(Type::IfcFlowController)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcFlowMeterTypeEnum);
    current = entity_descriptor_map[Type::IfcFlowMovingDevice] = new IfcEntityDescriptor(Type::IfcFlowMovingDevice,entity_descriptor_map.find(Type::IfcDistributionFlowElement)->second);

    current = entity_descriptor_map[Type::IfcFlowSegment] = new IfcEntityDescriptor(Type::IfcFlowSegment,entity_descriptor_map.find(Type::IfcDistributionFlowElement)->second);

    current = entity_descriptor_map[Type::IfcFlowStorageDevice] = new IfcEntityDescriptor(Type::IfcFlowStorageDevice,entity_descriptor_map.find(Type::IfcDistributionFlowElement)->second);

    current = entity_descriptor_map[Type::IfcFlowTerminal] = new IfcEntityDescriptor(Type::IfcFlowTerminal,entity_descriptor_map.find(Type::IfcDistributionFlowElement)->second);

    current = entity_descriptor_map[Type::IfcFlowTreatmentDevice] = new IfcEntityDescriptor(Type::IfcFlowTreatmentDevice,entity_descriptor_map.find(Type::IfcDistributionFlowElement)->second);

    current = entity_descriptor_map[Type::IfcFooting] = new IfcEntityDescriptor(Type::IfcFooting,entity_descriptor_map.find(Type::IfcBuildingElement)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcFootingTypeEnum);
    current = entity_descriptor_map[Type::IfcHeatExchanger] = new IfcEntityDescriptor(Type::IfcHeatExchanger,entity_descriptor_map.find(Type::IfcEnergyConversionDevice)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcHeatExchangerTypeEnum);
    current = entity_descriptor_map[Type::IfcHumidifier] = new IfcEntityDescriptor(Type::IfcHumidifier,entity_descriptor_map.find(Type::IfcEnergyConversionDevice)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcHumidifierTypeEnum);
    current = entity_descriptor_map[Type::IfcInterceptor] = new IfcEntityDescriptor(Type::IfcInterceptor,entity_descriptor_map.find(Type::IfcFlowTreatmentDevice)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcInterceptorTypeEnum);
    current = entity_descriptor_map[Type::IfcJunctionBox] = new IfcEntityDescriptor(Type::IfcJunctionBox,entity_descriptor_map.find(Type::IfcFlowFitting)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcJunctionBoxTypeEnum);
    current = entity_descriptor_map[Type::IfcLamp] = new IfcEntityDescriptor(Type::IfcLamp,entity_descriptor_map.find(Type::IfcFlowTerminal)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcLampTypeEnum);
    current = entity_descriptor_map[Type::IfcLightFixture] = new IfcEntityDescriptor(Type::IfcLightFixture,entity_descriptor_map.find(Type::IfcFlowTerminal)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcLightFixtureTypeEnum);
    current = entity_descriptor_map[Type::IfcMedicalDevice] = new IfcEntityDescriptor(Type::IfcMedicalDevice,entity_descriptor_map.find(Type::IfcFlowTerminal)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcMedicalDeviceTypeEnum);
    current = entity_descriptor_map[Type::IfcMember] = new IfcEntityDescriptor(Type::IfcMember,entity_descriptor_map.find(Type::IfcBuildingElement)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcMemberTypeEnum);
    current = entity_descriptor_map[Type::IfcMemberStandardCase] = new IfcEntityDescriptor(Type::IfcMemberStandardCase,entity_descriptor_map.find(Type::IfcMember)->second);

    current = entity_descriptor_map[Type::IfcMotorConnection] = new IfcEntityDescriptor(Type::IfcMotorConnection,entity_descriptor_map.find(Type::IfcEnergyConversionDevice)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcMotorConnectionTypeEnum);
    current = entity_descriptor_map[Type::IfcOuterBoundaryCurve] = new IfcEntityDescriptor(Type::IfcOuterBoundaryCurve,entity_descriptor_map.find(Type::IfcBoundaryCurve)->second);

    current = entity_descriptor_map[Type::IfcOutlet] = new IfcEntityDescriptor(Type::IfcOutlet,entity_descriptor_map.find(Type::IfcFlowTerminal)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcOutletTypeEnum);
    current = entity_descriptor_map[Type::IfcPile] = new IfcEntityDescriptor(Type::IfcPile,entity_descriptor_map.find(Type::IfcBuildingElement)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcPileTypeEnum);
    current->add("ConstructionType",true,IfcUtil::Argument_ENUMERATION,Type::IfcPileConstructionEnum);
    current = entity_descriptor_map[Type::IfcPipeFitting] = new IfcEntityDescriptor(Type::IfcPipeFitting,entity_descriptor_map.find(Type::IfcFlowFitting)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcPipeFittingTypeEnum);
    current = entity_descriptor_map[Type::IfcPipeSegment] = new IfcEntityDescriptor(Type::IfcPipeSegment,entity_descriptor_map.find(Type::IfcFlowSegment)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcPipeSegmentTypeEnum);
    current = entity_descriptor_map[Type::IfcPlate] = new IfcEntityDescriptor(Type::IfcPlate,entity_descriptor_map.find(Type::IfcBuildingElement)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcPlateTypeEnum);
    current = entity_descriptor_map[Type::IfcPlateStandardCase] = new IfcEntityDescriptor(Type::IfcPlateStandardCase,entity_descriptor_map.find(Type::IfcPlate)->second);

    current = entity_descriptor_map[Type::IfcProtectiveDevice] = new IfcEntityDescriptor(Type::IfcProtectiveDevice,entity_descriptor_map.find(Type::IfcFlowController)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcProtectiveDeviceTypeEnum);
    current = entity_descriptor_map[Type::IfcProtectiveDeviceTrippingUnitType] = new IfcEntityDescriptor(Type::IfcProtectiveDeviceTrippingUnitType,entity_descriptor_map.find(Type::IfcDistributionControlElementType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcProtectiveDeviceTrippingUnitTypeEnum);
    current = entity_descriptor_map[Type::IfcPump] = new IfcEntityDescriptor(Type::IfcPump,entity_descriptor_map.find(Type::IfcFlowMovingDevice)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcPumpTypeEnum);
    current = entity_descriptor_map[Type::IfcRailing] = new IfcEntityDescriptor(Type::IfcRailing,entity_descriptor_map.find(Type::IfcBuildingElement)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcRailingTypeEnum);
    current = entity_descriptor_map[Type::IfcRamp] = new IfcEntityDescriptor(Type::IfcRamp,entity_descriptor_map.find(Type::IfcBuildingElement)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcRampTypeEnum);
    current = entity_descriptor_map[Type::IfcRampFlight] = new IfcEntityDescriptor(Type::IfcRampFlight,entity_descriptor_map.find(Type::IfcBuildingElement)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcRampFlightTypeEnum);
    current = entity_descriptor_map[Type::IfcRationalBSplineCurveWithKnots] = new IfcEntityDescriptor(Type::IfcRationalBSplineCurveWithKnots,entity_descriptor_map.find(Type::IfcBSplineCurveWithKnots)->second);
    current->add("WeightsData",false,IfcUtil::Argument_AGGREGATE_OF_DOUBLE,Type::IfcReal);
    current = entity_descriptor_map[Type::IfcReinforcingBar] = new IfcEntityDescriptor(Type::IfcReinforcingBar,entity_descriptor_map.find(Type::IfcReinforcingElement)->second);
    current->add("NominalDiameter",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("CrossSectionArea",true,IfcUtil::Argument_DOUBLE,Type::IfcAreaMeasure);
    current->add("BarLength",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcReinforcingBarTypeEnum);
    current->add("BarSurface",true,IfcUtil::Argument_ENUMERATION,Type::IfcReinforcingBarSurfaceEnum);
    current = entity_descriptor_map[Type::IfcReinforcingBarType] = new IfcEntityDescriptor(Type::IfcReinforcingBarType,entity_descriptor_map.find(Type::IfcReinforcingElementType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcReinforcingBarTypeEnum);
    current->add("NominalDiameter",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("CrossSectionArea",true,IfcUtil::Argument_DOUBLE,Type::IfcAreaMeasure);
    current->add("BarLength",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("BarSurface",true,IfcUtil::Argument_ENUMERATION,Type::IfcReinforcingBarSurfaceEnum);
    current->add("BendingShapeCode",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("BendingParameters",true,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcBendingParameterSelect);
    current = entity_descriptor_map[Type::IfcRoof] = new IfcEntityDescriptor(Type::IfcRoof,entity_descriptor_map.find(Type::IfcBuildingElement)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcRoofTypeEnum);
    current = entity_descriptor_map[Type::IfcSanitaryTerminal] = new IfcEntityDescriptor(Type::IfcSanitaryTerminal,entity_descriptor_map.find(Type::IfcFlowTerminal)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcSanitaryTerminalTypeEnum);
    current = entity_descriptor_map[Type::IfcSensorType] = new IfcEntityDescriptor(Type::IfcSensorType,entity_descriptor_map.find(Type::IfcDistributionControlElementType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcSensorTypeEnum);
    current = entity_descriptor_map[Type::IfcShadingDevice] = new IfcEntityDescriptor(Type::IfcShadingDevice,entity_descriptor_map.find(Type::IfcBuildingElement)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcShadingDeviceTypeEnum);
    current = entity_descriptor_map[Type::IfcSlab] = new IfcEntityDescriptor(Type::IfcSlab,entity_descriptor_map.find(Type::IfcBuildingElement)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcSlabTypeEnum);
    current = entity_descriptor_map[Type::IfcSlabElementedCase] = new IfcEntityDescriptor(Type::IfcSlabElementedCase,entity_descriptor_map.find(Type::IfcSlab)->second);

    current = entity_descriptor_map[Type::IfcSlabStandardCase] = new IfcEntityDescriptor(Type::IfcSlabStandardCase,entity_descriptor_map.find(Type::IfcSlab)->second);

    current = entity_descriptor_map[Type::IfcSolarDevice] = new IfcEntityDescriptor(Type::IfcSolarDevice,entity_descriptor_map.find(Type::IfcEnergyConversionDevice)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcSolarDeviceTypeEnum);
    current = entity_descriptor_map[Type::IfcSpaceHeater] = new IfcEntityDescriptor(Type::IfcSpaceHeater,entity_descriptor_map.find(Type::IfcFlowTerminal)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcSpaceHeaterTypeEnum);
    current = entity_descriptor_map[Type::IfcStackTerminal] = new IfcEntityDescriptor(Type::IfcStackTerminal,entity_descriptor_map.find(Type::IfcFlowTerminal)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcStackTerminalTypeEnum);
    current = entity_descriptor_map[Type::IfcStair] = new IfcEntityDescriptor(Type::IfcStair,entity_descriptor_map.find(Type::IfcBuildingElement)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcStairTypeEnum);
    current = entity_descriptor_map[Type::IfcStairFlight] = new IfcEntityDescriptor(Type::IfcStairFlight,entity_descriptor_map.find(Type::IfcBuildingElement)->second);
    current->add("NumberOfRisers",true,IfcUtil::Argument_INT,Type::IfcInteger);
    current->add("NumberOfTreads",true,IfcUtil::Argument_INT,Type::IfcInteger);
    current->add("RiserHeight",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("TreadLength",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcStairFlightTypeEnum);
    current = entity_descriptor_map[Type::IfcStructuralAnalysisModel] = new IfcEntityDescriptor(Type::IfcStructuralAnalysisModel,entity_descriptor_map.find(Type::IfcSystem)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcAnalysisModelTypeEnum);
    current->add("OrientationOf2DPlane",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcAxis2Placement3D);
    current->add("LoadedBy",true,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcStructuralLoadGroup);
    current->add("HasResults",true,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcStructuralResultGroup);
    current->add("SharedPlacement",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcObjectPlacement);
    current = entity_descriptor_map[Type::IfcStructuralLoadCase] = new IfcEntityDescriptor(Type::IfcStructuralLoadCase,entity_descriptor_map.find(Type::IfcStructuralLoadGroup)->second);
    current->add("SelfWeightCoefficients",true,IfcUtil::Argument_AGGREGATE_OF_DOUBLE,Type::IfcRatioMeasure);
    current = entity_descriptor_map[Type::IfcStructuralPlanarAction] = new IfcEntityDescriptor(Type::IfcStructuralPlanarAction,entity_descriptor_map.find(Type::IfcStructuralSurfaceAction)->second);

    current = entity_descriptor_map[Type::IfcSwitchingDevice] = new IfcEntityDescriptor(Type::IfcSwitchingDevice,entity_descriptor_map.find(Type::IfcFlowController)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcSwitchingDeviceTypeEnum);
    current = entity_descriptor_map[Type::IfcTank] = new IfcEntityDescriptor(Type::IfcTank,entity_descriptor_map.find(Type::IfcFlowStorageDevice)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcTankTypeEnum);
    current = entity_descriptor_map[Type::IfcTransformer] = new IfcEntityDescriptor(Type::IfcTransformer,entity_descriptor_map.find(Type::IfcEnergyConversionDevice)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcTransformerTypeEnum);
    current = entity_descriptor_map[Type::IfcTubeBundle] = new IfcEntityDescriptor(Type::IfcTubeBundle,entity_descriptor_map.find(Type::IfcEnergyConversionDevice)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcTubeBundleTypeEnum);
    current = entity_descriptor_map[Type::IfcUnitaryControlElementType] = new IfcEntityDescriptor(Type::IfcUnitaryControlElementType,entity_descriptor_map.find(Type::IfcDistributionControlElementType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcUnitaryControlElementTypeEnum);
    current = entity_descriptor_map[Type::IfcUnitaryEquipment] = new IfcEntityDescriptor(Type::IfcUnitaryEquipment,entity_descriptor_map.find(Type::IfcEnergyConversionDevice)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcUnitaryEquipmentTypeEnum);
    current = entity_descriptor_map[Type::IfcValve] = new IfcEntityDescriptor(Type::IfcValve,entity_descriptor_map.find(Type::IfcFlowController)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcValveTypeEnum);
    current = entity_descriptor_map[Type::IfcWall] = new IfcEntityDescriptor(Type::IfcWall,entity_descriptor_map.find(Type::IfcBuildingElement)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcWallTypeEnum);
    current = entity_descriptor_map[Type::IfcWallElementedCase] = new IfcEntityDescriptor(Type::IfcWallElementedCase,entity_descriptor_map.find(Type::IfcWall)->second);

    current = entity_descriptor_map[Type::IfcWallStandardCase] = new IfcEntityDescriptor(Type::IfcWallStandardCase,entity_descriptor_map.find(Type::IfcWall)->second);

    current = entity_descriptor_map[Type::IfcWasteTerminal] = new IfcEntityDescriptor(Type::IfcWasteTerminal,entity_descriptor_map.find(Type::IfcFlowTerminal)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcWasteTerminalTypeEnum);
    current = entity_descriptor_map[Type::IfcWindow] = new IfcEntityDescriptor(Type::IfcWindow,entity_descriptor_map.find(Type::IfcBuildingElement)->second);
    current->add("OverallHeight",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("OverallWidth",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcWindowTypeEnum);
    current->add("PartitioningType",true,IfcUtil::Argument_ENUMERATION,Type::IfcWindowTypePartitioningEnum);
    current->add("UserDefinedPartitioningType",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current = entity_descriptor_map[Type::IfcWindowStandardCase] = new IfcEntityDescriptor(Type::IfcWindowStandardCase,entity_descriptor_map.find(Type::IfcWindow)->second);

    current = entity_descriptor_map[Type::IfcActuatorType] = new IfcEntityDescriptor(Type::IfcActuatorType,entity_descriptor_map.find(Type::IfcDistributionControlElementType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcActuatorTypeEnum);
    current = entity_descriptor_map[Type::IfcAirTerminal] = new IfcEntityDescriptor(Type::IfcAirTerminal,entity_descriptor_map.find(Type::IfcFlowTerminal)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcAirTerminalTypeEnum);
    current = entity_descriptor_map[Type::IfcAirTerminalBox] = new IfcEntityDescriptor(Type::IfcAirTerminalBox,entity_descriptor_map.find(Type::IfcFlowController)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcAirTerminalBoxTypeEnum);
    current = entity_descriptor_map[Type::IfcAirToAirHeatRecovery] = new IfcEntityDescriptor(Type::IfcAirToAirHeatRecovery,entity_descriptor_map.find(Type::IfcEnergyConversionDevice)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcAirToAirHeatRecoveryTypeEnum);
    current = entity_descriptor_map[Type::IfcAlarmType] = new IfcEntityDescriptor(Type::IfcAlarmType,entity_descriptor_map.find(Type::IfcDistributionControlElementType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcAlarmTypeEnum);
    current = entity_descriptor_map[Type::IfcAudioVisualAppliance] = new IfcEntityDescriptor(Type::IfcAudioVisualAppliance,entity_descriptor_map.find(Type::IfcFlowTerminal)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcAudioVisualApplianceTypeEnum);
    current = entity_descriptor_map[Type::IfcBeam] = new IfcEntityDescriptor(Type::IfcBeam,entity_descriptor_map.find(Type::IfcBuildingElement)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcBeamTypeEnum);
    current = entity_descriptor_map[Type::IfcBeamStandardCase] = new IfcEntityDescriptor(Type::IfcBeamStandardCase,entity_descriptor_map.find(Type::IfcBeam)->second);

    current = entity_descriptor_map[Type::IfcBoiler] = new IfcEntityDescriptor(Type::IfcBoiler,entity_descriptor_map.find(Type::IfcEnergyConversionDevice)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcBoilerTypeEnum);
    current = entity_descriptor_map[Type::IfcBurner] = new IfcEntityDescriptor(Type::IfcBurner,entity_descriptor_map.find(Type::IfcEnergyConversionDevice)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcBurnerTypeEnum);
    current = entity_descriptor_map[Type::IfcCableCarrierFitting] = new IfcEntityDescriptor(Type::IfcCableCarrierFitting,entity_descriptor_map.find(Type::IfcFlowFitting)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcCableCarrierFittingTypeEnum);
    current = entity_descriptor_map[Type::IfcCableCarrierSegment] = new IfcEntityDescriptor(Type::IfcCableCarrierSegment,entity_descriptor_map.find(Type::IfcFlowSegment)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcCableCarrierSegmentTypeEnum);
    current = entity_descriptor_map[Type::IfcCableFitting] = new IfcEntityDescriptor(Type::IfcCableFitting,entity_descriptor_map.find(Type::IfcFlowFitting)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcCableFittingTypeEnum);
    current = entity_descriptor_map[Type::IfcCableSegment] = new IfcEntityDescriptor(Type::IfcCableSegment,entity_descriptor_map.find(Type::IfcFlowSegment)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcCableSegmentTypeEnum);
    current = entity_descriptor_map[Type::IfcChiller] = new IfcEntityDescriptor(Type::IfcChiller,entity_descriptor_map.find(Type::IfcEnergyConversionDevice)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcChillerTypeEnum);
    current = entity_descriptor_map[Type::IfcCoil] = new IfcEntityDescriptor(Type::IfcCoil,entity_descriptor_map.find(Type::IfcEnergyConversionDevice)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcCoilTypeEnum);
    current = entity_descriptor_map[Type::IfcCommunicationsAppliance] = new IfcEntityDescriptor(Type::IfcCommunicationsAppliance,entity_descriptor_map.find(Type::IfcFlowTerminal)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcCommunicationsApplianceTypeEnum);
    current = entity_descriptor_map[Type::IfcCompressor] = new IfcEntityDescriptor(Type::IfcCompressor,entity_descriptor_map.find(Type::IfcFlowMovingDevice)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcCompressorTypeEnum);
    current = entity_descriptor_map[Type::IfcCondenser] = new IfcEntityDescriptor(Type::IfcCondenser,entity_descriptor_map.find(Type::IfcEnergyConversionDevice)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcCondenserTypeEnum);
    current = entity_descriptor_map[Type::IfcControllerType] = new IfcEntityDescriptor(Type::IfcControllerType,entity_descriptor_map.find(Type::IfcDistributionControlElementType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcControllerTypeEnum);
    current = entity_descriptor_map[Type::IfcCooledBeam] = new IfcEntityDescriptor(Type::IfcCooledBeam,entity_descriptor_map.find(Type::IfcEnergyConversionDevice)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcCooledBeamTypeEnum);
    current = entity_descriptor_map[Type::IfcCoolingTower] = new IfcEntityDescriptor(Type::IfcCoolingTower,entity_descriptor_map.find(Type::IfcEnergyConversionDevice)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcCoolingTowerTypeEnum);
    current = entity_descriptor_map[Type::IfcDamper] = new IfcEntityDescriptor(Type::IfcDamper,entity_descriptor_map.find(Type::IfcFlowController)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcDamperTypeEnum);
    current = entity_descriptor_map[Type::IfcDistributionChamberElement] = new IfcEntityDescriptor(Type::IfcDistributionChamberElement,entity_descriptor_map.find(Type::IfcDistributionFlowElement)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcDistributionChamberElementTypeEnum);
    current = entity_descriptor_map[Type::IfcDistributionCircuit] = new IfcEntityDescriptor(Type::IfcDistributionCircuit,entity_descriptor_map.find(Type::IfcDistributionSystem)->second);

    current = entity_descriptor_map[Type::IfcDistributionControlElement] = new IfcEntityDescriptor(Type::IfcDistributionControlElement,entity_descriptor_map.find(Type::IfcDistributionElement)->second);

    current = entity_descriptor_map[Type::IfcDuctFitting] = new IfcEntityDescriptor(Type::IfcDuctFitting,entity_descriptor_map.find(Type::IfcFlowFitting)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcDuctFittingTypeEnum);
    current = entity_descriptor_map[Type::IfcDuctSegment] = new IfcEntityDescriptor(Type::IfcDuctSegment,entity_descriptor_map.find(Type::IfcFlowSegment)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcDuctSegmentTypeEnum);
    current = entity_descriptor_map[Type::IfcDuctSilencer] = new IfcEntityDescriptor(Type::IfcDuctSilencer,entity_descriptor_map.find(Type::IfcFlowTreatmentDevice)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcDuctSilencerTypeEnum);
    current = entity_descriptor_map[Type::IfcElectricAppliance] = new IfcEntityDescriptor(Type::IfcElectricAppliance,entity_descriptor_map.find(Type::IfcFlowTerminal)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcElectricApplianceTypeEnum);
    current = entity_descriptor_map[Type::IfcElectricDistributionBoard] = new IfcEntityDescriptor(Type::IfcElectricDistributionBoard,entity_descriptor_map.find(Type::IfcFlowController)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcElectricDistributionBoardTypeEnum);
    current = entity_descriptor_map[Type::IfcElectricFlowStorageDevice] = new IfcEntityDescriptor(Type::IfcElectricFlowStorageDevice,entity_descriptor_map.find(Type::IfcFlowStorageDevice)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcElectricFlowStorageDeviceTypeEnum);
    current = entity_descriptor_map[Type::IfcElectricGenerator] = new IfcEntityDescriptor(Type::IfcElectricGenerator,entity_descriptor_map.find(Type::IfcEnergyConversionDevice)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcElectricGeneratorTypeEnum);
    current = entity_descriptor_map[Type::IfcElectricMotor] = new IfcEntityDescriptor(Type::IfcElectricMotor,entity_descriptor_map.find(Type::IfcEnergyConversionDevice)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcElectricMotorTypeEnum);
    current = entity_descriptor_map[Type::IfcElectricTimeControl] = new IfcEntityDescriptor(Type::IfcElectricTimeControl,entity_descriptor_map.find(Type::IfcFlowController)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcElectricTimeControlTypeEnum);
    current = entity_descriptor_map[Type::IfcFan] = new IfcEntityDescriptor(Type::IfcFan,entity_descriptor_map.find(Type::IfcFlowMovingDevice)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcFanTypeEnum);
    current = entity_descriptor_map[Type::IfcFilter] = new IfcEntityDescriptor(Type::IfcFilter,entity_descriptor_map.find(Type::IfcFlowTreatmentDevice)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcFilterTypeEnum);
    current = entity_descriptor_map[Type::IfcFireSuppressionTerminal] = new IfcEntityDescriptor(Type::IfcFireSuppressionTerminal,entity_descriptor_map.find(Type::IfcFlowTerminal)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcFireSuppressionTerminalTypeEnum);
    current = entity_descriptor_map[Type::IfcFlowInstrument] = new IfcEntityDescriptor(Type::IfcFlowInstrument,entity_descriptor_map.find(Type::IfcDistributionControlElement)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcFlowInstrumentTypeEnum);
    current = entity_descriptor_map[Type::IfcProtectiveDeviceTrippingUnit] = new IfcEntityDescriptor(Type::IfcProtectiveDeviceTrippingUnit,entity_descriptor_map.find(Type::IfcDistributionControlElement)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcProtectiveDeviceTrippingUnitTypeEnum);
    current = entity_descriptor_map[Type::IfcSensor] = new IfcEntityDescriptor(Type::IfcSensor,entity_descriptor_map.find(Type::IfcDistributionControlElement)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcSensorTypeEnum);
    current = entity_descriptor_map[Type::IfcUnitaryControlElement] = new IfcEntityDescriptor(Type::IfcUnitaryControlElement,entity_descriptor_map.find(Type::IfcDistributionControlElement)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcUnitaryControlElementTypeEnum);
    current = entity_descriptor_map[Type::IfcActuator] = new IfcEntityDescriptor(Type::IfcActuator,entity_descriptor_map.find(Type::IfcDistributionControlElement)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcActuatorTypeEnum);
    current = entity_descriptor_map[Type::IfcAlarm] = new IfcEntityDescriptor(Type::IfcAlarm,entity_descriptor_map.find(Type::IfcDistributionControlElement)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcAlarmTypeEnum);
    current = entity_descriptor_map[Type::IfcController] = new IfcEntityDescriptor(Type::IfcController,entity_descriptor_map.find(Type::IfcDistributionControlElement)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcControllerTypeEnum);
    // Enumerations
    std::vector<std::string> values;
    values.clear(); values.reserve(128);
    values.push_back("EMAIL");
    values.push_back("FAX");
    values.push_back("PHONE");
    values.push_back("POST");
    values.push_back("VERBAL");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcActionRequestTypeEnum] = new IfcEnumerationDescriptor(Type::IfcActionRequestTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("DEAD_LOAD_G");
    values.push_back("COMPLETION_G1");
    values.push_back("LIVE_LOAD_Q");
    values.push_back("SNOW_S");
    values.push_back("WIND_W");
    values.push_back("PRESTRESSING_P");
    values.push_back("SETTLEMENT_U");
    values.push_back("TEMPERATURE_T");
    values.push_back("EARTHQUAKE_E");
    values.push_back("FIRE");
    values.push_back("IMPULSE");
    values.push_back("IMPACT");
    values.push_back("TRANSPORT");
    values.push_back("ERECTION");
    values.push_back("PROPPING");
    values.push_back("SYSTEM_IMPERFECTION");
    values.push_back("SHRINKAGE");
    values.push_back("CREEP");
    values.push_back("LACK_OF_FIT");
    values.push_back("BUOYANCY");
    values.push_back("ICE");
    values.push_back("CURRENT");
    values.push_back("WAVE");
    values.push_back("RAIN");
    values.push_back("BRAKES");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcActionSourceTypeEnum] = new IfcEnumerationDescriptor(Type::IfcActionSourceTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("PERMANENT_G");
    values.push_back("VARIABLE_Q");
    values.push_back("EXTRAORDINARY_A");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcActionTypeEnum] = new IfcEnumerationDescriptor(Type::IfcActionTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("ELECTRICACTUATOR");
    values.push_back("HANDOPERATEDACTUATOR");
    values.push_back("HYDRAULICACTUATOR");
    values.push_back("PNEUMATICACTUATOR");
    values.push_back("THERMOSTATICACTUATOR");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcActuatorTypeEnum] = new IfcEnumerationDescriptor(Type::IfcActuatorTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("OFFICE");
    values.push_back("SITE");
    values.push_back("HOME");
    values.push_back("DISTRIBUTIONPOINT");
    values.push_back("USERDEFINED");
    enumeration_descriptor_map[Type::IfcAddressTypeEnum] = new IfcEnumerationDescriptor(Type::IfcAddressTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("CONSTANTFLOW");
    values.push_back("VARIABLEFLOWPRESSUREDEPENDANT");
    values.push_back("VARIABLEFLOWPRESSUREINDEPENDANT");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcAirTerminalBoxTypeEnum] = new IfcEnumerationDescriptor(Type::IfcAirTerminalBoxTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("DIFFUSER");
    values.push_back("GRILLE");
    values.push_back("LOUVRE");
    values.push_back("REGISTER");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcAirTerminalTypeEnum] = new IfcEnumerationDescriptor(Type::IfcAirTerminalTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("FIXEDPLATECOUNTERFLOWEXCHANGER");
    values.push_back("FIXEDPLATECROSSFLOWEXCHANGER");
    values.push_back("FIXEDPLATEPARALLELFLOWEXCHANGER");
    values.push_back("ROTARYWHEEL");
    values.push_back("RUNAROUNDCOILLOOP");
    values.push_back("HEATPIPE");
    values.push_back("TWINTOWERENTHALPYRECOVERYLOOPS");
    values.push_back("THERMOSIPHONSEALEDTUBEHEATEXCHANGERS");
    values.push_back("THERMOSIPHONCOILTYPEHEATEXCHANGERS");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcAirToAirHeatRecoveryTypeEnum] = new IfcEnumerationDescriptor(Type::IfcAirToAirHeatRecoveryTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("BELL");
    values.push_back("BREAKGLASSBUTTON");
    values.push_back("LIGHT");
    values.push_back("MANUALPULLBOX");
    values.push_back("SIREN");
    values.push_back("WHISTLE");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcAlarmTypeEnum] = new IfcEnumerationDescriptor(Type::IfcAlarmTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("IN_PLANE_LOADING_2D");
    values.push_back("OUT_PLANE_LOADING_2D");
    values.push_back("LOADING_3D");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcAnalysisModelTypeEnum] = new IfcEnumerationDescriptor(Type::IfcAnalysisModelTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("FIRST_ORDER_THEORY");
    values.push_back("SECOND_ORDER_THEORY");
    values.push_back("THIRD_ORDER_THEORY");
    values.push_back("FULL_NONLINEAR_THEORY");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcAnalysisTheoryTypeEnum] = new IfcEnumerationDescriptor(Type::IfcAnalysisTheoryTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("ADD");
    values.push_back("DIVIDE");
    values.push_back("MULTIPLY");
    values.push_back("SUBTRACT");
    enumeration_descriptor_map[Type::IfcArithmeticOperatorEnum] = new IfcEnumerationDescriptor(Type::IfcArithmeticOperatorEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("SITE");
    values.push_back("FACTORY");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcAssemblyPlaceEnum] = new IfcEnumerationDescriptor(Type::IfcAssemblyPlaceEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("AMPLIFIER");
    values.push_back("CAMERA");
    values.push_back("DISPLAY");
    values.push_back("MICROPHONE");
    values.push_back("PLAYER");
    values.push_back("PROJECTOR");
    values.push_back("RECEIVER");
    values.push_back("SPEAKER");
    values.push_back("SWITCHER");
    values.push_back("TELEPHONE");
    values.push_back("TUNER");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcAudioVisualApplianceTypeEnum] = new IfcEnumerationDescriptor(Type::IfcAudioVisualApplianceTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("POLYLINE_FORM");
    values.push_back("CIRCULAR_ARC");
    values.push_back("ELLIPTIC_ARC");
    values.push_back("PARABOLIC_ARC");
    values.push_back("HYPERBOLIC_ARC");
    values.push_back("UNSPECIFIED");
    enumeration_descriptor_map[Type::IfcBSplineCurveForm] = new IfcEnumerationDescriptor(Type::IfcBSplineCurveForm, values);
    values.clear(); values.reserve(128);
    values.push_back("PLANE_SURF");
    values.push_back("CYLINDRICAL_SURF");
    values.push_back("CONICAL_SURF");
    values.push_back("SPHERICAL_SURF");
    values.push_back("TOROIDAL_SURF");
    values.push_back("SURF_OF_REVOLUTION");
    values.push_back("RULED_SURF");
    values.push_back("GENERALISED_CONE");
    values.push_back("QUADRIC_SURF");
    values.push_back("SURF_OF_LINEAR_EXTRUSION");
    values.push_back("UNSPECIFIED");
    enumeration_descriptor_map[Type::IfcBSplineSurfaceForm] = new IfcEnumerationDescriptor(Type::IfcBSplineSurfaceForm, values);
    values.clear(); values.reserve(128);
    values.push_back("BEAM");
    values.push_back("JOIST");
    values.push_back("HOLLOWCORE");
    values.push_back("LINTEL");
    values.push_back("SPANDREL");
    values.push_back("T_BEAM");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcBeamTypeEnum] = new IfcEnumerationDescriptor(Type::IfcBeamTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("GREATERTHAN");
    values.push_back("GREATERTHANOREQUALTO");
    values.push_back("LESSTHAN");
    values.push_back("LESSTHANOREQUALTO");
    values.push_back("EQUALTO");
    values.push_back("NOTEQUALTO");
    values.push_back("INCLUDES");
    values.push_back("NOTINCLUDES");
    values.push_back("INCLUDEDIN");
    values.push_back("NOTINCLUDEDIN");
    enumeration_descriptor_map[Type::IfcBenchmarkEnum] = new IfcEnumerationDescriptor(Type::IfcBenchmarkEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("WATER");
    values.push_back("STEAM");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcBoilerTypeEnum] = new IfcEnumerationDescriptor(Type::IfcBoilerTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("UNION");
    values.push_back("INTERSECTION");
    values.push_back("DIFFERENCE");
    enumeration_descriptor_map[Type::IfcBooleanOperator] = new IfcEnumerationDescriptor(Type::IfcBooleanOperator, values);
    values.clear(); values.reserve(128);
    values.push_back("INSULATION");
    values.push_back("PRECASTPANEL");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcBuildingElementPartTypeEnum] = new IfcEnumerationDescriptor(Type::IfcBuildingElementPartTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("COMPLEX");
    values.push_back("ELEMENT");
    values.push_back("PARTIAL");
    values.push_back("PROVISIONFORVOID");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcBuildingElementProxyTypeEnum] = new IfcEnumerationDescriptor(Type::IfcBuildingElementProxyTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("FENESTRATION");
    values.push_back("FOUNDATION");
    values.push_back("LOADBEARING");
    values.push_back("OUTERSHELL");
    values.push_back("SHADING");
    values.push_back("TRANSPORT");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcBuildingSystemTypeEnum] = new IfcEnumerationDescriptor(Type::IfcBuildingSystemTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcBurnerTypeEnum] = new IfcEnumerationDescriptor(Type::IfcBurnerTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("BEND");
    values.push_back("CROSS");
    values.push_back("REDUCER");
    values.push_back("TEE");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcCableCarrierFittingTypeEnum] = new IfcEnumerationDescriptor(Type::IfcCableCarrierFittingTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("CABLELADDERSEGMENT");
    values.push_back("CABLETRAYSEGMENT");
    values.push_back("CABLETRUNKINGSEGMENT");
    values.push_back("CONDUITSEGMENT");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcCableCarrierSegmentTypeEnum] = new IfcEnumerationDescriptor(Type::IfcCableCarrierSegmentTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("CONNECTOR");
    values.push_back("ENTRY");
    values.push_back("EXIT");
    values.push_back("JUNCTION");
    values.push_back("TRANSITION");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcCableFittingTypeEnum] = new IfcEnumerationDescriptor(Type::IfcCableFittingTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("BUSBARSEGMENT");
    values.push_back("CABLESEGMENT");
    values.push_back("CONDUCTORSEGMENT");
    values.push_back("CORESEGMENT");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcCableSegmentTypeEnum] = new IfcEnumerationDescriptor(Type::IfcCableSegmentTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("NOCHANGE");
    values.push_back("MODIFIED");
    values.push_back("ADDED");
    values.push_back("DELETED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcChangeActionEnum] = new IfcEnumerationDescriptor(Type::IfcChangeActionEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("AIRCOOLED");
    values.push_back("WATERCOOLED");
    values.push_back("HEATRECOVERY");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcChillerTypeEnum] = new IfcEnumerationDescriptor(Type::IfcChillerTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcChimneyTypeEnum] = new IfcEnumerationDescriptor(Type::IfcChimneyTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("DXCOOLINGCOIL");
    values.push_back("ELECTRICHEATINGCOIL");
    values.push_back("GASHEATINGCOIL");
    values.push_back("HYDRONICCOIL");
    values.push_back("STEAMHEATINGCOIL");
    values.push_back("WATERCOOLINGCOIL");
    values.push_back("WATERHEATINGCOIL");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcCoilTypeEnum] = new IfcEnumerationDescriptor(Type::IfcCoilTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("COLUMN");
    values.push_back("PILASTER");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcColumnTypeEnum] = new IfcEnumerationDescriptor(Type::IfcColumnTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("ANTENNA");
    values.push_back("COMPUTER");
    values.push_back("FAX");
    values.push_back("GATEWAY");
    values.push_back("MODEM");
    values.push_back("NETWORKAPPLIANCE");
    values.push_back("NETWORKBRIDGE");
    values.push_back("NETWORKHUB");
    values.push_back("PRINTER");
    values.push_back("REPEATER");
    values.push_back("ROUTER");
    values.push_back("SCANNER");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcCommunicationsApplianceTypeEnum] = new IfcEnumerationDescriptor(Type::IfcCommunicationsApplianceTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("P_COMPLEX");
    values.push_back("Q_COMPLEX");
    enumeration_descriptor_map[Type::IfcComplexPropertyTemplateTypeEnum] = new IfcEnumerationDescriptor(Type::IfcComplexPropertyTemplateTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("DYNAMIC");
    values.push_back("RECIPROCATING");
    values.push_back("ROTARY");
    values.push_back("SCROLL");
    values.push_back("TROCHOIDAL");
    values.push_back("SINGLESTAGE");
    values.push_back("BOOSTER");
    values.push_back("OPENTYPE");
    values.push_back("HERMETIC");
    values.push_back("SEMIHERMETIC");
    values.push_back("WELDEDSHELLHERMETIC");
    values.push_back("ROLLINGPISTON");
    values.push_back("ROTARYVANE");
    values.push_back("SINGLESCREW");
    values.push_back("TWINSCREW");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcCompressorTypeEnum] = new IfcEnumerationDescriptor(Type::IfcCompressorTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("AIRCOOLED");
    values.push_back("EVAPORATIVECOOLED");
    values.push_back("WATERCOOLED");
    values.push_back("WATERCOOLEDBRAZEDPLATE");
    values.push_back("WATERCOOLEDSHELLCOIL");
    values.push_back("WATERCOOLEDSHELLTUBE");
    values.push_back("WATERCOOLEDTUBEINTUBE");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcCondenserTypeEnum] = new IfcEnumerationDescriptor(Type::IfcCondenserTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("ATPATH");
    values.push_back("ATSTART");
    values.push_back("ATEND");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcConnectionTypeEnum] = new IfcEnumerationDescriptor(Type::IfcConnectionTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("HARD");
    values.push_back("SOFT");
    values.push_back("ADVISORY");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcConstraintEnum] = new IfcEnumerationDescriptor(Type::IfcConstraintEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("DEMOLISHING");
    values.push_back("EARTHMOVING");
    values.push_back("ERECTING");
    values.push_back("HEATING");
    values.push_back("LIGHTING");
    values.push_back("PAVING");
    values.push_back("PUMPING");
    values.push_back("TRANSPORTING");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcConstructionEquipmentResourceTypeEnum] = new IfcEnumerationDescriptor(Type::IfcConstructionEquipmentResourceTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("AGGREGATES");
    values.push_back("CONCRETE");
    values.push_back("DRYWALL");
    values.push_back("FUEL");
    values.push_back("GYPSUM");
    values.push_back("MASONRY");
    values.push_back("METAL");
    values.push_back("PLASTIC");
    values.push_back("WOOD");
    values.push_back("NOTDEFINED");
    values.push_back("USERDEFINED");
    enumeration_descriptor_map[Type::IfcConstructionMaterialResourceTypeEnum] = new IfcEnumerationDescriptor(Type::IfcConstructionMaterialResourceTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("ASSEMBLY");
    values.push_back("FORMWORK");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcConstructionProductResourceTypeEnum] = new IfcEnumerationDescriptor(Type::IfcConstructionProductResourceTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("FLOATING");
    values.push_back("PROGRAMMABLE");
    values.push_back("PROPORTIONAL");
    values.push_back("MULTIPOSITION");
    values.push_back("TWOPOSITION");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcControllerTypeEnum] = new IfcEnumerationDescriptor(Type::IfcControllerTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("ACTIVE");
    values.push_back("PASSIVE");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcCooledBeamTypeEnum] = new IfcEnumerationDescriptor(Type::IfcCooledBeamTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("NATURALDRAFT");
    values.push_back("MECHANICALINDUCEDDRAFT");
    values.push_back("MECHANICALFORCEDDRAFT");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcCoolingTowerTypeEnum] = new IfcEnumerationDescriptor(Type::IfcCoolingTowerTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcCostItemTypeEnum] = new IfcEnumerationDescriptor(Type::IfcCostItemTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("BUDGET");
    values.push_back("COSTPLAN");
    values.push_back("ESTIMATE");
    values.push_back("TENDER");
    values.push_back("PRICEDBILLOFQUANTITIES");
    values.push_back("UNPRICEDBILLOFQUANTITIES");
    values.push_back("SCHEDULEOFRATES");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcCostScheduleTypeEnum] = new IfcEnumerationDescriptor(Type::IfcCostScheduleTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("CEILING");
    values.push_back("FLOORING");
    values.push_back("CLADDING");
    values.push_back("ROOFING");
    values.push_back("MOLDING");
    values.push_back("SKIRTINGBOARD");
    values.push_back("INSULATION");
    values.push_back("MEMBRANE");
    values.push_back("SLEEVING");
    values.push_back("WRAPPING");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcCoveringTypeEnum] = new IfcEnumerationDescriptor(Type::IfcCoveringTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("OFFICE");
    values.push_back("SITE");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcCrewResourceTypeEnum] = new IfcEnumerationDescriptor(Type::IfcCrewResourceTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcCurtainWallTypeEnum] = new IfcEnumerationDescriptor(Type::IfcCurtainWallTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("LINEAR");
    values.push_back("LOG_LINEAR");
    values.push_back("LOG_LOG");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcCurveInterpolationEnum] = new IfcEnumerationDescriptor(Type::IfcCurveInterpolationEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("BACKDRAFTDAMPER");
    values.push_back("BALANCINGDAMPER");
    values.push_back("BLASTDAMPER");
    values.push_back("CONTROLDAMPER");
    values.push_back("FIREDAMPER");
    values.push_back("FIRESMOKEDAMPER");
    values.push_back("FUMEHOODEXHAUST");
    values.push_back("GRAVITYDAMPER");
    values.push_back("GRAVITYRELIEFDAMPER");
    values.push_back("RELIEFDAMPER");
    values.push_back("SMOKEDAMPER");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcDamperTypeEnum] = new IfcEnumerationDescriptor(Type::IfcDamperTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("MEASURED");
    values.push_back("PREDICTED");
    values.push_back("SIMULATED");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcDataOriginEnum] = new IfcEnumerationDescriptor(Type::IfcDataOriginEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("ANGULARVELOCITYUNIT");
    values.push_back("AREADENSITYUNIT");
    values.push_back("COMPOUNDPLANEANGLEUNIT");
    values.push_back("DYNAMICVISCOSITYUNIT");
    values.push_back("HEATFLUXDENSITYUNIT");
    values.push_back("INTEGERCOUNTRATEUNIT");
    values.push_back("ISOTHERMALMOISTURECAPACITYUNIT");
    values.push_back("KINEMATICVISCOSITYUNIT");
    values.push_back("LINEARVELOCITYUNIT");
    values.push_back("MASSDENSITYUNIT");
    values.push_back("MASSFLOWRATEUNIT");
    values.push_back("MOISTUREDIFFUSIVITYUNIT");
    values.push_back("MOLECULARWEIGHTUNIT");
    values.push_back("SPECIFICHEATCAPACITYUNIT");
    values.push_back("THERMALADMITTANCEUNIT");
    values.push_back("THERMALCONDUCTANCEUNIT");
    values.push_back("THERMALRESISTANCEUNIT");
    values.push_back("THERMALTRANSMITTANCEUNIT");
    values.push_back("VAPORPERMEABILITYUNIT");
    values.push_back("VOLUMETRICFLOWRATEUNIT");
    values.push_back("ROTATIONALFREQUENCYUNIT");
    values.push_back("TORQUEUNIT");
    values.push_back("MOMENTOFINERTIAUNIT");
    values.push_back("LINEARMOMENTUNIT");
    values.push_back("LINEARFORCEUNIT");
    values.push_back("PLANARFORCEUNIT");
    values.push_back("MODULUSOFELASTICITYUNIT");
    values.push_back("SHEARMODULUSUNIT");
    values.push_back("LINEARSTIFFNESSUNIT");
    values.push_back("ROTATIONALSTIFFNESSUNIT");
    values.push_back("MODULUSOFSUBGRADEREACTIONUNIT");
    values.push_back("ACCELERATIONUNIT");
    values.push_back("CURVATUREUNIT");
    values.push_back("HEATINGVALUEUNIT");
    values.push_back("IONCONCENTRATIONUNIT");
    values.push_back("LUMINOUSINTENSITYDISTRIBUTIONUNIT");
    values.push_back("MASSPERLENGTHUNIT");
    values.push_back("MODULUSOFLINEARSUBGRADEREACTIONUNIT");
    values.push_back("MODULUSOFROTATIONALSUBGRADEREACTIONUNIT");
    values.push_back("PHUNIT");
    values.push_back("ROTATIONALMASSUNIT");
    values.push_back("SECTIONAREAINTEGRALUNIT");
    values.push_back("SECTIONMODULUSUNIT");
    values.push_back("SOUNDPOWERLEVELUNIT");
    values.push_back("SOUNDPOWERUNIT");
    values.push_back("SOUNDPRESSURELEVELUNIT");
    values.push_back("SOUNDPRESSUREUNIT");
    values.push_back("TEMPERATUREGRADIENTUNIT");
    values.push_back("TEMPERATURERATEOFCHANGEUNIT");
    values.push_back("THERMALEXPANSIONCOEFFICIENTUNIT");
    values.push_back("WARPINGCONSTANTUNIT");
    values.push_back("WARPINGMOMENTUNIT");
    values.push_back("USERDEFINED");
    enumeration_descriptor_map[Type::IfcDerivedUnitEnum] = new IfcEnumerationDescriptor(Type::IfcDerivedUnitEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("POSITIVE");
    values.push_back("NEGATIVE");
    enumeration_descriptor_map[Type::IfcDirectionSenseEnum] = new IfcEnumerationDescriptor(Type::IfcDirectionSenseEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("ANCHORPLATE");
    values.push_back("BRACKET");
    values.push_back("SHOE");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcDiscreteAccessoryTypeEnum] = new IfcEnumerationDescriptor(Type::IfcDiscreteAccessoryTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("FORMEDDUCT");
    values.push_back("INSPECTIONCHAMBER");
    values.push_back("INSPECTIONPIT");
    values.push_back("MANHOLE");
    values.push_back("METERCHAMBER");
    values.push_back("SUMP");
    values.push_back("TRENCH");
    values.push_back("VALVECHAMBER");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcDistributionChamberElementTypeEnum] = new IfcEnumerationDescriptor(Type::IfcDistributionChamberElementTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("CABLE");
    values.push_back("CABLECARRIER");
    values.push_back("DUCT");
    values.push_back("PIPE");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcDistributionPortTypeEnum] = new IfcEnumerationDescriptor(Type::IfcDistributionPortTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("AIRCONDITIONING");
    values.push_back("AUDIOVISUAL");
    values.push_back("CHEMICAL");
    values.push_back("CHILLEDWATER");
    values.push_back("COMMUNICATION");
    values.push_back("COMPRESSEDAIR");
    values.push_back("CONDENSERWATER");
    values.push_back("CONTROL");
    values.push_back("CONVEYING");
    values.push_back("DATA");
    values.push_back("DISPOSAL");
    values.push_back("DOMESTICCOLDWATER");
    values.push_back("DOMESTICHOTWATER");
    values.push_back("DRAINAGE");
    values.push_back("EARTHING");
    values.push_back("ELECTRICAL");
    values.push_back("ELECTROACOUSTIC");
    values.push_back("EXHAUST");
    values.push_back("FIREPROTECTION");
    values.push_back("FUEL");
    values.push_back("GAS");
    values.push_back("HAZARDOUS");
    values.push_back("HEATING");
    values.push_back("LIGHTING");
    values.push_back("LIGHTNINGPROTECTION");
    values.push_back("MUNICIPALSOLIDWASTE");
    values.push_back("OIL");
    values.push_back("OPERATIONAL");
    values.push_back("POWERGENERATION");
    values.push_back("RAINWATER");
    values.push_back("REFRIGERATION");
    values.push_back("SECURITY");
    values.push_back("SEWAGE");
    values.push_back("SIGNAL");
    values.push_back("STORMWATER");
    values.push_back("TELEPHONE");
    values.push_back("TV");
    values.push_back("VACUUM");
    values.push_back("VENT");
    values.push_back("VENTILATION");
    values.push_back("WASTEWATER");
    values.push_back("WATERSUPPLY");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcDistributionSystemEnum] = new IfcEnumerationDescriptor(Type::IfcDistributionSystemEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("PUBLIC");
    values.push_back("RESTRICTED");
    values.push_back("CONFIDENTIAL");
    values.push_back("PERSONAL");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcDocumentConfidentialityEnum] = new IfcEnumerationDescriptor(Type::IfcDocumentConfidentialityEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("DRAFT");
    values.push_back("FINALDRAFT");
    values.push_back("FINAL");
    values.push_back("REVISION");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcDocumentStatusEnum] = new IfcEnumerationDescriptor(Type::IfcDocumentStatusEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("SWINGING");
    values.push_back("DOUBLE_ACTING");
    values.push_back("SLIDING");
    values.push_back("FOLDING");
    values.push_back("REVOLVING");
    values.push_back("ROLLINGUP");
    values.push_back("FIXEDPANEL");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcDoorPanelOperationEnum] = new IfcEnumerationDescriptor(Type::IfcDoorPanelOperationEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("LEFT");
    values.push_back("MIDDLE");
    values.push_back("RIGHT");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcDoorPanelPositionEnum] = new IfcEnumerationDescriptor(Type::IfcDoorPanelPositionEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("ALUMINIUM");
    values.push_back("HIGH_GRADE_STEEL");
    values.push_back("STEEL");
    values.push_back("WOOD");
    values.push_back("ALUMINIUM_WOOD");
    values.push_back("ALUMINIUM_PLASTIC");
    values.push_back("PLASTIC");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcDoorStyleConstructionEnum] = new IfcEnumerationDescriptor(Type::IfcDoorStyleConstructionEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("SINGLE_SWING_LEFT");
    values.push_back("SINGLE_SWING_RIGHT");
    values.push_back("DOUBLE_DOOR_SINGLE_SWING");
    values.push_back("DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_LEFT");
    values.push_back("DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_RIGHT");
    values.push_back("DOUBLE_SWING_LEFT");
    values.push_back("DOUBLE_SWING_RIGHT");
    values.push_back("DOUBLE_DOOR_DOUBLE_SWING");
    values.push_back("SLIDING_TO_LEFT");
    values.push_back("SLIDING_TO_RIGHT");
    values.push_back("DOUBLE_DOOR_SLIDING");
    values.push_back("FOLDING_TO_LEFT");
    values.push_back("FOLDING_TO_RIGHT");
    values.push_back("DOUBLE_DOOR_FOLDING");
    values.push_back("REVOLVING");
    values.push_back("ROLLINGUP");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcDoorStyleOperationEnum] = new IfcEnumerationDescriptor(Type::IfcDoorStyleOperationEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("DOOR");
    values.push_back("GATE");
    values.push_back("TRAPDOOR");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcDoorTypeEnum] = new IfcEnumerationDescriptor(Type::IfcDoorTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("SINGLE_SWING_LEFT");
    values.push_back("SINGLE_SWING_RIGHT");
    values.push_back("DOUBLE_DOOR_SINGLE_SWING");
    values.push_back("DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_LEFT");
    values.push_back("DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_RIGHT");
    values.push_back("DOUBLE_SWING_LEFT");
    values.push_back("DOUBLE_SWING_RIGHT");
    values.push_back("DOUBLE_DOOR_DOUBLE_SWING");
    values.push_back("SLIDING_TO_LEFT");
    values.push_back("SLIDING_TO_RIGHT");
    values.push_back("DOUBLE_DOOR_SLIDING");
    values.push_back("FOLDING_TO_LEFT");
    values.push_back("FOLDING_TO_RIGHT");
    values.push_back("DOUBLE_DOOR_FOLDING");
    values.push_back("REVOLVING");
    values.push_back("ROLLINGUP");
    values.push_back("SWING_FIXED_LEFT");
    values.push_back("SWING_FIXED_RIGHT");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcDoorTypeOperationEnum] = new IfcEnumerationDescriptor(Type::IfcDoorTypeOperationEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("BEND");
    values.push_back("CONNECTOR");
    values.push_back("ENTRY");
    values.push_back("EXIT");
    values.push_back("JUNCTION");
    values.push_back("OBSTRUCTION");
    values.push_back("TRANSITION");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcDuctFittingTypeEnum] = new IfcEnumerationDescriptor(Type::IfcDuctFittingTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("RIGIDSEGMENT");
    values.push_back("FLEXIBLESEGMENT");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcDuctSegmentTypeEnum] = new IfcEnumerationDescriptor(Type::IfcDuctSegmentTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("FLATOVAL");
    values.push_back("RECTANGULAR");
    values.push_back("ROUND");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcDuctSilencerTypeEnum] = new IfcEnumerationDescriptor(Type::IfcDuctSilencerTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("DISHWASHER");
    values.push_back("ELECTRICCOOKER");
    values.push_back("FREESTANDINGELECTRICHEATER");
    values.push_back("FREESTANDINGFAN");
    values.push_back("FREESTANDINGWATERHEATER");
    values.push_back("FREESTANDINGWATERCOOLER");
    values.push_back("FREEZER");
    values.push_back("FRIDGE_FREEZER");
    values.push_back("HANDDRYER");
    values.push_back("KITCHENMACHINE");
    values.push_back("MICROWAVE");
    values.push_back("PHOTOCOPIER");
    values.push_back("REFRIGERATOR");
    values.push_back("TUMBLEDRYER");
    values.push_back("VENDINGMACHINE");
    values.push_back("WASHINGMACHINE");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcElectricApplianceTypeEnum] = new IfcEnumerationDescriptor(Type::IfcElectricApplianceTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("CONSUMERUNIT");
    values.push_back("DISTRIBUTIONBOARD");
    values.push_back("MOTORCONTROLCENTRE");
    values.push_back("SWITCHBOARD");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcElectricDistributionBoardTypeEnum] = new IfcEnumerationDescriptor(Type::IfcElectricDistributionBoardTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("BATTERY");
    values.push_back("CAPACITORBANK");
    values.push_back("HARMONICFILTER");
    values.push_back("INDUCTORBANK");
    values.push_back("UPS");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcElectricFlowStorageDeviceTypeEnum] = new IfcEnumerationDescriptor(Type::IfcElectricFlowStorageDeviceTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("CHP");
    values.push_back("ENGINEGENERATOR");
    values.push_back("STANDALONE");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcElectricGeneratorTypeEnum] = new IfcEnumerationDescriptor(Type::IfcElectricGeneratorTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("DC");
    values.push_back("INDUCTION");
    values.push_back("POLYPHASE");
    values.push_back("RELUCTANCESYNCHRONOUS");
    values.push_back("SYNCHRONOUS");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcElectricMotorTypeEnum] = new IfcEnumerationDescriptor(Type::IfcElectricMotorTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("TIMECLOCK");
    values.push_back("TIMEDELAY");
    values.push_back("RELAY");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcElectricTimeControlTypeEnum] = new IfcEnumerationDescriptor(Type::IfcElectricTimeControlTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("ACCESSORY_ASSEMBLY");
    values.push_back("ARCH");
    values.push_back("BEAM_GRID");
    values.push_back("BRACED_FRAME");
    values.push_back("GIRDER");
    values.push_back("REINFORCEMENT_UNIT");
    values.push_back("RIGID_FRAME");
    values.push_back("SLAB_FIELD");
    values.push_back("TRUSS");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcElementAssemblyTypeEnum] = new IfcEnumerationDescriptor(Type::IfcElementAssemblyTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("COMPLEX");
    values.push_back("ELEMENT");
    values.push_back("PARTIAL");
    enumeration_descriptor_map[Type::IfcElementCompositionEnum] = new IfcEnumerationDescriptor(Type::IfcElementCompositionEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("EXTERNALCOMBUSTION");
    values.push_back("INTERNALCOMBUSTION");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcEngineTypeEnum] = new IfcEnumerationDescriptor(Type::IfcEngineTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("DIRECTEVAPORATIVERANDOMMEDIAAIRCOOLER");
    values.push_back("DIRECTEVAPORATIVERIGIDMEDIAAIRCOOLER");
    values.push_back("DIRECTEVAPORATIVESLINGERSPACKAGEDAIRCOOLER");
    values.push_back("DIRECTEVAPORATIVEPACKAGEDROTARYAIRCOOLER");
    values.push_back("DIRECTEVAPORATIVEAIRWASHER");
    values.push_back("INDIRECTEVAPORATIVEPACKAGEAIRCOOLER");
    values.push_back("INDIRECTEVAPORATIVEWETCOIL");
    values.push_back("INDIRECTEVAPORATIVECOOLINGTOWERORCOILCOOLER");
    values.push_back("INDIRECTDIRECTCOMBINATION");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcEvaporativeCoolerTypeEnum] = new IfcEnumerationDescriptor(Type::IfcEvaporativeCoolerTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("DIRECTEXPANSION");
    values.push_back("DIRECTEXPANSIONSHELLANDTUBE");
    values.push_back("DIRECTEXPANSIONTUBEINTUBE");
    values.push_back("DIRECTEXPANSIONBRAZEDPLATE");
    values.push_back("FLOODEDSHELLANDTUBE");
    values.push_back("SHELLANDCOIL");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcEvaporatorTypeEnum] = new IfcEnumerationDescriptor(Type::IfcEvaporatorTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("EVENTRULE");
    values.push_back("EVENTMESSAGE");
    values.push_back("EVENTTIME");
    values.push_back("EVENTCOMPLEX");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcEventTriggerTypeEnum] = new IfcEnumerationDescriptor(Type::IfcEventTriggerTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("STARTEVENT");
    values.push_back("ENDEVENT");
    values.push_back("INTERMEDIATEEVENT");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcEventTypeEnum] = new IfcEnumerationDescriptor(Type::IfcEventTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("EXTERNAL");
    values.push_back("EXTERNAL_EARTH");
    values.push_back("EXTERNAL_WATER");
    values.push_back("EXTERNAL_FIRE");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFIEND");
    enumeration_descriptor_map[Type::IfcExternalSpatialElementTypeEnum] = new IfcEnumerationDescriptor(Type::IfcExternalSpatialElementTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("CENTRIFUGALFORWARDCURVED");
    values.push_back("CENTRIFUGALRADIAL");
    values.push_back("CENTRIFUGALBACKWARDINCLINEDCURVED");
    values.push_back("CENTRIFUGALAIRFOIL");
    values.push_back("TUBEAXIAL");
    values.push_back("VANEAXIAL");
    values.push_back("PROPELLORAXIAL");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcFanTypeEnum] = new IfcEnumerationDescriptor(Type::IfcFanTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("GLUE");
    values.push_back("MORTAR");
    values.push_back("WELD");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcFastenerTypeEnum] = new IfcEnumerationDescriptor(Type::IfcFastenerTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("AIRPARTICLEFILTER");
    values.push_back("COMPRESSEDAIRFILTER");
    values.push_back("ODORFILTER");
    values.push_back("OILFILTER");
    values.push_back("STRAINER");
    values.push_back("WATERFILTER");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcFilterTypeEnum] = new IfcEnumerationDescriptor(Type::IfcFilterTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("BREECHINGINLET");
    values.push_back("FIREHYDRANT");
    values.push_back("HOSEREEL");
    values.push_back("SPRINKLER");
    values.push_back("SPRINKLERDEFLECTOR");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcFireSuppressionTerminalTypeEnum] = new IfcEnumerationDescriptor(Type::IfcFireSuppressionTerminalTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("SOURCE");
    values.push_back("SINK");
    values.push_back("SOURCEANDSINK");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcFlowDirectionEnum] = new IfcEnumerationDescriptor(Type::IfcFlowDirectionEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("PRESSUREGAUGE");
    values.push_back("THERMOMETER");
    values.push_back("AMMETER");
    values.push_back("FREQUENCYMETER");
    values.push_back("POWERFACTORMETER");
    values.push_back("PHASEANGLEMETER");
    values.push_back("VOLTMETER_PEAK");
    values.push_back("VOLTMETER_RMS");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcFlowInstrumentTypeEnum] = new IfcEnumerationDescriptor(Type::IfcFlowInstrumentTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("ENERGYMETER");
    values.push_back("GASMETER");
    values.push_back("OILMETER");
    values.push_back("WATERMETER");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcFlowMeterTypeEnum] = new IfcEnumerationDescriptor(Type::IfcFlowMeterTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("CAISSON_FOUNDATION");
    values.push_back("FOOTING_BEAM");
    values.push_back("PAD_FOOTING");
    values.push_back("PILE_CAP");
    values.push_back("STRIP_FOOTING");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcFootingTypeEnum] = new IfcEnumerationDescriptor(Type::IfcFootingTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("CHAIR");
    values.push_back("TABLE");
    values.push_back("DESK");
    values.push_back("BED");
    values.push_back("FILECABINET");
    values.push_back("SHELF");
    values.push_back("SOFA");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcFurnitureTypeEnum] = new IfcEnumerationDescriptor(Type::IfcFurnitureTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("TERRAIN");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcGeographicElementTypeEnum] = new IfcEnumerationDescriptor(Type::IfcGeographicElementTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("GRAPH_VIEW");
    values.push_back("SKETCH_VIEW");
    values.push_back("MODEL_VIEW");
    values.push_back("PLAN_VIEW");
    values.push_back("REFLECTED_PLAN_VIEW");
    values.push_back("SECTION_VIEW");
    values.push_back("ELEVATION_VIEW");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcGeometricProjectionEnum] = new IfcEnumerationDescriptor(Type::IfcGeometricProjectionEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("GLOBAL_COORDS");
    values.push_back("LOCAL_COORDS");
    enumeration_descriptor_map[Type::IfcGlobalOrLocalEnum] = new IfcEnumerationDescriptor(Type::IfcGlobalOrLocalEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("RECTANGULAR");
    values.push_back("RADIAL");
    values.push_back("TRIANGULAR");
    values.push_back("IRREGULAR");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcGridTypeEnum] = new IfcEnumerationDescriptor(Type::IfcGridTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("PLATE");
    values.push_back("SHELLANDTUBE");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcHeatExchangerTypeEnum] = new IfcEnumerationDescriptor(Type::IfcHeatExchangerTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("STEAMINJECTION");
    values.push_back("ADIABATICAIRWASHER");
    values.push_back("ADIABATICPAN");
    values.push_back("ADIABATICWETTEDELEMENT");
    values.push_back("ADIABATICATOMIZING");
    values.push_back("ADIABATICULTRASONIC");
    values.push_back("ADIABATICRIGIDMEDIA");
    values.push_back("ADIABATICCOMPRESSEDAIRNOZZLE");
    values.push_back("ASSISTEDELECTRIC");
    values.push_back("ASSISTEDNATURALGAS");
    values.push_back("ASSISTEDPROPANE");
    values.push_back("ASSISTEDBUTANE");
    values.push_back("ASSISTEDSTEAM");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcHumidifierTypeEnum] = new IfcEnumerationDescriptor(Type::IfcHumidifierTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("CYCLONIC");
    values.push_back("GREASE");
    values.push_back("OIL");
    values.push_back("PETROL");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcInterceptorTypeEnum] = new IfcEnumerationDescriptor(Type::IfcInterceptorTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("INTERNAL");
    values.push_back("EXTERNAL");
    values.push_back("EXTERNAL_EARTH");
    values.push_back("EXTERNAL_WATER");
    values.push_back("EXTERNAL_FIRE");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcInternalOrExternalEnum] = new IfcEnumerationDescriptor(Type::IfcInternalOrExternalEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("ASSETINVENTORY");
    values.push_back("SPACEINVENTORY");
    values.push_back("FURNITUREINVENTORY");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcInventoryTypeEnum] = new IfcEnumerationDescriptor(Type::IfcInventoryTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("DATA");
    values.push_back("POWER");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcJunctionBoxTypeEnum] = new IfcEnumerationDescriptor(Type::IfcJunctionBoxTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("UNIFORM_KNOTS");
    values.push_back("QUASI_UNIFORM_KNOTS");
    values.push_back("PIECEWISE_BEZIER_KNOTS");
    values.push_back("UNSPECIFIED");
    enumeration_descriptor_map[Type::IfcKnotType] = new IfcEnumerationDescriptor(Type::IfcKnotType, values);
    values.clear(); values.reserve(128);
    values.push_back("ADMINISTRATION");
    values.push_back("CARPENTRY");
    values.push_back("CLEANING");
    values.push_back("CONCRETE");
    values.push_back("DRYWALL");
    values.push_back("ELECTRIC");
    values.push_back("FINISHING");
    values.push_back("FLOORING");
    values.push_back("GENERAL");
    values.push_back("HVAC");
    values.push_back("LANDSCAPING");
    values.push_back("MASONRY");
    values.push_back("PAINTING");
    values.push_back("PAVING");
    values.push_back("PLUMBING");
    values.push_back("ROOFING");
    values.push_back("SITEGRADING");
    values.push_back("STEELWORK");
    values.push_back("SURVEYING");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcLaborResourceTypeEnum] = new IfcEnumerationDescriptor(Type::IfcLaborResourceTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("COMPACTFLUORESCENT");
    values.push_back("FLUORESCENT");
    values.push_back("HALOGEN");
    values.push_back("HIGHPRESSUREMERCURY");
    values.push_back("HIGHPRESSURESODIUM");
    values.push_back("LED");
    values.push_back("METALHALIDE");
    values.push_back("OLED");
    values.push_back("TUNGSTENFILAMENT");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcLampTypeEnum] = new IfcEnumerationDescriptor(Type::IfcLampTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("AXIS1");
    values.push_back("AXIS2");
    values.push_back("AXIS3");
    enumeration_descriptor_map[Type::IfcLayerSetDirectionEnum] = new IfcEnumerationDescriptor(Type::IfcLayerSetDirectionEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("TYPE_A");
    values.push_back("TYPE_B");
    values.push_back("TYPE_C");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcLightDistributionCurveEnum] = new IfcEnumerationDescriptor(Type::IfcLightDistributionCurveEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("COMPACTFLUORESCENT");
    values.push_back("FLUORESCENT");
    values.push_back("HIGHPRESSUREMERCURY");
    values.push_back("HIGHPRESSURESODIUM");
    values.push_back("LIGHTEMITTINGDIODE");
    values.push_back("LOWPRESSURESODIUM");
    values.push_back("LOWVOLTAGEHALOGEN");
    values.push_back("MAINVOLTAGEHALOGEN");
    values.push_back("METALHALIDE");
    values.push_back("TUNGSTENFILAMENT");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcLightEmissionSourceEnum] = new IfcEnumerationDescriptor(Type::IfcLightEmissionSourceEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("POINTSOURCE");
    values.push_back("DIRECTIONSOURCE");
    values.push_back("SECURITYLIGHTING");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcLightFixtureTypeEnum] = new IfcEnumerationDescriptor(Type::IfcLightFixtureTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("LOAD_GROUP");
    values.push_back("LOAD_CASE");
    values.push_back("LOAD_COMBINATION");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcLoadGroupTypeEnum] = new IfcEnumerationDescriptor(Type::IfcLoadGroupTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("LOGICALAND");
    values.push_back("LOGICALOR");
    values.push_back("LOGICALXOR");
    values.push_back("LOGICALNOTAND");
    values.push_back("LOGICALNOTOR");
    enumeration_descriptor_map[Type::IfcLogicalOperatorEnum] = new IfcEnumerationDescriptor(Type::IfcLogicalOperatorEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("ANCHORBOLT");
    values.push_back("BOLT");
    values.push_back("DOWEL");
    values.push_back("NAIL");
    values.push_back("NAILPLATE");
    values.push_back("RIVET");
    values.push_back("SCREW");
    values.push_back("SHEARCONNECTOR");
    values.push_back("STAPLE");
    values.push_back("STUDSHEARCONNECTOR");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcMechanicalFastenerTypeEnum] = new IfcEnumerationDescriptor(Type::IfcMechanicalFastenerTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("AIRSTATION");
    values.push_back("FEEDAIRUNIT");
    values.push_back("OXYGENGENERATOR");
    values.push_back("OXYGENPLANT");
    values.push_back("VACUUMSTATION");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcMedicalDeviceTypeEnum] = new IfcEnumerationDescriptor(Type::IfcMedicalDeviceTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("BRACE");
    values.push_back("CHORD");
    values.push_back("COLLAR");
    values.push_back("MEMBER");
    values.push_back("MULLION");
    values.push_back("PLATE");
    values.push_back("POST");
    values.push_back("PURLIN");
    values.push_back("RAFTER");
    values.push_back("STRINGER");
    values.push_back("STRUT");
    values.push_back("STUD");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcMemberTypeEnum] = new IfcEnumerationDescriptor(Type::IfcMemberTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("BELTDRIVE");
    values.push_back("COUPLING");
    values.push_back("DIRECTDRIVE");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcMotorConnectionTypeEnum] = new IfcEnumerationDescriptor(Type::IfcMotorConnectionTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("NULL");
    enumeration_descriptor_map[Type::IfcNullStyle] = new IfcEnumerationDescriptor(Type::IfcNullStyle, values);
    values.clear(); values.reserve(128);
    values.push_back("PRODUCT");
    values.push_back("PROCESS");
    values.push_back("CONTROL");
    values.push_back("RESOURCE");
    values.push_back("ACTOR");
    values.push_back("GROUP");
    values.push_back("PROJECT");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcObjectTypeEnum] = new IfcEnumerationDescriptor(Type::IfcObjectTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("CODECOMPLIANCE");
    values.push_back("CODEWAIVER");
    values.push_back("DESIGNINTENT");
    values.push_back("EXTERNAL");
    values.push_back("HEALTHANDSAFETY");
    values.push_back("MERGECONFLICT");
    values.push_back("MODELVIEW");
    values.push_back("PARAMETER");
    values.push_back("REQUIREMENT");
    values.push_back("SPECIFICATION");
    values.push_back("TRIGGERCONDITION");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcObjectiveEnum] = new IfcEnumerationDescriptor(Type::IfcObjectiveEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("ASSIGNEE");
    values.push_back("ASSIGNOR");
    values.push_back("LESSEE");
    values.push_back("LESSOR");
    values.push_back("LETTINGAGENT");
    values.push_back("OWNER");
    values.push_back("TENANT");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcOccupantTypeEnum] = new IfcEnumerationDescriptor(Type::IfcOccupantTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("OPENING");
    values.push_back("RECESS");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcOpeningElementTypeEnum] = new IfcEnumerationDescriptor(Type::IfcOpeningElementTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("AUDIOVISUALOUTLET");
    values.push_back("COMMUNICATIONSOUTLET");
    values.push_back("POWEROUTLET");
    values.push_back("DATAOUTLET");
    values.push_back("TELEPHONEOUTLET");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcOutletTypeEnum] = new IfcEnumerationDescriptor(Type::IfcOutletTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcPerformanceHistoryTypeEnum] = new IfcEnumerationDescriptor(Type::IfcPerformanceHistoryTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("GRILL");
    values.push_back("LOUVER");
    values.push_back("SCREEN");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcPermeableCoveringOperationEnum] = new IfcEnumerationDescriptor(Type::IfcPermeableCoveringOperationEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("ACCESS");
    values.push_back("BUILDING");
    values.push_back("WORK");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcPermitTypeEnum] = new IfcEnumerationDescriptor(Type::IfcPermitTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("PHYSICAL");
    values.push_back("VIRTUAL");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcPhysicalOrVirtualEnum] = new IfcEnumerationDescriptor(Type::IfcPhysicalOrVirtualEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("CAST_IN_PLACE");
    values.push_back("COMPOSITE");
    values.push_back("PRECAST_CONCRETE");
    values.push_back("PREFAB_STEEL");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcPileConstructionEnum] = new IfcEnumerationDescriptor(Type::IfcPileConstructionEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("BORED");
    values.push_back("DRIVEN");
    values.push_back("JETGROUTING");
    values.push_back("COHESION");
    values.push_back("FRICTION");
    values.push_back("SUPPORT");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcPileTypeEnum] = new IfcEnumerationDescriptor(Type::IfcPileTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("BEND");
    values.push_back("CONNECTOR");
    values.push_back("ENTRY");
    values.push_back("EXIT");
    values.push_back("JUNCTION");
    values.push_back("OBSTRUCTION");
    values.push_back("TRANSITION");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcPipeFittingTypeEnum] = new IfcEnumerationDescriptor(Type::IfcPipeFittingTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("CULVERT");
    values.push_back("FLEXIBLESEGMENT");
    values.push_back("RIGIDSEGMENT");
    values.push_back("GUTTER");
    values.push_back("SPOOL");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcPipeSegmentTypeEnum] = new IfcEnumerationDescriptor(Type::IfcPipeSegmentTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("CURTAIN_PANEL");
    values.push_back("SHEET");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcPlateTypeEnum] = new IfcEnumerationDescriptor(Type::IfcPlateTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("ADVICE_CAUTION");
    values.push_back("ADVICE_NOTE");
    values.push_back("ADVICE_WARNING");
    values.push_back("CALIBRATION");
    values.push_back("DIAGNOSTIC");
    values.push_back("SHUTDOWN");
    values.push_back("STARTUP");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcProcedureTypeEnum] = new IfcEnumerationDescriptor(Type::IfcProcedureTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("CURVE");
    values.push_back("AREA");
    enumeration_descriptor_map[Type::IfcProfileTypeEnum] = new IfcEnumerationDescriptor(Type::IfcProfileTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("CHANGEORDER");
    values.push_back("MAINTENANCEWORKORDER");
    values.push_back("MOVEORDER");
    values.push_back("PURCHASEORDER");
    values.push_back("WORKORDER");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcProjectOrderTypeEnum] = new IfcEnumerationDescriptor(Type::IfcProjectOrderTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("PROJECTED_LENGTH");
    values.push_back("TRUE_LENGTH");
    enumeration_descriptor_map[Type::IfcProjectedOrTrueLengthEnum] = new IfcEnumerationDescriptor(Type::IfcProjectedOrTrueLengthEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcProjectionElementTypeEnum] = new IfcEnumerationDescriptor(Type::IfcProjectionElementTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("PSET_TYPEDRIVENONLY");
    values.push_back("PSET_TYPEDRIVENOVERRIDE");
    values.push_back("PSET_OCCURRENCEDRIVEN");
    values.push_back("PSET_PERFORMANCEDRIVEN");
    values.push_back("QTO_TYPEDRIVENONLY");
    values.push_back("QTO_TYPEDRIVENOVERRIDE");
    values.push_back("QTO_OCCURRENCEDRIVEN");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcPropertySetTemplateTypeEnum] = new IfcEnumerationDescriptor(Type::IfcPropertySetTemplateTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("ELECTRONIC");
    values.push_back("ELECTROMAGNETIC");
    values.push_back("RESIDUALCURRENT");
    values.push_back("THERMAL");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcProtectiveDeviceTrippingUnitTypeEnum] = new IfcEnumerationDescriptor(Type::IfcProtectiveDeviceTrippingUnitTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("CIRCUITBREAKER");
    values.push_back("EARTHLEAKAGECIRCUITBREAKER");
    values.push_back("EARTHINGSWITCH");
    values.push_back("FUSEDISCONNECTOR");
    values.push_back("RESIDUALCURRENTCIRCUITBREAKER");
    values.push_back("RESIDUALCURRENTSWITCH");
    values.push_back("VARISTOR");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcProtectiveDeviceTypeEnum] = new IfcEnumerationDescriptor(Type::IfcProtectiveDeviceTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("CIRCULATOR");
    values.push_back("ENDSUCTION");
    values.push_back("SPLITCASE");
    values.push_back("SUBMERSIBLEPUMP");
    values.push_back("SUMPPUMP");
    values.push_back("VERTICALINLINE");
    values.push_back("VERTICALTURBINE");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcPumpTypeEnum] = new IfcEnumerationDescriptor(Type::IfcPumpTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("HANDRAIL");
    values.push_back("GUARDRAIL");
    values.push_back("BALUSTRADE");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcRailingTypeEnum] = new IfcEnumerationDescriptor(Type::IfcRailingTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("STRAIGHT");
    values.push_back("SPIRAL");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcRampFlightTypeEnum] = new IfcEnumerationDescriptor(Type::IfcRampFlightTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("STRAIGHT_RUN_RAMP");
    values.push_back("TWO_STRAIGHT_RUN_RAMP");
    values.push_back("QUARTER_TURN_RAMP");
    values.push_back("TWO_QUARTER_TURN_RAMP");
    values.push_back("HALF_TURN_RAMP");
    values.push_back("SPIRAL_RAMP");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcRampTypeEnum] = new IfcEnumerationDescriptor(Type::IfcRampTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("DAILY");
    values.push_back("WEEKLY");
    values.push_back("MONTHLY_BY_DAY_OF_MONTH");
    values.push_back("MONTHLY_BY_POSITION");
    values.push_back("BY_DAY_COUNT");
    values.push_back("BY_WEEKDAY_COUNT");
    values.push_back("YEARLY_BY_DAY_OF_MONTH");
    values.push_back("YEARLY_BY_POSITION");
    enumeration_descriptor_map[Type::IfcRecurrenceTypeEnum] = new IfcEnumerationDescriptor(Type::IfcRecurrenceTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("BLINN");
    values.push_back("FLAT");
    values.push_back("GLASS");
    values.push_back("MATT");
    values.push_back("METAL");
    values.push_back("MIRROR");
    values.push_back("PHONG");
    values.push_back("PLASTIC");
    values.push_back("STRAUSS");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcReflectanceMethodEnum] = new IfcEnumerationDescriptor(Type::IfcReflectanceMethodEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("MAIN");
    values.push_back("SHEAR");
    values.push_back("LIGATURE");
    values.push_back("STUD");
    values.push_back("PUNCHING");
    values.push_back("EDGE");
    values.push_back("RING");
    values.push_back("ANCHORING");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcReinforcingBarRoleEnum] = new IfcEnumerationDescriptor(Type::IfcReinforcingBarRoleEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("PLAIN");
    values.push_back("TEXTURED");
    enumeration_descriptor_map[Type::IfcReinforcingBarSurfaceEnum] = new IfcEnumerationDescriptor(Type::IfcReinforcingBarSurfaceEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("ANCHORING");
    values.push_back("EDGE");
    values.push_back("LIGATURE");
    values.push_back("MAIN");
    values.push_back("PUNCHING");
    values.push_back("RING");
    values.push_back("SHEAR");
    values.push_back("STUD");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcReinforcingBarTypeEnum] = new IfcEnumerationDescriptor(Type::IfcReinforcingBarTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcReinforcingMeshTypeEnum] = new IfcEnumerationDescriptor(Type::IfcReinforcingMeshTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("SUPPLIER");
    values.push_back("MANUFACTURER");
    values.push_back("CONTRACTOR");
    values.push_back("SUBCONTRACTOR");
    values.push_back("ARCHITECT");
    values.push_back("STRUCTURALENGINEER");
    values.push_back("COSTENGINEER");
    values.push_back("CLIENT");
    values.push_back("BUILDINGOWNER");
    values.push_back("BUILDINGOPERATOR");
    values.push_back("MECHANICALENGINEER");
    values.push_back("ELECTRICALENGINEER");
    values.push_back("PROJECTMANAGER");
    values.push_back("FACILITIESMANAGER");
    values.push_back("CIVILENGINEER");
    values.push_back("COMMISSIONINGENGINEER");
    values.push_back("ENGINEER");
    values.push_back("OWNER");
    values.push_back("CONSULTANT");
    values.push_back("CONSTRUCTIONMANAGER");
    values.push_back("FIELDCONSTRUCTIONMANAGER");
    values.push_back("RESELLER");
    values.push_back("USERDEFINED");
    enumeration_descriptor_map[Type::IfcRoleEnum] = new IfcEnumerationDescriptor(Type::IfcRoleEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("FLAT_ROOF");
    values.push_back("SHED_ROOF");
    values.push_back("GABLE_ROOF");
    values.push_back("HIP_ROOF");
    values.push_back("HIPPED_GABLE_ROOF");
    values.push_back("GAMBREL_ROOF");
    values.push_back("MANSARD_ROOF");
    values.push_back("BARREL_ROOF");
    values.push_back("RAINBOW_ROOF");
    values.push_back("BUTTERFLY_ROOF");
    values.push_back("PAVILION_ROOF");
    values.push_back("DOME_ROOF");
    values.push_back("FREEFORM");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcRoofTypeEnum] = new IfcEnumerationDescriptor(Type::IfcRoofTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("EXA");
    values.push_back("PETA");
    values.push_back("TERA");
    values.push_back("GIGA");
    values.push_back("MEGA");
    values.push_back("KILO");
    values.push_back("HECTO");
    values.push_back("DECA");
    values.push_back("DECI");
    values.push_back("CENTI");
    values.push_back("MILLI");
    values.push_back("MICRO");
    values.push_back("NANO");
    values.push_back("PICO");
    values.push_back("FEMTO");
    values.push_back("ATTO");
    enumeration_descriptor_map[Type::IfcSIPrefix] = new IfcEnumerationDescriptor(Type::IfcSIPrefix, values);
    values.clear(); values.reserve(128);
    values.push_back("AMPERE");
    values.push_back("BECQUEREL");
    values.push_back("CANDELA");
    values.push_back("COULOMB");
    values.push_back("CUBIC_METRE");
    values.push_back("DEGREE_CELSIUS");
    values.push_back("FARAD");
    values.push_back("GRAM");
    values.push_back("GRAY");
    values.push_back("HENRY");
    values.push_back("HERTZ");
    values.push_back("JOULE");
    values.push_back("KELVIN");
    values.push_back("LUMEN");
    values.push_back("LUX");
    values.push_back("METRE");
    values.push_back("MOLE");
    values.push_back("NEWTON");
    values.push_back("OHM");
    values.push_back("PASCAL");
    values.push_back("RADIAN");
    values.push_back("SECOND");
    values.push_back("SIEMENS");
    values.push_back("SIEVERT");
    values.push_back("SQUARE_METRE");
    values.push_back("STERADIAN");
    values.push_back("TESLA");
    values.push_back("VOLT");
    values.push_back("WATT");
    values.push_back("WEBER");
    enumeration_descriptor_map[Type::IfcSIUnitName] = new IfcEnumerationDescriptor(Type::IfcSIUnitName, values);
    values.clear(); values.reserve(128);
    values.push_back("BATH");
    values.push_back("BIDET");
    values.push_back("CISTERN");
    values.push_back("SHOWER");
    values.push_back("SINK");
    values.push_back("SANITARYFOUNTAIN");
    values.push_back("TOILETPAN");
    values.push_back("URINAL");
    values.push_back("WASHHANDBASIN");
    values.push_back("WCSEAT");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcSanitaryTerminalTypeEnum] = new IfcEnumerationDescriptor(Type::IfcSanitaryTerminalTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("UNIFORM");
    values.push_back("TAPERED");
    enumeration_descriptor_map[Type::IfcSectionTypeEnum] = new IfcEnumerationDescriptor(Type::IfcSectionTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("CO2SENSOR");
    values.push_back("CONDUCTANCESENSOR");
    values.push_back("CONTACTSENSOR");
    values.push_back("FIRESENSOR");
    values.push_back("FLOWSENSOR");
    values.push_back("FROSTSENSOR");
    values.push_back("GASSENSOR");
    values.push_back("HEATSENSOR");
    values.push_back("HUMIDITYSENSOR");
    values.push_back("IDENTIFIERSENSOR");
    values.push_back("IONCONCENTRATIONSENSOR");
    values.push_back("LEVELSENSOR");
    values.push_back("LIGHTSENSOR");
    values.push_back("MOISTURESENSOR");
    values.push_back("MOVEMENTSENSOR");
    values.push_back("PHSENSOR");
    values.push_back("PRESSURESENSOR");
    values.push_back("RADIATIONSENSOR");
    values.push_back("RADIOACTIVITYSENSOR");
    values.push_back("SMOKESENSOR");
    values.push_back("SOUNDSENSOR");
    values.push_back("TEMPERATURESENSOR");
    values.push_back("WINDSENSOR");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcSensorTypeEnum] = new IfcEnumerationDescriptor(Type::IfcSensorTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("START_START");
    values.push_back("START_FINISH");
    values.push_back("FINISH_START");
    values.push_back("FINISH_FINISH");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcSequenceEnum] = new IfcEnumerationDescriptor(Type::IfcSequenceEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("JALOUSIE");
    values.push_back("SHUTTER");
    values.push_back("AWNING");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcShadingDeviceTypeEnum] = new IfcEnumerationDescriptor(Type::IfcShadingDeviceTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("P_SINGLEVALUE");
    values.push_back("P_ENUMERATEDVALUE");
    values.push_back("P_BOUNDEDVALUE");
    values.push_back("P_LISTVALUE");
    values.push_back("P_TABLEVALUE");
    values.push_back("P_REFERENCEVALUE");
    values.push_back("Q_LENGTH");
    values.push_back("Q_AREA");
    values.push_back("Q_VOLUME");
    values.push_back("Q_COUNT");
    values.push_back("Q_WEIGHT");
    values.push_back("Q_TIME");
    enumeration_descriptor_map[Type::IfcSimplePropertyTemplateTypeEnum] = new IfcEnumerationDescriptor(Type::IfcSimplePropertyTemplateTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("FLOOR");
    values.push_back("ROOF");
    values.push_back("LANDING");
    values.push_back("BASESLAB");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcSlabTypeEnum] = new IfcEnumerationDescriptor(Type::IfcSlabTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("SOLARCOLLECTOR");
    values.push_back("SOLARPANEL");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcSolarDeviceTypeEnum] = new IfcEnumerationDescriptor(Type::IfcSolarDeviceTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("CONVECTOR");
    values.push_back("RADIATOR");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcSpaceHeaterTypeEnum] = new IfcEnumerationDescriptor(Type::IfcSpaceHeaterTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("SPACE");
    values.push_back("PARKING");
    values.push_back("GFA");
    values.push_back("INTERNAL");
    values.push_back("EXTERNAL");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcSpaceTypeEnum] = new IfcEnumerationDescriptor(Type::IfcSpaceTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("CONSTRUCTION");
    values.push_back("FIRESAFETY");
    values.push_back("LIGHTING");
    values.push_back("OCCUPANCY");
    values.push_back("SECURITY");
    values.push_back("THERMAL");
    values.push_back("TRANSPORT");
    values.push_back("VENTILATION");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcSpatialZoneTypeEnum] = new IfcEnumerationDescriptor(Type::IfcSpatialZoneTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("BIRDCAGE");
    values.push_back("COWL");
    values.push_back("RAINWATERHOPPER");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcStackTerminalTypeEnum] = new IfcEnumerationDescriptor(Type::IfcStackTerminalTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("STRAIGHT");
    values.push_back("WINDER");
    values.push_back("SPIRAL");
    values.push_back("CURVED");
    values.push_back("FREEFORM");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcStairFlightTypeEnum] = new IfcEnumerationDescriptor(Type::IfcStairFlightTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("STRAIGHT_RUN_STAIR");
    values.push_back("TWO_STRAIGHT_RUN_STAIR");
    values.push_back("QUARTER_WINDING_STAIR");
    values.push_back("QUARTER_TURN_STAIR");
    values.push_back("HALF_WINDING_STAIR");
    values.push_back("HALF_TURN_STAIR");
    values.push_back("TWO_QUARTER_WINDING_STAIR");
    values.push_back("TWO_QUARTER_TURN_STAIR");
    values.push_back("THREE_QUARTER_WINDING_STAIR");
    values.push_back("THREE_QUARTER_TURN_STAIR");
    values.push_back("SPIRAL_STAIR");
    values.push_back("DOUBLE_RETURN_STAIR");
    values.push_back("CURVED_RUN_STAIR");
    values.push_back("TWO_CURVED_RUN_STAIR");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcStairTypeEnum] = new IfcEnumerationDescriptor(Type::IfcStairTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("READWRITE");
    values.push_back("READONLY");
    values.push_back("LOCKED");
    values.push_back("READWRITELOCKED");
    values.push_back("READONLYLOCKED");
    enumeration_descriptor_map[Type::IfcStateEnum] = new IfcEnumerationDescriptor(Type::IfcStateEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("CONST");
    values.push_back("LINEAR");
    values.push_back("POLYGONAL");
    values.push_back("EQUIDISTANT");
    values.push_back("SINUS");
    values.push_back("PARABOLA");
    values.push_back("DISCRETE");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcStructuralCurveActivityTypeEnum] = new IfcEnumerationDescriptor(Type::IfcStructuralCurveActivityTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("RIGID_JOINED_MEMBER");
    values.push_back("PIN_JOINED_MEMBER");
    values.push_back("CABLE");
    values.push_back("TENSION_MEMBER");
    values.push_back("COMPRESSION_MEMBER");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcStructuralCurveMemberTypeEnum] = new IfcEnumerationDescriptor(Type::IfcStructuralCurveMemberTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("CONST");
    values.push_back("BILINEAR");
    values.push_back("DISCRETE");
    values.push_back("ISOCONTOUR");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcStructuralSurfaceActivityTypeEnum] = new IfcEnumerationDescriptor(Type::IfcStructuralSurfaceActivityTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("BENDING_ELEMENT");
    values.push_back("MEMBRANE_ELEMENT");
    values.push_back("SHELL");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcStructuralSurfaceMemberTypeEnum] = new IfcEnumerationDescriptor(Type::IfcStructuralSurfaceMemberTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("PURCHASE");
    values.push_back("WORK");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcSubContractResourceTypeEnum] = new IfcEnumerationDescriptor(Type::IfcSubContractResourceTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("MARK");
    values.push_back("TAG");
    values.push_back("TREATMENT");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcSurfaceFeatureTypeEnum] = new IfcEnumerationDescriptor(Type::IfcSurfaceFeatureTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("POSITIVE");
    values.push_back("NEGATIVE");
    values.push_back("BOTH");
    enumeration_descriptor_map[Type::IfcSurfaceSide] = new IfcEnumerationDescriptor(Type::IfcSurfaceSide, values);
    values.clear(); values.reserve(128);
    values.push_back("CONTACTOR");
    values.push_back("DIMMERSWITCH");
    values.push_back("EMERGENCYSTOP");
    values.push_back("KEYPAD");
    values.push_back("MOMENTARYSWITCH");
    values.push_back("SELECTORSWITCH");
    values.push_back("STARTER");
    values.push_back("SWITCHDISCONNECTOR");
    values.push_back("TOGGLESWITCH");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcSwitchingDeviceTypeEnum] = new IfcEnumerationDescriptor(Type::IfcSwitchingDeviceTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("PANEL");
    values.push_back("WORKSURFACE");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcSystemFurnitureElementTypeEnum] = new IfcEnumerationDescriptor(Type::IfcSystemFurnitureElementTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("BASIN");
    values.push_back("BREAKPRESSURE");
    values.push_back("EXPANSION");
    values.push_back("FEEDANDEXPANSION");
    values.push_back("PRESSUREVESSEL");
    values.push_back("STORAGE");
    values.push_back("VESSEL");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcTankTypeEnum] = new IfcEnumerationDescriptor(Type::IfcTankTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("ELAPSEDTIME");
    values.push_back("WORKTIME");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcTaskDurationEnum] = new IfcEnumerationDescriptor(Type::IfcTaskDurationEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("ATTENDANCE");
    values.push_back("CONSTRUCTION");
    values.push_back("DEMOLITION");
    values.push_back("DISMANTLE");
    values.push_back("DISPOSAL");
    values.push_back("INSTALLATION");
    values.push_back("LOGISTIC");
    values.push_back("MAINTENANCE");
    values.push_back("MOVE");
    values.push_back("OPERATION");
    values.push_back("REMOVAL");
    values.push_back("RENOVATION");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcTaskTypeEnum] = new IfcEnumerationDescriptor(Type::IfcTaskTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("COUPLER");
    values.push_back("FIXED_END");
    values.push_back("TENSIONING_END");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcTendonAnchorTypeEnum] = new IfcEnumerationDescriptor(Type::IfcTendonAnchorTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("BAR");
    values.push_back("COATED");
    values.push_back("STRAND");
    values.push_back("WIRE");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcTendonTypeEnum] = new IfcEnumerationDescriptor(Type::IfcTendonTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("LEFT");
    values.push_back("RIGHT");
    values.push_back("UP");
    values.push_back("DOWN");
    enumeration_descriptor_map[Type::IfcTextPath] = new IfcEnumerationDescriptor(Type::IfcTextPath, values);
    values.clear(); values.reserve(128);
    values.push_back("CONTINUOUS");
    values.push_back("DISCRETE");
    values.push_back("DISCRETEBINARY");
    values.push_back("PIECEWISEBINARY");
    values.push_back("PIECEWISECONSTANT");
    values.push_back("PIECEWISECONTINUOUS");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcTimeSeriesDataTypeEnum] = new IfcEnumerationDescriptor(Type::IfcTimeSeriesDataTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("CURRENT");
    values.push_back("FREQUENCY");
    values.push_back("INVERTER");
    values.push_back("RECTIFIER");
    values.push_back("VOLTAGE");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcTransformerTypeEnum] = new IfcEnumerationDescriptor(Type::IfcTransformerTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("DISCONTINUOUS");
    values.push_back("CONTINUOUS");
    values.push_back("CONTSAMEGRADIENT");
    values.push_back("CONTSAMEGRADIENTSAMECURVATURE");
    enumeration_descriptor_map[Type::IfcTransitionCode] = new IfcEnumerationDescriptor(Type::IfcTransitionCode, values);
    values.clear(); values.reserve(128);
    values.push_back("ELEVATOR");
    values.push_back("ESCALATOR");
    values.push_back("MOVINGWALKWAY");
    values.push_back("CRANEWAY");
    values.push_back("LIFTINGGEAR");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcTransportElementTypeEnum] = new IfcEnumerationDescriptor(Type::IfcTransportElementTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("CARTESIAN");
    values.push_back("PARAMETER");
    values.push_back("UNSPECIFIED");
    enumeration_descriptor_map[Type::IfcTrimmingPreference] = new IfcEnumerationDescriptor(Type::IfcTrimmingPreference, values);
    values.clear(); values.reserve(128);
    values.push_back("FINNED");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcTubeBundleTypeEnum] = new IfcEnumerationDescriptor(Type::IfcTubeBundleTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("ABSORBEDDOSEUNIT");
    values.push_back("AMOUNTOFSUBSTANCEUNIT");
    values.push_back("AREAUNIT");
    values.push_back("DOSEEQUIVALENTUNIT");
    values.push_back("ELECTRICCAPACITANCEUNIT");
    values.push_back("ELECTRICCHARGEUNIT");
    values.push_back("ELECTRICCONDUCTANCEUNIT");
    values.push_back("ELECTRICCURRENTUNIT");
    values.push_back("ELECTRICRESISTANCEUNIT");
    values.push_back("ELECTRICVOLTAGEUNIT");
    values.push_back("ENERGYUNIT");
    values.push_back("FORCEUNIT");
    values.push_back("FREQUENCYUNIT");
    values.push_back("ILLUMINANCEUNIT");
    values.push_back("INDUCTANCEUNIT");
    values.push_back("LENGTHUNIT");
    values.push_back("LUMINOUSFLUXUNIT");
    values.push_back("LUMINOUSINTENSITYUNIT");
    values.push_back("MAGNETICFLUXDENSITYUNIT");
    values.push_back("MAGNETICFLUXUNIT");
    values.push_back("MASSUNIT");
    values.push_back("PLANEANGLEUNIT");
    values.push_back("POWERUNIT");
    values.push_back("PRESSUREUNIT");
    values.push_back("RADIOACTIVITYUNIT");
    values.push_back("SOLIDANGLEUNIT");
    values.push_back("THERMODYNAMICTEMPERATUREUNIT");
    values.push_back("TIMEUNIT");
    values.push_back("VOLUMEUNIT");
    values.push_back("USERDEFINED");
    enumeration_descriptor_map[Type::IfcUnitEnum] = new IfcEnumerationDescriptor(Type::IfcUnitEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("ALARMPANEL");
    values.push_back("CONTROLPANEL");
    values.push_back("GASDETECTIONPANEL");
    values.push_back("INDICATORPANEL");
    values.push_back("MIMICPANEL");
    values.push_back("HUMIDISTAT");
    values.push_back("THERMOSTAT");
    values.push_back("WEATHERSTATION");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcUnitaryControlElementTypeEnum] = new IfcEnumerationDescriptor(Type::IfcUnitaryControlElementTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("AIRHANDLER");
    values.push_back("AIRCONDITIONINGUNIT");
    values.push_back("DEHUMIDIFIER");
    values.push_back("SPLITSYSTEM");
    values.push_back("ROOFTOPUNIT");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcUnitaryEquipmentTypeEnum] = new IfcEnumerationDescriptor(Type::IfcUnitaryEquipmentTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("AIRRELEASE");
    values.push_back("ANTIVACUUM");
    values.push_back("CHANGEOVER");
    values.push_back("CHECK");
    values.push_back("COMMISSIONING");
    values.push_back("DIVERTING");
    values.push_back("DRAWOFFCOCK");
    values.push_back("DOUBLECHECK");
    values.push_back("DOUBLEREGULATING");
    values.push_back("FAUCET");
    values.push_back("FLUSHING");
    values.push_back("GASCOCK");
    values.push_back("GASTAP");
    values.push_back("ISOLATING");
    values.push_back("MIXING");
    values.push_back("PRESSUREREDUCING");
    values.push_back("PRESSURERELIEF");
    values.push_back("REGULATING");
    values.push_back("SAFETYCUTOFF");
    values.push_back("STEAMTRAP");
    values.push_back("STOPCOCK");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcValveTypeEnum] = new IfcEnumerationDescriptor(Type::IfcValveTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("COMPRESSION");
    values.push_back("SPRING");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcVibrationIsolatorTypeEnum] = new IfcEnumerationDescriptor(Type::IfcVibrationIsolatorTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("CUTOUT");
    values.push_back("NOTCH");
    values.push_back("HOLE");
    values.push_back("MITER");
    values.push_back("CHAMFER");
    values.push_back("EDGE");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcVoidingFeatureTypeEnum] = new IfcEnumerationDescriptor(Type::IfcVoidingFeatureTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("MOVABLE");
    values.push_back("PARAPET");
    values.push_back("PARTITIONING");
    values.push_back("PLUMBINGWALL");
    values.push_back("SHEAR");
    values.push_back("SOLIDWALL");
    values.push_back("STANDARD");
    values.push_back("POLYGONAL");
    values.push_back("ELEMENTEDWALL");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcWallTypeEnum] = new IfcEnumerationDescriptor(Type::IfcWallTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("FLOORTRAP");
    values.push_back("FLOORWASTE");
    values.push_back("GULLYSUMP");
    values.push_back("GULLYTRAP");
    values.push_back("ROOFDRAIN");
    values.push_back("WASTEDISPOSALUNIT");
    values.push_back("WASTETRAP");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcWasteTerminalTypeEnum] = new IfcEnumerationDescriptor(Type::IfcWasteTerminalTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("SIDEHUNGRIGHTHAND");
    values.push_back("SIDEHUNGLEFTHAND");
    values.push_back("TILTANDTURNRIGHTHAND");
    values.push_back("TILTANDTURNLEFTHAND");
    values.push_back("TOPHUNG");
    values.push_back("BOTTOMHUNG");
    values.push_back("PIVOTHORIZONTAL");
    values.push_back("PIVOTVERTICAL");
    values.push_back("SLIDINGHORIZONTAL");
    values.push_back("SLIDINGVERTICAL");
    values.push_back("REMOVABLECASEMENT");
    values.push_back("FIXEDCASEMENT");
    values.push_back("OTHEROPERATION");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcWindowPanelOperationEnum] = new IfcEnumerationDescriptor(Type::IfcWindowPanelOperationEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("LEFT");
    values.push_back("MIDDLE");
    values.push_back("RIGHT");
    values.push_back("BOTTOM");
    values.push_back("TOP");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcWindowPanelPositionEnum] = new IfcEnumerationDescriptor(Type::IfcWindowPanelPositionEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("ALUMINIUM");
    values.push_back("HIGH_GRADE_STEEL");
    values.push_back("STEEL");
    values.push_back("WOOD");
    values.push_back("ALUMINIUM_WOOD");
    values.push_back("PLASTIC");
    values.push_back("OTHER_CONSTRUCTION");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcWindowStyleConstructionEnum] = new IfcEnumerationDescriptor(Type::IfcWindowStyleConstructionEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("SINGLE_PANEL");
    values.push_back("DOUBLE_PANEL_VERTICAL");
    values.push_back("DOUBLE_PANEL_HORIZONTAL");
    values.push_back("TRIPLE_PANEL_VERTICAL");
    values.push_back("TRIPLE_PANEL_BOTTOM");
    values.push_back("TRIPLE_PANEL_TOP");
    values.push_back("TRIPLE_PANEL_LEFT");
    values.push_back("TRIPLE_PANEL_RIGHT");
    values.push_back("TRIPLE_PANEL_HORIZONTAL");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcWindowStyleOperationEnum] = new IfcEnumerationDescriptor(Type::IfcWindowStyleOperationEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("WINDOW");
    values.push_back("SKYLIGHT");
    values.push_back("LIGHTDOME");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcWindowTypeEnum] = new IfcEnumerationDescriptor(Type::IfcWindowTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("SINGLE_PANEL");
    values.push_back("DOUBLE_PANEL_VERTICAL");
    values.push_back("DOUBLE_PANEL_HORIZONTAL");
    values.push_back("TRIPLE_PANEL_VERTICAL");
    values.push_back("TRIPLE_PANEL_BOTTOM");
    values.push_back("TRIPLE_PANEL_TOP");
    values.push_back("TRIPLE_PANEL_LEFT");
    values.push_back("TRIPLE_PANEL_RIGHT");
    values.push_back("TRIPLE_PANEL_HORIZONTAL");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcWindowTypePartitioningEnum] = new IfcEnumerationDescriptor(Type::IfcWindowTypePartitioningEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("FIRSTSHIFT");
    values.push_back("SECONDSHIFT");
    values.push_back("THIRDSHIFT");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcWorkCalendarTypeEnum] = new IfcEnumerationDescriptor(Type::IfcWorkCalendarTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("ACTUAL");
    values.push_back("BASELINE");
    values.push_back("PLANNED");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcWorkPlanTypeEnum] = new IfcEnumerationDescriptor(Type::IfcWorkPlanTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("ACTUAL");
    values.push_back("BASELINE");
    values.push_back("PLANNED");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    enumeration_descriptor_map[Type::IfcWorkScheduleTypeEnum] = new IfcEnumerationDescriptor(Type::IfcWorkScheduleTypeEnum, values);
}

#ifdef _MSC_VER
#  pragma optimize( "", on )
#endif

void InitInverseMap() {
    inverse_map[Type::IfcActor].insert(std::make_pair("IsActingUpon", std::make_pair(Type::IfcRelAssignsToActor, 6)));
    inverse_map[Type::IfcActorRole].insert(std::make_pair("HasExternalReference", std::make_pair(Type::IfcExternalReferenceRelationship, 3)));
    inverse_map[Type::IfcAddress].insert(std::make_pair("OfPerson", std::make_pair(Type::IfcPerson, 7)));
    inverse_map[Type::IfcAddress].insert(std::make_pair("OfOrganization", std::make_pair(Type::IfcOrganization, 4)));
    inverse_map[Type::IfcAnnotation].insert(std::make_pair("ContainedInStructure", std::make_pair(Type::IfcRelContainedInSpatialStructure, 4)));
    inverse_map[Type::IfcAppliedValue].insert(std::make_pair("HasExternalReference", std::make_pair(Type::IfcExternalReferenceRelationship, 3)));
    inverse_map[Type::IfcApproval].insert(std::make_pair("HasExternalReferences", std::make_pair(Type::IfcExternalReferenceRelationship, 3)));
    inverse_map[Type::IfcApproval].insert(std::make_pair("ApprovedObjects", std::make_pair(Type::IfcRelAssociatesApproval, 5)));
    inverse_map[Type::IfcApproval].insert(std::make_pair("ApprovedResources", std::make_pair(Type::IfcResourceApprovalRelationship, 3)));
    inverse_map[Type::IfcApproval].insert(std::make_pair("IsRelatedWith", std::make_pair(Type::IfcApprovalRelationship, 3)));
    inverse_map[Type::IfcApproval].insert(std::make_pair("Relates", std::make_pair(Type::IfcApprovalRelationship, 2)));
    inverse_map[Type::IfcClassification].insert(std::make_pair("ClassificationForObjects", std::make_pair(Type::IfcRelAssociatesClassification, 5)));
    inverse_map[Type::IfcClassification].insert(std::make_pair("HasReferences", std::make_pair(Type::IfcClassificationReference, 3)));
    inverse_map[Type::IfcClassificationReference].insert(std::make_pair("ClassificationRefForObjects", std::make_pair(Type::IfcRelAssociatesClassification, 5)));
    inverse_map[Type::IfcClassificationReference].insert(std::make_pair("HasReferences", std::make_pair(Type::IfcClassificationReference, 3)));
    inverse_map[Type::IfcCompositeCurveSegment].insert(std::make_pair("UsingCurves", std::make_pair(Type::IfcCompositeCurve, 0)));
    inverse_map[Type::IfcConstraint].insert(std::make_pair("HasExternalReferences", std::make_pair(Type::IfcExternalReferenceRelationship, 3)));
    inverse_map[Type::IfcConstraint].insert(std::make_pair("PropertiesForConstraint", std::make_pair(Type::IfcResourceConstraintRelationship, 2)));
    inverse_map[Type::IfcContext].insert(std::make_pair("IsDefinedBy", std::make_pair(Type::IfcRelDefinesByProperties, 4)));
    inverse_map[Type::IfcContext].insert(std::make_pair("Declares", std::make_pair(Type::IfcRelDeclares, 4)));
    inverse_map[Type::IfcContextDependentUnit].insert(std::make_pair("HasExternalReference", std::make_pair(Type::IfcExternalReferenceRelationship, 3)));
    inverse_map[Type::IfcControl].insert(std::make_pair("Controls", std::make_pair(Type::IfcRelAssignsToControl, 6)));
    inverse_map[Type::IfcConversionBasedUnit].insert(std::make_pair("HasExternalReference", std::make_pair(Type::IfcExternalReferenceRelationship, 3)));
    inverse_map[Type::IfcCoordinateReferenceSystem].insert(std::make_pair("HasCoordinateOperation", std::make_pair(Type::IfcCoordinateOperation, 0)));
    inverse_map[Type::IfcCovering].insert(std::make_pair("CoversSpaces", std::make_pair(Type::IfcRelCoversSpaces, 5)));
    inverse_map[Type::IfcCovering].insert(std::make_pair("CoversElements", std::make_pair(Type::IfcRelCoversBldgElements, 5)));
    inverse_map[Type::IfcDistributionControlElement].insert(std::make_pair("AssignedToFlowElement", std::make_pair(Type::IfcRelFlowControlElements, 4)));
    inverse_map[Type::IfcDistributionElement].insert(std::make_pair("HasPorts", std::make_pair(Type::IfcRelConnectsPortToElement, 5)));
    inverse_map[Type::IfcDistributionFlowElement].insert(std::make_pair("HasControlElements", std::make_pair(Type::IfcRelFlowControlElements, 5)));
    inverse_map[Type::IfcDocumentInformation].insert(std::make_pair("DocumentInfoForObjects", std::make_pair(Type::IfcRelAssociatesDocument, 5)));
    inverse_map[Type::IfcDocumentInformation].insert(std::make_pair("HasDocumentReferences", std::make_pair(Type::IfcDocumentReference, 4)));
    inverse_map[Type::IfcDocumentInformation].insert(std::make_pair("IsPointedTo", std::make_pair(Type::IfcDocumentInformationRelationship, 3)));
    inverse_map[Type::IfcDocumentInformation].insert(std::make_pair("IsPointer", std::make_pair(Type::IfcDocumentInformationRelationship, 2)));
    inverse_map[Type::IfcDocumentReference].insert(std::make_pair("DocumentRefForObjects", std::make_pair(Type::IfcRelAssociatesDocument, 5)));
    inverse_map[Type::IfcElement].insert(std::make_pair("FillsVoids", std::make_pair(Type::IfcRelFillsElement, 5)));
    inverse_map[Type::IfcElement].insert(std::make_pair("ConnectedTo", std::make_pair(Type::IfcRelConnectsElements, 5)));
    inverse_map[Type::IfcElement].insert(std::make_pair("IsInterferedByElements", std::make_pair(Type::IfcRelInterferesElements, 5)));
    inverse_map[Type::IfcElement].insert(std::make_pair("InterferesElements", std::make_pair(Type::IfcRelInterferesElements, 4)));
    inverse_map[Type::IfcElement].insert(std::make_pair("HasProjections", std::make_pair(Type::IfcRelProjectsElement, 4)));
    inverse_map[Type::IfcElement].insert(std::make_pair("ReferencedInStructures", std::make_pair(Type::IfcRelReferencedInSpatialStructure, 4)));
    inverse_map[Type::IfcElement].insert(std::make_pair("HasOpenings", std::make_pair(Type::IfcRelVoidsElement, 4)));
    inverse_map[Type::IfcElement].insert(std::make_pair("IsConnectionRealization", std::make_pair(Type::IfcRelConnectsWithRealizingElements, 7)));
    inverse_map[Type::IfcElement].insert(std::make_pair("ProvidesBoundaries", std::make_pair(Type::IfcRelSpaceBoundary, 5)));
    inverse_map[Type::IfcElement].insert(std::make_pair("ConnectedFrom", std::make_pair(Type::IfcRelConnectsElements, 6)));
    inverse_map[Type::IfcElement].insert(std::make_pair("ContainedInStructure", std::make_pair(Type::IfcRelContainedInSpatialStructure, 4)));
    inverse_map[Type::IfcElement].insert(std::make_pair("HasCoverings", std::make_pair(Type::IfcRelCoversBldgElements, 4)));
    inverse_map[Type::IfcExternalReference].insert(std::make_pair("ExternalReferenceForResources", std::make_pair(Type::IfcExternalReferenceRelationship, 2)));
    inverse_map[Type::IfcExternalSpatialElement].insert(std::make_pair("BoundedBy", std::make_pair(Type::IfcRelSpaceBoundary, 4)));
    inverse_map[Type::IfcFace].insert(std::make_pair("HasTextureMaps", std::make_pair(Type::IfcTextureMap, 2)));
    inverse_map[Type::IfcFeatureElementAddition].insert(std::make_pair("ProjectsElements", std::make_pair(Type::IfcRelProjectsElement, 5)));
    inverse_map[Type::IfcFeatureElementSubtraction].insert(std::make_pair("VoidsElements", std::make_pair(Type::IfcRelVoidsElement, 5)));
    inverse_map[Type::IfcGeometricRepresentationContext].insert(std::make_pair("HasSubContexts", std::make_pair(Type::IfcGeometricRepresentationSubContext, 6)));
    inverse_map[Type::IfcGeometricRepresentationContext].insert(std::make_pair("HasCoordinateOperation", std::make_pair(Type::IfcCoordinateOperation, 0)));
    inverse_map[Type::IfcGrid].insert(std::make_pair("ContainedInStructure", std::make_pair(Type::IfcRelContainedInSpatialStructure, 4)));
    inverse_map[Type::IfcGridAxis].insert(std::make_pair("PartOfW", std::make_pair(Type::IfcGrid, 9)));
    inverse_map[Type::IfcGridAxis].insert(std::make_pair("PartOfV", std::make_pair(Type::IfcGrid, 8)));
    inverse_map[Type::IfcGridAxis].insert(std::make_pair("PartOfU", std::make_pair(Type::IfcGrid, 7)));
    inverse_map[Type::IfcGridAxis].insert(std::make_pair("HasIntersections", std::make_pair(Type::IfcVirtualGridIntersection, 0)));
    inverse_map[Type::IfcGroup].insert(std::make_pair("IsGroupedBy", std::make_pair(Type::IfcRelAssignsToGroup, 6)));
    inverse_map[Type::IfcLibraryInformation].insert(std::make_pair("LibraryInfoForObjects", std::make_pair(Type::IfcRelAssociatesLibrary, 5)));
    inverse_map[Type::IfcLibraryInformation].insert(std::make_pair("HasLibraryReferences", std::make_pair(Type::IfcLibraryReference, 5)));
    inverse_map[Type::IfcLibraryReference].insert(std::make_pair("LibraryRefForObjects", std::make_pair(Type::IfcRelAssociatesLibrary, 5)));
    inverse_map[Type::IfcMaterial].insert(std::make_pair("HasRepresentation", std::make_pair(Type::IfcMaterialDefinitionRepresentation, 3)));
    inverse_map[Type::IfcMaterial].insert(std::make_pair("IsRelatedWith", std::make_pair(Type::IfcMaterialRelationship, 3)));
    inverse_map[Type::IfcMaterial].insert(std::make_pair("RelatesTo", std::make_pair(Type::IfcMaterialRelationship, 2)));
    inverse_map[Type::IfcMaterialConstituent].insert(std::make_pair("ToMaterialConstituentSet", std::make_pair(Type::IfcMaterialConstituentSet, 2)));
    inverse_map[Type::IfcMaterialDefinition].insert(std::make_pair("AssociatedTo", std::make_pair(Type::IfcRelAssociatesMaterial, 5)));
    inverse_map[Type::IfcMaterialDefinition].insert(std::make_pair("HasExternalReferences", std::make_pair(Type::IfcExternalReferenceRelationship, 3)));
    inverse_map[Type::IfcMaterialDefinition].insert(std::make_pair("HasProperties", std::make_pair(Type::IfcMaterialProperties, 3)));
    inverse_map[Type::IfcMaterialLayer].insert(std::make_pair("ToMaterialLayerSet", std::make_pair(Type::IfcMaterialLayerSet, 0)));
    inverse_map[Type::IfcMaterialProfile].insert(std::make_pair("ToMaterialProfileSet", std::make_pair(Type::IfcMaterialProfileSet, 2)));
    inverse_map[Type::IfcMaterialUsageDefinition].insert(std::make_pair("AssociatedTo", std::make_pair(Type::IfcRelAssociatesMaterial, 5)));
    inverse_map[Type::IfcObject].insert(std::make_pair("IsDeclaredBy", std::make_pair(Type::IfcRelDefinesByObject, 4)));
    inverse_map[Type::IfcObject].insert(std::make_pair("Declares", std::make_pair(Type::IfcRelDefinesByObject, 5)));
    inverse_map[Type::IfcObject].insert(std::make_pair("IsTypedBy", std::make_pair(Type::IfcRelDefinesByType, 4)));
    inverse_map[Type::IfcObject].insert(std::make_pair("IsDefinedBy", std::make_pair(Type::IfcRelDefinesByProperties, 4)));
    inverse_map[Type::IfcObjectDefinition].insert(std::make_pair("HasAssignments", std::make_pair(Type::IfcRelAssigns, 4)));
    inverse_map[Type::IfcObjectDefinition].insert(std::make_pair("Nests", std::make_pair(Type::IfcRelNests, 5)));
    inverse_map[Type::IfcObjectDefinition].insert(std::make_pair("IsNestedBy", std::make_pair(Type::IfcRelNests, 4)));
    inverse_map[Type::IfcObjectDefinition].insert(std::make_pair("HasContext", std::make_pair(Type::IfcRelDeclares, 5)));
    inverse_map[Type::IfcObjectDefinition].insert(std::make_pair("IsDecomposedBy", std::make_pair(Type::IfcRelAggregates, 4)));
    inverse_map[Type::IfcObjectDefinition].insert(std::make_pair("Decomposes", std::make_pair(Type::IfcRelAggregates, 5)));
    inverse_map[Type::IfcObjectDefinition].insert(std::make_pair("HasAssociations", std::make_pair(Type::IfcRelAssociates, 4)));
    inverse_map[Type::IfcObjectPlacement].insert(std::make_pair("PlacesObject", std::make_pair(Type::IfcProduct, 5)));
    inverse_map[Type::IfcObjectPlacement].insert(std::make_pair("ReferencedByPlacements", std::make_pair(Type::IfcLocalPlacement, 0)));
    inverse_map[Type::IfcOpeningElement].insert(std::make_pair("HasFillings", std::make_pair(Type::IfcRelFillsElement, 4)));
    inverse_map[Type::IfcOrganization].insert(std::make_pair("IsRelatedBy", std::make_pair(Type::IfcOrganizationRelationship, 3)));
    inverse_map[Type::IfcOrganization].insert(std::make_pair("Relates", std::make_pair(Type::IfcOrganizationRelationship, 2)));
    inverse_map[Type::IfcOrganization].insert(std::make_pair("Engages", std::make_pair(Type::IfcPersonAndOrganization, 1)));
    inverse_map[Type::IfcPerson].insert(std::make_pair("EngagedIn", std::make_pair(Type::IfcPersonAndOrganization, 0)));
    inverse_map[Type::IfcPhysicalQuantity].insert(std::make_pair("HasExternalReferences", std::make_pair(Type::IfcExternalReferenceRelationship, 3)));
    inverse_map[Type::IfcPhysicalQuantity].insert(std::make_pair("PartOfComplex", std::make_pair(Type::IfcPhysicalComplexQuantity, 2)));
    inverse_map[Type::IfcPort].insert(std::make_pair("ContainedIn", std::make_pair(Type::IfcRelConnectsPortToElement, 4)));
    inverse_map[Type::IfcPort].insert(std::make_pair("ConnectedFrom", std::make_pair(Type::IfcRelConnectsPorts, 5)));
    inverse_map[Type::IfcPort].insert(std::make_pair("ConnectedTo", std::make_pair(Type::IfcRelConnectsPorts, 4)));
    inverse_map[Type::IfcProcess].insert(std::make_pair("IsPredecessorTo", std::make_pair(Type::IfcRelSequence, 4)));
    inverse_map[Type::IfcProcess].insert(std::make_pair("IsSuccessorFrom", std::make_pair(Type::IfcRelSequence, 5)));
    inverse_map[Type::IfcProcess].insert(std::make_pair("OperatesOn", std::make_pair(Type::IfcRelAssignsToProcess, 6)));
    inverse_map[Type::IfcProduct].insert(std::make_pair("ReferencedBy", std::make_pair(Type::IfcRelAssignsToProduct, 6)));
    inverse_map[Type::IfcProductDefinitionShape].insert(std::make_pair("ShapeOfProduct", std::make_pair(Type::IfcProduct, 6)));
    inverse_map[Type::IfcProductDefinitionShape].insert(std::make_pair("HasShapeAspects", std::make_pair(Type::IfcShapeAspect, 4)));
    inverse_map[Type::IfcProfileDef].insert(std::make_pair("HasExternalReference", std::make_pair(Type::IfcExternalReferenceRelationship, 3)));
    inverse_map[Type::IfcProfileDef].insert(std::make_pair("HasProperties", std::make_pair(Type::IfcProfileProperties, 3)));
    inverse_map[Type::IfcProperty].insert(std::make_pair("PartOfPset", std::make_pair(Type::IfcPropertySet, 4)));
    inverse_map[Type::IfcProperty].insert(std::make_pair("PropertyForDependance", std::make_pair(Type::IfcPropertyDependencyRelationship, 2)));
    inverse_map[Type::IfcProperty].insert(std::make_pair("PropertyDependsOn", std::make_pair(Type::IfcPropertyDependencyRelationship, 3)));
    inverse_map[Type::IfcProperty].insert(std::make_pair("PartOfComplex", std::make_pair(Type::IfcComplexProperty, 3)));
    inverse_map[Type::IfcProperty].insert(std::make_pair("HasConstraints", std::make_pair(Type::IfcResourceConstraintRelationship, 3)));
    inverse_map[Type::IfcProperty].insert(std::make_pair("HasApprovals", std::make_pair(Type::IfcResourceApprovalRelationship, 2)));
    inverse_map[Type::IfcPropertyAbstraction].insert(std::make_pair("HasExternalReferences", std::make_pair(Type::IfcExternalReferenceRelationship, 3)));
    inverse_map[Type::IfcPropertyDefinition].insert(std::make_pair("HasContext", std::make_pair(Type::IfcRelDeclares, 5)));
    inverse_map[Type::IfcPropertyDefinition].insert(std::make_pair("HasAssociations", std::make_pair(Type::IfcRelAssociates, 4)));
    inverse_map[Type::IfcPropertySetDefinition].insert(std::make_pair("DefinesType", std::make_pair(Type::IfcTypeObject, 5)));
    inverse_map[Type::IfcPropertySetDefinition].insert(std::make_pair("IsDefinedBy", std::make_pair(Type::IfcRelDefinesByTemplate, 4)));
    inverse_map[Type::IfcPropertySetDefinition].insert(std::make_pair("DefinesOccurrence", std::make_pair(Type::IfcRelDefinesByProperties, 5)));
    inverse_map[Type::IfcPropertySetTemplate].insert(std::make_pair("Defines", std::make_pair(Type::IfcRelDefinesByTemplate, 5)));
    inverse_map[Type::IfcPropertyTemplate].insert(std::make_pair("PartOfComplexTemplate", std::make_pair(Type::IfcComplexPropertyTemplate, 6)));
    inverse_map[Type::IfcPropertyTemplate].insert(std::make_pair("PartOfPsetTemplate", std::make_pair(Type::IfcPropertySetTemplate, 6)));
    inverse_map[Type::IfcRelSpaceBoundary1stLevel].insert(std::make_pair("InnerBoundaries", std::make_pair(Type::IfcRelSpaceBoundary1stLevel, 9)));
    inverse_map[Type::IfcRelSpaceBoundary2ndLevel].insert(std::make_pair("Corresponds", std::make_pair(Type::IfcRelSpaceBoundary2ndLevel, 10)));
    inverse_map[Type::IfcRepresentation].insert(std::make_pair("RepresentationMap", std::make_pair(Type::IfcRepresentationMap, 1)));
    inverse_map[Type::IfcRepresentation].insert(std::make_pair("LayerAssignments", std::make_pair(Type::IfcPresentationLayerAssignment, 2)));
    inverse_map[Type::IfcRepresentation].insert(std::make_pair("OfProductRepresentation", std::make_pair(Type::IfcProductRepresentation, 2)));
    inverse_map[Type::IfcRepresentationContext].insert(std::make_pair("RepresentationsInContext", std::make_pair(Type::IfcRepresentation, 0)));
    inverse_map[Type::IfcRepresentationItem].insert(std::make_pair("LayerAssignment", std::make_pair(Type::IfcPresentationLayerAssignment, 2)));
    inverse_map[Type::IfcRepresentationItem].insert(std::make_pair("StyledByItem", std::make_pair(Type::IfcStyledItem, 0)));
    inverse_map[Type::IfcRepresentationMap].insert(std::make_pair("HasShapeAspects", std::make_pair(Type::IfcShapeAspect, 4)));
    inverse_map[Type::IfcRepresentationMap].insert(std::make_pair("MapUsage", std::make_pair(Type::IfcMappedItem, 0)));
    inverse_map[Type::IfcResource].insert(std::make_pair("ResourceOf", std::make_pair(Type::IfcRelAssignsToResource, 6)));
    inverse_map[Type::IfcShapeModel].insert(std::make_pair("OfShapeAspect", std::make_pair(Type::IfcShapeAspect, 0)));
    inverse_map[Type::IfcSpace].insert(std::make_pair("HasCoverings", std::make_pair(Type::IfcRelCoversSpaces, 4)));
    inverse_map[Type::IfcSpace].insert(std::make_pair("BoundedBy", std::make_pair(Type::IfcRelSpaceBoundary, 4)));
    inverse_map[Type::IfcSpatialElement].insert(std::make_pair("ContainsElements", std::make_pair(Type::IfcRelContainedInSpatialStructure, 5)));
    inverse_map[Type::IfcSpatialElement].insert(std::make_pair("ServicedBySystems", std::make_pair(Type::IfcRelServicesBuildings, 5)));
    inverse_map[Type::IfcSpatialElement].insert(std::make_pair("ReferencesElements", std::make_pair(Type::IfcRelReferencedInSpatialStructure, 5)));
    inverse_map[Type::IfcStructuralActivity].insert(std::make_pair("AssignedToStructuralItem", std::make_pair(Type::IfcRelConnectsStructuralActivity, 5)));
    inverse_map[Type::IfcStructuralConnection].insert(std::make_pair("ConnectsStructuralMembers", std::make_pair(Type::IfcRelConnectsStructuralMember, 5)));
    inverse_map[Type::IfcStructuralItem].insert(std::make_pair("AssignedStructuralActivity", std::make_pair(Type::IfcRelConnectsStructuralActivity, 4)));
    inverse_map[Type::IfcStructuralLoadGroup].insert(std::make_pair("SourceOfResultGroup", std::make_pair(Type::IfcStructuralResultGroup, 6)));
    inverse_map[Type::IfcStructuralLoadGroup].insert(std::make_pair("LoadGroupFor", std::make_pair(Type::IfcStructuralAnalysisModel, 7)));
    inverse_map[Type::IfcStructuralMember].insert(std::make_pair("ConnectedBy", std::make_pair(Type::IfcRelConnectsStructuralMember, 4)));
    inverse_map[Type::IfcStructuralResultGroup].insert(std::make_pair("ResultGroupFor", std::make_pair(Type::IfcStructuralAnalysisModel, 8)));
    inverse_map[Type::IfcSurfaceTexture].insert(std::make_pair("IsMappedBy", std::make_pair(Type::IfcTextureCoordinate, 0)));
    inverse_map[Type::IfcSurfaceTexture].insert(std::make_pair("UsedInStyles", std::make_pair(Type::IfcSurfaceStyleWithTextures, 0)));
    inverse_map[Type::IfcSystem].insert(std::make_pair("ServicesBuildings", std::make_pair(Type::IfcRelServicesBuildings, 4)));
    inverse_map[Type::IfcTessellatedFaceSet].insert(std::make_pair("HasColours", std::make_pair(Type::IfcIndexedColourMap, 0)));
    inverse_map[Type::IfcTessellatedFaceSet].insert(std::make_pair("HasTextures", std::make_pair(Type::IfcIndexedTextureMap, 1)));
    inverse_map[Type::IfcTimeSeries].insert(std::make_pair("HasExternalReference", std::make_pair(Type::IfcExternalReferenceRelationship, 3)));
    inverse_map[Type::IfcTypeObject].insert(std::make_pair("Types", std::make_pair(Type::IfcRelDefinesByType, 5)));
    inverse_map[Type::IfcTypeProcess].insert(std::make_pair("OperatesOn", std::make_pair(Type::IfcRelAssignsToProcess, 6)));
    inverse_map[Type::IfcTypeProduct].insert(std::make_pair("ReferencedBy", std::make_pair(Type::IfcRelAssignsToProduct, 6)));
    inverse_map[Type::IfcTypeResource].insert(std::make_pair("ResourceOf", std::make_pair(Type::IfcRelAssignsToResource, 6)));
}

void InitDerivedMap() {
    {std::set<int> idxs; idxs.insert(2); idxs.insert(3); idxs.insert(4); idxs.insert(5); derived_map[Type::IfcGeometricRepresentationSubContext] = idxs;}
    {std::set<int> idxs; idxs.insert(3); derived_map[Type::IfcMirroredProfileDef] = idxs;}
    {std::set<int> idxs; idxs.insert(0); idxs.insert(1); derived_map[Type::IfcOrientedEdge] = idxs;}
    {std::set<int> idxs; idxs.insert(0); derived_map[Type::IfcSIUnit] = idxs;}
}

int Type::GetAttributeIndex(Enum t, const std::string& a) {
    if (entity_descriptor_map.empty()) ::InitDescriptorMap();
    std::map<Type::Enum,IfcEntityDescriptor*>::const_iterator i = entity_descriptor_map.find(t);
    if ( i == entity_descriptor_map.end() ) throw IfcException("Type not found");
    else return i->second->getArgumentIndex(a);
}

int Type::GetAttributeCount(Enum t) {
    if (entity_descriptor_map.empty()) ::InitDescriptorMap();
    std::map<Type::Enum,IfcEntityDescriptor*>::const_iterator i = entity_descriptor_map.find(t);
    if ( i == entity_descriptor_map.end() ) throw IfcException("Type not found");
    else return i->second->getArgumentCount();
}

ArgumentType Type::GetAttributeType(Enum t, unsigned char a) {
    if (entity_descriptor_map.empty()) ::InitDescriptorMap();
    std::map<Type::Enum,IfcEntityDescriptor*>::const_iterator i = entity_descriptor_map.find(t);
    if ( i == entity_descriptor_map.end() ) throw IfcException("Type not found");
    else return i->second->getArgumentType(a);
}

Type::Enum Type::GetAttributeEntity(Enum t, unsigned char a) {
    if (entity_descriptor_map.empty()) ::InitDescriptorMap();
    std::map<Type::Enum,IfcEntityDescriptor*>::const_iterator i = entity_descriptor_map.find(t);
    if ( i == entity_descriptor_map.end() ) throw IfcException("Type not found");
    else return i->second->getArgumentEntity(a);
}

const std::string& Type::GetAttributeName(Enum t, unsigned char a) {
    if (entity_descriptor_map.empty()) ::InitDescriptorMap();
    std::map<Type::Enum,IfcEntityDescriptor*>::const_iterator i = entity_descriptor_map.find(t);
    if ( i == entity_descriptor_map.end() ) throw IfcException("Type not found");
    else return i->second->getArgumentName(a);
}

bool Type::GetAttributeOptional(Enum t, unsigned char a) {
    if (entity_descriptor_map.empty()) ::InitDescriptorMap();
    std::map<Type::Enum,IfcEntityDescriptor*>::const_iterator i = entity_descriptor_map.find(t);
    if ( i == entity_descriptor_map.end() ) throw IfcException("Type not found");
    else return i->second->getArgumentOptional(a);
}

bool Type::GetAttributeDerived(Enum t, unsigned char a) {
    if (derived_map.empty()) ::InitDerivedMap();
    std::map<Type::Enum,std::set<int> >::const_iterator i = derived_map.find(t);
    return i != derived_map.end() && i->second.find(a) != i->second.end();
}

std::pair<const char*, int> Type::GetEnumerationIndex(Enum t, const std::string& a) {
    if (enumeration_descriptor_map.empty()) ::InitDescriptorMap();
    std::map<Type::Enum,IfcEnumerationDescriptor*>::const_iterator i = enumeration_descriptor_map.find(t);
    if ( i == enumeration_descriptor_map.end() ) throw IfcException("Value not found");
    else return i->second->getIndex(a);
}

std::pair<Type::Enum, unsigned> Type::GetInverseAttribute(Enum t, const std::string& a) {
    if (inverse_map.empty()) ::InitInverseMap();
    inverse_map_t::const_iterator it;
    inverse_map_t::mapped_type::const_iterator jt;
    for(;;) {
        it = inverse_map.find(t);
        if (it != inverse_map.end()) {
            jt = it->second.find(a);
            if (jt != it->second.end()) {
                return jt->second;
            }
        }
        boost::optional<Enum> pt = Parent(t);
        if (pt) {
            t = *pt;
        }
        else {
            break;
        }
    }
    throw IfcException("Attribute not found");
}

std::set<std::string> Type::GetInverseAttributeNames(Enum t) {
    if (inverse_map.empty()) ::InitInverseMap();
    inverse_map_t::const_iterator it;
    inverse_map_t::mapped_type::const_iterator jt;

    std::set<std::string> return_value;

    for (;;) {
        it = inverse_map.find(t);
        if (it != inverse_map.end()) {
            for (jt = it->second.begin(); jt != it->second.end(); ++jt) {
                return_value.insert(jt->first);
            }
        }
        boost::optional<Enum> pt = Parent(t);
        if (pt) {
            t = *pt;
        }
        else {
            break;
        }
    }

    return return_value;
}

void Type::PopulateDerivedFields(IfcEntityInstanceData* e) {
    if (derived_map.empty()) ::InitDerivedMap();
    std::map<Type::Enum, std::set<int> >::const_iterator i = derived_map.find(e->type());
    if (i != derived_map.end()) {
        for (std::set<int>::const_iterator it = i->second.begin(); it != i->second.end(); ++it) {
            IfcWrite::IfcWriteArgument* attr = new IfcWrite::IfcWriteArgument();
            attr->set(IfcWrite::IfcWriteArgument::Derived());
            e->setArgument(*it, attr);
        }
    }
}
#endif
