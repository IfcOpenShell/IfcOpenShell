/********************************************************************************
 *                                                                              *
 * This file is part of IfcOpenShell.                                           *
 *                                                                              *
 * IfcOpenShell is free software: you can redistribute it and/or modify         *
 * it under the terms of the Lesser GNU General Public License as published by  *
 * the Free Software Foundation, either version 3.0 of the License, or          *
 * (at your option) any later version.                                          *
 *                                                                              *
 * IfcOpenShell is distributed in the hope that it will be useful,              *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of               *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the                 *
 * Lesser GNU General Public License for more details.                          *
 *                                                                              *
 * You should have received a copy of the Lesser GNU General Public License     *
 * along with this program. If not, see <http://www.gnu.org/licenses/>.         *
 *                                                                              *
 ********************************************************************************/

/********************************************************************************
 *                                                                              *
 * This file has been generated from IFC2X3_TC1.exp. Do not make modifications  *
 * but instead modify the python script that has been used to generate this.    *
 *                                                                              *
 ********************************************************************************/

#ifndef USE_IFC4

#include <set>

#include "../ifcparse/Ifc2x3.h"
#include "../ifcparse/Ifc2x3-latebound.h"
#include "../ifcparse/IfcException.h"
#include "../ifcparse/IfcWrite.h"
#include "../ifcparse/IfcWritableEntity.h"
#include "../ifcparse/IfcUtil.h"
#include "../ifcparse/IfcEntityDescriptor.h"

using namespace Ifc2x3;
using namespace IfcParse;
using namespace IfcWrite;
using namespace IfcUtil;

typedef std::map<Type::Enum,IfcEntityDescriptor*> entity_descriptor_map_t;
typedef std::map<Type::Enum,IfcEnumerationDescriptor*> enumeration_descriptor_map_t;
typedef std::map<Type::Enum, std::map<std::string, std::pair<Type::Enum, int> > > inverse_map_t;
typedef std::map<Type::Enum,std::set<int> > derived_map_t;

entity_descriptor_map_t entity_descriptor_map;
enumeration_descriptor_map_t enumeration_descriptor_map;
inverse_map_t inverse_map;
derived_map_t derived_map;


#ifdef _MSC_VER
#  pragma optimize( "", off )
#endif

void InitDescriptorMap() {
    IfcEntityDescriptor* current;
    current = entity_descriptor_map[Type::IfcAbsorbedDoseMeasure] = new IfcEntityDescriptor(Type::IfcAbsorbedDoseMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcAccelerationMeasure] = new IfcEntityDescriptor(Type::IfcAccelerationMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcAmountOfSubstanceMeasure] = new IfcEntityDescriptor(Type::IfcAmountOfSubstanceMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcAngularVelocityMeasure] = new IfcEntityDescriptor(Type::IfcAngularVelocityMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcAreaMeasure] = new IfcEntityDescriptor(Type::IfcAreaMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcBoolean] = new IfcEntityDescriptor(Type::IfcBoolean,0);
    current->add("wrappedValue",false,IfcUtil::Argument_BOOL);
    current = entity_descriptor_map[Type::IfcBoxAlignment] = new IfcEntityDescriptor(Type::IfcBoxAlignment,0);
    current->add("wrappedValue",false,IfcUtil::Argument_STRING);
    current = entity_descriptor_map[Type::IfcComplexNumber] = new IfcEntityDescriptor(Type::IfcComplexNumber,0);
    current->add("wrappedValue",false,IfcUtil::Argument_AGGREGATE_OF_DOUBLE);
    current = entity_descriptor_map[Type::IfcCompoundPlaneAngleMeasure] = new IfcEntityDescriptor(Type::IfcCompoundPlaneAngleMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_AGGREGATE_OF_INT);
    current = entity_descriptor_map[Type::IfcContextDependentMeasure] = new IfcEntityDescriptor(Type::IfcContextDependentMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcCountMeasure] = new IfcEntityDescriptor(Type::IfcCountMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcCurvatureMeasure] = new IfcEntityDescriptor(Type::IfcCurvatureMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcDayInMonthNumber] = new IfcEntityDescriptor(Type::IfcDayInMonthNumber,0);
    current->add("wrappedValue",false,IfcUtil::Argument_INT);
    current = entity_descriptor_map[Type::IfcDaylightSavingHour] = new IfcEntityDescriptor(Type::IfcDaylightSavingHour,0);
    current->add("wrappedValue",false,IfcUtil::Argument_INT);
    current = entity_descriptor_map[Type::IfcDescriptiveMeasure] = new IfcEntityDescriptor(Type::IfcDescriptiveMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_STRING);
    current = entity_descriptor_map[Type::IfcDimensionCount] = new IfcEntityDescriptor(Type::IfcDimensionCount,0);
    current->add("wrappedValue",false,IfcUtil::Argument_INT);
    current = entity_descriptor_map[Type::IfcDoseEquivalentMeasure] = new IfcEntityDescriptor(Type::IfcDoseEquivalentMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcDynamicViscosityMeasure] = new IfcEntityDescriptor(Type::IfcDynamicViscosityMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcElectricCapacitanceMeasure] = new IfcEntityDescriptor(Type::IfcElectricCapacitanceMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcElectricChargeMeasure] = new IfcEntityDescriptor(Type::IfcElectricChargeMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcElectricConductanceMeasure] = new IfcEntityDescriptor(Type::IfcElectricConductanceMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcElectricCurrentMeasure] = new IfcEntityDescriptor(Type::IfcElectricCurrentMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcElectricResistanceMeasure] = new IfcEntityDescriptor(Type::IfcElectricResistanceMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcElectricVoltageMeasure] = new IfcEntityDescriptor(Type::IfcElectricVoltageMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcEnergyMeasure] = new IfcEntityDescriptor(Type::IfcEnergyMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcFontStyle] = new IfcEntityDescriptor(Type::IfcFontStyle,0);
    current->add("wrappedValue",false,IfcUtil::Argument_STRING);
    current = entity_descriptor_map[Type::IfcFontVariant] = new IfcEntityDescriptor(Type::IfcFontVariant,0);
    current->add("wrappedValue",false,IfcUtil::Argument_STRING);
    current = entity_descriptor_map[Type::IfcFontWeight] = new IfcEntityDescriptor(Type::IfcFontWeight,0);
    current->add("wrappedValue",false,IfcUtil::Argument_STRING);
    current = entity_descriptor_map[Type::IfcForceMeasure] = new IfcEntityDescriptor(Type::IfcForceMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcFrequencyMeasure] = new IfcEntityDescriptor(Type::IfcFrequencyMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcGloballyUniqueId] = new IfcEntityDescriptor(Type::IfcGloballyUniqueId,0);
    current->add("wrappedValue",false,IfcUtil::Argument_STRING);
    current = entity_descriptor_map[Type::IfcHeatFluxDensityMeasure] = new IfcEntityDescriptor(Type::IfcHeatFluxDensityMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcHeatingValueMeasure] = new IfcEntityDescriptor(Type::IfcHeatingValueMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcHourInDay] = new IfcEntityDescriptor(Type::IfcHourInDay,0);
    current->add("wrappedValue",false,IfcUtil::Argument_INT);
    current = entity_descriptor_map[Type::IfcIdentifier] = new IfcEntityDescriptor(Type::IfcIdentifier,0);
    current->add("wrappedValue",false,IfcUtil::Argument_STRING);
    current = entity_descriptor_map[Type::IfcIlluminanceMeasure] = new IfcEntityDescriptor(Type::IfcIlluminanceMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcInductanceMeasure] = new IfcEntityDescriptor(Type::IfcInductanceMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcInteger] = new IfcEntityDescriptor(Type::IfcInteger,0);
    current->add("wrappedValue",false,IfcUtil::Argument_INT);
    current = entity_descriptor_map[Type::IfcIntegerCountRateMeasure] = new IfcEntityDescriptor(Type::IfcIntegerCountRateMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_INT);
    current = entity_descriptor_map[Type::IfcIonConcentrationMeasure] = new IfcEntityDescriptor(Type::IfcIonConcentrationMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcIsothermalMoistureCapacityMeasure] = new IfcEntityDescriptor(Type::IfcIsothermalMoistureCapacityMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcKinematicViscosityMeasure] = new IfcEntityDescriptor(Type::IfcKinematicViscosityMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcLabel] = new IfcEntityDescriptor(Type::IfcLabel,0);
    current->add("wrappedValue",false,IfcUtil::Argument_STRING);
    current = entity_descriptor_map[Type::IfcLengthMeasure] = new IfcEntityDescriptor(Type::IfcLengthMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcLinearForceMeasure] = new IfcEntityDescriptor(Type::IfcLinearForceMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcLinearMomentMeasure] = new IfcEntityDescriptor(Type::IfcLinearMomentMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcLinearStiffnessMeasure] = new IfcEntityDescriptor(Type::IfcLinearStiffnessMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcLinearVelocityMeasure] = new IfcEntityDescriptor(Type::IfcLinearVelocityMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcLogical] = new IfcEntityDescriptor(Type::IfcLogical,0);
    current->add("wrappedValue",false,IfcUtil::Argument_BOOL);
    current = entity_descriptor_map[Type::IfcLuminousFluxMeasure] = new IfcEntityDescriptor(Type::IfcLuminousFluxMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcLuminousIntensityDistributionMeasure] = new IfcEntityDescriptor(Type::IfcLuminousIntensityDistributionMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcLuminousIntensityMeasure] = new IfcEntityDescriptor(Type::IfcLuminousIntensityMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcMagneticFluxDensityMeasure] = new IfcEntityDescriptor(Type::IfcMagneticFluxDensityMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcMagneticFluxMeasure] = new IfcEntityDescriptor(Type::IfcMagneticFluxMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcMassDensityMeasure] = new IfcEntityDescriptor(Type::IfcMassDensityMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcMassFlowRateMeasure] = new IfcEntityDescriptor(Type::IfcMassFlowRateMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcMassMeasure] = new IfcEntityDescriptor(Type::IfcMassMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcMassPerLengthMeasure] = new IfcEntityDescriptor(Type::IfcMassPerLengthMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcMinuteInHour] = new IfcEntityDescriptor(Type::IfcMinuteInHour,0);
    current->add("wrappedValue",false,IfcUtil::Argument_INT);
    current = entity_descriptor_map[Type::IfcModulusOfElasticityMeasure] = new IfcEntityDescriptor(Type::IfcModulusOfElasticityMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcModulusOfLinearSubgradeReactionMeasure] = new IfcEntityDescriptor(Type::IfcModulusOfLinearSubgradeReactionMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcModulusOfRotationalSubgradeReactionMeasure] = new IfcEntityDescriptor(Type::IfcModulusOfRotationalSubgradeReactionMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcModulusOfSubgradeReactionMeasure] = new IfcEntityDescriptor(Type::IfcModulusOfSubgradeReactionMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcMoistureDiffusivityMeasure] = new IfcEntityDescriptor(Type::IfcMoistureDiffusivityMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcMolecularWeightMeasure] = new IfcEntityDescriptor(Type::IfcMolecularWeightMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcMomentOfInertiaMeasure] = new IfcEntityDescriptor(Type::IfcMomentOfInertiaMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcMonetaryMeasure] = new IfcEntityDescriptor(Type::IfcMonetaryMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcMonthInYearNumber] = new IfcEntityDescriptor(Type::IfcMonthInYearNumber,0);
    current->add("wrappedValue",false,IfcUtil::Argument_INT);
    current = entity_descriptor_map[Type::IfcNormalisedRatioMeasure] = new IfcEntityDescriptor(Type::IfcNormalisedRatioMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcNumericMeasure] = new IfcEntityDescriptor(Type::IfcNumericMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcPHMeasure] = new IfcEntityDescriptor(Type::IfcPHMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcParameterValue] = new IfcEntityDescriptor(Type::IfcParameterValue,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcPlanarForceMeasure] = new IfcEntityDescriptor(Type::IfcPlanarForceMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcPlaneAngleMeasure] = new IfcEntityDescriptor(Type::IfcPlaneAngleMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcPositiveLengthMeasure] = new IfcEntityDescriptor(Type::IfcPositiveLengthMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcPositivePlaneAngleMeasure] = new IfcEntityDescriptor(Type::IfcPositivePlaneAngleMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcPositiveRatioMeasure] = new IfcEntityDescriptor(Type::IfcPositiveRatioMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcPowerMeasure] = new IfcEntityDescriptor(Type::IfcPowerMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcPresentableText] = new IfcEntityDescriptor(Type::IfcPresentableText,0);
    current->add("wrappedValue",false,IfcUtil::Argument_STRING);
    current = entity_descriptor_map[Type::IfcPressureMeasure] = new IfcEntityDescriptor(Type::IfcPressureMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcRadioActivityMeasure] = new IfcEntityDescriptor(Type::IfcRadioActivityMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcRatioMeasure] = new IfcEntityDescriptor(Type::IfcRatioMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcReal] = new IfcEntityDescriptor(Type::IfcReal,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcRotationalFrequencyMeasure] = new IfcEntityDescriptor(Type::IfcRotationalFrequencyMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcRotationalMassMeasure] = new IfcEntityDescriptor(Type::IfcRotationalMassMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcRotationalStiffnessMeasure] = new IfcEntityDescriptor(Type::IfcRotationalStiffnessMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcSecondInMinute] = new IfcEntityDescriptor(Type::IfcSecondInMinute,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcSectionModulusMeasure] = new IfcEntityDescriptor(Type::IfcSectionModulusMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcSectionalAreaIntegralMeasure] = new IfcEntityDescriptor(Type::IfcSectionalAreaIntegralMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcShearModulusMeasure] = new IfcEntityDescriptor(Type::IfcShearModulusMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcSolidAngleMeasure] = new IfcEntityDescriptor(Type::IfcSolidAngleMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcSoundPowerMeasure] = new IfcEntityDescriptor(Type::IfcSoundPowerMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcSoundPressureMeasure] = new IfcEntityDescriptor(Type::IfcSoundPressureMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcSpecificHeatCapacityMeasure] = new IfcEntityDescriptor(Type::IfcSpecificHeatCapacityMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcSpecularExponent] = new IfcEntityDescriptor(Type::IfcSpecularExponent,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcSpecularRoughness] = new IfcEntityDescriptor(Type::IfcSpecularRoughness,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcTemperatureGradientMeasure] = new IfcEntityDescriptor(Type::IfcTemperatureGradientMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcText] = new IfcEntityDescriptor(Type::IfcText,0);
    current->add("wrappedValue",false,IfcUtil::Argument_STRING);
    current = entity_descriptor_map[Type::IfcTextAlignment] = new IfcEntityDescriptor(Type::IfcTextAlignment,0);
    current->add("wrappedValue",false,IfcUtil::Argument_STRING);
    current = entity_descriptor_map[Type::IfcTextDecoration] = new IfcEntityDescriptor(Type::IfcTextDecoration,0);
    current->add("wrappedValue",false,IfcUtil::Argument_STRING);
    current = entity_descriptor_map[Type::IfcTextFontName] = new IfcEntityDescriptor(Type::IfcTextFontName,0);
    current->add("wrappedValue",false,IfcUtil::Argument_STRING);
    current = entity_descriptor_map[Type::IfcTextTransformation] = new IfcEntityDescriptor(Type::IfcTextTransformation,0);
    current->add("wrappedValue",false,IfcUtil::Argument_STRING);
    current = entity_descriptor_map[Type::IfcThermalAdmittanceMeasure] = new IfcEntityDescriptor(Type::IfcThermalAdmittanceMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcThermalConductivityMeasure] = new IfcEntityDescriptor(Type::IfcThermalConductivityMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcThermalExpansionCoefficientMeasure] = new IfcEntityDescriptor(Type::IfcThermalExpansionCoefficientMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcThermalResistanceMeasure] = new IfcEntityDescriptor(Type::IfcThermalResistanceMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcThermalTransmittanceMeasure] = new IfcEntityDescriptor(Type::IfcThermalTransmittanceMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcThermodynamicTemperatureMeasure] = new IfcEntityDescriptor(Type::IfcThermodynamicTemperatureMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcTimeMeasure] = new IfcEntityDescriptor(Type::IfcTimeMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcTimeStamp] = new IfcEntityDescriptor(Type::IfcTimeStamp,0);
    current->add("wrappedValue",false,IfcUtil::Argument_INT);
    current = entity_descriptor_map[Type::IfcTorqueMeasure] = new IfcEntityDescriptor(Type::IfcTorqueMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcVaporPermeabilityMeasure] = new IfcEntityDescriptor(Type::IfcVaporPermeabilityMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcVolumeMeasure] = new IfcEntityDescriptor(Type::IfcVolumeMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcVolumetricFlowRateMeasure] = new IfcEntityDescriptor(Type::IfcVolumetricFlowRateMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcWarpingConstantMeasure] = new IfcEntityDescriptor(Type::IfcWarpingConstantMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcWarpingMomentMeasure] = new IfcEntityDescriptor(Type::IfcWarpingMomentMeasure,0);
    current->add("wrappedValue",false,IfcUtil::Argument_DOUBLE);
    current = entity_descriptor_map[Type::IfcYearNumber] = new IfcEntityDescriptor(Type::IfcYearNumber,0);
    current->add("wrappedValue",false,IfcUtil::Argument_INT);
    current = entity_descriptor_map[Type::IfcActorRole] = new IfcEntityDescriptor(Type::IfcActorRole,0);
    current->add("Role",false,IfcUtil::Argument_ENUMERATION,Type::IfcRoleEnum);
    current->add("UserDefinedRole",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("Description",true,IfcUtil::Argument_STRING,Type::IfcText);
    current = entity_descriptor_map[Type::IfcAddress] = new IfcEntityDescriptor(Type::IfcAddress,0);
    current->add("Purpose",true,IfcUtil::Argument_ENUMERATION,Type::IfcAddressTypeEnum);
    current->add("Description",true,IfcUtil::Argument_STRING,Type::IfcText);
    current->add("UserDefinedPurpose",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current = entity_descriptor_map[Type::IfcApplication] = new IfcEntityDescriptor(Type::IfcApplication,0);
    current->add("ApplicationDeveloper",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcOrganization);
    current->add("Version",false,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("ApplicationFullName",false,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("ApplicationIdentifier",false,IfcUtil::Argument_STRING,Type::IfcIdentifier);
    current = entity_descriptor_map[Type::IfcAppliedValue] = new IfcEntityDescriptor(Type::IfcAppliedValue,0);
    current->add("Name",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("Description",true,IfcUtil::Argument_STRING,Type::IfcText);
    current->add("AppliedValue",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcAppliedValueSelect);
    current->add("UnitBasis",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcMeasureWithUnit);
    current->add("ApplicableDate",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcDateTimeSelect);
    current->add("FixedUntilDate",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcDateTimeSelect);
    current = entity_descriptor_map[Type::IfcAppliedValueRelationship] = new IfcEntityDescriptor(Type::IfcAppliedValueRelationship,0);
    current->add("ComponentOfTotal",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcAppliedValue);
    current->add("Components",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcAppliedValue);
    current->add("ArithmeticOperator",false,IfcUtil::Argument_ENUMERATION,Type::IfcArithmeticOperatorEnum);
    current->add("Name",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("Description",true,IfcUtil::Argument_STRING,Type::IfcText);
    current = entity_descriptor_map[Type::IfcApproval] = new IfcEntityDescriptor(Type::IfcApproval,0);
    current->add("Description",true,IfcUtil::Argument_STRING,Type::IfcText);
    current->add("ApprovalDateTime",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcDateTimeSelect);
    current->add("ApprovalStatus",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("ApprovalLevel",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("ApprovalQualifier",true,IfcUtil::Argument_STRING,Type::IfcText);
    current->add("Name",false,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("Identifier",false,IfcUtil::Argument_STRING,Type::IfcIdentifier);
    current = entity_descriptor_map[Type::IfcApprovalActorRelationship] = new IfcEntityDescriptor(Type::IfcApprovalActorRelationship,0);
    current->add("Actor",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcActorSelect);
    current->add("Approval",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcApproval);
    current->add("Role",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcActorRole);
    current = entity_descriptor_map[Type::IfcApprovalPropertyRelationship] = new IfcEntityDescriptor(Type::IfcApprovalPropertyRelationship,0);
    current->add("ApprovedProperties",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcProperty);
    current->add("Approval",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcApproval);
    current = entity_descriptor_map[Type::IfcApprovalRelationship] = new IfcEntityDescriptor(Type::IfcApprovalRelationship,0);
    current->add("RelatedApproval",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcApproval);
    current->add("RelatingApproval",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcApproval);
    current->add("Description",true,IfcUtil::Argument_STRING,Type::IfcText);
    current->add("Name",false,IfcUtil::Argument_STRING,Type::IfcLabel);
    current = entity_descriptor_map[Type::IfcBoundaryCondition] = new IfcEntityDescriptor(Type::IfcBoundaryCondition,0);
    current->add("Name",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current = entity_descriptor_map[Type::IfcBoundaryEdgeCondition] = new IfcEntityDescriptor(Type::IfcBoundaryEdgeCondition,entity_descriptor_map.find(Type::IfcBoundaryCondition)->second);
    current->add("LinearStiffnessByLengthX",true,IfcUtil::Argument_DOUBLE,Type::IfcModulusOfLinearSubgradeReactionMeasure);
    current->add("LinearStiffnessByLengthY",true,IfcUtil::Argument_DOUBLE,Type::IfcModulusOfLinearSubgradeReactionMeasure);
    current->add("LinearStiffnessByLengthZ",true,IfcUtil::Argument_DOUBLE,Type::IfcModulusOfLinearSubgradeReactionMeasure);
    current->add("RotationalStiffnessByLengthX",true,IfcUtil::Argument_DOUBLE,Type::IfcModulusOfRotationalSubgradeReactionMeasure);
    current->add("RotationalStiffnessByLengthY",true,IfcUtil::Argument_DOUBLE,Type::IfcModulusOfRotationalSubgradeReactionMeasure);
    current->add("RotationalStiffnessByLengthZ",true,IfcUtil::Argument_DOUBLE,Type::IfcModulusOfRotationalSubgradeReactionMeasure);
    current = entity_descriptor_map[Type::IfcBoundaryFaceCondition] = new IfcEntityDescriptor(Type::IfcBoundaryFaceCondition,entity_descriptor_map.find(Type::IfcBoundaryCondition)->second);
    current->add("LinearStiffnessByAreaX",true,IfcUtil::Argument_DOUBLE,Type::IfcModulusOfSubgradeReactionMeasure);
    current->add("LinearStiffnessByAreaY",true,IfcUtil::Argument_DOUBLE,Type::IfcModulusOfSubgradeReactionMeasure);
    current->add("LinearStiffnessByAreaZ",true,IfcUtil::Argument_DOUBLE,Type::IfcModulusOfSubgradeReactionMeasure);
    current = entity_descriptor_map[Type::IfcBoundaryNodeCondition] = new IfcEntityDescriptor(Type::IfcBoundaryNodeCondition,entity_descriptor_map.find(Type::IfcBoundaryCondition)->second);
    current->add("LinearStiffnessX",true,IfcUtil::Argument_DOUBLE,Type::IfcLinearStiffnessMeasure);
    current->add("LinearStiffnessY",true,IfcUtil::Argument_DOUBLE,Type::IfcLinearStiffnessMeasure);
    current->add("LinearStiffnessZ",true,IfcUtil::Argument_DOUBLE,Type::IfcLinearStiffnessMeasure);
    current->add("RotationalStiffnessX",true,IfcUtil::Argument_DOUBLE,Type::IfcRotationalStiffnessMeasure);
    current->add("RotationalStiffnessY",true,IfcUtil::Argument_DOUBLE,Type::IfcRotationalStiffnessMeasure);
    current->add("RotationalStiffnessZ",true,IfcUtil::Argument_DOUBLE,Type::IfcRotationalStiffnessMeasure);
    current = entity_descriptor_map[Type::IfcBoundaryNodeConditionWarping] = new IfcEntityDescriptor(Type::IfcBoundaryNodeConditionWarping,entity_descriptor_map.find(Type::IfcBoundaryNodeCondition)->second);
    current->add("WarpingStiffness",true,IfcUtil::Argument_DOUBLE,Type::IfcWarpingMomentMeasure);
    current = entity_descriptor_map[Type::IfcCalendarDate] = new IfcEntityDescriptor(Type::IfcCalendarDate,0);
    current->add("DayComponent",false,IfcUtil::Argument_INT,Type::IfcDayInMonthNumber);
    current->add("MonthComponent",false,IfcUtil::Argument_INT,Type::IfcMonthInYearNumber);
    current->add("YearComponent",false,IfcUtil::Argument_INT,Type::IfcYearNumber);
    current = entity_descriptor_map[Type::IfcClassification] = new IfcEntityDescriptor(Type::IfcClassification,0);
    current->add("Source",false,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("Edition",false,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("EditionDate",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcCalendarDate);
    current->add("Name",false,IfcUtil::Argument_STRING,Type::IfcLabel);
    current = entity_descriptor_map[Type::IfcClassificationItem] = new IfcEntityDescriptor(Type::IfcClassificationItem,0);
    current->add("Notation",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcClassificationNotationFacet);
    current->add("ItemOf",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcClassification);
    current->add("Title",false,IfcUtil::Argument_STRING,Type::IfcLabel);
    current = entity_descriptor_map[Type::IfcClassificationItemRelationship] = new IfcEntityDescriptor(Type::IfcClassificationItemRelationship,0);
    current->add("RelatingItem",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcClassificationItem);
    current->add("RelatedItems",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcClassificationItem);
    current = entity_descriptor_map[Type::IfcClassificationNotation] = new IfcEntityDescriptor(Type::IfcClassificationNotation,0);
    current->add("NotationFacets",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcClassificationNotationFacet);
    current = entity_descriptor_map[Type::IfcClassificationNotationFacet] = new IfcEntityDescriptor(Type::IfcClassificationNotationFacet,0);
    current->add("NotationValue",false,IfcUtil::Argument_STRING,Type::IfcLabel);
    current = entity_descriptor_map[Type::IfcColourSpecification] = new IfcEntityDescriptor(Type::IfcColourSpecification,0);
    current->add("Name",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current = entity_descriptor_map[Type::IfcConnectionGeometry] = new IfcEntityDescriptor(Type::IfcConnectionGeometry,0);

    current = entity_descriptor_map[Type::IfcConnectionPointGeometry] = new IfcEntityDescriptor(Type::IfcConnectionPointGeometry,entity_descriptor_map.find(Type::IfcConnectionGeometry)->second);
    current->add("PointOnRelatingElement",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcPointOrVertexPoint);
    current->add("PointOnRelatedElement",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcPointOrVertexPoint);
    current = entity_descriptor_map[Type::IfcConnectionPortGeometry] = new IfcEntityDescriptor(Type::IfcConnectionPortGeometry,entity_descriptor_map.find(Type::IfcConnectionGeometry)->second);
    current->add("LocationAtRelatingElement",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcAxis2Placement);
    current->add("LocationAtRelatedElement",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcAxis2Placement);
    current->add("ProfileOfPort",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcProfileDef);
    current = entity_descriptor_map[Type::IfcConnectionSurfaceGeometry] = new IfcEntityDescriptor(Type::IfcConnectionSurfaceGeometry,entity_descriptor_map.find(Type::IfcConnectionGeometry)->second);
    current->add("SurfaceOnRelatingElement",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcSurfaceOrFaceSurface);
    current->add("SurfaceOnRelatedElement",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcSurfaceOrFaceSurface);
    current = entity_descriptor_map[Type::IfcConstraint] = new IfcEntityDescriptor(Type::IfcConstraint,0);
    current->add("Name",false,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("Description",true,IfcUtil::Argument_STRING,Type::IfcText);
    current->add("ConstraintGrade",false,IfcUtil::Argument_ENUMERATION,Type::IfcConstraintEnum);
    current->add("ConstraintSource",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("CreatingActor",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcActorSelect);
    current->add("CreationTime",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcDateTimeSelect);
    current->add("UserDefinedGrade",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current = entity_descriptor_map[Type::IfcConstraintAggregationRelationship] = new IfcEntityDescriptor(Type::IfcConstraintAggregationRelationship,0);
    current->add("Name",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("Description",true,IfcUtil::Argument_STRING,Type::IfcText);
    current->add("RelatingConstraint",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcConstraint);
    current->add("RelatedConstraints",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcConstraint);
    current->add("LogicalAggregator",false,IfcUtil::Argument_ENUMERATION,Type::IfcLogicalOperatorEnum);
    current = entity_descriptor_map[Type::IfcConstraintClassificationRelationship] = new IfcEntityDescriptor(Type::IfcConstraintClassificationRelationship,0);
    current->add("ClassifiedConstraint",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcConstraint);
    current->add("RelatedClassifications",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcClassificationNotationSelect);
    current = entity_descriptor_map[Type::IfcConstraintRelationship] = new IfcEntityDescriptor(Type::IfcConstraintRelationship,0);
    current->add("Name",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("Description",true,IfcUtil::Argument_STRING,Type::IfcText);
    current->add("RelatingConstraint",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcConstraint);
    current->add("RelatedConstraints",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcConstraint);
    current = entity_descriptor_map[Type::IfcCoordinatedUniversalTimeOffset] = new IfcEntityDescriptor(Type::IfcCoordinatedUniversalTimeOffset,0);
    current->add("HourOffset",false,IfcUtil::Argument_INT,Type::IfcHourInDay);
    current->add("MinuteOffset",true,IfcUtil::Argument_INT,Type::IfcMinuteInHour);
    current->add("Sense",false,IfcUtil::Argument_ENUMERATION,Type::IfcAheadOrBehind);
    current = entity_descriptor_map[Type::IfcCostValue] = new IfcEntityDescriptor(Type::IfcCostValue,entity_descriptor_map.find(Type::IfcAppliedValue)->second);
    current->add("CostType",false,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("Condition",true,IfcUtil::Argument_STRING,Type::IfcText);
    current = entity_descriptor_map[Type::IfcCurrencyRelationship] = new IfcEntityDescriptor(Type::IfcCurrencyRelationship,0);
    current->add("RelatingMonetaryUnit",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcMonetaryUnit);
    current->add("RelatedMonetaryUnit",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcMonetaryUnit);
    current->add("ExchangeRate",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveRatioMeasure);
    current->add("RateDateTime",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcDateAndTime);
    current->add("RateSource",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcLibraryInformation);
    current = entity_descriptor_map[Type::IfcCurveStyleFont] = new IfcEntityDescriptor(Type::IfcCurveStyleFont,0);
    current->add("Name",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("PatternList",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcCurveStyleFontPattern);
    current = entity_descriptor_map[Type::IfcCurveStyleFontAndScaling] = new IfcEntityDescriptor(Type::IfcCurveStyleFontAndScaling,0);
    current->add("Name",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("CurveFont",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcCurveStyleFontSelect);
    current->add("CurveFontScaling",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveRatioMeasure);
    current = entity_descriptor_map[Type::IfcCurveStyleFontPattern] = new IfcEntityDescriptor(Type::IfcCurveStyleFontPattern,0);
    current->add("VisibleSegmentLength",false,IfcUtil::Argument_DOUBLE,Type::IfcLengthMeasure);
    current->add("InvisibleSegmentLength",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current = entity_descriptor_map[Type::IfcDateAndTime] = new IfcEntityDescriptor(Type::IfcDateAndTime,0);
    current->add("DateComponent",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcCalendarDate);
    current->add("TimeComponent",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcLocalTime);
    current = entity_descriptor_map[Type::IfcDerivedUnit] = new IfcEntityDescriptor(Type::IfcDerivedUnit,0);
    current->add("Elements",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcDerivedUnitElement);
    current->add("UnitType",false,IfcUtil::Argument_ENUMERATION,Type::IfcDerivedUnitEnum);
    current->add("UserDefinedType",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current = entity_descriptor_map[Type::IfcDerivedUnitElement] = new IfcEntityDescriptor(Type::IfcDerivedUnitElement,0);
    current->add("Unit",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcNamedUnit);
    current->add("Exponent",false,IfcUtil::Argument_INT,Type::UNDEFINED);
    current = entity_descriptor_map[Type::IfcDimensionalExponents] = new IfcEntityDescriptor(Type::IfcDimensionalExponents,0);
    current->add("LengthExponent",false,IfcUtil::Argument_INT,Type::UNDEFINED);
    current->add("MassExponent",false,IfcUtil::Argument_INT,Type::UNDEFINED);
    current->add("TimeExponent",false,IfcUtil::Argument_INT,Type::UNDEFINED);
    current->add("ElectricCurrentExponent",false,IfcUtil::Argument_INT,Type::UNDEFINED);
    current->add("ThermodynamicTemperatureExponent",false,IfcUtil::Argument_INT,Type::UNDEFINED);
    current->add("AmountOfSubstanceExponent",false,IfcUtil::Argument_INT,Type::UNDEFINED);
    current->add("LuminousIntensityExponent",false,IfcUtil::Argument_INT,Type::UNDEFINED);
    current = entity_descriptor_map[Type::IfcDocumentElectronicFormat] = new IfcEntityDescriptor(Type::IfcDocumentElectronicFormat,0);
    current->add("FileExtension",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("MimeContentType",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("MimeSubtype",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current = entity_descriptor_map[Type::IfcDocumentInformation] = new IfcEntityDescriptor(Type::IfcDocumentInformation,0);
    current->add("DocumentId",false,IfcUtil::Argument_STRING,Type::IfcIdentifier);
    current->add("Name",false,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("Description",true,IfcUtil::Argument_STRING,Type::IfcText);
    current->add("DocumentReferences",true,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcDocumentReference);
    current->add("Purpose",true,IfcUtil::Argument_STRING,Type::IfcText);
    current->add("IntendedUse",true,IfcUtil::Argument_STRING,Type::IfcText);
    current->add("Scope",true,IfcUtil::Argument_STRING,Type::IfcText);
    current->add("Revision",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("DocumentOwner",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcActorSelect);
    current->add("Editors",true,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcActorSelect);
    current->add("CreationTime",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcDateAndTime);
    current->add("LastRevisionTime",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcDateAndTime);
    current->add("ElectronicFormat",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcDocumentElectronicFormat);
    current->add("ValidFrom",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcCalendarDate);
    current->add("ValidUntil",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcCalendarDate);
    current->add("Confidentiality",true,IfcUtil::Argument_ENUMERATION,Type::IfcDocumentConfidentialityEnum);
    current->add("Status",true,IfcUtil::Argument_ENUMERATION,Type::IfcDocumentStatusEnum);
    current = entity_descriptor_map[Type::IfcDocumentInformationRelationship] = new IfcEntityDescriptor(Type::IfcDocumentInformationRelationship,0);
    current->add("RelatingDocument",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcDocumentInformation);
    current->add("RelatedDocuments",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcDocumentInformation);
    current->add("RelationshipType",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current = entity_descriptor_map[Type::IfcDraughtingCalloutRelationship] = new IfcEntityDescriptor(Type::IfcDraughtingCalloutRelationship,0);
    current->add("Name",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("Description",true,IfcUtil::Argument_STRING,Type::IfcText);
    current->add("RelatingDraughtingCallout",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcDraughtingCallout);
    current->add("RelatedDraughtingCallout",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcDraughtingCallout);
    current = entity_descriptor_map[Type::IfcEnvironmentalImpactValue] = new IfcEntityDescriptor(Type::IfcEnvironmentalImpactValue,entity_descriptor_map.find(Type::IfcAppliedValue)->second);
    current->add("ImpactType",false,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("Category",false,IfcUtil::Argument_ENUMERATION,Type::IfcEnvironmentalImpactCategoryEnum);
    current->add("UserDefinedCategory",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current = entity_descriptor_map[Type::IfcExternalReference] = new IfcEntityDescriptor(Type::IfcExternalReference,0);
    current->add("Location",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("ItemReference",true,IfcUtil::Argument_STRING,Type::IfcIdentifier);
    current->add("Name",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current = entity_descriptor_map[Type::IfcExternallyDefinedHatchStyle] = new IfcEntityDescriptor(Type::IfcExternallyDefinedHatchStyle,entity_descriptor_map.find(Type::IfcExternalReference)->second);

    current = entity_descriptor_map[Type::IfcExternallyDefinedSurfaceStyle] = new IfcEntityDescriptor(Type::IfcExternallyDefinedSurfaceStyle,entity_descriptor_map.find(Type::IfcExternalReference)->second);

    current = entity_descriptor_map[Type::IfcExternallyDefinedSymbol] = new IfcEntityDescriptor(Type::IfcExternallyDefinedSymbol,entity_descriptor_map.find(Type::IfcExternalReference)->second);

    current = entity_descriptor_map[Type::IfcExternallyDefinedTextFont] = new IfcEntityDescriptor(Type::IfcExternallyDefinedTextFont,entity_descriptor_map.find(Type::IfcExternalReference)->second);

    current = entity_descriptor_map[Type::IfcGridAxis] = new IfcEntityDescriptor(Type::IfcGridAxis,0);
    current->add("AxisTag",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("AxisCurve",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcCurve);
    current->add("SameSense",false,IfcUtil::Argument_BOOL,Type::IfcBoolean);
    current = entity_descriptor_map[Type::IfcIrregularTimeSeriesValue] = new IfcEntityDescriptor(Type::IfcIrregularTimeSeriesValue,0);
    current->add("TimeStamp",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcDateTimeSelect);
    current->add("ListValues",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcValue);
    current = entity_descriptor_map[Type::IfcLibraryInformation] = new IfcEntityDescriptor(Type::IfcLibraryInformation,0);
    current->add("Name",false,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("Version",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("Publisher",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcOrganization);
    current->add("VersionDate",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcCalendarDate);
    current->add("LibraryReference",true,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcLibraryReference);
    current = entity_descriptor_map[Type::IfcLibraryReference] = new IfcEntityDescriptor(Type::IfcLibraryReference,entity_descriptor_map.find(Type::IfcExternalReference)->second);

    current = entity_descriptor_map[Type::IfcLightDistributionData] = new IfcEntityDescriptor(Type::IfcLightDistributionData,0);
    current->add("MainPlaneAngle",false,IfcUtil::Argument_DOUBLE,Type::IfcPlaneAngleMeasure);
    current->add("SecondaryPlaneAngle",false,IfcUtil::Argument_AGGREGATE_OF_DOUBLE,Type::IfcPlaneAngleMeasure);
    current->add("LuminousIntensity",false,IfcUtil::Argument_AGGREGATE_OF_DOUBLE,Type::IfcLuminousIntensityDistributionMeasure);
    current = entity_descriptor_map[Type::IfcLightIntensityDistribution] = new IfcEntityDescriptor(Type::IfcLightIntensityDistribution,0);
    current->add("LightDistributionCurve",false,IfcUtil::Argument_ENUMERATION,Type::IfcLightDistributionCurveEnum);
    current->add("DistributionData",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcLightDistributionData);
    current = entity_descriptor_map[Type::IfcLocalTime] = new IfcEntityDescriptor(Type::IfcLocalTime,0);
    current->add("HourComponent",false,IfcUtil::Argument_INT,Type::IfcHourInDay);
    current->add("MinuteComponent",true,IfcUtil::Argument_INT,Type::IfcMinuteInHour);
    current->add("SecondComponent",true,IfcUtil::Argument_DOUBLE,Type::IfcSecondInMinute);
    current->add("Zone",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcCoordinatedUniversalTimeOffset);
    current->add("DaylightSavingOffset",true,IfcUtil::Argument_INT,Type::IfcDaylightSavingHour);
    current = entity_descriptor_map[Type::IfcMaterial] = new IfcEntityDescriptor(Type::IfcMaterial,0);
    current->add("Name",false,IfcUtil::Argument_STRING,Type::IfcLabel);
    current = entity_descriptor_map[Type::IfcMaterialClassificationRelationship] = new IfcEntityDescriptor(Type::IfcMaterialClassificationRelationship,0);
    current->add("MaterialClassifications",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcClassificationNotationSelect);
    current->add("ClassifiedMaterial",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcMaterial);
    current = entity_descriptor_map[Type::IfcMaterialLayer] = new IfcEntityDescriptor(Type::IfcMaterialLayer,0);
    current->add("Material",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcMaterial);
    current->add("LayerThickness",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("IsVentilated",true,IfcUtil::Argument_BOOL,Type::IfcLogical);
    current = entity_descriptor_map[Type::IfcMaterialLayerSet] = new IfcEntityDescriptor(Type::IfcMaterialLayerSet,0);
    current->add("MaterialLayers",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcMaterialLayer);
    current->add("LayerSetName",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current = entity_descriptor_map[Type::IfcMaterialLayerSetUsage] = new IfcEntityDescriptor(Type::IfcMaterialLayerSetUsage,0);
    current->add("ForLayerSet",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcMaterialLayerSet);
    current->add("LayerSetDirection",false,IfcUtil::Argument_ENUMERATION,Type::IfcLayerSetDirectionEnum);
    current->add("DirectionSense",false,IfcUtil::Argument_ENUMERATION,Type::IfcDirectionSenseEnum);
    current->add("OffsetFromReferenceLine",false,IfcUtil::Argument_DOUBLE,Type::IfcLengthMeasure);
    current = entity_descriptor_map[Type::IfcMaterialList] = new IfcEntityDescriptor(Type::IfcMaterialList,0);
    current->add("Materials",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcMaterial);
    current = entity_descriptor_map[Type::IfcMaterialProperties] = new IfcEntityDescriptor(Type::IfcMaterialProperties,0);
    current->add("Material",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcMaterial);
    current = entity_descriptor_map[Type::IfcMeasureWithUnit] = new IfcEntityDescriptor(Type::IfcMeasureWithUnit,0);
    current->add("ValueComponent",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcValue);
    current->add("UnitComponent",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcUnit);
    current = entity_descriptor_map[Type::IfcMechanicalMaterialProperties] = new IfcEntityDescriptor(Type::IfcMechanicalMaterialProperties,entity_descriptor_map.find(Type::IfcMaterialProperties)->second);
    current->add("DynamicViscosity",true,IfcUtil::Argument_DOUBLE,Type::IfcDynamicViscosityMeasure);
    current->add("YoungModulus",true,IfcUtil::Argument_DOUBLE,Type::IfcModulusOfElasticityMeasure);
    current->add("ShearModulus",true,IfcUtil::Argument_DOUBLE,Type::IfcModulusOfElasticityMeasure);
    current->add("PoissonRatio",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveRatioMeasure);
    current->add("ThermalExpansionCoefficient",true,IfcUtil::Argument_DOUBLE,Type::IfcThermalExpansionCoefficientMeasure);
    current = entity_descriptor_map[Type::IfcMechanicalSteelMaterialProperties] = new IfcEntityDescriptor(Type::IfcMechanicalSteelMaterialProperties,entity_descriptor_map.find(Type::IfcMechanicalMaterialProperties)->second);
    current->add("YieldStress",true,IfcUtil::Argument_DOUBLE,Type::IfcPressureMeasure);
    current->add("UltimateStress",true,IfcUtil::Argument_DOUBLE,Type::IfcPressureMeasure);
    current->add("UltimateStrain",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveRatioMeasure);
    current->add("HardeningModule",true,IfcUtil::Argument_DOUBLE,Type::IfcModulusOfElasticityMeasure);
    current->add("ProportionalStress",true,IfcUtil::Argument_DOUBLE,Type::IfcPressureMeasure);
    current->add("PlasticStrain",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveRatioMeasure);
    current->add("Relaxations",true,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcRelaxation);
    current = entity_descriptor_map[Type::IfcMetric] = new IfcEntityDescriptor(Type::IfcMetric,entity_descriptor_map.find(Type::IfcConstraint)->second);
    current->add("Benchmark",false,IfcUtil::Argument_ENUMERATION,Type::IfcBenchmarkEnum);
    current->add("ValueSource",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("DataValue",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcMetricValueSelect);
    current = entity_descriptor_map[Type::IfcMonetaryUnit] = new IfcEntityDescriptor(Type::IfcMonetaryUnit,0);
    current->add("Currency",false,IfcUtil::Argument_ENUMERATION,Type::IfcCurrencyEnum);
    current = entity_descriptor_map[Type::IfcNamedUnit] = new IfcEntityDescriptor(Type::IfcNamedUnit,0);
    current->add("Dimensions",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcDimensionalExponents);
    current->add("UnitType",false,IfcUtil::Argument_ENUMERATION,Type::IfcUnitEnum);
    current = entity_descriptor_map[Type::IfcObjectPlacement] = new IfcEntityDescriptor(Type::IfcObjectPlacement,0);

    current = entity_descriptor_map[Type::IfcObjective] = new IfcEntityDescriptor(Type::IfcObjective,entity_descriptor_map.find(Type::IfcConstraint)->second);
    current->add("BenchmarkValues",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcMetric);
    current->add("ResultValues",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcMetric);
    current->add("ObjectiveQualifier",false,IfcUtil::Argument_ENUMERATION,Type::IfcObjectiveEnum);
    current->add("UserDefinedQualifier",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current = entity_descriptor_map[Type::IfcOpticalMaterialProperties] = new IfcEntityDescriptor(Type::IfcOpticalMaterialProperties,entity_descriptor_map.find(Type::IfcMaterialProperties)->second);
    current->add("VisibleTransmittance",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveRatioMeasure);
    current->add("SolarTransmittance",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveRatioMeasure);
    current->add("ThermalIrTransmittance",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveRatioMeasure);
    current->add("ThermalIrEmissivityBack",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveRatioMeasure);
    current->add("ThermalIrEmissivityFront",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveRatioMeasure);
    current->add("VisibleReflectanceBack",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveRatioMeasure);
    current->add("VisibleReflectanceFront",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveRatioMeasure);
    current->add("SolarReflectanceFront",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveRatioMeasure);
    current->add("SolarReflectanceBack",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveRatioMeasure);
    current = entity_descriptor_map[Type::IfcOrganization] = new IfcEntityDescriptor(Type::IfcOrganization,0);
    current->add("Id",true,IfcUtil::Argument_STRING,Type::IfcIdentifier);
    current->add("Name",false,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("Description",true,IfcUtil::Argument_STRING,Type::IfcText);
    current->add("Roles",true,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcActorRole);
    current->add("Addresses",true,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcAddress);
    current = entity_descriptor_map[Type::IfcOrganizationRelationship] = new IfcEntityDescriptor(Type::IfcOrganizationRelationship,0);
    current->add("Name",false,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("Description",true,IfcUtil::Argument_STRING,Type::IfcText);
    current->add("RelatingOrganization",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcOrganization);
    current->add("RelatedOrganizations",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcOrganization);
    current = entity_descriptor_map[Type::IfcOwnerHistory] = new IfcEntityDescriptor(Type::IfcOwnerHistory,0);
    current->add("OwningUser",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcPersonAndOrganization);
    current->add("OwningApplication",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcApplication);
    current->add("State",true,IfcUtil::Argument_ENUMERATION,Type::IfcStateEnum);
    current->add("ChangeAction",false,IfcUtil::Argument_ENUMERATION,Type::IfcChangeActionEnum);
    current->add("LastModifiedDate",true,IfcUtil::Argument_INT,Type::IfcTimeStamp);
    current->add("LastModifyingUser",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcPersonAndOrganization);
    current->add("LastModifyingApplication",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcApplication);
    current->add("CreationDate",false,IfcUtil::Argument_INT,Type::IfcTimeStamp);
    current = entity_descriptor_map[Type::IfcPerson] = new IfcEntityDescriptor(Type::IfcPerson,0);
    current->add("Id",true,IfcUtil::Argument_STRING,Type::IfcIdentifier);
    current->add("FamilyName",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("GivenName",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("MiddleNames",true,IfcUtil::Argument_AGGREGATE_OF_STRING,Type::IfcLabel);
    current->add("PrefixTitles",true,IfcUtil::Argument_AGGREGATE_OF_STRING,Type::IfcLabel);
    current->add("SuffixTitles",true,IfcUtil::Argument_AGGREGATE_OF_STRING,Type::IfcLabel);
    current->add("Roles",true,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcActorRole);
    current->add("Addresses",true,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcAddress);
    current = entity_descriptor_map[Type::IfcPersonAndOrganization] = new IfcEntityDescriptor(Type::IfcPersonAndOrganization,0);
    current->add("ThePerson",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcPerson);
    current->add("TheOrganization",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcOrganization);
    current->add("Roles",true,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcActorRole);
    current = entity_descriptor_map[Type::IfcPhysicalQuantity] = new IfcEntityDescriptor(Type::IfcPhysicalQuantity,0);
    current->add("Name",false,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("Description",true,IfcUtil::Argument_STRING,Type::IfcText);
    current = entity_descriptor_map[Type::IfcPhysicalSimpleQuantity] = new IfcEntityDescriptor(Type::IfcPhysicalSimpleQuantity,entity_descriptor_map.find(Type::IfcPhysicalQuantity)->second);
    current->add("Unit",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcNamedUnit);
    current = entity_descriptor_map[Type::IfcPostalAddress] = new IfcEntityDescriptor(Type::IfcPostalAddress,entity_descriptor_map.find(Type::IfcAddress)->second);
    current->add("InternalLocation",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("AddressLines",true,IfcUtil::Argument_AGGREGATE_OF_STRING,Type::IfcLabel);
    current->add("PostalBox",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("Town",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("Region",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("PostalCode",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("Country",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current = entity_descriptor_map[Type::IfcPreDefinedItem] = new IfcEntityDescriptor(Type::IfcPreDefinedItem,0);
    current->add("Name",false,IfcUtil::Argument_STRING,Type::IfcLabel);
    current = entity_descriptor_map[Type::IfcPreDefinedSymbol] = new IfcEntityDescriptor(Type::IfcPreDefinedSymbol,entity_descriptor_map.find(Type::IfcPreDefinedItem)->second);

    current = entity_descriptor_map[Type::IfcPreDefinedTerminatorSymbol] = new IfcEntityDescriptor(Type::IfcPreDefinedTerminatorSymbol,entity_descriptor_map.find(Type::IfcPreDefinedSymbol)->second);

    current = entity_descriptor_map[Type::IfcPreDefinedTextFont] = new IfcEntityDescriptor(Type::IfcPreDefinedTextFont,entity_descriptor_map.find(Type::IfcPreDefinedItem)->second);

    current = entity_descriptor_map[Type::IfcPresentationLayerAssignment] = new IfcEntityDescriptor(Type::IfcPresentationLayerAssignment,0);
    current->add("Name",false,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("Description",true,IfcUtil::Argument_STRING,Type::IfcText);
    current->add("AssignedItems",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcLayeredItem);
    current->add("Identifier",true,IfcUtil::Argument_STRING,Type::IfcIdentifier);
    current = entity_descriptor_map[Type::IfcPresentationLayerWithStyle] = new IfcEntityDescriptor(Type::IfcPresentationLayerWithStyle,entity_descriptor_map.find(Type::IfcPresentationLayerAssignment)->second);
    current->add("LayerOn",false,IfcUtil::Argument_BOOL,Type::UNDEFINED);
    current->add("LayerFrozen",false,IfcUtil::Argument_BOOL,Type::UNDEFINED);
    current->add("LayerBlocked",false,IfcUtil::Argument_BOOL,Type::UNDEFINED);
    current->add("LayerStyles",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcPresentationStyleSelect);
    current = entity_descriptor_map[Type::IfcPresentationStyle] = new IfcEntityDescriptor(Type::IfcPresentationStyle,0);
    current->add("Name",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current = entity_descriptor_map[Type::IfcPresentationStyleAssignment] = new IfcEntityDescriptor(Type::IfcPresentationStyleAssignment,0);
    current->add("Styles",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcPresentationStyleSelect);
    current = entity_descriptor_map[Type::IfcProductRepresentation] = new IfcEntityDescriptor(Type::IfcProductRepresentation,0);
    current->add("Name",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("Description",true,IfcUtil::Argument_STRING,Type::IfcText);
    current->add("Representations",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcRepresentation);
    current = entity_descriptor_map[Type::IfcProductsOfCombustionProperties] = new IfcEntityDescriptor(Type::IfcProductsOfCombustionProperties,entity_descriptor_map.find(Type::IfcMaterialProperties)->second);
    current->add("SpecificHeatCapacity",true,IfcUtil::Argument_DOUBLE,Type::IfcSpecificHeatCapacityMeasure);
    current->add("N20Content",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveRatioMeasure);
    current->add("COContent",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveRatioMeasure);
    current->add("CO2Content",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveRatioMeasure);
    current = entity_descriptor_map[Type::IfcProfileDef] = new IfcEntityDescriptor(Type::IfcProfileDef,0);
    current->add("ProfileType",false,IfcUtil::Argument_ENUMERATION,Type::IfcProfileTypeEnum);
    current->add("ProfileName",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current = entity_descriptor_map[Type::IfcProfileProperties] = new IfcEntityDescriptor(Type::IfcProfileProperties,0);
    current->add("ProfileName",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("ProfileDefinition",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcProfileDef);
    current = entity_descriptor_map[Type::IfcProperty] = new IfcEntityDescriptor(Type::IfcProperty,0);
    current->add("Name",false,IfcUtil::Argument_STRING,Type::IfcIdentifier);
    current->add("Description",true,IfcUtil::Argument_STRING,Type::IfcText);
    current = entity_descriptor_map[Type::IfcPropertyConstraintRelationship] = new IfcEntityDescriptor(Type::IfcPropertyConstraintRelationship,0);
    current->add("RelatingConstraint",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcConstraint);
    current->add("RelatedProperties",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcProperty);
    current->add("Name",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("Description",true,IfcUtil::Argument_STRING,Type::IfcText);
    current = entity_descriptor_map[Type::IfcPropertyDependencyRelationship] = new IfcEntityDescriptor(Type::IfcPropertyDependencyRelationship,0);
    current->add("DependingProperty",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcProperty);
    current->add("DependantProperty",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcProperty);
    current->add("Name",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("Description",true,IfcUtil::Argument_STRING,Type::IfcText);
    current->add("Expression",true,IfcUtil::Argument_STRING,Type::IfcText);
    current = entity_descriptor_map[Type::IfcPropertyEnumeration] = new IfcEntityDescriptor(Type::IfcPropertyEnumeration,0);
    current->add("Name",false,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("EnumerationValues",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcValue);
    current->add("Unit",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcUnit);
    current = entity_descriptor_map[Type::IfcQuantityArea] = new IfcEntityDescriptor(Type::IfcQuantityArea,entity_descriptor_map.find(Type::IfcPhysicalSimpleQuantity)->second);
    current->add("AreaValue",false,IfcUtil::Argument_DOUBLE,Type::IfcAreaMeasure);
    current = entity_descriptor_map[Type::IfcQuantityCount] = new IfcEntityDescriptor(Type::IfcQuantityCount,entity_descriptor_map.find(Type::IfcPhysicalSimpleQuantity)->second);
    current->add("CountValue",false,IfcUtil::Argument_DOUBLE,Type::IfcCountMeasure);
    current = entity_descriptor_map[Type::IfcQuantityLength] = new IfcEntityDescriptor(Type::IfcQuantityLength,entity_descriptor_map.find(Type::IfcPhysicalSimpleQuantity)->second);
    current->add("LengthValue",false,IfcUtil::Argument_DOUBLE,Type::IfcLengthMeasure);
    current = entity_descriptor_map[Type::IfcQuantityTime] = new IfcEntityDescriptor(Type::IfcQuantityTime,entity_descriptor_map.find(Type::IfcPhysicalSimpleQuantity)->second);
    current->add("TimeValue",false,IfcUtil::Argument_DOUBLE,Type::IfcTimeMeasure);
    current = entity_descriptor_map[Type::IfcQuantityVolume] = new IfcEntityDescriptor(Type::IfcQuantityVolume,entity_descriptor_map.find(Type::IfcPhysicalSimpleQuantity)->second);
    current->add("VolumeValue",false,IfcUtil::Argument_DOUBLE,Type::IfcVolumeMeasure);
    current = entity_descriptor_map[Type::IfcQuantityWeight] = new IfcEntityDescriptor(Type::IfcQuantityWeight,entity_descriptor_map.find(Type::IfcPhysicalSimpleQuantity)->second);
    current->add("WeightValue",false,IfcUtil::Argument_DOUBLE,Type::IfcMassMeasure);
    current = entity_descriptor_map[Type::IfcReferencesValueDocument] = new IfcEntityDescriptor(Type::IfcReferencesValueDocument,0);
    current->add("ReferencedDocument",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcDocumentSelect);
    current->add("ReferencingValues",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcAppliedValue);
    current->add("Name",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("Description",true,IfcUtil::Argument_STRING,Type::IfcText);
    current = entity_descriptor_map[Type::IfcReinforcementBarProperties] = new IfcEntityDescriptor(Type::IfcReinforcementBarProperties,0);
    current->add("TotalCrossSectionArea",false,IfcUtil::Argument_DOUBLE,Type::IfcAreaMeasure);
    current->add("SteelGrade",false,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("BarSurface",true,IfcUtil::Argument_ENUMERATION,Type::IfcReinforcingBarSurfaceEnum);
    current->add("EffectiveDepth",true,IfcUtil::Argument_DOUBLE,Type::IfcLengthMeasure);
    current->add("NominalBarDiameter",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("BarCount",true,IfcUtil::Argument_DOUBLE,Type::IfcCountMeasure);
    current = entity_descriptor_map[Type::IfcRelaxation] = new IfcEntityDescriptor(Type::IfcRelaxation,0);
    current->add("RelaxationValue",false,IfcUtil::Argument_DOUBLE,Type::IfcNormalisedRatioMeasure);
    current->add("InitialStress",false,IfcUtil::Argument_DOUBLE,Type::IfcNormalisedRatioMeasure);
    current = entity_descriptor_map[Type::IfcRepresentation] = new IfcEntityDescriptor(Type::IfcRepresentation,0);
    current->add("ContextOfItems",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcRepresentationContext);
    current->add("RepresentationIdentifier",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("RepresentationType",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("Items",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcRepresentationItem);
    current = entity_descriptor_map[Type::IfcRepresentationContext] = new IfcEntityDescriptor(Type::IfcRepresentationContext,0);
    current->add("ContextIdentifier",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("ContextType",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current = entity_descriptor_map[Type::IfcRepresentationItem] = new IfcEntityDescriptor(Type::IfcRepresentationItem,0);

    current = entity_descriptor_map[Type::IfcRepresentationMap] = new IfcEntityDescriptor(Type::IfcRepresentationMap,0);
    current->add("MappingOrigin",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcAxis2Placement);
    current->add("MappedRepresentation",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcRepresentation);
    current = entity_descriptor_map[Type::IfcRibPlateProfileProperties] = new IfcEntityDescriptor(Type::IfcRibPlateProfileProperties,entity_descriptor_map.find(Type::IfcProfileProperties)->second);
    current->add("Thickness",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("RibHeight",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("RibWidth",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("RibSpacing",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("Direction",false,IfcUtil::Argument_ENUMERATION,Type::IfcRibPlateDirectionEnum);
    current = entity_descriptor_map[Type::IfcRoot] = new IfcEntityDescriptor(Type::IfcRoot,0);
    current->add("GlobalId",false,IfcUtil::Argument_STRING,Type::IfcGloballyUniqueId);
    current->add("OwnerHistory",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcOwnerHistory);
    current->add("Name",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("Description",true,IfcUtil::Argument_STRING,Type::IfcText);
    current = entity_descriptor_map[Type::IfcSIUnit] = new IfcEntityDescriptor(Type::IfcSIUnit,entity_descriptor_map.find(Type::IfcNamedUnit)->second);
    current->add("Prefix",true,IfcUtil::Argument_ENUMERATION,Type::IfcSIPrefix);
    current->add("Name",false,IfcUtil::Argument_ENUMERATION,Type::IfcSIUnitName);
    current = entity_descriptor_map[Type::IfcSectionProperties] = new IfcEntityDescriptor(Type::IfcSectionProperties,0);
    current->add("SectionType",false,IfcUtil::Argument_ENUMERATION,Type::IfcSectionTypeEnum);
    current->add("StartProfile",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcProfileDef);
    current->add("EndProfile",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcProfileDef);
    current = entity_descriptor_map[Type::IfcSectionReinforcementProperties] = new IfcEntityDescriptor(Type::IfcSectionReinforcementProperties,0);
    current->add("LongitudinalStartPosition",false,IfcUtil::Argument_DOUBLE,Type::IfcLengthMeasure);
    current->add("LongitudinalEndPosition",false,IfcUtil::Argument_DOUBLE,Type::IfcLengthMeasure);
    current->add("TransversePosition",true,IfcUtil::Argument_DOUBLE,Type::IfcLengthMeasure);
    current->add("ReinforcementRole",false,IfcUtil::Argument_ENUMERATION,Type::IfcReinforcingBarRoleEnum);
    current->add("SectionDefinition",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcSectionProperties);
    current->add("CrossSectionReinforcementDefinitions",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcReinforcementBarProperties);
    current = entity_descriptor_map[Type::IfcShapeAspect] = new IfcEntityDescriptor(Type::IfcShapeAspect,0);
    current->add("ShapeRepresentations",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcShapeModel);
    current->add("Name",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("Description",true,IfcUtil::Argument_STRING,Type::IfcText);
    current->add("ProductDefinitional",false,IfcUtil::Argument_BOOL,Type::UNDEFINED);
    current->add("PartOfProductDefinitionShape",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcProductDefinitionShape);
    current = entity_descriptor_map[Type::IfcShapeModel] = new IfcEntityDescriptor(Type::IfcShapeModel,entity_descriptor_map.find(Type::IfcRepresentation)->second);

    current = entity_descriptor_map[Type::IfcShapeRepresentation] = new IfcEntityDescriptor(Type::IfcShapeRepresentation,entity_descriptor_map.find(Type::IfcShapeModel)->second);

    current = entity_descriptor_map[Type::IfcSimpleProperty] = new IfcEntityDescriptor(Type::IfcSimpleProperty,entity_descriptor_map.find(Type::IfcProperty)->second);

    current = entity_descriptor_map[Type::IfcStructuralConnectionCondition] = new IfcEntityDescriptor(Type::IfcStructuralConnectionCondition,0);
    current->add("Name",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current = entity_descriptor_map[Type::IfcStructuralLoad] = new IfcEntityDescriptor(Type::IfcStructuralLoad,0);
    current->add("Name",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current = entity_descriptor_map[Type::IfcStructuralLoadStatic] = new IfcEntityDescriptor(Type::IfcStructuralLoadStatic,entity_descriptor_map.find(Type::IfcStructuralLoad)->second);

    current = entity_descriptor_map[Type::IfcStructuralLoadTemperature] = new IfcEntityDescriptor(Type::IfcStructuralLoadTemperature,entity_descriptor_map.find(Type::IfcStructuralLoadStatic)->second);
    current->add("DeltaT_Constant",true,IfcUtil::Argument_DOUBLE,Type::IfcThermodynamicTemperatureMeasure);
    current->add("DeltaT_Y",true,IfcUtil::Argument_DOUBLE,Type::IfcThermodynamicTemperatureMeasure);
    current->add("DeltaT_Z",true,IfcUtil::Argument_DOUBLE,Type::IfcThermodynamicTemperatureMeasure);
    current = entity_descriptor_map[Type::IfcStyleModel] = new IfcEntityDescriptor(Type::IfcStyleModel,entity_descriptor_map.find(Type::IfcRepresentation)->second);

    current = entity_descriptor_map[Type::IfcStyledItem] = new IfcEntityDescriptor(Type::IfcStyledItem,entity_descriptor_map.find(Type::IfcRepresentationItem)->second);
    current->add("Item",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcRepresentationItem);
    current->add("Styles",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcPresentationStyleAssignment);
    current->add("Name",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current = entity_descriptor_map[Type::IfcStyledRepresentation] = new IfcEntityDescriptor(Type::IfcStyledRepresentation,entity_descriptor_map.find(Type::IfcStyleModel)->second);

    current = entity_descriptor_map[Type::IfcSurfaceStyle] = new IfcEntityDescriptor(Type::IfcSurfaceStyle,entity_descriptor_map.find(Type::IfcPresentationStyle)->second);
    current->add("Side",false,IfcUtil::Argument_ENUMERATION,Type::IfcSurfaceSide);
    current->add("Styles",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcSurfaceStyleElementSelect);
    current = entity_descriptor_map[Type::IfcSurfaceStyleLighting] = new IfcEntityDescriptor(Type::IfcSurfaceStyleLighting,0);
    current->add("DiffuseTransmissionColour",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcColourRgb);
    current->add("DiffuseReflectionColour",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcColourRgb);
    current->add("TransmissionColour",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcColourRgb);
    current->add("ReflectanceColour",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcColourRgb);
    current = entity_descriptor_map[Type::IfcSurfaceStyleRefraction] = new IfcEntityDescriptor(Type::IfcSurfaceStyleRefraction,0);
    current->add("RefractionIndex",true,IfcUtil::Argument_DOUBLE,Type::IfcReal);
    current->add("DispersionFactor",true,IfcUtil::Argument_DOUBLE,Type::IfcReal);
    current = entity_descriptor_map[Type::IfcSurfaceStyleShading] = new IfcEntityDescriptor(Type::IfcSurfaceStyleShading,0);
    current->add("SurfaceColour",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcColourRgb);
    current = entity_descriptor_map[Type::IfcSurfaceStyleWithTextures] = new IfcEntityDescriptor(Type::IfcSurfaceStyleWithTextures,0);
    current->add("Textures",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcSurfaceTexture);
    current = entity_descriptor_map[Type::IfcSurfaceTexture] = new IfcEntityDescriptor(Type::IfcSurfaceTexture,0);
    current->add("RepeatS",false,IfcUtil::Argument_BOOL,Type::UNDEFINED);
    current->add("RepeatT",false,IfcUtil::Argument_BOOL,Type::UNDEFINED);
    current->add("TextureType",false,IfcUtil::Argument_ENUMERATION,Type::IfcSurfaceTextureEnum);
    current->add("TextureTransform",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcCartesianTransformationOperator2D);
    current = entity_descriptor_map[Type::IfcSymbolStyle] = new IfcEntityDescriptor(Type::IfcSymbolStyle,entity_descriptor_map.find(Type::IfcPresentationStyle)->second);
    current->add("StyleOfSymbol",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcSymbolStyleSelect);
    current = entity_descriptor_map[Type::IfcTable] = new IfcEntityDescriptor(Type::IfcTable,0);
    current->add("Name",false,IfcUtil::Argument_STRING,Type::UNDEFINED);
    current->add("Rows",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcTableRow);
    current = entity_descriptor_map[Type::IfcTableRow] = new IfcEntityDescriptor(Type::IfcTableRow,0);
    current->add("RowCells",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcValue);
    current->add("IsHeading",false,IfcUtil::Argument_BOOL,Type::UNDEFINED);
    current = entity_descriptor_map[Type::IfcTelecomAddress] = new IfcEntityDescriptor(Type::IfcTelecomAddress,entity_descriptor_map.find(Type::IfcAddress)->second);
    current->add("TelephoneNumbers",true,IfcUtil::Argument_AGGREGATE_OF_STRING,Type::IfcLabel);
    current->add("FacsimileNumbers",true,IfcUtil::Argument_AGGREGATE_OF_STRING,Type::IfcLabel);
    current->add("PagerNumber",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("ElectronicMailAddresses",true,IfcUtil::Argument_AGGREGATE_OF_STRING,Type::IfcLabel);
    current->add("WWWHomePageURL",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current = entity_descriptor_map[Type::IfcTextStyle] = new IfcEntityDescriptor(Type::IfcTextStyle,entity_descriptor_map.find(Type::IfcPresentationStyle)->second);
    current->add("TextCharacterAppearance",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcCharacterStyleSelect);
    current->add("TextStyle",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcTextStyleSelect);
    current->add("TextFontStyle",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcTextFontSelect);
    current = entity_descriptor_map[Type::IfcTextStyleFontModel] = new IfcEntityDescriptor(Type::IfcTextStyleFontModel,entity_descriptor_map.find(Type::IfcPreDefinedTextFont)->second);
    current->add("FontFamily",true,IfcUtil::Argument_AGGREGATE_OF_STRING,Type::IfcTextFontName);
    current->add("FontStyle",true,IfcUtil::Argument_STRING,Type::IfcFontStyle);
    current->add("FontVariant",true,IfcUtil::Argument_STRING,Type::IfcFontVariant);
    current->add("FontWeight",true,IfcUtil::Argument_STRING,Type::IfcFontWeight);
    current->add("FontSize",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcSizeSelect);
    current = entity_descriptor_map[Type::IfcTextStyleForDefinedFont] = new IfcEntityDescriptor(Type::IfcTextStyleForDefinedFont,0);
    current->add("Colour",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcColour);
    current->add("BackgroundColour",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcColour);
    current = entity_descriptor_map[Type::IfcTextStyleTextModel] = new IfcEntityDescriptor(Type::IfcTextStyleTextModel,0);
    current->add("TextIndent",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcSizeSelect);
    current->add("TextAlign",true,IfcUtil::Argument_STRING,Type::IfcTextAlignment);
    current->add("TextDecoration",true,IfcUtil::Argument_STRING,Type::IfcTextDecoration);
    current->add("LetterSpacing",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcSizeSelect);
    current->add("WordSpacing",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcSizeSelect);
    current->add("TextTransform",true,IfcUtil::Argument_STRING,Type::IfcTextTransformation);
    current->add("LineHeight",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcSizeSelect);
    current = entity_descriptor_map[Type::IfcTextStyleWithBoxCharacteristics] = new IfcEntityDescriptor(Type::IfcTextStyleWithBoxCharacteristics,0);
    current->add("BoxHeight",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("BoxWidth",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("BoxSlantAngle",true,IfcUtil::Argument_DOUBLE,Type::IfcPlaneAngleMeasure);
    current->add("BoxRotateAngle",true,IfcUtil::Argument_DOUBLE,Type::IfcPlaneAngleMeasure);
    current->add("CharacterSpacing",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcSizeSelect);
    current = entity_descriptor_map[Type::IfcTextureCoordinate] = new IfcEntityDescriptor(Type::IfcTextureCoordinate,0);

    current = entity_descriptor_map[Type::IfcTextureCoordinateGenerator] = new IfcEntityDescriptor(Type::IfcTextureCoordinateGenerator,entity_descriptor_map.find(Type::IfcTextureCoordinate)->second);
    current->add("Mode",false,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("Parameter",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcSimpleValue);
    current = entity_descriptor_map[Type::IfcTextureMap] = new IfcEntityDescriptor(Type::IfcTextureMap,entity_descriptor_map.find(Type::IfcTextureCoordinate)->second);
    current->add("TextureMaps",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcVertexBasedTextureMap);
    current = entity_descriptor_map[Type::IfcTextureVertex] = new IfcEntityDescriptor(Type::IfcTextureVertex,0);
    current->add("Coordinates",false,IfcUtil::Argument_AGGREGATE_OF_DOUBLE,Type::IfcParameterValue);
    current = entity_descriptor_map[Type::IfcThermalMaterialProperties] = new IfcEntityDescriptor(Type::IfcThermalMaterialProperties,entity_descriptor_map.find(Type::IfcMaterialProperties)->second);
    current->add("SpecificHeatCapacity",true,IfcUtil::Argument_DOUBLE,Type::IfcSpecificHeatCapacityMeasure);
    current->add("BoilingPoint",true,IfcUtil::Argument_DOUBLE,Type::IfcThermodynamicTemperatureMeasure);
    current->add("FreezingPoint",true,IfcUtil::Argument_DOUBLE,Type::IfcThermodynamicTemperatureMeasure);
    current->add("ThermalConductivity",true,IfcUtil::Argument_DOUBLE,Type::IfcThermalConductivityMeasure);
    current = entity_descriptor_map[Type::IfcTimeSeries] = new IfcEntityDescriptor(Type::IfcTimeSeries,0);
    current->add("Name",false,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("Description",true,IfcUtil::Argument_STRING,Type::IfcText);
    current->add("StartTime",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcDateTimeSelect);
    current->add("EndTime",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcDateTimeSelect);
    current->add("TimeSeriesDataType",false,IfcUtil::Argument_ENUMERATION,Type::IfcTimeSeriesDataTypeEnum);
    current->add("DataOrigin",false,IfcUtil::Argument_ENUMERATION,Type::IfcDataOriginEnum);
    current->add("UserDefinedDataOrigin",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("Unit",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcUnit);
    current = entity_descriptor_map[Type::IfcTimeSeriesReferenceRelationship] = new IfcEntityDescriptor(Type::IfcTimeSeriesReferenceRelationship,0);
    current->add("ReferencedTimeSeries",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcTimeSeries);
    current->add("TimeSeriesReferences",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcDocumentSelect);
    current = entity_descriptor_map[Type::IfcTimeSeriesValue] = new IfcEntityDescriptor(Type::IfcTimeSeriesValue,0);
    current->add("ListValues",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcValue);
    current = entity_descriptor_map[Type::IfcTopologicalRepresentationItem] = new IfcEntityDescriptor(Type::IfcTopologicalRepresentationItem,entity_descriptor_map.find(Type::IfcRepresentationItem)->second);

    current = entity_descriptor_map[Type::IfcTopologyRepresentation] = new IfcEntityDescriptor(Type::IfcTopologyRepresentation,entity_descriptor_map.find(Type::IfcShapeModel)->second);

    current = entity_descriptor_map[Type::IfcUnitAssignment] = new IfcEntityDescriptor(Type::IfcUnitAssignment,0);
    current->add("Units",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcUnit);
    current = entity_descriptor_map[Type::IfcVertex] = new IfcEntityDescriptor(Type::IfcVertex,entity_descriptor_map.find(Type::IfcTopologicalRepresentationItem)->second);

    current = entity_descriptor_map[Type::IfcVertexBasedTextureMap] = new IfcEntityDescriptor(Type::IfcVertexBasedTextureMap,0);
    current->add("TextureVertices",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcTextureVertex);
    current->add("TexturePoints",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcCartesianPoint);
    current = entity_descriptor_map[Type::IfcVertexPoint] = new IfcEntityDescriptor(Type::IfcVertexPoint,entity_descriptor_map.find(Type::IfcVertex)->second);
    current->add("VertexGeometry",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcPoint);
    current = entity_descriptor_map[Type::IfcVirtualGridIntersection] = new IfcEntityDescriptor(Type::IfcVirtualGridIntersection,0);
    current->add("IntersectingAxes",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcGridAxis);
    current->add("OffsetDistances",false,IfcUtil::Argument_AGGREGATE_OF_DOUBLE,Type::IfcLengthMeasure);
    current = entity_descriptor_map[Type::IfcWaterProperties] = new IfcEntityDescriptor(Type::IfcWaterProperties,entity_descriptor_map.find(Type::IfcMaterialProperties)->second);
    current->add("IsPotable",true,IfcUtil::Argument_BOOL,Type::UNDEFINED);
    current->add("Hardness",true,IfcUtil::Argument_DOUBLE,Type::IfcIonConcentrationMeasure);
    current->add("AlkalinityConcentration",true,IfcUtil::Argument_DOUBLE,Type::IfcIonConcentrationMeasure);
    current->add("AcidityConcentration",true,IfcUtil::Argument_DOUBLE,Type::IfcIonConcentrationMeasure);
    current->add("ImpuritiesContent",true,IfcUtil::Argument_DOUBLE,Type::IfcNormalisedRatioMeasure);
    current->add("PHLevel",true,IfcUtil::Argument_DOUBLE,Type::IfcPHMeasure);
    current->add("DissolvedSolidsContent",true,IfcUtil::Argument_DOUBLE,Type::IfcNormalisedRatioMeasure);
    current = entity_descriptor_map[Type::IfcAnnotationOccurrence] = new IfcEntityDescriptor(Type::IfcAnnotationOccurrence,entity_descriptor_map.find(Type::IfcStyledItem)->second);

    current = entity_descriptor_map[Type::IfcAnnotationSurfaceOccurrence] = new IfcEntityDescriptor(Type::IfcAnnotationSurfaceOccurrence,entity_descriptor_map.find(Type::IfcAnnotationOccurrence)->second);

    current = entity_descriptor_map[Type::IfcAnnotationSymbolOccurrence] = new IfcEntityDescriptor(Type::IfcAnnotationSymbolOccurrence,entity_descriptor_map.find(Type::IfcAnnotationOccurrence)->second);

    current = entity_descriptor_map[Type::IfcAnnotationTextOccurrence] = new IfcEntityDescriptor(Type::IfcAnnotationTextOccurrence,entity_descriptor_map.find(Type::IfcAnnotationOccurrence)->second);

    current = entity_descriptor_map[Type::IfcArbitraryClosedProfileDef] = new IfcEntityDescriptor(Type::IfcArbitraryClosedProfileDef,entity_descriptor_map.find(Type::IfcProfileDef)->second);
    current->add("OuterCurve",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcCurve);
    current = entity_descriptor_map[Type::IfcArbitraryOpenProfileDef] = new IfcEntityDescriptor(Type::IfcArbitraryOpenProfileDef,entity_descriptor_map.find(Type::IfcProfileDef)->second);
    current->add("Curve",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcBoundedCurve);
    current = entity_descriptor_map[Type::IfcArbitraryProfileDefWithVoids] = new IfcEntityDescriptor(Type::IfcArbitraryProfileDefWithVoids,entity_descriptor_map.find(Type::IfcArbitraryClosedProfileDef)->second);
    current->add("InnerCurves",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcCurve);
    current = entity_descriptor_map[Type::IfcBlobTexture] = new IfcEntityDescriptor(Type::IfcBlobTexture,entity_descriptor_map.find(Type::IfcSurfaceTexture)->second);
    current->add("RasterFormat",false,IfcUtil::Argument_STRING,Type::IfcIdentifier);
    current->add("RasterCode",false,IfcUtil::Argument_BOOL,Type::UNDEFINED);
    current = entity_descriptor_map[Type::IfcCenterLineProfileDef] = new IfcEntityDescriptor(Type::IfcCenterLineProfileDef,entity_descriptor_map.find(Type::IfcArbitraryOpenProfileDef)->second);
    current->add("Thickness",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current = entity_descriptor_map[Type::IfcClassificationReference] = new IfcEntityDescriptor(Type::IfcClassificationReference,entity_descriptor_map.find(Type::IfcExternalReference)->second);
    current->add("ReferencedSource",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcClassification);
    current = entity_descriptor_map[Type::IfcColourRgb] = new IfcEntityDescriptor(Type::IfcColourRgb,entity_descriptor_map.find(Type::IfcColourSpecification)->second);
    current->add("Red",false,IfcUtil::Argument_DOUBLE,Type::IfcNormalisedRatioMeasure);
    current->add("Green",false,IfcUtil::Argument_DOUBLE,Type::IfcNormalisedRatioMeasure);
    current->add("Blue",false,IfcUtil::Argument_DOUBLE,Type::IfcNormalisedRatioMeasure);
    current = entity_descriptor_map[Type::IfcComplexProperty] = new IfcEntityDescriptor(Type::IfcComplexProperty,entity_descriptor_map.find(Type::IfcProperty)->second);
    current->add("UsageName",false,IfcUtil::Argument_STRING,Type::IfcIdentifier);
    current->add("HasProperties",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcProperty);
    current = entity_descriptor_map[Type::IfcCompositeProfileDef] = new IfcEntityDescriptor(Type::IfcCompositeProfileDef,entity_descriptor_map.find(Type::IfcProfileDef)->second);
    current->add("Profiles",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcProfileDef);
    current->add("Label",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current = entity_descriptor_map[Type::IfcConnectedFaceSet] = new IfcEntityDescriptor(Type::IfcConnectedFaceSet,entity_descriptor_map.find(Type::IfcTopologicalRepresentationItem)->second);
    current->add("CfsFaces",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcFace);
    current = entity_descriptor_map[Type::IfcConnectionCurveGeometry] = new IfcEntityDescriptor(Type::IfcConnectionCurveGeometry,entity_descriptor_map.find(Type::IfcConnectionGeometry)->second);
    current->add("CurveOnRelatingElement",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcCurveOrEdgeCurve);
    current->add("CurveOnRelatedElement",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcCurveOrEdgeCurve);
    current = entity_descriptor_map[Type::IfcConnectionPointEccentricity] = new IfcEntityDescriptor(Type::IfcConnectionPointEccentricity,entity_descriptor_map.find(Type::IfcConnectionPointGeometry)->second);
    current->add("EccentricityInX",true,IfcUtil::Argument_DOUBLE,Type::IfcLengthMeasure);
    current->add("EccentricityInY",true,IfcUtil::Argument_DOUBLE,Type::IfcLengthMeasure);
    current->add("EccentricityInZ",true,IfcUtil::Argument_DOUBLE,Type::IfcLengthMeasure);
    current = entity_descriptor_map[Type::IfcContextDependentUnit] = new IfcEntityDescriptor(Type::IfcContextDependentUnit,entity_descriptor_map.find(Type::IfcNamedUnit)->second);
    current->add("Name",false,IfcUtil::Argument_STRING,Type::IfcLabel);
    current = entity_descriptor_map[Type::IfcConversionBasedUnit] = new IfcEntityDescriptor(Type::IfcConversionBasedUnit,entity_descriptor_map.find(Type::IfcNamedUnit)->second);
    current->add("Name",false,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("ConversionFactor",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcMeasureWithUnit);
    current = entity_descriptor_map[Type::IfcCurveStyle] = new IfcEntityDescriptor(Type::IfcCurveStyle,entity_descriptor_map.find(Type::IfcPresentationStyle)->second);
    current->add("CurveFont",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcCurveFontOrScaledCurveFontSelect);
    current->add("CurveWidth",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcSizeSelect);
    current->add("CurveColour",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcColour);
    current = entity_descriptor_map[Type::IfcDerivedProfileDef] = new IfcEntityDescriptor(Type::IfcDerivedProfileDef,entity_descriptor_map.find(Type::IfcProfileDef)->second);
    current->add("ParentProfile",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcProfileDef);
    current->add("Operator",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcCartesianTransformationOperator2D);
    current->add("Label",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current = entity_descriptor_map[Type::IfcDimensionCalloutRelationship] = new IfcEntityDescriptor(Type::IfcDimensionCalloutRelationship,entity_descriptor_map.find(Type::IfcDraughtingCalloutRelationship)->second);

    current = entity_descriptor_map[Type::IfcDimensionPair] = new IfcEntityDescriptor(Type::IfcDimensionPair,entity_descriptor_map.find(Type::IfcDraughtingCalloutRelationship)->second);

    current = entity_descriptor_map[Type::IfcDocumentReference] = new IfcEntityDescriptor(Type::IfcDocumentReference,entity_descriptor_map.find(Type::IfcExternalReference)->second);

    current = entity_descriptor_map[Type::IfcDraughtingPreDefinedTextFont] = new IfcEntityDescriptor(Type::IfcDraughtingPreDefinedTextFont,entity_descriptor_map.find(Type::IfcPreDefinedTextFont)->second);

    current = entity_descriptor_map[Type::IfcEdge] = new IfcEntityDescriptor(Type::IfcEdge,entity_descriptor_map.find(Type::IfcTopologicalRepresentationItem)->second);
    current->add("EdgeStart",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcVertex);
    current->add("EdgeEnd",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcVertex);
    current = entity_descriptor_map[Type::IfcEdgeCurve] = new IfcEntityDescriptor(Type::IfcEdgeCurve,entity_descriptor_map.find(Type::IfcEdge)->second);
    current->add("EdgeGeometry",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcCurve);
    current->add("SameSense",false,IfcUtil::Argument_BOOL,Type::UNDEFINED);
    current = entity_descriptor_map[Type::IfcExtendedMaterialProperties] = new IfcEntityDescriptor(Type::IfcExtendedMaterialProperties,entity_descriptor_map.find(Type::IfcMaterialProperties)->second);
    current->add("ExtendedProperties",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcProperty);
    current->add("Description",true,IfcUtil::Argument_STRING,Type::IfcText);
    current->add("Name",false,IfcUtil::Argument_STRING,Type::IfcLabel);
    current = entity_descriptor_map[Type::IfcFace] = new IfcEntityDescriptor(Type::IfcFace,entity_descriptor_map.find(Type::IfcTopologicalRepresentationItem)->second);
    current->add("Bounds",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcFaceBound);
    current = entity_descriptor_map[Type::IfcFaceBound] = new IfcEntityDescriptor(Type::IfcFaceBound,entity_descriptor_map.find(Type::IfcTopologicalRepresentationItem)->second);
    current->add("Bound",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcLoop);
    current->add("Orientation",false,IfcUtil::Argument_BOOL,Type::UNDEFINED);
    current = entity_descriptor_map[Type::IfcFaceOuterBound] = new IfcEntityDescriptor(Type::IfcFaceOuterBound,entity_descriptor_map.find(Type::IfcFaceBound)->second);

    current = entity_descriptor_map[Type::IfcFaceSurface] = new IfcEntityDescriptor(Type::IfcFaceSurface,entity_descriptor_map.find(Type::IfcFace)->second);
    current->add("FaceSurface",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcSurface);
    current->add("SameSense",false,IfcUtil::Argument_BOOL,Type::UNDEFINED);
    current = entity_descriptor_map[Type::IfcFailureConnectionCondition] = new IfcEntityDescriptor(Type::IfcFailureConnectionCondition,entity_descriptor_map.find(Type::IfcStructuralConnectionCondition)->second);
    current->add("TensionFailureX",true,IfcUtil::Argument_DOUBLE,Type::IfcForceMeasure);
    current->add("TensionFailureY",true,IfcUtil::Argument_DOUBLE,Type::IfcForceMeasure);
    current->add("TensionFailureZ",true,IfcUtil::Argument_DOUBLE,Type::IfcForceMeasure);
    current->add("CompressionFailureX",true,IfcUtil::Argument_DOUBLE,Type::IfcForceMeasure);
    current->add("CompressionFailureY",true,IfcUtil::Argument_DOUBLE,Type::IfcForceMeasure);
    current->add("CompressionFailureZ",true,IfcUtil::Argument_DOUBLE,Type::IfcForceMeasure);
    current = entity_descriptor_map[Type::IfcFillAreaStyle] = new IfcEntityDescriptor(Type::IfcFillAreaStyle,entity_descriptor_map.find(Type::IfcPresentationStyle)->second);
    current->add("FillStyles",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcFillStyleSelect);
    current = entity_descriptor_map[Type::IfcFuelProperties] = new IfcEntityDescriptor(Type::IfcFuelProperties,entity_descriptor_map.find(Type::IfcMaterialProperties)->second);
    current->add("CombustionTemperature",true,IfcUtil::Argument_DOUBLE,Type::IfcThermodynamicTemperatureMeasure);
    current->add("CarbonContent",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveRatioMeasure);
    current->add("LowerHeatingValue",true,IfcUtil::Argument_DOUBLE,Type::IfcHeatingValueMeasure);
    current->add("HigherHeatingValue",true,IfcUtil::Argument_DOUBLE,Type::IfcHeatingValueMeasure);
    current = entity_descriptor_map[Type::IfcGeneralMaterialProperties] = new IfcEntityDescriptor(Type::IfcGeneralMaterialProperties,entity_descriptor_map.find(Type::IfcMaterialProperties)->second);
    current->add("MolecularWeight",true,IfcUtil::Argument_DOUBLE,Type::IfcMolecularWeightMeasure);
    current->add("Porosity",true,IfcUtil::Argument_DOUBLE,Type::IfcNormalisedRatioMeasure);
    current->add("MassDensity",true,IfcUtil::Argument_DOUBLE,Type::IfcMassDensityMeasure);
    current = entity_descriptor_map[Type::IfcGeneralProfileProperties] = new IfcEntityDescriptor(Type::IfcGeneralProfileProperties,entity_descriptor_map.find(Type::IfcProfileProperties)->second);
    current->add("PhysicalWeight",true,IfcUtil::Argument_DOUBLE,Type::IfcMassPerLengthMeasure);
    current->add("Perimeter",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("MinimumPlateThickness",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("MaximumPlateThickness",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("CrossSectionArea",true,IfcUtil::Argument_DOUBLE,Type::IfcAreaMeasure);
    current = entity_descriptor_map[Type::IfcGeometricRepresentationContext] = new IfcEntityDescriptor(Type::IfcGeometricRepresentationContext,entity_descriptor_map.find(Type::IfcRepresentationContext)->second);
    current->add("CoordinateSpaceDimension",false,IfcUtil::Argument_INT,Type::IfcDimensionCount);
    current->add("Precision",true,IfcUtil::Argument_DOUBLE,Type::UNDEFINED);
    current->add("WorldCoordinateSystem",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcAxis2Placement);
    current->add("TrueNorth",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcDirection);
    current = entity_descriptor_map[Type::IfcGeometricRepresentationItem] = new IfcEntityDescriptor(Type::IfcGeometricRepresentationItem,entity_descriptor_map.find(Type::IfcRepresentationItem)->second);

    current = entity_descriptor_map[Type::IfcGeometricRepresentationSubContext] = new IfcEntityDescriptor(Type::IfcGeometricRepresentationSubContext,entity_descriptor_map.find(Type::IfcGeometricRepresentationContext)->second);
    current->add("ParentContext",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcGeometricRepresentationContext);
    current->add("TargetScale",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveRatioMeasure);
    current->add("TargetView",false,IfcUtil::Argument_ENUMERATION,Type::IfcGeometricProjectionEnum);
    current->add("UserDefinedTargetView",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current = entity_descriptor_map[Type::IfcGeometricSet] = new IfcEntityDescriptor(Type::IfcGeometricSet,entity_descriptor_map.find(Type::IfcGeometricRepresentationItem)->second);
    current->add("Elements",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcGeometricSetSelect);
    current = entity_descriptor_map[Type::IfcGridPlacement] = new IfcEntityDescriptor(Type::IfcGridPlacement,entity_descriptor_map.find(Type::IfcObjectPlacement)->second);
    current->add("PlacementLocation",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcVirtualGridIntersection);
    current->add("PlacementRefDirection",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcVirtualGridIntersection);
    current = entity_descriptor_map[Type::IfcHalfSpaceSolid] = new IfcEntityDescriptor(Type::IfcHalfSpaceSolid,entity_descriptor_map.find(Type::IfcGeometricRepresentationItem)->second);
    current->add("BaseSurface",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcSurface);
    current->add("AgreementFlag",false,IfcUtil::Argument_BOOL,Type::UNDEFINED);
    current = entity_descriptor_map[Type::IfcHygroscopicMaterialProperties] = new IfcEntityDescriptor(Type::IfcHygroscopicMaterialProperties,entity_descriptor_map.find(Type::IfcMaterialProperties)->second);
    current->add("UpperVaporResistanceFactor",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveRatioMeasure);
    current->add("LowerVaporResistanceFactor",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveRatioMeasure);
    current->add("IsothermalMoistureCapacity",true,IfcUtil::Argument_DOUBLE,Type::IfcIsothermalMoistureCapacityMeasure);
    current->add("VaporPermeability",true,IfcUtil::Argument_DOUBLE,Type::IfcVaporPermeabilityMeasure);
    current->add("MoistureDiffusivity",true,IfcUtil::Argument_DOUBLE,Type::IfcMoistureDiffusivityMeasure);
    current = entity_descriptor_map[Type::IfcImageTexture] = new IfcEntityDescriptor(Type::IfcImageTexture,entity_descriptor_map.find(Type::IfcSurfaceTexture)->second);
    current->add("UrlReference",false,IfcUtil::Argument_STRING,Type::IfcIdentifier);
    current = entity_descriptor_map[Type::IfcIrregularTimeSeries] = new IfcEntityDescriptor(Type::IfcIrregularTimeSeries,entity_descriptor_map.find(Type::IfcTimeSeries)->second);
    current->add("Values",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcIrregularTimeSeriesValue);
    current = entity_descriptor_map[Type::IfcLightSource] = new IfcEntityDescriptor(Type::IfcLightSource,entity_descriptor_map.find(Type::IfcGeometricRepresentationItem)->second);
    current->add("Name",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("LightColour",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcColourRgb);
    current->add("AmbientIntensity",true,IfcUtil::Argument_DOUBLE,Type::IfcNormalisedRatioMeasure);
    current->add("Intensity",true,IfcUtil::Argument_DOUBLE,Type::IfcNormalisedRatioMeasure);
    current = entity_descriptor_map[Type::IfcLightSourceAmbient] = new IfcEntityDescriptor(Type::IfcLightSourceAmbient,entity_descriptor_map.find(Type::IfcLightSource)->second);

    current = entity_descriptor_map[Type::IfcLightSourceDirectional] = new IfcEntityDescriptor(Type::IfcLightSourceDirectional,entity_descriptor_map.find(Type::IfcLightSource)->second);
    current->add("Orientation",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcDirection);
    current = entity_descriptor_map[Type::IfcLightSourceGoniometric] = new IfcEntityDescriptor(Type::IfcLightSourceGoniometric,entity_descriptor_map.find(Type::IfcLightSource)->second);
    current->add("Position",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcAxis2Placement3D);
    current->add("ColourAppearance",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcColourRgb);
    current->add("ColourTemperature",false,IfcUtil::Argument_DOUBLE,Type::IfcThermodynamicTemperatureMeasure);
    current->add("LuminousFlux",false,IfcUtil::Argument_DOUBLE,Type::IfcLuminousFluxMeasure);
    current->add("LightEmissionSource",false,IfcUtil::Argument_ENUMERATION,Type::IfcLightEmissionSourceEnum);
    current->add("LightDistributionDataSource",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcLightDistributionDataSourceSelect);
    current = entity_descriptor_map[Type::IfcLightSourcePositional] = new IfcEntityDescriptor(Type::IfcLightSourcePositional,entity_descriptor_map.find(Type::IfcLightSource)->second);
    current->add("Position",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcCartesianPoint);
    current->add("Radius",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("ConstantAttenuation",false,IfcUtil::Argument_DOUBLE,Type::IfcReal);
    current->add("DistanceAttenuation",false,IfcUtil::Argument_DOUBLE,Type::IfcReal);
    current->add("QuadricAttenuation",false,IfcUtil::Argument_DOUBLE,Type::IfcReal);
    current = entity_descriptor_map[Type::IfcLightSourceSpot] = new IfcEntityDescriptor(Type::IfcLightSourceSpot,entity_descriptor_map.find(Type::IfcLightSourcePositional)->second);
    current->add("Orientation",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcDirection);
    current->add("ConcentrationExponent",true,IfcUtil::Argument_DOUBLE,Type::IfcReal);
    current->add("SpreadAngle",false,IfcUtil::Argument_DOUBLE,Type::IfcPositivePlaneAngleMeasure);
    current->add("BeamWidthAngle",false,IfcUtil::Argument_DOUBLE,Type::IfcPositivePlaneAngleMeasure);
    current = entity_descriptor_map[Type::IfcLocalPlacement] = new IfcEntityDescriptor(Type::IfcLocalPlacement,entity_descriptor_map.find(Type::IfcObjectPlacement)->second);
    current->add("PlacementRelTo",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcObjectPlacement);
    current->add("RelativePlacement",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcAxis2Placement);
    current = entity_descriptor_map[Type::IfcLoop] = new IfcEntityDescriptor(Type::IfcLoop,entity_descriptor_map.find(Type::IfcTopologicalRepresentationItem)->second);

    current = entity_descriptor_map[Type::IfcMappedItem] = new IfcEntityDescriptor(Type::IfcMappedItem,entity_descriptor_map.find(Type::IfcRepresentationItem)->second);
    current->add("MappingSource",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcRepresentationMap);
    current->add("MappingTarget",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcCartesianTransformationOperator);
    current = entity_descriptor_map[Type::IfcMaterialDefinitionRepresentation] = new IfcEntityDescriptor(Type::IfcMaterialDefinitionRepresentation,entity_descriptor_map.find(Type::IfcProductRepresentation)->second);
    current->add("RepresentedMaterial",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcMaterial);
    current = entity_descriptor_map[Type::IfcMechanicalConcreteMaterialProperties] = new IfcEntityDescriptor(Type::IfcMechanicalConcreteMaterialProperties,entity_descriptor_map.find(Type::IfcMechanicalMaterialProperties)->second);
    current->add("CompressiveStrength",true,IfcUtil::Argument_DOUBLE,Type::IfcPressureMeasure);
    current->add("MaxAggregateSize",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("AdmixturesDescription",true,IfcUtil::Argument_STRING,Type::IfcText);
    current->add("Workability",true,IfcUtil::Argument_STRING,Type::IfcText);
    current->add("ProtectivePoreRatio",true,IfcUtil::Argument_DOUBLE,Type::IfcNormalisedRatioMeasure);
    current->add("WaterImpermeability",true,IfcUtil::Argument_STRING,Type::IfcText);
    current = entity_descriptor_map[Type::IfcObjectDefinition] = new IfcEntityDescriptor(Type::IfcObjectDefinition,entity_descriptor_map.find(Type::IfcRoot)->second);

    current = entity_descriptor_map[Type::IfcOneDirectionRepeatFactor] = new IfcEntityDescriptor(Type::IfcOneDirectionRepeatFactor,entity_descriptor_map.find(Type::IfcGeometricRepresentationItem)->second);
    current->add("RepeatFactor",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcVector);
    current = entity_descriptor_map[Type::IfcOpenShell] = new IfcEntityDescriptor(Type::IfcOpenShell,entity_descriptor_map.find(Type::IfcConnectedFaceSet)->second);

    current = entity_descriptor_map[Type::IfcOrientedEdge] = new IfcEntityDescriptor(Type::IfcOrientedEdge,entity_descriptor_map.find(Type::IfcEdge)->second);
    current->add("EdgeElement",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcEdge);
    current->add("Orientation",false,IfcUtil::Argument_BOOL,Type::UNDEFINED);
    current = entity_descriptor_map[Type::IfcParameterizedProfileDef] = new IfcEntityDescriptor(Type::IfcParameterizedProfileDef,entity_descriptor_map.find(Type::IfcProfileDef)->second);
    current->add("Position",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcAxis2Placement2D);
    current = entity_descriptor_map[Type::IfcPath] = new IfcEntityDescriptor(Type::IfcPath,entity_descriptor_map.find(Type::IfcTopologicalRepresentationItem)->second);
    current->add("EdgeList",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcOrientedEdge);
    current = entity_descriptor_map[Type::IfcPhysicalComplexQuantity] = new IfcEntityDescriptor(Type::IfcPhysicalComplexQuantity,entity_descriptor_map.find(Type::IfcPhysicalQuantity)->second);
    current->add("HasQuantities",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcPhysicalQuantity);
    current->add("Discrimination",false,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("Quality",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("Usage",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current = entity_descriptor_map[Type::IfcPixelTexture] = new IfcEntityDescriptor(Type::IfcPixelTexture,entity_descriptor_map.find(Type::IfcSurfaceTexture)->second);
    current->add("Width",false,IfcUtil::Argument_INT,Type::IfcInteger);
    current->add("Height",false,IfcUtil::Argument_INT,Type::IfcInteger);
    current->add("ColourComponents",false,IfcUtil::Argument_INT,Type::IfcInteger);
    current->add("Pixel",false,IfcUtil::Argument_AGGREGATE_OF_BINARY,Type::UNDEFINED);
    current = entity_descriptor_map[Type::IfcPlacement] = new IfcEntityDescriptor(Type::IfcPlacement,entity_descriptor_map.find(Type::IfcGeometricRepresentationItem)->second);
    current->add("Location",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcCartesianPoint);
    current = entity_descriptor_map[Type::IfcPlanarExtent] = new IfcEntityDescriptor(Type::IfcPlanarExtent,entity_descriptor_map.find(Type::IfcGeometricRepresentationItem)->second);
    current->add("SizeInX",false,IfcUtil::Argument_DOUBLE,Type::IfcLengthMeasure);
    current->add("SizeInY",false,IfcUtil::Argument_DOUBLE,Type::IfcLengthMeasure);
    current = entity_descriptor_map[Type::IfcPoint] = new IfcEntityDescriptor(Type::IfcPoint,entity_descriptor_map.find(Type::IfcGeometricRepresentationItem)->second);

    current = entity_descriptor_map[Type::IfcPointOnCurve] = new IfcEntityDescriptor(Type::IfcPointOnCurve,entity_descriptor_map.find(Type::IfcPoint)->second);
    current->add("BasisCurve",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcCurve);
    current->add("PointParameter",false,IfcUtil::Argument_DOUBLE,Type::IfcParameterValue);
    current = entity_descriptor_map[Type::IfcPointOnSurface] = new IfcEntityDescriptor(Type::IfcPointOnSurface,entity_descriptor_map.find(Type::IfcPoint)->second);
    current->add("BasisSurface",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcSurface);
    current->add("PointParameterU",false,IfcUtil::Argument_DOUBLE,Type::IfcParameterValue);
    current->add("PointParameterV",false,IfcUtil::Argument_DOUBLE,Type::IfcParameterValue);
    current = entity_descriptor_map[Type::IfcPolyLoop] = new IfcEntityDescriptor(Type::IfcPolyLoop,entity_descriptor_map.find(Type::IfcLoop)->second);
    current->add("Polygon",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcCartesianPoint);
    current = entity_descriptor_map[Type::IfcPolygonalBoundedHalfSpace] = new IfcEntityDescriptor(Type::IfcPolygonalBoundedHalfSpace,entity_descriptor_map.find(Type::IfcHalfSpaceSolid)->second);
    current->add("Position",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcAxis2Placement3D);
    current->add("PolygonalBoundary",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcBoundedCurve);
    current = entity_descriptor_map[Type::IfcPreDefinedColour] = new IfcEntityDescriptor(Type::IfcPreDefinedColour,entity_descriptor_map.find(Type::IfcPreDefinedItem)->second);

    current = entity_descriptor_map[Type::IfcPreDefinedCurveFont] = new IfcEntityDescriptor(Type::IfcPreDefinedCurveFont,entity_descriptor_map.find(Type::IfcPreDefinedItem)->second);

    current = entity_descriptor_map[Type::IfcPreDefinedDimensionSymbol] = new IfcEntityDescriptor(Type::IfcPreDefinedDimensionSymbol,entity_descriptor_map.find(Type::IfcPreDefinedSymbol)->second);

    current = entity_descriptor_map[Type::IfcPreDefinedPointMarkerSymbol] = new IfcEntityDescriptor(Type::IfcPreDefinedPointMarkerSymbol,entity_descriptor_map.find(Type::IfcPreDefinedSymbol)->second);

    current = entity_descriptor_map[Type::IfcProductDefinitionShape] = new IfcEntityDescriptor(Type::IfcProductDefinitionShape,entity_descriptor_map.find(Type::IfcProductRepresentation)->second);

    current = entity_descriptor_map[Type::IfcPropertyBoundedValue] = new IfcEntityDescriptor(Type::IfcPropertyBoundedValue,entity_descriptor_map.find(Type::IfcSimpleProperty)->second);
    current->add("UpperBoundValue",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcValue);
    current->add("LowerBoundValue",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcValue);
    current->add("Unit",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcUnit);
    current = entity_descriptor_map[Type::IfcPropertyDefinition] = new IfcEntityDescriptor(Type::IfcPropertyDefinition,entity_descriptor_map.find(Type::IfcRoot)->second);

    current = entity_descriptor_map[Type::IfcPropertyEnumeratedValue] = new IfcEntityDescriptor(Type::IfcPropertyEnumeratedValue,entity_descriptor_map.find(Type::IfcSimpleProperty)->second);
    current->add("EnumerationValues",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcValue);
    current->add("EnumerationReference",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcPropertyEnumeration);
    current = entity_descriptor_map[Type::IfcPropertyListValue] = new IfcEntityDescriptor(Type::IfcPropertyListValue,entity_descriptor_map.find(Type::IfcSimpleProperty)->second);
    current->add("ListValues",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcValue);
    current->add("Unit",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcUnit);
    current = entity_descriptor_map[Type::IfcPropertyReferenceValue] = new IfcEntityDescriptor(Type::IfcPropertyReferenceValue,entity_descriptor_map.find(Type::IfcSimpleProperty)->second);
    current->add("UsageName",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("PropertyReference",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcObjectReferenceSelect);
    current = entity_descriptor_map[Type::IfcPropertySetDefinition] = new IfcEntityDescriptor(Type::IfcPropertySetDefinition,entity_descriptor_map.find(Type::IfcPropertyDefinition)->second);

    current = entity_descriptor_map[Type::IfcPropertySingleValue] = new IfcEntityDescriptor(Type::IfcPropertySingleValue,entity_descriptor_map.find(Type::IfcSimpleProperty)->second);
    current->add("NominalValue",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcValue);
    current->add("Unit",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcUnit);
    current = entity_descriptor_map[Type::IfcPropertyTableValue] = new IfcEntityDescriptor(Type::IfcPropertyTableValue,entity_descriptor_map.find(Type::IfcSimpleProperty)->second);
    current->add("DefiningValues",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcValue);
    current->add("DefinedValues",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcValue);
    current->add("Expression",true,IfcUtil::Argument_STRING,Type::IfcText);
    current->add("DefiningUnit",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcUnit);
    current->add("DefinedUnit",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcUnit);
    current = entity_descriptor_map[Type::IfcRectangleProfileDef] = new IfcEntityDescriptor(Type::IfcRectangleProfileDef,entity_descriptor_map.find(Type::IfcParameterizedProfileDef)->second);
    current->add("XDim",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("YDim",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current = entity_descriptor_map[Type::IfcRegularTimeSeries] = new IfcEntityDescriptor(Type::IfcRegularTimeSeries,entity_descriptor_map.find(Type::IfcTimeSeries)->second);
    current->add("TimeStep",false,IfcUtil::Argument_DOUBLE,Type::IfcTimeMeasure);
    current->add("Values",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcTimeSeriesValue);
    current = entity_descriptor_map[Type::IfcReinforcementDefinitionProperties] = new IfcEntityDescriptor(Type::IfcReinforcementDefinitionProperties,entity_descriptor_map.find(Type::IfcPropertySetDefinition)->second);
    current->add("DefinitionType",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("ReinforcementSectionDefinitions",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcSectionReinforcementProperties);
    current = entity_descriptor_map[Type::IfcRelationship] = new IfcEntityDescriptor(Type::IfcRelationship,entity_descriptor_map.find(Type::IfcRoot)->second);

    current = entity_descriptor_map[Type::IfcRoundedRectangleProfileDef] = new IfcEntityDescriptor(Type::IfcRoundedRectangleProfileDef,entity_descriptor_map.find(Type::IfcRectangleProfileDef)->second);
    current->add("RoundingRadius",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current = entity_descriptor_map[Type::IfcSectionedSpine] = new IfcEntityDescriptor(Type::IfcSectionedSpine,entity_descriptor_map.find(Type::IfcGeometricRepresentationItem)->second);
    current->add("SpineCurve",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcCompositeCurve);
    current->add("CrossSections",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcProfileDef);
    current->add("CrossSectionPositions",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcAxis2Placement3D);
    current = entity_descriptor_map[Type::IfcServiceLifeFactor] = new IfcEntityDescriptor(Type::IfcServiceLifeFactor,entity_descriptor_map.find(Type::IfcPropertySetDefinition)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcServiceLifeFactorTypeEnum);
    current->add("UpperValue",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcMeasureValue);
    current->add("MostUsedValue",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcMeasureValue);
    current->add("LowerValue",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcMeasureValue);
    current = entity_descriptor_map[Type::IfcShellBasedSurfaceModel] = new IfcEntityDescriptor(Type::IfcShellBasedSurfaceModel,entity_descriptor_map.find(Type::IfcGeometricRepresentationItem)->second);
    current->add("SbsmBoundary",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcShell);
    current = entity_descriptor_map[Type::IfcSlippageConnectionCondition] = new IfcEntityDescriptor(Type::IfcSlippageConnectionCondition,entity_descriptor_map.find(Type::IfcStructuralConnectionCondition)->second);
    current->add("SlippageX",true,IfcUtil::Argument_DOUBLE,Type::IfcLengthMeasure);
    current->add("SlippageY",true,IfcUtil::Argument_DOUBLE,Type::IfcLengthMeasure);
    current->add("SlippageZ",true,IfcUtil::Argument_DOUBLE,Type::IfcLengthMeasure);
    current = entity_descriptor_map[Type::IfcSolidModel] = new IfcEntityDescriptor(Type::IfcSolidModel,entity_descriptor_map.find(Type::IfcGeometricRepresentationItem)->second);

    current = entity_descriptor_map[Type::IfcSoundProperties] = new IfcEntityDescriptor(Type::IfcSoundProperties,entity_descriptor_map.find(Type::IfcPropertySetDefinition)->second);
    current->add("IsAttenuating",false,IfcUtil::Argument_BOOL,Type::IfcBoolean);
    current->add("SoundScale",true,IfcUtil::Argument_ENUMERATION,Type::IfcSoundScaleEnum);
    current->add("SoundValues",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcSoundValue);
    current = entity_descriptor_map[Type::IfcSoundValue] = new IfcEntityDescriptor(Type::IfcSoundValue,entity_descriptor_map.find(Type::IfcPropertySetDefinition)->second);
    current->add("SoundLevelTimeSeries",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcTimeSeries);
    current->add("Frequency",false,IfcUtil::Argument_DOUBLE,Type::IfcFrequencyMeasure);
    current->add("SoundLevelSingleValue",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcDerivedMeasureValue);
    current = entity_descriptor_map[Type::IfcSpaceThermalLoadProperties] = new IfcEntityDescriptor(Type::IfcSpaceThermalLoadProperties,entity_descriptor_map.find(Type::IfcPropertySetDefinition)->second);
    current->add("ApplicableValueRatio",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveRatioMeasure);
    current->add("ThermalLoadSource",false,IfcUtil::Argument_ENUMERATION,Type::IfcThermalLoadSourceEnum);
    current->add("PropertySource",false,IfcUtil::Argument_ENUMERATION,Type::IfcPropertySourceEnum);
    current->add("SourceDescription",true,IfcUtil::Argument_STRING,Type::IfcText);
    current->add("MaximumValue",false,IfcUtil::Argument_DOUBLE,Type::IfcPowerMeasure);
    current->add("MinimumValue",true,IfcUtil::Argument_DOUBLE,Type::IfcPowerMeasure);
    current->add("ThermalLoadTimeSeriesValues",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcTimeSeries);
    current->add("UserDefinedThermalLoadSource",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("UserDefinedPropertySource",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("ThermalLoadType",false,IfcUtil::Argument_ENUMERATION,Type::IfcThermalLoadTypeEnum);
    current = entity_descriptor_map[Type::IfcStructuralLoadLinearForce] = new IfcEntityDescriptor(Type::IfcStructuralLoadLinearForce,entity_descriptor_map.find(Type::IfcStructuralLoadStatic)->second);
    current->add("LinearForceX",true,IfcUtil::Argument_DOUBLE,Type::IfcLinearForceMeasure);
    current->add("LinearForceY",true,IfcUtil::Argument_DOUBLE,Type::IfcLinearForceMeasure);
    current->add("LinearForceZ",true,IfcUtil::Argument_DOUBLE,Type::IfcLinearForceMeasure);
    current->add("LinearMomentX",true,IfcUtil::Argument_DOUBLE,Type::IfcLinearMomentMeasure);
    current->add("LinearMomentY",true,IfcUtil::Argument_DOUBLE,Type::IfcLinearMomentMeasure);
    current->add("LinearMomentZ",true,IfcUtil::Argument_DOUBLE,Type::IfcLinearMomentMeasure);
    current = entity_descriptor_map[Type::IfcStructuralLoadPlanarForce] = new IfcEntityDescriptor(Type::IfcStructuralLoadPlanarForce,entity_descriptor_map.find(Type::IfcStructuralLoadStatic)->second);
    current->add("PlanarForceX",true,IfcUtil::Argument_DOUBLE,Type::IfcPlanarForceMeasure);
    current->add("PlanarForceY",true,IfcUtil::Argument_DOUBLE,Type::IfcPlanarForceMeasure);
    current->add("PlanarForceZ",true,IfcUtil::Argument_DOUBLE,Type::IfcPlanarForceMeasure);
    current = entity_descriptor_map[Type::IfcStructuralLoadSingleDisplacement] = new IfcEntityDescriptor(Type::IfcStructuralLoadSingleDisplacement,entity_descriptor_map.find(Type::IfcStructuralLoadStatic)->second);
    current->add("DisplacementX",true,IfcUtil::Argument_DOUBLE,Type::IfcLengthMeasure);
    current->add("DisplacementY",true,IfcUtil::Argument_DOUBLE,Type::IfcLengthMeasure);
    current->add("DisplacementZ",true,IfcUtil::Argument_DOUBLE,Type::IfcLengthMeasure);
    current->add("RotationalDisplacementRX",true,IfcUtil::Argument_DOUBLE,Type::IfcPlaneAngleMeasure);
    current->add("RotationalDisplacementRY",true,IfcUtil::Argument_DOUBLE,Type::IfcPlaneAngleMeasure);
    current->add("RotationalDisplacementRZ",true,IfcUtil::Argument_DOUBLE,Type::IfcPlaneAngleMeasure);
    current = entity_descriptor_map[Type::IfcStructuralLoadSingleDisplacementDistortion] = new IfcEntityDescriptor(Type::IfcStructuralLoadSingleDisplacementDistortion,entity_descriptor_map.find(Type::IfcStructuralLoadSingleDisplacement)->second);
    current->add("Distortion",true,IfcUtil::Argument_DOUBLE,Type::IfcCurvatureMeasure);
    current = entity_descriptor_map[Type::IfcStructuralLoadSingleForce] = new IfcEntityDescriptor(Type::IfcStructuralLoadSingleForce,entity_descriptor_map.find(Type::IfcStructuralLoadStatic)->second);
    current->add("ForceX",true,IfcUtil::Argument_DOUBLE,Type::IfcForceMeasure);
    current->add("ForceY",true,IfcUtil::Argument_DOUBLE,Type::IfcForceMeasure);
    current->add("ForceZ",true,IfcUtil::Argument_DOUBLE,Type::IfcForceMeasure);
    current->add("MomentX",true,IfcUtil::Argument_DOUBLE,Type::IfcTorqueMeasure);
    current->add("MomentY",true,IfcUtil::Argument_DOUBLE,Type::IfcTorqueMeasure);
    current->add("MomentZ",true,IfcUtil::Argument_DOUBLE,Type::IfcTorqueMeasure);
    current = entity_descriptor_map[Type::IfcStructuralLoadSingleForceWarping] = new IfcEntityDescriptor(Type::IfcStructuralLoadSingleForceWarping,entity_descriptor_map.find(Type::IfcStructuralLoadSingleForce)->second);
    current->add("WarpingMoment",true,IfcUtil::Argument_DOUBLE,Type::IfcWarpingMomentMeasure);
    current = entity_descriptor_map[Type::IfcStructuralProfileProperties] = new IfcEntityDescriptor(Type::IfcStructuralProfileProperties,entity_descriptor_map.find(Type::IfcGeneralProfileProperties)->second);
    current->add("TorsionalConstantX",true,IfcUtil::Argument_DOUBLE,Type::IfcMomentOfInertiaMeasure);
    current->add("MomentOfInertiaYZ",true,IfcUtil::Argument_DOUBLE,Type::IfcMomentOfInertiaMeasure);
    current->add("MomentOfInertiaY",true,IfcUtil::Argument_DOUBLE,Type::IfcMomentOfInertiaMeasure);
    current->add("MomentOfInertiaZ",true,IfcUtil::Argument_DOUBLE,Type::IfcMomentOfInertiaMeasure);
    current->add("WarpingConstant",true,IfcUtil::Argument_DOUBLE,Type::IfcWarpingConstantMeasure);
    current->add("ShearCentreZ",true,IfcUtil::Argument_DOUBLE,Type::IfcLengthMeasure);
    current->add("ShearCentreY",true,IfcUtil::Argument_DOUBLE,Type::IfcLengthMeasure);
    current->add("ShearDeformationAreaZ",true,IfcUtil::Argument_DOUBLE,Type::IfcAreaMeasure);
    current->add("ShearDeformationAreaY",true,IfcUtil::Argument_DOUBLE,Type::IfcAreaMeasure);
    current->add("MaximumSectionModulusY",true,IfcUtil::Argument_DOUBLE,Type::IfcSectionModulusMeasure);
    current->add("MinimumSectionModulusY",true,IfcUtil::Argument_DOUBLE,Type::IfcSectionModulusMeasure);
    current->add("MaximumSectionModulusZ",true,IfcUtil::Argument_DOUBLE,Type::IfcSectionModulusMeasure);
    current->add("MinimumSectionModulusZ",true,IfcUtil::Argument_DOUBLE,Type::IfcSectionModulusMeasure);
    current->add("TorsionalSectionModulus",true,IfcUtil::Argument_DOUBLE,Type::IfcSectionModulusMeasure);
    current->add("CentreOfGravityInX",true,IfcUtil::Argument_DOUBLE,Type::IfcLengthMeasure);
    current->add("CentreOfGravityInY",true,IfcUtil::Argument_DOUBLE,Type::IfcLengthMeasure);
    current = entity_descriptor_map[Type::IfcStructuralSteelProfileProperties] = new IfcEntityDescriptor(Type::IfcStructuralSteelProfileProperties,entity_descriptor_map.find(Type::IfcStructuralProfileProperties)->second);
    current->add("ShearAreaZ",true,IfcUtil::Argument_DOUBLE,Type::IfcAreaMeasure);
    current->add("ShearAreaY",true,IfcUtil::Argument_DOUBLE,Type::IfcAreaMeasure);
    current->add("PlasticShapeFactorY",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveRatioMeasure);
    current->add("PlasticShapeFactorZ",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveRatioMeasure);
    current = entity_descriptor_map[Type::IfcSubedge] = new IfcEntityDescriptor(Type::IfcSubedge,entity_descriptor_map.find(Type::IfcEdge)->second);
    current->add("ParentEdge",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcEdge);
    current = entity_descriptor_map[Type::IfcSurface] = new IfcEntityDescriptor(Type::IfcSurface,entity_descriptor_map.find(Type::IfcGeometricRepresentationItem)->second);

    current = entity_descriptor_map[Type::IfcSurfaceStyleRendering] = new IfcEntityDescriptor(Type::IfcSurfaceStyleRendering,entity_descriptor_map.find(Type::IfcSurfaceStyleShading)->second);
    current->add("Transparency",true,IfcUtil::Argument_DOUBLE,Type::IfcNormalisedRatioMeasure);
    current->add("DiffuseColour",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcColourOrFactor);
    current->add("TransmissionColour",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcColourOrFactor);
    current->add("DiffuseTransmissionColour",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcColourOrFactor);
    current->add("ReflectionColour",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcColourOrFactor);
    current->add("SpecularColour",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcColourOrFactor);
    current->add("SpecularHighlight",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcSpecularHighlightSelect);
    current->add("ReflectanceMethod",false,IfcUtil::Argument_ENUMERATION,Type::IfcReflectanceMethodEnum);
    current = entity_descriptor_map[Type::IfcSweptAreaSolid] = new IfcEntityDescriptor(Type::IfcSweptAreaSolid,entity_descriptor_map.find(Type::IfcSolidModel)->second);
    current->add("SweptArea",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcProfileDef);
    current->add("Position",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcAxis2Placement3D);
    current = entity_descriptor_map[Type::IfcSweptDiskSolid] = new IfcEntityDescriptor(Type::IfcSweptDiskSolid,entity_descriptor_map.find(Type::IfcSolidModel)->second);
    current->add("Directrix",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcCurve);
    current->add("Radius",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("InnerRadius",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("StartParam",false,IfcUtil::Argument_DOUBLE,Type::IfcParameterValue);
    current->add("EndParam",false,IfcUtil::Argument_DOUBLE,Type::IfcParameterValue);
    current = entity_descriptor_map[Type::IfcSweptSurface] = new IfcEntityDescriptor(Type::IfcSweptSurface,entity_descriptor_map.find(Type::IfcSurface)->second);
    current->add("SweptCurve",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcProfileDef);
    current->add("Position",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcAxis2Placement3D);
    current = entity_descriptor_map[Type::IfcTShapeProfileDef] = new IfcEntityDescriptor(Type::IfcTShapeProfileDef,entity_descriptor_map.find(Type::IfcParameterizedProfileDef)->second);
    current->add("Depth",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("FlangeWidth",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("WebThickness",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("FlangeThickness",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("FilletRadius",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("FlangeEdgeRadius",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("WebEdgeRadius",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("WebSlope",true,IfcUtil::Argument_DOUBLE,Type::IfcPlaneAngleMeasure);
    current->add("FlangeSlope",true,IfcUtil::Argument_DOUBLE,Type::IfcPlaneAngleMeasure);
    current->add("CentreOfGravityInY",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current = entity_descriptor_map[Type::IfcTerminatorSymbol] = new IfcEntityDescriptor(Type::IfcTerminatorSymbol,entity_descriptor_map.find(Type::IfcAnnotationSymbolOccurrence)->second);
    current->add("AnnotatedCurve",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcAnnotationCurveOccurrence);
    current = entity_descriptor_map[Type::IfcTextLiteral] = new IfcEntityDescriptor(Type::IfcTextLiteral,entity_descriptor_map.find(Type::IfcGeometricRepresentationItem)->second);
    current->add("Literal",false,IfcUtil::Argument_STRING,Type::IfcPresentableText);
    current->add("Placement",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcAxis2Placement);
    current->add("Path",false,IfcUtil::Argument_ENUMERATION,Type::IfcTextPath);
    current = entity_descriptor_map[Type::IfcTextLiteralWithExtent] = new IfcEntityDescriptor(Type::IfcTextLiteralWithExtent,entity_descriptor_map.find(Type::IfcTextLiteral)->second);
    current->add("Extent",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcPlanarExtent);
    current->add("BoxAlignment",false,IfcUtil::Argument_STRING,Type::IfcBoxAlignment);
    current = entity_descriptor_map[Type::IfcTrapeziumProfileDef] = new IfcEntityDescriptor(Type::IfcTrapeziumProfileDef,entity_descriptor_map.find(Type::IfcParameterizedProfileDef)->second);
    current->add("BottomXDim",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("TopXDim",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("YDim",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("TopXOffset",false,IfcUtil::Argument_DOUBLE,Type::IfcLengthMeasure);
    current = entity_descriptor_map[Type::IfcTwoDirectionRepeatFactor] = new IfcEntityDescriptor(Type::IfcTwoDirectionRepeatFactor,entity_descriptor_map.find(Type::IfcOneDirectionRepeatFactor)->second);
    current->add("SecondRepeatFactor",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcVector);
    current = entity_descriptor_map[Type::IfcTypeObject] = new IfcEntityDescriptor(Type::IfcTypeObject,entity_descriptor_map.find(Type::IfcObjectDefinition)->second);
    current->add("ApplicableOccurrence",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("HasPropertySets",true,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcPropertySetDefinition);
    current = entity_descriptor_map[Type::IfcTypeProduct] = new IfcEntityDescriptor(Type::IfcTypeProduct,entity_descriptor_map.find(Type::IfcTypeObject)->second);
    current->add("RepresentationMaps",true,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcRepresentationMap);
    current->add("Tag",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current = entity_descriptor_map[Type::IfcUShapeProfileDef] = new IfcEntityDescriptor(Type::IfcUShapeProfileDef,entity_descriptor_map.find(Type::IfcParameterizedProfileDef)->second);
    current->add("Depth",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("FlangeWidth",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("WebThickness",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("FlangeThickness",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("FilletRadius",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("EdgeRadius",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("FlangeSlope",true,IfcUtil::Argument_DOUBLE,Type::IfcPlaneAngleMeasure);
    current->add("CentreOfGravityInX",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current = entity_descriptor_map[Type::IfcVector] = new IfcEntityDescriptor(Type::IfcVector,entity_descriptor_map.find(Type::IfcGeometricRepresentationItem)->second);
    current->add("Orientation",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcDirection);
    current->add("Magnitude",false,IfcUtil::Argument_DOUBLE,Type::IfcLengthMeasure);
    current = entity_descriptor_map[Type::IfcVertexLoop] = new IfcEntityDescriptor(Type::IfcVertexLoop,entity_descriptor_map.find(Type::IfcLoop)->second);
    current->add("LoopVertex",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcVertex);
    current = entity_descriptor_map[Type::IfcWindowLiningProperties] = new IfcEntityDescriptor(Type::IfcWindowLiningProperties,entity_descriptor_map.find(Type::IfcPropertySetDefinition)->second);
    current->add("LiningDepth",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("LiningThickness",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("TransomThickness",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("MullionThickness",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("FirstTransomOffset",true,IfcUtil::Argument_DOUBLE,Type::IfcNormalisedRatioMeasure);
    current->add("SecondTransomOffset",true,IfcUtil::Argument_DOUBLE,Type::IfcNormalisedRatioMeasure);
    current->add("FirstMullionOffset",true,IfcUtil::Argument_DOUBLE,Type::IfcNormalisedRatioMeasure);
    current->add("SecondMullionOffset",true,IfcUtil::Argument_DOUBLE,Type::IfcNormalisedRatioMeasure);
    current->add("ShapeAspectStyle",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcShapeAspect);
    current = entity_descriptor_map[Type::IfcWindowPanelProperties] = new IfcEntityDescriptor(Type::IfcWindowPanelProperties,entity_descriptor_map.find(Type::IfcPropertySetDefinition)->second);
    current->add("OperationType",false,IfcUtil::Argument_ENUMERATION,Type::IfcWindowPanelOperationEnum);
    current->add("PanelPosition",false,IfcUtil::Argument_ENUMERATION,Type::IfcWindowPanelPositionEnum);
    current->add("FrameDepth",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("FrameThickness",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("ShapeAspectStyle",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcShapeAspect);
    current = entity_descriptor_map[Type::IfcWindowStyle] = new IfcEntityDescriptor(Type::IfcWindowStyle,entity_descriptor_map.find(Type::IfcTypeProduct)->second);
    current->add("ConstructionType",false,IfcUtil::Argument_ENUMERATION,Type::IfcWindowStyleConstructionEnum);
    current->add("OperationType",false,IfcUtil::Argument_ENUMERATION,Type::IfcWindowStyleOperationEnum);
    current->add("ParameterTakesPrecedence",false,IfcUtil::Argument_BOOL,Type::UNDEFINED);
    current->add("Sizeable",false,IfcUtil::Argument_BOOL,Type::UNDEFINED);
    current = entity_descriptor_map[Type::IfcZShapeProfileDef] = new IfcEntityDescriptor(Type::IfcZShapeProfileDef,entity_descriptor_map.find(Type::IfcParameterizedProfileDef)->second);
    current->add("Depth",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("FlangeWidth",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("WebThickness",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("FlangeThickness",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("FilletRadius",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("EdgeRadius",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current = entity_descriptor_map[Type::IfcAnnotationCurveOccurrence] = new IfcEntityDescriptor(Type::IfcAnnotationCurveOccurrence,entity_descriptor_map.find(Type::IfcAnnotationOccurrence)->second);

    current = entity_descriptor_map[Type::IfcAnnotationFillArea] = new IfcEntityDescriptor(Type::IfcAnnotationFillArea,entity_descriptor_map.find(Type::IfcGeometricRepresentationItem)->second);
    current->add("OuterBoundary",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcCurve);
    current->add("InnerBoundaries",true,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcCurve);
    current = entity_descriptor_map[Type::IfcAnnotationFillAreaOccurrence] = new IfcEntityDescriptor(Type::IfcAnnotationFillAreaOccurrence,entity_descriptor_map.find(Type::IfcAnnotationOccurrence)->second);
    current->add("FillStyleTarget",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcPoint);
    current->add("GlobalOrLocal",true,IfcUtil::Argument_ENUMERATION,Type::IfcGlobalOrLocalEnum);
    current = entity_descriptor_map[Type::IfcAnnotationSurface] = new IfcEntityDescriptor(Type::IfcAnnotationSurface,entity_descriptor_map.find(Type::IfcGeometricRepresentationItem)->second);
    current->add("Item",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcGeometricRepresentationItem);
    current->add("TextureCoordinates",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcTextureCoordinate);
    current = entity_descriptor_map[Type::IfcAxis1Placement] = new IfcEntityDescriptor(Type::IfcAxis1Placement,entity_descriptor_map.find(Type::IfcPlacement)->second);
    current->add("Axis",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcDirection);
    current = entity_descriptor_map[Type::IfcAxis2Placement2D] = new IfcEntityDescriptor(Type::IfcAxis2Placement2D,entity_descriptor_map.find(Type::IfcPlacement)->second);
    current->add("RefDirection",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcDirection);
    current = entity_descriptor_map[Type::IfcAxis2Placement3D] = new IfcEntityDescriptor(Type::IfcAxis2Placement3D,entity_descriptor_map.find(Type::IfcPlacement)->second);
    current->add("Axis",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcDirection);
    current->add("RefDirection",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcDirection);
    current = entity_descriptor_map[Type::IfcBooleanResult] = new IfcEntityDescriptor(Type::IfcBooleanResult,entity_descriptor_map.find(Type::IfcGeometricRepresentationItem)->second);
    current->add("Operator",false,IfcUtil::Argument_ENUMERATION,Type::IfcBooleanOperator);
    current->add("FirstOperand",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcBooleanOperand);
    current->add("SecondOperand",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcBooleanOperand);
    current = entity_descriptor_map[Type::IfcBoundedSurface] = new IfcEntityDescriptor(Type::IfcBoundedSurface,entity_descriptor_map.find(Type::IfcSurface)->second);

    current = entity_descriptor_map[Type::IfcBoundingBox] = new IfcEntityDescriptor(Type::IfcBoundingBox,entity_descriptor_map.find(Type::IfcGeometricRepresentationItem)->second);
    current->add("Corner",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcCartesianPoint);
    current->add("XDim",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("YDim",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("ZDim",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current = entity_descriptor_map[Type::IfcBoxedHalfSpace] = new IfcEntityDescriptor(Type::IfcBoxedHalfSpace,entity_descriptor_map.find(Type::IfcHalfSpaceSolid)->second);
    current->add("Enclosure",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcBoundingBox);
    current = entity_descriptor_map[Type::IfcCShapeProfileDef] = new IfcEntityDescriptor(Type::IfcCShapeProfileDef,entity_descriptor_map.find(Type::IfcParameterizedProfileDef)->second);
    current->add("Depth",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("Width",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("WallThickness",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("Girth",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("InternalFilletRadius",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("CentreOfGravityInX",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current = entity_descriptor_map[Type::IfcCartesianPoint] = new IfcEntityDescriptor(Type::IfcCartesianPoint,entity_descriptor_map.find(Type::IfcPoint)->second);
    current->add("Coordinates",false,IfcUtil::Argument_AGGREGATE_OF_DOUBLE,Type::IfcLengthMeasure);
    current = entity_descriptor_map[Type::IfcCartesianTransformationOperator] = new IfcEntityDescriptor(Type::IfcCartesianTransformationOperator,entity_descriptor_map.find(Type::IfcGeometricRepresentationItem)->second);
    current->add("Axis1",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcDirection);
    current->add("Axis2",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcDirection);
    current->add("LocalOrigin",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcCartesianPoint);
    current->add("Scale",true,IfcUtil::Argument_DOUBLE,Type::UNDEFINED);
    current = entity_descriptor_map[Type::IfcCartesianTransformationOperator2D] = new IfcEntityDescriptor(Type::IfcCartesianTransformationOperator2D,entity_descriptor_map.find(Type::IfcCartesianTransformationOperator)->second);

    current = entity_descriptor_map[Type::IfcCartesianTransformationOperator2DnonUniform] = new IfcEntityDescriptor(Type::IfcCartesianTransformationOperator2DnonUniform,entity_descriptor_map.find(Type::IfcCartesianTransformationOperator2D)->second);
    current->add("Scale2",true,IfcUtil::Argument_DOUBLE,Type::UNDEFINED);
    current = entity_descriptor_map[Type::IfcCartesianTransformationOperator3D] = new IfcEntityDescriptor(Type::IfcCartesianTransformationOperator3D,entity_descriptor_map.find(Type::IfcCartesianTransformationOperator)->second);
    current->add("Axis3",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcDirection);
    current = entity_descriptor_map[Type::IfcCartesianTransformationOperator3DnonUniform] = new IfcEntityDescriptor(Type::IfcCartesianTransformationOperator3DnonUniform,entity_descriptor_map.find(Type::IfcCartesianTransformationOperator3D)->second);
    current->add("Scale2",true,IfcUtil::Argument_DOUBLE,Type::UNDEFINED);
    current->add("Scale3",true,IfcUtil::Argument_DOUBLE,Type::UNDEFINED);
    current = entity_descriptor_map[Type::IfcCircleProfileDef] = new IfcEntityDescriptor(Type::IfcCircleProfileDef,entity_descriptor_map.find(Type::IfcParameterizedProfileDef)->second);
    current->add("Radius",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current = entity_descriptor_map[Type::IfcClosedShell] = new IfcEntityDescriptor(Type::IfcClosedShell,entity_descriptor_map.find(Type::IfcConnectedFaceSet)->second);

    current = entity_descriptor_map[Type::IfcCompositeCurveSegment] = new IfcEntityDescriptor(Type::IfcCompositeCurveSegment,entity_descriptor_map.find(Type::IfcGeometricRepresentationItem)->second);
    current->add("Transition",false,IfcUtil::Argument_ENUMERATION,Type::IfcTransitionCode);
    current->add("SameSense",false,IfcUtil::Argument_BOOL,Type::UNDEFINED);
    current->add("ParentCurve",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcCurve);
    current = entity_descriptor_map[Type::IfcCraneRailAShapeProfileDef] = new IfcEntityDescriptor(Type::IfcCraneRailAShapeProfileDef,entity_descriptor_map.find(Type::IfcParameterizedProfileDef)->second);
    current->add("OverallHeight",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("BaseWidth2",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("Radius",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("HeadWidth",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("HeadDepth2",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("HeadDepth3",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("WebThickness",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("BaseWidth4",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("BaseDepth1",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("BaseDepth2",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("BaseDepth3",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("CentreOfGravityInY",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current = entity_descriptor_map[Type::IfcCraneRailFShapeProfileDef] = new IfcEntityDescriptor(Type::IfcCraneRailFShapeProfileDef,entity_descriptor_map.find(Type::IfcParameterizedProfileDef)->second);
    current->add("OverallHeight",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("HeadWidth",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("Radius",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("HeadDepth2",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("HeadDepth3",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("WebThickness",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("BaseDepth1",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("BaseDepth2",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("CentreOfGravityInY",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current = entity_descriptor_map[Type::IfcCsgPrimitive3D] = new IfcEntityDescriptor(Type::IfcCsgPrimitive3D,entity_descriptor_map.find(Type::IfcGeometricRepresentationItem)->second);
    current->add("Position",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcAxis2Placement3D);
    current = entity_descriptor_map[Type::IfcCsgSolid] = new IfcEntityDescriptor(Type::IfcCsgSolid,entity_descriptor_map.find(Type::IfcSolidModel)->second);
    current->add("TreeRootExpression",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcCsgSelect);
    current = entity_descriptor_map[Type::IfcCurve] = new IfcEntityDescriptor(Type::IfcCurve,entity_descriptor_map.find(Type::IfcGeometricRepresentationItem)->second);

    current = entity_descriptor_map[Type::IfcCurveBoundedPlane] = new IfcEntityDescriptor(Type::IfcCurveBoundedPlane,entity_descriptor_map.find(Type::IfcBoundedSurface)->second);
    current->add("BasisSurface",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcPlane);
    current->add("OuterBoundary",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcCurve);
    current->add("InnerBoundaries",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcCurve);
    current = entity_descriptor_map[Type::IfcDefinedSymbol] = new IfcEntityDescriptor(Type::IfcDefinedSymbol,entity_descriptor_map.find(Type::IfcGeometricRepresentationItem)->second);
    current->add("Definition",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcDefinedSymbolSelect);
    current->add("Target",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcCartesianTransformationOperator2D);
    current = entity_descriptor_map[Type::IfcDimensionCurve] = new IfcEntityDescriptor(Type::IfcDimensionCurve,entity_descriptor_map.find(Type::IfcAnnotationCurveOccurrence)->second);

    current = entity_descriptor_map[Type::IfcDimensionCurveTerminator] = new IfcEntityDescriptor(Type::IfcDimensionCurveTerminator,entity_descriptor_map.find(Type::IfcTerminatorSymbol)->second);
    current->add("Role",false,IfcUtil::Argument_ENUMERATION,Type::IfcDimensionExtentUsage);
    current = entity_descriptor_map[Type::IfcDirection] = new IfcEntityDescriptor(Type::IfcDirection,entity_descriptor_map.find(Type::IfcGeometricRepresentationItem)->second);
    current->add("DirectionRatios",false,IfcUtil::Argument_AGGREGATE_OF_DOUBLE,Type::UNDEFINED);
    current = entity_descriptor_map[Type::IfcDoorLiningProperties] = new IfcEntityDescriptor(Type::IfcDoorLiningProperties,entity_descriptor_map.find(Type::IfcPropertySetDefinition)->second);
    current->add("LiningDepth",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("LiningThickness",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("ThresholdDepth",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("ThresholdThickness",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("TransomThickness",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("TransomOffset",true,IfcUtil::Argument_DOUBLE,Type::IfcLengthMeasure);
    current->add("LiningOffset",true,IfcUtil::Argument_DOUBLE,Type::IfcLengthMeasure);
    current->add("ThresholdOffset",true,IfcUtil::Argument_DOUBLE,Type::IfcLengthMeasure);
    current->add("CasingThickness",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("CasingDepth",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("ShapeAspectStyle",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcShapeAspect);
    current = entity_descriptor_map[Type::IfcDoorPanelProperties] = new IfcEntityDescriptor(Type::IfcDoorPanelProperties,entity_descriptor_map.find(Type::IfcPropertySetDefinition)->second);
    current->add("PanelDepth",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("PanelOperation",false,IfcUtil::Argument_ENUMERATION,Type::IfcDoorPanelOperationEnum);
    current->add("PanelWidth",true,IfcUtil::Argument_DOUBLE,Type::IfcNormalisedRatioMeasure);
    current->add("PanelPosition",false,IfcUtil::Argument_ENUMERATION,Type::IfcDoorPanelPositionEnum);
    current->add("ShapeAspectStyle",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcShapeAspect);
    current = entity_descriptor_map[Type::IfcDoorStyle] = new IfcEntityDescriptor(Type::IfcDoorStyle,entity_descriptor_map.find(Type::IfcTypeProduct)->second);
    current->add("OperationType",false,IfcUtil::Argument_ENUMERATION,Type::IfcDoorStyleOperationEnum);
    current->add("ConstructionType",false,IfcUtil::Argument_ENUMERATION,Type::IfcDoorStyleConstructionEnum);
    current->add("ParameterTakesPrecedence",false,IfcUtil::Argument_BOOL,Type::UNDEFINED);
    current->add("Sizeable",false,IfcUtil::Argument_BOOL,Type::UNDEFINED);
    current = entity_descriptor_map[Type::IfcDraughtingCallout] = new IfcEntityDescriptor(Type::IfcDraughtingCallout,entity_descriptor_map.find(Type::IfcGeometricRepresentationItem)->second);
    current->add("Contents",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcDraughtingCalloutElement);
    current = entity_descriptor_map[Type::IfcDraughtingPreDefinedColour] = new IfcEntityDescriptor(Type::IfcDraughtingPreDefinedColour,entity_descriptor_map.find(Type::IfcPreDefinedColour)->second);

    current = entity_descriptor_map[Type::IfcDraughtingPreDefinedCurveFont] = new IfcEntityDescriptor(Type::IfcDraughtingPreDefinedCurveFont,entity_descriptor_map.find(Type::IfcPreDefinedCurveFont)->second);

    current = entity_descriptor_map[Type::IfcEdgeLoop] = new IfcEntityDescriptor(Type::IfcEdgeLoop,entity_descriptor_map.find(Type::IfcLoop)->second);
    current->add("EdgeList",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcOrientedEdge);
    current = entity_descriptor_map[Type::IfcElementQuantity] = new IfcEntityDescriptor(Type::IfcElementQuantity,entity_descriptor_map.find(Type::IfcPropertySetDefinition)->second);
    current->add("MethodOfMeasurement",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("Quantities",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcPhysicalQuantity);
    current = entity_descriptor_map[Type::IfcElementType] = new IfcEntityDescriptor(Type::IfcElementType,entity_descriptor_map.find(Type::IfcTypeProduct)->second);
    current->add("ElementType",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current = entity_descriptor_map[Type::IfcElementarySurface] = new IfcEntityDescriptor(Type::IfcElementarySurface,entity_descriptor_map.find(Type::IfcSurface)->second);
    current->add("Position",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcAxis2Placement3D);
    current = entity_descriptor_map[Type::IfcEllipseProfileDef] = new IfcEntityDescriptor(Type::IfcEllipseProfileDef,entity_descriptor_map.find(Type::IfcParameterizedProfileDef)->second);
    current->add("SemiAxis1",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("SemiAxis2",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current = entity_descriptor_map[Type::IfcEnergyProperties] = new IfcEntityDescriptor(Type::IfcEnergyProperties,entity_descriptor_map.find(Type::IfcPropertySetDefinition)->second);
    current->add("EnergySequence",true,IfcUtil::Argument_ENUMERATION,Type::IfcEnergySequenceEnum);
    current->add("UserDefinedEnergySequence",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current = entity_descriptor_map[Type::IfcExtrudedAreaSolid] = new IfcEntityDescriptor(Type::IfcExtrudedAreaSolid,entity_descriptor_map.find(Type::IfcSweptAreaSolid)->second);
    current->add("ExtrudedDirection",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcDirection);
    current->add("Depth",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current = entity_descriptor_map[Type::IfcFaceBasedSurfaceModel] = new IfcEntityDescriptor(Type::IfcFaceBasedSurfaceModel,entity_descriptor_map.find(Type::IfcGeometricRepresentationItem)->second);
    current->add("FbsmFaces",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcConnectedFaceSet);
    current = entity_descriptor_map[Type::IfcFillAreaStyleHatching] = new IfcEntityDescriptor(Type::IfcFillAreaStyleHatching,entity_descriptor_map.find(Type::IfcGeometricRepresentationItem)->second);
    current->add("HatchLineAppearance",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcCurveStyle);
    current->add("StartOfNextHatchLine",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcHatchLineDistanceSelect);
    current->add("PointOfReferenceHatchLine",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcCartesianPoint);
    current->add("PatternStart",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcCartesianPoint);
    current->add("HatchLineAngle",false,IfcUtil::Argument_DOUBLE,Type::IfcPlaneAngleMeasure);
    current = entity_descriptor_map[Type::IfcFillAreaStyleTileSymbolWithStyle] = new IfcEntityDescriptor(Type::IfcFillAreaStyleTileSymbolWithStyle,entity_descriptor_map.find(Type::IfcGeometricRepresentationItem)->second);
    current->add("Symbol",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcAnnotationSymbolOccurrence);
    current = entity_descriptor_map[Type::IfcFillAreaStyleTiles] = new IfcEntityDescriptor(Type::IfcFillAreaStyleTiles,entity_descriptor_map.find(Type::IfcGeometricRepresentationItem)->second);
    current->add("TilingPattern",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcOneDirectionRepeatFactor);
    current->add("Tiles",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcFillAreaStyleTileShapeSelect);
    current->add("TilingScale",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveRatioMeasure);
    current = entity_descriptor_map[Type::IfcFluidFlowProperties] = new IfcEntityDescriptor(Type::IfcFluidFlowProperties,entity_descriptor_map.find(Type::IfcPropertySetDefinition)->second);
    current->add("PropertySource",false,IfcUtil::Argument_ENUMERATION,Type::IfcPropertySourceEnum);
    current->add("FlowConditionTimeSeries",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcTimeSeries);
    current->add("VelocityTimeSeries",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcTimeSeries);
    current->add("FlowrateTimeSeries",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcTimeSeries);
    current->add("Fluid",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcMaterial);
    current->add("PressureTimeSeries",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcTimeSeries);
    current->add("UserDefinedPropertySource",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("TemperatureSingleValue",true,IfcUtil::Argument_DOUBLE,Type::IfcThermodynamicTemperatureMeasure);
    current->add("WetBulbTemperatureSingleValue",true,IfcUtil::Argument_DOUBLE,Type::IfcThermodynamicTemperatureMeasure);
    current->add("WetBulbTemperatureTimeSeries",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcTimeSeries);
    current->add("TemperatureTimeSeries",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcTimeSeries);
    current->add("FlowrateSingleValue",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcDerivedMeasureValue);
    current->add("FlowConditionSingleValue",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveRatioMeasure);
    current->add("VelocitySingleValue",true,IfcUtil::Argument_DOUBLE,Type::IfcLinearVelocityMeasure);
    current->add("PressureSingleValue",true,IfcUtil::Argument_DOUBLE,Type::IfcPressureMeasure);
    current = entity_descriptor_map[Type::IfcFurnishingElementType] = new IfcEntityDescriptor(Type::IfcFurnishingElementType,entity_descriptor_map.find(Type::IfcElementType)->second);

    current = entity_descriptor_map[Type::IfcFurnitureType] = new IfcEntityDescriptor(Type::IfcFurnitureType,entity_descriptor_map.find(Type::IfcFurnishingElementType)->second);
    current->add("AssemblyPlace",false,IfcUtil::Argument_ENUMERATION,Type::IfcAssemblyPlaceEnum);
    current = entity_descriptor_map[Type::IfcGeometricCurveSet] = new IfcEntityDescriptor(Type::IfcGeometricCurveSet,entity_descriptor_map.find(Type::IfcGeometricSet)->second);

    current = entity_descriptor_map[Type::IfcIShapeProfileDef] = new IfcEntityDescriptor(Type::IfcIShapeProfileDef,entity_descriptor_map.find(Type::IfcParameterizedProfileDef)->second);
    current->add("OverallWidth",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("OverallDepth",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("WebThickness",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("FlangeThickness",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("FilletRadius",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current = entity_descriptor_map[Type::IfcLShapeProfileDef] = new IfcEntityDescriptor(Type::IfcLShapeProfileDef,entity_descriptor_map.find(Type::IfcParameterizedProfileDef)->second);
    current->add("Depth",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("Width",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("Thickness",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("FilletRadius",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("EdgeRadius",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("LegSlope",true,IfcUtil::Argument_DOUBLE,Type::IfcPlaneAngleMeasure);
    current->add("CentreOfGravityInX",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("CentreOfGravityInY",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current = entity_descriptor_map[Type::IfcLine] = new IfcEntityDescriptor(Type::IfcLine,entity_descriptor_map.find(Type::IfcCurve)->second);
    current->add("Pnt",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcCartesianPoint);
    current->add("Dir",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcVector);
    current = entity_descriptor_map[Type::IfcManifoldSolidBrep] = new IfcEntityDescriptor(Type::IfcManifoldSolidBrep,entity_descriptor_map.find(Type::IfcSolidModel)->second);
    current->add("Outer",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcClosedShell);
    current = entity_descriptor_map[Type::IfcObject] = new IfcEntityDescriptor(Type::IfcObject,entity_descriptor_map.find(Type::IfcObjectDefinition)->second);
    current->add("ObjectType",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current = entity_descriptor_map[Type::IfcOffsetCurve2D] = new IfcEntityDescriptor(Type::IfcOffsetCurve2D,entity_descriptor_map.find(Type::IfcCurve)->second);
    current->add("BasisCurve",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcCurve);
    current->add("Distance",false,IfcUtil::Argument_DOUBLE,Type::IfcLengthMeasure);
    current->add("SelfIntersect",false,IfcUtil::Argument_BOOL,Type::UNDEFINED);
    current = entity_descriptor_map[Type::IfcOffsetCurve3D] = new IfcEntityDescriptor(Type::IfcOffsetCurve3D,entity_descriptor_map.find(Type::IfcCurve)->second);
    current->add("BasisCurve",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcCurve);
    current->add("Distance",false,IfcUtil::Argument_DOUBLE,Type::IfcLengthMeasure);
    current->add("SelfIntersect",false,IfcUtil::Argument_BOOL,Type::UNDEFINED);
    current->add("RefDirection",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcDirection);
    current = entity_descriptor_map[Type::IfcPermeableCoveringProperties] = new IfcEntityDescriptor(Type::IfcPermeableCoveringProperties,entity_descriptor_map.find(Type::IfcPropertySetDefinition)->second);
    current->add("OperationType",false,IfcUtil::Argument_ENUMERATION,Type::IfcPermeableCoveringOperationEnum);
    current->add("PanelPosition",false,IfcUtil::Argument_ENUMERATION,Type::IfcWindowPanelPositionEnum);
    current->add("FrameDepth",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("FrameThickness",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("ShapeAspectStyle",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcShapeAspect);
    current = entity_descriptor_map[Type::IfcPlanarBox] = new IfcEntityDescriptor(Type::IfcPlanarBox,entity_descriptor_map.find(Type::IfcPlanarExtent)->second);
    current->add("Placement",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcAxis2Placement);
    current = entity_descriptor_map[Type::IfcPlane] = new IfcEntityDescriptor(Type::IfcPlane,entity_descriptor_map.find(Type::IfcElementarySurface)->second);

    current = entity_descriptor_map[Type::IfcProcess] = new IfcEntityDescriptor(Type::IfcProcess,entity_descriptor_map.find(Type::IfcObject)->second);

    current = entity_descriptor_map[Type::IfcProduct] = new IfcEntityDescriptor(Type::IfcProduct,entity_descriptor_map.find(Type::IfcObject)->second);
    current->add("ObjectPlacement",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcObjectPlacement);
    current->add("Representation",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcProductRepresentation);
    current = entity_descriptor_map[Type::IfcProject] = new IfcEntityDescriptor(Type::IfcProject,entity_descriptor_map.find(Type::IfcObject)->second);
    current->add("LongName",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("Phase",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("RepresentationContexts",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcRepresentationContext);
    current->add("UnitsInContext",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcUnitAssignment);
    current = entity_descriptor_map[Type::IfcProjectionCurve] = new IfcEntityDescriptor(Type::IfcProjectionCurve,entity_descriptor_map.find(Type::IfcAnnotationCurveOccurrence)->second);

    current = entity_descriptor_map[Type::IfcPropertySet] = new IfcEntityDescriptor(Type::IfcPropertySet,entity_descriptor_map.find(Type::IfcPropertySetDefinition)->second);
    current->add("HasProperties",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcProperty);
    current = entity_descriptor_map[Type::IfcProxy] = new IfcEntityDescriptor(Type::IfcProxy,entity_descriptor_map.find(Type::IfcProduct)->second);
    current->add("ProxyType",false,IfcUtil::Argument_ENUMERATION,Type::IfcObjectTypeEnum);
    current->add("Tag",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current = entity_descriptor_map[Type::IfcRectangleHollowProfileDef] = new IfcEntityDescriptor(Type::IfcRectangleHollowProfileDef,entity_descriptor_map.find(Type::IfcRectangleProfileDef)->second);
    current->add("WallThickness",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("InnerFilletRadius",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("OuterFilletRadius",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current = entity_descriptor_map[Type::IfcRectangularPyramid] = new IfcEntityDescriptor(Type::IfcRectangularPyramid,entity_descriptor_map.find(Type::IfcCsgPrimitive3D)->second);
    current->add("XLength",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("YLength",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("Height",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current = entity_descriptor_map[Type::IfcRectangularTrimmedSurface] = new IfcEntityDescriptor(Type::IfcRectangularTrimmedSurface,entity_descriptor_map.find(Type::IfcBoundedSurface)->second);
    current->add("BasisSurface",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcSurface);
    current->add("U1",false,IfcUtil::Argument_DOUBLE,Type::IfcParameterValue);
    current->add("V1",false,IfcUtil::Argument_DOUBLE,Type::IfcParameterValue);
    current->add("U2",false,IfcUtil::Argument_DOUBLE,Type::IfcParameterValue);
    current->add("V2",false,IfcUtil::Argument_DOUBLE,Type::IfcParameterValue);
    current->add("Usense",false,IfcUtil::Argument_BOOL,Type::UNDEFINED);
    current->add("Vsense",false,IfcUtil::Argument_BOOL,Type::UNDEFINED);
    current = entity_descriptor_map[Type::IfcRelAssigns] = new IfcEntityDescriptor(Type::IfcRelAssigns,entity_descriptor_map.find(Type::IfcRelationship)->second);
    current->add("RelatedObjects",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcObjectDefinition);
    current->add("RelatedObjectsType",true,IfcUtil::Argument_ENUMERATION,Type::IfcObjectTypeEnum);
    current = entity_descriptor_map[Type::IfcRelAssignsToActor] = new IfcEntityDescriptor(Type::IfcRelAssignsToActor,entity_descriptor_map.find(Type::IfcRelAssigns)->second);
    current->add("RelatingActor",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcActor);
    current->add("ActingRole",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcActorRole);
    current = entity_descriptor_map[Type::IfcRelAssignsToControl] = new IfcEntityDescriptor(Type::IfcRelAssignsToControl,entity_descriptor_map.find(Type::IfcRelAssigns)->second);
    current->add("RelatingControl",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcControl);
    current = entity_descriptor_map[Type::IfcRelAssignsToGroup] = new IfcEntityDescriptor(Type::IfcRelAssignsToGroup,entity_descriptor_map.find(Type::IfcRelAssigns)->second);
    current->add("RelatingGroup",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcGroup);
    current = entity_descriptor_map[Type::IfcRelAssignsToProcess] = new IfcEntityDescriptor(Type::IfcRelAssignsToProcess,entity_descriptor_map.find(Type::IfcRelAssigns)->second);
    current->add("RelatingProcess",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcProcess);
    current->add("QuantityInProcess",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcMeasureWithUnit);
    current = entity_descriptor_map[Type::IfcRelAssignsToProduct] = new IfcEntityDescriptor(Type::IfcRelAssignsToProduct,entity_descriptor_map.find(Type::IfcRelAssigns)->second);
    current->add("RelatingProduct",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcProduct);
    current = entity_descriptor_map[Type::IfcRelAssignsToProjectOrder] = new IfcEntityDescriptor(Type::IfcRelAssignsToProjectOrder,entity_descriptor_map.find(Type::IfcRelAssignsToControl)->second);

    current = entity_descriptor_map[Type::IfcRelAssignsToResource] = new IfcEntityDescriptor(Type::IfcRelAssignsToResource,entity_descriptor_map.find(Type::IfcRelAssigns)->second);
    current->add("RelatingResource",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcResource);
    current = entity_descriptor_map[Type::IfcRelAssociates] = new IfcEntityDescriptor(Type::IfcRelAssociates,entity_descriptor_map.find(Type::IfcRelationship)->second);
    current->add("RelatedObjects",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcRoot);
    current = entity_descriptor_map[Type::IfcRelAssociatesAppliedValue] = new IfcEntityDescriptor(Type::IfcRelAssociatesAppliedValue,entity_descriptor_map.find(Type::IfcRelAssociates)->second);
    current->add("RelatingAppliedValue",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcAppliedValue);
    current = entity_descriptor_map[Type::IfcRelAssociatesApproval] = new IfcEntityDescriptor(Type::IfcRelAssociatesApproval,entity_descriptor_map.find(Type::IfcRelAssociates)->second);
    current->add("RelatingApproval",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcApproval);
    current = entity_descriptor_map[Type::IfcRelAssociatesClassification] = new IfcEntityDescriptor(Type::IfcRelAssociatesClassification,entity_descriptor_map.find(Type::IfcRelAssociates)->second);
    current->add("RelatingClassification",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcClassificationNotationSelect);
    current = entity_descriptor_map[Type::IfcRelAssociatesConstraint] = new IfcEntityDescriptor(Type::IfcRelAssociatesConstraint,entity_descriptor_map.find(Type::IfcRelAssociates)->second);
    current->add("Intent",false,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("RelatingConstraint",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcConstraint);
    current = entity_descriptor_map[Type::IfcRelAssociatesDocument] = new IfcEntityDescriptor(Type::IfcRelAssociatesDocument,entity_descriptor_map.find(Type::IfcRelAssociates)->second);
    current->add("RelatingDocument",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcDocumentSelect);
    current = entity_descriptor_map[Type::IfcRelAssociatesLibrary] = new IfcEntityDescriptor(Type::IfcRelAssociatesLibrary,entity_descriptor_map.find(Type::IfcRelAssociates)->second);
    current->add("RelatingLibrary",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcLibrarySelect);
    current = entity_descriptor_map[Type::IfcRelAssociatesMaterial] = new IfcEntityDescriptor(Type::IfcRelAssociatesMaterial,entity_descriptor_map.find(Type::IfcRelAssociates)->second);
    current->add("RelatingMaterial",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcMaterialSelect);
    current = entity_descriptor_map[Type::IfcRelAssociatesProfileProperties] = new IfcEntityDescriptor(Type::IfcRelAssociatesProfileProperties,entity_descriptor_map.find(Type::IfcRelAssociates)->second);
    current->add("RelatingProfileProperties",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcProfileProperties);
    current->add("ProfileSectionLocation",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcShapeAspect);
    current->add("ProfileOrientation",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcOrientationSelect);
    current = entity_descriptor_map[Type::IfcRelConnects] = new IfcEntityDescriptor(Type::IfcRelConnects,entity_descriptor_map.find(Type::IfcRelationship)->second);

    current = entity_descriptor_map[Type::IfcRelConnectsElements] = new IfcEntityDescriptor(Type::IfcRelConnectsElements,entity_descriptor_map.find(Type::IfcRelConnects)->second);
    current->add("ConnectionGeometry",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcConnectionGeometry);
    current->add("RelatingElement",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcElement);
    current->add("RelatedElement",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcElement);
    current = entity_descriptor_map[Type::IfcRelConnectsPathElements] = new IfcEntityDescriptor(Type::IfcRelConnectsPathElements,entity_descriptor_map.find(Type::IfcRelConnectsElements)->second);
    current->add("RelatingPriorities",false,IfcUtil::Argument_AGGREGATE_OF_INT,Type::UNDEFINED);
    current->add("RelatedPriorities",false,IfcUtil::Argument_AGGREGATE_OF_INT,Type::UNDEFINED);
    current->add("RelatedConnectionType",false,IfcUtil::Argument_ENUMERATION,Type::IfcConnectionTypeEnum);
    current->add("RelatingConnectionType",false,IfcUtil::Argument_ENUMERATION,Type::IfcConnectionTypeEnum);
    current = entity_descriptor_map[Type::IfcRelConnectsPortToElement] = new IfcEntityDescriptor(Type::IfcRelConnectsPortToElement,entity_descriptor_map.find(Type::IfcRelConnects)->second);
    current->add("RelatingPort",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcPort);
    current->add("RelatedElement",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcElement);
    current = entity_descriptor_map[Type::IfcRelConnectsPorts] = new IfcEntityDescriptor(Type::IfcRelConnectsPorts,entity_descriptor_map.find(Type::IfcRelConnects)->second);
    current->add("RelatingPort",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcPort);
    current->add("RelatedPort",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcPort);
    current->add("RealizingElement",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcElement);
    current = entity_descriptor_map[Type::IfcRelConnectsStructuralActivity] = new IfcEntityDescriptor(Type::IfcRelConnectsStructuralActivity,entity_descriptor_map.find(Type::IfcRelConnects)->second);
    current->add("RelatingElement",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcStructuralActivityAssignmentSelect);
    current->add("RelatedStructuralActivity",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcStructuralActivity);
    current = entity_descriptor_map[Type::IfcRelConnectsStructuralElement] = new IfcEntityDescriptor(Type::IfcRelConnectsStructuralElement,entity_descriptor_map.find(Type::IfcRelConnects)->second);
    current->add("RelatingElement",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcElement);
    current->add("RelatedStructuralMember",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcStructuralMember);
    current = entity_descriptor_map[Type::IfcRelConnectsStructuralMember] = new IfcEntityDescriptor(Type::IfcRelConnectsStructuralMember,entity_descriptor_map.find(Type::IfcRelConnects)->second);
    current->add("RelatingStructuralMember",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcStructuralMember);
    current->add("RelatedStructuralConnection",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcStructuralConnection);
    current->add("AppliedCondition",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcBoundaryCondition);
    current->add("AdditionalConditions",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcStructuralConnectionCondition);
    current->add("SupportedLength",true,IfcUtil::Argument_DOUBLE,Type::IfcLengthMeasure);
    current->add("ConditionCoordinateSystem",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcAxis2Placement3D);
    current = entity_descriptor_map[Type::IfcRelConnectsWithEccentricity] = new IfcEntityDescriptor(Type::IfcRelConnectsWithEccentricity,entity_descriptor_map.find(Type::IfcRelConnectsStructuralMember)->second);
    current->add("ConnectionConstraint",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcConnectionGeometry);
    current = entity_descriptor_map[Type::IfcRelConnectsWithRealizingElements] = new IfcEntityDescriptor(Type::IfcRelConnectsWithRealizingElements,entity_descriptor_map.find(Type::IfcRelConnectsElements)->second);
    current->add("RealizingElements",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcElement);
    current->add("ConnectionType",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current = entity_descriptor_map[Type::IfcRelContainedInSpatialStructure] = new IfcEntityDescriptor(Type::IfcRelContainedInSpatialStructure,entity_descriptor_map.find(Type::IfcRelConnects)->second);
    current->add("RelatedElements",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcProduct);
    current->add("RelatingStructure",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcSpatialStructureElement);
    current = entity_descriptor_map[Type::IfcRelCoversBldgElements] = new IfcEntityDescriptor(Type::IfcRelCoversBldgElements,entity_descriptor_map.find(Type::IfcRelConnects)->second);
    current->add("RelatingBuildingElement",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcElement);
    current->add("RelatedCoverings",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcCovering);
    current = entity_descriptor_map[Type::IfcRelCoversSpaces] = new IfcEntityDescriptor(Type::IfcRelCoversSpaces,entity_descriptor_map.find(Type::IfcRelConnects)->second);
    current->add("RelatedSpace",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcSpace);
    current->add("RelatedCoverings",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcCovering);
    current = entity_descriptor_map[Type::IfcRelDecomposes] = new IfcEntityDescriptor(Type::IfcRelDecomposes,entity_descriptor_map.find(Type::IfcRelationship)->second);
    current->add("RelatingObject",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcObjectDefinition);
    current->add("RelatedObjects",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcObjectDefinition);
    current = entity_descriptor_map[Type::IfcRelDefines] = new IfcEntityDescriptor(Type::IfcRelDefines,entity_descriptor_map.find(Type::IfcRelationship)->second);
    current->add("RelatedObjects",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcObject);
    current = entity_descriptor_map[Type::IfcRelDefinesByProperties] = new IfcEntityDescriptor(Type::IfcRelDefinesByProperties,entity_descriptor_map.find(Type::IfcRelDefines)->second);
    current->add("RelatingPropertyDefinition",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcPropertySetDefinition);
    current = entity_descriptor_map[Type::IfcRelDefinesByType] = new IfcEntityDescriptor(Type::IfcRelDefinesByType,entity_descriptor_map.find(Type::IfcRelDefines)->second);
    current->add("RelatingType",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcTypeObject);
    current = entity_descriptor_map[Type::IfcRelFillsElement] = new IfcEntityDescriptor(Type::IfcRelFillsElement,entity_descriptor_map.find(Type::IfcRelConnects)->second);
    current->add("RelatingOpeningElement",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcOpeningElement);
    current->add("RelatedBuildingElement",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcElement);
    current = entity_descriptor_map[Type::IfcRelFlowControlElements] = new IfcEntityDescriptor(Type::IfcRelFlowControlElements,entity_descriptor_map.find(Type::IfcRelConnects)->second);
    current->add("RelatedControlElements",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcDistributionControlElement);
    current->add("RelatingFlowElement",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcDistributionFlowElement);
    current = entity_descriptor_map[Type::IfcRelInteractionRequirements] = new IfcEntityDescriptor(Type::IfcRelInteractionRequirements,entity_descriptor_map.find(Type::IfcRelConnects)->second);
    current->add("DailyInteraction",true,IfcUtil::Argument_DOUBLE,Type::IfcCountMeasure);
    current->add("ImportanceRating",true,IfcUtil::Argument_DOUBLE,Type::IfcNormalisedRatioMeasure);
    current->add("LocationOfInteraction",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcSpatialStructureElement);
    current->add("RelatedSpaceProgram",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcSpaceProgram);
    current->add("RelatingSpaceProgram",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcSpaceProgram);
    current = entity_descriptor_map[Type::IfcRelNests] = new IfcEntityDescriptor(Type::IfcRelNests,entity_descriptor_map.find(Type::IfcRelDecomposes)->second);

    current = entity_descriptor_map[Type::IfcRelOccupiesSpaces] = new IfcEntityDescriptor(Type::IfcRelOccupiesSpaces,entity_descriptor_map.find(Type::IfcRelAssignsToActor)->second);

    current = entity_descriptor_map[Type::IfcRelOverridesProperties] = new IfcEntityDescriptor(Type::IfcRelOverridesProperties,entity_descriptor_map.find(Type::IfcRelDefinesByProperties)->second);
    current->add("OverridingProperties",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcProperty);
    current = entity_descriptor_map[Type::IfcRelProjectsElement] = new IfcEntityDescriptor(Type::IfcRelProjectsElement,entity_descriptor_map.find(Type::IfcRelConnects)->second);
    current->add("RelatingElement",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcElement);
    current->add("RelatedFeatureElement",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcFeatureElementAddition);
    current = entity_descriptor_map[Type::IfcRelReferencedInSpatialStructure] = new IfcEntityDescriptor(Type::IfcRelReferencedInSpatialStructure,entity_descriptor_map.find(Type::IfcRelConnects)->second);
    current->add("RelatedElements",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcProduct);
    current->add("RelatingStructure",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcSpatialStructureElement);
    current = entity_descriptor_map[Type::IfcRelSchedulesCostItems] = new IfcEntityDescriptor(Type::IfcRelSchedulesCostItems,entity_descriptor_map.find(Type::IfcRelAssignsToControl)->second);

    current = entity_descriptor_map[Type::IfcRelSequence] = new IfcEntityDescriptor(Type::IfcRelSequence,entity_descriptor_map.find(Type::IfcRelConnects)->second);
    current->add("RelatingProcess",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcProcess);
    current->add("RelatedProcess",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcProcess);
    current->add("TimeLag",false,IfcUtil::Argument_DOUBLE,Type::IfcTimeMeasure);
    current->add("SequenceType",false,IfcUtil::Argument_ENUMERATION,Type::IfcSequenceEnum);
    current = entity_descriptor_map[Type::IfcRelServicesBuildings] = new IfcEntityDescriptor(Type::IfcRelServicesBuildings,entity_descriptor_map.find(Type::IfcRelConnects)->second);
    current->add("RelatingSystem",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcSystem);
    current->add("RelatedBuildings",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcSpatialStructureElement);
    current = entity_descriptor_map[Type::IfcRelSpaceBoundary] = new IfcEntityDescriptor(Type::IfcRelSpaceBoundary,entity_descriptor_map.find(Type::IfcRelConnects)->second);
    current->add("RelatingSpace",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcSpace);
    current->add("RelatedBuildingElement",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcElement);
    current->add("ConnectionGeometry",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcConnectionGeometry);
    current->add("PhysicalOrVirtualBoundary",false,IfcUtil::Argument_ENUMERATION,Type::IfcPhysicalOrVirtualEnum);
    current->add("InternalOrExternalBoundary",false,IfcUtil::Argument_ENUMERATION,Type::IfcInternalOrExternalEnum);
    current = entity_descriptor_map[Type::IfcRelVoidsElement] = new IfcEntityDescriptor(Type::IfcRelVoidsElement,entity_descriptor_map.find(Type::IfcRelConnects)->second);
    current->add("RelatingBuildingElement",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcElement);
    current->add("RelatedOpeningElement",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcFeatureElementSubtraction);
    current = entity_descriptor_map[Type::IfcResource] = new IfcEntityDescriptor(Type::IfcResource,entity_descriptor_map.find(Type::IfcObject)->second);

    current = entity_descriptor_map[Type::IfcRevolvedAreaSolid] = new IfcEntityDescriptor(Type::IfcRevolvedAreaSolid,entity_descriptor_map.find(Type::IfcSweptAreaSolid)->second);
    current->add("Axis",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcAxis1Placement);
    current->add("Angle",false,IfcUtil::Argument_DOUBLE,Type::IfcPlaneAngleMeasure);
    current = entity_descriptor_map[Type::IfcRightCircularCone] = new IfcEntityDescriptor(Type::IfcRightCircularCone,entity_descriptor_map.find(Type::IfcCsgPrimitive3D)->second);
    current->add("Height",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("BottomRadius",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current = entity_descriptor_map[Type::IfcRightCircularCylinder] = new IfcEntityDescriptor(Type::IfcRightCircularCylinder,entity_descriptor_map.find(Type::IfcCsgPrimitive3D)->second);
    current->add("Height",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("Radius",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current = entity_descriptor_map[Type::IfcSpatialStructureElement] = new IfcEntityDescriptor(Type::IfcSpatialStructureElement,entity_descriptor_map.find(Type::IfcProduct)->second);
    current->add("LongName",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("CompositionType",false,IfcUtil::Argument_ENUMERATION,Type::IfcElementCompositionEnum);
    current = entity_descriptor_map[Type::IfcSpatialStructureElementType] = new IfcEntityDescriptor(Type::IfcSpatialStructureElementType,entity_descriptor_map.find(Type::IfcElementType)->second);

    current = entity_descriptor_map[Type::IfcSphere] = new IfcEntityDescriptor(Type::IfcSphere,entity_descriptor_map.find(Type::IfcCsgPrimitive3D)->second);
    current->add("Radius",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current = entity_descriptor_map[Type::IfcStructuralActivity] = new IfcEntityDescriptor(Type::IfcStructuralActivity,entity_descriptor_map.find(Type::IfcProduct)->second);
    current->add("AppliedLoad",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcStructuralLoad);
    current->add("GlobalOrLocal",false,IfcUtil::Argument_ENUMERATION,Type::IfcGlobalOrLocalEnum);
    current = entity_descriptor_map[Type::IfcStructuralItem] = new IfcEntityDescriptor(Type::IfcStructuralItem,entity_descriptor_map.find(Type::IfcProduct)->second);

    current = entity_descriptor_map[Type::IfcStructuralMember] = new IfcEntityDescriptor(Type::IfcStructuralMember,entity_descriptor_map.find(Type::IfcStructuralItem)->second);

    current = entity_descriptor_map[Type::IfcStructuralReaction] = new IfcEntityDescriptor(Type::IfcStructuralReaction,entity_descriptor_map.find(Type::IfcStructuralActivity)->second);

    current = entity_descriptor_map[Type::IfcStructuralSurfaceMember] = new IfcEntityDescriptor(Type::IfcStructuralSurfaceMember,entity_descriptor_map.find(Type::IfcStructuralMember)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcStructuralSurfaceTypeEnum);
    current->add("Thickness",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current = entity_descriptor_map[Type::IfcStructuralSurfaceMemberVarying] = new IfcEntityDescriptor(Type::IfcStructuralSurfaceMemberVarying,entity_descriptor_map.find(Type::IfcStructuralSurfaceMember)->second);
    current->add("SubsequentThickness",false,IfcUtil::Argument_AGGREGATE_OF_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("VaryingThicknessLocation",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcShapeAspect);
    current = entity_descriptor_map[Type::IfcStructuredDimensionCallout] = new IfcEntityDescriptor(Type::IfcStructuredDimensionCallout,entity_descriptor_map.find(Type::IfcDraughtingCallout)->second);

    current = entity_descriptor_map[Type::IfcSurfaceCurveSweptAreaSolid] = new IfcEntityDescriptor(Type::IfcSurfaceCurveSweptAreaSolid,entity_descriptor_map.find(Type::IfcSweptAreaSolid)->second);
    current->add("Directrix",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcCurve);
    current->add("StartParam",false,IfcUtil::Argument_DOUBLE,Type::IfcParameterValue);
    current->add("EndParam",false,IfcUtil::Argument_DOUBLE,Type::IfcParameterValue);
    current->add("ReferenceSurface",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcSurface);
    current = entity_descriptor_map[Type::IfcSurfaceOfLinearExtrusion] = new IfcEntityDescriptor(Type::IfcSurfaceOfLinearExtrusion,entity_descriptor_map.find(Type::IfcSweptSurface)->second);
    current->add("ExtrudedDirection",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcDirection);
    current->add("Depth",false,IfcUtil::Argument_DOUBLE,Type::IfcLengthMeasure);
    current = entity_descriptor_map[Type::IfcSurfaceOfRevolution] = new IfcEntityDescriptor(Type::IfcSurfaceOfRevolution,entity_descriptor_map.find(Type::IfcSweptSurface)->second);
    current->add("AxisPosition",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcAxis1Placement);
    current = entity_descriptor_map[Type::IfcSystemFurnitureElementType] = new IfcEntityDescriptor(Type::IfcSystemFurnitureElementType,entity_descriptor_map.find(Type::IfcFurnishingElementType)->second);

    current = entity_descriptor_map[Type::IfcTask] = new IfcEntityDescriptor(Type::IfcTask,entity_descriptor_map.find(Type::IfcProcess)->second);
    current->add("TaskId",false,IfcUtil::Argument_STRING,Type::IfcIdentifier);
    current->add("Status",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("WorkMethod",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("IsMilestone",false,IfcUtil::Argument_BOOL,Type::UNDEFINED);
    current->add("Priority",true,IfcUtil::Argument_INT,Type::UNDEFINED);
    current = entity_descriptor_map[Type::IfcTransportElementType] = new IfcEntityDescriptor(Type::IfcTransportElementType,entity_descriptor_map.find(Type::IfcElementType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcTransportElementTypeEnum);
    current = entity_descriptor_map[Type::IfcActor] = new IfcEntityDescriptor(Type::IfcActor,entity_descriptor_map.find(Type::IfcObject)->second);
    current->add("TheActor",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcActorSelect);
    current = entity_descriptor_map[Type::IfcAnnotation] = new IfcEntityDescriptor(Type::IfcAnnotation,entity_descriptor_map.find(Type::IfcProduct)->second);

    current = entity_descriptor_map[Type::IfcAsymmetricIShapeProfileDef] = new IfcEntityDescriptor(Type::IfcAsymmetricIShapeProfileDef,entity_descriptor_map.find(Type::IfcIShapeProfileDef)->second);
    current->add("TopFlangeWidth",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("TopFlangeThickness",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("TopFlangeFilletRadius",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("CentreOfGravityInY",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current = entity_descriptor_map[Type::IfcBlock] = new IfcEntityDescriptor(Type::IfcBlock,entity_descriptor_map.find(Type::IfcCsgPrimitive3D)->second);
    current->add("XLength",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("YLength",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("ZLength",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current = entity_descriptor_map[Type::IfcBooleanClippingResult] = new IfcEntityDescriptor(Type::IfcBooleanClippingResult,entity_descriptor_map.find(Type::IfcBooleanResult)->second);

    current = entity_descriptor_map[Type::IfcBoundedCurve] = new IfcEntityDescriptor(Type::IfcBoundedCurve,entity_descriptor_map.find(Type::IfcCurve)->second);

    current = entity_descriptor_map[Type::IfcBuilding] = new IfcEntityDescriptor(Type::IfcBuilding,entity_descriptor_map.find(Type::IfcSpatialStructureElement)->second);
    current->add("ElevationOfRefHeight",true,IfcUtil::Argument_DOUBLE,Type::IfcLengthMeasure);
    current->add("ElevationOfTerrain",true,IfcUtil::Argument_DOUBLE,Type::IfcLengthMeasure);
    current->add("BuildingAddress",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcPostalAddress);
    current = entity_descriptor_map[Type::IfcBuildingElementType] = new IfcEntityDescriptor(Type::IfcBuildingElementType,entity_descriptor_map.find(Type::IfcElementType)->second);

    current = entity_descriptor_map[Type::IfcBuildingStorey] = new IfcEntityDescriptor(Type::IfcBuildingStorey,entity_descriptor_map.find(Type::IfcSpatialStructureElement)->second);
    current->add("Elevation",true,IfcUtil::Argument_DOUBLE,Type::IfcLengthMeasure);
    current = entity_descriptor_map[Type::IfcCircleHollowProfileDef] = new IfcEntityDescriptor(Type::IfcCircleHollowProfileDef,entity_descriptor_map.find(Type::IfcCircleProfileDef)->second);
    current->add("WallThickness",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current = entity_descriptor_map[Type::IfcColumnType] = new IfcEntityDescriptor(Type::IfcColumnType,entity_descriptor_map.find(Type::IfcBuildingElementType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcColumnTypeEnum);
    current = entity_descriptor_map[Type::IfcCompositeCurve] = new IfcEntityDescriptor(Type::IfcCompositeCurve,entity_descriptor_map.find(Type::IfcBoundedCurve)->second);
    current->add("Segments",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcCompositeCurveSegment);
    current->add("SelfIntersect",false,IfcUtil::Argument_BOOL,Type::UNDEFINED);
    current = entity_descriptor_map[Type::IfcConic] = new IfcEntityDescriptor(Type::IfcConic,entity_descriptor_map.find(Type::IfcCurve)->second);
    current->add("Position",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcAxis2Placement);
    current = entity_descriptor_map[Type::IfcConstructionResource] = new IfcEntityDescriptor(Type::IfcConstructionResource,entity_descriptor_map.find(Type::IfcResource)->second);
    current->add("ResourceIdentifier",true,IfcUtil::Argument_STRING,Type::IfcIdentifier);
    current->add("ResourceGroup",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("ResourceConsumption",true,IfcUtil::Argument_ENUMERATION,Type::IfcResourceConsumptionEnum);
    current->add("BaseQuantity",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcMeasureWithUnit);
    current = entity_descriptor_map[Type::IfcControl] = new IfcEntityDescriptor(Type::IfcControl,entity_descriptor_map.find(Type::IfcObject)->second);

    current = entity_descriptor_map[Type::IfcCostItem] = new IfcEntityDescriptor(Type::IfcCostItem,entity_descriptor_map.find(Type::IfcControl)->second);

    current = entity_descriptor_map[Type::IfcCostSchedule] = new IfcEntityDescriptor(Type::IfcCostSchedule,entity_descriptor_map.find(Type::IfcControl)->second);
    current->add("SubmittedBy",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcActorSelect);
    current->add("PreparedBy",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcActorSelect);
    current->add("SubmittedOn",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcDateTimeSelect);
    current->add("Status",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("TargetUsers",true,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcActorSelect);
    current->add("UpdateDate",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcDateTimeSelect);
    current->add("ID",false,IfcUtil::Argument_STRING,Type::IfcIdentifier);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcCostScheduleTypeEnum);
    current = entity_descriptor_map[Type::IfcCoveringType] = new IfcEntityDescriptor(Type::IfcCoveringType,entity_descriptor_map.find(Type::IfcBuildingElementType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcCoveringTypeEnum);
    current = entity_descriptor_map[Type::IfcCrewResource] = new IfcEntityDescriptor(Type::IfcCrewResource,entity_descriptor_map.find(Type::IfcConstructionResource)->second);

    current = entity_descriptor_map[Type::IfcCurtainWallType] = new IfcEntityDescriptor(Type::IfcCurtainWallType,entity_descriptor_map.find(Type::IfcBuildingElementType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcCurtainWallTypeEnum);
    current = entity_descriptor_map[Type::IfcDimensionCurveDirectedCallout] = new IfcEntityDescriptor(Type::IfcDimensionCurveDirectedCallout,entity_descriptor_map.find(Type::IfcDraughtingCallout)->second);

    current = entity_descriptor_map[Type::IfcDistributionElementType] = new IfcEntityDescriptor(Type::IfcDistributionElementType,entity_descriptor_map.find(Type::IfcElementType)->second);

    current = entity_descriptor_map[Type::IfcDistributionFlowElementType] = new IfcEntityDescriptor(Type::IfcDistributionFlowElementType,entity_descriptor_map.find(Type::IfcDistributionElementType)->second);

    current = entity_descriptor_map[Type::IfcElectricalBaseProperties] = new IfcEntityDescriptor(Type::IfcElectricalBaseProperties,entity_descriptor_map.find(Type::IfcEnergyProperties)->second);
    current->add("ElectricCurrentType",true,IfcUtil::Argument_ENUMERATION,Type::IfcElectricCurrentEnum);
    current->add("InputVoltage",false,IfcUtil::Argument_DOUBLE,Type::IfcElectricVoltageMeasure);
    current->add("InputFrequency",false,IfcUtil::Argument_DOUBLE,Type::IfcFrequencyMeasure);
    current->add("FullLoadCurrent",true,IfcUtil::Argument_DOUBLE,Type::IfcElectricCurrentMeasure);
    current->add("MinimumCircuitCurrent",true,IfcUtil::Argument_DOUBLE,Type::IfcElectricCurrentMeasure);
    current->add("MaximumPowerInput",true,IfcUtil::Argument_DOUBLE,Type::IfcPowerMeasure);
    current->add("RatedPowerInput",true,IfcUtil::Argument_DOUBLE,Type::IfcPowerMeasure);
    current->add("InputPhase",false,IfcUtil::Argument_INT,Type::UNDEFINED);
    current = entity_descriptor_map[Type::IfcElement] = new IfcEntityDescriptor(Type::IfcElement,entity_descriptor_map.find(Type::IfcProduct)->second);
    current->add("Tag",true,IfcUtil::Argument_STRING,Type::IfcIdentifier);
    current = entity_descriptor_map[Type::IfcElementAssembly] = new IfcEntityDescriptor(Type::IfcElementAssembly,entity_descriptor_map.find(Type::IfcElement)->second);
    current->add("AssemblyPlace",true,IfcUtil::Argument_ENUMERATION,Type::IfcAssemblyPlaceEnum);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcElementAssemblyTypeEnum);
    current = entity_descriptor_map[Type::IfcElementComponent] = new IfcEntityDescriptor(Type::IfcElementComponent,entity_descriptor_map.find(Type::IfcElement)->second);

    current = entity_descriptor_map[Type::IfcElementComponentType] = new IfcEntityDescriptor(Type::IfcElementComponentType,entity_descriptor_map.find(Type::IfcElementType)->second);

    current = entity_descriptor_map[Type::IfcEllipse] = new IfcEntityDescriptor(Type::IfcEllipse,entity_descriptor_map.find(Type::IfcConic)->second);
    current->add("SemiAxis1",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("SemiAxis2",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current = entity_descriptor_map[Type::IfcEnergyConversionDeviceType] = new IfcEntityDescriptor(Type::IfcEnergyConversionDeviceType,entity_descriptor_map.find(Type::IfcDistributionFlowElementType)->second);

    current = entity_descriptor_map[Type::IfcEquipmentElement] = new IfcEntityDescriptor(Type::IfcEquipmentElement,entity_descriptor_map.find(Type::IfcElement)->second);

    current = entity_descriptor_map[Type::IfcEquipmentStandard] = new IfcEntityDescriptor(Type::IfcEquipmentStandard,entity_descriptor_map.find(Type::IfcControl)->second);

    current = entity_descriptor_map[Type::IfcEvaporativeCoolerType] = new IfcEntityDescriptor(Type::IfcEvaporativeCoolerType,entity_descriptor_map.find(Type::IfcEnergyConversionDeviceType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcEvaporativeCoolerTypeEnum);
    current = entity_descriptor_map[Type::IfcEvaporatorType] = new IfcEntityDescriptor(Type::IfcEvaporatorType,entity_descriptor_map.find(Type::IfcEnergyConversionDeviceType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcEvaporatorTypeEnum);
    current = entity_descriptor_map[Type::IfcFacetedBrep] = new IfcEntityDescriptor(Type::IfcFacetedBrep,entity_descriptor_map.find(Type::IfcManifoldSolidBrep)->second);

    current = entity_descriptor_map[Type::IfcFacetedBrepWithVoids] = new IfcEntityDescriptor(Type::IfcFacetedBrepWithVoids,entity_descriptor_map.find(Type::IfcManifoldSolidBrep)->second);
    current->add("Voids",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcClosedShell);
    current = entity_descriptor_map[Type::IfcFastener] = new IfcEntityDescriptor(Type::IfcFastener,entity_descriptor_map.find(Type::IfcElementComponent)->second);

    current = entity_descriptor_map[Type::IfcFastenerType] = new IfcEntityDescriptor(Type::IfcFastenerType,entity_descriptor_map.find(Type::IfcElementComponentType)->second);

    current = entity_descriptor_map[Type::IfcFeatureElement] = new IfcEntityDescriptor(Type::IfcFeatureElement,entity_descriptor_map.find(Type::IfcElement)->second);

    current = entity_descriptor_map[Type::IfcFeatureElementAddition] = new IfcEntityDescriptor(Type::IfcFeatureElementAddition,entity_descriptor_map.find(Type::IfcFeatureElement)->second);

    current = entity_descriptor_map[Type::IfcFeatureElementSubtraction] = new IfcEntityDescriptor(Type::IfcFeatureElementSubtraction,entity_descriptor_map.find(Type::IfcFeatureElement)->second);

    current = entity_descriptor_map[Type::IfcFlowControllerType] = new IfcEntityDescriptor(Type::IfcFlowControllerType,entity_descriptor_map.find(Type::IfcDistributionFlowElementType)->second);

    current = entity_descriptor_map[Type::IfcFlowFittingType] = new IfcEntityDescriptor(Type::IfcFlowFittingType,entity_descriptor_map.find(Type::IfcDistributionFlowElementType)->second);

    current = entity_descriptor_map[Type::IfcFlowMeterType] = new IfcEntityDescriptor(Type::IfcFlowMeterType,entity_descriptor_map.find(Type::IfcFlowControllerType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcFlowMeterTypeEnum);
    current = entity_descriptor_map[Type::IfcFlowMovingDeviceType] = new IfcEntityDescriptor(Type::IfcFlowMovingDeviceType,entity_descriptor_map.find(Type::IfcDistributionFlowElementType)->second);

    current = entity_descriptor_map[Type::IfcFlowSegmentType] = new IfcEntityDescriptor(Type::IfcFlowSegmentType,entity_descriptor_map.find(Type::IfcDistributionFlowElementType)->second);

    current = entity_descriptor_map[Type::IfcFlowStorageDeviceType] = new IfcEntityDescriptor(Type::IfcFlowStorageDeviceType,entity_descriptor_map.find(Type::IfcDistributionFlowElementType)->second);

    current = entity_descriptor_map[Type::IfcFlowTerminalType] = new IfcEntityDescriptor(Type::IfcFlowTerminalType,entity_descriptor_map.find(Type::IfcDistributionFlowElementType)->second);

    current = entity_descriptor_map[Type::IfcFlowTreatmentDeviceType] = new IfcEntityDescriptor(Type::IfcFlowTreatmentDeviceType,entity_descriptor_map.find(Type::IfcDistributionFlowElementType)->second);

    current = entity_descriptor_map[Type::IfcFurnishingElement] = new IfcEntityDescriptor(Type::IfcFurnishingElement,entity_descriptor_map.find(Type::IfcElement)->second);

    current = entity_descriptor_map[Type::IfcFurnitureStandard] = new IfcEntityDescriptor(Type::IfcFurnitureStandard,entity_descriptor_map.find(Type::IfcControl)->second);

    current = entity_descriptor_map[Type::IfcGasTerminalType] = new IfcEntityDescriptor(Type::IfcGasTerminalType,entity_descriptor_map.find(Type::IfcFlowTerminalType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcGasTerminalTypeEnum);
    current = entity_descriptor_map[Type::IfcGrid] = new IfcEntityDescriptor(Type::IfcGrid,entity_descriptor_map.find(Type::IfcProduct)->second);
    current->add("UAxes",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcGridAxis);
    current->add("VAxes",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcGridAxis);
    current->add("WAxes",true,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcGridAxis);
    current = entity_descriptor_map[Type::IfcGroup] = new IfcEntityDescriptor(Type::IfcGroup,entity_descriptor_map.find(Type::IfcObject)->second);

    current = entity_descriptor_map[Type::IfcHeatExchangerType] = new IfcEntityDescriptor(Type::IfcHeatExchangerType,entity_descriptor_map.find(Type::IfcEnergyConversionDeviceType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcHeatExchangerTypeEnum);
    current = entity_descriptor_map[Type::IfcHumidifierType] = new IfcEntityDescriptor(Type::IfcHumidifierType,entity_descriptor_map.find(Type::IfcEnergyConversionDeviceType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcHumidifierTypeEnum);
    current = entity_descriptor_map[Type::IfcInventory] = new IfcEntityDescriptor(Type::IfcInventory,entity_descriptor_map.find(Type::IfcGroup)->second);
    current->add("InventoryType",false,IfcUtil::Argument_ENUMERATION,Type::IfcInventoryTypeEnum);
    current->add("Jurisdiction",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcActorSelect);
    current->add("ResponsiblePersons",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcPerson);
    current->add("LastUpdateDate",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcCalendarDate);
    current->add("CurrentValue",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcCostValue);
    current->add("OriginalValue",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcCostValue);
    current = entity_descriptor_map[Type::IfcJunctionBoxType] = new IfcEntityDescriptor(Type::IfcJunctionBoxType,entity_descriptor_map.find(Type::IfcFlowFittingType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcJunctionBoxTypeEnum);
    current = entity_descriptor_map[Type::IfcLaborResource] = new IfcEntityDescriptor(Type::IfcLaborResource,entity_descriptor_map.find(Type::IfcConstructionResource)->second);
    current->add("SkillSet",true,IfcUtil::Argument_STRING,Type::IfcText);
    current = entity_descriptor_map[Type::IfcLampType] = new IfcEntityDescriptor(Type::IfcLampType,entity_descriptor_map.find(Type::IfcFlowTerminalType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcLampTypeEnum);
    current = entity_descriptor_map[Type::IfcLightFixtureType] = new IfcEntityDescriptor(Type::IfcLightFixtureType,entity_descriptor_map.find(Type::IfcFlowTerminalType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcLightFixtureTypeEnum);
    current = entity_descriptor_map[Type::IfcLinearDimension] = new IfcEntityDescriptor(Type::IfcLinearDimension,entity_descriptor_map.find(Type::IfcDimensionCurveDirectedCallout)->second);

    current = entity_descriptor_map[Type::IfcMechanicalFastener] = new IfcEntityDescriptor(Type::IfcMechanicalFastener,entity_descriptor_map.find(Type::IfcFastener)->second);
    current->add("NominalDiameter",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("NominalLength",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current = entity_descriptor_map[Type::IfcMechanicalFastenerType] = new IfcEntityDescriptor(Type::IfcMechanicalFastenerType,entity_descriptor_map.find(Type::IfcFastenerType)->second);

    current = entity_descriptor_map[Type::IfcMemberType] = new IfcEntityDescriptor(Type::IfcMemberType,entity_descriptor_map.find(Type::IfcBuildingElementType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcMemberTypeEnum);
    current = entity_descriptor_map[Type::IfcMotorConnectionType] = new IfcEntityDescriptor(Type::IfcMotorConnectionType,entity_descriptor_map.find(Type::IfcEnergyConversionDeviceType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcMotorConnectionTypeEnum);
    current = entity_descriptor_map[Type::IfcMove] = new IfcEntityDescriptor(Type::IfcMove,entity_descriptor_map.find(Type::IfcTask)->second);
    current->add("MoveFrom",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcSpatialStructureElement);
    current->add("MoveTo",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcSpatialStructureElement);
    current->add("PunchList",true,IfcUtil::Argument_AGGREGATE_OF_STRING,Type::IfcText);
    current = entity_descriptor_map[Type::IfcOccupant] = new IfcEntityDescriptor(Type::IfcOccupant,entity_descriptor_map.find(Type::IfcActor)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcOccupantTypeEnum);
    current = entity_descriptor_map[Type::IfcOpeningElement] = new IfcEntityDescriptor(Type::IfcOpeningElement,entity_descriptor_map.find(Type::IfcFeatureElementSubtraction)->second);

    current = entity_descriptor_map[Type::IfcOrderAction] = new IfcEntityDescriptor(Type::IfcOrderAction,entity_descriptor_map.find(Type::IfcTask)->second);
    current->add("ActionID",false,IfcUtil::Argument_STRING,Type::IfcIdentifier);
    current = entity_descriptor_map[Type::IfcOutletType] = new IfcEntityDescriptor(Type::IfcOutletType,entity_descriptor_map.find(Type::IfcFlowTerminalType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcOutletTypeEnum);
    current = entity_descriptor_map[Type::IfcPerformanceHistory] = new IfcEntityDescriptor(Type::IfcPerformanceHistory,entity_descriptor_map.find(Type::IfcControl)->second);
    current->add("LifeCyclePhase",false,IfcUtil::Argument_STRING,Type::IfcLabel);
    current = entity_descriptor_map[Type::IfcPermit] = new IfcEntityDescriptor(Type::IfcPermit,entity_descriptor_map.find(Type::IfcControl)->second);
    current->add("PermitID",false,IfcUtil::Argument_STRING,Type::IfcIdentifier);
    current = entity_descriptor_map[Type::IfcPipeFittingType] = new IfcEntityDescriptor(Type::IfcPipeFittingType,entity_descriptor_map.find(Type::IfcFlowFittingType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcPipeFittingTypeEnum);
    current = entity_descriptor_map[Type::IfcPipeSegmentType] = new IfcEntityDescriptor(Type::IfcPipeSegmentType,entity_descriptor_map.find(Type::IfcFlowSegmentType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcPipeSegmentTypeEnum);
    current = entity_descriptor_map[Type::IfcPlateType] = new IfcEntityDescriptor(Type::IfcPlateType,entity_descriptor_map.find(Type::IfcBuildingElementType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcPlateTypeEnum);
    current = entity_descriptor_map[Type::IfcPolyline] = new IfcEntityDescriptor(Type::IfcPolyline,entity_descriptor_map.find(Type::IfcBoundedCurve)->second);
    current->add("Points",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcCartesianPoint);
    current = entity_descriptor_map[Type::IfcPort] = new IfcEntityDescriptor(Type::IfcPort,entity_descriptor_map.find(Type::IfcProduct)->second);

    current = entity_descriptor_map[Type::IfcProcedure] = new IfcEntityDescriptor(Type::IfcProcedure,entity_descriptor_map.find(Type::IfcProcess)->second);
    current->add("ProcedureID",false,IfcUtil::Argument_STRING,Type::IfcIdentifier);
    current->add("ProcedureType",false,IfcUtil::Argument_ENUMERATION,Type::IfcProcedureTypeEnum);
    current->add("UserDefinedProcedureType",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current = entity_descriptor_map[Type::IfcProjectOrder] = new IfcEntityDescriptor(Type::IfcProjectOrder,entity_descriptor_map.find(Type::IfcControl)->second);
    current->add("ID",false,IfcUtil::Argument_STRING,Type::IfcIdentifier);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcProjectOrderTypeEnum);
    current->add("Status",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current = entity_descriptor_map[Type::IfcProjectOrderRecord] = new IfcEntityDescriptor(Type::IfcProjectOrderRecord,entity_descriptor_map.find(Type::IfcControl)->second);
    current->add("Records",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcRelAssignsToProjectOrder);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcProjectOrderRecordTypeEnum);
    current = entity_descriptor_map[Type::IfcProjectionElement] = new IfcEntityDescriptor(Type::IfcProjectionElement,entity_descriptor_map.find(Type::IfcFeatureElementAddition)->second);

    current = entity_descriptor_map[Type::IfcProtectiveDeviceType] = new IfcEntityDescriptor(Type::IfcProtectiveDeviceType,entity_descriptor_map.find(Type::IfcFlowControllerType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcProtectiveDeviceTypeEnum);
    current = entity_descriptor_map[Type::IfcPumpType] = new IfcEntityDescriptor(Type::IfcPumpType,entity_descriptor_map.find(Type::IfcFlowMovingDeviceType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcPumpTypeEnum);
    current = entity_descriptor_map[Type::IfcRadiusDimension] = new IfcEntityDescriptor(Type::IfcRadiusDimension,entity_descriptor_map.find(Type::IfcDimensionCurveDirectedCallout)->second);

    current = entity_descriptor_map[Type::IfcRailingType] = new IfcEntityDescriptor(Type::IfcRailingType,entity_descriptor_map.find(Type::IfcBuildingElementType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcRailingTypeEnum);
    current = entity_descriptor_map[Type::IfcRampFlightType] = new IfcEntityDescriptor(Type::IfcRampFlightType,entity_descriptor_map.find(Type::IfcBuildingElementType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcRampFlightTypeEnum);
    current = entity_descriptor_map[Type::IfcRelAggregates] = new IfcEntityDescriptor(Type::IfcRelAggregates,entity_descriptor_map.find(Type::IfcRelDecomposes)->second);

    current = entity_descriptor_map[Type::IfcRelAssignsTasks] = new IfcEntityDescriptor(Type::IfcRelAssignsTasks,entity_descriptor_map.find(Type::IfcRelAssignsToControl)->second);
    current->add("TimeForTask",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcScheduleTimeControl);
    current = entity_descriptor_map[Type::IfcSanitaryTerminalType] = new IfcEntityDescriptor(Type::IfcSanitaryTerminalType,entity_descriptor_map.find(Type::IfcFlowTerminalType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcSanitaryTerminalTypeEnum);
    current = entity_descriptor_map[Type::IfcScheduleTimeControl] = new IfcEntityDescriptor(Type::IfcScheduleTimeControl,entity_descriptor_map.find(Type::IfcControl)->second);
    current->add("ActualStart",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcDateTimeSelect);
    current->add("EarlyStart",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcDateTimeSelect);
    current->add("LateStart",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcDateTimeSelect);
    current->add("ScheduleStart",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcDateTimeSelect);
    current->add("ActualFinish",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcDateTimeSelect);
    current->add("EarlyFinish",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcDateTimeSelect);
    current->add("LateFinish",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcDateTimeSelect);
    current->add("ScheduleFinish",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcDateTimeSelect);
    current->add("ScheduleDuration",true,IfcUtil::Argument_DOUBLE,Type::IfcTimeMeasure);
    current->add("ActualDuration",true,IfcUtil::Argument_DOUBLE,Type::IfcTimeMeasure);
    current->add("RemainingTime",true,IfcUtil::Argument_DOUBLE,Type::IfcTimeMeasure);
    current->add("FreeFloat",true,IfcUtil::Argument_DOUBLE,Type::IfcTimeMeasure);
    current->add("TotalFloat",true,IfcUtil::Argument_DOUBLE,Type::IfcTimeMeasure);
    current->add("IsCritical",true,IfcUtil::Argument_BOOL,Type::UNDEFINED);
    current->add("StatusTime",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcDateTimeSelect);
    current->add("StartFloat",true,IfcUtil::Argument_DOUBLE,Type::IfcTimeMeasure);
    current->add("FinishFloat",true,IfcUtil::Argument_DOUBLE,Type::IfcTimeMeasure);
    current->add("Completion",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveRatioMeasure);
    current = entity_descriptor_map[Type::IfcServiceLife] = new IfcEntityDescriptor(Type::IfcServiceLife,entity_descriptor_map.find(Type::IfcControl)->second);
    current->add("ServiceLifeType",false,IfcUtil::Argument_ENUMERATION,Type::IfcServiceLifeTypeEnum);
    current->add("ServiceLifeDuration",false,IfcUtil::Argument_DOUBLE,Type::IfcTimeMeasure);
    current = entity_descriptor_map[Type::IfcSite] = new IfcEntityDescriptor(Type::IfcSite,entity_descriptor_map.find(Type::IfcSpatialStructureElement)->second);
    current->add("RefLatitude",true,IfcUtil::Argument_AGGREGATE_OF_INT,Type::IfcCompoundPlaneAngleMeasure);
    current->add("RefLongitude",true,IfcUtil::Argument_AGGREGATE_OF_INT,Type::IfcCompoundPlaneAngleMeasure);
    current->add("RefElevation",true,IfcUtil::Argument_DOUBLE,Type::IfcLengthMeasure);
    current->add("LandTitleNumber",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("SiteAddress",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcPostalAddress);
    current = entity_descriptor_map[Type::IfcSlabType] = new IfcEntityDescriptor(Type::IfcSlabType,entity_descriptor_map.find(Type::IfcBuildingElementType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcSlabTypeEnum);
    current = entity_descriptor_map[Type::IfcSpace] = new IfcEntityDescriptor(Type::IfcSpace,entity_descriptor_map.find(Type::IfcSpatialStructureElement)->second);
    current->add("InteriorOrExteriorSpace",false,IfcUtil::Argument_ENUMERATION,Type::IfcInternalOrExternalEnum);
    current->add("ElevationWithFlooring",true,IfcUtil::Argument_DOUBLE,Type::IfcLengthMeasure);
    current = entity_descriptor_map[Type::IfcSpaceHeaterType] = new IfcEntityDescriptor(Type::IfcSpaceHeaterType,entity_descriptor_map.find(Type::IfcEnergyConversionDeviceType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcSpaceHeaterTypeEnum);
    current = entity_descriptor_map[Type::IfcSpaceProgram] = new IfcEntityDescriptor(Type::IfcSpaceProgram,entity_descriptor_map.find(Type::IfcControl)->second);
    current->add("SpaceProgramIdentifier",false,IfcUtil::Argument_STRING,Type::IfcIdentifier);
    current->add("MaxRequiredArea",true,IfcUtil::Argument_DOUBLE,Type::IfcAreaMeasure);
    current->add("MinRequiredArea",true,IfcUtil::Argument_DOUBLE,Type::IfcAreaMeasure);
    current->add("RequestedLocation",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcSpatialStructureElement);
    current->add("StandardRequiredArea",false,IfcUtil::Argument_DOUBLE,Type::IfcAreaMeasure);
    current = entity_descriptor_map[Type::IfcSpaceType] = new IfcEntityDescriptor(Type::IfcSpaceType,entity_descriptor_map.find(Type::IfcSpatialStructureElementType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcSpaceTypeEnum);
    current = entity_descriptor_map[Type::IfcStackTerminalType] = new IfcEntityDescriptor(Type::IfcStackTerminalType,entity_descriptor_map.find(Type::IfcFlowTerminalType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcStackTerminalTypeEnum);
    current = entity_descriptor_map[Type::IfcStairFlightType] = new IfcEntityDescriptor(Type::IfcStairFlightType,entity_descriptor_map.find(Type::IfcBuildingElementType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcStairFlightTypeEnum);
    current = entity_descriptor_map[Type::IfcStructuralAction] = new IfcEntityDescriptor(Type::IfcStructuralAction,entity_descriptor_map.find(Type::IfcStructuralActivity)->second);
    current->add("DestabilizingLoad",false,IfcUtil::Argument_BOOL,Type::UNDEFINED);
    current->add("CausedBy",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcStructuralReaction);
    current = entity_descriptor_map[Type::IfcStructuralConnection] = new IfcEntityDescriptor(Type::IfcStructuralConnection,entity_descriptor_map.find(Type::IfcStructuralItem)->second);
    current->add("AppliedCondition",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcBoundaryCondition);
    current = entity_descriptor_map[Type::IfcStructuralCurveConnection] = new IfcEntityDescriptor(Type::IfcStructuralCurveConnection,entity_descriptor_map.find(Type::IfcStructuralConnection)->second);

    current = entity_descriptor_map[Type::IfcStructuralCurveMember] = new IfcEntityDescriptor(Type::IfcStructuralCurveMember,entity_descriptor_map.find(Type::IfcStructuralMember)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcStructuralCurveTypeEnum);
    current = entity_descriptor_map[Type::IfcStructuralCurveMemberVarying] = new IfcEntityDescriptor(Type::IfcStructuralCurveMemberVarying,entity_descriptor_map.find(Type::IfcStructuralCurveMember)->second);

    current = entity_descriptor_map[Type::IfcStructuralLinearAction] = new IfcEntityDescriptor(Type::IfcStructuralLinearAction,entity_descriptor_map.find(Type::IfcStructuralAction)->second);
    current->add("ProjectedOrTrue",false,IfcUtil::Argument_ENUMERATION,Type::IfcProjectedOrTrueLengthEnum);
    current = entity_descriptor_map[Type::IfcStructuralLinearActionVarying] = new IfcEntityDescriptor(Type::IfcStructuralLinearActionVarying,entity_descriptor_map.find(Type::IfcStructuralLinearAction)->second);
    current->add("VaryingAppliedLoadLocation",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcShapeAspect);
    current->add("SubsequentAppliedLoads",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcStructuralLoad);
    current = entity_descriptor_map[Type::IfcStructuralLoadGroup] = new IfcEntityDescriptor(Type::IfcStructuralLoadGroup,entity_descriptor_map.find(Type::IfcGroup)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcLoadGroupTypeEnum);
    current->add("ActionType",false,IfcUtil::Argument_ENUMERATION,Type::IfcActionTypeEnum);
    current->add("ActionSource",false,IfcUtil::Argument_ENUMERATION,Type::IfcActionSourceTypeEnum);
    current->add("Coefficient",true,IfcUtil::Argument_DOUBLE,Type::IfcRatioMeasure);
    current->add("Purpose",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current = entity_descriptor_map[Type::IfcStructuralPlanarAction] = new IfcEntityDescriptor(Type::IfcStructuralPlanarAction,entity_descriptor_map.find(Type::IfcStructuralAction)->second);
    current->add("ProjectedOrTrue",false,IfcUtil::Argument_ENUMERATION,Type::IfcProjectedOrTrueLengthEnum);
    current = entity_descriptor_map[Type::IfcStructuralPlanarActionVarying] = new IfcEntityDescriptor(Type::IfcStructuralPlanarActionVarying,entity_descriptor_map.find(Type::IfcStructuralPlanarAction)->second);
    current->add("VaryingAppliedLoadLocation",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcShapeAspect);
    current->add("SubsequentAppliedLoads",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcStructuralLoad);
    current = entity_descriptor_map[Type::IfcStructuralPointAction] = new IfcEntityDescriptor(Type::IfcStructuralPointAction,entity_descriptor_map.find(Type::IfcStructuralAction)->second);

    current = entity_descriptor_map[Type::IfcStructuralPointConnection] = new IfcEntityDescriptor(Type::IfcStructuralPointConnection,entity_descriptor_map.find(Type::IfcStructuralConnection)->second);

    current = entity_descriptor_map[Type::IfcStructuralPointReaction] = new IfcEntityDescriptor(Type::IfcStructuralPointReaction,entity_descriptor_map.find(Type::IfcStructuralReaction)->second);

    current = entity_descriptor_map[Type::IfcStructuralResultGroup] = new IfcEntityDescriptor(Type::IfcStructuralResultGroup,entity_descriptor_map.find(Type::IfcGroup)->second);
    current->add("TheoryType",false,IfcUtil::Argument_ENUMERATION,Type::IfcAnalysisTheoryTypeEnum);
    current->add("ResultForLoadGroup",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcStructuralLoadGroup);
    current->add("IsLinear",false,IfcUtil::Argument_BOOL,Type::UNDEFINED);
    current = entity_descriptor_map[Type::IfcStructuralSurfaceConnection] = new IfcEntityDescriptor(Type::IfcStructuralSurfaceConnection,entity_descriptor_map.find(Type::IfcStructuralConnection)->second);

    current = entity_descriptor_map[Type::IfcSubContractResource] = new IfcEntityDescriptor(Type::IfcSubContractResource,entity_descriptor_map.find(Type::IfcConstructionResource)->second);
    current->add("SubContractor",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcActorSelect);
    current->add("JobDescription",true,IfcUtil::Argument_STRING,Type::IfcText);
    current = entity_descriptor_map[Type::IfcSwitchingDeviceType] = new IfcEntityDescriptor(Type::IfcSwitchingDeviceType,entity_descriptor_map.find(Type::IfcFlowControllerType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcSwitchingDeviceTypeEnum);
    current = entity_descriptor_map[Type::IfcSystem] = new IfcEntityDescriptor(Type::IfcSystem,entity_descriptor_map.find(Type::IfcGroup)->second);

    current = entity_descriptor_map[Type::IfcTankType] = new IfcEntityDescriptor(Type::IfcTankType,entity_descriptor_map.find(Type::IfcFlowStorageDeviceType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcTankTypeEnum);
    current = entity_descriptor_map[Type::IfcTimeSeriesSchedule] = new IfcEntityDescriptor(Type::IfcTimeSeriesSchedule,entity_descriptor_map.find(Type::IfcControl)->second);
    current->add("ApplicableDates",true,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcDateTimeSelect);
    current->add("TimeSeriesScheduleType",false,IfcUtil::Argument_ENUMERATION,Type::IfcTimeSeriesScheduleTypeEnum);
    current->add("TimeSeries",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcTimeSeries);
    current = entity_descriptor_map[Type::IfcTransformerType] = new IfcEntityDescriptor(Type::IfcTransformerType,entity_descriptor_map.find(Type::IfcEnergyConversionDeviceType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcTransformerTypeEnum);
    current = entity_descriptor_map[Type::IfcTransportElement] = new IfcEntityDescriptor(Type::IfcTransportElement,entity_descriptor_map.find(Type::IfcElement)->second);
    current->add("OperationType",true,IfcUtil::Argument_ENUMERATION,Type::IfcTransportElementTypeEnum);
    current->add("CapacityByWeight",true,IfcUtil::Argument_DOUBLE,Type::IfcMassMeasure);
    current->add("CapacityByNumber",true,IfcUtil::Argument_DOUBLE,Type::IfcCountMeasure);
    current = entity_descriptor_map[Type::IfcTrimmedCurve] = new IfcEntityDescriptor(Type::IfcTrimmedCurve,entity_descriptor_map.find(Type::IfcBoundedCurve)->second);
    current->add("BasisCurve",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcCurve);
    current->add("Trim1",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcTrimmingSelect);
    current->add("Trim2",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcTrimmingSelect);
    current->add("SenseAgreement",false,IfcUtil::Argument_BOOL,Type::UNDEFINED);
    current->add("MasterRepresentation",false,IfcUtil::Argument_ENUMERATION,Type::IfcTrimmingPreference);
    current = entity_descriptor_map[Type::IfcTubeBundleType] = new IfcEntityDescriptor(Type::IfcTubeBundleType,entity_descriptor_map.find(Type::IfcEnergyConversionDeviceType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcTubeBundleTypeEnum);
    current = entity_descriptor_map[Type::IfcUnitaryEquipmentType] = new IfcEntityDescriptor(Type::IfcUnitaryEquipmentType,entity_descriptor_map.find(Type::IfcEnergyConversionDeviceType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcUnitaryEquipmentTypeEnum);
    current = entity_descriptor_map[Type::IfcValveType] = new IfcEntityDescriptor(Type::IfcValveType,entity_descriptor_map.find(Type::IfcFlowControllerType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcValveTypeEnum);
    current = entity_descriptor_map[Type::IfcVirtualElement] = new IfcEntityDescriptor(Type::IfcVirtualElement,entity_descriptor_map.find(Type::IfcElement)->second);

    current = entity_descriptor_map[Type::IfcWallType] = new IfcEntityDescriptor(Type::IfcWallType,entity_descriptor_map.find(Type::IfcBuildingElementType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcWallTypeEnum);
    current = entity_descriptor_map[Type::IfcWasteTerminalType] = new IfcEntityDescriptor(Type::IfcWasteTerminalType,entity_descriptor_map.find(Type::IfcFlowTerminalType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcWasteTerminalTypeEnum);
    current = entity_descriptor_map[Type::IfcWorkControl] = new IfcEntityDescriptor(Type::IfcWorkControl,entity_descriptor_map.find(Type::IfcControl)->second);
    current->add("Identifier",false,IfcUtil::Argument_STRING,Type::IfcIdentifier);
    current->add("CreationDate",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcDateTimeSelect);
    current->add("Creators",true,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcPerson);
    current->add("Purpose",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current->add("Duration",true,IfcUtil::Argument_DOUBLE,Type::IfcTimeMeasure);
    current->add("TotalFloat",true,IfcUtil::Argument_DOUBLE,Type::IfcTimeMeasure);
    current->add("StartTime",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcDateTimeSelect);
    current->add("FinishTime",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcDateTimeSelect);
    current->add("WorkControlType",true,IfcUtil::Argument_ENUMERATION,Type::IfcWorkControlTypeEnum);
    current->add("UserDefinedControlType",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current = entity_descriptor_map[Type::IfcWorkPlan] = new IfcEntityDescriptor(Type::IfcWorkPlan,entity_descriptor_map.find(Type::IfcWorkControl)->second);

    current = entity_descriptor_map[Type::IfcWorkSchedule] = new IfcEntityDescriptor(Type::IfcWorkSchedule,entity_descriptor_map.find(Type::IfcWorkControl)->second);

    current = entity_descriptor_map[Type::IfcZone] = new IfcEntityDescriptor(Type::IfcZone,entity_descriptor_map.find(Type::IfcGroup)->second);

    current = entity_descriptor_map[Type::Ifc2DCompositeCurve] = new IfcEntityDescriptor(Type::Ifc2DCompositeCurve,entity_descriptor_map.find(Type::IfcCompositeCurve)->second);

    current = entity_descriptor_map[Type::IfcActionRequest] = new IfcEntityDescriptor(Type::IfcActionRequest,entity_descriptor_map.find(Type::IfcControl)->second);
    current->add("RequestID",false,IfcUtil::Argument_STRING,Type::IfcIdentifier);
    current = entity_descriptor_map[Type::IfcAirTerminalBoxType] = new IfcEntityDescriptor(Type::IfcAirTerminalBoxType,entity_descriptor_map.find(Type::IfcFlowControllerType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcAirTerminalBoxTypeEnum);
    current = entity_descriptor_map[Type::IfcAirTerminalType] = new IfcEntityDescriptor(Type::IfcAirTerminalType,entity_descriptor_map.find(Type::IfcFlowTerminalType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcAirTerminalTypeEnum);
    current = entity_descriptor_map[Type::IfcAirToAirHeatRecoveryType] = new IfcEntityDescriptor(Type::IfcAirToAirHeatRecoveryType,entity_descriptor_map.find(Type::IfcEnergyConversionDeviceType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcAirToAirHeatRecoveryTypeEnum);
    current = entity_descriptor_map[Type::IfcAngularDimension] = new IfcEntityDescriptor(Type::IfcAngularDimension,entity_descriptor_map.find(Type::IfcDimensionCurveDirectedCallout)->second);

    current = entity_descriptor_map[Type::IfcAsset] = new IfcEntityDescriptor(Type::IfcAsset,entity_descriptor_map.find(Type::IfcGroup)->second);
    current->add("AssetID",false,IfcUtil::Argument_STRING,Type::IfcIdentifier);
    current->add("OriginalValue",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcCostValue);
    current->add("CurrentValue",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcCostValue);
    current->add("TotalReplacementCost",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcCostValue);
    current->add("Owner",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcActorSelect);
    current->add("User",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcActorSelect);
    current->add("ResponsiblePerson",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcPerson);
    current->add("IncorporationDate",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcCalendarDate);
    current->add("DepreciatedValue",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcCostValue);
    current = entity_descriptor_map[Type::IfcBSplineCurve] = new IfcEntityDescriptor(Type::IfcBSplineCurve,entity_descriptor_map.find(Type::IfcBoundedCurve)->second);
    current->add("Degree",false,IfcUtil::Argument_INT,Type::UNDEFINED);
    current->add("ControlPointsList",false,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcCartesianPoint);
    current->add("CurveForm",false,IfcUtil::Argument_ENUMERATION,Type::IfcBSplineCurveForm);
    current->add("ClosedCurve",false,IfcUtil::Argument_BOOL,Type::UNDEFINED);
    current->add("SelfIntersect",false,IfcUtil::Argument_BOOL,Type::UNDEFINED);
    current = entity_descriptor_map[Type::IfcBeamType] = new IfcEntityDescriptor(Type::IfcBeamType,entity_descriptor_map.find(Type::IfcBuildingElementType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcBeamTypeEnum);
    current = entity_descriptor_map[Type::IfcBezierCurve] = new IfcEntityDescriptor(Type::IfcBezierCurve,entity_descriptor_map.find(Type::IfcBSplineCurve)->second);

    current = entity_descriptor_map[Type::IfcBoilerType] = new IfcEntityDescriptor(Type::IfcBoilerType,entity_descriptor_map.find(Type::IfcEnergyConversionDeviceType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcBoilerTypeEnum);
    current = entity_descriptor_map[Type::IfcBuildingElement] = new IfcEntityDescriptor(Type::IfcBuildingElement,entity_descriptor_map.find(Type::IfcElement)->second);

    current = entity_descriptor_map[Type::IfcBuildingElementComponent] = new IfcEntityDescriptor(Type::IfcBuildingElementComponent,entity_descriptor_map.find(Type::IfcBuildingElement)->second);

    current = entity_descriptor_map[Type::IfcBuildingElementPart] = new IfcEntityDescriptor(Type::IfcBuildingElementPart,entity_descriptor_map.find(Type::IfcBuildingElementComponent)->second);

    current = entity_descriptor_map[Type::IfcBuildingElementProxy] = new IfcEntityDescriptor(Type::IfcBuildingElementProxy,entity_descriptor_map.find(Type::IfcBuildingElement)->second);
    current->add("CompositionType",true,IfcUtil::Argument_ENUMERATION,Type::IfcElementCompositionEnum);
    current = entity_descriptor_map[Type::IfcBuildingElementProxyType] = new IfcEntityDescriptor(Type::IfcBuildingElementProxyType,entity_descriptor_map.find(Type::IfcBuildingElementType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcBuildingElementProxyTypeEnum);
    current = entity_descriptor_map[Type::IfcCableCarrierFittingType] = new IfcEntityDescriptor(Type::IfcCableCarrierFittingType,entity_descriptor_map.find(Type::IfcFlowFittingType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcCableCarrierFittingTypeEnum);
    current = entity_descriptor_map[Type::IfcCableCarrierSegmentType] = new IfcEntityDescriptor(Type::IfcCableCarrierSegmentType,entity_descriptor_map.find(Type::IfcFlowSegmentType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcCableCarrierSegmentTypeEnum);
    current = entity_descriptor_map[Type::IfcCableSegmentType] = new IfcEntityDescriptor(Type::IfcCableSegmentType,entity_descriptor_map.find(Type::IfcFlowSegmentType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcCableSegmentTypeEnum);
    current = entity_descriptor_map[Type::IfcChillerType] = new IfcEntityDescriptor(Type::IfcChillerType,entity_descriptor_map.find(Type::IfcEnergyConversionDeviceType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcChillerTypeEnum);
    current = entity_descriptor_map[Type::IfcCircle] = new IfcEntityDescriptor(Type::IfcCircle,entity_descriptor_map.find(Type::IfcConic)->second);
    current->add("Radius",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current = entity_descriptor_map[Type::IfcCoilType] = new IfcEntityDescriptor(Type::IfcCoilType,entity_descriptor_map.find(Type::IfcEnergyConversionDeviceType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcCoilTypeEnum);
    current = entity_descriptor_map[Type::IfcColumn] = new IfcEntityDescriptor(Type::IfcColumn,entity_descriptor_map.find(Type::IfcBuildingElement)->second);

    current = entity_descriptor_map[Type::IfcCompressorType] = new IfcEntityDescriptor(Type::IfcCompressorType,entity_descriptor_map.find(Type::IfcFlowMovingDeviceType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcCompressorTypeEnum);
    current = entity_descriptor_map[Type::IfcCondenserType] = new IfcEntityDescriptor(Type::IfcCondenserType,entity_descriptor_map.find(Type::IfcEnergyConversionDeviceType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcCondenserTypeEnum);
    current = entity_descriptor_map[Type::IfcCondition] = new IfcEntityDescriptor(Type::IfcCondition,entity_descriptor_map.find(Type::IfcGroup)->second);

    current = entity_descriptor_map[Type::IfcConditionCriterion] = new IfcEntityDescriptor(Type::IfcConditionCriterion,entity_descriptor_map.find(Type::IfcControl)->second);
    current->add("Criterion",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcConditionCriterionSelect);
    current->add("CriterionDateTime",false,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcDateTimeSelect);
    current = entity_descriptor_map[Type::IfcConstructionEquipmentResource] = new IfcEntityDescriptor(Type::IfcConstructionEquipmentResource,entity_descriptor_map.find(Type::IfcConstructionResource)->second);

    current = entity_descriptor_map[Type::IfcConstructionMaterialResource] = new IfcEntityDescriptor(Type::IfcConstructionMaterialResource,entity_descriptor_map.find(Type::IfcConstructionResource)->second);
    current->add("Suppliers",true,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcActorSelect);
    current->add("UsageRatio",true,IfcUtil::Argument_DOUBLE,Type::IfcRatioMeasure);
    current = entity_descriptor_map[Type::IfcConstructionProductResource] = new IfcEntityDescriptor(Type::IfcConstructionProductResource,entity_descriptor_map.find(Type::IfcConstructionResource)->second);

    current = entity_descriptor_map[Type::IfcCooledBeamType] = new IfcEntityDescriptor(Type::IfcCooledBeamType,entity_descriptor_map.find(Type::IfcEnergyConversionDeviceType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcCooledBeamTypeEnum);
    current = entity_descriptor_map[Type::IfcCoolingTowerType] = new IfcEntityDescriptor(Type::IfcCoolingTowerType,entity_descriptor_map.find(Type::IfcEnergyConversionDeviceType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcCoolingTowerTypeEnum);
    current = entity_descriptor_map[Type::IfcCovering] = new IfcEntityDescriptor(Type::IfcCovering,entity_descriptor_map.find(Type::IfcBuildingElement)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcCoveringTypeEnum);
    current = entity_descriptor_map[Type::IfcCurtainWall] = new IfcEntityDescriptor(Type::IfcCurtainWall,entity_descriptor_map.find(Type::IfcBuildingElement)->second);

    current = entity_descriptor_map[Type::IfcDamperType] = new IfcEntityDescriptor(Type::IfcDamperType,entity_descriptor_map.find(Type::IfcFlowControllerType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcDamperTypeEnum);
    current = entity_descriptor_map[Type::IfcDiameterDimension] = new IfcEntityDescriptor(Type::IfcDiameterDimension,entity_descriptor_map.find(Type::IfcDimensionCurveDirectedCallout)->second);

    current = entity_descriptor_map[Type::IfcDiscreteAccessory] = new IfcEntityDescriptor(Type::IfcDiscreteAccessory,entity_descriptor_map.find(Type::IfcElementComponent)->second);

    current = entity_descriptor_map[Type::IfcDiscreteAccessoryType] = new IfcEntityDescriptor(Type::IfcDiscreteAccessoryType,entity_descriptor_map.find(Type::IfcElementComponentType)->second);

    current = entity_descriptor_map[Type::IfcDistributionChamberElementType] = new IfcEntityDescriptor(Type::IfcDistributionChamberElementType,entity_descriptor_map.find(Type::IfcDistributionFlowElementType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcDistributionChamberElementTypeEnum);
    current = entity_descriptor_map[Type::IfcDistributionControlElementType] = new IfcEntityDescriptor(Type::IfcDistributionControlElementType,entity_descriptor_map.find(Type::IfcDistributionElementType)->second);

    current = entity_descriptor_map[Type::IfcDistributionElement] = new IfcEntityDescriptor(Type::IfcDistributionElement,entity_descriptor_map.find(Type::IfcElement)->second);

    current = entity_descriptor_map[Type::IfcDistributionFlowElement] = new IfcEntityDescriptor(Type::IfcDistributionFlowElement,entity_descriptor_map.find(Type::IfcDistributionElement)->second);

    current = entity_descriptor_map[Type::IfcDistributionPort] = new IfcEntityDescriptor(Type::IfcDistributionPort,entity_descriptor_map.find(Type::IfcPort)->second);
    current->add("FlowDirection",true,IfcUtil::Argument_ENUMERATION,Type::IfcFlowDirectionEnum);
    current = entity_descriptor_map[Type::IfcDoor] = new IfcEntityDescriptor(Type::IfcDoor,entity_descriptor_map.find(Type::IfcBuildingElement)->second);
    current->add("OverallHeight",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("OverallWidth",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current = entity_descriptor_map[Type::IfcDuctFittingType] = new IfcEntityDescriptor(Type::IfcDuctFittingType,entity_descriptor_map.find(Type::IfcFlowFittingType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcDuctFittingTypeEnum);
    current = entity_descriptor_map[Type::IfcDuctSegmentType] = new IfcEntityDescriptor(Type::IfcDuctSegmentType,entity_descriptor_map.find(Type::IfcFlowSegmentType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcDuctSegmentTypeEnum);
    current = entity_descriptor_map[Type::IfcDuctSilencerType] = new IfcEntityDescriptor(Type::IfcDuctSilencerType,entity_descriptor_map.find(Type::IfcFlowTreatmentDeviceType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcDuctSilencerTypeEnum);
    current = entity_descriptor_map[Type::IfcEdgeFeature] = new IfcEntityDescriptor(Type::IfcEdgeFeature,entity_descriptor_map.find(Type::IfcFeatureElementSubtraction)->second);
    current->add("FeatureLength",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current = entity_descriptor_map[Type::IfcElectricApplianceType] = new IfcEntityDescriptor(Type::IfcElectricApplianceType,entity_descriptor_map.find(Type::IfcFlowTerminalType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcElectricApplianceTypeEnum);
    current = entity_descriptor_map[Type::IfcElectricFlowStorageDeviceType] = new IfcEntityDescriptor(Type::IfcElectricFlowStorageDeviceType,entity_descriptor_map.find(Type::IfcFlowStorageDeviceType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcElectricFlowStorageDeviceTypeEnum);
    current = entity_descriptor_map[Type::IfcElectricGeneratorType] = new IfcEntityDescriptor(Type::IfcElectricGeneratorType,entity_descriptor_map.find(Type::IfcEnergyConversionDeviceType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcElectricGeneratorTypeEnum);
    current = entity_descriptor_map[Type::IfcElectricHeaterType] = new IfcEntityDescriptor(Type::IfcElectricHeaterType,entity_descriptor_map.find(Type::IfcFlowTerminalType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcElectricHeaterTypeEnum);
    current = entity_descriptor_map[Type::IfcElectricMotorType] = new IfcEntityDescriptor(Type::IfcElectricMotorType,entity_descriptor_map.find(Type::IfcEnergyConversionDeviceType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcElectricMotorTypeEnum);
    current = entity_descriptor_map[Type::IfcElectricTimeControlType] = new IfcEntityDescriptor(Type::IfcElectricTimeControlType,entity_descriptor_map.find(Type::IfcFlowControllerType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcElectricTimeControlTypeEnum);
    current = entity_descriptor_map[Type::IfcElectricalCircuit] = new IfcEntityDescriptor(Type::IfcElectricalCircuit,entity_descriptor_map.find(Type::IfcSystem)->second);

    current = entity_descriptor_map[Type::IfcElectricalElement] = new IfcEntityDescriptor(Type::IfcElectricalElement,entity_descriptor_map.find(Type::IfcElement)->second);

    current = entity_descriptor_map[Type::IfcEnergyConversionDevice] = new IfcEntityDescriptor(Type::IfcEnergyConversionDevice,entity_descriptor_map.find(Type::IfcDistributionFlowElement)->second);

    current = entity_descriptor_map[Type::IfcFanType] = new IfcEntityDescriptor(Type::IfcFanType,entity_descriptor_map.find(Type::IfcFlowMovingDeviceType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcFanTypeEnum);
    current = entity_descriptor_map[Type::IfcFilterType] = new IfcEntityDescriptor(Type::IfcFilterType,entity_descriptor_map.find(Type::IfcFlowTreatmentDeviceType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcFilterTypeEnum);
    current = entity_descriptor_map[Type::IfcFireSuppressionTerminalType] = new IfcEntityDescriptor(Type::IfcFireSuppressionTerminalType,entity_descriptor_map.find(Type::IfcFlowTerminalType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcFireSuppressionTerminalTypeEnum);
    current = entity_descriptor_map[Type::IfcFlowController] = new IfcEntityDescriptor(Type::IfcFlowController,entity_descriptor_map.find(Type::IfcDistributionFlowElement)->second);

    current = entity_descriptor_map[Type::IfcFlowFitting] = new IfcEntityDescriptor(Type::IfcFlowFitting,entity_descriptor_map.find(Type::IfcDistributionFlowElement)->second);

    current = entity_descriptor_map[Type::IfcFlowInstrumentType] = new IfcEntityDescriptor(Type::IfcFlowInstrumentType,entity_descriptor_map.find(Type::IfcDistributionControlElementType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcFlowInstrumentTypeEnum);
    current = entity_descriptor_map[Type::IfcFlowMovingDevice] = new IfcEntityDescriptor(Type::IfcFlowMovingDevice,entity_descriptor_map.find(Type::IfcDistributionFlowElement)->second);

    current = entity_descriptor_map[Type::IfcFlowSegment] = new IfcEntityDescriptor(Type::IfcFlowSegment,entity_descriptor_map.find(Type::IfcDistributionFlowElement)->second);

    current = entity_descriptor_map[Type::IfcFlowStorageDevice] = new IfcEntityDescriptor(Type::IfcFlowStorageDevice,entity_descriptor_map.find(Type::IfcDistributionFlowElement)->second);

    current = entity_descriptor_map[Type::IfcFlowTerminal] = new IfcEntityDescriptor(Type::IfcFlowTerminal,entity_descriptor_map.find(Type::IfcDistributionFlowElement)->second);

    current = entity_descriptor_map[Type::IfcFlowTreatmentDevice] = new IfcEntityDescriptor(Type::IfcFlowTreatmentDevice,entity_descriptor_map.find(Type::IfcDistributionFlowElement)->second);

    current = entity_descriptor_map[Type::IfcFooting] = new IfcEntityDescriptor(Type::IfcFooting,entity_descriptor_map.find(Type::IfcBuildingElement)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcFootingTypeEnum);
    current = entity_descriptor_map[Type::IfcMember] = new IfcEntityDescriptor(Type::IfcMember,entity_descriptor_map.find(Type::IfcBuildingElement)->second);

    current = entity_descriptor_map[Type::IfcPile] = new IfcEntityDescriptor(Type::IfcPile,entity_descriptor_map.find(Type::IfcBuildingElement)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcPileTypeEnum);
    current->add("ConstructionType",true,IfcUtil::Argument_ENUMERATION,Type::IfcPileConstructionEnum);
    current = entity_descriptor_map[Type::IfcPlate] = new IfcEntityDescriptor(Type::IfcPlate,entity_descriptor_map.find(Type::IfcBuildingElement)->second);

    current = entity_descriptor_map[Type::IfcRailing] = new IfcEntityDescriptor(Type::IfcRailing,entity_descriptor_map.find(Type::IfcBuildingElement)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcRailingTypeEnum);
    current = entity_descriptor_map[Type::IfcRamp] = new IfcEntityDescriptor(Type::IfcRamp,entity_descriptor_map.find(Type::IfcBuildingElement)->second);
    current->add("ShapeType",false,IfcUtil::Argument_ENUMERATION,Type::IfcRampTypeEnum);
    current = entity_descriptor_map[Type::IfcRampFlight] = new IfcEntityDescriptor(Type::IfcRampFlight,entity_descriptor_map.find(Type::IfcBuildingElement)->second);

    current = entity_descriptor_map[Type::IfcRationalBezierCurve] = new IfcEntityDescriptor(Type::IfcRationalBezierCurve,entity_descriptor_map.find(Type::IfcBezierCurve)->second);
    current->add("WeightsData",false,IfcUtil::Argument_AGGREGATE_OF_DOUBLE,Type::UNDEFINED);
    current = entity_descriptor_map[Type::IfcReinforcingElement] = new IfcEntityDescriptor(Type::IfcReinforcingElement,entity_descriptor_map.find(Type::IfcBuildingElementComponent)->second);
    current->add("SteelGrade",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current = entity_descriptor_map[Type::IfcReinforcingMesh] = new IfcEntityDescriptor(Type::IfcReinforcingMesh,entity_descriptor_map.find(Type::IfcReinforcingElement)->second);
    current->add("MeshLength",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("MeshWidth",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("LongitudinalBarNominalDiameter",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("TransverseBarNominalDiameter",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("LongitudinalBarCrossSectionArea",false,IfcUtil::Argument_DOUBLE,Type::IfcAreaMeasure);
    current->add("TransverseBarCrossSectionArea",false,IfcUtil::Argument_DOUBLE,Type::IfcAreaMeasure);
    current->add("LongitudinalBarSpacing",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("TransverseBarSpacing",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current = entity_descriptor_map[Type::IfcRoof] = new IfcEntityDescriptor(Type::IfcRoof,entity_descriptor_map.find(Type::IfcBuildingElement)->second);
    current->add("ShapeType",false,IfcUtil::Argument_ENUMERATION,Type::IfcRoofTypeEnum);
    current = entity_descriptor_map[Type::IfcRoundedEdgeFeature] = new IfcEntityDescriptor(Type::IfcRoundedEdgeFeature,entity_descriptor_map.find(Type::IfcEdgeFeature)->second);
    current->add("Radius",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current = entity_descriptor_map[Type::IfcSensorType] = new IfcEntityDescriptor(Type::IfcSensorType,entity_descriptor_map.find(Type::IfcDistributionControlElementType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcSensorTypeEnum);
    current = entity_descriptor_map[Type::IfcSlab] = new IfcEntityDescriptor(Type::IfcSlab,entity_descriptor_map.find(Type::IfcBuildingElement)->second);
    current->add("PredefinedType",true,IfcUtil::Argument_ENUMERATION,Type::IfcSlabTypeEnum);
    current = entity_descriptor_map[Type::IfcStair] = new IfcEntityDescriptor(Type::IfcStair,entity_descriptor_map.find(Type::IfcBuildingElement)->second);
    current->add("ShapeType",false,IfcUtil::Argument_ENUMERATION,Type::IfcStairTypeEnum);
    current = entity_descriptor_map[Type::IfcStairFlight] = new IfcEntityDescriptor(Type::IfcStairFlight,entity_descriptor_map.find(Type::IfcBuildingElement)->second);
    current->add("NumberOfRiser",true,IfcUtil::Argument_INT,Type::UNDEFINED);
    current->add("NumberOfTreads",true,IfcUtil::Argument_INT,Type::UNDEFINED);
    current->add("RiserHeight",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("TreadLength",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current = entity_descriptor_map[Type::IfcStructuralAnalysisModel] = new IfcEntityDescriptor(Type::IfcStructuralAnalysisModel,entity_descriptor_map.find(Type::IfcSystem)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcAnalysisModelTypeEnum);
    current->add("OrientationOf2DPlane",true,IfcUtil::Argument_ENTITY_INSTANCE,Type::IfcAxis2Placement3D);
    current->add("LoadedBy",true,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcStructuralLoadGroup);
    current->add("HasResults",true,IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE,Type::IfcStructuralResultGroup);
    current = entity_descriptor_map[Type::IfcTendon] = new IfcEntityDescriptor(Type::IfcTendon,entity_descriptor_map.find(Type::IfcReinforcingElement)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcTendonTypeEnum);
    current->add("NominalDiameter",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("CrossSectionArea",false,IfcUtil::Argument_DOUBLE,Type::IfcAreaMeasure);
    current->add("TensionForce",true,IfcUtil::Argument_DOUBLE,Type::IfcForceMeasure);
    current->add("PreStress",true,IfcUtil::Argument_DOUBLE,Type::IfcPressureMeasure);
    current->add("FrictionCoefficient",true,IfcUtil::Argument_DOUBLE,Type::IfcNormalisedRatioMeasure);
    current->add("AnchorageSlip",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("MinCurvatureRadius",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current = entity_descriptor_map[Type::IfcTendonAnchor] = new IfcEntityDescriptor(Type::IfcTendonAnchor,entity_descriptor_map.find(Type::IfcReinforcingElement)->second);

    current = entity_descriptor_map[Type::IfcVibrationIsolatorType] = new IfcEntityDescriptor(Type::IfcVibrationIsolatorType,entity_descriptor_map.find(Type::IfcDiscreteAccessoryType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcVibrationIsolatorTypeEnum);
    current = entity_descriptor_map[Type::IfcWall] = new IfcEntityDescriptor(Type::IfcWall,entity_descriptor_map.find(Type::IfcBuildingElement)->second);

    current = entity_descriptor_map[Type::IfcWallStandardCase] = new IfcEntityDescriptor(Type::IfcWallStandardCase,entity_descriptor_map.find(Type::IfcWall)->second);

    current = entity_descriptor_map[Type::IfcWindow] = new IfcEntityDescriptor(Type::IfcWindow,entity_descriptor_map.find(Type::IfcBuildingElement)->second);
    current->add("OverallHeight",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("OverallWidth",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current = entity_descriptor_map[Type::IfcActuatorType] = new IfcEntityDescriptor(Type::IfcActuatorType,entity_descriptor_map.find(Type::IfcDistributionControlElementType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcActuatorTypeEnum);
    current = entity_descriptor_map[Type::IfcAlarmType] = new IfcEntityDescriptor(Type::IfcAlarmType,entity_descriptor_map.find(Type::IfcDistributionControlElementType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcAlarmTypeEnum);
    current = entity_descriptor_map[Type::IfcBeam] = new IfcEntityDescriptor(Type::IfcBeam,entity_descriptor_map.find(Type::IfcBuildingElement)->second);

    current = entity_descriptor_map[Type::IfcChamferEdgeFeature] = new IfcEntityDescriptor(Type::IfcChamferEdgeFeature,entity_descriptor_map.find(Type::IfcEdgeFeature)->second);
    current->add("Width",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("Height",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current = entity_descriptor_map[Type::IfcControllerType] = new IfcEntityDescriptor(Type::IfcControllerType,entity_descriptor_map.find(Type::IfcDistributionControlElementType)->second);
    current->add("PredefinedType",false,IfcUtil::Argument_ENUMERATION,Type::IfcControllerTypeEnum);
    current = entity_descriptor_map[Type::IfcDistributionChamberElement] = new IfcEntityDescriptor(Type::IfcDistributionChamberElement,entity_descriptor_map.find(Type::IfcDistributionFlowElement)->second);

    current = entity_descriptor_map[Type::IfcDistributionControlElement] = new IfcEntityDescriptor(Type::IfcDistributionControlElement,entity_descriptor_map.find(Type::IfcDistributionElement)->second);
    current->add("ControlElementId",true,IfcUtil::Argument_STRING,Type::IfcIdentifier);
    current = entity_descriptor_map[Type::IfcElectricDistributionPoint] = new IfcEntityDescriptor(Type::IfcElectricDistributionPoint,entity_descriptor_map.find(Type::IfcFlowController)->second);
    current->add("DistributionPointFunction",false,IfcUtil::Argument_ENUMERATION,Type::IfcElectricDistributionPointFunctionEnum);
    current->add("UserDefinedFunction",true,IfcUtil::Argument_STRING,Type::IfcLabel);
    current = entity_descriptor_map[Type::IfcReinforcingBar] = new IfcEntityDescriptor(Type::IfcReinforcingBar,entity_descriptor_map.find(Type::IfcReinforcingElement)->second);
    current->add("NominalDiameter",false,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("CrossSectionArea",false,IfcUtil::Argument_DOUBLE,Type::IfcAreaMeasure);
    current->add("BarLength",true,IfcUtil::Argument_DOUBLE,Type::IfcPositiveLengthMeasure);
    current->add("BarRole",false,IfcUtil::Argument_ENUMERATION,Type::IfcReinforcingBarRoleEnum);
    current->add("BarSurface",true,IfcUtil::Argument_ENUMERATION,Type::IfcReinforcingBarSurfaceEnum);
    // Enumerations
    IfcEnumerationDescriptor* current_enum;
    std::vector<std::string> values;
    values.clear(); values.reserve(128);
    values.push_back("DEAD_LOAD_G");
    values.push_back("COMPLETION_G1");
    values.push_back("LIVE_LOAD_Q");
    values.push_back("SNOW_S");
    values.push_back("WIND_W");
    values.push_back("PRESTRESSING_P");
    values.push_back("SETTLEMENT_U");
    values.push_back("TEMPERATURE_T");
    values.push_back("EARTHQUAKE_E");
    values.push_back("FIRE");
    values.push_back("IMPULSE");
    values.push_back("IMPACT");
    values.push_back("TRANSPORT");
    values.push_back("ERECTION");
    values.push_back("PROPPING");
    values.push_back("SYSTEM_IMPERFECTION");
    values.push_back("SHRINKAGE");
    values.push_back("CREEP");
    values.push_back("LACK_OF_FIT");
    values.push_back("BUOYANCY");
    values.push_back("ICE");
    values.push_back("CURRENT");
    values.push_back("WAVE");
    values.push_back("RAIN");
    values.push_back("BRAKES");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcActionSourceTypeEnum] = new IfcEnumerationDescriptor(Type::IfcActionSourceTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("PERMANENT_G");
    values.push_back("VARIABLE_Q");
    values.push_back("EXTRAORDINARY_A");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcActionTypeEnum] = new IfcEnumerationDescriptor(Type::IfcActionTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("ELECTRICACTUATOR");
    values.push_back("HANDOPERATEDACTUATOR");
    values.push_back("HYDRAULICACTUATOR");
    values.push_back("PNEUMATICACTUATOR");
    values.push_back("THERMOSTATICACTUATOR");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcActuatorTypeEnum] = new IfcEnumerationDescriptor(Type::IfcActuatorTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("OFFICE");
    values.push_back("SITE");
    values.push_back("HOME");
    values.push_back("DISTRIBUTIONPOINT");
    values.push_back("USERDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcAddressTypeEnum] = new IfcEnumerationDescriptor(Type::IfcAddressTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("AHEAD");
    values.push_back("BEHIND");
    current_enum = enumeration_descriptor_map[Type::IfcAheadOrBehind] = new IfcEnumerationDescriptor(Type::IfcAheadOrBehind, values);
    values.clear(); values.reserve(128);
    values.push_back("CONSTANTFLOW");
    values.push_back("VARIABLEFLOWPRESSUREDEPENDANT");
    values.push_back("VARIABLEFLOWPRESSUREINDEPENDANT");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcAirTerminalBoxTypeEnum] = new IfcEnumerationDescriptor(Type::IfcAirTerminalBoxTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("GRILLE");
    values.push_back("REGISTER");
    values.push_back("DIFFUSER");
    values.push_back("EYEBALL");
    values.push_back("IRIS");
    values.push_back("LINEARGRILLE");
    values.push_back("LINEARDIFFUSER");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcAirTerminalTypeEnum] = new IfcEnumerationDescriptor(Type::IfcAirTerminalTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("FIXEDPLATECOUNTERFLOWEXCHANGER");
    values.push_back("FIXEDPLATECROSSFLOWEXCHANGER");
    values.push_back("FIXEDPLATEPARALLELFLOWEXCHANGER");
    values.push_back("ROTARYWHEEL");
    values.push_back("RUNAROUNDCOILLOOP");
    values.push_back("HEATPIPE");
    values.push_back("TWINTOWERENTHALPYRECOVERYLOOPS");
    values.push_back("THERMOSIPHONSEALEDTUBEHEATEXCHANGERS");
    values.push_back("THERMOSIPHONCOILTYPEHEATEXCHANGERS");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcAirToAirHeatRecoveryTypeEnum] = new IfcEnumerationDescriptor(Type::IfcAirToAirHeatRecoveryTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("BELL");
    values.push_back("BREAKGLASSBUTTON");
    values.push_back("LIGHT");
    values.push_back("MANUALPULLBOX");
    values.push_back("SIREN");
    values.push_back("WHISTLE");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcAlarmTypeEnum] = new IfcEnumerationDescriptor(Type::IfcAlarmTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("IN_PLANE_LOADING_2D");
    values.push_back("OUT_PLANE_LOADING_2D");
    values.push_back("LOADING_3D");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcAnalysisModelTypeEnum] = new IfcEnumerationDescriptor(Type::IfcAnalysisModelTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("FIRST_ORDER_THEORY");
    values.push_back("SECOND_ORDER_THEORY");
    values.push_back("THIRD_ORDER_THEORY");
    values.push_back("FULL_NONLINEAR_THEORY");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcAnalysisTheoryTypeEnum] = new IfcEnumerationDescriptor(Type::IfcAnalysisTheoryTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("ADD");
    values.push_back("DIVIDE");
    values.push_back("MULTIPLY");
    values.push_back("SUBTRACT");
    current_enum = enumeration_descriptor_map[Type::IfcArithmeticOperatorEnum] = new IfcEnumerationDescriptor(Type::IfcArithmeticOperatorEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("SITE");
    values.push_back("FACTORY");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcAssemblyPlaceEnum] = new IfcEnumerationDescriptor(Type::IfcAssemblyPlaceEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("POLYLINE_FORM");
    values.push_back("CIRCULAR_ARC");
    values.push_back("ELLIPTIC_ARC");
    values.push_back("PARABOLIC_ARC");
    values.push_back("HYPERBOLIC_ARC");
    values.push_back("UNSPECIFIED");
    current_enum = enumeration_descriptor_map[Type::IfcBSplineCurveForm] = new IfcEnumerationDescriptor(Type::IfcBSplineCurveForm, values);
    values.clear(); values.reserve(128);
    values.push_back("BEAM");
    values.push_back("JOIST");
    values.push_back("LINTEL");
    values.push_back("T_BEAM");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcBeamTypeEnum] = new IfcEnumerationDescriptor(Type::IfcBeamTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("GREATERTHAN");
    values.push_back("GREATERTHANOREQUALTO");
    values.push_back("LESSTHAN");
    values.push_back("LESSTHANOREQUALTO");
    values.push_back("EQUALTO");
    values.push_back("NOTEQUALTO");
    current_enum = enumeration_descriptor_map[Type::IfcBenchmarkEnum] = new IfcEnumerationDescriptor(Type::IfcBenchmarkEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("WATER");
    values.push_back("STEAM");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcBoilerTypeEnum] = new IfcEnumerationDescriptor(Type::IfcBoilerTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("UNION");
    values.push_back("INTERSECTION");
    values.push_back("DIFFERENCE");
    current_enum = enumeration_descriptor_map[Type::IfcBooleanOperator] = new IfcEnumerationDescriptor(Type::IfcBooleanOperator, values);
    values.clear(); values.reserve(128);
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcBuildingElementProxyTypeEnum] = new IfcEnumerationDescriptor(Type::IfcBuildingElementProxyTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("BEND");
    values.push_back("CROSS");
    values.push_back("REDUCER");
    values.push_back("TEE");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcCableCarrierFittingTypeEnum] = new IfcEnumerationDescriptor(Type::IfcCableCarrierFittingTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("CABLELADDERSEGMENT");
    values.push_back("CABLETRAYSEGMENT");
    values.push_back("CABLETRUNKINGSEGMENT");
    values.push_back("CONDUITSEGMENT");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcCableCarrierSegmentTypeEnum] = new IfcEnumerationDescriptor(Type::IfcCableCarrierSegmentTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("CABLESEGMENT");
    values.push_back("CONDUCTORSEGMENT");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcCableSegmentTypeEnum] = new IfcEnumerationDescriptor(Type::IfcCableSegmentTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("NOCHANGE");
    values.push_back("MODIFIED");
    values.push_back("ADDED");
    values.push_back("DELETED");
    values.push_back("MODIFIEDADDED");
    values.push_back("MODIFIEDDELETED");
    current_enum = enumeration_descriptor_map[Type::IfcChangeActionEnum] = new IfcEnumerationDescriptor(Type::IfcChangeActionEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("AIRCOOLED");
    values.push_back("WATERCOOLED");
    values.push_back("HEATRECOVERY");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcChillerTypeEnum] = new IfcEnumerationDescriptor(Type::IfcChillerTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("DXCOOLINGCOIL");
    values.push_back("WATERCOOLINGCOIL");
    values.push_back("STEAMHEATINGCOIL");
    values.push_back("WATERHEATINGCOIL");
    values.push_back("ELECTRICHEATINGCOIL");
    values.push_back("GASHEATINGCOIL");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcCoilTypeEnum] = new IfcEnumerationDescriptor(Type::IfcCoilTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("COLUMN");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcColumnTypeEnum] = new IfcEnumerationDescriptor(Type::IfcColumnTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("DYNAMIC");
    values.push_back("RECIPROCATING");
    values.push_back("ROTARY");
    values.push_back("SCROLL");
    values.push_back("TROCHOIDAL");
    values.push_back("SINGLESTAGE");
    values.push_back("BOOSTER");
    values.push_back("OPENTYPE");
    values.push_back("HERMETIC");
    values.push_back("SEMIHERMETIC");
    values.push_back("WELDEDSHELLHERMETIC");
    values.push_back("ROLLINGPISTON");
    values.push_back("ROTARYVANE");
    values.push_back("SINGLESCREW");
    values.push_back("TWINSCREW");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcCompressorTypeEnum] = new IfcEnumerationDescriptor(Type::IfcCompressorTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("WATERCOOLEDSHELLTUBE");
    values.push_back("WATERCOOLEDSHELLCOIL");
    values.push_back("WATERCOOLEDTUBEINTUBE");
    values.push_back("WATERCOOLEDBRAZEDPLATE");
    values.push_back("AIRCOOLED");
    values.push_back("EVAPORATIVECOOLED");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcCondenserTypeEnum] = new IfcEnumerationDescriptor(Type::IfcCondenserTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("ATPATH");
    values.push_back("ATSTART");
    values.push_back("ATEND");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcConnectionTypeEnum] = new IfcEnumerationDescriptor(Type::IfcConnectionTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("HARD");
    values.push_back("SOFT");
    values.push_back("ADVISORY");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcConstraintEnum] = new IfcEnumerationDescriptor(Type::IfcConstraintEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("FLOATING");
    values.push_back("PROPORTIONAL");
    values.push_back("PROPORTIONALINTEGRAL");
    values.push_back("PROPORTIONALINTEGRALDERIVATIVE");
    values.push_back("TIMEDTWOPOSITION");
    values.push_back("TWOPOSITION");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcControllerTypeEnum] = new IfcEnumerationDescriptor(Type::IfcControllerTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("ACTIVE");
    values.push_back("PASSIVE");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcCooledBeamTypeEnum] = new IfcEnumerationDescriptor(Type::IfcCooledBeamTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("NATURALDRAFT");
    values.push_back("MECHANICALINDUCEDDRAFT");
    values.push_back("MECHANICALFORCEDDRAFT");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcCoolingTowerTypeEnum] = new IfcEnumerationDescriptor(Type::IfcCoolingTowerTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("BUDGET");
    values.push_back("COSTPLAN");
    values.push_back("ESTIMATE");
    values.push_back("TENDER");
    values.push_back("PRICEDBILLOFQUANTITIES");
    values.push_back("UNPRICEDBILLOFQUANTITIES");
    values.push_back("SCHEDULEOFRATES");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcCostScheduleTypeEnum] = new IfcEnumerationDescriptor(Type::IfcCostScheduleTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("CEILING");
    values.push_back("FLOORING");
    values.push_back("CLADDING");
    values.push_back("ROOFING");
    values.push_back("INSULATION");
    values.push_back("MEMBRANE");
    values.push_back("SLEEVING");
    values.push_back("WRAPPING");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcCoveringTypeEnum] = new IfcEnumerationDescriptor(Type::IfcCoveringTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("AED");
    values.push_back("AES");
    values.push_back("ATS");
    values.push_back("AUD");
    values.push_back("BBD");
    values.push_back("BEG");
    values.push_back("BGL");
    values.push_back("BHD");
    values.push_back("BMD");
    values.push_back("BND");
    values.push_back("BRL");
    values.push_back("BSD");
    values.push_back("BWP");
    values.push_back("BZD");
    values.push_back("CAD");
    values.push_back("CBD");
    values.push_back("CHF");
    values.push_back("CLP");
    values.push_back("CNY");
    values.push_back("CYS");
    values.push_back("CZK");
    values.push_back("DDP");
    values.push_back("DEM");
    values.push_back("DKK");
    values.push_back("EGL");
    values.push_back("EST");
    values.push_back("EUR");
    values.push_back("FAK");
    values.push_back("FIM");
    values.push_back("FJD");
    values.push_back("FKP");
    values.push_back("FRF");
    values.push_back("GBP");
    values.push_back("GIP");
    values.push_back("GMD");
    values.push_back("GRX");
    values.push_back("HKD");
    values.push_back("HUF");
    values.push_back("ICK");
    values.push_back("IDR");
    values.push_back("ILS");
    values.push_back("INR");
    values.push_back("IRP");
    values.push_back("ITL");
    values.push_back("JMD");
    values.push_back("JOD");
    values.push_back("JPY");
    values.push_back("KES");
    values.push_back("KRW");
    values.push_back("KWD");
    values.push_back("KYD");
    values.push_back("LKR");
    values.push_back("LUF");
    values.push_back("MTL");
    values.push_back("MUR");
    values.push_back("MXN");
    values.push_back("MYR");
    values.push_back("NLG");
    values.push_back("NZD");
    values.push_back("OMR");
    values.push_back("PGK");
    values.push_back("PHP");
    values.push_back("PKR");
    values.push_back("PLN");
    values.push_back("PTN");
    values.push_back("QAR");
    values.push_back("RUR");
    values.push_back("SAR");
    values.push_back("SCR");
    values.push_back("SEK");
    values.push_back("SGD");
    values.push_back("SKP");
    values.push_back("THB");
    values.push_back("TRL");
    values.push_back("TTD");
    values.push_back("TWD");
    values.push_back("USD");
    values.push_back("VEB");
    values.push_back("VND");
    values.push_back("XEU");
    values.push_back("ZAR");
    values.push_back("ZWD");
    values.push_back("NOK");
    current_enum = enumeration_descriptor_map[Type::IfcCurrencyEnum] = new IfcEnumerationDescriptor(Type::IfcCurrencyEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcCurtainWallTypeEnum] = new IfcEnumerationDescriptor(Type::IfcCurtainWallTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("CONTROLDAMPER");
    values.push_back("FIREDAMPER");
    values.push_back("SMOKEDAMPER");
    values.push_back("FIRESMOKEDAMPER");
    values.push_back("BACKDRAFTDAMPER");
    values.push_back("RELIEFDAMPER");
    values.push_back("BLASTDAMPER");
    values.push_back("GRAVITYDAMPER");
    values.push_back("GRAVITYRELIEFDAMPER");
    values.push_back("BALANCINGDAMPER");
    values.push_back("FUMEHOODEXHAUST");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcDamperTypeEnum] = new IfcEnumerationDescriptor(Type::IfcDamperTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("MEASURED");
    values.push_back("PREDICTED");
    values.push_back("SIMULATED");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcDataOriginEnum] = new IfcEnumerationDescriptor(Type::IfcDataOriginEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("ANGULARVELOCITYUNIT");
    values.push_back("COMPOUNDPLANEANGLEUNIT");
    values.push_back("DYNAMICVISCOSITYUNIT");
    values.push_back("HEATFLUXDENSITYUNIT");
    values.push_back("INTEGERCOUNTRATEUNIT");
    values.push_back("ISOTHERMALMOISTURECAPACITYUNIT");
    values.push_back("KINEMATICVISCOSITYUNIT");
    values.push_back("LINEARVELOCITYUNIT");
    values.push_back("MASSDENSITYUNIT");
    values.push_back("MASSFLOWRATEUNIT");
    values.push_back("MOISTUREDIFFUSIVITYUNIT");
    values.push_back("MOLECULARWEIGHTUNIT");
    values.push_back("SPECIFICHEATCAPACITYUNIT");
    values.push_back("THERMALADMITTANCEUNIT");
    values.push_back("THERMALCONDUCTANCEUNIT");
    values.push_back("THERMALRESISTANCEUNIT");
    values.push_back("THERMALTRANSMITTANCEUNIT");
    values.push_back("VAPORPERMEABILITYUNIT");
    values.push_back("VOLUMETRICFLOWRATEUNIT");
    values.push_back("ROTATIONALFREQUENCYUNIT");
    values.push_back("TORQUEUNIT");
    values.push_back("MOMENTOFINERTIAUNIT");
    values.push_back("LINEARMOMENTUNIT");
    values.push_back("LINEARFORCEUNIT");
    values.push_back("PLANARFORCEUNIT");
    values.push_back("MODULUSOFELASTICITYUNIT");
    values.push_back("SHEARMODULUSUNIT");
    values.push_back("LINEARSTIFFNESSUNIT");
    values.push_back("ROTATIONALSTIFFNESSUNIT");
    values.push_back("MODULUSOFSUBGRADEREACTIONUNIT");
    values.push_back("ACCELERATIONUNIT");
    values.push_back("CURVATUREUNIT");
    values.push_back("HEATINGVALUEUNIT");
    values.push_back("IONCONCENTRATIONUNIT");
    values.push_back("LUMINOUSINTENSITYDISTRIBUTIONUNIT");
    values.push_back("MASSPERLENGTHUNIT");
    values.push_back("MODULUSOFLINEARSUBGRADEREACTIONUNIT");
    values.push_back("MODULUSOFROTATIONALSUBGRADEREACTIONUNIT");
    values.push_back("PHUNIT");
    values.push_back("ROTATIONALMASSUNIT");
    values.push_back("SECTIONAREAINTEGRALUNIT");
    values.push_back("SECTIONMODULUSUNIT");
    values.push_back("SOUNDPOWERUNIT");
    values.push_back("SOUNDPRESSUREUNIT");
    values.push_back("TEMPERATUREGRADIENTUNIT");
    values.push_back("THERMALEXPANSIONCOEFFICIENTUNIT");
    values.push_back("WARPINGCONSTANTUNIT");
    values.push_back("WARPINGMOMENTUNIT");
    values.push_back("USERDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcDerivedUnitEnum] = new IfcEnumerationDescriptor(Type::IfcDerivedUnitEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("ORIGIN");
    values.push_back("TARGET");
    current_enum = enumeration_descriptor_map[Type::IfcDimensionExtentUsage] = new IfcEnumerationDescriptor(Type::IfcDimensionExtentUsage, values);
    values.clear(); values.reserve(128);
    values.push_back("POSITIVE");
    values.push_back("NEGATIVE");
    current_enum = enumeration_descriptor_map[Type::IfcDirectionSenseEnum] = new IfcEnumerationDescriptor(Type::IfcDirectionSenseEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("FORMEDDUCT");
    values.push_back("INSPECTIONCHAMBER");
    values.push_back("INSPECTIONPIT");
    values.push_back("MANHOLE");
    values.push_back("METERCHAMBER");
    values.push_back("SUMP");
    values.push_back("TRENCH");
    values.push_back("VALVECHAMBER");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcDistributionChamberElementTypeEnum] = new IfcEnumerationDescriptor(Type::IfcDistributionChamberElementTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("PUBLIC");
    values.push_back("RESTRICTED");
    values.push_back("CONFIDENTIAL");
    values.push_back("PERSONAL");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcDocumentConfidentialityEnum] = new IfcEnumerationDescriptor(Type::IfcDocumentConfidentialityEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("DRAFT");
    values.push_back("FINALDRAFT");
    values.push_back("FINAL");
    values.push_back("REVISION");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcDocumentStatusEnum] = new IfcEnumerationDescriptor(Type::IfcDocumentStatusEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("SWINGING");
    values.push_back("DOUBLE_ACTING");
    values.push_back("SLIDING");
    values.push_back("FOLDING");
    values.push_back("REVOLVING");
    values.push_back("ROLLINGUP");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcDoorPanelOperationEnum] = new IfcEnumerationDescriptor(Type::IfcDoorPanelOperationEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("LEFT");
    values.push_back("MIDDLE");
    values.push_back("RIGHT");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcDoorPanelPositionEnum] = new IfcEnumerationDescriptor(Type::IfcDoorPanelPositionEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("ALUMINIUM");
    values.push_back("HIGH_GRADE_STEEL");
    values.push_back("STEEL");
    values.push_back("WOOD");
    values.push_back("ALUMINIUM_WOOD");
    values.push_back("ALUMINIUM_PLASTIC");
    values.push_back("PLASTIC");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcDoorStyleConstructionEnum] = new IfcEnumerationDescriptor(Type::IfcDoorStyleConstructionEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("SINGLE_SWING_LEFT");
    values.push_back("SINGLE_SWING_RIGHT");
    values.push_back("DOUBLE_DOOR_SINGLE_SWING");
    values.push_back("DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_LEFT");
    values.push_back("DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_RIGHT");
    values.push_back("DOUBLE_SWING_LEFT");
    values.push_back("DOUBLE_SWING_RIGHT");
    values.push_back("DOUBLE_DOOR_DOUBLE_SWING");
    values.push_back("SLIDING_TO_LEFT");
    values.push_back("SLIDING_TO_RIGHT");
    values.push_back("DOUBLE_DOOR_SLIDING");
    values.push_back("FOLDING_TO_LEFT");
    values.push_back("FOLDING_TO_RIGHT");
    values.push_back("DOUBLE_DOOR_FOLDING");
    values.push_back("REVOLVING");
    values.push_back("ROLLINGUP");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcDoorStyleOperationEnum] = new IfcEnumerationDescriptor(Type::IfcDoorStyleOperationEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("BEND");
    values.push_back("CONNECTOR");
    values.push_back("ENTRY");
    values.push_back("EXIT");
    values.push_back("JUNCTION");
    values.push_back("OBSTRUCTION");
    values.push_back("TRANSITION");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcDuctFittingTypeEnum] = new IfcEnumerationDescriptor(Type::IfcDuctFittingTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("RIGIDSEGMENT");
    values.push_back("FLEXIBLESEGMENT");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcDuctSegmentTypeEnum] = new IfcEnumerationDescriptor(Type::IfcDuctSegmentTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("FLATOVAL");
    values.push_back("RECTANGULAR");
    values.push_back("ROUND");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcDuctSilencerTypeEnum] = new IfcEnumerationDescriptor(Type::IfcDuctSilencerTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("COMPUTER");
    values.push_back("DIRECTWATERHEATER");
    values.push_back("DISHWASHER");
    values.push_back("ELECTRICCOOKER");
    values.push_back("ELECTRICHEATER");
    values.push_back("FACSIMILE");
    values.push_back("FREESTANDINGFAN");
    values.push_back("FREEZER");
    values.push_back("FRIDGE_FREEZER");
    values.push_back("HANDDRYER");
    values.push_back("INDIRECTWATERHEATER");
    values.push_back("MICROWAVE");
    values.push_back("PHOTOCOPIER");
    values.push_back("PRINTER");
    values.push_back("REFRIGERATOR");
    values.push_back("RADIANTHEATER");
    values.push_back("SCANNER");
    values.push_back("TELEPHONE");
    values.push_back("TUMBLEDRYER");
    values.push_back("TV");
    values.push_back("VENDINGMACHINE");
    values.push_back("WASHINGMACHINE");
    values.push_back("WATERHEATER");
    values.push_back("WATERCOOLER");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcElectricApplianceTypeEnum] = new IfcEnumerationDescriptor(Type::IfcElectricApplianceTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("ALTERNATING");
    values.push_back("DIRECT");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcElectricCurrentEnum] = new IfcEnumerationDescriptor(Type::IfcElectricCurrentEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("ALARMPANEL");
    values.push_back("CONSUMERUNIT");
    values.push_back("CONTROLPANEL");
    values.push_back("DISTRIBUTIONBOARD");
    values.push_back("GASDETECTORPANEL");
    values.push_back("INDICATORPANEL");
    values.push_back("MIMICPANEL");
    values.push_back("MOTORCONTROLCENTRE");
    values.push_back("SWITCHBOARD");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcElectricDistributionPointFunctionEnum] = new IfcEnumerationDescriptor(Type::IfcElectricDistributionPointFunctionEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("BATTERY");
    values.push_back("CAPACITORBANK");
    values.push_back("HARMONICFILTER");
    values.push_back("INDUCTORBANK");
    values.push_back("UPS");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcElectricFlowStorageDeviceTypeEnum] = new IfcEnumerationDescriptor(Type::IfcElectricFlowStorageDeviceTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcElectricGeneratorTypeEnum] = new IfcEnumerationDescriptor(Type::IfcElectricGeneratorTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("ELECTRICPOINTHEATER");
    values.push_back("ELECTRICCABLEHEATER");
    values.push_back("ELECTRICMATHEATER");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcElectricHeaterTypeEnum] = new IfcEnumerationDescriptor(Type::IfcElectricHeaterTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("DC");
    values.push_back("INDUCTION");
    values.push_back("POLYPHASE");
    values.push_back("RELUCTANCESYNCHRONOUS");
    values.push_back("SYNCHRONOUS");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcElectricMotorTypeEnum] = new IfcEnumerationDescriptor(Type::IfcElectricMotorTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("TIMECLOCK");
    values.push_back("TIMEDELAY");
    values.push_back("RELAY");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcElectricTimeControlTypeEnum] = new IfcEnumerationDescriptor(Type::IfcElectricTimeControlTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("ACCESSORY_ASSEMBLY");
    values.push_back("ARCH");
    values.push_back("BEAM_GRID");
    values.push_back("BRACED_FRAME");
    values.push_back("GIRDER");
    values.push_back("REINFORCEMENT_UNIT");
    values.push_back("RIGID_FRAME");
    values.push_back("SLAB_FIELD");
    values.push_back("TRUSS");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcElementAssemblyTypeEnum] = new IfcEnumerationDescriptor(Type::IfcElementAssemblyTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("COMPLEX");
    values.push_back("ELEMENT");
    values.push_back("PARTIAL");
    current_enum = enumeration_descriptor_map[Type::IfcElementCompositionEnum] = new IfcEnumerationDescriptor(Type::IfcElementCompositionEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("PRIMARY");
    values.push_back("SECONDARY");
    values.push_back("TERTIARY");
    values.push_back("AUXILIARY");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcEnergySequenceEnum] = new IfcEnumerationDescriptor(Type::IfcEnergySequenceEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("COMBINEDVALUE");
    values.push_back("DISPOSAL");
    values.push_back("EXTRACTION");
    values.push_back("INSTALLATION");
    values.push_back("MANUFACTURE");
    values.push_back("TRANSPORTATION");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcEnvironmentalImpactCategoryEnum] = new IfcEnumerationDescriptor(Type::IfcEnvironmentalImpactCategoryEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("DIRECTEVAPORATIVERANDOMMEDIAAIRCOOLER");
    values.push_back("DIRECTEVAPORATIVERIGIDMEDIAAIRCOOLER");
    values.push_back("DIRECTEVAPORATIVESLINGERSPACKAGEDAIRCOOLER");
    values.push_back("DIRECTEVAPORATIVEPACKAGEDROTARYAIRCOOLER");
    values.push_back("DIRECTEVAPORATIVEAIRWASHER");
    values.push_back("INDIRECTEVAPORATIVEPACKAGEAIRCOOLER");
    values.push_back("INDIRECTEVAPORATIVEWETCOIL");
    values.push_back("INDIRECTEVAPORATIVECOOLINGTOWERORCOILCOOLER");
    values.push_back("INDIRECTDIRECTCOMBINATION");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcEvaporativeCoolerTypeEnum] = new IfcEnumerationDescriptor(Type::IfcEvaporativeCoolerTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("DIRECTEXPANSIONSHELLANDTUBE");
    values.push_back("DIRECTEXPANSIONTUBEINTUBE");
    values.push_back("DIRECTEXPANSIONBRAZEDPLATE");
    values.push_back("FLOODEDSHELLANDTUBE");
    values.push_back("SHELLANDCOIL");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcEvaporatorTypeEnum] = new IfcEnumerationDescriptor(Type::IfcEvaporatorTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("CENTRIFUGALFORWARDCURVED");
    values.push_back("CENTRIFUGALRADIAL");
    values.push_back("CENTRIFUGALBACKWARDINCLINEDCURVED");
    values.push_back("CENTRIFUGALAIRFOIL");
    values.push_back("TUBEAXIAL");
    values.push_back("VANEAXIAL");
    values.push_back("PROPELLORAXIAL");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcFanTypeEnum] = new IfcEnumerationDescriptor(Type::IfcFanTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("AIRPARTICLEFILTER");
    values.push_back("ODORFILTER");
    values.push_back("OILFILTER");
    values.push_back("STRAINER");
    values.push_back("WATERFILTER");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcFilterTypeEnum] = new IfcEnumerationDescriptor(Type::IfcFilterTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("BREECHINGINLET");
    values.push_back("FIREHYDRANT");
    values.push_back("HOSEREEL");
    values.push_back("SPRINKLER");
    values.push_back("SPRINKLERDEFLECTOR");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcFireSuppressionTerminalTypeEnum] = new IfcEnumerationDescriptor(Type::IfcFireSuppressionTerminalTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("SOURCE");
    values.push_back("SINK");
    values.push_back("SOURCEANDSINK");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcFlowDirectionEnum] = new IfcEnumerationDescriptor(Type::IfcFlowDirectionEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("PRESSUREGAUGE");
    values.push_back("THERMOMETER");
    values.push_back("AMMETER");
    values.push_back("FREQUENCYMETER");
    values.push_back("POWERFACTORMETER");
    values.push_back("PHASEANGLEMETER");
    values.push_back("VOLTMETER_PEAK");
    values.push_back("VOLTMETER_RMS");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcFlowInstrumentTypeEnum] = new IfcEnumerationDescriptor(Type::IfcFlowInstrumentTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("ELECTRICMETER");
    values.push_back("ENERGYMETER");
    values.push_back("FLOWMETER");
    values.push_back("GASMETER");
    values.push_back("OILMETER");
    values.push_back("WATERMETER");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcFlowMeterTypeEnum] = new IfcEnumerationDescriptor(Type::IfcFlowMeterTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("FOOTING_BEAM");
    values.push_back("PAD_FOOTING");
    values.push_back("PILE_CAP");
    values.push_back("STRIP_FOOTING");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcFootingTypeEnum] = new IfcEnumerationDescriptor(Type::IfcFootingTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("GASAPPLIANCE");
    values.push_back("GASBOOSTER");
    values.push_back("GASBURNER");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcGasTerminalTypeEnum] = new IfcEnumerationDescriptor(Type::IfcGasTerminalTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("GRAPH_VIEW");
    values.push_back("SKETCH_VIEW");
    values.push_back("MODEL_VIEW");
    values.push_back("PLAN_VIEW");
    values.push_back("REFLECTED_PLAN_VIEW");
    values.push_back("SECTION_VIEW");
    values.push_back("ELEVATION_VIEW");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcGeometricProjectionEnum] = new IfcEnumerationDescriptor(Type::IfcGeometricProjectionEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("GLOBAL_COORDS");
    values.push_back("LOCAL_COORDS");
    current_enum = enumeration_descriptor_map[Type::IfcGlobalOrLocalEnum] = new IfcEnumerationDescriptor(Type::IfcGlobalOrLocalEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("PLATE");
    values.push_back("SHELLANDTUBE");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcHeatExchangerTypeEnum] = new IfcEnumerationDescriptor(Type::IfcHeatExchangerTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("STEAMINJECTION");
    values.push_back("ADIABATICAIRWASHER");
    values.push_back("ADIABATICPAN");
    values.push_back("ADIABATICWETTEDELEMENT");
    values.push_back("ADIABATICATOMIZING");
    values.push_back("ADIABATICULTRASONIC");
    values.push_back("ADIABATICRIGIDMEDIA");
    values.push_back("ADIABATICCOMPRESSEDAIRNOZZLE");
    values.push_back("ASSISTEDELECTRIC");
    values.push_back("ASSISTEDNATURALGAS");
    values.push_back("ASSISTEDPROPANE");
    values.push_back("ASSISTEDBUTANE");
    values.push_back("ASSISTEDSTEAM");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcHumidifierTypeEnum] = new IfcEnumerationDescriptor(Type::IfcHumidifierTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("INTERNAL");
    values.push_back("EXTERNAL");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcInternalOrExternalEnum] = new IfcEnumerationDescriptor(Type::IfcInternalOrExternalEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("ASSETINVENTORY");
    values.push_back("SPACEINVENTORY");
    values.push_back("FURNITUREINVENTORY");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcInventoryTypeEnum] = new IfcEnumerationDescriptor(Type::IfcInventoryTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcJunctionBoxTypeEnum] = new IfcEnumerationDescriptor(Type::IfcJunctionBoxTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("COMPACTFLUORESCENT");
    values.push_back("FLUORESCENT");
    values.push_back("HIGHPRESSUREMERCURY");
    values.push_back("HIGHPRESSURESODIUM");
    values.push_back("METALHALIDE");
    values.push_back("TUNGSTENFILAMENT");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcLampTypeEnum] = new IfcEnumerationDescriptor(Type::IfcLampTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("AXIS1");
    values.push_back("AXIS2");
    values.push_back("AXIS3");
    current_enum = enumeration_descriptor_map[Type::IfcLayerSetDirectionEnum] = new IfcEnumerationDescriptor(Type::IfcLayerSetDirectionEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("TYPE_A");
    values.push_back("TYPE_B");
    values.push_back("TYPE_C");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcLightDistributionCurveEnum] = new IfcEnumerationDescriptor(Type::IfcLightDistributionCurveEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("COMPACTFLUORESCENT");
    values.push_back("FLUORESCENT");
    values.push_back("HIGHPRESSUREMERCURY");
    values.push_back("HIGHPRESSURESODIUM");
    values.push_back("LIGHTEMITTINGDIODE");
    values.push_back("LOWPRESSURESODIUM");
    values.push_back("LOWVOLTAGEHALOGEN");
    values.push_back("MAINVOLTAGEHALOGEN");
    values.push_back("METALHALIDE");
    values.push_back("TUNGSTENFILAMENT");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcLightEmissionSourceEnum] = new IfcEnumerationDescriptor(Type::IfcLightEmissionSourceEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("POINTSOURCE");
    values.push_back("DIRECTIONSOURCE");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcLightFixtureTypeEnum] = new IfcEnumerationDescriptor(Type::IfcLightFixtureTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("LOAD_GROUP");
    values.push_back("LOAD_CASE");
    values.push_back("LOAD_COMBINATION_GROUP");
    values.push_back("LOAD_COMBINATION");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcLoadGroupTypeEnum] = new IfcEnumerationDescriptor(Type::IfcLoadGroupTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("LOGICALAND");
    values.push_back("LOGICALOR");
    current_enum = enumeration_descriptor_map[Type::IfcLogicalOperatorEnum] = new IfcEnumerationDescriptor(Type::IfcLogicalOperatorEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("BRACE");
    values.push_back("CHORD");
    values.push_back("COLLAR");
    values.push_back("MEMBER");
    values.push_back("MULLION");
    values.push_back("PLATE");
    values.push_back("POST");
    values.push_back("PURLIN");
    values.push_back("RAFTER");
    values.push_back("STRINGER");
    values.push_back("STRUT");
    values.push_back("STUD");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcMemberTypeEnum] = new IfcEnumerationDescriptor(Type::IfcMemberTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("BELTDRIVE");
    values.push_back("COUPLING");
    values.push_back("DIRECTDRIVE");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcMotorConnectionTypeEnum] = new IfcEnumerationDescriptor(Type::IfcMotorConnectionTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("NULL");
    current_enum = enumeration_descriptor_map[Type::IfcNullStyle] = new IfcEnumerationDescriptor(Type::IfcNullStyle, values);
    values.clear(); values.reserve(128);
    values.push_back("PRODUCT");
    values.push_back("PROCESS");
    values.push_back("CONTROL");
    values.push_back("RESOURCE");
    values.push_back("ACTOR");
    values.push_back("GROUP");
    values.push_back("PROJECT");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcObjectTypeEnum] = new IfcEnumerationDescriptor(Type::IfcObjectTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("CODECOMPLIANCE");
    values.push_back("DESIGNINTENT");
    values.push_back("HEALTHANDSAFETY");
    values.push_back("REQUIREMENT");
    values.push_back("SPECIFICATION");
    values.push_back("TRIGGERCONDITION");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcObjectiveEnum] = new IfcEnumerationDescriptor(Type::IfcObjectiveEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("ASSIGNEE");
    values.push_back("ASSIGNOR");
    values.push_back("LESSEE");
    values.push_back("LESSOR");
    values.push_back("LETTINGAGENT");
    values.push_back("OWNER");
    values.push_back("TENANT");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcOccupantTypeEnum] = new IfcEnumerationDescriptor(Type::IfcOccupantTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("AUDIOVISUALOUTLET");
    values.push_back("COMMUNICATIONSOUTLET");
    values.push_back("POWEROUTLET");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcOutletTypeEnum] = new IfcEnumerationDescriptor(Type::IfcOutletTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("GRILL");
    values.push_back("LOUVER");
    values.push_back("SCREEN");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcPermeableCoveringOperationEnum] = new IfcEnumerationDescriptor(Type::IfcPermeableCoveringOperationEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("PHYSICAL");
    values.push_back("VIRTUAL");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcPhysicalOrVirtualEnum] = new IfcEnumerationDescriptor(Type::IfcPhysicalOrVirtualEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("CAST_IN_PLACE");
    values.push_back("COMPOSITE");
    values.push_back("PRECAST_CONCRETE");
    values.push_back("PREFAB_STEEL");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcPileConstructionEnum] = new IfcEnumerationDescriptor(Type::IfcPileConstructionEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("COHESION");
    values.push_back("FRICTION");
    values.push_back("SUPPORT");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcPileTypeEnum] = new IfcEnumerationDescriptor(Type::IfcPileTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("BEND");
    values.push_back("CONNECTOR");
    values.push_back("ENTRY");
    values.push_back("EXIT");
    values.push_back("JUNCTION");
    values.push_back("OBSTRUCTION");
    values.push_back("TRANSITION");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcPipeFittingTypeEnum] = new IfcEnumerationDescriptor(Type::IfcPipeFittingTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("FLEXIBLESEGMENT");
    values.push_back("RIGIDSEGMENT");
    values.push_back("GUTTER");
    values.push_back("SPOOL");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcPipeSegmentTypeEnum] = new IfcEnumerationDescriptor(Type::IfcPipeSegmentTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("CURTAIN_PANEL");
    values.push_back("SHEET");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcPlateTypeEnum] = new IfcEnumerationDescriptor(Type::IfcPlateTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("ADVICE_CAUTION");
    values.push_back("ADVICE_NOTE");
    values.push_back("ADVICE_WARNING");
    values.push_back("CALIBRATION");
    values.push_back("DIAGNOSTIC");
    values.push_back("SHUTDOWN");
    values.push_back("STARTUP");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcProcedureTypeEnum] = new IfcEnumerationDescriptor(Type::IfcProcedureTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("CURVE");
    values.push_back("AREA");
    current_enum = enumeration_descriptor_map[Type::IfcProfileTypeEnum] = new IfcEnumerationDescriptor(Type::IfcProfileTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("CHANGE");
    values.push_back("MAINTENANCE");
    values.push_back("MOVE");
    values.push_back("PURCHASE");
    values.push_back("WORK");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcProjectOrderRecordTypeEnum] = new IfcEnumerationDescriptor(Type::IfcProjectOrderRecordTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("CHANGEORDER");
    values.push_back("MAINTENANCEWORKORDER");
    values.push_back("MOVEORDER");
    values.push_back("PURCHASEORDER");
    values.push_back("WORKORDER");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcProjectOrderTypeEnum] = new IfcEnumerationDescriptor(Type::IfcProjectOrderTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("PROJECTED_LENGTH");
    values.push_back("TRUE_LENGTH");
    current_enum = enumeration_descriptor_map[Type::IfcProjectedOrTrueLengthEnum] = new IfcEnumerationDescriptor(Type::IfcProjectedOrTrueLengthEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("DESIGN");
    values.push_back("DESIGNMAXIMUM");
    values.push_back("DESIGNMINIMUM");
    values.push_back("SIMULATED");
    values.push_back("ASBUILT");
    values.push_back("COMMISSIONING");
    values.push_back("MEASURED");
    values.push_back("USERDEFINED");
    values.push_back("NOTKNOWN");
    current_enum = enumeration_descriptor_map[Type::IfcPropertySourceEnum] = new IfcEnumerationDescriptor(Type::IfcPropertySourceEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("FUSEDISCONNECTOR");
    values.push_back("CIRCUITBREAKER");
    values.push_back("EARTHFAILUREDEVICE");
    values.push_back("RESIDUALCURRENTCIRCUITBREAKER");
    values.push_back("RESIDUALCURRENTSWITCH");
    values.push_back("VARISTOR");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcProtectiveDeviceTypeEnum] = new IfcEnumerationDescriptor(Type::IfcProtectiveDeviceTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("CIRCULATOR");
    values.push_back("ENDSUCTION");
    values.push_back("SPLITCASE");
    values.push_back("VERTICALINLINE");
    values.push_back("VERTICALTURBINE");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcPumpTypeEnum] = new IfcEnumerationDescriptor(Type::IfcPumpTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("HANDRAIL");
    values.push_back("GUARDRAIL");
    values.push_back("BALUSTRADE");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcRailingTypeEnum] = new IfcEnumerationDescriptor(Type::IfcRailingTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("STRAIGHT");
    values.push_back("SPIRAL");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcRampFlightTypeEnum] = new IfcEnumerationDescriptor(Type::IfcRampFlightTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("STRAIGHT_RUN_RAMP");
    values.push_back("TWO_STRAIGHT_RUN_RAMP");
    values.push_back("QUARTER_TURN_RAMP");
    values.push_back("TWO_QUARTER_TURN_RAMP");
    values.push_back("HALF_TURN_RAMP");
    values.push_back("SPIRAL_RAMP");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcRampTypeEnum] = new IfcEnumerationDescriptor(Type::IfcRampTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("BLINN");
    values.push_back("FLAT");
    values.push_back("GLASS");
    values.push_back("MATT");
    values.push_back("METAL");
    values.push_back("MIRROR");
    values.push_back("PHONG");
    values.push_back("PLASTIC");
    values.push_back("STRAUSS");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcReflectanceMethodEnum] = new IfcEnumerationDescriptor(Type::IfcReflectanceMethodEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("MAIN");
    values.push_back("SHEAR");
    values.push_back("LIGATURE");
    values.push_back("STUD");
    values.push_back("PUNCHING");
    values.push_back("EDGE");
    values.push_back("RING");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcReinforcingBarRoleEnum] = new IfcEnumerationDescriptor(Type::IfcReinforcingBarRoleEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("PLAIN");
    values.push_back("TEXTURED");
    current_enum = enumeration_descriptor_map[Type::IfcReinforcingBarSurfaceEnum] = new IfcEnumerationDescriptor(Type::IfcReinforcingBarSurfaceEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("CONSUMED");
    values.push_back("PARTIALLYCONSUMED");
    values.push_back("NOTCONSUMED");
    values.push_back("OCCUPIED");
    values.push_back("PARTIALLYOCCUPIED");
    values.push_back("NOTOCCUPIED");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcResourceConsumptionEnum] = new IfcEnumerationDescriptor(Type::IfcResourceConsumptionEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("DIRECTION_X");
    values.push_back("DIRECTION_Y");
    current_enum = enumeration_descriptor_map[Type::IfcRibPlateDirectionEnum] = new IfcEnumerationDescriptor(Type::IfcRibPlateDirectionEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("SUPPLIER");
    values.push_back("MANUFACTURER");
    values.push_back("CONTRACTOR");
    values.push_back("SUBCONTRACTOR");
    values.push_back("ARCHITECT");
    values.push_back("STRUCTURALENGINEER");
    values.push_back("COSTENGINEER");
    values.push_back("CLIENT");
    values.push_back("BUILDINGOWNER");
    values.push_back("BUILDINGOPERATOR");
    values.push_back("MECHANICALENGINEER");
    values.push_back("ELECTRICALENGINEER");
    values.push_back("PROJECTMANAGER");
    values.push_back("FACILITIESMANAGER");
    values.push_back("CIVILENGINEER");
    values.push_back("COMISSIONINGENGINEER");
    values.push_back("ENGINEER");
    values.push_back("OWNER");
    values.push_back("CONSULTANT");
    values.push_back("CONSTRUCTIONMANAGER");
    values.push_back("FIELDCONSTRUCTIONMANAGER");
    values.push_back("RESELLER");
    values.push_back("USERDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcRoleEnum] = new IfcEnumerationDescriptor(Type::IfcRoleEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("FLAT_ROOF");
    values.push_back("SHED_ROOF");
    values.push_back("GABLE_ROOF");
    values.push_back("HIP_ROOF");
    values.push_back("HIPPED_GABLE_ROOF");
    values.push_back("GAMBREL_ROOF");
    values.push_back("MANSARD_ROOF");
    values.push_back("BARREL_ROOF");
    values.push_back("RAINBOW_ROOF");
    values.push_back("BUTTERFLY_ROOF");
    values.push_back("PAVILION_ROOF");
    values.push_back("DOME_ROOF");
    values.push_back("FREEFORM");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcRoofTypeEnum] = new IfcEnumerationDescriptor(Type::IfcRoofTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("EXA");
    values.push_back("PETA");
    values.push_back("TERA");
    values.push_back("GIGA");
    values.push_back("MEGA");
    values.push_back("KILO");
    values.push_back("HECTO");
    values.push_back("DECA");
    values.push_back("DECI");
    values.push_back("CENTI");
    values.push_back("MILLI");
    values.push_back("MICRO");
    values.push_back("NANO");
    values.push_back("PICO");
    values.push_back("FEMTO");
    values.push_back("ATTO");
    current_enum = enumeration_descriptor_map[Type::IfcSIPrefix] = new IfcEnumerationDescriptor(Type::IfcSIPrefix, values);
    values.clear(); values.reserve(128);
    values.push_back("AMPERE");
    values.push_back("BECQUEREL");
    values.push_back("CANDELA");
    values.push_back("COULOMB");
    values.push_back("CUBIC_METRE");
    values.push_back("DEGREE_CELSIUS");
    values.push_back("FARAD");
    values.push_back("GRAM");
    values.push_back("GRAY");
    values.push_back("HENRY");
    values.push_back("HERTZ");
    values.push_back("JOULE");
    values.push_back("KELVIN");
    values.push_back("LUMEN");
    values.push_back("LUX");
    values.push_back("METRE");
    values.push_back("MOLE");
    values.push_back("NEWTON");
    values.push_back("OHM");
    values.push_back("PASCAL");
    values.push_back("RADIAN");
    values.push_back("SECOND");
    values.push_back("SIEMENS");
    values.push_back("SIEVERT");
    values.push_back("SQUARE_METRE");
    values.push_back("STERADIAN");
    values.push_back("TESLA");
    values.push_back("VOLT");
    values.push_back("WATT");
    values.push_back("WEBER");
    current_enum = enumeration_descriptor_map[Type::IfcSIUnitName] = new IfcEnumerationDescriptor(Type::IfcSIUnitName, values);
    values.clear(); values.reserve(128);
    values.push_back("BATH");
    values.push_back("BIDET");
    values.push_back("CISTERN");
    values.push_back("SHOWER");
    values.push_back("SINK");
    values.push_back("SANITARYFOUNTAIN");
    values.push_back("TOILETPAN");
    values.push_back("URINAL");
    values.push_back("WASHHANDBASIN");
    values.push_back("WCSEAT");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcSanitaryTerminalTypeEnum] = new IfcEnumerationDescriptor(Type::IfcSanitaryTerminalTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("UNIFORM");
    values.push_back("TAPERED");
    current_enum = enumeration_descriptor_map[Type::IfcSectionTypeEnum] = new IfcEnumerationDescriptor(Type::IfcSectionTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("CO2SENSOR");
    values.push_back("FIRESENSOR");
    values.push_back("FLOWSENSOR");
    values.push_back("GASSENSOR");
    values.push_back("HEATSENSOR");
    values.push_back("HUMIDITYSENSOR");
    values.push_back("LIGHTSENSOR");
    values.push_back("MOISTURESENSOR");
    values.push_back("MOVEMENTSENSOR");
    values.push_back("PRESSURESENSOR");
    values.push_back("SMOKESENSOR");
    values.push_back("SOUNDSENSOR");
    values.push_back("TEMPERATURESENSOR");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcSensorTypeEnum] = new IfcEnumerationDescriptor(Type::IfcSensorTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("START_START");
    values.push_back("START_FINISH");
    values.push_back("FINISH_START");
    values.push_back("FINISH_FINISH");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcSequenceEnum] = new IfcEnumerationDescriptor(Type::IfcSequenceEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("A_QUALITYOFCOMPONENTS");
    values.push_back("B_DESIGNLEVEL");
    values.push_back("C_WORKEXECUTIONLEVEL");
    values.push_back("D_INDOORENVIRONMENT");
    values.push_back("E_OUTDOORENVIRONMENT");
    values.push_back("F_INUSECONDITIONS");
    values.push_back("G_MAINTENANCELEVEL");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcServiceLifeFactorTypeEnum] = new IfcEnumerationDescriptor(Type::IfcServiceLifeFactorTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("ACTUALSERVICELIFE");
    values.push_back("EXPECTEDSERVICELIFE");
    values.push_back("OPTIMISTICREFERENCESERVICELIFE");
    values.push_back("PESSIMISTICREFERENCESERVICELIFE");
    values.push_back("REFERENCESERVICELIFE");
    current_enum = enumeration_descriptor_map[Type::IfcServiceLifeTypeEnum] = new IfcEnumerationDescriptor(Type::IfcServiceLifeTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("FLOOR");
    values.push_back("ROOF");
    values.push_back("LANDING");
    values.push_back("BASESLAB");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcSlabTypeEnum] = new IfcEnumerationDescriptor(Type::IfcSlabTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("DBA");
    values.push_back("DBB");
    values.push_back("DBC");
    values.push_back("NC");
    values.push_back("NR");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcSoundScaleEnum] = new IfcEnumerationDescriptor(Type::IfcSoundScaleEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("SECTIONALRADIATOR");
    values.push_back("PANELRADIATOR");
    values.push_back("TUBULARRADIATOR");
    values.push_back("CONVECTOR");
    values.push_back("BASEBOARDHEATER");
    values.push_back("FINNEDTUBEUNIT");
    values.push_back("UNITHEATER");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcSpaceHeaterTypeEnum] = new IfcEnumerationDescriptor(Type::IfcSpaceHeaterTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcSpaceTypeEnum] = new IfcEnumerationDescriptor(Type::IfcSpaceTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("BIRDCAGE");
    values.push_back("COWL");
    values.push_back("RAINWATERHOPPER");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcStackTerminalTypeEnum] = new IfcEnumerationDescriptor(Type::IfcStackTerminalTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("STRAIGHT");
    values.push_back("WINDER");
    values.push_back("SPIRAL");
    values.push_back("CURVED");
    values.push_back("FREEFORM");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcStairFlightTypeEnum] = new IfcEnumerationDescriptor(Type::IfcStairFlightTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("STRAIGHT_RUN_STAIR");
    values.push_back("TWO_STRAIGHT_RUN_STAIR");
    values.push_back("QUARTER_WINDING_STAIR");
    values.push_back("QUARTER_TURN_STAIR");
    values.push_back("HALF_WINDING_STAIR");
    values.push_back("HALF_TURN_STAIR");
    values.push_back("TWO_QUARTER_WINDING_STAIR");
    values.push_back("TWO_QUARTER_TURN_STAIR");
    values.push_back("THREE_QUARTER_WINDING_STAIR");
    values.push_back("THREE_QUARTER_TURN_STAIR");
    values.push_back("SPIRAL_STAIR");
    values.push_back("DOUBLE_RETURN_STAIR");
    values.push_back("CURVED_RUN_STAIR");
    values.push_back("TWO_CURVED_RUN_STAIR");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcStairTypeEnum] = new IfcEnumerationDescriptor(Type::IfcStairTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("READWRITE");
    values.push_back("READONLY");
    values.push_back("LOCKED");
    values.push_back("READWRITELOCKED");
    values.push_back("READONLYLOCKED");
    current_enum = enumeration_descriptor_map[Type::IfcStateEnum] = new IfcEnumerationDescriptor(Type::IfcStateEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("RIGID_JOINED_MEMBER");
    values.push_back("PIN_JOINED_MEMBER");
    values.push_back("CABLE");
    values.push_back("TENSION_MEMBER");
    values.push_back("COMPRESSION_MEMBER");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcStructuralCurveTypeEnum] = new IfcEnumerationDescriptor(Type::IfcStructuralCurveTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("BENDING_ELEMENT");
    values.push_back("MEMBRANE_ELEMENT");
    values.push_back("SHELL");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcStructuralSurfaceTypeEnum] = new IfcEnumerationDescriptor(Type::IfcStructuralSurfaceTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("POSITIVE");
    values.push_back("NEGATIVE");
    values.push_back("BOTH");
    current_enum = enumeration_descriptor_map[Type::IfcSurfaceSide] = new IfcEnumerationDescriptor(Type::IfcSurfaceSide, values);
    values.clear(); values.reserve(128);
    values.push_back("BUMP");
    values.push_back("OPACITY");
    values.push_back("REFLECTION");
    values.push_back("SELFILLUMINATION");
    values.push_back("SHININESS");
    values.push_back("SPECULAR");
    values.push_back("TEXTURE");
    values.push_back("TRANSPARENCYMAP");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcSurfaceTextureEnum] = new IfcEnumerationDescriptor(Type::IfcSurfaceTextureEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("CONTACTOR");
    values.push_back("EMERGENCYSTOP");
    values.push_back("STARTER");
    values.push_back("SWITCHDISCONNECTOR");
    values.push_back("TOGGLESWITCH");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcSwitchingDeviceTypeEnum] = new IfcEnumerationDescriptor(Type::IfcSwitchingDeviceTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("PREFORMED");
    values.push_back("SECTIONAL");
    values.push_back("EXPANSION");
    values.push_back("PRESSUREVESSEL");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcTankTypeEnum] = new IfcEnumerationDescriptor(Type::IfcTankTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("STRAND");
    values.push_back("WIRE");
    values.push_back("BAR");
    values.push_back("COATED");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcTendonTypeEnum] = new IfcEnumerationDescriptor(Type::IfcTendonTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("LEFT");
    values.push_back("RIGHT");
    values.push_back("UP");
    values.push_back("DOWN");
    current_enum = enumeration_descriptor_map[Type::IfcTextPath] = new IfcEnumerationDescriptor(Type::IfcTextPath, values);
    values.clear(); values.reserve(128);
    values.push_back("PEOPLE");
    values.push_back("LIGHTING");
    values.push_back("EQUIPMENT");
    values.push_back("VENTILATIONINDOORAIR");
    values.push_back("VENTILATIONOUTSIDEAIR");
    values.push_back("RECIRCULATEDAIR");
    values.push_back("EXHAUSTAIR");
    values.push_back("AIREXCHANGERATE");
    values.push_back("DRYBULBTEMPERATURE");
    values.push_back("RELATIVEHUMIDITY");
    values.push_back("INFILTRATION");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcThermalLoadSourceEnum] = new IfcEnumerationDescriptor(Type::IfcThermalLoadSourceEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("SENSIBLE");
    values.push_back("LATENT");
    values.push_back("RADIANT");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcThermalLoadTypeEnum] = new IfcEnumerationDescriptor(Type::IfcThermalLoadTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("CONTINUOUS");
    values.push_back("DISCRETE");
    values.push_back("DISCRETEBINARY");
    values.push_back("PIECEWISEBINARY");
    values.push_back("PIECEWISECONSTANT");
    values.push_back("PIECEWISECONTINUOUS");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcTimeSeriesDataTypeEnum] = new IfcEnumerationDescriptor(Type::IfcTimeSeriesDataTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("ANNUAL");
    values.push_back("MONTHLY");
    values.push_back("WEEKLY");
    values.push_back("DAILY");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcTimeSeriesScheduleTypeEnum] = new IfcEnumerationDescriptor(Type::IfcTimeSeriesScheduleTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("CURRENT");
    values.push_back("FREQUENCY");
    values.push_back("VOLTAGE");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcTransformerTypeEnum] = new IfcEnumerationDescriptor(Type::IfcTransformerTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("DISCONTINUOUS");
    values.push_back("CONTINUOUS");
    values.push_back("CONTSAMEGRADIENT");
    values.push_back("CONTSAMEGRADIENTSAMECURVATURE");
    current_enum = enumeration_descriptor_map[Type::IfcTransitionCode] = new IfcEnumerationDescriptor(Type::IfcTransitionCode, values);
    values.clear(); values.reserve(128);
    values.push_back("ELEVATOR");
    values.push_back("ESCALATOR");
    values.push_back("MOVINGWALKWAY");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcTransportElementTypeEnum] = new IfcEnumerationDescriptor(Type::IfcTransportElementTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("CARTESIAN");
    values.push_back("PARAMETER");
    values.push_back("UNSPECIFIED");
    current_enum = enumeration_descriptor_map[Type::IfcTrimmingPreference] = new IfcEnumerationDescriptor(Type::IfcTrimmingPreference, values);
    values.clear(); values.reserve(128);
    values.push_back("FINNED");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcTubeBundleTypeEnum] = new IfcEnumerationDescriptor(Type::IfcTubeBundleTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("ABSORBEDDOSEUNIT");
    values.push_back("AMOUNTOFSUBSTANCEUNIT");
    values.push_back("AREAUNIT");
    values.push_back("DOSEEQUIVALENTUNIT");
    values.push_back("ELECTRICCAPACITANCEUNIT");
    values.push_back("ELECTRICCHARGEUNIT");
    values.push_back("ELECTRICCONDUCTANCEUNIT");
    values.push_back("ELECTRICCURRENTUNIT");
    values.push_back("ELECTRICRESISTANCEUNIT");
    values.push_back("ELECTRICVOLTAGEUNIT");
    values.push_back("ENERGYUNIT");
    values.push_back("FORCEUNIT");
    values.push_back("FREQUENCYUNIT");
    values.push_back("ILLUMINANCEUNIT");
    values.push_back("INDUCTANCEUNIT");
    values.push_back("LENGTHUNIT");
    values.push_back("LUMINOUSFLUXUNIT");
    values.push_back("LUMINOUSINTENSITYUNIT");
    values.push_back("MAGNETICFLUXDENSITYUNIT");
    values.push_back("MAGNETICFLUXUNIT");
    values.push_back("MASSUNIT");
    values.push_back("PLANEANGLEUNIT");
    values.push_back("POWERUNIT");
    values.push_back("PRESSUREUNIT");
    values.push_back("RADIOACTIVITYUNIT");
    values.push_back("SOLIDANGLEUNIT");
    values.push_back("THERMODYNAMICTEMPERATUREUNIT");
    values.push_back("TIMEUNIT");
    values.push_back("VOLUMEUNIT");
    values.push_back("USERDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcUnitEnum] = new IfcEnumerationDescriptor(Type::IfcUnitEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("AIRHANDLER");
    values.push_back("AIRCONDITIONINGUNIT");
    values.push_back("SPLITSYSTEM");
    values.push_back("ROOFTOPUNIT");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcUnitaryEquipmentTypeEnum] = new IfcEnumerationDescriptor(Type::IfcUnitaryEquipmentTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("AIRRELEASE");
    values.push_back("ANTIVACUUM");
    values.push_back("CHANGEOVER");
    values.push_back("CHECK");
    values.push_back("COMMISSIONING");
    values.push_back("DIVERTING");
    values.push_back("DRAWOFFCOCK");
    values.push_back("DOUBLECHECK");
    values.push_back("DOUBLEREGULATING");
    values.push_back("FAUCET");
    values.push_back("FLUSHING");
    values.push_back("GASCOCK");
    values.push_back("GASTAP");
    values.push_back("ISOLATING");
    values.push_back("MIXING");
    values.push_back("PRESSUREREDUCING");
    values.push_back("PRESSURERELIEF");
    values.push_back("REGULATING");
    values.push_back("SAFETYCUTOFF");
    values.push_back("STEAMTRAP");
    values.push_back("STOPCOCK");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcValveTypeEnum] = new IfcEnumerationDescriptor(Type::IfcValveTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("COMPRESSION");
    values.push_back("SPRING");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcVibrationIsolatorTypeEnum] = new IfcEnumerationDescriptor(Type::IfcVibrationIsolatorTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("STANDARD");
    values.push_back("POLYGONAL");
    values.push_back("SHEAR");
    values.push_back("ELEMENTEDWALL");
    values.push_back("PLUMBINGWALL");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcWallTypeEnum] = new IfcEnumerationDescriptor(Type::IfcWallTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("FLOORTRAP");
    values.push_back("FLOORWASTE");
    values.push_back("GULLYSUMP");
    values.push_back("GULLYTRAP");
    values.push_back("GREASEINTERCEPTOR");
    values.push_back("OILINTERCEPTOR");
    values.push_back("PETROLINTERCEPTOR");
    values.push_back("ROOFDRAIN");
    values.push_back("WASTEDISPOSALUNIT");
    values.push_back("WASTETRAP");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcWasteTerminalTypeEnum] = new IfcEnumerationDescriptor(Type::IfcWasteTerminalTypeEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("SIDEHUNGRIGHTHAND");
    values.push_back("SIDEHUNGLEFTHAND");
    values.push_back("TILTANDTURNRIGHTHAND");
    values.push_back("TILTANDTURNLEFTHAND");
    values.push_back("TOPHUNG");
    values.push_back("BOTTOMHUNG");
    values.push_back("PIVOTHORIZONTAL");
    values.push_back("PIVOTVERTICAL");
    values.push_back("SLIDINGHORIZONTAL");
    values.push_back("SLIDINGVERTICAL");
    values.push_back("REMOVABLECASEMENT");
    values.push_back("FIXEDCASEMENT");
    values.push_back("OTHEROPERATION");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcWindowPanelOperationEnum] = new IfcEnumerationDescriptor(Type::IfcWindowPanelOperationEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("LEFT");
    values.push_back("MIDDLE");
    values.push_back("RIGHT");
    values.push_back("BOTTOM");
    values.push_back("TOP");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcWindowPanelPositionEnum] = new IfcEnumerationDescriptor(Type::IfcWindowPanelPositionEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("ALUMINIUM");
    values.push_back("HIGH_GRADE_STEEL");
    values.push_back("STEEL");
    values.push_back("WOOD");
    values.push_back("ALUMINIUM_WOOD");
    values.push_back("PLASTIC");
    values.push_back("OTHER_CONSTRUCTION");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcWindowStyleConstructionEnum] = new IfcEnumerationDescriptor(Type::IfcWindowStyleConstructionEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("SINGLE_PANEL");
    values.push_back("DOUBLE_PANEL_VERTICAL");
    values.push_back("DOUBLE_PANEL_HORIZONTAL");
    values.push_back("TRIPLE_PANEL_VERTICAL");
    values.push_back("TRIPLE_PANEL_BOTTOM");
    values.push_back("TRIPLE_PANEL_TOP");
    values.push_back("TRIPLE_PANEL_LEFT");
    values.push_back("TRIPLE_PANEL_RIGHT");
    values.push_back("TRIPLE_PANEL_HORIZONTAL");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcWindowStyleOperationEnum] = new IfcEnumerationDescriptor(Type::IfcWindowStyleOperationEnum, values);
    values.clear(); values.reserve(128);
    values.push_back("ACTUAL");
    values.push_back("BASELINE");
    values.push_back("PLANNED");
    values.push_back("USERDEFINED");
    values.push_back("NOTDEFINED");
    current_enum = enumeration_descriptor_map[Type::IfcWorkControlTypeEnum] = new IfcEnumerationDescriptor(Type::IfcWorkControlTypeEnum, values);
}

#ifdef _MSC_VER
#  pragma optimize( "", on )
#endif

void InitInverseMap() {
    inverse_map[Type::IfcActor].insert(std::make_pair("IsActingUpon", std::make_pair(Type::IfcRelAssignsToActor, 6)));
    inverse_map[Type::IfcAddress].insert(std::make_pair("OfPerson", std::make_pair(Type::IfcPerson, 7)));
    inverse_map[Type::IfcAddress].insert(std::make_pair("OfOrganization", std::make_pair(Type::IfcOrganization, 4)));
    inverse_map[Type::IfcAnnotation].insert(std::make_pair("ContainedInStructure", std::make_pair(Type::IfcRelContainedInSpatialStructure, 4)));
    inverse_map[Type::IfcAppliedValue].insert(std::make_pair("ValuesReferenced", std::make_pair(Type::IfcReferencesValueDocument, 1)));
    inverse_map[Type::IfcAppliedValue].insert(std::make_pair("ValueOfComponents", std::make_pair(Type::IfcAppliedValueRelationship, 0)));
    inverse_map[Type::IfcAppliedValue].insert(std::make_pair("IsComponentIn", std::make_pair(Type::IfcAppliedValueRelationship, 1)));
    inverse_map[Type::IfcApproval].insert(std::make_pair("Actors", std::make_pair(Type::IfcApprovalActorRelationship, 1)));
    inverse_map[Type::IfcApproval].insert(std::make_pair("IsRelatedWith", std::make_pair(Type::IfcApprovalRelationship, 0)));
    inverse_map[Type::IfcApproval].insert(std::make_pair("Relates", std::make_pair(Type::IfcApprovalRelationship, 1)));
    inverse_map[Type::IfcClassification].insert(std::make_pair("Contains", std::make_pair(Type::IfcClassificationItem, 1)));
    inverse_map[Type::IfcClassificationItem].insert(std::make_pair("IsClassifiedItemIn", std::make_pair(Type::IfcClassificationItemRelationship, 1)));
    inverse_map[Type::IfcClassificationItem].insert(std::make_pair("IsClassifyingItemIn", std::make_pair(Type::IfcClassificationItemRelationship, 0)));
    inverse_map[Type::IfcCompositeCurveSegment].insert(std::make_pair("UsingCurves", std::make_pair(Type::IfcCompositeCurve, 0)));
    inverse_map[Type::IfcConstraint].insert(std::make_pair("ClassifiedAs", std::make_pair(Type::IfcConstraintClassificationRelationship, 0)));
    inverse_map[Type::IfcConstraint].insert(std::make_pair("RelatesConstraints", std::make_pair(Type::IfcConstraintRelationship, 2)));
    inverse_map[Type::IfcConstraint].insert(std::make_pair("IsRelatedWith", std::make_pair(Type::IfcConstraintRelationship, 3)));
    inverse_map[Type::IfcConstraint].insert(std::make_pair("PropertiesForConstraint", std::make_pair(Type::IfcPropertyConstraintRelationship, 0)));
    inverse_map[Type::IfcConstraint].insert(std::make_pair("Aggregates", std::make_pair(Type::IfcConstraintAggregationRelationship, 2)));
    inverse_map[Type::IfcConstraint].insert(std::make_pair("IsAggregatedIn", std::make_pair(Type::IfcConstraintAggregationRelationship, 3)));
    inverse_map[Type::IfcControl].insert(std::make_pair("Controls", std::make_pair(Type::IfcRelAssignsToControl, 6)));
    inverse_map[Type::IfcCovering].insert(std::make_pair("CoversSpaces", std::make_pair(Type::IfcRelCoversSpaces, 5)));
    inverse_map[Type::IfcCovering].insert(std::make_pair("Covers", std::make_pair(Type::IfcRelCoversBldgElements, 5)));
    inverse_map[Type::IfcDimensionCurve].insert(std::make_pair("AnnotatedBySymbols", std::make_pair(Type::IfcTerminatorSymbol, 3)));
    inverse_map[Type::IfcDistributionControlElement].insert(std::make_pair("AssignedToFlowElement", std::make_pair(Type::IfcRelFlowControlElements, 4)));
    inverse_map[Type::IfcDistributionFlowElement].insert(std::make_pair("HasControlElements", std::make_pair(Type::IfcRelFlowControlElements, 5)));
    inverse_map[Type::IfcDocumentInformation].insert(std::make_pair("IsPointedTo", std::make_pair(Type::IfcDocumentInformationRelationship, 1)));
    inverse_map[Type::IfcDocumentInformation].insert(std::make_pair("IsPointer", std::make_pair(Type::IfcDocumentInformationRelationship, 0)));
    inverse_map[Type::IfcDocumentReference].insert(std::make_pair("ReferenceToDocument", std::make_pair(Type::IfcDocumentInformation, 3)));
    inverse_map[Type::IfcDraughtingCallout].insert(std::make_pair("IsRelatedFromCallout", std::make_pair(Type::IfcDraughtingCalloutRelationship, 3)));
    inverse_map[Type::IfcDraughtingCallout].insert(std::make_pair("IsRelatedToCallout", std::make_pair(Type::IfcDraughtingCalloutRelationship, 2)));
    inverse_map[Type::IfcElement].insert(std::make_pair("HasStructuralMember", std::make_pair(Type::IfcRelConnectsStructuralElement, 4)));
    inverse_map[Type::IfcElement].insert(std::make_pair("FillsVoids", std::make_pair(Type::IfcRelFillsElement, 5)));
    inverse_map[Type::IfcElement].insert(std::make_pair("ConnectedTo", std::make_pair(Type::IfcRelConnectsElements, 5)));
    inverse_map[Type::IfcElement].insert(std::make_pair("HasCoverings", std::make_pair(Type::IfcRelCoversBldgElements, 4)));
    inverse_map[Type::IfcElement].insert(std::make_pair("HasProjections", std::make_pair(Type::IfcRelProjectsElement, 4)));
    inverse_map[Type::IfcElement].insert(std::make_pair("ReferencedInStructures", std::make_pair(Type::IfcRelReferencedInSpatialStructure, 4)));
    inverse_map[Type::IfcElement].insert(std::make_pair("HasPorts", std::make_pair(Type::IfcRelConnectsPortToElement, 5)));
    inverse_map[Type::IfcElement].insert(std::make_pair("HasOpenings", std::make_pair(Type::IfcRelVoidsElement, 4)));
    inverse_map[Type::IfcElement].insert(std::make_pair("IsConnectionRealization", std::make_pair(Type::IfcRelConnectsWithRealizingElements, 7)));
    inverse_map[Type::IfcElement].insert(std::make_pair("ProvidesBoundaries", std::make_pair(Type::IfcRelSpaceBoundary, 5)));
    inverse_map[Type::IfcElement].insert(std::make_pair("ConnectedFrom", std::make_pair(Type::IfcRelConnectsElements, 6)));
    inverse_map[Type::IfcElement].insert(std::make_pair("ContainedInStructure", std::make_pair(Type::IfcRelContainedInSpatialStructure, 4)));
    inverse_map[Type::IfcFeatureElementAddition].insert(std::make_pair("ProjectsElements", std::make_pair(Type::IfcRelProjectsElement, 5)));
    inverse_map[Type::IfcFeatureElementSubtraction].insert(std::make_pair("VoidsElements", std::make_pair(Type::IfcRelVoidsElement, 5)));
    inverse_map[Type::IfcGeometricRepresentationContext].insert(std::make_pair("HasSubContexts", std::make_pair(Type::IfcGeometricRepresentationSubContext, 6)));
    inverse_map[Type::IfcGrid].insert(std::make_pair("ContainedInStructure", std::make_pair(Type::IfcRelContainedInSpatialStructure, 4)));
    inverse_map[Type::IfcGridAxis].insert(std::make_pair("PartOfW", std::make_pair(Type::IfcGrid, 9)));
    inverse_map[Type::IfcGridAxis].insert(std::make_pair("PartOfV", std::make_pair(Type::IfcGrid, 8)));
    inverse_map[Type::IfcGridAxis].insert(std::make_pair("PartOfU", std::make_pair(Type::IfcGrid, 7)));
    inverse_map[Type::IfcGridAxis].insert(std::make_pair("HasIntersections", std::make_pair(Type::IfcVirtualGridIntersection, 0)));
    inverse_map[Type::IfcGroup].insert(std::make_pair("IsGroupedBy", std::make_pair(Type::IfcRelAssignsToGroup, 6)));
    inverse_map[Type::IfcLibraryReference].insert(std::make_pair("ReferenceIntoLibrary", std::make_pair(Type::IfcLibraryInformation, 4)));
    inverse_map[Type::IfcMaterial].insert(std::make_pair("HasRepresentation", std::make_pair(Type::IfcMaterialDefinitionRepresentation, 3)));
    inverse_map[Type::IfcMaterial].insert(std::make_pair("ClassifiedAs", std::make_pair(Type::IfcMaterialClassificationRelationship, 1)));
    inverse_map[Type::IfcMaterialLayer].insert(std::make_pair("ToMaterialLayerSet", std::make_pair(Type::IfcMaterialLayerSet, 0)));
    inverse_map[Type::IfcObject].insert(std::make_pair("IsDefinedBy", std::make_pair(Type::IfcRelDefines, 4)));
    inverse_map[Type::IfcObjectDefinition].insert(std::make_pair("HasAssignments", std::make_pair(Type::IfcRelAssigns, 4)));
    inverse_map[Type::IfcObjectDefinition].insert(std::make_pair("IsDecomposedBy", std::make_pair(Type::IfcRelDecomposes, 4)));
    inverse_map[Type::IfcObjectDefinition].insert(std::make_pair("Decomposes", std::make_pair(Type::IfcRelDecomposes, 5)));
    inverse_map[Type::IfcObjectDefinition].insert(std::make_pair("HasAssociations", std::make_pair(Type::IfcRelAssociates, 4)));
    inverse_map[Type::IfcObjectPlacement].insert(std::make_pair("PlacesObject", std::make_pair(Type::IfcProduct, 5)));
    inverse_map[Type::IfcObjectPlacement].insert(std::make_pair("ReferencedByPlacements", std::make_pair(Type::IfcLocalPlacement, 0)));
    inverse_map[Type::IfcOpeningElement].insert(std::make_pair("HasFillings", std::make_pair(Type::IfcRelFillsElement, 4)));
    inverse_map[Type::IfcOrganization].insert(std::make_pair("IsRelatedBy", std::make_pair(Type::IfcOrganizationRelationship, 3)));
    inverse_map[Type::IfcOrganization].insert(std::make_pair("Relates", std::make_pair(Type::IfcOrganizationRelationship, 2)));
    inverse_map[Type::IfcOrganization].insert(std::make_pair("Engages", std::make_pair(Type::IfcPersonAndOrganization, 1)));
    inverse_map[Type::IfcPerson].insert(std::make_pair("EngagedIn", std::make_pair(Type::IfcPersonAndOrganization, 0)));
    inverse_map[Type::IfcPhysicalQuantity].insert(std::make_pair("PartOfComplex", std::make_pair(Type::IfcPhysicalComplexQuantity, 2)));
    inverse_map[Type::IfcPort].insert(std::make_pair("ContainedIn", std::make_pair(Type::IfcRelConnectsPortToElement, 4)));
    inverse_map[Type::IfcPort].insert(std::make_pair("ConnectedFrom", std::make_pair(Type::IfcRelConnectsPorts, 5)));
    inverse_map[Type::IfcPort].insert(std::make_pair("ConnectedTo", std::make_pair(Type::IfcRelConnectsPorts, 4)));
    inverse_map[Type::IfcProcess].insert(std::make_pair("OperatesOn", std::make_pair(Type::IfcRelAssignsToProcess, 6)));
    inverse_map[Type::IfcProcess].insert(std::make_pair("IsSuccessorFrom", std::make_pair(Type::IfcRelSequence, 5)));
    inverse_map[Type::IfcProcess].insert(std::make_pair("IsPredecessorTo", std::make_pair(Type::IfcRelSequence, 4)));
    inverse_map[Type::IfcProduct].insert(std::make_pair("ReferencedBy", std::make_pair(Type::IfcRelAssignsToProduct, 6)));
    inverse_map[Type::IfcProductDefinitionShape].insert(std::make_pair("ShapeOfProduct", std::make_pair(Type::IfcProduct, 6)));
    inverse_map[Type::IfcProductDefinitionShape].insert(std::make_pair("HasShapeAspects", std::make_pair(Type::IfcShapeAspect, 4)));
    inverse_map[Type::IfcProperty].insert(std::make_pair("PropertyForDependance", std::make_pair(Type::IfcPropertyDependencyRelationship, 0)));
    inverse_map[Type::IfcProperty].insert(std::make_pair("PropertyDependsOn", std::make_pair(Type::IfcPropertyDependencyRelationship, 1)));
    inverse_map[Type::IfcProperty].insert(std::make_pair("PartOfComplex", std::make_pair(Type::IfcComplexProperty, 3)));
    inverse_map[Type::IfcPropertyDefinition].insert(std::make_pair("HasAssociations", std::make_pair(Type::IfcRelAssociates, 4)));
    inverse_map[Type::IfcPropertySetDefinition].insert(std::make_pair("PropertyDefinitionOf", std::make_pair(Type::IfcRelDefinesByProperties, 5)));
    inverse_map[Type::IfcPropertySetDefinition].insert(std::make_pair("DefinesType", std::make_pair(Type::IfcTypeObject, 5)));
    inverse_map[Type::IfcRepresentation].insert(std::make_pair("RepresentationMap", std::make_pair(Type::IfcRepresentationMap, 1)));
    inverse_map[Type::IfcRepresentation].insert(std::make_pair("LayerAssignments", std::make_pair(Type::IfcPresentationLayerAssignment, 2)));
    inverse_map[Type::IfcRepresentation].insert(std::make_pair("OfProductRepresentation", std::make_pair(Type::IfcProductRepresentation, 2)));
    inverse_map[Type::IfcRepresentationContext].insert(std::make_pair("RepresentationsInContext", std::make_pair(Type::IfcRepresentation, 0)));
    inverse_map[Type::IfcRepresentationItem].insert(std::make_pair("LayerAssignments", std::make_pair(Type::IfcPresentationLayerAssignment, 2)));
    inverse_map[Type::IfcRepresentationItem].insert(std::make_pair("StyledByItem", std::make_pair(Type::IfcStyledItem, 0)));
    inverse_map[Type::IfcRepresentationMap].insert(std::make_pair("MapUsage", std::make_pair(Type::IfcMappedItem, 0)));
    inverse_map[Type::IfcResource].insert(std::make_pair("ResourceOf", std::make_pair(Type::IfcRelAssignsToResource, 6)));
    inverse_map[Type::IfcScheduleTimeControl].insert(std::make_pair("ScheduleTimeControlAssigned", std::make_pair(Type::IfcRelAssignsTasks, 7)));
    inverse_map[Type::IfcShapeModel].insert(std::make_pair("OfShapeAspect", std::make_pair(Type::IfcShapeAspect, 0)));
    inverse_map[Type::IfcSpace].insert(std::make_pair("HasCoverings", std::make_pair(Type::IfcRelCoversSpaces, 4)));
    inverse_map[Type::IfcSpace].insert(std::make_pair("BoundedBy", std::make_pair(Type::IfcRelSpaceBoundary, 4)));
    inverse_map[Type::IfcSpaceProgram].insert(std::make_pair("HasInteractionReqsFrom", std::make_pair(Type::IfcRelInteractionRequirements, 7)));
    inverse_map[Type::IfcSpaceProgram].insert(std::make_pair("HasInteractionReqsTo", std::make_pair(Type::IfcRelInteractionRequirements, 8)));
    inverse_map[Type::IfcSpatialStructureElement].insert(std::make_pair("ReferencesElements", std::make_pair(Type::IfcRelReferencedInSpatialStructure, 5)));
    inverse_map[Type::IfcSpatialStructureElement].insert(std::make_pair("ServicedBySystems", std::make_pair(Type::IfcRelServicesBuildings, 5)));
    inverse_map[Type::IfcSpatialStructureElement].insert(std::make_pair("ContainsElements", std::make_pair(Type::IfcRelContainedInSpatialStructure, 5)));
    inverse_map[Type::IfcStructuralActivity].insert(std::make_pair("AssignedToStructuralItem", std::make_pair(Type::IfcRelConnectsStructuralActivity, 5)));
    inverse_map[Type::IfcStructuralConnection].insert(std::make_pair("ConnectsStructuralMembers", std::make_pair(Type::IfcRelConnectsStructuralMember, 5)));
    inverse_map[Type::IfcStructuralItem].insert(std::make_pair("AssignedStructuralActivity", std::make_pair(Type::IfcRelConnectsStructuralActivity, 4)));
    inverse_map[Type::IfcStructuralLoadGroup].insert(std::make_pair("SourceOfResultGroup", std::make_pair(Type::IfcStructuralResultGroup, 6)));
    inverse_map[Type::IfcStructuralLoadGroup].insert(std::make_pair("LoadGroupFor", std::make_pair(Type::IfcStructuralAnalysisModel, 7)));
    inverse_map[Type::IfcStructuralMember].insert(std::make_pair("ReferencesElement", std::make_pair(Type::IfcRelConnectsStructuralElement, 5)));
    inverse_map[Type::IfcStructuralMember].insert(std::make_pair("ConnectedBy", std::make_pair(Type::IfcRelConnectsStructuralMember, 4)));
    inverse_map[Type::IfcStructuralReaction].insert(std::make_pair("Causes", std::make_pair(Type::IfcStructuralAction, 10)));
    inverse_map[Type::IfcStructuralResultGroup].insert(std::make_pair("ResultGroupFor", std::make_pair(Type::IfcStructuralAnalysisModel, 8)));
    inverse_map[Type::IfcSystem].insert(std::make_pair("ServicesBuildings", std::make_pair(Type::IfcRelServicesBuildings, 4)));
    inverse_map[Type::IfcTableRow].insert(std::make_pair("OfTable", std::make_pair(Type::IfcTable, 1)));
    inverse_map[Type::IfcTextureCoordinate].insert(std::make_pair("AnnotatedSurface", std::make_pair(Type::IfcAnnotationSurface, 1)));
    inverse_map[Type::IfcTimeSeries].insert(std::make_pair("DocumentedBy", std::make_pair(Type::IfcTimeSeriesReferenceRelationship, 0)));
    inverse_map[Type::IfcTypeObject].insert(std::make_pair("ObjectTypeOf", std::make_pair(Type::IfcRelDefinesByType, 5)));
}

void InitDerivedMap() {
    {std::set<int> idxs; idxs.insert(2); idxs.insert(3); idxs.insert(4); idxs.insert(5); derived_map[Type::IfcGeometricRepresentationSubContext] = idxs;}
    {std::set<int> idxs; idxs.insert(0); idxs.insert(1); derived_map[Type::IfcOrientedEdge] = idxs;}
    {std::set<int> idxs; idxs.insert(0); derived_map[Type::IfcSIUnit] = idxs;}
}

int Type::GetAttributeIndex(Enum t, const std::string& a) {
    if (entity_descriptor_map.empty()) ::InitDescriptorMap();
    std::map<Type::Enum,IfcEntityDescriptor*>::const_iterator i = entity_descriptor_map.find(t);
    if ( i == entity_descriptor_map.end() ) throw IfcException("Type not found");
    else return i->second->getArgumentIndex(a);
}

int Type::GetAttributeCount(Enum t) {
    if (entity_descriptor_map.empty()) ::InitDescriptorMap();
    std::map<Type::Enum,IfcEntityDescriptor*>::const_iterator i = entity_descriptor_map.find(t);
    if ( i == entity_descriptor_map.end() ) throw IfcException("Type not found");
    else return i->second->getArgumentCount();
}

ArgumentType Type::GetAttributeType(Enum t, unsigned char a) {
    if (entity_descriptor_map.empty()) ::InitDescriptorMap();
    std::map<Type::Enum,IfcEntityDescriptor*>::const_iterator i = entity_descriptor_map.find(t);
    if ( i == entity_descriptor_map.end() ) throw IfcException("Type not found");
    else return i->second->getArgumentType(a);
}

Type::Enum Type::GetAttributeEntity(Enum t, unsigned char a) {
    if (entity_descriptor_map.empty()) ::InitDescriptorMap();
    std::map<Type::Enum,IfcEntityDescriptor*>::const_iterator i = entity_descriptor_map.find(t);
    if ( i == entity_descriptor_map.end() ) throw IfcException("Type not found");
    else return i->second->getArgumentEntity(a);
}

const std::string& Type::GetAttributeName(Enum t, unsigned char a) {
    if (entity_descriptor_map.empty()) ::InitDescriptorMap();
    std::map<Type::Enum,IfcEntityDescriptor*>::const_iterator i = entity_descriptor_map.find(t);
    if ( i == entity_descriptor_map.end() ) throw IfcException("Type not found");
    else return i->second->getArgumentName(a);
}

bool Type::GetAttributeOptional(Enum t, unsigned char a) {
    if (entity_descriptor_map.empty()) ::InitDescriptorMap();
    std::map<Type::Enum,IfcEntityDescriptor*>::const_iterator i = entity_descriptor_map.find(t);
    if ( i == entity_descriptor_map.end() ) throw IfcException("Type not found");
    else return i->second->getArgumentOptional(a);
}

bool Type::GetAttributeDerived(Enum t, unsigned char a) {
    if (derived_map.empty()) ::InitDerivedMap();
    std::map<Type::Enum,std::set<int> >::const_iterator i = derived_map.find(t);
    return i != derived_map.end() && i->second.find(a) != i->second.end();
}

std::pair<const char*, int> Type::GetEnumerationIndex(Enum t, const std::string& a) {
    if (enumeration_descriptor_map.empty()) ::InitDescriptorMap();
    std::map<Type::Enum,IfcEnumerationDescriptor*>::const_iterator i = enumeration_descriptor_map.find(t);
    if ( i == enumeration_descriptor_map.end() ) throw IfcException("Value not found");
    else return i->second->getIndex(a);
}

std::pair<Type::Enum, unsigned> Type::GetInverseAttribute(Enum t, const std::string& a) {
	if (inverse_map.empty()) ::InitInverseMap();
	inverse_map_t::const_iterator it;
	inverse_map_t::mapped_type::const_iterator jt;
    while (true) {
        it = inverse_map.find(t);
        if (it != inverse_map.end()) {
			jt = it->second.find(a);
			if (jt != it->second.end()) {
				return jt->second;
			}
		}
        if ((t = Parent(t)) == -1) break;
    }
    throw IfcException("Attribute not found");
}

std::set<std::string> Type::GetInverseAttributeNames(Enum t) {
	if (inverse_map.empty()) ::InitInverseMap();
	inverse_map_t::const_iterator it;
	inverse_map_t::mapped_type::const_iterator jt;

	std::set<std::string> return_value;

    while (true) {
        it = inverse_map.find(t);
        if (it != inverse_map.end()) {
			for (jt = it->second.begin(); jt != it->second.end(); ++jt) {
				return_value.insert(jt->first);
			}
		}
        if ((t = Parent(t)) == -1) break;
    }
    
	return return_value;
}

void Type::PopulateDerivedFields(IfcWrite::IfcWritableEntity* e) {
    std::map<Type::Enum, std::set<int> >::const_iterator i = derived_map.find(e->type());
	if (i != derived_map.end()) {
		for (std::set<int>::const_iterator it = i->second.begin(); it != i->second.end(); ++it) {
			e->setArgumentDerived(*it);
		}
	}
}
#endif
