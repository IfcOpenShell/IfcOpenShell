/********************************************************************************
 *                                                                              *
 * This file is part of IfcOpenShell.                                           *
 *                                                                              *
 * IfcOpenShell is free software: you can redistribute it and/or modify         *
 * it under the terms of the Lesser GNU General Public License as published by  *
 * the Free Software Foundation, either version 3.0 of the License, or          *
 * (at your option) any later version.                                          *
 *                                                                              *
 * IfcOpenShell is distributed in the hope that it will be useful,              *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of               *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the                 *
 * Lesser GNU General Public License for more details.                          *
 *                                                                              *
 * You should have received a copy of the Lesser GNU General Public License     *
 * along with this program. If not, see <http://www.gnu.org/licenses/>.         *
 *                                                                              *
 ********************************************************************************/

/********************************************************************************
 *                                                                              *
 * This file has been generated from IFC4.exp. Do not make modifications        *
 * but instead modify the python script that has been used to generate this.    *
 *                                                                              *
 ********************************************************************************/

#ifndef IFC4_H
#define IFC4_H

#include <string>
#include <vector>

#include <boost/optional.hpp>

#include "../ifcparse/ifc_parse_api.h"

#include "../ifcparse/IfcEntityList.h"
#include "../ifcparse/IfcBaseClass.h"
#include "../ifcparse/IfcException.h"
#include "../ifcparse/Argument.h"

#include "../ifcparse/Ifc4enum.h"

#define IfcSchema Ifc4

namespace Ifc4 {

const char* const Identifier = "IFC4";

// Forward definitions
class IfcActionRequest; class IfcActor; class IfcActorRole; class IfcActuator; class IfcActuatorType; class IfcAddress; class IfcAdvancedBrep; class IfcAdvancedBrepWithVoids; class IfcAdvancedFace; class IfcAirTerminal; class IfcAirTerminalBox; class IfcAirTerminalBoxType; class IfcAirTerminalType; class IfcAirToAirHeatRecovery; class IfcAirToAirHeatRecoveryType; class IfcAlarm; class IfcAlarmType; class IfcAnnotation; class IfcAnnotationFillArea; class IfcApplication; class IfcAppliedValue; class IfcApproval; class IfcApprovalRelationship; class IfcArbitraryClosedProfileDef; class IfcArbitraryOpenProfileDef; class IfcArbitraryProfileDefWithVoids; class IfcAsset; class IfcAsymmetricIShapeProfileDef; class IfcAudioVisualAppliance; class IfcAudioVisualApplianceType; class IfcAxis1Placement; class IfcAxis2Placement2D; class IfcAxis2Placement3D; class IfcBSplineCurve; class IfcBSplineCurveWithKnots; class IfcBSplineSurface; class IfcBSplineSurfaceWithKnots; class IfcBeam; class IfcBeamStandardCase; class IfcBeamType; class IfcBlobTexture; class IfcBlock; class IfcBoiler; class IfcBoilerType; class IfcBooleanClippingResult; class IfcBooleanResult; class IfcBoundaryCondition; class IfcBoundaryCurve; class IfcBoundaryEdgeCondition; class IfcBoundaryFaceCondition; class IfcBoundaryNodeCondition; class IfcBoundaryNodeConditionWarping; class IfcBoundedCurve; class IfcBoundedSurface; class IfcBoundingBox; class IfcBoxedHalfSpace; class IfcBuilding; class IfcBuildingElement; class IfcBuildingElementPart; class IfcBuildingElementPartType; class IfcBuildingElementProxy; class IfcBuildingElementProxyType; class IfcBuildingElementType; class IfcBuildingStorey; class IfcBuildingSystem; class IfcBurner; class IfcBurnerType; class IfcCShapeProfileDef; class IfcCableCarrierFitting; class IfcCableCarrierFittingType; class IfcCableCarrierSegment; class IfcCableCarrierSegmentType; class IfcCableFitting; class IfcCableFittingType; class IfcCableSegment; class IfcCableSegmentType; class IfcCartesianPoint; class IfcCartesianPointList; class IfcCartesianPointList2D; class IfcCartesianPointList3D; class IfcCartesianTransformationOperator; class IfcCartesianTransformationOperator2D; class IfcCartesianTransformationOperator2DnonUniform; class IfcCartesianTransformationOperator3D; class IfcCartesianTransformationOperator3DnonUniform; class IfcCenterLineProfileDef; class IfcChiller; class IfcChillerType; class IfcChimney; class IfcChimneyType; class IfcCircle; class IfcCircleHollowProfileDef; class IfcCircleProfileDef; class IfcCivilElement; class IfcCivilElementType; class IfcClassification; class IfcClassificationReference; class IfcClosedShell; class IfcCoil; class IfcCoilType; class IfcColourRgb; class IfcColourRgbList; class IfcColourSpecification; class IfcColumn; class IfcColumnStandardCase; class IfcColumnType; class IfcCommunicationsAppliance; class IfcCommunicationsApplianceType; class IfcComplexProperty; class IfcComplexPropertyTemplate; class IfcCompositeCurve; class IfcCompositeCurveOnSurface; class IfcCompositeCurveSegment; class IfcCompositeProfileDef; class IfcCompressor; class IfcCompressorType; class IfcCondenser; class IfcCondenserType; class IfcConic; class IfcConnectedFaceSet; class IfcConnectionCurveGeometry; class IfcConnectionGeometry; class IfcConnectionPointEccentricity; class IfcConnectionPointGeometry; class IfcConnectionSurfaceGeometry; class IfcConnectionVolumeGeometry; class IfcConstraint; class IfcConstructionEquipmentResource; class IfcConstructionEquipmentResourceType; class IfcConstructionMaterialResource; class IfcConstructionMaterialResourceType; class IfcConstructionProductResource; class IfcConstructionProductResourceType; class IfcConstructionResource; class IfcConstructionResourceType; class IfcContext; class IfcContextDependentUnit; class IfcControl; class IfcController; class IfcControllerType; class IfcConversionBasedUnit; class IfcConversionBasedUnitWithOffset; class IfcCooledBeam; class IfcCooledBeamType; class IfcCoolingTower; class IfcCoolingTowerType; class IfcCoordinateOperation; class IfcCoordinateReferenceSystem; class IfcCostItem; class IfcCostSchedule; class IfcCostValue; class IfcCovering; class IfcCoveringType; class IfcCrewResource; class IfcCrewResourceType; class IfcCsgPrimitive3D; class IfcCsgSolid; class IfcCurrencyRelationship; class IfcCurtainWall; class IfcCurtainWallType; class IfcCurve; class IfcCurveBoundedPlane; class IfcCurveBoundedSurface; class IfcCurveStyle; class IfcCurveStyleFont; class IfcCurveStyleFontAndScaling; class IfcCurveStyleFontPattern; class IfcCylindricalSurface; class IfcDamper; class IfcDamperType; class IfcDerivedProfileDef; class IfcDerivedUnit; class IfcDerivedUnitElement; class IfcDimensionalExponents; class IfcDirection; class IfcDiscreteAccessory; class IfcDiscreteAccessoryType; class IfcDistributionChamberElement; class IfcDistributionChamberElementType; class IfcDistributionCircuit; class IfcDistributionControlElement; class IfcDistributionControlElementType; class IfcDistributionElement; class IfcDistributionElementType; class IfcDistributionFlowElement; class IfcDistributionFlowElementType; class IfcDistributionPort; class IfcDistributionSystem; class IfcDocumentInformation; class IfcDocumentInformationRelationship; class IfcDocumentReference; class IfcDoor; class IfcDoorLiningProperties; class IfcDoorPanelProperties; class IfcDoorStandardCase; class IfcDoorStyle; class IfcDoorType; class IfcDraughtingPreDefinedColour; class IfcDraughtingPreDefinedCurveFont; class IfcDuctFitting; class IfcDuctFittingType; class IfcDuctSegment; class IfcDuctSegmentType; class IfcDuctSilencer; class IfcDuctSilencerType; class IfcEdge; class IfcEdgeCurve; class IfcEdgeLoop; class IfcElectricAppliance; class IfcElectricApplianceType; class IfcElectricDistributionBoard; class IfcElectricDistributionBoardType; class IfcElectricFlowStorageDevice; class IfcElectricFlowStorageDeviceType; class IfcElectricGenerator; class IfcElectricGeneratorType; class IfcElectricMotor; class IfcElectricMotorType; class IfcElectricTimeControl; class IfcElectricTimeControlType; class IfcElement; class IfcElementAssembly; class IfcElementAssemblyType; class IfcElementComponent; class IfcElementComponentType; class IfcElementQuantity; class IfcElementType; class IfcElementarySurface; class IfcEllipse; class IfcEllipseProfileDef; class IfcEnergyConversionDevice; class IfcEnergyConversionDeviceType; class IfcEngine; class IfcEngineType; class IfcEvaporativeCooler; class IfcEvaporativeCoolerType; class IfcEvaporator; class IfcEvaporatorType; class IfcEvent; class IfcEventTime; class IfcEventType; class IfcExtendedProperties; class IfcExternalInformation; class IfcExternalReference; class IfcExternalReferenceRelationship; class IfcExternalSpatialElement; class IfcExternalSpatialStructureElement; class IfcExternallyDefinedHatchStyle; class IfcExternallyDefinedSurfaceStyle; class IfcExternallyDefinedTextFont; class IfcExtrudedAreaSolid; class IfcExtrudedAreaSolidTapered; class IfcFace; class IfcFaceBasedSurfaceModel; class IfcFaceBound; class IfcFaceOuterBound; class IfcFaceSurface; class IfcFacetedBrep; class IfcFacetedBrepWithVoids; class IfcFailureConnectionCondition; class IfcFan; class IfcFanType; class IfcFastener; class IfcFastenerType; class IfcFeatureElement; class IfcFeatureElementAddition; class IfcFeatureElementSubtraction; class IfcFillAreaStyle; class IfcFillAreaStyleHatching; class IfcFillAreaStyleTiles; class IfcFilter; class IfcFilterType; class IfcFireSuppressionTerminal; class IfcFireSuppressionTerminalType; class IfcFixedReferenceSweptAreaSolid; class IfcFlowController; class IfcFlowControllerType; class IfcFlowFitting; class IfcFlowFittingType; class IfcFlowInstrument; class IfcFlowInstrumentType; class IfcFlowMeter; class IfcFlowMeterType; class IfcFlowMovingDevice; class IfcFlowMovingDeviceType; class IfcFlowSegment; class IfcFlowSegmentType; class IfcFlowStorageDevice; class IfcFlowStorageDeviceType; class IfcFlowTerminal; class IfcFlowTerminalType; class IfcFlowTreatmentDevice; class IfcFlowTreatmentDeviceType; class IfcFooting; class IfcFootingType; class IfcFurnishingElement; class IfcFurnishingElementType; class IfcFurniture; class IfcFurnitureType; class IfcGeographicElement; class IfcGeographicElementType; class IfcGeometricCurveSet; class IfcGeometricRepresentationContext; class IfcGeometricRepresentationItem; class IfcGeometricRepresentationSubContext; class IfcGeometricSet; class IfcGrid; class IfcGridAxis; class IfcGridPlacement; class IfcGroup; class IfcHalfSpaceSolid; class IfcHeatExchanger; class IfcHeatExchangerType; class IfcHumidifier; class IfcHumidifierType; class IfcIShapeProfileDef; class IfcImageTexture; class IfcIndexedColourMap; class IfcIndexedPolyCurve; class IfcIndexedPolygonalFace; class IfcIndexedPolygonalFaceWithVoids; class IfcIndexedTextureMap; class IfcIndexedTriangleTextureMap; class IfcInterceptor; class IfcInterceptorType; class IfcIntersectionCurve; class IfcInventory; class IfcIrregularTimeSeries; class IfcIrregularTimeSeriesValue; class IfcJunctionBox; class IfcJunctionBoxType; class IfcLShapeProfileDef; class IfcLaborResource; class IfcLaborResourceType; class IfcLagTime; class IfcLamp; class IfcLampType; class IfcLibraryInformation; class IfcLibraryReference; class IfcLightDistributionData; class IfcLightFixture; class IfcLightFixtureType; class IfcLightIntensityDistribution; class IfcLightSource; class IfcLightSourceAmbient; class IfcLightSourceDirectional; class IfcLightSourceGoniometric; class IfcLightSourcePositional; class IfcLightSourceSpot; class IfcLine; class IfcLocalPlacement; class IfcLoop; class IfcManifoldSolidBrep; class IfcMapConversion; class IfcMappedItem; class IfcMaterial; class IfcMaterialClassificationRelationship; class IfcMaterialConstituent; class IfcMaterialConstituentSet; class IfcMaterialDefinition; class IfcMaterialDefinitionRepresentation; class IfcMaterialLayer; class IfcMaterialLayerSet; class IfcMaterialLayerSetUsage; class IfcMaterialLayerWithOffsets; class IfcMaterialList; class IfcMaterialProfile; class IfcMaterialProfileSet; class IfcMaterialProfileSetUsage; class IfcMaterialProfileSetUsageTapering; class IfcMaterialProfileWithOffsets; class IfcMaterialProperties; class IfcMaterialRelationship; class IfcMaterialUsageDefinition; class IfcMeasureWithUnit; class IfcMechanicalFastener; class IfcMechanicalFastenerType; class IfcMedicalDevice; class IfcMedicalDeviceType; class IfcMember; class IfcMemberStandardCase; class IfcMemberType; class IfcMetric; class IfcMirroredProfileDef; class IfcMonetaryUnit; class IfcMotorConnection; class IfcMotorConnectionType; class IfcNamedUnit; class IfcObject; class IfcObjectDefinition; class IfcObjectPlacement; class IfcObjective; class IfcOccupant; class IfcOffsetCurve2D; class IfcOffsetCurve3D; class IfcOpenShell; class IfcOpeningElement; class IfcOpeningStandardCase; class IfcOrganization; class IfcOrganizationRelationship; class IfcOrientedEdge; class IfcOuterBoundaryCurve; class IfcOutlet; class IfcOutletType; class IfcOwnerHistory; class IfcParameterizedProfileDef; class IfcPath; class IfcPcurve; class IfcPerformanceHistory; class IfcPermeableCoveringProperties; class IfcPermit; class IfcPerson; class IfcPersonAndOrganization; class IfcPhysicalComplexQuantity; class IfcPhysicalQuantity; class IfcPhysicalSimpleQuantity; class IfcPile; class IfcPileType; class IfcPipeFitting; class IfcPipeFittingType; class IfcPipeSegment; class IfcPipeSegmentType; class IfcPixelTexture; class IfcPlacement; class IfcPlanarBox; class IfcPlanarExtent; class IfcPlane; class IfcPlate; class IfcPlateStandardCase; class IfcPlateType; class IfcPoint; class IfcPointOnCurve; class IfcPointOnSurface; class IfcPolyLoop; class IfcPolygonalBoundedHalfSpace; class IfcPolygonalFaceSet; class IfcPolyline; class IfcPort; class IfcPostalAddress; class IfcPreDefinedColour; class IfcPreDefinedCurveFont; class IfcPreDefinedItem; class IfcPreDefinedProperties; class IfcPreDefinedPropertySet; class IfcPreDefinedTextFont; class IfcPresentationItem; class IfcPresentationLayerAssignment; class IfcPresentationLayerWithStyle; class IfcPresentationStyle; class IfcPresentationStyleAssignment; class IfcProcedure; class IfcProcedureType; class IfcProcess; class IfcProduct; class IfcProductDefinitionShape; class IfcProductRepresentation; class IfcProfileDef; class IfcProfileProperties; class IfcProject; class IfcProjectLibrary; class IfcProjectOrder; class IfcProjectedCRS; class IfcProjectionElement; class IfcProperty; class IfcPropertyAbstraction; class IfcPropertyBoundedValue; class IfcPropertyDefinition; class IfcPropertyDependencyRelationship; class IfcPropertyEnumeratedValue; class IfcPropertyEnumeration; class IfcPropertyListValue; class IfcPropertyReferenceValue; class IfcPropertySet; class IfcPropertySetDefinition; class IfcPropertySetTemplate; class IfcPropertySingleValue; class IfcPropertyTableValue; class IfcPropertyTemplate; class IfcPropertyTemplateDefinition; class IfcProtectiveDevice; class IfcProtectiveDeviceTrippingUnit; class IfcProtectiveDeviceTrippingUnitType; class IfcProtectiveDeviceType; class IfcProxy; class IfcPump; class IfcPumpType; class IfcQuantityArea; class IfcQuantityCount; class IfcQuantityLength; class IfcQuantitySet; class IfcQuantityTime; class IfcQuantityVolume; class IfcQuantityWeight; class IfcRailing; class IfcRailingType; class IfcRamp; class IfcRampFlight; class IfcRampFlightType; class IfcRampType; class IfcRationalBSplineCurveWithKnots; class IfcRationalBSplineSurfaceWithKnots; class IfcRectangleHollowProfileDef; class IfcRectangleProfileDef; class IfcRectangularPyramid; class IfcRectangularTrimmedSurface; class IfcRecurrencePattern; class IfcReference; class IfcRegularTimeSeries; class IfcReinforcementBarProperties; class IfcReinforcementDefinitionProperties; class IfcReinforcingBar; class IfcReinforcingBarType; class IfcReinforcingElement; class IfcReinforcingElementType; class IfcReinforcingMesh; class IfcReinforcingMeshType; class IfcRelAggregates; class IfcRelAssigns; class IfcRelAssignsToActor; class IfcRelAssignsToControl; class IfcRelAssignsToGroup; class IfcRelAssignsToGroupByFactor; class IfcRelAssignsToProcess; class IfcRelAssignsToProduct; class IfcRelAssignsToResource; class IfcRelAssociates; class IfcRelAssociatesApproval; class IfcRelAssociatesClassification; class IfcRelAssociatesConstraint; class IfcRelAssociatesDocument; class IfcRelAssociatesLibrary; class IfcRelAssociatesMaterial; class IfcRelConnects; class IfcRelConnectsElements; class IfcRelConnectsPathElements; class IfcRelConnectsPortToElement; class IfcRelConnectsPorts; class IfcRelConnectsStructuralActivity; class IfcRelConnectsStructuralMember; class IfcRelConnectsWithEccentricity; class IfcRelConnectsWithRealizingElements; class IfcRelContainedInSpatialStructure; class IfcRelCoversBldgElements; class IfcRelCoversSpaces; class IfcRelDeclares; class IfcRelDecomposes; class IfcRelDefines; class IfcRelDefinesByObject; class IfcRelDefinesByProperties; class IfcRelDefinesByTemplate; class IfcRelDefinesByType; class IfcRelFillsElement; class IfcRelFlowControlElements; class IfcRelInterferesElements; class IfcRelNests; class IfcRelProjectsElement; class IfcRelReferencedInSpatialStructure; class IfcRelSequence; class IfcRelServicesBuildings; class IfcRelSpaceBoundary; class IfcRelSpaceBoundary1stLevel; class IfcRelSpaceBoundary2ndLevel; class IfcRelVoidsElement; class IfcRelationship; class IfcReparametrisedCompositeCurveSegment; class IfcRepresentation; class IfcRepresentationContext; class IfcRepresentationItem; class IfcRepresentationMap; class IfcResource; class IfcResourceApprovalRelationship; class IfcResourceConstraintRelationship; class IfcResourceLevelRelationship; class IfcResourceTime; class IfcRevolvedAreaSolid; class IfcRevolvedAreaSolidTapered; class IfcRightCircularCone; class IfcRightCircularCylinder; class IfcRoof; class IfcRoofType; class IfcRoot; class IfcRoundedRectangleProfileDef; class IfcSIUnit; class IfcSanitaryTerminal; class IfcSanitaryTerminalType; class IfcSchedulingTime; class IfcSeamCurve; class IfcSectionProperties; class IfcSectionReinforcementProperties; class IfcSectionedSpine; class IfcSensor; class IfcSensorType; class IfcShadingDevice; class IfcShadingDeviceType; class IfcShapeAspect; class IfcShapeModel; class IfcShapeRepresentation; class IfcShellBasedSurfaceModel; class IfcSimpleProperty; class IfcSimplePropertyTemplate; class IfcSite; class IfcSlab; class IfcSlabElementedCase; class IfcSlabStandardCase; class IfcSlabType; class IfcSlippageConnectionCondition; class IfcSolarDevice; class IfcSolarDeviceType; class IfcSolidModel; class IfcSpace; class IfcSpaceHeater; class IfcSpaceHeaterType; class IfcSpaceType; class IfcSpatialElement; class IfcSpatialElementType; class IfcSpatialStructureElement; class IfcSpatialStructureElementType; class IfcSpatialZone; class IfcSpatialZoneType; class IfcSphere; class IfcSphericalSurface; class IfcStackTerminal; class IfcStackTerminalType; class IfcStair; class IfcStairFlight; class IfcStairFlightType; class IfcStairType; class IfcStructuralAction; class IfcStructuralActivity; class IfcStructuralAnalysisModel; class IfcStructuralConnection; class IfcStructuralConnectionCondition; class IfcStructuralCurveAction; class IfcStructuralCurveConnection; class IfcStructuralCurveMember; class IfcStructuralCurveMemberVarying; class IfcStructuralCurveReaction; class IfcStructuralItem; class IfcStructuralLinearAction; class IfcStructuralLoad; class IfcStructuralLoadCase; class IfcStructuralLoadConfiguration; class IfcStructuralLoadGroup; class IfcStructuralLoadLinearForce; class IfcStructuralLoadOrResult; class IfcStructuralLoadPlanarForce; class IfcStructuralLoadSingleDisplacement; class IfcStructuralLoadSingleDisplacementDistortion; class IfcStructuralLoadSingleForce; class IfcStructuralLoadSingleForceWarping; class IfcStructuralLoadStatic; class IfcStructuralLoadTemperature; class IfcStructuralMember; class IfcStructuralPlanarAction; class IfcStructuralPointAction; class IfcStructuralPointConnection; class IfcStructuralPointReaction; class IfcStructuralReaction; class IfcStructuralResultGroup; class IfcStructuralSurfaceAction; class IfcStructuralSurfaceConnection; class IfcStructuralSurfaceMember; class IfcStructuralSurfaceMemberVarying; class IfcStructuralSurfaceReaction; class IfcStyleModel; class IfcStyledItem; class IfcStyledRepresentation; class IfcSubContractResource; class IfcSubContractResourceType; class IfcSubedge; class IfcSurface; class IfcSurfaceCurve; class IfcSurfaceCurveSweptAreaSolid; class IfcSurfaceFeature; class IfcSurfaceOfLinearExtrusion; class IfcSurfaceOfRevolution; class IfcSurfaceReinforcementArea; class IfcSurfaceStyle; class IfcSurfaceStyleLighting; class IfcSurfaceStyleRefraction; class IfcSurfaceStyleRendering; class IfcSurfaceStyleShading; class IfcSurfaceStyleWithTextures; class IfcSurfaceTexture; class IfcSweptAreaSolid; class IfcSweptDiskSolid; class IfcSweptDiskSolidPolygonal; class IfcSweptSurface; class IfcSwitchingDevice; class IfcSwitchingDeviceType; class IfcSystem; class IfcSystemFurnitureElement; class IfcSystemFurnitureElementType; class IfcTShapeProfileDef; class IfcTable; class IfcTableColumn; class IfcTableRow; class IfcTank; class IfcTankType; class IfcTask; class IfcTaskTime; class IfcTaskTimeRecurring; class IfcTaskType; class IfcTelecomAddress; class IfcTendon; class IfcTendonAnchor; class IfcTendonAnchorType; class IfcTendonType; class IfcTessellatedFaceSet; class IfcTessellatedItem; class IfcTextLiteral; class IfcTextLiteralWithExtent; class IfcTextStyle; class IfcTextStyleFontModel; class IfcTextStyleForDefinedFont; class IfcTextStyleTextModel; class IfcTextureCoordinate; class IfcTextureCoordinateGenerator; class IfcTextureMap; class IfcTextureVertex; class IfcTextureVertexList; class IfcTimePeriod; class IfcTimeSeries; class IfcTimeSeriesValue; class IfcTopologicalRepresentationItem; class IfcTopologyRepresentation; class IfcToroidalSurface; class IfcTransformer; class IfcTransformerType; class IfcTransportElement; class IfcTransportElementType; class IfcTrapeziumProfileDef; class IfcTriangulatedFaceSet; class IfcTrimmedCurve; class IfcTubeBundle; class IfcTubeBundleType; class IfcTypeObject; class IfcTypeProcess; class IfcTypeProduct; class IfcTypeResource; class IfcUShapeProfileDef; class IfcUnitAssignment; class IfcUnitaryControlElement; class IfcUnitaryControlElementType; class IfcUnitaryEquipment; class IfcUnitaryEquipmentType; class IfcValve; class IfcValveType; class IfcVector; class IfcVertex; class IfcVertexLoop; class IfcVertexPoint; class IfcVibrationIsolator; class IfcVibrationIsolatorType; class IfcVirtualElement; class IfcVirtualGridIntersection; class IfcVoidingFeature; class IfcWall; class IfcWallElementedCase; class IfcWallStandardCase; class IfcWallType; class IfcWasteTerminal; class IfcWasteTerminalType; class IfcWindow; class IfcWindowLiningProperties; class IfcWindowPanelProperties; class IfcWindowStandardCase; class IfcWindowStyle; class IfcWindowType; class IfcWorkCalendar; class IfcWorkControl; class IfcWorkPlan; class IfcWorkSchedule; class IfcWorkTime; class IfcZShapeProfileDef; class IfcZone; class IfcAbsorbedDoseMeasure; class IfcAccelerationMeasure; class IfcAmountOfSubstanceMeasure; class IfcAngularVelocityMeasure; class IfcArcIndex; class IfcAreaDensityMeasure; class IfcAreaMeasure; class IfcBinary; class IfcBoolean; class IfcBoxAlignment; class IfcCardinalPointReference; class IfcComplexNumber; class IfcCompoundPlaneAngleMeasure; class IfcContextDependentMeasure; class IfcCountMeasure; class IfcCurvatureMeasure; class IfcDate; class IfcDateTime; class IfcDayInMonthNumber; class IfcDayInWeekNumber; class IfcDescriptiveMeasure; class IfcDimensionCount; class IfcDoseEquivalentMeasure; class IfcDuration; class IfcDynamicViscosityMeasure; class IfcElectricCapacitanceMeasure; class IfcElectricChargeMeasure; class IfcElectricConductanceMeasure; class IfcElectricCurrentMeasure; class IfcElectricResistanceMeasure; class IfcElectricVoltageMeasure; class IfcEnergyMeasure; class IfcFontStyle; class IfcFontVariant; class IfcFontWeight; class IfcForceMeasure; class IfcFrequencyMeasure; class IfcGloballyUniqueId; class IfcHeatFluxDensityMeasure; class IfcHeatingValueMeasure; class IfcIdentifier; class IfcIlluminanceMeasure; class IfcInductanceMeasure; class IfcInteger; class IfcIntegerCountRateMeasure; class IfcIonConcentrationMeasure; class IfcIsothermalMoistureCapacityMeasure; class IfcKinematicViscosityMeasure; class IfcLabel; class IfcLanguageId; class IfcLengthMeasure; class IfcLineIndex; class IfcLinearForceMeasure; class IfcLinearMomentMeasure; class IfcLinearStiffnessMeasure; class IfcLinearVelocityMeasure; class IfcLogical; class IfcLuminousFluxMeasure; class IfcLuminousIntensityDistributionMeasure; class IfcLuminousIntensityMeasure; class IfcMagneticFluxDensityMeasure; class IfcMagneticFluxMeasure; class IfcMassDensityMeasure; class IfcMassFlowRateMeasure; class IfcMassMeasure; class IfcMassPerLengthMeasure; class IfcModulusOfElasticityMeasure; class IfcModulusOfLinearSubgradeReactionMeasure; class IfcModulusOfRotationalSubgradeReactionMeasure; class IfcModulusOfSubgradeReactionMeasure; class IfcMoistureDiffusivityMeasure; class IfcMolecularWeightMeasure; class IfcMomentOfInertiaMeasure; class IfcMonetaryMeasure; class IfcMonthInYearNumber; class IfcNonNegativeLengthMeasure; class IfcNormalisedRatioMeasure; class IfcNumericMeasure; class IfcPHMeasure; class IfcParameterValue; class IfcPlanarForceMeasure; class IfcPlaneAngleMeasure; class IfcPositiveInteger; class IfcPositiveLengthMeasure; class IfcPositivePlaneAngleMeasure; class IfcPositiveRatioMeasure; class IfcPowerMeasure; class IfcPresentableText; class IfcPressureMeasure; class IfcPropertySetDefinitionSet; class IfcRadioActivityMeasure; class IfcRatioMeasure; class IfcReal; class IfcRotationalFrequencyMeasure; class IfcRotationalMassMeasure; class IfcRotationalStiffnessMeasure; class IfcSectionModulusMeasure; class IfcSectionalAreaIntegralMeasure; class IfcShearModulusMeasure; class IfcSolidAngleMeasure; class IfcSoundPowerLevelMeasure; class IfcSoundPowerMeasure; class IfcSoundPressureLevelMeasure; class IfcSoundPressureMeasure; class IfcSpecificHeatCapacityMeasure; class IfcSpecularExponent; class IfcSpecularRoughness; class IfcTemperatureGradientMeasure; class IfcTemperatureRateOfChangeMeasure; class IfcText; class IfcTextAlignment; class IfcTextDecoration; class IfcTextFontName; class IfcTextTransformation; class IfcThermalAdmittanceMeasure; class IfcThermalConductivityMeasure; class IfcThermalExpansionCoefficientMeasure; class IfcThermalResistanceMeasure; class IfcThermalTransmittanceMeasure; class IfcThermodynamicTemperatureMeasure; class IfcTime; class IfcTimeMeasure; class IfcTimeStamp; class IfcTorqueMeasure; class IfcURIReference; class IfcVaporPermeabilityMeasure; class IfcVolumeMeasure; class IfcVolumetricFlowRateMeasure; class IfcWarpingConstantMeasure; class IfcWarpingMomentMeasure; 

/// The actor select type allows a person, or an organization, or a person associated with an organization to be referenced.
/// 
/// NOTE Corresponds to the following entity in ISO 10303-41: person_organization_select.
/// 
/// HISTORY New entity in IFC Release 1.5.1
/// 
/// SELECT 
/// 
/// IfcOrganization An organization. 
/// IfcPerson A person. 
/// IfcPersonAndOrganization A person related to an organization.
typedef IfcUtil::IfcBaseClass IfcActorSelect;
/// IfcAppliedValueSelect defines the selection of whether a value (expressed as a ratio) or an amount should be used as the value for an IfcAppliedValue. 
/// 
/// Select from:  
/// 
/// IfcMeasureWithUnit 
///   IfcMonetaryMeasure 
///   IfcRatioMeasure 
/// 
/// HISTORY: New SELECT type in IFC 2x2.
/// 
/// Use definitions 
/// Selecting IfcMeasureWithUnit allows the specification of both the actual figure for the value together with the currency in which the value is represented. 
/// Selecting IfcMonetaryMeasure allows the specification only of the value, the currency being as set by the global context 
/// Selecting IfcRatioMeasure assumes that the amount is a percentage or other REAL number. Note that if the amount is normally specified as -20%, then this figure will need to be converted to a multiplier of 0.8
typedef IfcUtil::IfcBaseClass IfcAppliedValueSelect;
/// Definition from ISO/CD 10303-42:1992: This select type collects together both versions of the placement as used in two dimensional or in three dimensional Cartesian space. This enables entities requiring this information to reference them without specifying the space dimensionality.  
/// 
/// NOTE: Corresponding STEP type: axis2_placement, please refer to ISO/IS 10303-42:1994, p. 19 for the final definition of the formal standard.
/// 
/// HISTORY: New type in IFC Release 1.5
typedef IfcUtil::IfcBaseClass IfcAxis2Placement;
/// Definition from IAI: A select type for selecting between simple measure types for reinforcement bending parameters.
/// 
/// HISTORY New type in IFC Release 2x4
typedef IfcUtil::IfcBaseClass IfcBendingParameterSelect;
/// Definition from ISO/CD 10303-42:1992: This select type identifies
///   all those types of entities which may participate in a Boolean operation to
///   form a CSG solid.  
///   Definition from IAI: CSG primitives are out of scope for the
///   current IFC Release. Only faceted B-reps, swept area solids and half space
///   solids are available as Boolean operands. Boolean results themselves can be used
///   as operands thus enabling nested Boolean operations. 
/// 
/// NOTE Corresponding STEP type:
///   boolean_operand, please refer to ISO/IS 10303-42:1994, p.167 for the final
///   definition of the formal standard. In IFC Release 1.5.1 & 2.0 only Boolean
///   results (IfcBooleanResult), half space solids
///   (IfcHalfSpaceSolid), faceted B-Rep, extruded solids and revolved solids
///   (IfcSolidModel) are defined for being valid Boolean operands.
/// 
/// HISTORY: New Type in IFC Release 1.5.1
typedef IfcUtil::IfcBaseClass IfcBooleanOperand;
/// IfcClassificationReferenceSelect enables selection of whether a classification reference is a subset of another classification reference or is a top level entry of a classification source. 
/// 
/// HISTORY: New Select Type in IFC2x
/// 
/// Select From: 
/// 
/// IfcClassification (for classification information)  
/// IfcClassificationReference (for reference into a classification source)
typedef IfcUtil::IfcBaseClass IfcClassificationReferenceSelect;
/// IfcClassificationSelect enables selection of whether a classification reference is to be referenced from an external source, or whether a classification is referenced as such.
/// 
/// NOTE  Generally, it is expected that selection will be by IfcClassificationReference to identify an individual classification notation that classifies an element in the building information model. For example an element, such as IfcTank, might be further classified by assigning an IfcClassificationReference with Identification = "L6814" and a ClassificationSource identifying the appropriate version of Uniclass.  IfcClassification should only be selected in
/// circumstances where there could be a need to indicate the classification system that will be used without associating a notation or reference to an individual object. This may occur for higher level objects such as IfcProject, IfcSystem, or similar. For example an IfcStructuralAnalysisModel might be classified to be applicable to a particular version of EuroCode.
/// 
/// HISTORY  New select type in IFC2x
/// 
/// IFC2x4 CHANGE  Select renamed from IfcClassificationNotationSelect.
/// 
/// Select from:
/// 
/// IfcClassification (for referencing a classification system)
/// IfcClassificationReference (for referencing a classification item (or facet) inside a classification system)
typedef IfcUtil::IfcBaseClass IfcClassificationSelect;
/// Definition from ISO/CD 10303-46:1992: The colour entity defines a basic appearance of elements which shall be visualized in a picture.
/// 
/// NOTE  Corresponding STEP name: colour. It has been made into a SELECT type in IFC to avoid multiple inheritance for pre defined colour. Please refer to ISO/IS 10303-46:1994, p. 138 for the final definition of the formal standard.
/// 
/// HISTORY  New entity in IFC2x2.
typedef IfcUtil::IfcBaseClass IfcColour;
/// The IfcColourOrFactor enables the selection of either a RGB colour value or a scalar factor value for the use as values of the reflectance components.
/// 
/// HISTORY: New type in IFC2x2.
typedef IfcUtil::IfcBaseClass IfcColourOrFactor;
/// IfcCoordinateReferenceSystemSelect is a select between either the local engineering coordinate system, represented by the IfcGeometricRepresentationContext, or another coordinate reference system, represented by IfcCoordinateReferenceSystem, to be the source of a coordinate operation.
/// 
/// HISTORY  New select type in IFC2x4.
typedef IfcUtil::IfcBaseClass IfcCoordinateReferenceSystemSelect;
/// Definition from ISO/CD 10303-42:1992: This type identifies the types of entity which may be selected as the root of a CSG tree including a single CSG primitive as a special case.
/// Definition from IAI: The IfcBooleanResult, and subtypes of IfcCsgPrimitive3D are defined as potential root tree expression (at IfcCsgSolid). A subtype of IfcCsgPrimitive3D marks the special case of a CSG solid solely expressed by a single primitive.
/// 
/// NOTE Corresponding ISO 10303-42 type: csg_select, please refer to ISO/IS 10303-42:1994, p.168 for the final definition of the formal standard.
/// 
/// HISTORY New Type in IFC Release 1.5.1.
typedef IfcUtil::IfcBaseClass IfcCsgSelect;
/// Definition from ISO/CD 10303-46:1992: The curve font or scaled curve font select is a selection of either a curve font style select (being either a predefined curve font or an explicitly defined curve font) or a curve style font and scaling. 
/// 
/// NOTE Corresponding ISO 10303 name: curve_font_or_scaled_curve_font_select. Please refer to ISO/IS 10303-46:1994 for the final definition of the formal standard.
/// 
/// HISTORY New entity in IFC2x2.
typedef IfcUtil::IfcBaseClass IfcCurveFontOrScaledCurveFontSelect;

typedef IfcUtil::IfcBaseClass IfcCurveOnSurface;
/// IfcCurveOrEdgeCurve provides the option to either select a geometric curve (IfcCurve
/// and subtypes) within a geometric model, or a curve with associated geometry and coordinates (IfcEdgeCurve) within a topological model.
/// SELECT 
/// 
/// IfcCurve
///   IfcEdgeCurve
/// 
/// HISTORY  New select type in IFC2x Edition 3.
typedef IfcUtil::IfcBaseClass IfcCurveOrEdgeCurve;
/// Definition from ISO/CD 10303-46:1992: The curve style font select is a selection of a curve style font or a predefined curve style font. 
/// 
/// NOTE Corresponding ISO 10303 name: curve_style_font_select. Please refer to ISO/IS 10303-46:1994 for the final definition of the formal standard.
/// 
/// HISTORY New entity in IFC2x2.
typedef IfcUtil::IfcBaseClass IfcCurveStyleFontSelect;
/// IfcDefinitionSelect provides the option to either select an object or type object IfcObjectDefinition, or a property set template or property set, IfcPropertyDefinition.
/// SELECT
/// 
/// IfcObjectDefinition,
/// IfcPropertyDefinition
/// 
/// HISTORY  New select type in IFC2x4.
typedef IfcUtil::IfcBaseClass IfcDefinitionSelect;
/// IfcDerivedMeasureValue is a select type for selecting between derived measure types.
/// 
/// SELECT 
/// 
/// IfcAbsorbedDoseMeasure 
///   IfcAccelerationMeasure 
///   IfcAngularVelocityMeasure 
///   IfcCompoundPlaneAngleMeasure 
///   IfcDoseEquivalentMeasure 
///   IfcDynamicViscosityMeasure 
///   IfcElectricCapacitanceMeasure 
///   IfcElectricChargeMeasure 
///   IfcElectricConductanceMeasure 
///   IfcElectricResistanceMeasure 
///   IfcElectricVoltageMeasure 
///   IfcEnergyMeasure 
///   IfcForceMeasure 
///   IfcFrequencyMeasure 
///   IfcHeatFluxDensityMeasure 
///   IfcIlluminanceMeasure 
///   IfcInductanceMeasure 
///   IfcIntegerCountRateMeasure 
///   IfcIsothermalMoisturecapacityMeasure 
///   IfcKinematicViscosityMeasure 
///   IfcLinearForceMeasure 
///   IfcLinearMomentMeasure  
///   IfcLinearStiffnessMeasure 
///   IfcLinearVelocityMeasure 
///   IfcLuminousFluxMeasure 
///   IfcMagneticFluxDensityMeasure 
///   IfcMagneticFluxMeasure 
///   IfcMassDensityMeasure 
///   IfcMassFlowRateMeasure 
///   IfcModulusOfElasticityMeasure 
///   IfcModulusOfSubgradeReactionMeasure 
///   IfcMoistureDiffusivityMeasure 
///   IfcMolecularWeightMeasure 
///   IfcMomentOfInertiaMeasure  
///   IfcMonetaryMeasure 
///   IfcPlanarForceMeasure 
///   IfcPowerMeasure 
///   IfcPressureMeasure 
///   IfcRadioActivityMeasure 
///   IfcRotationalFrequencyMeasure 
///   IfcRotationalStiffnessMeasure 
///   IfcShearModulusMeasure 
///   IfcSpecificHeatCapacityMeasure 
///   IfcThermalAdmittanceMeasure 
///   IfcThermalConductivityMeasure 
///   IfcThermalResistanceMeasure 
///   IfcThermalTransmittanceMeasure 
///   IfcTimeStamp 
///   IfcTorqueMeasure 
///   IfcVaporPermeabilityMeasure 
///   IfcVolumetricFlowRateMeasure 
///   IfcCurvatureMeasure 
///   IfcMassPerLengthMeasure 
///   IfcRotationalMassMeasure 
///   IfcSectionalAreaIntegralMeasure 
///   IfcSectionModulusMeasure 
///   IfcTemperatureGradientMeasure 
///   IfcTemperatureRateOfChangeMeasure 
///   IfcWarpingConstantMeasure 
///   IfcWarpingMomentMeasure 
///   IfcThermalExpansionCoefficientMeasure 
///   IfcModulusOfLinearSubgradeReactionMeasure 
///   IfcModulusOfRotationalSubgradeReactionMeasure 
///   IfcLuminousIntensityDistributionMeasure 
///   IfcSoundPowerMeasure 
///   IfcSoundPressureMeasure 
/// 
/// HISTORY New type in IFC Release 2x.
/// 
/// IFC2x4 change: added IfcTemperatureRateOfChangeMeasure.
typedef IfcUtil::IfcBaseClass IfcDerivedMeasureValue;
/// IfcDocumentSelect enables selection of whether document information is to be contained within an IFC model or is to be referenced from an external source. 
/// 
/// HISTORY: New Select Type in IFC 2x
/// 
/// Select From: 
/// 
/// IfcDocumentInformation (for "metadata" of an external document)  
/// IfcDocumentReference (for reference within a document)
typedef IfcUtil::IfcBaseClass IfcDocumentSelect;
/// Definition from ISO/CD 10303-46:1992: The fill style select is a selection between different fill area styles.
/// 
/// NOTE Corresponding ISO 10303 name: fill_style_select. Please refer to ISO/IS 10303-46:1994 for
/// the final definition of the formal standard.
/// 
/// HISTORY New type in IFC2x2.
typedef IfcUtil::IfcBaseClass IfcFillStyleSelect;
/// Definition from ISO/CD 10303-42:1992: This select type identifies the types of entities which can occur in a geometric set. 
/// 
/// NOTE: Corresponding ISO 10303 type: geometric_set_select. Please refer to ISO/IS 10303-42:1994, p. 169 for the final definition of the formal standard.
/// 
/// HISTORY: New type in IFC Release 2x.
typedef IfcUtil::IfcBaseClass IfcGeometricSetSelect;
/// IfcGridPlacementDirectionSelect enables the choice of defining a grid placement be either an explicit direction, or by referencing a second grid intersection to provide the direction.
/// 
/// SELECT
/// 
/// IfcDirection,
/// IfcVirtualGridIntersection
/// 
/// HISTORY  New select type in IFC2x4.
typedef IfcUtil::IfcBaseClass IfcGridPlacementDirectionSelect;
/// The IfcHatchLineDistanceSelect is a selection between different ways to determine the distance and potentially start point of hatch lines, either by an offset distance length measure or by a vector.
/// 
/// HISTORY  New type in IFC2x3.
typedef IfcUtil::IfcBaseClass IfcHatchLineDistanceSelect;
/// Definition from ISO/CD 10303-46:1992: The layered things type selects those things, which can be grouped in layers. 
/// 
/// It is the collection of all those items, that are assigned to a single layer. These items are representation items or complete representations (IfcRepresentationItem, IfcRepresentation). If an IfcRepresentation is referenced, all IfcRepresentationItem within its set of Items are assigned to the same layer. 
/// 
/// NOTE: Corresponding ISO 10303 name: layered_item. It was called layered_things in the ISO/CD version and had been renamed to layered_item in the ISO/IS final version. Please refer to ISO/IS 10303-46:1994, p. 13 for the final definition of the formal standard.
/// 
/// HISTORY: New type in IFC2x2.
typedef IfcUtil::IfcBaseClass IfcLayeredItem;
/// IfcLibrarySelect enables selection of whether library information is to be contained within an IFC model or is to be referenced from an external source. 
/// 
/// HISTORY: New Select Type in IFC2x
/// 
/// Select From: 
/// 
/// IfcLibraryInformation (for library information)  
/// IfcLibraryReference (for reference into a library of information by location)  
/// 
/// Generally, it is expected that selection will be IfcLibraryReference and only rarely IfcLibraryInformation. IfcLibraryInformation should only be selected in circumstances where there could be a need to indicate the libraries that will be used without making individual references. This may occur for higher level objects such as a project or building.
typedef IfcUtil::IfcBaseClass IfcLibrarySelect;
/// A goniometric light gets its intensity distribution function (how much light goes in any one direction) from one of two sources: (i) an industry-standard file, (ii) from distribution data passed directly via the IfcLightIntensityDistribution. 
/// 
/// The light distribution provides the luminous intensity distribution according to some standardized light distribution curves. 
/// 
/// Select: 
/// 
/// Type 
///   Definition 
/// 
/// IfcExternalReference 
///   Light distribution is represented by a standard photometric data file such as Eulumdat, IES, CIBSE TM14.  
/// 
/// IfcLightIntensityDistribution 
///   For representing a light distribution directly the
///   following values needs to be given in a table like structure with column and
///   row headings. These headings should contain the angles (C/&#947; or B/&#946; )
///   and the table body contains the intensity values, (normally normalized to
///   cd/Klm). The angles can be non- equidistant and the angle steps can be almost
///   any value in the valid range, so a list of all available angles in both
///   directions covers all cases.  
/// 
/// HISTORY New type in IFC2x2.
typedef IfcUtil::IfcBaseClass IfcLightDistributionDataSourceSelect;
/// IfcMaterialSelect provides selection of either a material
/// definition or a material usage definition that can be assigned to
/// an element, a resource or another entity within IFC.
/// SELECT
/// 
/// IfcMaterialDefinition
/// 
/// IfcMaterial
/// IfcMaterialLayer
/// IfcMaterialLayerSet
/// IfcMaterialProfile
/// IfcMaterialProfileSet
/// IfcMaterialConstituent
/// IfcMaterialConstituentSet
/// 
/// IfcMaterialUsageDefinition
/// 
/// IfcMaterialLayerSetUsage
/// IfcMaterialProfileSetUsage
/// 
/// IfcMaterialList
/// 
/// HISTORY New select in IFC 1.0
/// 
/// IFC2x4 CHANGE The select now includes two new abstract entities IfcMaterialDefinition
/// and IfcMaterialUsageDefinition with upward compatibility.  The use of IfcMaterialList is deprecated from IFC2x4 onwards.
typedef IfcUtil::IfcBaseClass IfcMaterialSelect;
/// Definition from ISO/CD 10303-41:1992: A measure value is a value as defined in ISO 31-0 (clause 2).
/// 
/// NOTE IfcMeasureValue is a select data type for most basic measure types coming from ISO 10303-41.  Select item IfcNonNegativeLengthMeasure is in addition to ISO 10303-41.
/// 
/// NOTE Corresponding ISO 10303 name: measure_value, please refer to ISO/IS 10303-41 for the final definition of the formal standard.
/// 
/// HISTORY New type in IFC Release 1.5.1.
/// 
/// IFC 2x4 change: added IfcNonNegativeLengthMeasure
typedef IfcUtil::IfcBaseClass IfcMeasureValue;
/// IfcMetricValueSelect is a select type that enables selection of the data type for the value component of an IfcMetric. 
/// 
/// HISTORY: New type in IFC Release 2.0
/// 
/// Select 
/// 
/// IfcCostValue
///   IfcDateTime 
///   IfcMeasureWithUnit 
///   IfcTable 
///   IfcText 
///   IfcTimeSeries
typedef IfcUtil::IfcBaseClass IfcMetricValueSelect;
/// Definition from IAI: A measure for modulus of rotational subgrade reaction which expresses the rotational bedding of a structural curve item per length.  TRUE denotes infinite stiffness (rigidity).  FALSE denotes no stiffness (a release).  A numeric value denotes finite linear-elastic stiffness.
/// 
/// HISTORY: New type in IFC 2x4.
typedef IfcUtil::IfcBaseClass IfcModulusOfRotationalSubgradeReactionSelect;
/// Definition from IAI: Bedding measure which expresses the bedding of a structural face item per area.  TRUE denotes infinite stiffness (rigidity).  FALSE denotes no stiffness (a release).  A numeric value denotes finite linear-elastic stiffness.
/// 
/// HISTORY: New type in IFC 2x4.
typedef IfcUtil::IfcBaseClass IfcModulusOfSubgradeReactionSelect;
/// Definition from IAI: A measure for modulus of translational subgrade reaction which expresses the translational bedding of a structural curve item per length.  TRUE denotes infinite stiffness (rigidity).  FALSE denotes no stiffness (a release).  A numeric value denotes finite linear-elastic stiffness.
/// 
/// HISTORY: New type in IFC 2x4.
typedef IfcUtil::IfcBaseClass IfcModulusOfTranslationalSubgradeReactionSelect;
/// IfcObjectReferenceSelect is a select type, that holds a list of resource level entities that can be used as properties within a property set. 
/// 
/// HISTORY  New select type in IFC Release 2.0.
typedef IfcUtil::IfcBaseClass IfcObjectReferenceSelect;
/// IfcPointOrVertexPoint provides the option to either select a geometric point (IfcPoint and subtypes) within a geometric model, or a vertex with associated point coordinates (IfcVertexPoint) within a topological model.
/// SELECT 
/// 
/// IfcPoint, 
///   IfcVertexPoint
/// 
/// HISTORY  New select type in IFC2x Edition 3.
typedef IfcUtil::IfcBaseClass IfcPointOrVertexPoint;
/// Definition from ISO/CD 10303-46:1992: The presentation style select is a selection of one of many kinds of styles, a different one for each kind of geometric representation item to be styled.
/// 
/// NOTE Corresponding ISO 10303 name: presentation_style_Select. Please refer to ISO/IS
/// 10303-46:1994 for the final definition of the formal standard.
/// 
/// HISTORY New type in IFC2x2.
/// 
/// IFC2x4 CHANGE The select type has been deprecated.
typedef IfcUtil::IfcBaseClass IfcPresentationStyleSelect;
/// IfcProcessSelect provides the option to either
///   select a process or activity occurrence, IfcProcess,
///   or a process or activity type, IfcTypeProcess.
///   SELECT
/// 
/// IfcProcess,
/// 
/// IfcTypeProcess
/// 
/// HISTORY  New select type in IFC2x4.
typedef IfcUtil::IfcBaseClass IfcProcessSelect;

typedef IfcUtil::IfcBaseClass IfcProductRepresentationSelect;
/// IfcProductSelect provides the option to either select a
/// product occurrence, IfcProduct, or a product type,
/// IfcTypeProduct.
/// SELECT
/// 
/// IfcProduct,
/// IfcTypeProduct
/// 
/// HISTORY  New select type in IFC2x4.
typedef IfcUtil::IfcBaseClass IfcProductSelect;

typedef IfcUtil::IfcBaseClass IfcPropertySetDefinitionSelect;
/// IfcResourceObjectSelect enables selection of resource level objects that are to be related to an resource level relationship object. The use of IfcResourceObjectSelect includes the ability to assign an external reference entity (library, classification, or documentation reference) to entities within the resource level.
/// 
/// HISTORY  New Select type in IFC2x4.
typedef IfcUtil::IfcBaseClass IfcResourceObjectSelect;
/// IfcResourceSelect provides the option to either select a
/// resource occurrence, IfcResource, or a resource type,
/// IfcTypeResource.
/// SELECT
/// 
/// IfcResource,
/// IfcTypeResource
/// 
/// HISTORY  New select type in IFC2x4.
typedef IfcUtil::IfcBaseClass IfcResourceSelect;
/// Definition from IAI: A measure of rotational stiffness.  TRUE denotes infinite stiffness (rigidity).  FALSE denotes no stiffness (a release).  A numeric value denotes finite linear-elastic stiffness.
/// 
/// HISTORY: New type in IFC 2x4.
typedef IfcUtil::IfcBaseClass IfcRotationalStiffnessSelect;

typedef IfcUtil::IfcBaseClass IfcSegmentIndexSelect;
/// Definition from ISO/CD 10303-42:1992 This type collects together, for reference when constructing more complex models, the subtypes which have the characteristics of a shell. A shell is a connected object of fixed dimensionality d = 0; 1; or 2, typically used to bound a region. The domain of a shell, if present, includes its bounds and 0 £ X < ¥.  
/// 
/// A shell of dimensionality 0 is represented by a graph consisting of a single vertex. The vertex shall not have any associated edges. 
/// A shell of dimensionality 1 is represented by a connected graph of dimensionality 1. 
/// A shell of dimensionality 2 is a topological entity constructed by joining faces along edges. Its domain, if present, is a connected, orientable 2-manifold with boundary, that is, a connected, oriented, finite, non-self-intersecting surface, which may be closed or open. 
/// 
/// Shells of dimensionality 0 and 1 are not part of the current IFC release. 
/// 
/// NOTE  Corresponding ISO 10303 type: shell. Please refer to ISO/IS 10303-42:1994, p. 127 for the final definition of the formal standard. Only the select items closed_shell (IfcClosedShell) and open_shell (IfcOpenShell) have been incorporated in the current IFC release. 
/// 
/// HISTORY  New type in IFC2x.
typedef IfcUtil::IfcBaseClass IfcShell;
/// IfcSimpleValue is a select type for selecting between simple value types.
/// 
/// SELECT 
/// 
/// IfcInteger: Defined type of simple type INTEGER. 
///   IfcReal: Defined type of simple type REAL. 
///   IfcBoolean: Defined type of simple type BOOLEAN. 
///   IfcLogical: Defined type of simple type LOGICAL. 
///   IfcIdentifier: Defined type of simple type STRING for identification purposes. 
///   IfcLabel: Defined type of simple type STRING for naming purposes. 
///   IfcText: Defined type of simple type STRING for descriptive purposes. 
///   IfcDateTime: Defined type of simple type STRING to represent a date and time. 
///   IfcDate: Defined type of simple type STRING to represent a date. 
///   IfcTime: Defined type of simple type STRING to represent a time. 
///   IfcDuration: Defined type of simple type STRING to represent a duration. 
/// 
/// HISTORY New type in IFC Release 2x.
/// 
/// IFC2x4 CHANGE Items IfcDateTime, IfcDate, IfcTime, IfcDuration added.
typedef IfcUtil::IfcBaseClass IfcSimpleValue;
/// Definition from ISO/CD 10303-46:1992: The size select is a selection of a specific positive length measure.
/// 
/// Definition from ISO: The size (or width) measure value is given in the global drawing length units.
/// 
/// NOTE  global units are defined at the single IfcProject instance, given by UnitsInContext:IfcUnitAssignment, the same units are used for the geometric representation items and for the style definitions.
/// 
/// NOTE  Corresponding ISO 10303 name: size_select. Please refer to ISO/IS 10303-46:1994 for the final
/// definition of the formal standard.
/// 
/// HISTORY  New type in IFC2x2.
/// 
/// IFC2x3 CHANGE  The SELECT item IfcMeasureWithUnit has been removed from the IfcSizeSelect, the IfcRatioMeasure and IfcDescriptiveMeasure has been added.
typedef IfcUtil::IfcBaseClass IfcSizeSelect;
/// The IfcSolidOrShell provides the option to either select a geometric volume (IfcSolidModel and subtypes) within a geometric model, or a shell (IfcClosedShell) within a topological model.
/// SELECT
/// 
/// IfcSolidModel
/// IfcClosedShell
/// 
/// HISTORY  New select type in IFC2x4.
typedef IfcUtil::IfcBaseClass IfcSolidOrShell;
/// Definition from IAI: The
/// IfcSpaceBoundarySelect selects either an internal space
/// for internal or external space boundaries, or an external spatial
/// element for external space boundaries at the outer envelop of the
/// building.
/// SELECT
/// 
/// IfcSpace,
/// IfcExternalSpatialElement
/// 
/// HISTORY  New select type
/// in IFC2x4.
typedef IfcUtil::IfcBaseClass IfcSpaceBoundarySelect;
/// The IfcSpecularHighlightSelect defines the selectable types of value for specular highlight sharpness. 
/// 
/// NOTE: The two select types relate to the different ways to specifiy the sharpness (or shininess) of the specular part of the reflectance equation. It relates to the attributes: 
/// 
/// in ISO10303-46 the attribute specular_exponent is given 
///   in VRML97 the attribute shininess is given 
/// 
/// For each surface side style only one of the two methods is needed for calculating the specular part of the equation.
/// 
/// HISTORY: New type in IFC2x2.
typedef IfcUtil::IfcBaseClass IfcSpecularHighlightSelect;
/// Definition from IAI: This type definition shall be used to
///   distinguish between a reference to an instance either of
///   IfcStructuralItem or IfcBuildingElement. The
///   IfcStructuralActivityAssignmentSelect type is referenced by the entity
///   IfcRelConnectsStructuralActivity which defines the connection between
///   activities (IfcStructuralActivity) and the loaded element.  
/// 
/// HISTORY: New type in Release IFC2x
///   Edition 2.
typedef IfcUtil::IfcBaseClass IfcStructuralActivityAssignmentSelect;
/// The style assignment select is a selection of two wasy of assigning presentation styles to an IfcStyledItem.
/// 
/// by directly assigning presentation styles as subtypes of IfcPresentationStyle
/// by assigning presentation stypes via an intermediate collection entity IfcPresentationStyleAssignment
/// 
/// NOTE Using IfcPresentationStyleAssignment is deprecated in IFC2x4 onwards
/// 
/// NOTE The select type has been introduced to provide an upward compatible improvement for assigning styles to a styled items.
/// 
/// HISTORY New select type in IFC2x4.
typedef IfcUtil::IfcBaseClass IfcStyleAssignmentSelect;
/// IfcSurfaceOrFaceSurface provides the option to either select a geometric surface (IfcSurface
/// and subtypes) within a geometric model, or a face with associated surface geometry and coordinates (IfcFaceSurface) within a topological model.
/// SELECT 
/// 
/// IfcSurface 
///   IfcFaceSurface
///   IfcFaceBasedSurfaceModel (a connected face set, representing a faceted surface as an approximation of a non planar, non rectangular bounded surface)
/// 
/// HISTORY  New select type in IFC2x3.
typedef IfcUtil::IfcBaseClass IfcSurfaceOrFaceSurface;
/// Definition from ISO/CD 10303-46:1992: The surface style element select is a selection of the different surface styles to use in the presentation of the side of a surface. 
/// 
/// The select type only includes the IfcSurfaceStyleRendering (which is the equivalent to surface_style_rendering) from the select type surface_style_element_select. In addition it has the IfcSurfaceStyleLighting, which holds the exact physically based lighting properties for lighting based calculation algorithms (as the opposite to the rendering based calculation), the IfcSurfaceStyleRefraction (for more advanced refraction indices) and IfcSurfaceStyleWithTextures (to allow for image textures applied to surfaces). In addition an IfcExternallyDefinedSurfaceStyle can be selected that points into an external material library. 
/// 
/// NOTE The IfcSurfaceLightingProperties are needed for exact lighting calculation, because physically based lighting calculation algorithms need exact physically based parameters. The factors in IfcSurfaceStyleRendering lack the physical base, they are intended for rendering calculations, but a lighting calculation based software cannot use these values.
/// 
/// NOTE: Corresponding ISO 10303 type: surface_style_element_select. Please refer to ISO/IS 10303-46:1994, p. 85 for the final definition of the formal standard.
/// 
/// HISTORY: New Select type in IFC2x2.
typedef IfcUtil::IfcBaseClass IfcSurfaceStyleElementSelect;
/// IfcTextFontSelect allows for either a predefined text font, a text font model or an externally defined text font to be used to describe the font of a text literal. The definition of the text font model is based on W3C TR Cascading Style Sheet Version 1, whereas the definition of predefined text font is based on ISO 10303.
/// 
/// NOTE  IfcTextFontSelect is an entity that had been adopted from ISO 10303, Industrial automation systems and integration—Product data representation and exchange, Part 46: Integrated generic resources: Visual presentation. Corresponding ISO 10303 name: font_select. Please refer to ISO/IS 10303-46:1994, p. 133 for the final definition of the formal standard.
/// 
/// HISTORY  New type in IFC2x2.
/// 
/// IFC2x3 CHANGE  The select type has been renamed from IfcFontSelect.
typedef IfcUtil::IfcBaseClass IfcTextFontSelect;
/// IfcTimeOrRatioSelect allows a value to be selected as being either a ratio or a time measure.
/// HISTORY New SELECT in IFC2x4
typedef IfcUtil::IfcBaseClass IfcTimeOrRatioSelect;
/// Definition from IAI: A measure of linear stiffness.  TRUE denotes infinite stiffness (rigidity).  FALSE denotes no stiffness (a release).  A numeric value denotes finite linear-elastic stiffness.
/// 
/// HISTORY: New type in IFC 2x4.
typedef IfcUtil::IfcBaseClass IfcTranslationalStiffnessSelect;
/// Definition from ISO/CD 10303-42:1992: This select type identifies the two possible ways of trimming a parametric curve; by a Cartesian point on the curve, or by a REAL number defining a parameter value within the parametric range of the curve. 
/// 
/// NOTE Corresponding ISO 10303 type: trimming_select, please refer to ISO/IS 10303-42:1994, p. 20 for the final definition of the formal standard.
/// 
/// HISTORY New Type in IFC Release 1.0
typedef IfcUtil::IfcBaseClass IfcTrimmingSelect;
/// Definition from ISO/CD 10303-41:1992: A unit is a physical quantity, with a value of one, which is used as a standard in terms of which other quantities are expressed.
/// 
/// NOTE: Select item IfcMonetaryUnit is an addition to ISO 10303-41.
/// 
/// NOTE: Corresponding ISO 10303 name: unit, please refer to ISO/IS 10303-41 for the final definition of the formal standard.
/// 
/// SELECT 
/// 
/// IfcNamedUnit: A unit which is identified by a name.
/// IfcDerivedUnit: A unit which is derived from an expression of units. 
/// IfcMonetaryUnit: A unit for defining currencies. 
/// 
/// HISTORY: New type in IFC Release 1.5.1.
typedef IfcUtil::IfcBaseClass IfcUnit;
/// IfcValue is a select type for selecting between more specialised select types IfcSimpleValue,
/// IfcMeasureValue and IfcDerivedMeasureValue.
/// 
/// SELECT 
/// 
/// IfcSimpleValue A select type for basic defined types of simple data type. 
///   IfcMeasureValue A select type for basic measure types of ISO 10303-41. 
///   IfcDerivedMeasureValue A select type for derived measure types.
/// 
/// HISTORY New type in IFC Release 2x.
typedef IfcUtil::IfcBaseClass IfcValue;
/// Definition from ISO/CD 10303-42:1992: This type is used to
///   identify the types of entity which can participate in vector computations. 
/// 
/// NOTE Corresponding STEP type:
///   vector_or_direction, please refer to ISO/IS 10303-42:1994, p. 20 for the final
///   definition of the formal standard.  
///   HISTORY New Type in IFC Release
///   1.5
typedef IfcUtil::IfcBaseClass IfcVectorOrDirection;
/// Definition from IAI: A measure of warping stiffness.  TRUE denotes infinite stiffness (rigidity).  FALSE denotes no stiffness (a release).  A numeric value denotes finite linear-elastic stiffness.
/// 
/// HISTORY: New type in IFC 2x4.
typedef IfcUtil::IfcBaseClass IfcWarpingStiffnessSelect;
namespace IfcActionRequestTypeEnum {
/// IfcActionRequestTypeEnum defines the types of sources through which a request can be made. 
///   HISTORY: New Enumeration in IFC2x4. 
///   Enumeration: 
/// 
/// EMAIL: Request was made through email. 
/// FAX: Request was made through facsimile. 
/// PHONE: Request was made verbally over a telephone. 
/// POST: Request was made through postal mail. 
/// VERBAL: Request was made verbally in person.  
/// USERDEFINED: User-defined type. 
/// NOTDEFINED: Undefined type.
typedef enum {IfcActionRequestType_EMAIL, IfcActionRequestType_FAX, IfcActionRequestType_PHONE, IfcActionRequestType_POST, IfcActionRequestType_VERBAL, IfcActionRequestType_USERDEFINED, IfcActionRequestType_NOTDEFINED} IfcActionRequestTypeEnum;
IFC_PARSE_API const char* ToString(IfcActionRequestTypeEnum v);
IFC_PARSE_API IfcActionRequestTypeEnum FromString(const std::string& s);
}
namespace IfcActionSourceTypeEnum {
/// Definition from IAI:This enumeration type contains possible
///   action sources. 
/// 
/// HISTORY: New type in Release IFC2x
///   Edition 2.
typedef enum {IfcActionSourceType_DEAD_LOAD_G, IfcActionSourceType_COMPLETION_G1, IfcActionSourceType_LIVE_LOAD_Q, IfcActionSourceType_SNOW_S, IfcActionSourceType_WIND_W, IfcActionSourceType_PRESTRESSING_P, IfcActionSourceType_SETTLEMENT_U, IfcActionSourceType_TEMPERATURE_T, IfcActionSourceType_EARTHQUAKE_E, IfcActionSourceType_FIRE, IfcActionSourceType_IMPULSE, IfcActionSourceType_IMPACT, IfcActionSourceType_TRANSPORT, IfcActionSourceType_ERECTION, IfcActionSourceType_PROPPING, IfcActionSourceType_SYSTEM_IMPERFECTION, IfcActionSourceType_SHRINKAGE, IfcActionSourceType_CREEP, IfcActionSourceType_LACK_OF_FIT, IfcActionSourceType_BUOYANCY, IfcActionSourceType_ICE, IfcActionSourceType_CURRENT, IfcActionSourceType_WAVE, IfcActionSourceType_RAIN, IfcActionSourceType_BRAKES, IfcActionSourceType_USERDEFINED, IfcActionSourceType_NOTDEFINED} IfcActionSourceTypeEnum;
IFC_PARSE_API const char* ToString(IfcActionSourceTypeEnum v);
IFC_PARSE_API IfcActionSourceTypeEnum FromString(const std::string& s);
}
namespace IfcActionTypeEnum {
/// Definition from IAI: This enumeration type is used to distinguish
///   between possible action types at a high level. It can be used for an automated
///   definition of load combinations and for dimensioning. The contained items and
///   their acronyms are adopted from the Eurocode standard. 
/// 
/// HISTORY: New type in Release IFC2x
///   Edition 2.
typedef enum {IfcActionType_PERMANENT_G, IfcActionType_VARIABLE_Q, IfcActionType_EXTRAORDINARY_A, IfcActionType_USERDEFINED, IfcActionType_NOTDEFINED} IfcActionTypeEnum;
IFC_PARSE_API const char* ToString(IfcActionTypeEnum v);
IFC_PARSE_API IfcActionTypeEnum FromString(const std::string& s);
}
namespace IfcActuatorTypeEnum {
/// The IfcActuatorTypeEnum defines the range of different types of actuator that can be specified. 
/// 
/// HISTORY: New type in IFC
///   R2.0  
///   Enumeration 
/// 
/// ELECTRICACTUATOR: A device that electrically actuates a control element.  
/// PNEUMATICACTUATOR<: A device that pneumatically actuates a control element  
/// HYDRAULICACTUATOR: A device that electrically actuates a control element.  
/// HANDOPERATEDACTUATOR: A device that manually actuates a control element. 
/// THERMOSTATICACTUATOR: A device that thermostatically actuates a control element. 
/// USERDEFINED: User-defined type. 
/// NOTDEFINED: Undefined type. 
/// 
/// See property set of actuator common attributes for specification of
///   properties for hand operated actuators.
typedef enum {IfcActuatorType_ELECTRICACTUATOR, IfcActuatorType_HANDOPERATEDACTUATOR, IfcActuatorType_HYDRAULICACTUATOR, IfcActuatorType_PNEUMATICACTUATOR, IfcActuatorType_THERMOSTATICACTUATOR, IfcActuatorType_USERDEFINED, IfcActuatorType_NOTDEFINED} IfcActuatorTypeEnum;
IFC_PARSE_API const char* ToString(IfcActuatorTypeEnum v);
IFC_PARSE_API IfcActuatorTypeEnum FromString(const std::string& s);
}
namespace IfcAddressTypeEnum {
/// Definition from IAI: Identifies the logical location of the address.
/// 
/// HISTORY New type in IFC Release 2x.
/// 
/// ENUMERATION 
/// 
/// OFFICE An office address. 
///   SITE A site address.
///   HOME A home address.
///   DISTRIBUTIONPOINT A postal distribution point address.
///   USERDEFINED A user defined address type to be provided.
typedef enum {IfcAddressType_OFFICE, IfcAddressType_SITE, IfcAddressType_HOME, IfcAddressType_DISTRIBUTIONPOINT, IfcAddressType_USERDEFINED} IfcAddressTypeEnum;
IFC_PARSE_API const char* ToString(IfcAddressTypeEnum v);
IFC_PARSE_API IfcAddressTypeEnum FromString(const std::string& s);
}
namespace IfcAirTerminalBoxTypeEnum {
/// This enumeration identifies different types of air terminal boxes.   
/// 
/// Valid enumerations are:
/// 
/// CONSTANTFLOW:  Terminal box does not include a means to reset the volume automatically to an outside signal such as thermostat.
///   VARIABLEFLOWPRESSUREDEPENDANT:  terminal box includes a means to reset the volume automatically to a different control point in response to an outside signal such as thermostat: air-flow rate depends on supply pressure.
///   VARIABLEFLOWPRESSUREINDEPENDANT:  terminal box includes a means to reset the volume automatically to a different control point in response to an outside signal such as thermostat: air-flow rate is independant of supply pressure.
///   USERDEFINED:				  User-defined terminal box.
///   NOTDEFINED:					  Undefined terminal box.
/// 
/// HISTORY: New enumeration in IFC R2.0
typedef enum {IfcAirTerminalBoxType_CONSTANTFLOW, IfcAirTerminalBoxType_VARIABLEFLOWPRESSUREDEPENDANT, IfcAirTerminalBoxType_VARIABLEFLOWPRESSUREINDEPENDANT, IfcAirTerminalBoxType_USERDEFINED, IfcAirTerminalBoxType_NOTDEFINED} IfcAirTerminalBoxTypeEnum;
IFC_PARSE_API const char* ToString(IfcAirTerminalBoxTypeEnum v);
IFC_PARSE_API IfcAirTerminalBoxTypeEnum FromString(const std::string& s);
}
namespace IfcAirTerminalTypeEnum {
/// Enumeration defining the functional types of air terminals. 
///   The IfcAirTerminalTypeEnum contains the following:
/// 
/// GRILLE: A covering for any area through which air passes.
///   REGISTER: A grille typically equipped with a damper or control valve.
///   DIFFUSER: An outlet discharging supply air in various directions and planes.
///   LOUVRE: A rectilinear louvre.
///   USERDEFINED: User-defined air terminal type.
///   NOTDEFINED:  Undefined air terminal type.
/// 
/// NOTE: Architectural louvres within doors or windows are defined by IfcPermeableCoveringProperties.
/// 
/// HISTORY: New enumeration in IFC R2x2.  Modified in IFC R2x4 to add LOUVRE and remove EYEBALL, IRIS, LINEARGRILLE, LINEARDIFFUSER
typedef enum {IfcAirTerminalType_DIFFUSER, IfcAirTerminalType_GRILLE, IfcAirTerminalType_LOUVRE, IfcAirTerminalType_REGISTER, IfcAirTerminalType_USERDEFINED, IfcAirTerminalType_NOTDEFINED} IfcAirTerminalTypeEnum;
IFC_PARSE_API const char* ToString(IfcAirTerminalTypeEnum v);
IFC_PARSE_API IfcAirTerminalTypeEnum FromString(const std::string& s);
}
namespace IfcAirToAirHeatRecoveryTypeEnum {
/// Defines general types of pumps.
///   The IfcPumpTypeEnum contains the following:
/// 
/// FIXEDPLATECOUNTERFLOWEXCHANGER: Heat exchanger with moving parts and alternate layers of plates, separated and sealed from the exhaust and supply air stream passages with primary air enters at secondary air outlet location and exits at secondary air inlet location.
///   FIXEDPLATECROSSFLOWEXCHANGER: Heat exchanger with moving parts and alternate layers of plates, separated and sealed from the exhaust and supply air stream passages with secondary air flow in the direction perpendicular to primary air flow.
///   FIXEDPLATEPARALLELFLOWEXCHANGER: Heat exchanger with moving parts and alternate layers of plates, separated and sealed from the exhaust and supply air stream passages with primary air enters at secondary air inlet location and exits at secondary air outlet location.
///   ROTARYWHEEL: A heat wheel with a revolving cylinder filled with an air-permeable medium having a large internal surface area.
///   RUNAROUNDCOILLOOP: A typical coil energy recovery loop places extended surface, finned tube water coils in the supply and exhaust airstreams of a building.
///   HEATPIPE: A passive energy recovery device with a heat pipe divided into evaporator and condenser sections.
///   TWINTOWERENTHALPYRECOVERYLOOPS: An air-to-liquid, liquid-to-air enthalpy recovery system with a sorbent liquid circulates continuously between supply and exhaust airstreams, alternately contacting both airstreams directly in contactor towers.
///   THERMOSIPHONSEALEDTUBEHEATEXCHANGERS: Sealed systems that consist of an evaporator, a condenser, interconnecting piping, and an intermediate working fluid that is present in both liquid and vapor phases where the evaporator and the condenser are usually at opposite ends of a bundle of straight, individual thermosiphon tubes and the exhaust and supply ducts are adjacent to each other.
///   THERMOSIPHONCOILTYPEHEATEXCHANGERS: Sealed systems that consist of an evaporator, a condenser, interconnecting piping, and an intermediate working fluid that is present in both liquid and vapor phases where the evaporator and condensor coils are installed independently in the ducts and are interconnected by the working fluid piping.
///   USERDEFINED: User-defined air to air heat recovery type.
///   NOTDEFINED:  Undefined air to air heat recovery type.
/// 
/// HISTORY: New enumeration in IFC R2x.
typedef enum {IfcAirToAirHeatRecoveryType_FIXEDPLATECOUNTERFLOWEXCHANGER, IfcAirToAirHeatRecoveryType_FIXEDPLATECROSSFLOWEXCHANGER, IfcAirToAirHeatRecoveryType_FIXEDPLATEPARALLELFLOWEXCHANGER, IfcAirToAirHeatRecoveryType_ROTARYWHEEL, IfcAirToAirHeatRecoveryType_RUNAROUNDCOILLOOP, IfcAirToAirHeatRecoveryType_HEATPIPE, IfcAirToAirHeatRecoveryType_TWINTOWERENTHALPYRECOVERYLOOPS, IfcAirToAirHeatRecoveryType_THERMOSIPHONSEALEDTUBEHEATEXCHANGERS, IfcAirToAirHeatRecoveryType_THERMOSIPHONCOILTYPEHEATEXCHANGERS, IfcAirToAirHeatRecoveryType_USERDEFINED, IfcAirToAirHeatRecoveryType_NOTDEFINED} IfcAirToAirHeatRecoveryTypeEnum;
IFC_PARSE_API const char* ToString(IfcAirToAirHeatRecoveryTypeEnum v);
IFC_PARSE_API IfcAirToAirHeatRecoveryTypeEnum FromString(const std::string& s);
}
namespace IfcAlarmTypeEnum {
/// The IfcAlarmTypeEnum defines the range of different types of alarm that can be specified. 
/// 
/// HISTORY: New type in IFC 2x2
/// 
/// Enumeration 
/// 
/// BELL: An audible alarm. 
/// BREAKGLASSBUTTON: An alarm activation mechanism in which a protective glass has to be broken to enable a button to be pressed. 
/// LIGHT: A visual alarm. 
/// MANUALPULLBOX: An alarm activation mechanism in which activation is achieved by a pulling action. 
/// SIREN: An audible alarm. 
/// WHISTLE: An audible alarm.  
/// USERDEFINED: User-defined type. 
/// NOTDEFINED: Undefined type.
typedef enum {IfcAlarmType_BELL, IfcAlarmType_BREAKGLASSBUTTON, IfcAlarmType_LIGHT, IfcAlarmType_MANUALPULLBOX, IfcAlarmType_SIREN, IfcAlarmType_WHISTLE, IfcAlarmType_USERDEFINED, IfcAlarmType_NOTDEFINED} IfcAlarmTypeEnum;
IFC_PARSE_API const char* ToString(IfcAlarmTypeEnum v);
IFC_PARSE_API IfcAlarmTypeEnum FromString(const std::string& s);
}
namespace IfcAnalysisModelTypeEnum {
/// Definition from IAI: This type definition is used to distinguish
///   between different types of structural analysis models. The analysis models are
///   differentiated by their dimensionality. 
/// 
/// HISTORY: New type in Release IFC2x
///   Edition 2.
typedef enum {IfcAnalysisModelType_IN_PLANE_LOADING_2D, IfcAnalysisModelType_OUT_PLANE_LOADING_2D, IfcAnalysisModelType_LOADING_3D, IfcAnalysisModelType_USERDEFINED, IfcAnalysisModelType_NOTDEFINED} IfcAnalysisModelTypeEnum;
IFC_PARSE_API const char* ToString(IfcAnalysisModelTypeEnum v);
IFC_PARSE_API IfcAnalysisModelTypeEnum FromString(const std::string& s);
}
namespace IfcAnalysisTheoryTypeEnum {
/// Definition from IAI: This type definition is used to distinguish
///   between different types of structural analysis methods, i.e. first order
///   theory, second order theory (small deformations), third order theory (large
///   deformations) and the full nonlinear theory (geometric nonlinearity together with other nonlinearities, e.g. plasticity). 
/// 
/// HISTORY: New type in Release IFC2x
///   Edition 2.
typedef enum {IfcAnalysisTheoryType_FIRST_ORDER_THEORY, IfcAnalysisTheoryType_SECOND_ORDER_THEORY, IfcAnalysisTheoryType_THIRD_ORDER_THEORY, IfcAnalysisTheoryType_FULL_NONLINEAR_THEORY, IfcAnalysisTheoryType_USERDEFINED, IfcAnalysisTheoryType_NOTDEFINED} IfcAnalysisTheoryTypeEnum;
IFC_PARSE_API const char* ToString(IfcAnalysisTheoryTypeEnum v);
IFC_PARSE_API IfcAnalysisTheoryTypeEnum FromString(const std::string& s);
}
namespace IfcArithmeticOperatorEnum {
/// IfcArithmeticOperatorEnum specifies the form of arithmetical operation implied by the relationship. 
/// Enumeration 
/// 
/// ADD 
///   DIVIDE 
///   MULTIPLY 
///   SUBTRACT 
/// 
/// HISTORY: New enumeration in IFC2x2.
/// 
/// Use definitions 
/// There can be only one arithmetic operator for each applied value relationship. This is to enforce arithmetic consistency. Given this consistency, the cardinality of the IfcAppliedValueRelationship.Components attribute is a set of one to many applied values that are components of an applied value.
typedef enum {IfcArithmeticOperator_ADD, IfcArithmeticOperator_DIVIDE, IfcArithmeticOperator_MULTIPLY, IfcArithmeticOperator_SUBTRACT} IfcArithmeticOperatorEnum;
IFC_PARSE_API const char* ToString(IfcArithmeticOperatorEnum v);
IFC_PARSE_API IfcArithmeticOperatorEnum FromString(const std::string& s);
}
namespace IfcAssemblyPlaceEnum {
/// Definition from IAI: Enumeration defining where the
///   assembly is intended to take place, either in a factory or
///   on the building site.
/// 
/// HISTORY New enumeration in
///   Release IFC2x Edition 2.
/// 
/// Enumeration
/// 
/// SITE - this assembly is assembled at site
/// 
/// FACTORY - this assembly is assembled in a factory
typedef enum {IfcAssemblyPlace_SITE, IfcAssemblyPlace_FACTORY, IfcAssemblyPlace_NOTDEFINED} IfcAssemblyPlaceEnum;
IFC_PARSE_API const char* ToString(IfcAssemblyPlaceEnum v);
IFC_PARSE_API IfcAssemblyPlaceEnum FromString(const std::string& s);
}
namespace IfcAudioVisualApplianceTypeEnum {
/// Defines the range of different types of audio-video devices that can be specified. 
/// HISTORY: New enumeration in IFC2x4 
/// 
/// AMPLIFIER: A device that receives an audio signal and amplifies it to play through speakers. 
/// CAMERA: A device that records images, either as a still photograph or as moving images known as videos or movies.  Note that a camera may operate with light from the visible spectrum or from other parts of the electromagnetic spectrum such as infrared or ultraviolet. 
/// DISPLAY: An electronic device that represents information in visual form such as a flat-panel display or television. 
/// MICROPHONE: An acoustic-to-electric transducer or sensor that converts sound into an electrical signal.  Microphones types in use include electromagnetic induction (dynamic microphones), capacitance change (condenser microphones) or piezoelectric generation to produce the signal from mechanical vibration. 
/// PLAYER: A device that plays audio and/or video content directly or to another device, having fixed or removable storage media. 
/// PROJECTOR: An apparatus for projecting a picture on a screen. Whether the device is an overhead, slide projector, or a film projector, it is usually referred to as simply a projector. 
/// RECEIVER: A device that receives audio and/or video signals, switches sources, and amplifies signals to play through speakers. 
/// SPEAKER: A loudspeaker, speaker, or speaker system is an electroacoustical transducer that converts an electrical signal to sound. 
/// SWITCHER: A device that receives audio and/or video signals, switches sources, and transmits signals to downstream devices. 
/// TELEPHONE: A telecommunications device that is used to transmit and receive sound, and optionally video. 
/// TUNER: An electronic receiver that detects, demodulates, and amplifies transmitted signals.
typedef enum {IfcAudioVisualApplianceType_AMPLIFIER, IfcAudioVisualApplianceType_CAMERA, IfcAudioVisualApplianceType_DISPLAY, IfcAudioVisualApplianceType_MICROPHONE, IfcAudioVisualApplianceType_PLAYER, IfcAudioVisualApplianceType_PROJECTOR, IfcAudioVisualApplianceType_RECEIVER, IfcAudioVisualApplianceType_SPEAKER, IfcAudioVisualApplianceType_SWITCHER, IfcAudioVisualApplianceType_TELEPHONE, IfcAudioVisualApplianceType_TUNER, IfcAudioVisualApplianceType_USERDEFINED, IfcAudioVisualApplianceType_NOTDEFINED} IfcAudioVisualApplianceTypeEnum;
IFC_PARSE_API const char* ToString(IfcAudioVisualApplianceTypeEnum v);
IFC_PARSE_API IfcAudioVisualApplianceTypeEnum FromString(const std::string& s);
}
namespace IfcBSplineCurveForm {
/// Definition from ISO/CD 10303-42:1992: This type is used to indicate that the B-spline curve represents a part of a curve of some specific form.
/// 
/// Enumeration
/// 
/// polyline form: A connected sequence of line segments represented by degree 1 B-spline basis functions.
/// circular arc: An arc of a circle, or a complete circle represented by a B-spline curve.
/// elliptic arc: An arc of an ellipse, or a complete ellipse, represented by a B-spline curve.
/// parabolic arc: An arc of finite length of a parabola represented by a B-spline curve.
/// hyperbolic arc: An arc of finite length of one branch of a hyperbola represented by a B-spline curve.
/// unspecified: A B-spline curve for which no particular form is specified.
/// 
/// NOTE  Corresponding ISO 10303 type: b_spline_curve_form. Please refer to ISO/IS 10303-42:1994, p. 15 for the final definition of the formal standard.
/// 
/// HISTORY  New type in Release IFC2x2.
typedef enum {IfcBSplineCurveForm_POLYLINE_FORM, IfcBSplineCurveForm_CIRCULAR_ARC, IfcBSplineCurveForm_ELLIPTIC_ARC, IfcBSplineCurveForm_PARABOLIC_ARC, IfcBSplineCurveForm_HYPERBOLIC_ARC, IfcBSplineCurveForm_UNSPECIFIED} IfcBSplineCurveForm;
IFC_PARSE_API const char* ToString(IfcBSplineCurveForm v);
IFC_PARSE_API IfcBSplineCurveForm FromString(const std::string& s);
}
namespace IfcBSplineSurfaceForm {

typedef enum {IfcBSplineSurfaceForm_PLANE_SURF, IfcBSplineSurfaceForm_CYLINDRICAL_SURF, IfcBSplineSurfaceForm_CONICAL_SURF, IfcBSplineSurfaceForm_SPHERICAL_SURF, IfcBSplineSurfaceForm_TOROIDAL_SURF, IfcBSplineSurfaceForm_SURF_OF_REVOLUTION, IfcBSplineSurfaceForm_RULED_SURF, IfcBSplineSurfaceForm_GENERALISED_CONE, IfcBSplineSurfaceForm_QUADRIC_SURF, IfcBSplineSurfaceForm_SURF_OF_LINEAR_EXTRUSION, IfcBSplineSurfaceForm_UNSPECIFIED} IfcBSplineSurfaceForm;
IFC_PARSE_API const char* ToString(IfcBSplineSurfaceForm v);
IFC_PARSE_API IfcBSplineSurfaceForm FromString(const std::string& s);
}
namespace IfcBeamTypeEnum {
/// Definition from IAI: This enumeration defines the
/// different types of linear elements an IfcBeamType object
/// can fulfill:
/// 
/// BEAM: A standard beam usually used horizontally.
/// JOIST: A beam used to support a floor or ceiling.
/// HOLLOWCORE: A wide often prestressed beam with a
/// hollow-core profile that usually serves as a slab component.
/// LINTEL: A beam or horizontal piece of material over an
/// opening (e.g. door, window).
/// SPANDREL: A tall beam placed on the facade of a
/// building. One tall side is usually finished to provide the
/// exterior of the building. Can be used to support joists or slab
/// elements on its interior side.
/// 
/// NOTE  They are also referred to as "spandrel
/// panels", which are parts of a facade and sometimes have
/// supporting consoles for floor slabs
/// integrated.
/// 
/// T_BEAM: A beam that forms part of a slab construction
/// and acts together with the slab which its carries. Such beams are
/// often of T-shape (therefore the English name), but may have other
/// shapes as well, e.g. an L-Shape or an Inverted-T-Shape.
/// 
/// NOTE  In order to distinguish beams by shape,
/// the assigned IfcProfileDef subtypes provide the shape type
/// and, if using a subtype of
/// IfcParameterizedProfileDef, also the shape
/// parameterization.
/// 
/// USERDEFINED: User-defined linear beam element.
/// NOTDEFINED: Undefined linear beam element
/// 
/// HISTORY  New Enumeration
/// in Release IFC2x Edition 2.
/// IFC2x4 CHANGE  The enumerators
/// HOLLOWCORE and SPANDREL have been
/// added.
typedef enum {IfcBeamType_BEAM, IfcBeamType_JOIST, IfcBeamType_HOLLOWCORE, IfcBeamType_LINTEL, IfcBeamType_SPANDREL, IfcBeamType_T_BEAM, IfcBeamType_USERDEFINED, IfcBeamType_NOTDEFINED} IfcBeamTypeEnum;
IFC_PARSE_API const char* ToString(IfcBeamTypeEnum v);
IFC_PARSE_API IfcBeamTypeEnum FromString(const std::string& s);
}
namespace IfcBenchmarkEnum {
/// IfcBenchmarkEnum is an enumeration used to identify the logical comparators that can be applied in conjunction with constraint values. 
/// 
/// HISTORY: New type in IFC Release 2.0
/// 
/// IFC2x4 CHANGE: Extended to include comparators for item-set and set-item comparisons: INCLUDES, NOTINCLUDES, INCLUDEDIN and NOTINCLUDEDIN, to test if an individual item is a member of a given aggregation, or if an aggregation has a given individual item as a member.
/// 
/// Enumeration 
/// 
/// Value 
///   Definition 
/// 
/// GREATERTHAN 
///   Identifies that a value must be greater than that set by the constraint. 
/// 
/// GREATERTHANOREQUALTO 
///   Identifies that a value must be either greater than or equal to that set by the constraint. 
/// 
/// LESSTHAN 
///   Identifies that a value must be less than that set by the constraint. 
/// 
/// LESSTHANOREQUALTO 
///   Identifies that a value must be either less than or equal to that set by the constraint. 
/// 
/// EQUALTO 
///   Identifies that a value must be equal to that set by the constraint. 
/// 
/// NOTEQUALTO 
///   Identifies that a value must be not equal to that set by the constraint. 
/// 
/// INCLUDES 
///   Identifies that an aggregation (set, list or table) must include the value (individual item) set by the constraint. 
/// 
/// NOTINCLUDES 
///   Identifies that an aggregation (set, list or table) must not include (i.e must exclude) the value (individual item) set by the constraint. 
/// 
/// INCLUDEDIN 
///   Identifies that a value (individual item) must be included in the aggregation (set, list or table) set by the constraint. 
/// 
/// NOTINCLUDEDIN 
///   Identifies that a value (individual item) must not be included (i.e. must be excluded) in the aggregation (set, list or table) set by the constraint.
typedef enum {IfcBenchmark_GREATERTHAN, IfcBenchmark_GREATERTHANOREQUALTO, IfcBenchmark_LESSTHAN, IfcBenchmark_LESSTHANOREQUALTO, IfcBenchmark_EQUALTO, IfcBenchmark_NOTEQUALTO, IfcBenchmark_INCLUDES, IfcBenchmark_NOTINCLUDES, IfcBenchmark_INCLUDEDIN, IfcBenchmark_NOTINCLUDEDIN} IfcBenchmarkEnum;
IFC_PARSE_API const char* ToString(IfcBenchmarkEnum v);
IFC_PARSE_API IfcBenchmarkEnum FromString(const std::string& s);
}
namespace IfcBoilerTypeEnum {
/// Enumeration defining the typical types of boilers.
///   The IfcBoilerTypeEnum contains the following:
/// 
/// WATER: Water boiler.
///   STEAM: Steam boiler.
///   USERDEFINED: User-defined Boiler type.
///   NOTDEFINED:  Undefined Boiler type.
/// 
/// HISTORY: New enumeration in IFC R2x.
typedef enum {IfcBoilerType_WATER, IfcBoilerType_STEAM, IfcBoilerType_USERDEFINED, IfcBoilerType_NOTDEFINED} IfcBoilerTypeEnum;
IFC_PARSE_API const char* ToString(IfcBoilerTypeEnum v);
IFC_PARSE_API IfcBoilerTypeEnum FromString(const std::string& s);
}
namespace IfcBooleanOperator {
/// Definition from ISO/CD 10303-42:1992: This type defines the three Boolean operators used in the definition of CSG solids.
/// 
/// UNION: The operation of constructing the regularized set theoretic union of the volumes defined by two solids.
/// INTERSECTION: The operation of constructing the regularised set theoretic intersection of the volumes defined by two solids.
/// DIFFERENCE: The operation of constructing the regularized set theoretic intersection of the volumes defined by two solids.
/// 
/// NOTE Corresponding STEP type: boolean_operator, please refer to ISO/IS 10303-42:1994, p.167 for the final definition of the formal standard.
/// 
/// HISTORY New Type in IFC Release 1.5.1.
typedef enum {IfcBooleanOperator_UNION, IfcBooleanOperator_INTERSECTION, IfcBooleanOperator_DIFFERENCE} IfcBooleanOperator;
IFC_PARSE_API const char* ToString(IfcBooleanOperator v);
IFC_PARSE_API IfcBooleanOperator FromString(const std::string& s);
}
namespace IfcBuildingElementPartTypeEnum {
/// Definition from IAI: This enumeration defines the different types of building element parts:
/// 
/// INSULATION: The part provides thermal insulation, for example as insulation layer between wall panels in sandwich walls or as infill in stud walls.
/// PRECASTPANEL: The part is a precast panel, usually as an internal or external layer in a sandwich wall panel.
/// USERDEFINED: User-defined accessory
/// NOTDEFINED: Undefined accessory
/// 
/// HISTORY  New Enumeration in IFC 2x4.
typedef enum {IfcBuildingElementPartType_INSULATION, IfcBuildingElementPartType_PRECASTPANEL, IfcBuildingElementPartType_USERDEFINED, IfcBuildingElementPartType_NOTDEFINED} IfcBuildingElementPartTypeEnum;
IFC_PARSE_API const char* ToString(IfcBuildingElementPartTypeEnum v);
IFC_PARSE_API IfcBuildingElementPartTypeEnum FromString(const std::string& s);
}
namespace IfcBuildingElementProxyTypeEnum {
/// Definition from IAI: This enumeration defines the
///   available generic types for IfcBuildingElementProxyType.
/// 
/// HISTORY  New enumeration
///   in Release IFC2x Edition 3.
/// 
/// Enumeration
/// 
/// USERDEFINED
/// 
/// NOTDEFINED
typedef enum {IfcBuildingElementProxyType_COMPLEX, IfcBuildingElementProxyType_ELEMENT, IfcBuildingElementProxyType_PARTIAL, IfcBuildingElementProxyType_PROVISIONFORVOID, IfcBuildingElementProxyType_PROVISIONFORSPACE, IfcBuildingElementProxyType_USERDEFINED, IfcBuildingElementProxyType_NOTDEFINED} IfcBuildingElementProxyTypeEnum;
IFC_PARSE_API const char* ToString(IfcBuildingElementProxyTypeEnum v);
IFC_PARSE_API IfcBuildingElementProxyTypeEnum FromString(const std::string& s);
}
namespace IfcBuildingSystemTypeEnum {
/// Definition from IAI: This enumeration identifies
/// different types of distribution systems.
/// HISTORY New enumeration
/// in IFC2x4.
/// Valid enumerations for building systems include:
/// 
/// FENESTRATION: System of doors, windows, and other
/// fillings in opening in a building envelop that are designed to
/// permit the passage of air or light,
/// SHADING: System of shading elements (external or
/// internal) that permits the limitation or control of impact of
/// natural sun light,
/// TRANSPORT: System of all transport elements in a
/// building that enables the transport of people or goods.
typedef enum {IfcBuildingSystemType_FENESTRATION, IfcBuildingSystemType_FOUNDATION, IfcBuildingSystemType_LOADBEARING, IfcBuildingSystemType_OUTERSHELL, IfcBuildingSystemType_SHADING, IfcBuildingSystemType_TRANSPORT, IfcBuildingSystemType_USERDEFINED, IfcBuildingSystemType_NOTDEFINED} IfcBuildingSystemTypeEnum;
IFC_PARSE_API const char* ToString(IfcBuildingSystemTypeEnum v);
IFC_PARSE_API IfcBuildingSystemTypeEnum FromString(const std::string& s);
}
namespace IfcBurnerTypeEnum {
/// Enumeration defining the functional type of burner.
///   The IfcBurnerTypeEnum contains the following:
/// 
/// USERDEFINED: User-defined burner type.
///   NOTDEFINED:  Undefined burner type.
/// 
/// HISTORY: New enumeration in IFC R2x4.
typedef enum {IfcBurnerType_USERDEFINED, IfcBurnerType_NOTDEFINED} IfcBurnerTypeEnum;
IFC_PARSE_API const char* ToString(IfcBurnerTypeEnum v);
IFC_PARSE_API IfcBurnerTypeEnum FromString(const std::string& s);
}
namespace IfcCableCarrierFittingTypeEnum {
/// The IfcCableCarrierFittingTypeEnum defines the range of different types of cable carrier fitting that can be specified. 
///   HISTORY: New type in IFC 2x2  
///   Enumeration 
/// 
/// BEND: A fitting that changes the route of the cable carrier. 
/// CROSS: A fitting at which two branches are taken from the main route of the cable carrier simultaneously. 
/// REDUCER: A fitting that changes the physical size of the main route of the cable carrier. 
/// TEE: A fitting at which a branch is taken from the main route of the cable carrier. 
/// USERDEFINED: User-defined type. 
/// NOTDEFINED: Undefined type.
typedef enum {IfcCableCarrierFittingType_BEND, IfcCableCarrierFittingType_CROSS, IfcCableCarrierFittingType_REDUCER, IfcCableCarrierFittingType_TEE, IfcCableCarrierFittingType_USERDEFINED, IfcCableCarrierFittingType_NOTDEFINED} IfcCableCarrierFittingTypeEnum;
IFC_PARSE_API const char* ToString(IfcCableCarrierFittingTypeEnum v);
IFC_PARSE_API IfcCableCarrierFittingTypeEnum FromString(const std::string& s);
}
namespace IfcCableCarrierSegmentTypeEnum {
/// The IfcCableCarrierSegmentTypeEnum defines the range of different types of cable carrier segment that can be specified. 
///   HISTORY: New type in IFC 2x2  
///   Enumeration 
/// 
/// CABLELADDERSEGMENT: An open carrier segment on which cables are carried on a ladder structure.
/// CABLETRAYSEGMENT: A (typically) open carrier segment onto which cables are laid.
/// CABLETRUNKINGSEGMENT: An enclosed carrier segment with one or more compartments into which cables are placed.
/// CONDUITSEGMENT: An enclosed tubular carrier segment through which cables are pulled.
/// USERDEFINED: User-defined type.  
/// NOTDEFINED: Undefined type.
typedef enum {IfcCableCarrierSegmentType_CABLELADDERSEGMENT, IfcCableCarrierSegmentType_CABLETRAYSEGMENT, IfcCableCarrierSegmentType_CABLETRUNKINGSEGMENT, IfcCableCarrierSegmentType_CONDUITSEGMENT, IfcCableCarrierSegmentType_USERDEFINED, IfcCableCarrierSegmentType_NOTDEFINED} IfcCableCarrierSegmentTypeEnum;
IFC_PARSE_API const char* ToString(IfcCableCarrierSegmentTypeEnum v);
IFC_PARSE_API IfcCableCarrierSegmentTypeEnum FromString(const std::string& s);
}
namespace IfcCableFittingTypeEnum {
/// The IfcCableFittingTypeEnum defines the range of different types of cable fitting that can be specified. 
///   HISTORY: New type in IFC 2x4  
///   Enumeration 
/// 
/// CONNECTOR: A fitting that joins two cable segments of the same connector type (though potentially different gender). 
/// ENTRY: A fitting that begins a cable segment at a non-electrical element such as a grounding clamp attached to a pipe. 
/// EXIT: A fitting that ends a cable segment at a non-electrical element such as a grounding clamp attached to a pipe or to the ground.  
/// JUNCTION: A fitting that joins three or more segments of arbitrary connector types for signal splitting or multiplexing.  
/// TRANSITION: A fitting that joins two cable segments of different connector types.  
/// USERDEFINED: User-defined type. 
/// NOTDEFINED: Undefined type.
typedef enum {IfcCableFittingType_CONNECTOR, IfcCableFittingType_ENTRY, IfcCableFittingType_EXIT, IfcCableFittingType_JUNCTION, IfcCableFittingType_TRANSITION, IfcCableFittingType_USERDEFINED, IfcCableFittingType_NOTDEFINED} IfcCableFittingTypeEnum;
IFC_PARSE_API const char* ToString(IfcCableFittingTypeEnum v);
IFC_PARSE_API IfcCableFittingTypeEnum FromString(const std::string& s);
}
namespace IfcCableSegmentTypeEnum {
/// The IfcCableSegmentTypeEnum defines the range of different types of cable segment that can be specified. 
/// 
/// HISTORY: New type in IFC
///   2x2. Core and busbar segment added in IFC 2x4.  
///   Enumeration 
/// 
/// BUSBARSEGMENT: Electrical conductor that makes a common connection between several electrical circuits. Properties of a busbar are the same as those of a cable segment and are captured by the cable segment property set. 
/// CABLESEGMENT: Cable with a specific purpose to lead electric current within a circuit or any other electric construction. Includes all types of electric cables, mainly several core segments or conductor segments wrapped together. 
/// CONDUCTORSEGMENT: A single linear element within a cable or an exposed wire (such as for grounding) with the specific purpose to lead electric current, data, or a telecommunications signal.  
/// CORESEGMENT: A self contained element of a  cable that comprises one or more conductors and sheathing.The core of one lead is normally single wired or multiwired which are intertwined.  
/// USERDEFINED: User-defined type.  
/// NOTDEFINED: Undefined type.
typedef enum {IfcCableSegmentType_BUSBARSEGMENT, IfcCableSegmentType_CABLESEGMENT, IfcCableSegmentType_CONDUCTORSEGMENT, IfcCableSegmentType_CORESEGMENT, IfcCableSegmentType_USERDEFINED, IfcCableSegmentType_NOTDEFINED} IfcCableSegmentTypeEnum;
IFC_PARSE_API const char* ToString(IfcCableSegmentTypeEnum v);
IFC_PARSE_API IfcCableSegmentTypeEnum FromString(const std::string& s);
}
namespace IfcChangeActionEnum {
/// IfcChangeActionEnum identifies the type of change that might have occurred to the object during the last session (for example, added, modified, deleted). This information is required in a partial model exchange scenario so that an application or model server will know how an object might have been affected by the previous application. Valid enumerations are:
/// 
/// NOCHANGE: Object has not been modified.
/// 
/// MODIFIED: A modification to the object has been made by the user and application defined by the LastModifyingUser and LastModifyingApplication respectively.
/// 
/// ADDED: The object has been created by the user and application defined by the OwningUser and OwningApplication respectively.
/// 
/// DELETED: The object has been deleted by the user and application defined by the LastModifyingUser and LastModifyingApplication respectively.
/// 
/// NOTDEFINED: The change action is not known or has not been defined.
/// 
/// Consider Application A will create an IFC dataset that it wants to publish to others for modification and have the ability to subsequently merge these changes back into the original model. Before publication, it may want to set the IfcChangeActionEnum to NOCHANGE to establish a baseline so that other application changes can be easily identified. Application B then receives this IFC dataset and adds a new object and sets IfcChangeActionEnum to ADDED with Application B defined as the OwningApplication. Application B then modifies an existing object and (re)defines the LastModifiedDate to the time of the modification, LastModifyingUser to the IfcPersonAndOrganization making the change, and sets the LastModifyingApplication to Application B. When Application A receives this modified dataset, it can determine which objects have been added and modified by Application B and either merge or reject these changes as necessary. Consequently, the intent is that an application only modifies the value of IfcChangeActionEnum when it does something to the object, with the further intent that a model server is responsible for clearing the IfcChangeActionEnum back to NOCHANGE when it is ready to be republished.
/// 
/// HISTORY: New enumeration in IFC R2.0. Modified in IFC2x4.
typedef enum {IfcChangeAction_NOCHANGE, IfcChangeAction_MODIFIED, IfcChangeAction_ADDED, IfcChangeAction_DELETED, IfcChangeAction_NOTDEFINED} IfcChangeActionEnum;
IFC_PARSE_API const char* ToString(IfcChangeActionEnum v);
IFC_PARSE_API IfcChangeActionEnum FromString(const std::string& s);
}
namespace IfcChillerTypeEnum {
/// Enumeration defining the typical types of Chillers classified by their method of heat rejection. 
///   The IfcChillerTypeEnum contains the following:
/// 
/// AIRCOOLED: Air cooled chiller.
///   WATERCOOLED: Water cooled chiller.
///   HEATRECOVERY: Heat recovery chiller.
///   USERDEFINED:	User-defined chiller type.
///   NOTDEFINED: Undefined chiller type.
/// 
/// HISTORY: New enumeration in IFC R2x.
typedef enum {IfcChillerType_AIRCOOLED, IfcChillerType_WATERCOOLED, IfcChillerType_HEATRECOVERY, IfcChillerType_USERDEFINED, IfcChillerType_NOTDEFINED} IfcChillerTypeEnum;
IFC_PARSE_API const char* ToString(IfcChillerTypeEnum v);
IFC_PARSE_API IfcChillerTypeEnum FromString(const std::string& s);
}
namespace IfcChimneyTypeEnum {
/// Definition from IAI: Enumeration defining the valid
///   types of chimneys that can be predefined using the
///   enumeration values.
/// 
/// HISTORY  New Enumeration in
///   Release IFC2x4
/// 
/// NOTE  Currently there are no specific enumerators
///   defined, the IfcChimneyTypeEnum has been added
///   for future extensions.
typedef enum {IfcChimneyType_USERDEFINED, IfcChimneyType_NOTDEFINED} IfcChimneyTypeEnum;
IFC_PARSE_API const char* ToString(IfcChimneyTypeEnum v);
IFC_PARSE_API IfcChimneyTypeEnum FromString(const std::string& s);
}
namespace IfcCoilTypeEnum {
/// Enumeration defining the typical types of coils.
/// 
/// The IfcCoilTypeEnum contains the following:
/// 
/// DXCOOLINGCOIL: Cooling coil using a refrigerant to cool the air stream directly.
/// 
/// WATERCOOLINGCOIL: Cooling coil using chilled water. HYDRONICCOIL supercedes this enumerator.
/// 
/// STEAMHEATINGCOIL: Heating coil using steam as heating source.
/// 
/// WATERHEATINGCOIL: Heating coil using hot water as a heating source. HYDRONICCOIL supercedes this enumerator.
/// 
/// ELECTRICHEATINGCOIL: Heating coil using electricity as a heating source.
/// 
/// GASHEATINGCOIL: Heating coil using gas as a heating source.
/// 
/// HYDRONICCOIL: Cooling or Heating coil that uses a hydronic fluid as a cooling or heating source.
///   USERDEFINED: User-defined coil type.
/// 
/// NOTDEFINED:  Undefined coil type.
/// 
/// HISTORY: New enumeration in IFC R2x.
typedef enum {IfcCoilType_DXCOOLINGCOIL, IfcCoilType_ELECTRICHEATINGCOIL, IfcCoilType_GASHEATINGCOIL, IfcCoilType_HYDRONICCOIL, IfcCoilType_STEAMHEATINGCOIL, IfcCoilType_WATERCOOLINGCOIL, IfcCoilType_WATERHEATINGCOIL, IfcCoilType_USERDEFINED, IfcCoilType_NOTDEFINED} IfcCoilTypeEnum;
IFC_PARSE_API const char* ToString(IfcCoilTypeEnum v);
IFC_PARSE_API IfcCoilTypeEnum FromString(const std::string& s);
}
namespace IfcColumnTypeEnum {
/// Definition from IAI: This enumeration defines the
/// different types of linear elements an IfcColumnType object
/// can fulfill:
/// 
/// COLUMN: A standard column element usually used
/// vertically.
/// USERDEFINED: User-defined linear element.
/// NOTDEFINED: Undefined linear element
/// 
/// NOTE: This enumeration has been mainly
/// introduced to allow further detailing of the type information in
/// future releases of IFC.
/// HISTORY New Enumeration
/// in Release IFC2x Edition 2.
typedef enum {IfcColumnType_COLUMN, IfcColumnType_PILASTER, IfcColumnType_USERDEFINED, IfcColumnType_NOTDEFINED} IfcColumnTypeEnum;
IFC_PARSE_API const char* ToString(IfcColumnTypeEnum v);
IFC_PARSE_API IfcColumnTypeEnum FromString(const std::string& s);
}
namespace IfcCommunicationsApplianceTypeEnum {
/// Defines the range of different types of communications appliance that can be specified. 
/// 
/// HISTORY: New enumeration in IFC2x4 
/// 
/// ANTENNA: A transducer designed to transmit or receive electromagnetic waves. 
/// COMPUTER: A desktop, laptop, PDA or other type of computer that can be moved from one place to another and connected to an electrical supply via a plugged outlet. 
/// FAX: A machine that has the primary function of transmitting a facsimile copy of printed matter using a telephone line. 
/// GATEWAY: A gateway connects multiple network segments with different protocols at all layers (layers 1-7) of the OSI model 
/// MODEM: A modem (from modulator-demodulator) is a device that modulates an analog carrier signal to encode digital information, and also demodulates such a carrier signal to decode the transmitted information 
/// NETWORKAPPLIANCE: A network appliance performs a dedicated function such as firewall protection, content filtering, load balancing, or equipment management. 
/// NETWORKBRIDGE: A network bridge connects multiple network segments at the data link layer (layer 2) of the OSI model, and the term layer 2 switch is very often used interchangeably with bridge 
/// NETWORKHUB: A network hub connects multiple network segments at the physical layer (layer 1) of the OSI model. 
/// PRINTER: A machine that has the primary function of printing text and/or graphics onto paper or other media. 
/// REPEATER: A repeater is an electronic device that receives a signal and retransmits it at a higher level and/or higher power, or onto the other side of an obstruction, so that the signal can cover longer distances without degradation. 
/// ROUTER: A router is a networking device whose software and hardware are usually tailored to the tasks of routing and forwarding information. For example, on the Internet, information is directed to various paths by routers. 
/// SCANNER: A machine that has the primary function of scanning the content of printed matter and converting it to digital format that can be stored in a computer.
typedef enum {IfcCommunicationsApplianceType_ANTENNA, IfcCommunicationsApplianceType_COMPUTER, IfcCommunicationsApplianceType_FAX, IfcCommunicationsApplianceType_GATEWAY, IfcCommunicationsApplianceType_MODEM, IfcCommunicationsApplianceType_NETWORKAPPLIANCE, IfcCommunicationsApplianceType_NETWORKBRIDGE, IfcCommunicationsApplianceType_NETWORKHUB, IfcCommunicationsApplianceType_PRINTER, IfcCommunicationsApplianceType_REPEATER, IfcCommunicationsApplianceType_ROUTER, IfcCommunicationsApplianceType_SCANNER, IfcCommunicationsApplianceType_USERDEFINED, IfcCommunicationsApplianceType_NOTDEFINED} IfcCommunicationsApplianceTypeEnum;
IFC_PARSE_API const char* ToString(IfcCommunicationsApplianceTypeEnum v);
IFC_PARSE_API IfcCommunicationsApplianceTypeEnum FromString(const std::string& s);
}
namespace IfcComplexPropertyTemplateTypeEnum {
/// This enumeration defines the subtype of instances of IfcComplexProperty or IfcPhysicalComplexQuantity that may be created and defined by an IfcComplexPropertyTemplate.
/// 
/// HISTORY New enumeration in IFC2x4.
/// 
/// Enumeration
/// 
/// P_COMPLEX: the properties defined by this IfcComplexPropertyTemplate are of type IfcComplexProperty.
/// Q_COMPLEX: the properties defined by this IfcComplexPropertyTemplate are of type IfcPhysicalComplexQuantity.
typedef enum {IfcComplexPropertyTemplateType_P_COMPLEX, IfcComplexPropertyTemplateType_Q_COMPLEX} IfcComplexPropertyTemplateTypeEnum;
IFC_PARSE_API const char* ToString(IfcComplexPropertyTemplateTypeEnum v);
IFC_PARSE_API IfcComplexPropertyTemplateTypeEnum FromString(const std::string& s);
}
namespace IfcCompressorTypeEnum {
/// Types of compressors.
///   The IfcCompressorTypeEnum contains the following:
/// 
/// DYNAMIC: The pressure of refrigerant vapor is increased by a continuous transfer of angular momentum from a rotating member to the vapor followed by conversion of this momentum into static pressure.
///   RECIPROCATING: Positive-displacement compressor using a piston driven by a connecting rod from a crankshaft.
///   ROTARY: Positive-displacement compressor using a roller or rotor device.
///   SCROLL: Positive-displacement compressor using two inter-fitting, spiral-shaped scroll members.
///   TROCHOIDAL: Positive-displacement compressor using a rolling motion of one circle outside or inside the circumference of a basic circle and produce either epitrochoids or hypotrochoids.
///   SINGLESTAGE: Positive-displacement reciprocating compressor where vapor is compressed in a single stage.
///   BOOSTER: Positive-displacement reciprocating compressor where pressure is increased by a booster.
///   OPENTYPE: Positive-displacement reciprocating compressor where the shaft extends through a seal in the crankcase for an external drive.
///   HERMETIC: Positive-displacement reciprocating compressor where the motor and compressor are contained within the same housing, with the motor shaft integral with the compressor crankshaft and the motor in contact with refrigerant.
///   SEMIHERMETIC: Positive-displacement reciprocating compressor where the hermetic compressors use bolted construction amenable to field repair.
///   WELDEDSHELLHERMETIC: Positive-displacement reciprocating compressor where the motor compressor is mounted inside a steel shell, which, in turn is sealed by welding.
///   ROLLINGPISTON: Positive-displacement rotary compressor using a roller mounted on the eccentric of a shaft with a single vane in the nonrotating cylindrical housing.
///   ROTARYVANE: Positive-displacement rotary compressor using a roller mounted on the eccentric of a shaft with multiple vanes in the nontotating cylindrical housing.
///   SINGLESCREW: Positive-displacement rotary compressor using a single cylindrical main rotor that works with a pair of gate rotors.
///   TWINSCREW: Positive-displacement rotary compressor using two mating helically grooved rotors, male (lobes) and female (flutes) in a stationary housing with inlet and outlet gas ports.
///   USERDEFINED: User-defined compressor type.
///   NOTDEFINED:  Undefined compressor type.
/// 
/// HISTORY: New enumeration in IFC R2x.
typedef enum {IfcCompressorType_DYNAMIC, IfcCompressorType_RECIPROCATING, IfcCompressorType_ROTARY, IfcCompressorType_SCROLL, IfcCompressorType_TROCHOIDAL, IfcCompressorType_SINGLESTAGE, IfcCompressorType_BOOSTER, IfcCompressorType_OPENTYPE, IfcCompressorType_HERMETIC, IfcCompressorType_SEMIHERMETIC, IfcCompressorType_WELDEDSHELLHERMETIC, IfcCompressorType_ROLLINGPISTON, IfcCompressorType_ROTARYVANE, IfcCompressorType_SINGLESCREW, IfcCompressorType_TWINSCREW, IfcCompressorType_USERDEFINED, IfcCompressorType_NOTDEFINED} IfcCompressorTypeEnum;
IFC_PARSE_API const char* ToString(IfcCompressorTypeEnum v);
IFC_PARSE_API IfcCompressorTypeEnum FromString(const std::string& s);
}
namespace IfcCondenserTypeEnum {
/// Enumeration defining the typical types of condensers.  Air is used as the cooling medium for AIRCOOLED; water is used as the cooling medium for all other types.  The IfcCondenserTypeEnum contains the following:
/// 
/// AIRCOOLED: A condenser in which heat is transferred to an air-stream.
///   EVAPORATIVECOOLED: A condenser that is cooled evaporatively.
///   WATERCOOLED: Water-cooled condenser with unspecified operation.
///   WATERCOOLEDSHELLTUBE: Water-cooled condenser with cooling water circulated through one or more tubes contained within the shell.
///   WATERCOOLEDSHELLCOIL: Water-cooled condenser with cooling water circulated through one or more continuous or assembled coils contained within the shell.
///   WATERCOOLEDTUBEINTUBE: Water-cooled condenser consisting of one or more assemblies of two tubes, one within the other.
///   WATERCOOLEDBRAZEDPLATE: Water-cooled condenser condenser with plates brazed together to form an assembly of separate channels.
///   USERDEFINED: User-defined condenser type.
///   NOTDEFINED:  Undefined condenser type.
/// 
/// HISTORY: New enumeration in IFC 2x2.  WATERCOOLED added in IFC 2x4.
typedef enum {IfcCondenserType_AIRCOOLED, IfcCondenserType_EVAPORATIVECOOLED, IfcCondenserType_WATERCOOLED, IfcCondenserType_WATERCOOLEDBRAZEDPLATE, IfcCondenserType_WATERCOOLEDSHELLCOIL, IfcCondenserType_WATERCOOLEDSHELLTUBE, IfcCondenserType_WATERCOOLEDTUBEINTUBE, IfcCondenserType_USERDEFINED, IfcCondenserType_NOTDEFINED} IfcCondenserTypeEnum;
IFC_PARSE_API const char* ToString(IfcCondenserTypeEnum v);
IFC_PARSE_API IfcCondenserTypeEnum FromString(const std::string& s);
}
namespace IfcConnectionTypeEnum {
/// This enumeration defines the different ways how path based elements (such as IfcWallStandardCase) can connect, as shown in Figure 65. 
/// 
/// HISTORY New type in IFC Release 2.0 
/// 
/// L-Shape Connection 
/// 
/// RelatingConnectionType: AtStart 
///   RelatedConnectionType: AtStart 
/// 
/// L-Shape Connection 
/// 
/// RelatingConnectionType: AtEnd 
///   RelatedConnectionType: AtStart 
/// 
/// T-Shape Connection 
/// 
/// RelatingConnectionType: AtPath 
///   RelatedConnectionType: AtStart 
/// 
/// Figure 65 — Connection types</td
typedef enum {IfcConnectionType_ATPATH, IfcConnectionType_ATSTART, IfcConnectionType_ATEND, IfcConnectionType_NOTDEFINED} IfcConnectionTypeEnum;
IFC_PARSE_API const char* ToString(IfcConnectionTypeEnum v);
IFC_PARSE_API IfcConnectionTypeEnum FromString(const std::string& s);
}
namespace IfcConstraintEnum {
/// IfcConstraintEnum is an enumeration used to qualify a constraint. 
/// 
/// HISTORY: New type in IFC Release 2.0
/// 
/// Enumeration 
/// 
/// Value 
///   Definition 
/// 
/// HARD 
///   Qualifies a constraint such that it must be followed rigidly within or at the values set. 
/// 
/// SOFT 
///   Qualifies a constraint such that it should be followed within or at the values set. 
/// 
/// ADVISORY 
///   Qualifies a constraint such that it is advised that it is followed within or at the values set.
typedef enum {IfcConstraint_HARD, IfcConstraint_SOFT, IfcConstraint_ADVISORY, IfcConstraint_USERDEFINED, IfcConstraint_NOTDEFINED} IfcConstraintEnum;
IFC_PARSE_API const char* ToString(IfcConstraintEnum v);
IFC_PARSE_API IfcConstraintEnum FromString(const std::string& s);
}
namespace IfcConstructionEquipmentResourceTypeEnum {
/// This enumeration is used to identify the primary purpose of a construction equipment resource. It is limited to the most common equipment used in construction.  The IfcConstructionEquipmentResourceTypeEnum contains the following:
/// 
/// DEMOLISHING: Removal or destruction of building elements.
/// EARTHMOVING: Excavating, filling, or contouring earth.
/// ERECTING: Lifting, positioning, and placing elements.
/// HEATING: Temporary heat to support construction.
/// LIGHTING: Temporary lighting to support construction.
/// PAVING: Asphalt or concrete roads or walkways.
/// PUMPING: Installing materials through pumps.
/// TRANSPORTING: Transporting products or materials.
/// USERDEFINED: User-defined resource.
/// NOTDEFINED: Undefined resource.
/// 
/// HISTORY: New enumeration in IFC2x4
typedef enum {IfcConstructionEquipmentResourceType_DEMOLISHING, IfcConstructionEquipmentResourceType_EARTHMOVING, IfcConstructionEquipmentResourceType_ERECTING, IfcConstructionEquipmentResourceType_HEATING, IfcConstructionEquipmentResourceType_LIGHTING, IfcConstructionEquipmentResourceType_PAVING, IfcConstructionEquipmentResourceType_PUMPING, IfcConstructionEquipmentResourceType_TRANSPORTING, IfcConstructionEquipmentResourceType_USERDEFINED, IfcConstructionEquipmentResourceType_NOTDEFINED} IfcConstructionEquipmentResourceTypeEnum;
IFC_PARSE_API const char* ToString(IfcConstructionEquipmentResourceTypeEnum v);
IFC_PARSE_API IfcConstructionEquipmentResourceTypeEnum FromString(const std::string& s);
}
namespace IfcConstructionMaterialResourceTypeEnum {
/// This enumeration is used to identify the primary purpose of a construction material resource. It is limited to the most common raw materials used in construction and excludes materials commonly sold as finished products.  The IfcConstructionMaterialResourceTypeEnum contains the following:
/// 
/// AGGREGATES: Construction aggregate including sand, gravel, and crushed stone.
/// CONCRETE: Cast-in-place concrete.
/// DRYWALL: Wall board, including gypsum board.
/// FUEL: Fuel for running equipment.
/// GYPSUM: Any gypsum material.
/// MASONRY: Masonry including brick, stone, concrete block, glass block, and tile.
/// METAL: Any metallic material.
/// PLASTIC: Any plastic material.
/// WOOD: Any wood material.
/// USERDEFINED: User-defined resource.
/// NOTDEFINED: Undefined resource.
/// 
/// HISTORY: New enumeration in IFC2x4
typedef enum {IfcConstructionMaterialResourceType_AGGREGATES, IfcConstructionMaterialResourceType_CONCRETE, IfcConstructionMaterialResourceType_DRYWALL, IfcConstructionMaterialResourceType_FUEL, IfcConstructionMaterialResourceType_GYPSUM, IfcConstructionMaterialResourceType_MASONRY, IfcConstructionMaterialResourceType_METAL, IfcConstructionMaterialResourceType_PLASTIC, IfcConstructionMaterialResourceType_WOOD, IfcConstructionMaterialResourceType_NOTDEFINED, IfcConstructionMaterialResourceType_USERDEFINED} IfcConstructionMaterialResourceTypeEnum;
IFC_PARSE_API const char* ToString(IfcConstructionMaterialResourceTypeEnum v);
IFC_PARSE_API IfcConstructionMaterialResourceTypeEnum FromString(const std::string& s);
}
namespace IfcConstructionProductResourceTypeEnum {
/// This enumeration is used to identify the primary purpose of a construction product resource. It describes use of products created for construction, and excludes products of the finished building model.  The IfcConstructionProductsResourceTypeEnum contains the following:
/// 
/// ASSEMBLY: Construction of assemblies for use as input to the building model or other assemblies.
/// FORMWORK: Construction or placement of forms for placing materials such as concrete.
/// USERDEFINED: User-defined resource.
/// NOTDEFINED: Undefined resource.
/// 
/// HISTORY: New enumeration in IFC2x4
typedef enum {IfcConstructionProductResourceType_ASSEMBLY, IfcConstructionProductResourceType_FORMWORK, IfcConstructionProductResourceType_USERDEFINED, IfcConstructionProductResourceType_NOTDEFINED} IfcConstructionProductResourceTypeEnum;
IFC_PARSE_API const char* ToString(IfcConstructionProductResourceTypeEnum v);
IFC_PARSE_API IfcConstructionProductResourceTypeEnum FromString(const std::string& s);
}
namespace IfcControllerTypeEnum {
/// The IfcControllerTypeEnum defines the range of different types of controller that can be specified.
/// 
/// HISTORY: New type in IFC R2.0
///   Documentation extended in IFC 2x4. PROPORTIONALINTEGRAL and PROPORTIONALINTEGRALDERIVATIVE values deleted (property set enumeration now used).  MULTIPOSITION added.
/// 
/// Enumeration
/// 
/// FLOATING: Output increases or decreases at a constant or accelerating rate.
/// MULTIPOSITION: Output is discrete value, can be one of three or more values.
/// PROGRAMMABLE: Output is programmable such as Discrete Digital Control (DDC).
/// PROPORTIONAL: Output is proportional to the control error and optionally time integral and derivative.
/// TWOPOSITION: Output can be either on or off
/// USERDEFINED: User-defined type.
/// NOTDEFINED: Undefined type.
typedef enum {IfcControllerType_FLOATING, IfcControllerType_PROGRAMMABLE, IfcControllerType_PROPORTIONAL, IfcControllerType_MULTIPOSITION, IfcControllerType_TWOPOSITION, IfcControllerType_USERDEFINED, IfcControllerType_NOTDEFINED} IfcControllerTypeEnum;
IFC_PARSE_API const char* ToString(IfcControllerTypeEnum v);
IFC_PARSE_API IfcControllerTypeEnum FromString(const std::string& s);
}
namespace IfcCooledBeamTypeEnum {
/// There are two general types of cooled or chilled beams: passive and active.
/// 
/// An active Cooled Beam uses a fan or other auxilliary device to aid in air recirculation, while a passive
/// 
/// Cooled Beam relies solely on convection to cool the space.
/// 
/// Enumeration defining the typical types of cooled beams.
/// 
/// The IfcCooledBeamTypeEnum contains the following:
/// 
/// ACTIVE: An active or ventilated cooled beam provides cooling (and heating) but can also function as an air terminal in a ventilation system.
/// 
/// PASSIVE: A passive or static cooled beam provides cooling (and heating) to a room or zone.
/// 
/// USERDEFINED: User-defined cooled beam type.
/// 
/// NOTDEFINED:  Undefined cooled beam type.
/// 
/// HISTORY: New enumeration in IFC 2x2.
typedef enum {IfcCooledBeamType_ACTIVE, IfcCooledBeamType_PASSIVE, IfcCooledBeamType_USERDEFINED, IfcCooledBeamType_NOTDEFINED} IfcCooledBeamTypeEnum;
IFC_PARSE_API const char* ToString(IfcCooledBeamTypeEnum v);
IFC_PARSE_API IfcCooledBeamTypeEnum FromString(const std::string& s);
}
namespace IfcCoolingTowerTypeEnum {
/// Enumeration defining the typical types of cooling towers. 
///   The IfcCoolingTowerTypeEnum contains the following:
/// 
/// NATURALDRAFT: Air flow is produced naturally.
///   MECHANICALINDUCEDDRAFT: Air flow is produced by a mechanical device, typically one or more fans, located on 
/// 
/// the air outlet side of the cooling tower.
///   MECHANICALFORCEDDRAFT: Air flow is produced by a mechanical device, typically one or more fans, located on 
/// 
/// the inlet air side of the cooling tower.
///   USERDEFINED:  User-defined cooling tower type.
///   NOTDEFINED:  Undefined cooling tower type.
/// 
/// HISTORY: New enumeration in IFC R2x.
typedef enum {IfcCoolingTowerType_NATURALDRAFT, IfcCoolingTowerType_MECHANICALINDUCEDDRAFT, IfcCoolingTowerType_MECHANICALFORCEDDRAFT, IfcCoolingTowerType_USERDEFINED, IfcCoolingTowerType_NOTDEFINED} IfcCoolingTowerTypeEnum;
IFC_PARSE_API const char* ToString(IfcCoolingTowerTypeEnum v);
IFC_PARSE_API IfcCoolingTowerTypeEnum FromString(const std::string& s);
}
namespace IfcCostItemTypeEnum {
/// An IfcCostItemTypeEnum is a list of the available types of cost items. 
///   HISTORY: New type in IFC2x4  
///   Enumeration 
/// 
/// USERDEFINED: User-defined type. 
/// NOTDEFINED: Undefined type.
typedef enum {IfcCostItemType_USERDEFINED, IfcCostItemType_NOTDEFINED} IfcCostItemTypeEnum;
IFC_PARSE_API const char* ToString(IfcCostItemTypeEnum v);
IFC_PARSE_API IfcCostItemTypeEnum FromString(const std::string& s);
}
namespace IfcCostScheduleTypeEnum {
/// An IfcCostScheduleTypeEnum is a list of the available types of cost schedule from which that required may be selected. 
///   HISTORY: New type in IFC 2x2  
///   Enumeration 
/// 
/// BUDGET: An allocation of money for a particular purpose. 
/// COSTPLAN: An assessment of the amount of money needing to be expended for a defined purpose based on incomplete information about the goods and services required for a construction or installation.  
/// ESTIMATE: An assessment of the amount of money needing to be expended for a defined purpose based on actual information about the goods and services required for a construction or installation. 
/// TENDER: An offer to provide goods and services.  
/// PRICEDBILLOFQUANTITIES: A complete listing of all work items forming construction or installation works in which costs have been allocated to work items.  
/// UNPRICEDBILLOFQUANTITIES: A complete listing of all work items forming construction or installation works in which costs have not yet been allocated to work items. 
/// SCHEDULEOFRATES: A listing of each type of goods forming construction or installation works with the cost of purchase, construction/installation, overheads and profit assigned so that additional items of that type can be costed.  
/// USERDEFINED: User-defined type. 
/// NOTDEFINED: Undefined type.
typedef enum {IfcCostScheduleType_BUDGET, IfcCostScheduleType_COSTPLAN, IfcCostScheduleType_ESTIMATE, IfcCostScheduleType_TENDER, IfcCostScheduleType_PRICEDBILLOFQUANTITIES, IfcCostScheduleType_UNPRICEDBILLOFQUANTITIES, IfcCostScheduleType_SCHEDULEOFRATES, IfcCostScheduleType_USERDEFINED, IfcCostScheduleType_NOTDEFINED} IfcCostScheduleTypeEnum;
IFC_PARSE_API const char* ToString(IfcCostScheduleTypeEnum v);
IFC_PARSE_API IfcCostScheduleTypeEnum FromString(const std::string& s);
}
namespace IfcCoveringTypeEnum {
/// Definition from IAI: This enumeration defines the range
/// of different types of covering that can further specify an
/// IfcCovering or an IfcCoveringType.
/// HISTORY New enumeration
/// in IFC Release 1.0
/// IFC2x4 CHANGE The following
/// enumerators of the IfcCoveringTypeEnum have been
/// deprecated INSULATION, SLEEVING and
/// WRAPPING.
/// Enumeration
/// 
/// CEILING: the covering is used to
/// represent a ceiling
/// FLOORING: the covering is used to
/// represent a flooring
/// CLADDING: the covering is used to
/// represent a cladding
/// ROOFING: the covering is used to
/// represent a roof
/// 
/// INSULATION: the covering is used to
/// insulate an element for thermal or acoustic purposes.
/// IFC2x4 NOTE The use of this
/// enumerator is deprecated.
/// MEMBRANE: an impervious layer that
/// could be used for e.g. roof covering (below tiling - that may be
/// known as sarking etc.) or as a damp proof course membrane
/// IFC2x4 NOTE The use of this
/// enumerator is deprecated.
/// SLEEVING: the covering is used to
/// isolate a distribution element from a space in which it is
/// contained.
/// IFC2x4 NOTE The use of this
/// enumerator is deprecated.
/// WRAPPING: the covering is used for
/// wrapping particularly of distribution elements using tape.
/// IFC2x4 NOTE The use of this
/// enumerator is deprecated.
/// 
/// USERDEFINED: user defined type of
/// covering
/// NOTDEFINED: undefined type of
/// covering
typedef enum {IfcCoveringType_CEILING, IfcCoveringType_FLOORING, IfcCoveringType_CLADDING, IfcCoveringType_ROOFING, IfcCoveringType_MOLDING, IfcCoveringType_SKIRTINGBOARD, IfcCoveringType_INSULATION, IfcCoveringType_MEMBRANE, IfcCoveringType_SLEEVING, IfcCoveringType_WRAPPING, IfcCoveringType_USERDEFINED, IfcCoveringType_NOTDEFINED} IfcCoveringTypeEnum;
IFC_PARSE_API const char* ToString(IfcCoveringTypeEnum v);
IFC_PARSE_API IfcCoveringTypeEnum FromString(const std::string& s);
}
namespace IfcCrewResourceTypeEnum {
/// This enumeration is used to identify the primary purpose of a crew resource.  The IfcCrewResourceTypeEnum contains the following:
/// 
/// OFFICE: A composition of resources performing administration work in an office.
/// SITE: A composition of resources performing production work on a construction site.
/// USERDEFINED: User-defined resource.
/// NOTDEFINED: Undefined resource.
/// 
/// HISTORY: New enumeration in IFC2x4
typedef enum {IfcCrewResourceType_OFFICE, IfcCrewResourceType_SITE, IfcCrewResourceType_USERDEFINED, IfcCrewResourceType_NOTDEFINED} IfcCrewResourceTypeEnum;
IFC_PARSE_API const char* ToString(IfcCrewResourceTypeEnum v);
IFC_PARSE_API IfcCrewResourceTypeEnum FromString(const std::string& s);
}
namespace IfcCurtainWallTypeEnum {
/// Definition from IAI: Enumeration defining
/// the valid types of curtain wall that can be predefined using the
/// enumeration values. 
/// HISTORY 
/// New Enumeration in Release IFC2x Edition 3
/// NOTE  Currently there
/// are no specific enumerators defined, the IfcCurtainWallTypeEnum
/// has
/// been added for future extensions.
typedef enum {IfcCurtainWallType_USERDEFINED, IfcCurtainWallType_NOTDEFINED} IfcCurtainWallTypeEnum;
IFC_PARSE_API const char* ToString(IfcCurtainWallTypeEnum v);
IFC_PARSE_API IfcCurtainWallTypeEnum FromString(const std::string& s);
}
namespace IfcCurveInterpolationEnum {
/// IfcCurveInterpolationEnum specifies the possible methods
/// for the interpolation of property values given as a curve.
/// 
/// HISTORY  New type in IFC2x4.
/// 
/// Enumeration
/// 
/// LINEAR: Indicates that values between the defined
/// values are to be found by linear interpolation.
/// LOG_LINEAR: Indicates that values between the defined
/// values are to be found by linear interpolation of the natural
/// logarithm (base e) of the values.
/// LOG_LOG: Indicates that values between the defined
/// values are to be found by linear interpolation of the Briggs'
/// logarithm (base 10) of the values.
/// NOTDEFINED: No interpolation information is
/// provided
typedef enum {IfcCurveInterpolation_LINEAR, IfcCurveInterpolation_LOG_LINEAR, IfcCurveInterpolation_LOG_LOG, IfcCurveInterpolation_NOTDEFINED} IfcCurveInterpolationEnum;
IFC_PARSE_API const char* ToString(IfcCurveInterpolationEnum v);
IFC_PARSE_API IfcCurveInterpolationEnum FromString(const std::string& s);
}
namespace IfcDamperTypeEnum {
/// This enumeration defines the various types of damper:
/// 
/// BALANCINGDAMPER: Damper used for purposes of manually balancing pressure differences.  Commonly operated by mechanical adjustment.
/// BACKDRAFTDAMPER: Backdraft damper used to restrict the movement of air in one direction.  Commonly operated by mechanical spring.
/// BLASTDAMPER: Blast damper use to prevent protect occupants and equipment against overpressures resultant of an explosion.  Commonly operated by mechanical spring.
/// CONTROLDAMPER: Control damper used to modulate the flow of air by adjusting the position of the blades.  Commonly operated by an actuator of a building automation system.
/// FIREDAMPER: Fire damper used to prevent the spread of fire for a specified duration.  Commonly operated by fusable link that melts above a certain temperature.
/// FIRESMOKEDAMPER: Combination fire and smoke damper used to preven the spread of fire and smoke.  Commonly operated by a fusable link and a smoke detector
/// FUMEHOODEXHAUST: Fume hood exhaust damper.  Commonly operated by actuator.
/// GRAVITYDAMPER: Gravity damper closes from the force of gravity.  Commonly operated by gravitational weight.
/// GRAVITYRELIEFDAMPER: Gravity-relief damper used to allow air to move upon a buildup of enough pressure to overcome the gravitational force exerted upon the damper blades.  Commonly operated by gravitational weight.
/// RELIEFDAMPER: Relief damper used to allow air to move upon a buildup of a specified pressure differential.  Commonly operated by mechanical spring.
/// SMOKEDAMPER: Smoke damper used to prevent the spread of smoke.  Commonly operated by a smoke detector of a building automation system.
/// USERDEFINED: User-defined damper.
/// NOTDEFINED: Undefined damper.
/// 
/// HISTORY: New enumeration in IFC R2.0
typedef enum {IfcDamperType_BACKDRAFTDAMPER, IfcDamperType_BALANCINGDAMPER, IfcDamperType_BLASTDAMPER, IfcDamperType_CONTROLDAMPER, IfcDamperType_FIREDAMPER, IfcDamperType_FIRESMOKEDAMPER, IfcDamperType_FUMEHOODEXHAUST, IfcDamperType_GRAVITYDAMPER, IfcDamperType_GRAVITYRELIEFDAMPER, IfcDamperType_RELIEFDAMPER, IfcDamperType_SMOKEDAMPER, IfcDamperType_USERDEFINED, IfcDamperType_NOTDEFINED} IfcDamperTypeEnum;
IFC_PARSE_API const char* ToString(IfcDamperTypeEnum v);
IFC_PARSE_API IfcDamperTypeEnum FromString(const std::string& s);
}
namespace IfcDataOriginEnum {
/// IfcDataOriginEnum identifies the origin of time data:
/// 
/// MEASURED: The origin of the time data is a measurement device.
///   PREDICTED: The time data are a prediction.
///   SIMULATED: The origin of the time data is a simulation.
///   NOTDEFINED: The origin of the time data is undefined.
/// 
/// HISTORY: New enumeration in IFC 2x2.
typedef enum {IfcDataOrigin_MEASURED, IfcDataOrigin_PREDICTED, IfcDataOrigin_SIMULATED, IfcDataOrigin_USERDEFINED, IfcDataOrigin_NOTDEFINED} IfcDataOriginEnum;
IFC_PARSE_API const char* ToString(IfcDataOriginEnum v);
IFC_PARSE_API IfcDataOriginEnum FromString(const std::string& s);
}
namespace IfcDerivedUnitEnum {
/// IfcDerivedUnitEnum is an enumeration type for allowed types of derived units.
/// ENUMERATION 
/// 
/// ACCELERATIONUNIT 
///   ANGULARVELOCITYUNIT 
///   COMPOUNDPLANEANGLEUNIT 
///   DYNAMICVISCOSITYUNIT 
///   HEATFLUXDENSITYUNIT 
///   INTEGERCOUNTRATEUNIT 
///   ISOTHERMALMOISTURECAPACITYUNIT 
///   KINEMATICVISCOSITYUNIT 
///   LINEARFORCEUNIT 
///   LINEARMOMENTUNIT 
///   LINEARSTIFFNESSUNIT 
///   LINEARVELOCITYUNIT 
///   MASSDENSITYUNIT 
///   MASSFLOWRATEUNIT 
///   MODULUSOFELASTICITYUNIT 
///   MODULUSOFSUBGRADEREACTIONUNIT 
///   MOISTUREDIFFUSIVITYUNIT 
///   MOLECULARWEIGHTUNIT 
///   MOMENTORINERTIAUNIT 
///   PLANARFORCEUNIT 
///   ROTATIONALFREQUENCYUNIT 
///   ROTATIONALSTIFFNESSUNIT 
///   SHEARMODULUSUNIT 
///   SPECIFICHEATCAPACITYUNIT 
///   THERMALADMITTANCEUNIT 
///   THERMALCONDUCTANCEUNIT 
///   THERMALRESISTANCEUNIT 
///   THERMALTRANSMITTANCEUNIT 
///   TORQUEUNIT 
///   VAPORPERMEABILITYUNIT 
///   VOLUMETRICFLOWRATEUNIT 
///   CURVATUREUNIT 
///   HEATINGVALUEUNIT 
///   IONCONCENTRATIONUNIT 
///   LUMINOUSINTENSITYDISTRIBUTIONUNIT 
///   MASSPERLENGTHUNIT 
///   MODULUSOFLINEARSUBGRADEREACTIONUNIT 
///   MODULUSOFROTATIONALSUBGRADEREACTIONUNIT 
///   PHUNIT 
///   ROTATIONALMASSUNIT 
///   SECTIONAREAINTEGRALUNIT 
///   SECTIONMODULUSUNIT 
///   SOUNDPOWERUNIT 
///   SOUNDPRESSUREUNIT 
///   TEMPERATUREGRADIENTUNIT 
///   TEMPERATURERATEOFCHANGE 
///   THERMALEXPANSIONCOEFFICIENTUNIT 
///   WARPINGCONSTANTUNIT 
///   WARPINGMOMENTUNIT 
///   USERDEFINED: User defined derived unit. 
/// 
/// HISTORY: New type in IFC Release 2.0.
/// 
/// IFC 2x4 change: added TEMPERATURERATEOFCHANGE.
typedef enum {IfcDerivedUnit_ANGULARVELOCITYUNIT, IfcDerivedUnit_AREADENSITYUNIT, IfcDerivedUnit_COMPOUNDPLANEANGLEUNIT, IfcDerivedUnit_DYNAMICVISCOSITYUNIT, IfcDerivedUnit_HEATFLUXDENSITYUNIT, IfcDerivedUnit_INTEGERCOUNTRATEUNIT, IfcDerivedUnit_ISOTHERMALMOISTURECAPACITYUNIT, IfcDerivedUnit_KINEMATICVISCOSITYUNIT, IfcDerivedUnit_LINEARVELOCITYUNIT, IfcDerivedUnit_MASSDENSITYUNIT, IfcDerivedUnit_MASSFLOWRATEUNIT, IfcDerivedUnit_MOISTUREDIFFUSIVITYUNIT, IfcDerivedUnit_MOLECULARWEIGHTUNIT, IfcDerivedUnit_SPECIFICHEATCAPACITYUNIT, IfcDerivedUnit_THERMALADMITTANCEUNIT, IfcDerivedUnit_THERMALCONDUCTANCEUNIT, IfcDerivedUnit_THERMALRESISTANCEUNIT, IfcDerivedUnit_THERMALTRANSMITTANCEUNIT, IfcDerivedUnit_VAPORPERMEABILITYUNIT, IfcDerivedUnit_VOLUMETRICFLOWRATEUNIT, IfcDerivedUnit_ROTATIONALFREQUENCYUNIT, IfcDerivedUnit_TORQUEUNIT, IfcDerivedUnit_MOMENTOFINERTIAUNIT, IfcDerivedUnit_LINEARMOMENTUNIT, IfcDerivedUnit_LINEARFORCEUNIT, IfcDerivedUnit_PLANARFORCEUNIT, IfcDerivedUnit_MODULUSOFELASTICITYUNIT, IfcDerivedUnit_SHEARMODULUSUNIT, IfcDerivedUnit_LINEARSTIFFNESSUNIT, IfcDerivedUnit_ROTATIONALSTIFFNESSUNIT, IfcDerivedUnit_MODULUSOFSUBGRADEREACTIONUNIT, IfcDerivedUnit_ACCELERATIONUNIT, IfcDerivedUnit_CURVATUREUNIT, IfcDerivedUnit_HEATINGVALUEUNIT, IfcDerivedUnit_IONCONCENTRATIONUNIT, IfcDerivedUnit_LUMINOUSINTENSITYDISTRIBUTIONUNIT, IfcDerivedUnit_MASSPERLENGTHUNIT, IfcDerivedUnit_MODULUSOFLINEARSUBGRADEREACTIONUNIT, IfcDerivedUnit_MODULUSOFROTATIONALSUBGRADEREACTIONUNIT, IfcDerivedUnit_PHUNIT, IfcDerivedUnit_ROTATIONALMASSUNIT, IfcDerivedUnit_SECTIONAREAINTEGRALUNIT, IfcDerivedUnit_SECTIONMODULUSUNIT, IfcDerivedUnit_SOUNDPOWERLEVELUNIT, IfcDerivedUnit_SOUNDPOWERUNIT, IfcDerivedUnit_SOUNDPRESSURELEVELUNIT, IfcDerivedUnit_SOUNDPRESSUREUNIT, IfcDerivedUnit_TEMPERATUREGRADIENTUNIT, IfcDerivedUnit_TEMPERATURERATEOFCHANGEUNIT, IfcDerivedUnit_THERMALEXPANSIONCOEFFICIENTUNIT, IfcDerivedUnit_WARPINGCONSTANTUNIT, IfcDerivedUnit_WARPINGMOMENTUNIT, IfcDerivedUnit_USERDEFINED} IfcDerivedUnitEnum;
IFC_PARSE_API const char* ToString(IfcDerivedUnitEnum v);
IFC_PARSE_API IfcDerivedUnitEnum FromString(const std::string& s);
}
namespace IfcDirectionSenseEnum {
/// IfcDirectionSenseEnum is an enumeration denoting whether sense of direction is positive or negative along the given axis.
/// 
/// ENUMERATION
/// 
/// POSITIVE: Direction defined to be positive.
/// NEGATIVE: Direction defined to be negative.
/// 
/// HISTORY New Type in IFC2x.
typedef enum {IfcDirectionSense_POSITIVE, IfcDirectionSense_NEGATIVE} IfcDirectionSenseEnum;
IFC_PARSE_API const char* ToString(IfcDirectionSenseEnum v);
IFC_PARSE_API IfcDirectionSenseEnum FromString(const std::string& s);
}
namespace IfcDiscreteAccessoryTypeEnum {
/// Definition from IAI: This enumeration defines the different types of discrete accessories:
/// 
/// ANCHORPLATE: An accessory consisting of a steel plate, shear stud connectors or welded-on rebar which is embedded into the surface of a concrete element so that other elements can be welded or bolted onto it later.
/// BRACKET: An L-shaped or similarly shaped accessory attached in a corner between elements to hold them together or to carry a secondary element.
/// SHOE: A column shoe or a beam shoe (beam hanger) used to support or secure an element.
/// USERDEFINED: User-defined accessory
/// NOTDEFINED: Undefined accessory
/// 
/// HISTORY  New Enumeration in IFC 2x4.
typedef enum {IfcDiscreteAccessoryType_ANCHORPLATE, IfcDiscreteAccessoryType_BRACKET, IfcDiscreteAccessoryType_SHOE, IfcDiscreteAccessoryType_USERDEFINED, IfcDiscreteAccessoryType_NOTDEFINED} IfcDiscreteAccessoryTypeEnum;
IFC_PARSE_API const char* ToString(IfcDiscreteAccessoryTypeEnum v);
IFC_PARSE_API IfcDiscreteAccessoryTypeEnum FromString(const std::string& s);
}
namespace IfcDistributionChamberElementTypeEnum {
/// This enumeration identifies different types of distribution chambers.
/// 
/// Valid enumerations are:
/// 
/// FORMEDDUCT: Space formed in the ground for the passage of pipes, cables, ducts.
/// INSPECTIONCHAMBER: Chamber constructed on a drain, sewer or pipeline with a removable cover that permits visble inspection.
/// INSPECTIONPIT:  Recess or chamber formed to permit access for inspection of substructure and services.
/// MANHOLE: Chamber constructed on a drain, sewer or pipeline with a removable cover that permits the entry of a person.
/// METERCHAMBER: Chamber that houses a meter(s).
/// SUMP: Recessed or small chamber into which liquid is drained to facilitate its collection for removal.
/// TRENCH: Excavated chamber, the length of which typically exceeds the width.
/// VALVECHAMBER: Chamber that houses a valve(s).
/// USERDEFINED: User-defined chamber type.
/// NOTDEFINED: Undefined chamber type.
/// 
/// HISTORY: New enumeration in IFC R2x2
typedef enum {IfcDistributionChamberElementType_FORMEDDUCT, IfcDistributionChamberElementType_INSPECTIONCHAMBER, IfcDistributionChamberElementType_INSPECTIONPIT, IfcDistributionChamberElementType_MANHOLE, IfcDistributionChamberElementType_METERCHAMBER, IfcDistributionChamberElementType_SUMP, IfcDistributionChamberElementType_TRENCH, IfcDistributionChamberElementType_VALVECHAMBER, IfcDistributionChamberElementType_USERDEFINED, IfcDistributionChamberElementType_NOTDEFINED} IfcDistributionChamberElementTypeEnum;
IFC_PARSE_API const char* ToString(IfcDistributionChamberElementTypeEnum v);
IFC_PARSE_API IfcDistributionChamberElementTypeEnum FromString(const std::string& s);
}
namespace IfcDistributionPortTypeEnum {

typedef enum {IfcDistributionPortType_CABLE, IfcDistributionPortType_CABLECARRIER, IfcDistributionPortType_DUCT, IfcDistributionPortType_PIPE, IfcDistributionPortType_USERDEFINED, IfcDistributionPortType_NOTDEFINED} IfcDistributionPortTypeEnum;
IFC_PARSE_API const char* ToString(IfcDistributionPortTypeEnum v);
IFC_PARSE_API IfcDistributionPortTypeEnum FromString(const std::string& s);
}
namespace IfcDistributionSystemEnum {
/// This enumeration identifies different types of distribution systems.
/// 
/// HISTORY: New enumeration in IFC R2x4
/// 
/// Valid enumerations for pipes and related elements include:
/// 
/// CHEMICAL: Arbitrary chemical further qualified by property set, such as for medical or industrial use.
///   CHILLEDWATER: Nonpotable chilled water, such as circulated through an evaporator.
///   COMPRESSEDAIR: Compressed air system.
///   CONDENSERWATER: Nonpotable water, such as circulated through a condensor.
///   DOMESTICCOLDWATER: Unheated potable water distribution system.
///   DOMESTICHOTWATER: Heated potable water distribution system.
///   DRAINAGE: Drainage collection system.
///   FIREPROTECTION: Fire protection sprinkler system.
///   GAS: Methane distribution system.
///   HAZARDOUS: Hazardous material or fluid collection system.
///   HEATING: Heated water distribution system.
///   OIL: Oil distribution system.
///   RAINWATER: Rainwater resulting from precipitation which directly falls on a parcel.
///   REFRIGERATION: Refrigerant distribution system for purposes of fulfilling all or parts of a refrigeration cycle.
///   SEWAGE: Sewage collection system.
///   STORMWATER: Stormwater resulting from precipitation which runs off or travels over the ground surface.
///   VACUUM: Vacuum distribution system.
///   VENT: Vent system for wastewater piping systems.
///   WASTE: Waste collection system.
/// 
/// Valid enumerations for ducts and related elements include:
/// 
/// AIRCONDITIONING:  Conditioned air distribution system for purposes of maintaining a temperature range within one or more spaces.
///   EXHAUST:  Exhaust air collection system for removing stale or noxious air from one or more spaces.
///   VENTILATION:  Ventilation air distribution system involved in either the exchange of air to the outside as well as circulation of air within a building.
/// 
/// Valid enumerations for cables and related elements include:
/// 
/// AUDIOVISUAL:  A transport of a single media source, having audio and/or video streams.
///   CONTROL:  A transport or network dedicated to control system usage.
///   DATA: A network having general-purpose usage.
///   EARTHING: A path for equipotential bonding, conducting current to the ground.
///   ELECTRICAL: A circuit for delivering electrical power.
///   ELECTROACCOUSTIC: An amplified audio signal such as for loudspeakers.
///   LIGHTING: A circuit dedicated for lighting, such as a fixture having sockets for lamps.
///   LIGHTNINGPROTECTION: A path for conducting lightning current to the ground.
///   POWERGENERATION: A path for power generation.
///   SECURITY: A transport or network dedicated to security system usage.
///   SIGNAL: A raw analog signal, such as modulated data or measurements from sensors.
///   TELEPHONE: A transport or network dedicated to telephone system usage.
///   TV: A transport of multiple media sources (e.g. analog cable, satellite, over-the-air).
typedef enum {IfcDistributionSystem_AIRCONDITIONING, IfcDistributionSystem_AUDIOVISUAL, IfcDistributionSystem_CHEMICAL, IfcDistributionSystem_CHILLEDWATER, IfcDistributionSystem_COMMUNICATION, IfcDistributionSystem_COMPRESSEDAIR, IfcDistributionSystem_CONDENSERWATER, IfcDistributionSystem_CONTROL, IfcDistributionSystem_CONVEYING, IfcDistributionSystem_DATA, IfcDistributionSystem_DISPOSAL, IfcDistributionSystem_DOMESTICCOLDWATER, IfcDistributionSystem_DOMESTICHOTWATER, IfcDistributionSystem_DRAINAGE, IfcDistributionSystem_EARTHING, IfcDistributionSystem_ELECTRICAL, IfcDistributionSystem_ELECTROACOUSTIC, IfcDistributionSystem_EXHAUST, IfcDistributionSystem_FIREPROTECTION, IfcDistributionSystem_FUEL, IfcDistributionSystem_GAS, IfcDistributionSystem_HAZARDOUS, IfcDistributionSystem_HEATING, IfcDistributionSystem_LIGHTING, IfcDistributionSystem_LIGHTNINGPROTECTION, IfcDistributionSystem_MUNICIPALSOLIDWASTE, IfcDistributionSystem_OIL, IfcDistributionSystem_OPERATIONAL, IfcDistributionSystem_POWERGENERATION, IfcDistributionSystem_RAINWATER, IfcDistributionSystem_REFRIGERATION, IfcDistributionSystem_SECURITY, IfcDistributionSystem_SEWAGE, IfcDistributionSystem_SIGNAL, IfcDistributionSystem_STORMWATER, IfcDistributionSystem_TELEPHONE, IfcDistributionSystem_TV, IfcDistributionSystem_VACUUM, IfcDistributionSystem_VENT, IfcDistributionSystem_VENTILATION, IfcDistributionSystem_WASTEWATER, IfcDistributionSystem_WATERSUPPLY, IfcDistributionSystem_USERDEFINED, IfcDistributionSystem_NOTDEFINED} IfcDistributionSystemEnum;
IFC_PARSE_API const char* ToString(IfcDistributionSystemEnum v);
IFC_PARSE_API IfcDistributionSystemEnum FromString(const std::string& s);
}
namespace IfcDocumentConfidentialityEnum {
/// IfcDocumentConfidentialityEnum enables selection of the level of confidentiality of document information from a list of choices. 
/// 
/// HISTORY: New enumeration in IFC 2x
/// 
/// Enumeration 
/// 
/// PUBLIC: Document is publicly available. 
/// RESTRICTED: Document availability is restricted. 
/// CONFIDENTIAL: Document is confidential and its contents should not be revealed without permission. 
/// PERSONAL: Document is personal to the author. 
/// USERDEFINED 
/// NOTDEFINED
typedef enum {IfcDocumentConfidentiality_PUBLIC, IfcDocumentConfidentiality_RESTRICTED, IfcDocumentConfidentiality_CONFIDENTIAL, IfcDocumentConfidentiality_PERSONAL, IfcDocumentConfidentiality_USERDEFINED, IfcDocumentConfidentiality_NOTDEFINED} IfcDocumentConfidentialityEnum;
IFC_PARSE_API const char* ToString(IfcDocumentConfidentialityEnum v);
IFC_PARSE_API IfcDocumentConfidentialityEnum FromString(const std::string& s);
}
namespace IfcDocumentStatusEnum {
/// IfcDocumentStatusEnum enables selection of the status of document information from a list of choices.
/// 
/// HISTORY: New enumeration in IFC Release 2x.
typedef enum {IfcDocumentStatus_DRAFT, IfcDocumentStatus_FINALDRAFT, IfcDocumentStatus_FINAL, IfcDocumentStatus_REVISION, IfcDocumentStatus_NOTDEFINED} IfcDocumentStatusEnum;
IFC_PARSE_API const char* ToString(IfcDocumentStatusEnum v);
IFC_PARSE_API IfcDocumentStatusEnum FromString(const std::string& s);
}
namespace IfcDoorPanelOperationEnum {
/// This enumeration defines the basic ways how individual door panels operate as shown in Figure 164.
/// HISTORY New Enumeration in IFC Release 2.0.
/// IFC2x4 CHANGE Enumerator FIXEDPANELadded.
/// 
/// Swinging
/// 
/// DoubleActing
/// 
/// Sliding
/// 
/// Folding
/// 
/// Revolving
/// 
/// Rollingup
/// 
/// FixedPanel
/// 
/// NOTE Enumerator added in IFC2x4.
/// 
/// UserDefined
///  
/// 
/// NotDefined
///  
/// 
/// Figure 164 — Door operations
/// 
/// The opening direction of the door panels is given by the local
/// placement of the IfcDoor. The positive y-axis determines
/// the direction as shown in Figure 165.
/// 
/// Figure 165 — Door panel operations
/// 
/// NOTE  Figures (symbolic representation) depend on the national building code.  These figures are only shown as illustrations
typedef enum {IfcDoorPanelOperation_SWINGING, IfcDoorPanelOperation_DOUBLE_ACTING, IfcDoorPanelOperation_SLIDING, IfcDoorPanelOperation_FOLDING, IfcDoorPanelOperation_REVOLVING, IfcDoorPanelOperation_ROLLINGUP, IfcDoorPanelOperation_FIXEDPANEL, IfcDoorPanelOperation_USERDEFINED, IfcDoorPanelOperation_NOTDEFINED} IfcDoorPanelOperationEnum;
IFC_PARSE_API const char* ToString(IfcDoorPanelOperationEnum v);
IFC_PARSE_API IfcDoorPanelOperationEnum FromString(const std::string& s);
}
namespace IfcDoorPanelPositionEnum {
/// Definition: This enumeration defines the basic ways to describe the location of a door panel within a door lining.
/// 
/// HISTORY New Enumeration in IFC Release 2.x
/// 
/// Figure 166 shows the designation of a door panel with PanelPosition = LEFT and a door panel with PanelPosition = RIGHT within a door style with OperationType = DOUBLE_DOOR_SINGLE_SWING. The position is given as shown in the XZ plane of the local placement, looking into the direction of the positive Y axis. 
/// 
/// Figure 166 — Door panel positions
typedef enum {IfcDoorPanelPosition_LEFT, IfcDoorPanelPosition_MIDDLE, IfcDoorPanelPosition_RIGHT, IfcDoorPanelPosition_NOTDEFINED} IfcDoorPanelPositionEnum;
IFC_PARSE_API const char* ToString(IfcDoorPanelPositionEnum v);
IFC_PARSE_API IfcDoorPanelPositionEnum FromString(const std::string& s);
}
namespace IfcDoorStyleConstructionEnum {
/// Definition from IAI: This enumeration defines the
///   basic types of construction of doors. The construction type
///   relates to the main material (or material combination) used
///   for making the door.
/// 
/// HISTORY New Enumeration in
///   IFC Release 2x .
typedef enum {IfcDoorStyleConstruction_ALUMINIUM, IfcDoorStyleConstruction_HIGH_GRADE_STEEL, IfcDoorStyleConstruction_STEEL, IfcDoorStyleConstruction_WOOD, IfcDoorStyleConstruction_ALUMINIUM_WOOD, IfcDoorStyleConstruction_ALUMINIUM_PLASTIC, IfcDoorStyleConstruction_PLASTIC, IfcDoorStyleConstruction_USERDEFINED, IfcDoorStyleConstruction_NOTDEFINED} IfcDoorStyleConstructionEnum;
IFC_PARSE_API const char* ToString(IfcDoorStyleConstructionEnum v);
IFC_PARSE_API IfcDoorStyleConstructionEnum FromString(const std::string& s);
}
namespace IfcDoorStyleOperationEnum {
/// This enumeration defines the basic ways to describe how doors operate as shown in Figure 167.
/// HISTORY  New Enumeration in Release IFC2x.
/// 
/// Enumerator
///   Description
///   Figure
/// 
/// SINGLE_SWING_LEFT
/// 
/// Door with one
/// panel that opens (swings) to the
/// left. The hinges are on the left side as viewed in the direction of the
/// positive y-axis.
///   Note: Direction of swing (whether
/// in or out)
/// is determined at the IfcDoor.
/// 
/// SINGLE_SWING_RIGHT
/// 
/// Door with one
/// panel that opens (swings) to the
/// right. The hinges are on the right side as viewed in the direction of
/// the positive y-axis.
///   Note: Direction of swing (whether
/// in or out)
/// is determined at the IfcDoor.
/// 
/// DOUBLE_DOOR_
/// SINGLE_SWING
/// 
/// Door with two
/// panels, one opens (swings) to the
/// left the other opens (swings) to the right.
///   Note: Direction of swing (whether
/// in or out)
/// is determined at the IfcDoor. 
/// 
/// DOUBLE_SWING_LEFT
/// 
/// Door with one
/// panel that swings in both
/// directions and to the left in the main trafic direction. Also called
/// double acting door.
///   Note: Direction of main swing
/// (whether in or
/// out) is determined at the IfcDoor. 
/// 
/// DOUBLE_SWING_RIGHT
/// 
/// Door with one
/// panel that swings in both
/// directions and to the right in the main trafic direction. Also called
/// double acting door.
///   Note: Direction of main swing
/// (whether in or
/// out) is determined at the IfcDoor.
/// 
/// DOUBLE_DOOR_
/// DOUBLE_SWING
/// 
/// Door with two
/// panels, one swings in both
/// directions and to the right in the main trafic direction the other
/// swings also in both directions and to the left in the main trafic
/// direction.
///   Note: Direction of main swing
/// (whether in or
/// out) is determined at the IfcDoor.
/// 
/// DOUBLE_DOOR_
/// SINGLE_SWING_
/// OPPOSITE_LEFT
/// 
/// Door with two
/// panels that both open to the left,
/// one panel swings in one direction and the other panel swings in the
/// opposite direction.
///   Note: Direction of main swing
/// (whether in or
/// out) is determined at the IfcDoor.
/// 
/// DOUBLE_DOOR_
/// SINGLE_SWING_
/// OPPOSITE_RIGHT
///   Door with two
/// panels that both open to the right,
/// one panel swings in one direction and the other panel swings in the
/// opposite direction.
///   Note: Direction of main swing
/// (whether in or
/// out) is determined at the IfcDoor.
/// 
/// SLIDING_TO_LEFT
/// 
/// Door with one
/// panel that is sliding to the left. 
/// 
/// SLIDING_TO_RIGHT
/// 
/// Door with one
/// panel that is sliding to the right. 
/// 
/// DOUBLE_DOOR_SLIDING
/// 
/// Door with two
/// panels, one is sliding to the left
/// the other is sliding to the right. 
/// 
/// FOLDING_TO_LEFT
/// 
/// Door with one
/// panel that is folding to the left. 
/// 
/// FOLDING_TO_RIGHT
///   Door with one
/// panel that is folding to the right. 
/// 
/// DOUBLE_DOOR_FOLDING
/// 
/// Door with two
/// panels, one is folding to the left
/// the other is folding to the right. 
/// 
/// REVOLVING
/// 
/// An entrance door
/// consisting of four leaves set in
/// a form of a cross and revolving around a central vertical axis (the
/// four panels are described by a single IfcDoor panel
/// property). 
/// 
/// ROLLINGUP
/// 
/// Door that opens
/// by rolling up.
///   Note: Whether it rolls up to the
/// inside or
/// outside is determined at the IfcDoor.
/// 
/// USERDEFINED
///   User defined
/// operation type
///    
/// 
/// NOTDEFINED
///   A door with a
/// not defined operation type is
/// considered as a door with a lining, but no panels. It is thereby always
/// open.
///    
/// 
/// Figure 167 — Door style operations
/// 
/// NOTE
/// 
/// Figures are shown in the ground view.
///   Figures (symbolic representation) depend on the national
/// building
/// code.
///   These figures are only shown as illustrations, the actual
/// representation in the ground view might differ. 
///   Open to the outside is declared as open into the direction
/// of the
/// positive y-axis, determined by the ObjectPlacement
/// at IfcDoor
///   The location of the panel relative to the wall thickness is
/// defined by the ObjectPlacement at IfcDoor,
/// and the IfcDoorLiningProperties.LiningOffset
/// parameter.
typedef enum {IfcDoorStyleOperation_SINGLE_SWING_LEFT, IfcDoorStyleOperation_SINGLE_SWING_RIGHT, IfcDoorStyleOperation_DOUBLE_DOOR_SINGLE_SWING, IfcDoorStyleOperation_DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_LEFT, IfcDoorStyleOperation_DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_RIGHT, IfcDoorStyleOperation_DOUBLE_SWING_LEFT, IfcDoorStyleOperation_DOUBLE_SWING_RIGHT, IfcDoorStyleOperation_DOUBLE_DOOR_DOUBLE_SWING, IfcDoorStyleOperation_SLIDING_TO_LEFT, IfcDoorStyleOperation_SLIDING_TO_RIGHT, IfcDoorStyleOperation_DOUBLE_DOOR_SLIDING, IfcDoorStyleOperation_FOLDING_TO_LEFT, IfcDoorStyleOperation_FOLDING_TO_RIGHT, IfcDoorStyleOperation_DOUBLE_DOOR_FOLDING, IfcDoorStyleOperation_REVOLVING, IfcDoorStyleOperation_ROLLINGUP, IfcDoorStyleOperation_USERDEFINED, IfcDoorStyleOperation_NOTDEFINED} IfcDoorStyleOperationEnum;
IFC_PARSE_API const char* ToString(IfcDoorStyleOperationEnum v);
IFC_PARSE_API IfcDoorStyleOperationEnum FromString(const std::string& s);
}
namespace IfcDoorTypeEnum {
/// Definition from IAI: This enumeration defines the
/// different predefined types of an IfcDoorType object can
/// fulfill:
/// 
/// DOOR: A standard door usually within a wall opening,
/// as a door panel in a curtain wall, or as a "free standing"
/// door.
/// GATE: A gate is a point of entry to a property usually
/// within an opening in a fence. Or as a "free standing" gate.
/// TRAPDOOR: A special door that lies horizonally in a
/// slab opening. Often used for accessing cellar or attic.
/// USERDEFINED: User-defined linear beam element.
/// NOTDEFINED: Undefined linear beam element
/// 
/// HISTORY  New Enumeration
/// in IFC2x4.
typedef enum {IfcDoorType_DOOR, IfcDoorType_GATE, IfcDoorType_TRAPDOOR, IfcDoorType_USERDEFINED, IfcDoorType_NOTDEFINED} IfcDoorTypeEnum;
IFC_PARSE_API const char* ToString(IfcDoorTypeEnum v);
IFC_PARSE_API IfcDoorTypeEnum FromString(const std::string& s);
}
namespace IfcDoorTypeOperationEnum {
/// This enumeration defines the basic ways to describe how doors operate, as shown in Figure 66. It combines the partitioning of the door into a single or multiple door panels and the operation types of that panels.
/// 
/// In the most common case of swinging doors the IfcDoorTypeOperationEnum defined the hinge side (left hing or right hung) and the opening direction (opening to the left, opening to the right). Whether the door opens inwards or outwards is determined by the local coordinate system of the IfcDoor, or IfcDoorStandardCase.
/// 
/// NOTE There are different definitions in various countries on what a left opening or left hung or left swing door is (same for right). Therefore the IFC definition terms may derivate from the local standard and may need to be mapped appropriately.
/// 
/// HISTORY  New Enumeration in IFC2x4.
/// 
/// IFC2x4 CHANGE The new IfcDoorTypeOperationEnum replaces the use of IfcDoorStyleOperationEnum that is deprecated from IFC2x4 onwards.
/// 
/// Enumerator
/// Description
/// Figures
///  
/// 
/// SINGLE_SWING_LEFT
/// 
/// Door with one panel that opens
/// (swings) to the left. The hinges are on the left side as viewed
/// in the direction of the positive y-axis.
/// Note: Direction of swing (whether in or out)
/// is determined at the IfcDoor or
/// IfcDoorStandardCase.
/// 
/// SINGLE_SWING_RIGHT
/// 
/// Door with one panel that opens
/// (swings) to the right. The hinges are on the right side as viewed
/// in the direction of the positive y-axis.
/// Note: Direction of swing (whether in or out)
/// is determined at the IfcDoor or
/// IfcDoorStandardCase.
/// 
/// DOUBLE_DOOR_
/// SINGLE_SWING
/// 
/// Door with two panels, one opens
/// (swings) to the left the other opens (swings) to the right.
/// Note: Direction of swing (whether in or out)
/// is determined at the IfcDoor or
/// IfcDoorStandardCase. 
/// 
/// DOUBLE_SWING_LEFT
/// 
/// Door with one panel that swings in
/// both directions and to the left in the main trafic direction.
/// Also called double acting door.
/// Note: Direction of main swing (whether in or
/// out) is determined at the IfcDoor or
/// IfcDoorStandardCase. 
/// 
/// DOUBLE_SWING_RIGHT
/// 
/// Door with one panel that swings in
/// both directions and to the right in the main trafic direction.
/// Also called double acting door.
/// Note: Direction of main swing (whether in or
/// out) is determined at the IfcDoor or
/// IfcDoorStandardCase.
/// 
/// DOUBLE_DOOR_
/// DOUBLE_SWING
/// 
/// Door with two panels, one swings in
/// both directions and to the right in the main trafic direction the
/// other swings also in both directions and to the left in the main
/// trafic direction.
/// Note: Direction of main swing (whether in or
/// out) is determined at the IfcDoor or
/// IfcDoorStandardCase.
/// 
/// DOUBLE_DOOR_
/// SINGLE_SWING_
/// OPPOSITE_LEFT
/// 
/// Door with two panels that both open
/// to the left, one panel swings in one direction and the other
/// panel swings in the opposite direction.
/// Note: Direction of main swing (whether in or
/// out) is determined at the IfcDoor or
/// IfcDoorStandardCase.
/// 
///  
///  
/// 
/// DOUBLE_DOOR_
/// SINGLE_SWING_
/// OPPOSITE_RIGHT
/// Door with two panels that both open
/// to the right, one panel swings in one direction and the other
/// panel swings in the opposite direction.
/// Note: Direction of main swing (whether in or
/// out) is determined at the IfcDoor or
/// IfcDoorStandardCase.
/// 
///  
///  
/// 
/// SLIDING_TO_LEFT
/// 
/// Door with one panel that is sliding
/// to the left.
/// 
/// SLIDING_TO_RIGHT
/// 
/// Door with one panel that is sliding
/// to the right.
/// 
/// DOUBLE_DOOR_SLIDING
/// 
/// Door with two panels, one is sliding
/// to the left the other is sliding to the right.
/// 
/// FOLDING_TO_LEFT
/// 
/// Door with one panel that is folding
/// to the left.
/// 
/// FOLDING_TO_RIGHT
/// Door with one panel that is folding
/// to the right.
/// 
/// DOUBLE_DOOR_FOLDING
/// 
/// Door with two panels, one is folding
/// to the left the other is folding to the right.
/// 
/// REVOLVING
/// 
/// An entrance door consisting of four
/// leaves set in a form of a cross and revolving around a central
/// vertical axis (the four panels are described by a single
/// IfcDoor panel property).
///  
///  
/// 
/// ROLLINGUP
/// 
/// Door that opens by rolling up.
/// Note: Whether it rolls up to the inside or
/// outside is determined at the IfcDoor.
/// 
/// SWING_FIXED_LEFT
/// Door with one panel that opens
/// (swings) to the left and one fixed panel. The hinges of the
/// swinging panel are on the left side as viewed in the direction of
/// the positive y-axis.
/// Note: Direction of swing (whether in or out)
/// is determined at the IfcDoor or or
/// IfcDoorStandardCase.
/// IFC2x4 CHANGE This is a new
/// enumerator compared with previous
/// IfcDoorStyleOperationEnum.
/// 
/// SWING_FIXED_RIGHT
/// Door with one panel that opens
/// (swings) to the right and one fixed panel. The hinges of the
/// swinging panel are on the right side as viewed in the direction
/// of the positive y-axis.
/// Note: Direction of swing (whether in or out)
/// is determined at the IfcDoor or or
/// IfcDoorStandardCase.
/// IFC2x4 CHANGE This is a new
/// enumerator compared with previous
/// IfcDoorStyleOperationEnum.
/// 
/// USERDEFINED
/// User defined operation type
///  
///  
/// 
/// NOTDEFINED
/// A door with a not defined operation
/// type is considered as a door with a lining, but no panels. It is
/// thereby always open.
/// 
///  
/// 
/// Figure 66 — Door operations
/// 
/// NOTE
/// 
/// Figures are shown in the ground view.
/// Figures (symbolic representation) depend on the national
/// building code.
/// These figures are only shown as illustrations, the actual
/// representation in the ground view might differ.
/// Open to the outside is declared as open into the direction of
/// the positive y-axis, determined by the ObjectPlacement at
/// IfcDoor
/// The location of the panel relative to the wall thickness is
/// defined by the ObjectPlacement at IfcDoor, and the
/// IfcDoorLiningProperties.LiningOffset parameter.
typedef enum {IfcDoorTypeOperation_SINGLE_SWING_LEFT, IfcDoorTypeOperation_SINGLE_SWING_RIGHT, IfcDoorTypeOperation_DOUBLE_DOOR_SINGLE_SWING, IfcDoorTypeOperation_DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_LEFT, IfcDoorTypeOperation_DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_RIGHT, IfcDoorTypeOperation_DOUBLE_SWING_LEFT, IfcDoorTypeOperation_DOUBLE_SWING_RIGHT, IfcDoorTypeOperation_DOUBLE_DOOR_DOUBLE_SWING, IfcDoorTypeOperation_SLIDING_TO_LEFT, IfcDoorTypeOperation_SLIDING_TO_RIGHT, IfcDoorTypeOperation_DOUBLE_DOOR_SLIDING, IfcDoorTypeOperation_FOLDING_TO_LEFT, IfcDoorTypeOperation_FOLDING_TO_RIGHT, IfcDoorTypeOperation_DOUBLE_DOOR_FOLDING, IfcDoorTypeOperation_REVOLVING, IfcDoorTypeOperation_ROLLINGUP, IfcDoorTypeOperation_SWING_FIXED_LEFT, IfcDoorTypeOperation_SWING_FIXED_RIGHT, IfcDoorTypeOperation_USERDEFINED, IfcDoorTypeOperation_NOTDEFINED} IfcDoorTypeOperationEnum;
IFC_PARSE_API const char* ToString(IfcDoorTypeOperationEnum v);
IFC_PARSE_API IfcDoorTypeOperationEnum FromString(const std::string& s);
}
namespace IfcDuctFittingTypeEnum {
/// This enumeration is used to identify the primary purpose of a duct fitting. This is a very basic categorization mechanism
///   to generically identify the duct fitting type. Subcategories
///   of duct fittings are not enumerated. 
///   The IfcDuctFittingTypeEnum contains the following:
/// 
/// BEND:		A fitting with typically two ports used to change 
///   the direction of flow between connected elements.
///   CONNECTOR:   Connector fitting, typically used to join two
///   ports together within a flow distribution system 
///   (e.g., a coupling used to join two duct segments).
///   ENTRY:       Entry fitting, typically unconnected at one port
///   and connected to a flow distribution system at 
///   the other (e.g., an outside air duct system 
///   intake opening).
///   EXIT:        Exit fitting, typically unconnected at one port
///   and connected to a flow distribution system at 
///   the other (e.g., an exhaust air discharge 
///   opening).
///   JUNCTION:	A fitting with typically more than two ports used
///   to redistribute flow among the ports and/or to
///   change the direction of flow between connected
///   elements (e.g, tee, cross, wye, etc.).
///   OBSTRUCTION: A fitting with typically two ports used to 
///   obstruct or restrict flow between the connected
///   elements (e.g., screen, perforated plate, etc.).
///   TRANSITION:	A fitting with typically two ports having
///   different shapes or sizes. Can also be used to
///   change the direction of flow between connected
///   elements.
///   USERDEFINED: User-defined fitting.
///   NOTDEFINED:  Undefined fitting.
/// 
/// HISTORY: New enumeration in IFC 2x2
typedef enum {IfcDuctFittingType_BEND, IfcDuctFittingType_CONNECTOR, IfcDuctFittingType_ENTRY, IfcDuctFittingType_EXIT, IfcDuctFittingType_JUNCTION, IfcDuctFittingType_OBSTRUCTION, IfcDuctFittingType_TRANSITION, IfcDuctFittingType_USERDEFINED, IfcDuctFittingType_NOTDEFINED} IfcDuctFittingTypeEnum;
IFC_PARSE_API const char* ToString(IfcDuctFittingTypeEnum v);
IFC_PARSE_API IfcDuctFittingTypeEnum FromString(const std::string& s);
}
namespace IfcDuctSegmentTypeEnum {
/// This enumeration is used to identify the primary purpose of a
///   duct segment. This is a very basic categorization mechanism
///   to generically identify the duct segment type. Subcategories
///   of duct segments are not enumerated. 
///   The IfcDuctSegmentTypeEnum contains the following:
/// 
/// RIGIDSEGMENT: A rigid segment is continuous linear segment of duct
///   that cannot be deformed.
///   FLEXIBLESEGMENT:  A flexible segment is a continuous non-linear segment
///   of duct that can be deformed and change the direction 
///   of flow.
///   USERDEFINED: User-defined segment.
///   NOTDEFINED:  Undefined segment.
/// 
/// HISTORY: New enumeration in IFC 2x2
typedef enum {IfcDuctSegmentType_RIGIDSEGMENT, IfcDuctSegmentType_FLEXIBLESEGMENT, IfcDuctSegmentType_USERDEFINED, IfcDuctSegmentType_NOTDEFINED} IfcDuctSegmentTypeEnum;
IFC_PARSE_API const char* ToString(IfcDuctSegmentTypeEnum v);
IFC_PARSE_API IfcDuctSegmentTypeEnum FromString(const std::string& s);
}
namespace IfcDuctSilencerTypeEnum {
/// Enumeration defining the typical types of duct silencers. 
///   The IfcDuctSilencerTypeEnum contains the following:
/// 
/// FLATOVAL:  Flat-oval shaped duct silencer type.
///   RECTANGULAR:  Rectangular shaped duct silencer type.
///   ROUND:  Round duct silencer type.
///   USERDEFINED:  User-defined duct silencer type.
///   NOTDEFINED:  Undefined duct silencer type.
/// 
/// HISTORY: New enumeration in IFC 2x2.
typedef enum {IfcDuctSilencerType_FLATOVAL, IfcDuctSilencerType_RECTANGULAR, IfcDuctSilencerType_ROUND, IfcDuctSilencerType_USERDEFINED, IfcDuctSilencerType_NOTDEFINED} IfcDuctSilencerTypeEnum;
IFC_PARSE_API const char* ToString(IfcDuctSilencerTypeEnum v);
IFC_PARSE_API IfcDuctSilencerTypeEnum FromString(const std::string& s);
}
namespace IfcElectricApplianceTypeEnum {
/// The IfcElectricApplianceTypeEnum defines the range of different types of electrical appliance that can be specified. 
/// 
/// HISTORY: New type in IFC R2.0.
///   Renamed from IfcElectricalApplianceTypeEnum if IFC 2x2.IFC 2x2 Addendum 1:
///   Missing enumeration values added (ELECTRICHEATER, TUMBLEDRYER and
///   WATERHEATER)
///   IFC 2x4: ELECTRICHEATER changed to FREESTANDINGELECTRICHEATER and noted as being for occasional use. RADIANTHEATER removed as part of general 'heater consolidation'. WATERHEATER, DIRECTWATERHEATER and INDIRECTWATERHEATER rationalized to FREESTANDINGWATERHEATER. WATERCOOLER changed to FREESTANDINGWATERCOOLER.
///   COMPUTER, FACSIMILE (FAX), PRINTER, SCANNER, TELEPHONE, TV (TELEVISION) moved to IfcAudioVisualApplianceTypeEnum and IfcCommunicationsApplianceTypeEnum. KITCHENMACHINE added.
/// 
/// Enumeration 
/// 
/// DISHWASHER: An appliance that has the primary function of washing dishes. 
/// ELECTRICCOOKER: An electrical appliance that has the primary function of cooking food (including oven, hob, grill). 
/// FREESTANDINGELECTRICHEATER: An electrical appliance that is used occasionally to provide heat. A freestanding electric heater is a 'plugged' appliance whose load may be removed from an electric circuit. 
/// FREESTANDINGFAN: An electrical appliance that is used occasionally to provide ventilation. A freestanding fan is a 'plugged' appliance whose load may be removed from an electric circuit. 
/// FREESTANDINGWATERHEATER: A small, local electrical appliance for heating water. A freestanding water heater is a 'plugged' appliance whose load may be removed from an electric circuit. 
/// FREESTANDINGWATERCOOLER: A small, local electrical appliance for cooling water. A freestanding water cooler is a 'plugged' appliance whose load may be removed from an electric circuit. 
/// FREEZER: An electrical appliance that has the primary function of storing food at temperatures below the freezing point of water. 
/// FRIDGE_FREEZER: An electrical appliance that combines the functions of a freezer and a refrigerator through the provision of separate compartments. 
/// KITCHENMACHINE: A specialized appliance used in commercial kitchens such as a mixer. 
/// HANDDRYER: An electrical appliance that has the primary function of drying hands. 
/// MICROWAVE: An electrical appliance that has the primary function of cooking food using microwaves. 
/// PHOTOCOPIER: A machine that has the primary function of reproduction of printed matter. 
/// REFRIGERATOR: An electrical appliance that has the primary function of storing food at low temperature but above the freezing point of water. 
/// TUMBLEDRYER: An electrical appliance that has the primary function of drying clothes. 
/// VENDINGMACHINE: An appliance that stores and vends goods including food, drink and goods of various types. 
/// WASHINGMACHINE: An appliance that has the primary function of washing clothes. 	  
/// USERDEFINED: User-defined type. 
/// NOTDEFINED: Undefined type.
typedef enum {IfcElectricApplianceType_DISHWASHER, IfcElectricApplianceType_ELECTRICCOOKER, IfcElectricApplianceType_FREESTANDINGELECTRICHEATER, IfcElectricApplianceType_FREESTANDINGFAN, IfcElectricApplianceType_FREESTANDINGWATERHEATER, IfcElectricApplianceType_FREESTANDINGWATERCOOLER, IfcElectricApplianceType_FREEZER, IfcElectricApplianceType_FRIDGE_FREEZER, IfcElectricApplianceType_HANDDRYER, IfcElectricApplianceType_KITCHENMACHINE, IfcElectricApplianceType_MICROWAVE, IfcElectricApplianceType_PHOTOCOPIER, IfcElectricApplianceType_REFRIGERATOR, IfcElectricApplianceType_TUMBLEDRYER, IfcElectricApplianceType_VENDINGMACHINE, IfcElectricApplianceType_WASHINGMACHINE, IfcElectricApplianceType_USERDEFINED, IfcElectricApplianceType_NOTDEFINED} IfcElectricApplianceTypeEnum;
IFC_PARSE_API const char* ToString(IfcElectricApplianceTypeEnum v);
IFC_PARSE_API IfcElectricApplianceTypeEnum FromString(const std::string& s);
}
namespace IfcElectricDistributionBoardTypeEnum {
/// The IfcElectricDistributionBoardTypeEnum defines the range of different types and/or functions of electric distribution board possible. 
///   HISTORY: New type in IFC 2x4. Replaces IfcElectricDistributionPointTypeEnum  
///   Enumeration 
/// 
/// CONSUMERUNIT: A distribution point on the incoming electrical supply, typically in domestic premises, at which protective devices are located. 
/// DISTRIBUTIONBOARD: A distribution point at which connections are made for distribution of electrical circuits usually through protective devices. 
/// MOTORCONTROLCENTRE: A distribution point at which starting and control devices for major plant items are located. 
/// SWITCHBOARD: A distribution point at which switching devices are located. 
/// USERDEFINED: User-defined type. 
/// NOTDEFINED: Undefined type.
typedef enum {IfcElectricDistributionBoardType_CONSUMERUNIT, IfcElectricDistributionBoardType_DISTRIBUTIONBOARD, IfcElectricDistributionBoardType_MOTORCONTROLCENTRE, IfcElectricDistributionBoardType_SWITCHBOARD, IfcElectricDistributionBoardType_USERDEFINED, IfcElectricDistributionBoardType_NOTDEFINED} IfcElectricDistributionBoardTypeEnum;
IFC_PARSE_API const char* ToString(IfcElectricDistributionBoardTypeEnum v);
IFC_PARSE_API IfcElectricDistributionBoardTypeEnum FromString(const std::string& s);
}
namespace IfcElectricFlowStorageDeviceTypeEnum {
/// The IfcElectricFlowStorageDeviceTypeEnum defines the range of different types of electrical flow storage device available. 
///   HISTORY: New type in IFC 2x2  
///   Enumeration 
/// 
/// BATTERY: A device for storing energy in chemical form so that it can be released as electrical energy. 
/// CAPACITORBANK: A device that stores electrical energy when an external power supply is present using the electrical property of capacitance 
/// HARMONICFILTER: A device that constantly injects currents that precisely correspond to the harmonic components drawn by the load. 
/// UPS: A device that provides a time limited alternative source of power supply in the event of failure of the main supply.  
/// USERDEFINED: User-defined type.  
/// NOTDEFINED: Undefined type.
typedef enum {IfcElectricFlowStorageDeviceType_BATTERY, IfcElectricFlowStorageDeviceType_CAPACITORBANK, IfcElectricFlowStorageDeviceType_HARMONICFILTER, IfcElectricFlowStorageDeviceType_INDUCTORBANK, IfcElectricFlowStorageDeviceType_UPS, IfcElectricFlowStorageDeviceType_USERDEFINED, IfcElectricFlowStorageDeviceType_NOTDEFINED} IfcElectricFlowStorageDeviceTypeEnum;
IFC_PARSE_API const char* ToString(IfcElectricFlowStorageDeviceTypeEnum v);
IFC_PARSE_API IfcElectricFlowStorageDeviceTypeEnum FromString(const std::string& s);
}
namespace IfcElectricGeneratorTypeEnum {
/// The IfcElectricGeneratorTypeEnum defines the range of types of electric generators available.
///   HISTORY: New type in IFC 2x2.  Values added in IFC 2x4. 
/// 
/// Enumeration 
/// 
/// CHP: Combined heat and power supply, used not only as a source of electric energy but also as a heating source for the building. It may therefore be not only part of an electrical system but also of a heating system. 
/// ENGINEGENERATOR: Electrical generator with a fuel-driven engine, for example a diesel-driven emergency power supply. 
/// STANDALONE: Electrical generator which does not include its source of kinetic energy, that is, a motor, engine, or turbine is modeled by a separate object. 
/// USERDEFINED: User-defined type. 
/// NOTDEFINED: Undefined type.
typedef enum {IfcElectricGeneratorType_CHP, IfcElectricGeneratorType_ENGINEGENERATOR, IfcElectricGeneratorType_STANDALONE, IfcElectricGeneratorType_USERDEFINED, IfcElectricGeneratorType_NOTDEFINED} IfcElectricGeneratorTypeEnum;
IFC_PARSE_API const char* ToString(IfcElectricGeneratorTypeEnum v);
IFC_PARSE_API IfcElectricGeneratorTypeEnum FromString(const std::string& s);
}
namespace IfcElectricMotorTypeEnum {
/// The IfcElectricMotorTypeEnum defines the range of different types of electric motor that can be specified. 
///   HISTORY: New type in IFC 2x2  
///   Enumeration 
/// 
/// DC: A motor using either generated or rectified D.C. power. 
/// INDUCTION: An alternating current motor in which the primary winding on one member (usually the stator) is connected to the power source and a secondary winding or a squirrel-cage secondary winding on the other member (usually the rotor) carries the induced current. There is no physical electrical connection to the secondary winding, its current is induced. 
/// POLYPHASE: A two or three-phase induction motor in which the windings, one for each phase, are evenly divided by the same number of electrical degrees.  
/// RELUCTANCESYNCHRONOUS: A synchronous motor with a special rotor design which directly lines the rotor up with the rotating magnetic field of the stator, allowing for no slip under load.  
/// SYNCHRONOUS: A motor that operates at a constant speed up to full load. The rotor speed is equal to the speed of the rotating magnetic field of the stator; there is no slip. 
/// USERDEFINED: User-defined type. 
/// NOTDEFINED: Undefined type.
typedef enum {IfcElectricMotorType_DC, IfcElectricMotorType_INDUCTION, IfcElectricMotorType_POLYPHASE, IfcElectricMotorType_RELUCTANCESYNCHRONOUS, IfcElectricMotorType_SYNCHRONOUS, IfcElectricMotorType_USERDEFINED, IfcElectricMotorType_NOTDEFINED} IfcElectricMotorTypeEnum;
IFC_PARSE_API const char* ToString(IfcElectricMotorTypeEnum v);
IFC_PARSE_API IfcElectricMotorTypeEnum FromString(const std::string& s);
}
namespace IfcElectricTimeControlTypeEnum {
/// The IfcElectricTimeControlTypeEnum defines the range of types of electrical time control available. 
///   HISTORY: New type in IFC 2x2  
///   Enumeration 
/// 
/// TIMECLOCK: A control that causes action to occur at set times. 
/// TIMEDELAY: A control that causes action to occur following a set duration. 
/// RELAY: Electromagnetically operated contactor for making or breaking a control circuit. 
/// USERDEFINED: User-defined type. 
/// NOTDEFINED: Undefined type.
typedef enum {IfcElectricTimeControlType_TIMECLOCK, IfcElectricTimeControlType_TIMEDELAY, IfcElectricTimeControlType_RELAY, IfcElectricTimeControlType_USERDEFINED, IfcElectricTimeControlType_NOTDEFINED} IfcElectricTimeControlTypeEnum;
IFC_PARSE_API const char* ToString(IfcElectricTimeControlTypeEnum v);
IFC_PARSE_API IfcElectricTimeControlTypeEnum FromString(const std::string& s);
}
namespace IfcElementAssemblyTypeEnum {
/// Definition from IAI: An enumeration defining the
///   basic configuration types for element assemblies.
/// 
/// HISTORY New enumeration type
///   in Release IFC2x Edition 2.
/// 
/// Enumeration
/// 
/// ACCESSORY_ASSEMBLY: Assembled accessories or components
///   ARCH: A curved structure
///   BEAM_GRID: Interconnected beams, located in one (typically horizontal) plane
///   BRACED_FRAME: A rigid frame with additional bracing members
///   GIRDER: A beam-like superstructure
///   REINFORCEMENT_UNIT: Assembled reinforcement elements
///   RIGID_FRAME: A structure built up of beams, columns, etc. with moment-resisting joints
///   SLAB_FIELD: Slabs, laid out in one plane
///   TRUSS: A structure built up of members with (quasi) pinned joints
///   USERDEFINED: User-defined element assembly
///   NOTDEFINED: Undefined element assembly
typedef enum {IfcElementAssemblyType_ACCESSORY_ASSEMBLY, IfcElementAssemblyType_ARCH, IfcElementAssemblyType_BEAM_GRID, IfcElementAssemblyType_BRACED_FRAME, IfcElementAssemblyType_GIRDER, IfcElementAssemblyType_REINFORCEMENT_UNIT, IfcElementAssemblyType_RIGID_FRAME, IfcElementAssemblyType_SLAB_FIELD, IfcElementAssemblyType_TRUSS, IfcElementAssemblyType_USERDEFINED, IfcElementAssemblyType_NOTDEFINED} IfcElementAssemblyTypeEnum;
IFC_PARSE_API const char* ToString(IfcElementAssemblyTypeEnum v);
IFC_PARSE_API IfcElementAssemblyTypeEnum FromString(const std::string& s);
}
namespace IfcElementCompositionEnum {
/// Definition from IAI: Enumeration that provides an
///   indication, whether the spatial structure element or proxy
///   represents a:
/// 
/// COMPLEX - a group or aggregation of similar elements
/// 
/// ELEMENT - a (undivided) element itself
/// 
/// PARTIAL - a subelement or part
/// 
/// HISTORY New enumeration in
///   IFC Release 2.x
typedef enum {IfcElementComposition_COMPLEX, IfcElementComposition_ELEMENT, IfcElementComposition_PARTIAL} IfcElementCompositionEnum;
IFC_PARSE_API const char* ToString(IfcElementCompositionEnum v);
IFC_PARSE_API IfcElementCompositionEnum FromString(const std::string& s);
}
namespace IfcEngineTypeEnum {
/// Enumeration defining the typical types of engines.  The IfcEngineTypeEnum contains the following:
/// 
/// EXTERNALCOMBUSTION: Combustion is external.
///   INTERNALCOMBUSTION: Combustion is internal.
///   USERDEFINED: User-defined engine type.
///   NOTDEFINED:  Undefined engine type.
/// 
/// HISTORY: New enumeration in IFC 2x4.
typedef enum {IfcEngineType_EXTERNALCOMBUSTION, IfcEngineType_INTERNALCOMBUSTION, IfcEngineType_USERDEFINED, IfcEngineType_NOTDEFINED} IfcEngineTypeEnum;
IFC_PARSE_API const char* ToString(IfcEngineTypeEnum v);
IFC_PARSE_API IfcEngineTypeEnum FromString(const std::string& s);
}
namespace IfcEvaporativeCoolerTypeEnum {
/// Enumeration defining the typical types of evaporative coolers. 
///   The IfcEvaporativeCoolerTypeEnum contains the following:
/// 
/// DIRECTEVAPORATIVERANDOMMEDIAAIRCOOLER: Direct evaporative random media air cooler: Cools the air stream by evaporating water dircectly into the air stream using coolers with evaporative pads, usually of aspen wood or plastic fiber/foam.
///   DIRECTEVAPORATIVERIGIDMEDIAAIRCOOLER: Direct evaporative rigid media air cooler: Cools the air stream by evaporating water dircectly into the air stream using coolers with sheets of rigid, corrugated material as the wetted surface.
///   DIRECTEVAPORATIVESLINGERSPACKAGEDAIRCOOLER: Direct evaporative slingers packaged air cooler: Cools the air stream by evaporating water dircectly into the air stream using coolers with a water slinger in an evaporative cooling section and a fan section.
///   DIRECTEVAPORATIVEPACKAGEDROTARYAIRCOOLER: Direct evaporative packaged rotary air cooler: Cools the air stream by evaporating water dircectly into the air stream using coolers that wet and wash the evaporative pad by rotating it through a water bath.
///   DIRECTEVAPORATIVEAIRWASHER: Direct evaporative air washer: Cools the air stream by evaporating water dircectly into the air stream using coolers with spray-type air washer consist of a chamber or casing containing spray nozzles, and tank for collecting spray water, and an eliminator section for removing entrained drops of water from the air.
///   INDIRECTEVAPORATIVEPACKAGEAIRCOOLER: Indirect evaporative package air cooler: Cools the air stream by evaporating water indirectly and without adding moisture into the air stream. On one side of the heat exchanger, the secondary air stream is cooled by evaporation, while on the other side of heat exchanger, the primary air stream (conditioned air to be supplied to the room) is sensibly cooled by the heat exchanger surfaces.
///   INDIRECTEVAPORATIVEWETCOIL: Indirect evaporative wet coil: Cools the air stream by evaporating water indirectly and without adding moisture into the air stream. Water is sprayed directly on the tubes of the heat exchanger where latent cooling takes place and the vaporization of the water on the outside of the heat exchanger tubes allows the simultaneous heat and mass transfer which removes heat from the supply air on the tube side.
///   INDIRECTEVAPORATIVECOOLINGTOWERORCOILCOOLER: Indirect evaporative cooling tower or coil cooler: Cools the air stream by evaporating water indirectly and without adding moisture into the air stream using a combination of a cooling tower or other evaporative water cooler with a water-to-air heat exchanger coil and water circulating pump.
///   INDIRECTDIRECTCOMBINATION: Indirect/Direct combination: Cools the air stream by evaporating water indirectly and without adding moisture into the air stream using a two-stage cooler with a first-stage indirect evaporative cooler and second-stage direct evaporative cooler.
///   USERDEFINED:  User-defined evaporative cooler type.
///   NOTDEFINED:  Undefined evaporative cooler type.
/// 
/// HISTORY: New enumeration in IFC 2x2.
typedef enum {IfcEvaporativeCoolerType_DIRECTEVAPORATIVERANDOMMEDIAAIRCOOLER, IfcEvaporativeCoolerType_DIRECTEVAPORATIVERIGIDMEDIAAIRCOOLER, IfcEvaporativeCoolerType_DIRECTEVAPORATIVESLINGERSPACKAGEDAIRCOOLER, IfcEvaporativeCoolerType_DIRECTEVAPORATIVEPACKAGEDROTARYAIRCOOLER, IfcEvaporativeCoolerType_DIRECTEVAPORATIVEAIRWASHER, IfcEvaporativeCoolerType_INDIRECTEVAPORATIVEPACKAGEAIRCOOLER, IfcEvaporativeCoolerType_INDIRECTEVAPORATIVEWETCOIL, IfcEvaporativeCoolerType_INDIRECTEVAPORATIVECOOLINGTOWERORCOILCOOLER, IfcEvaporativeCoolerType_INDIRECTDIRECTCOMBINATION, IfcEvaporativeCoolerType_USERDEFINED, IfcEvaporativeCoolerType_NOTDEFINED} IfcEvaporativeCoolerTypeEnum;
IFC_PARSE_API const char* ToString(IfcEvaporativeCoolerTypeEnum v);
IFC_PARSE_API IfcEvaporativeCoolerTypeEnum FromString(const std::string& s);
}
namespace IfcEvaporatorTypeEnum {
/// Enumeration defining the typical types of evaporators. 
///   The IfcEvaporatorTypeEnum contains the following:
/// 
/// DIRECTEXPANSION: Direct-expansion evaporator.
///   DIRECTEXPANSIONSHELLANDTUBE: Direct-expansion evaporator where a refrigerant evaporates inside a series of baffles that channel the fluid throughout the shell side.
///   DIRECTEXPANSIONTUBEINTUBE: Direct-expansion evaporator where a refrigerant evaporates inside one or more pairs of coaxial tubes.
///   DIRECTEXPANSIONBRAZEDPLATE: Direct-expansion evaporator where a refrigerant evaporates inside plates brazed or welded together to make up an assembly of separate channels.
///   FLOODEDSHELLANDTUBE: Evaporator in which refrigerant evaporates outside tubes.
///   SHELLANDCOIL: Evaporator in which refrigerant evaporates inside a simple coiled tube immersed in the fluid to be cooled.
///   USERDEFINED:  User-defined evaporator type.
///   NOTDEFINED:  Undefined evaporator type.
/// 
/// HISTORY: New enumeration in IFC 2x2.
typedef enum {IfcEvaporatorType_DIRECTEXPANSION, IfcEvaporatorType_DIRECTEXPANSIONSHELLANDTUBE, IfcEvaporatorType_DIRECTEXPANSIONTUBEINTUBE, IfcEvaporatorType_DIRECTEXPANSIONBRAZEDPLATE, IfcEvaporatorType_FLOODEDSHELLANDTUBE, IfcEvaporatorType_SHELLANDCOIL, IfcEvaporatorType_USERDEFINED, IfcEvaporatorType_NOTDEFINED} IfcEvaporatorTypeEnum;
IFC_PARSE_API const char* ToString(IfcEvaporatorTypeEnum v);
IFC_PARSE_API IfcEvaporatorTypeEnum FromString(const std::string& s);
}
namespace IfcEventTriggerTypeEnum {
/// The IfcEventTriggerTypeEnum defines the range of different types of event trigger that can be specified.
/// 
/// HISTORY: New type in IFC2x4
/// 
/// Enumeration: The definition of event trigger types has been adopted from the Business Process Modeling Notation (BPMN), which is also used in the Information Delivery Manual (IDM) for defining business processes. More detailed information about the use of event trigger types can be found in these specifications.
/// 
/// EVENTRULE: An event trigger that is a rule or constraint
/// EVENTMESSAGE: An event trigger that is a message or set of information
/// EVENTTIME: An event trigger that is at, or occurs after, a particular point in or period of time
/// EVENTCOMPLEX: An event trigger that is a complex combination of things
/// USERDEFINED
/// NOTDEFINED
typedef enum {IfcEventTriggerType_EVENTRULE, IfcEventTriggerType_EVENTMESSAGE, IfcEventTriggerType_EVENTTIME, IfcEventTriggerType_EVENTCOMPLEX, IfcEventTriggerType_USERDEFINED, IfcEventTriggerType_NOTDEFINED} IfcEventTriggerTypeEnum;
IFC_PARSE_API const char* ToString(IfcEventTriggerTypeEnum v);
IFC_PARSE_API IfcEventTriggerTypeEnum FromString(const std::string& s);
}
namespace IfcEventTypeEnum {
/// The IfcEventTypeEnum defines the range of different types of event that can be specified.
/// 
/// HISTORY  New type in IFC2x4
/// 
/// Enumeration:
/// 
/// STARTEVENT: An initiating event of a process
/// ENDEVENT: A terminating event of a process
/// INTERMEDIATEEVENT: An event that occurs at an intermediate stage of a process
/// USERDEFINED
/// NOTDEFINED
typedef enum {IfcEventType_STARTEVENT, IfcEventType_ENDEVENT, IfcEventType_INTERMEDIATEEVENT, IfcEventType_USERDEFINED, IfcEventType_NOTDEFINED} IfcEventTypeEnum;
IFC_PARSE_API const char* ToString(IfcEventTypeEnum v);
IFC_PARSE_API IfcEventTypeEnum FromString(const std::string& s);
}
namespace IfcExternalSpatialElementTypeEnum {
/// Definition from IAI: This enumeration defines the
/// different types of external spatial elements.
/// Enumeration:
/// 
/// EXTERNAL - External air space around the building.
/// EXTERNAL_EARTH - External volume covered by earth around the
/// building.
/// EXTERNAL_WATER - External volume covered with water around
/// the building.
/// EXTERNAL_FIRE - Space occupied by a neightboring
/// building.
/// USERDEFINED
/// NOTDEFINED
/// 
/// HISTORY New enumeration
/// in IFC2x4.
typedef enum {IfcExternalSpatialElementType_EXTERNAL, IfcExternalSpatialElementType_EXTERNAL_EARTH, IfcExternalSpatialElementType_EXTERNAL_WATER, IfcExternalSpatialElementType_EXTERNAL_FIRE, IfcExternalSpatialElementType_USERDEFINED, IfcExternalSpatialElementType_NOTDEFINED} IfcExternalSpatialElementTypeEnum;
IFC_PARSE_API const char* ToString(IfcExternalSpatialElementTypeEnum v);
IFC_PARSE_API IfcExternalSpatialElementTypeEnum FromString(const std::string& s);
}
namespace IfcFanTypeEnum {
/// Enumeration defining the typical types of fans.
///   The IfcFanTypeEnum contains the following:
/// 
/// CENTRIFUGALFORWARDCURVED: Air flows through the impeller radially using blades that are forward curved.
///   CENTRIFUGALRADIAL: Air flows through the impeller radially using blades that are uncurved or slightl forward curved.
///   CENTRIFUGALBACKWARDINCLINEDCURVED: Air flows through the impeller radially using blades that are backward curved.
///   CENTRIFUGALAIRFOIL: Air flows through the impeller radially using blades are airfoil shaped.
///   TUBEAXIAL: Air flows through the impeller axially with reduced tip clearance and operating at higher tip speeds.
///   VANEAXIAL: Air flows through the impeller axially with guide vanes and reduced running blade tip clearance.
///   PROPELLORAXIAL: Air flows through the impeller axially and small hub-to-tip ratio impeller mounted in an orifice plate or inlet ring.
///   USERDEFINED:	User-defined fan type.
///   NOTDEFINED: Undefined fan type.
/// 
/// HISTORY: New enumeration in IFC 2x2.
typedef enum {IfcFanType_CENTRIFUGALFORWARDCURVED, IfcFanType_CENTRIFUGALRADIAL, IfcFanType_CENTRIFUGALBACKWARDINCLINEDCURVED, IfcFanType_CENTRIFUGALAIRFOIL, IfcFanType_TUBEAXIAL, IfcFanType_VANEAXIAL, IfcFanType_PROPELLORAXIAL, IfcFanType_USERDEFINED, IfcFanType_NOTDEFINED} IfcFanTypeEnum;
IFC_PARSE_API const char* ToString(IfcFanTypeEnum v);
IFC_PARSE_API IfcFanTypeEnum FromString(const std::string& s);
}
namespace IfcFastenerTypeEnum {
/// Definition from IAI: This enumeration defines the different types of fasteners, except for mechanical fasteners:
/// 
/// GLUE: A fastening connection where glue is used to join together elements.
/// MORTAR: A composition of mineralic or other materials used to fill jointing gaps and possibly fulfilling a load carrying role.
/// WELD: A weld seam between parts of metallic material or other suitable materials.
/// USERDEFINED: User-defined fastener
/// NOTDEFINED: Undefined fastener
/// 
/// HISTORY  New Enumeration in IFC 2x4.
typedef enum {IfcFastenerType_GLUE, IfcFastenerType_MORTAR, IfcFastenerType_WELD, IfcFastenerType_USERDEFINED, IfcFastenerType_NOTDEFINED} IfcFastenerTypeEnum;
IFC_PARSE_API const char* ToString(IfcFastenerTypeEnum v);
IFC_PARSE_API IfcFastenerTypeEnum FromString(const std::string& s);
}
namespace IfcFilterTypeEnum {
/// This enumeration defines the various types of filter typically used
///   within building services distribution systems:
/// 
/// AIRPARTICLEFILTER: A filter used to remove particulates from air.
///   COMPRESSEDAIRFILTER: A filter used to remove particulates from compressed air.
///   ODORFILTER: A filter used to remove odors from air.
///   OILFILTER: A filter used to remove particulates from oil.
///   STRAINER: A filter used to remove particulates from a fluid.
///   WATERFILTER: A filter used to remove particulates from water.
///   USERDEFINED:	User-defined filter type.
///   NOTDEFINED:	Undefined filter type.
/// 
/// HISTORY: New enumeration in IFC R2x.  COMPRESSEDAIRFILTER added in IFC2x4.
typedef enum {IfcFilterType_AIRPARTICLEFILTER, IfcFilterType_COMPRESSEDAIRFILTER, IfcFilterType_ODORFILTER, IfcFilterType_OILFILTER, IfcFilterType_STRAINER, IfcFilterType_WATERFILTER, IfcFilterType_USERDEFINED, IfcFilterType_NOTDEFINED} IfcFilterTypeEnum;
IFC_PARSE_API const char* ToString(IfcFilterTypeEnum v);
IFC_PARSE_API IfcFilterTypeEnum FromString(const std::string& s);
}
namespace IfcFireSuppressionTerminalTypeEnum {
/// The IfcFireSuppressionTerminalTypeEnum defines the range of different types of fire suppression terminal that can be specified. 
/// 
/// HISTORY: New type in IFC 2x2
/// 
/// Enumeration
/// 
/// BREECHINGINLET: Symmetrical pipe fitting that unites two or more inlets into a single pipe (BS6100 330 114 adapted). A breeching inlet may be used on either a wet or dry riser. Used by fire services personnel for fast connection of fire appliance hose reels. May also be used for foam. 
/// FIREHYDRANT: Device, fitted to a pipe, through which a temporary supply of water may be provided (BS6100 330 6107).  May also be termed a stand pipe. 
/// HOSEREEL: A supporting framework on which a hose may be wound (BS6100 155 8201). 
/// SPRINKLER: Device for sprinkling water from a pipe under pressure over an area (BS6100 100 3432). 
/// SPRINKLERDEFLECTOR: Device attached to a sprinkler to deflect the water flow into a spread pattern to cover the required area. 
/// USERDEFINED: User-defined type. 
/// NOTDEFINED: Underined type.
typedef enum {IfcFireSuppressionTerminalType_BREECHINGINLET, IfcFireSuppressionTerminalType_FIREHYDRANT, IfcFireSuppressionTerminalType_HOSEREEL, IfcFireSuppressionTerminalType_SPRINKLER, IfcFireSuppressionTerminalType_SPRINKLERDEFLECTOR, IfcFireSuppressionTerminalType_USERDEFINED, IfcFireSuppressionTerminalType_NOTDEFINED} IfcFireSuppressionTerminalTypeEnum;
IFC_PARSE_API const char* ToString(IfcFireSuppressionTerminalTypeEnum v);
IFC_PARSE_API IfcFireSuppressionTerminalTypeEnum FromString(const std::string& s);
}
namespace IfcFlowDirectionEnum {
/// This enumeration defines the flow direction at a port as either a SOURCE, SINK, or SOURCEANDSINK.  For solids, liquids, or gas, the direction is the physical flow direction.  For electric power (circuits containing hot, neutral, ground), the direction is from the origination of power (from a distribution board to protective devices to switches to fixtures).  For communication signals, the direction originates from where the signal is shaped, such as a sensor.  For communicaton networks, the direction originates from the up-level network host, such as a router (having SOURCE ports) hosting multiple computers (having SINK ports).
/// 
/// SOURCE:        A flow source, where a substance flows out of the connection.
///   SINK:          A flow sink, where a substance flows into the connection.
///   SOURCEANDSINK: Both a source and sink, where a substance flows both into and out of the connection simultaneously.
///   NOTDEFINED:    Undefined flow direction.
/// 
/// HISTORY: New enumeration in IFC R2.0
typedef enum {IfcFlowDirection_SOURCE, IfcFlowDirection_SINK, IfcFlowDirection_SOURCEANDSINK, IfcFlowDirection_NOTDEFINED} IfcFlowDirectionEnum;
IFC_PARSE_API const char* ToString(IfcFlowDirectionEnum v);
IFC_PARSE_API IfcFlowDirectionEnum FromString(const std::string& s);
}
namespace IfcFlowInstrumentTypeEnum {
/// The IfcFlowInstrumentTypeEnum defines the range of different types of flow instrument that can be specified. 
/// 
/// HISTORY: New type in IFC
///   2x2  
///   Enumeration 
/// 
/// PRESSUREGAUGE: A device that reads and displays a pressure value at a point or the pressure difference between two points. 
/// THERMOMETER: A device that reads and displays a temperature value at a point. 
/// AMMETER: A device that reads and displays the current flow in a circuit. 
/// FREQUENCYMETER: A device that reads and displays the electrical frequency of an alternating current circuit. 
/// PHASEANGLEMETER: A device that reads and displays the phase angle of a phase in a polyphase electrical circuit. 
/// POWERFACTORMETER: A device that reads and displays the power factor of an electrical circuit. 
/// VOLTMETER_PEAK: A device that reads and displays the peak voltage in an electrical circuit. 
/// VOLTMETER_RMS: A device that reads and displays the RMS (mean) voltage in an electrical circuit. 
/// USERDEFINED: User-defined type. 
/// NOTDEFINED: Undefined type.
typedef enum {IfcFlowInstrumentType_PRESSUREGAUGE, IfcFlowInstrumentType_THERMOMETER, IfcFlowInstrumentType_AMMETER, IfcFlowInstrumentType_FREQUENCYMETER, IfcFlowInstrumentType_POWERFACTORMETER, IfcFlowInstrumentType_PHASEANGLEMETER, IfcFlowInstrumentType_VOLTMETER_PEAK, IfcFlowInstrumentType_VOLTMETER_RMS, IfcFlowInstrumentType_USERDEFINED, IfcFlowInstrumentType_NOTDEFINED} IfcFlowInstrumentTypeEnum;
IFC_PARSE_API const char* ToString(IfcFlowInstrumentTypeEnum v);
IFC_PARSE_API IfcFlowInstrumentTypeEnum FromString(const std::string& s);
}
namespace IfcFlowMeterTypeEnum {
/// This enumeration defines various types of flow meter:
/// 
/// ENERGYMETER:   An electric meter or energy meter is a device that measures the amount of electrical energy supplied to or produced by a residence, business or machine.
/// 
/// GASMETER:   A device that measures the quantity of a gas or fuel.
/// 
/// OILMETER:   A device that measures the quantity of oil.
/// 
/// WATERMETER:   A device that measures the quantity of water.
/// 
/// USERDEFINED:   User-defined meter type
/// 
/// NOTDEFINED:    Undefined meter type
/// 
/// HISTORY: New enumeration in IFC 2x2
typedef enum {IfcFlowMeterType_ENERGYMETER, IfcFlowMeterType_GASMETER, IfcFlowMeterType_OILMETER, IfcFlowMeterType_WATERMETER, IfcFlowMeterType_USERDEFINED, IfcFlowMeterType_NOTDEFINED} IfcFlowMeterTypeEnum;
IFC_PARSE_API const char* ToString(IfcFlowMeterTypeEnum v);
IFC_PARSE_API IfcFlowMeterTypeEnum FromString(const std::string& s);
}
namespace IfcFootingTypeEnum {
/// Definition from IAI: Enumeration defining the generic footing type.
/// 
/// HISTORY New type in IFC Release 2x2
/// IFC 2x4 change:  Item CAISSON_FOUNDATION added
/// 
/// ENUMERATION 
/// 
/// CAISSON_FOUNDATION A foundation construction type used in underwater construction.
///   FOOTING_BEAM Footing elements that are in bending and are supported clear of the ground. They will normally span between piers, piles or pile caps. They are distinguished from beams in the building superstructure since they will normally require a lower grade of finish. They are distinguished from STRIP_FOOTING since they are clear of the ground surface and hence require support to the lower face while the concrete is curing.
///   PAD_FOOTING An element that transfers the load of a single column (possibly two) to the ground.
///   PILE_CAP An element that transfers the load from a column or group of columns to a pier or pile or group of piers or piles.
///   STRIP_FOOTING A linear element that transfers loads into the ground from either a continuous element, such as a wall, or from a series of elements, such as columns.
///   USERDEFINED Special types of footings which meet specific local requirements.
///   NOTDEFINED The type of footing is not defined.
typedef enum {IfcFootingType_CAISSON_FOUNDATION, IfcFootingType_FOOTING_BEAM, IfcFootingType_PAD_FOOTING, IfcFootingType_PILE_CAP, IfcFootingType_STRIP_FOOTING, IfcFootingType_USERDEFINED, IfcFootingType_NOTDEFINED} IfcFootingTypeEnum;
IFC_PARSE_API const char* ToString(IfcFootingTypeEnum v);
IFC_PARSE_API IfcFootingTypeEnum FromString(const std::string& s);
}
namespace IfcFurnitureTypeEnum {
/// IfcFurnitureTypeEnum defines the types of furniture from which the type required can be selected. 
///   HISTORY: New Enumeration in IFC 2x4. 
///   Enumeration: 
/// 
/// CHAIR: Furniture for seating a single person.  
/// TABLE: Furniture with a countertop for multiple people.  
/// DESK: Furniture with a countertop and optional drawers for a single person.  
/// BED: Furniture for sleeping.  
/// FILECABINET: Furniture with sliding drawers for storing files.  
/// SHELF: Furniture for storing books or other items.  
/// SOFA: Furniture for seating multiple people.  
/// USERDEFINED: User-defined type.  
/// NOTDEFINED: Undefined type.
typedef enum {IfcFurnitureType_CHAIR, IfcFurnitureType_TABLE, IfcFurnitureType_DESK, IfcFurnitureType_BED, IfcFurnitureType_FILECABINET, IfcFurnitureType_SHELF, IfcFurnitureType_SOFA, IfcFurnitureType_USERDEFINED, IfcFurnitureType_NOTDEFINED} IfcFurnitureTypeEnum;
IFC_PARSE_API const char* ToString(IfcFurnitureTypeEnum v);
IFC_PARSE_API IfcFurnitureTypeEnum FromString(const std::string& s);
}
namespace IfcGeographicElementTypeEnum {

typedef enum {IfcGeographicElementType_TERRAIN, IfcGeographicElementType_USERDEFINED, IfcGeographicElementType_NOTDEFINED} IfcGeographicElementTypeEnum;
IFC_PARSE_API const char* ToString(IfcGeographicElementTypeEnum v);
IFC_PARSE_API IfcGeographicElementTypeEnum FromString(const std::string& s);
}
namespace IfcGeometricProjectionEnum {
/// IfcGeometricProjectionEnum defines the various representation types that can be semantically distinguished. Often different levels of detail of the shape representation are controlled by the representation type.
/// 
/// GRAPH_VIEW:
/// Geometric display representation that shows an abstract, often 1D
/// element representation, e.g. representing a wall by its axis line.
///   SKETCH_VIEW:
/// Geometric display representation that shows an abstract, often 2D
/// element representation, e.g. representing a wall by its two foot print
/// edges, surpressing any inner layer representation.
///   MODEL_VIEW:
/// Geometric display representation that shows a full 3D element
/// representation, e.g. representing a wall by its volumetric body.
///   PLAN_VIEW:
/// Geometric display representation that shows a full 2D element
/// representation, the level of detail often depends on the target scale,
/// e.g. representing a wall by its two foot print edges and the edges of
/// all inner layers. The projection is shown in ground view as seen from
/// above.
///   REFLECTED_PLAN_VIEW:
/// Geometric display representation that shows a full 2D element
/// representation, the level of detail often depends on the target scale,
/// e.g. representing a wall by its two foot print edges and the edges of
/// all inner layers. The projection is shown in ground view as seen from
/// below.
///   SECTION_VIEW:
/// Geometric display representation that shows a full 2D element
/// representation, the level of detail often depends on the target scale,
/// e.g. representing a wall by its two inner/outer edges and the edges of
/// all inner layers, if the element is cut by the section line.
///   ELEVATION_VIEW:
/// Geometric display representation that shows a full 2D element
/// representation, the level of detail often depends on the target scale,
/// e.g. representing a wall by its bounding edges if the element is within
/// an elevation view.
///   USERDEFINED:
/// A user defined specification is given by the value of the UserDefinedTargetView
/// attribute.
///   NOTDEFINED:
/// No specification given.
/// 
/// HISTORY: New Type in Release IFC2x2.
typedef enum {IfcGeometricProjection_GRAPH_VIEW, IfcGeometricProjection_SKETCH_VIEW, IfcGeometricProjection_MODEL_VIEW, IfcGeometricProjection_PLAN_VIEW, IfcGeometricProjection_REFLECTED_PLAN_VIEW, IfcGeometricProjection_SECTION_VIEW, IfcGeometricProjection_ELEVATION_VIEW, IfcGeometricProjection_USERDEFINED, IfcGeometricProjection_NOTDEFINED} IfcGeometricProjectionEnum;
IFC_PARSE_API const char* ToString(IfcGeometricProjectionEnum v);
IFC_PARSE_API IfcGeometricProjectionEnum FromString(const std::string& s);
}
namespace IfcGlobalOrLocalEnum {
/// This enumeration type defines if the local object coordinate system or the global world coordinate system for the project is used to describe the measure values of entities which have a reference to this type.
/// 
/// NOTE  The world coordinate system is given by the IfcGeometricRepresentationContext.WorldCoordinateSystem
/// and is unique within the project. The local (or object) coordinate system is given by IfcProduct.ObjectPlacement and is used by all IfcRepresentation's within the IfcProduct.Representation.
/// 
/// HISTORY: New type in IFC2x2.
typedef enum {IfcGlobalOrLocal_GLOBAL_COORDS, IfcGlobalOrLocal_LOCAL_COORDS} IfcGlobalOrLocalEnum;
IFC_PARSE_API const char* ToString(IfcGlobalOrLocalEnum v);
IFC_PARSE_API IfcGlobalOrLocalEnum FromString(const std::string& s);
}
namespace IfcGridTypeEnum {

typedef enum {IfcGridType_RECTANGULAR, IfcGridType_RADIAL, IfcGridType_TRIANGULAR, IfcGridType_IRREGULAR, IfcGridType_USERDEFINED, IfcGridType_NOTDEFINED} IfcGridTypeEnum;
IFC_PARSE_API const char* ToString(IfcGridTypeEnum v);
IFC_PARSE_API IfcGridTypeEnum FromString(const std::string& s);
}
namespace IfcHeatExchangerTypeEnum {
/// Enumeration defining the typical types of heat exchangers. 
///   The IfcHeatExchangerTypeEnum contains the following:
/// 
/// PLATE: Plate heat exchanger.
///   SHELLANDTUBE: Shell and Tube heat exchanger.
///   USERDEFINED:  User-defined heat exchanger type.
///   NOTDEFINED:  Undefined heat exchanger type.
/// 
/// HISTORY: New enumeration in IFC R2x.
typedef enum {IfcHeatExchangerType_PLATE, IfcHeatExchangerType_SHELLANDTUBE, IfcHeatExchangerType_USERDEFINED, IfcHeatExchangerType_NOTDEFINED} IfcHeatExchangerTypeEnum;
IFC_PARSE_API const char* ToString(IfcHeatExchangerTypeEnum v);
IFC_PARSE_API IfcHeatExchangerTypeEnum FromString(const std::string& s);
}
namespace IfcHumidifierTypeEnum {
/// Enumeration defining the typical types of humidifiers. 
///   The IfcHumidifierTypeEnum contains the following:
/// 
/// STEAMINJECTION: Water vapor is added into the airstream through direction steam injection.
///   ADIABATICAIRWASHER: Water vapor is added into the airstream through adiabatic evaporation using an air washing element.
///   ADIABATICPAN:  Water vapor is added into the airstream through adiabatic evaporation using a pan.
///   ADIABATICWETTEDELEMENT: Water vapor is added into the airstream through adiabatic evaporation using a wetted element.
///   ADIABATICATOMIZING: Water vapor is added into the airstream through adiabatic evaporation using an atomizing element.
///   ADIABATICULTRASONIC: Water vapor is added into the airstream through adiabatic evaporation using an ultrasonic element.
///   ADIABATICRIGIDMEDIA: Water vapor is added into the airstream through adiabatic evaporation using a rigid media.
///   ADIABATICCOMPRESSEDAIRNOZZLE: Water vapor is added into the airstream through adiabatic evaporation using a compressed air nozzle.
///   ASSISTEDELECTRIC: Water vapor is added into the airstream through water heated evaporation using an electric heater.
///   ASSISTEDNATURALGAS: Water vapor is added into the airstream through water heated evaporation using a natural gas heater.
///   ASSISTEDPROPANE: Water vapor is added into the airstream through water heated evaporation using a propane heater.
///   ASSISTEDBUTANE: Water vapor is added into the airstream through water heated evaporation using a butane heater.
///   ASSISTEDSTEAM: Water vapor is added into the airstream through water heated evaporation using a steam heater.
///   USERDEFINED:  User-defined humidifier type.
///   NOTDEFINED:  Undefined humidifier type.
/// 
/// HISTORY: New enumeration in IFC 2x2.
typedef enum {IfcHumidifierType_STEAMINJECTION, IfcHumidifierType_ADIABATICAIRWASHER, IfcHumidifierType_ADIABATICPAN, IfcHumidifierType_ADIABATICWETTEDELEMENT, IfcHumidifierType_ADIABATICATOMIZING, IfcHumidifierType_ADIABATICULTRASONIC, IfcHumidifierType_ADIABATICRIGIDMEDIA, IfcHumidifierType_ADIABATICCOMPRESSEDAIRNOZZLE, IfcHumidifierType_ASSISTEDELECTRIC, IfcHumidifierType_ASSISTEDNATURALGAS, IfcHumidifierType_ASSISTEDPROPANE, IfcHumidifierType_ASSISTEDBUTANE, IfcHumidifierType_ASSISTEDSTEAM, IfcHumidifierType_USERDEFINED, IfcHumidifierType_NOTDEFINED} IfcHumidifierTypeEnum;
IFC_PARSE_API const char* ToString(IfcHumidifierTypeEnum v);
IFC_PARSE_API IfcHumidifierTypeEnum FromString(const std::string& s);
}
namespace IfcInterceptorTypeEnum {
/// The IfcInterceptorTypeEnum defines the range of different types of interceptor that can be specified. 
///   HISTORY: New type in IFC 2x4 
///   Enumeration 
/// 
/// CYCLONIC: Removes larger liquid drops or larger solid particles. 
/// GREASE: Chamber, on the line of a drain or discharge pipe, that prevents grease passing into a drainage system (BS6100 330 6205). 
/// OIL: One or more chambers arranged to prevent the ingress of oil to a drain or sewer, that retain the oil for later removal (BS6100 330 67316). 
/// PETROL: Two or more chambers with inlet and outlet pipes arranged to allow petrol/gasoline collected on the surface of water drained into them to evaporate through ventilating pipes. 
/// USERDEFINED: User-defined type. 
/// NOTDEFINED: Undefined type.
typedef enum {IfcInterceptorType_CYCLONIC, IfcInterceptorType_GREASE, IfcInterceptorType_OIL, IfcInterceptorType_PETROL, IfcInterceptorType_USERDEFINED, IfcInterceptorType_NOTDEFINED} IfcInterceptorTypeEnum;
IFC_PARSE_API const char* ToString(IfcInterceptorTypeEnum v);
IFC_PARSE_API IfcInterceptorTypeEnum FromString(const std::string& s);
}
namespace IfcInternalOrExternalEnum {
/// Definition from IAI: This enumeration defines the
/// different types of space boundaries in terms of either being
/// inside the building or outside the building.
/// Enumeration:
/// 
/// INTERNAL
/// 
/// IfcSpaceBoundary
/// The space boundary faces a physical
/// or virtual element where there is an internal space on the other
/// side.
/// 
/// EXTERNAL
/// 
/// IfcSpaceBoundary
/// The space boundary faces a physical
/// or virtual element where there is an external space on the other
/// side (i.e. air). Or it is the space boundary of that external
/// space against the building.
/// 
/// EXTERNAL_EARTH
/// 
/// IfcSpaceBoundary
/// The space boundary faces a physical
/// or virtual element where there is earth (or terrain) on the other
/// side. Or it is the space boundary of that earth (or terrain
/// object) external space against the building.
/// 
/// EXTERNAL_WATER
/// 
/// IfcSpaceBoundary
/// The space boundary faces a physical
/// or virtual element where there is water (water component of
/// terrain) on the other side. Or it is the space boundary of that
/// object representing water external space against the
/// building.
/// 
/// EXTERNAL_FIRE
/// 
/// IfcSpaceBoundary
/// The space boundary faces a physical
/// or virtual element where there is another building on the other
/// side. Or it is the space boundary of that other neighbor building
/// against the building in question.
/// 
/// NOTDEFINED
/// 
/// No information available.
/// 
/// HISTORY: New enumeration
/// in IFC Release 2.0
/// IFC2x4 CHANGE: Enumeration no longer
/// applicable to IfcSpace. The following enumerators are
/// added: EXTERNAL_EARTH, EXTERNAL_WATER,
/// EXTERNAL_FIRE.
typedef enum {IfcInternalOrExternal_INTERNAL, IfcInternalOrExternal_EXTERNAL, IfcInternalOrExternal_EXTERNAL_EARTH, IfcInternalOrExternal_EXTERNAL_WATER, IfcInternalOrExternal_EXTERNAL_FIRE, IfcInternalOrExternal_NOTDEFINED} IfcInternalOrExternalEnum;
IFC_PARSE_API const char* ToString(IfcInternalOrExternalEnum v);
IFC_PARSE_API IfcInternalOrExternalEnum FromString(const std::string& s);
}
namespace IfcInventoryTypeEnum {
/// IfcInventoryTypeEnum defines the types of inventory that can be defined. 
///   HISTORY: New Enumeration in IFC Release 2.0  
///   Enumeration: 
/// 
/// ASSETINVENTORY: A collection of asset instances of type IfcAsset 
/// SPACEINVENTORY: A collection of space instances of type IfcSpace 
/// FURNITUREINVENTORY: A collection of furniture instances of type IfcFurnishingElement 
/// USERDEFINED: User-defined type. 
/// NOTDEFINED: Undefined type.
typedef enum {IfcInventoryType_ASSETINVENTORY, IfcInventoryType_SPACEINVENTORY, IfcInventoryType_FURNITUREINVENTORY, IfcInventoryType_USERDEFINED, IfcInventoryType_NOTDEFINED} IfcInventoryTypeEnum;
IFC_PARSE_API const char* ToString(IfcInventoryTypeEnum v);
IFC_PARSE_API IfcInventoryTypeEnum FromString(const std::string& s);
}
namespace IfcJunctionBoxTypeEnum {
/// The IfcJunctionBoxTypeEnum defines the range of types of junction boxes available.
///   HISTORY: New type in IFC 2x2.  Values added in IFC 2x4. 
/// 
/// POWER: Contains cables, outlets, and/or switches for electrical power.
/// DATA: Contains cables, outlets, and/or switches for communications use.
/// USERDEFINED: User-defined type.
/// NOTDEFINED: Undefined type.
typedef enum {IfcJunctionBoxType_DATA, IfcJunctionBoxType_POWER, IfcJunctionBoxType_USERDEFINED, IfcJunctionBoxType_NOTDEFINED} IfcJunctionBoxTypeEnum;
IFC_PARSE_API const char* ToString(IfcJunctionBoxTypeEnum v);
IFC_PARSE_API IfcJunctionBoxTypeEnum FromString(const std::string& s);
}
namespace IfcKnotType {

typedef enum {IfcKnotType_UNIFORM_KNOTS, IfcKnotType_QUASI_UNIFORM_KNOTS, IfcKnotType_PIECEWISE_BEZIER_KNOTS, IfcKnotType_UNSPECIFIED} IfcKnotType;
IFC_PARSE_API const char* ToString(IfcKnotType v);
IFC_PARSE_API IfcKnotType FromString(const std::string& s);
}
namespace IfcLaborResourceTypeEnum {
/// This enumeration is used to identify the primary purpose of a labor resource, and is limited to high-level categories based upon common skillsets.  The IfcLaborResourceTypeEnum contains the following:
/// 
/// ADMINISTRATION: Coordination of work.
/// CARPENTRY: Rough carpentry including framing.
/// CLEANING: Removal of dust and debris.
/// DRYWALL: Gypsum wallboard placement and taping.
/// ELECTRIC: Electrical fixtures, equipment, and cables.
/// FINISHING: Finish carpentry including custom cabinetry.
/// FLOORING: Carpet, tile, terazzo, wood, or other flooring.
/// HVAC: Heating and ventilation fixtures, equipment, and ducts.
/// GENERAL: General labor not requiring specific skill.
/// LANDSCAPING: Grass, plants, trees, or irrigation.
/// MASONRY: Laying bricks or blocks with mortar.
/// PAINTING: Applying decorative coatings or coverings.
/// PAVING: Asphalt or concrete roads and walkways.
/// PLUMBING: Plumbing fixtures, equipment, and pipes.
/// ROOFING: Membranes, shingles, tile, or other roofing.
/// SITEGRADING: Excavating, filling, or contouring earth.
/// STEELWORK: Erecting and attaching steel elements.
/// SURVEYING: Determining positions, distances, and angles.
/// USERDEFINED: User-defined resource.
/// NOTDEFINED: Undefined resource.
/// 
/// HISTORY: New enumeration in IFC2x4
typedef enum {IfcLaborResourceType_ADMINISTRATION, IfcLaborResourceType_CARPENTRY, IfcLaborResourceType_CLEANING, IfcLaborResourceType_CONCRETE, IfcLaborResourceType_DRYWALL, IfcLaborResourceType_ELECTRIC, IfcLaborResourceType_FINISHING, IfcLaborResourceType_FLOORING, IfcLaborResourceType_GENERAL, IfcLaborResourceType_HVAC, IfcLaborResourceType_LANDSCAPING, IfcLaborResourceType_MASONRY, IfcLaborResourceType_PAINTING, IfcLaborResourceType_PAVING, IfcLaborResourceType_PLUMBING, IfcLaborResourceType_ROOFING, IfcLaborResourceType_SITEGRADING, IfcLaborResourceType_STEELWORK, IfcLaborResourceType_SURVEYING, IfcLaborResourceType_USERDEFINED, IfcLaborResourceType_NOTDEFINED} IfcLaborResourceTypeEnum;
IFC_PARSE_API const char* ToString(IfcLaborResourceTypeEnum v);
IFC_PARSE_API IfcLaborResourceTypeEnum FromString(const std::string& s);
}
namespace IfcLampTypeEnum {
/// The IfcLampTypeEnum defines the range of different types of lamp available. 
/// 
/// HISTORY: New type in IFC 2x2 Addendum
///   1  
///   Enumeration 
/// 
/// COMPACTFLUORESCENT: A fluorescent lamp having a compact form factor produced by shaping the tube. 
/// FLUORESCENT: A typically tubular discharge lamp in which most of the light is emitted by one or several layers of phosphors excited by ultraviolet radiation from the discharge.
/// HALOGEN: an incandescent lamp in which a tungsten filament is sealed into a compact transport envelope filled with an inert gas and a small amount of halogen such as iodine or bromine.
/// HIGHPRESSUREMERCURY: A discharge lamp in which most of the light is emitted by exciting mercury at high pressure.
/// HIGHPRESSURESODIUM: A discharge lamp in which most of the light is emitted by exciting sodium at high pressure.
/// LED: a solid state lamp that uses light-emitting diodes as the source of light.
/// METALHALIDE: A discharge lamp in which most of the light is emitted by exciting a metal halide.
/// OLED: a solid state lamp that uses light-emitting diodes as the source of light whose emissive electroluminescent layer is composed of a film of organic compounds.
/// TUNGSTENFILAMENT: A lamp that emits light by passing an electrical current through a tungsten wire filament in a near vacuum.
/// USERDEFINED: User-defined type.
/// NOTDEFINED: Undefined type.
typedef enum {IfcLampType_COMPACTFLUORESCENT, IfcLampType_FLUORESCENT, IfcLampType_HALOGEN, IfcLampType_HIGHPRESSUREMERCURY, IfcLampType_HIGHPRESSURESODIUM, IfcLampType_LED, IfcLampType_METALHALIDE, IfcLampType_OLED, IfcLampType_TUNGSTENFILAMENT, IfcLampType_USERDEFINED, IfcLampType_NOTDEFINED} IfcLampTypeEnum;
IFC_PARSE_API const char* ToString(IfcLampTypeEnum v);
IFC_PARSE_API IfcLampTypeEnum FromString(const std::string& s);
}
namespace IfcLayerSetDirectionEnum {
/// IfcLayerSetDirectionEnum provides identification of the axis of element geometry, denoting the layer set thickness direction, or direction of layer offsets.
/// 
/// ENUMERATION
/// 
/// AXIS1: Usually x-axis.
/// AXIS2: Usually y-axis.
/// AXIS3: Usually z-axis.
/// 
/// HISTORY: New Type in IFC2x.
typedef enum {IfcLayerSetDirection_AXIS1, IfcLayerSetDirection_AXIS2, IfcLayerSetDirection_AXIS3} IfcLayerSetDirectionEnum;
IFC_PARSE_API const char* ToString(IfcLayerSetDirectionEnum v);
IFC_PARSE_API IfcLayerSetDirectionEnum FromString(const std::string& s);
}
namespace IfcLightDistributionCurveEnum {
/// There are three kinds of light distribution curves, according to Standard CEN TC 169, prEN 13032-1, CIE 121: 
/// 
/// TYPE_A: Type A is basically not used. For completeness the Type A Photometry equals the Type B rotated 90° around the Z-Axis counter clockwise. 
/// TYPE_B: Type B is sometimes used for floodlights. The B-Plane System has a horizontal axis. B-Angles are valid from -180° to +180° with B 0° at the bottom and B180°/B-180° at the top, &#946;-Angles are valid from -90° to +90°. (See Figure 302.)
/// TYPE_C: Type C is the recommended standard system. The C-Plane system equals a globe with a vertical axis. C-Angles are valid from 0° to 360°, &#947;-Angles are valid from 0° (south pole) to 180° (north pole). (See Figure 302.) 
/// 
/// <table
/// 
/// B-Type System 
///   C-Type System 
/// 
/// Figure 302 — Light distribution curves
/// 
/// HISTORY  This is a new enumeration in IFC2x2.
typedef enum {IfcLightDistributionCurve_TYPE_A, IfcLightDistributionCurve_TYPE_B, IfcLightDistributionCurve_TYPE_C, IfcLightDistributionCurve_NOTDEFINED} IfcLightDistributionCurveEnum;
IFC_PARSE_API const char* ToString(IfcLightDistributionCurveEnum v);
IFC_PARSE_API IfcLightDistributionCurveEnum FromString(const std::string& s);
}
namespace IfcLightEmissionSourceEnum {
/// IfcLightEmissionSourceEnum defines the range of different types of light emitter available. 
/// 
/// HISTORY: New type in IFC2x2.
/// 
/// Enumeration 
/// 
/// COMPACTFLUORESCENT
/// FLUORESCENT
/// HIGHPRESSUREMERCURY
/// HIGHPRESSURESODIUM
/// LIGHTEMITTINGDIODE
/// LOWPRESSURESODIUM
/// LOWVOLTAGEHALOGEN
/// MAINVOLTAGEHALOGEN
/// METALHALIDE 
/// TUNGSTENFILAMENT 
/// NOTDEFINED
typedef enum {IfcLightEmissionSource_COMPACTFLUORESCENT, IfcLightEmissionSource_FLUORESCENT, IfcLightEmissionSource_HIGHPRESSUREMERCURY, IfcLightEmissionSource_HIGHPRESSURESODIUM, IfcLightEmissionSource_LIGHTEMITTINGDIODE, IfcLightEmissionSource_LOWPRESSURESODIUM, IfcLightEmissionSource_LOWVOLTAGEHALOGEN, IfcLightEmissionSource_MAINVOLTAGEHALOGEN, IfcLightEmissionSource_METALHALIDE, IfcLightEmissionSource_TUNGSTENFILAMENT, IfcLightEmissionSource_NOTDEFINED} IfcLightEmissionSourceEnum;
IFC_PARSE_API const char* ToString(IfcLightEmissionSourceEnum v);
IFC_PARSE_API IfcLightEmissionSourceEnum FromString(const std::string& s);
}
namespace IfcLightFixtureTypeEnum {
/// The IfcLightFixtureTypeEnum defines the range of different types of light fixture available.
/// 
/// HISTORY: New type in IFC 2x Edition 2IFC 2x4: SECURITYLIGHTING added
/// 
/// Enumeration
/// 
/// POINTSOURCE: A light fixture that is considered to have negligible area and that emit light with approximately equal intensity in all directions.  A light fixture containing a tungsten, halogen or similar bulb is an example of a point source.
/// DIRECTIONSOURCE: A light fixture that is considered to have a length or surface area from which it emits light in a direction. A light fixture containing one or more fluorescent lamps is an example of a direction source. 
/// SECURITYLIGHTING: A light fixture having specific purpose of directing occupants in an emergency, such as an illuminated exit sign or emergency flood light. 
/// USERDEFINED: User-defined type.
/// NOTDEFINED: Undefined type.
typedef enum {IfcLightFixtureType_POINTSOURCE, IfcLightFixtureType_DIRECTIONSOURCE, IfcLightFixtureType_SECURITYLIGHTING, IfcLightFixtureType_USERDEFINED, IfcLightFixtureType_NOTDEFINED} IfcLightFixtureTypeEnum;
IFC_PARSE_API const char* ToString(IfcLightFixtureTypeEnum v);
IFC_PARSE_API IfcLightFixtureTypeEnum FromString(const std::string& s);
}
namespace IfcLoadGroupTypeEnum {
/// Definition from IAI: This type definition is used to distinguish between different levels
/// of load grouping.  It allows to differentiate between load groups, load cases, and load combinations.
/// Normally, these enumeration types shall be used in the following context:
/// 
/// LOAD_GROUP groups instances of subtypes of IfcStructuralAction.  It shall be used as a
///   container for loads grouped together for specific purposes, e.g. loads which are part of a
///   special load pattern.
///   LOAD_CASE groups LOAD_GROUPs and instances of subtypes of IfcStructuralAction.
///   It should be used as a container for loads with the same origin.
///   LOAD_COMBINATION_GROUP is an intermediate level between LOAD_CASE and LOAD_COMBINATION.
///   The purpose of this level is to provide a factor with which one or more LOAD_CASEs occur in a
///   LOAD_COMBINATION.  This factor cannot be specified directly at the load case if the load case
///   is meant to occur in more than one combination with different factors.
///   This intermediate level is obsolete.  Instead, 
///   LOAD_COMBINATION is used to group load cases which act together into a load combination.
///   USERDEFINED:  A grouping level which does not follow the standard hierarchy of load group types.
///   NOTDEFINED:  The grouping level is not yet known.
/// 
/// HISTORY: New type in IFC 2x2.
/// 
/// IFC 2x4 change:  Obsolete item LOAD_COMBINATION_GROUP removed.  Load cases are directly assigned to load combinations with different factors for each load case—load combination pair by means of IfcRelAssignsToGroupByFactor.
typedef enum {IfcLoadGroupType_LOAD_GROUP, IfcLoadGroupType_LOAD_CASE, IfcLoadGroupType_LOAD_COMBINATION, IfcLoadGroupType_USERDEFINED, IfcLoadGroupType_NOTDEFINED} IfcLoadGroupTypeEnum;
IFC_PARSE_API const char* ToString(IfcLoadGroupTypeEnum v);
IFC_PARSE_API IfcLoadGroupTypeEnum FromString(const std::string& s);
}
namespace IfcLogicalOperatorEnum {
/// Definition: IfcLogicalOperatorEnum is an enumeration that defines the logical operators that may be applied for the satisfaction of one or more operands (IfcConstraint) at a time. 
/// 
/// HISTORY  New type in IFC Release 2.0.  Renamed from IfcConstraintAggregatorEnum in IFC 2x2
/// 
/// IFC2x4 CHANGE: Extended to include LOGICALXOR, LOGICALNOTAND and LOGICALNOTOR.
/// 
/// Enumeration 
/// 
/// Value 
///   Definition 
/// 
/// LOGICALAND 
///   Defines a relationship between operands whereby the result is true if all operands are true, i.e. false if at least 
/// 
/// one operand is false. 
/// 
/// LOGICALOR 
///   Defines a relationship between operands whereby the result is true if at least one operand is true, i.e false if 
/// 
/// all operands are false. 
/// 
/// LOGICALXOR 
///   Defines a relationship between operands whereby the result is true if exactly one operand is true (exclusive or). 
/// 
/// LOGICALNOTAND 
///   Defines a relationship between operands whereby the result is true if at least one operand is false, i.e false if 
/// 
/// all operands are true. 
/// 
/// LOGICALNOTOR 
///   Defines a relationship between operands whereby the result is true if all operands are false, i.e false if at least 
/// 
/// one operand is true. 
/// 
/// Use Definition 
/// 
/// The IfcLogicalOperatorEnum, when applied in a case of three operands, A, B and C, evaluates for each operator as 
/// 
/// follows:
/// 
/// TRUTH TABLE: LOGICALAND(A,B,C)
/// 
/// A
/// F
/// F
/// F
/// T
/// F
/// T
/// T
/// T
/// 
/// B
/// F
/// F
/// T
/// F
/// T
/// F
/// T
/// T
/// 
/// C
/// F
/// T
/// F
/// F
/// T
/// T
/// F
/// T
/// 
/// AND
/// F
/// F
/// F
/// F
/// F
/// F
/// F
/// T
/// 
/// TRUTH TABLE: LOGICALOR(A,B,C)
/// 
/// A
/// F
/// F
/// F
/// T
/// F
/// T
/// T
/// T
/// 
/// B
/// F
/// F
/// T
/// F
/// T
/// F
/// T
/// T
/// 
/// C
/// F
/// T
/// F
/// F
/// T
/// T
/// F
/// T
/// 
/// OR
/// F
/// T
/// T
/// T
/// T
/// T
/// T
/// T
/// 
/// TRUTH TABLE: LOGICALXOR(A,B,C)
/// 
/// A
/// F
/// F
/// F
/// T
/// F
/// T
/// T
/// T
/// 
/// B
/// F
/// F
/// T
/// F
/// T
/// F
/// T
/// T
/// 
/// C
/// F
/// T
/// F
/// F
/// T
/// T
/// F
/// T
/// 
/// XOR
/// F
/// T
/// T
/// T
/// F
/// F
/// F
/// F
/// 
/// TRUTH TABLE: LOGICALNOTAND(A,B,C)
/// 
/// A
/// F
/// F
/// F
/// T
/// F
/// T
/// T
/// T
/// 
/// B
/// F
/// F
/// T
/// F
/// T
/// F
/// T
/// T
/// 
/// C
/// F
/// T
/// F
/// F
/// T
/// T
/// F
/// T
/// 
/// NOTAND
/// T
/// T
/// T
/// T
/// T
/// T
/// T
/// F
/// 
/// TRUTH TABLE: LOGICALNOTOR(A,B,C)
/// 
/// A
/// F
/// F
/// F
/// T
/// F
/// T
/// T
/// T
/// 
/// B
/// F
/// F
/// T
/// F
/// T
/// F
/// T
/// T
/// 
/// C
/// F
/// T
/// F
/// F
/// T
/// T
/// F
/// T
/// 
/// NOTOR
/// T
/// F
/// F
/// F
/// F
/// F
/// F
/// F
typedef enum {IfcLogicalOperator_LOGICALAND, IfcLogicalOperator_LOGICALOR, IfcLogicalOperator_LOGICALXOR, IfcLogicalOperator_LOGICALNOTAND, IfcLogicalOperator_LOGICALNOTOR} IfcLogicalOperatorEnum;
IFC_PARSE_API const char* ToString(IfcLogicalOperatorEnum v);
IFC_PARSE_API IfcLogicalOperatorEnum FromString(const std::string& s);
}
namespace IfcMechanicalFastenerTypeEnum {
/// Definition from IAI: This enumeration defines the
/// different types of mechanical fasteners:
/// 
/// ANCHORBOLT: A special bolt which is anchored into conrete, stone, or brickwork.
/// BOLT: A threaded cylindrical rod that engages with a similarly threaded hole in a nut or any other part to form a fastener. The mechanical fastener often also includes one or more washers and one or more nuts.
/// DOWEL: A cylindrical rod that is driven into holes of the connected pieces.
/// NAIL: A thin pointed piece of metal that is hammered into materials as a fastener.
/// NAILPLATE: A piece of sheet metal with punched points that overlaps the connected pieces and is pressed into their material.
/// RIVET: A fastening part having a head at one end and the other end being hammered flat after being passed through holes in the pieces that are fastened together.
/// SCREW: A fastener with a tapered threaded shank and a slotted head.
/// SHEARCONNECTOR: A ring connector that is accepted by ring keyways in the connected pieces; or a toothed circular or square connector that is pressed into the connected pieces.
/// STAPLE: A doubly pointed piece of metal that is hammered into materials as a fastener.
/// STUDSHEARCONNECTOR: Stud shear connectors are cylindrical fastening parts with a head on one side. On the other side they are welded on steel members for the use in composite steel and concrete structures.
/// USERDEFINED: User-defined mechanical fastener
/// NOTDEFINED: Undefined mechanical fastener
/// 
/// HISTORY  New Enumeration in IFC 2x4.
typedef enum {IfcMechanicalFastenerType_ANCHORBOLT, IfcMechanicalFastenerType_BOLT, IfcMechanicalFastenerType_DOWEL, IfcMechanicalFastenerType_NAIL, IfcMechanicalFastenerType_NAILPLATE, IfcMechanicalFastenerType_RIVET, IfcMechanicalFastenerType_SCREW, IfcMechanicalFastenerType_SHEARCONNECTOR, IfcMechanicalFastenerType_STAPLE, IfcMechanicalFastenerType_STUDSHEARCONNECTOR, IfcMechanicalFastenerType_USERDEFINED, IfcMechanicalFastenerType_NOTDEFINED} IfcMechanicalFastenerTypeEnum;
IFC_PARSE_API const char* ToString(IfcMechanicalFastenerTypeEnum v);
IFC_PARSE_API IfcMechanicalFastenerTypeEnum FromString(const std::string& s);
}
namespace IfcMedicalDeviceTypeEnum {
/// Enumeration defining the functional type of medical device.
/// 
/// The IfcMedicalDeviceTypeEnum contains the following:
/// 
/// AIRSTATION: Device that provides purified medical air, composed of an air compressor and air treatment line.
/// FEEDERUNIT: Device that feeds air to an oxygen generator, composed of an air compressor, air treatment line, and an air receiver.
/// OXYGENGENERATOR: Device that generates oxygen from air.
/// OXYGENPLANT: Device that combines a feed air unit, oxygen generator, and backup oxygen cylinders.
/// VACUUMSTATION: Device that provides suction, composed of a vacuum pump and bacterial filtration line.
/// USERDEFINED: User-defined medical device type.
/// NOTDEFINED:  Undefined medical device type.
/// 
/// HISTORY: New enumeration in IFC 2x4.
typedef enum {IfcMedicalDeviceType_AIRSTATION, IfcMedicalDeviceType_FEEDAIRUNIT, IfcMedicalDeviceType_OXYGENGENERATOR, IfcMedicalDeviceType_OXYGENPLANT, IfcMedicalDeviceType_VACUUMSTATION, IfcMedicalDeviceType_USERDEFINED, IfcMedicalDeviceType_NOTDEFINED} IfcMedicalDeviceTypeEnum;
IFC_PARSE_API const char* ToString(IfcMedicalDeviceTypeEnum v);
IFC_PARSE_API IfcMedicalDeviceTypeEnum FromString(const std::string& s);
}
namespace IfcMemberTypeEnum {
/// Definition from IAI: This enumeration defines the
/// different types of linear elements an IfcMemberType object
/// can fulfill:
/// 
/// BRACE: A linear element (usually sloped) often used
/// for bracing of a girder or truss.
/// CHORD: Upper or lower longitudinal member of a truss,
/// used horizontally or sloped.
/// COLLAR: A linear element (usually used horizontally)
/// within a roof structure to connect rafters and posts.
/// MEMBER: A linear element within a girder or truss with
/// no further meaning.
/// MULLION: A linear element within a curtain wall system
/// to connect two (or more) panels.
/// PLATE: A linear continuous horizontal element in wall
/// framing, e.g. a head piece or a sole plate.
/// 
/// NOTE  This head piece or sole plate shall not
/// be mixed up with planar elements, such as sheets and panels, that
/// are handled as IfcPlate (and
/// IfcPlateType).
/// 
/// POST: A linear member (usually used vertically) within
/// a roof structure to support purlins.
/// PURLIN: A linear element (usually used horizontally)
/// within a roof structure to support rafters
/// RAFTER: A linear elements used to support roof slabs
/// or roof covering, usually used with slope.
/// STRINGER: A linear element used to support stair or
/// ramp flights, usually used with slope.
/// STRUT: A linear element often used within a girder or
/// truss.
/// STUD: Vertical element in wall framing.
/// USERDEFINED: User-defined linear element.
/// NOTDEFINED: Undefined linear element
/// 
/// HISTORY: New
/// Enumeration in Release IFC2x Edition 2.
/// IFC2x Edition 2
/// Addendum 1 CHANGE  The additional identifiers CHORD, PLATE, STUD
/// are added.
/// IFC2x Edition 3 CHANGE  The additional identifier MULLION has
/// been added.
typedef enum {IfcMemberType_BRACE, IfcMemberType_CHORD, IfcMemberType_COLLAR, IfcMemberType_MEMBER, IfcMemberType_MULLION, IfcMemberType_PLATE, IfcMemberType_POST, IfcMemberType_PURLIN, IfcMemberType_RAFTER, IfcMemberType_STRINGER, IfcMemberType_STRUT, IfcMemberType_STUD, IfcMemberType_USERDEFINED, IfcMemberType_NOTDEFINED} IfcMemberTypeEnum;
IFC_PARSE_API const char* ToString(IfcMemberTypeEnum v);
IFC_PARSE_API IfcMemberTypeEnum FromString(const std::string& s);
}
namespace IfcMotorConnectionTypeEnum {
/// The IfcMotorConnectionTypeEnum defines the range of different types of motor connection that can be specified. 
///   HISTORY: New type in IFC 2x.  
///   Enumeration 
/// 
/// BELTDRIVE: An indirect connection made through the medium of a shaped, flexible continuous loop. 
/// COUPLING: An indirect connection made through the medium of the viscosity of a fluid. 
/// DIRECTDRIVE: A direct, physical connection made between the motor and the driven device. 
/// USERDEFINED: User-defined type. 
/// NOTDEFINED: Undefined type.
typedef enum {IfcMotorConnectionType_BELTDRIVE, IfcMotorConnectionType_COUPLING, IfcMotorConnectionType_DIRECTDRIVE, IfcMotorConnectionType_USERDEFINED, IfcMotorConnectionType_NOTDEFINED} IfcMotorConnectionTypeEnum;
IFC_PARSE_API const char* ToString(IfcMotorConnectionTypeEnum v);
IFC_PARSE_API IfcMotorConnectionTypeEnum FromString(const std::string& s);
}
namespace IfcNullStyle {
/// Definition from ISO/CD 10303-46:1992: The null style type specifies, that a representation item is not styled.
/// 
/// NOTE  Corresponding ISO 10303 name: null_style. Please refer to ISO/IS 10303-46:1994 for the final
/// definition of the formal standard.
/// 
/// HISTORY  New enumeration in IFC2x2.
/// 
/// IFC2x4 CHANGE  The enumeration is deprecated.
typedef enum {IfcNullStyle_NULL} IfcNullStyle;
IFC_PARSE_API const char* ToString(IfcNullStyle v);
IFC_PARSE_API IfcNullStyle FromString(const std::string& s);
}
namespace IfcObjectTypeEnum {
/// This enumeration defines the applicable object categories, that is, the subtypes at the 2nd level of the IFC inheritance tree. Attached to an object, it indicates to which subtype of IfcObject the entity referencing it would otherwise comply with. 
/// 
/// HISTORY New entity in IFC Release 1.0, has been renamed from IfcProxyEnum in IFC 2x.
typedef enum {IfcObjectType_PRODUCT, IfcObjectType_PROCESS, IfcObjectType_CONTROL, IfcObjectType_RESOURCE, IfcObjectType_ACTOR, IfcObjectType_GROUP, IfcObjectType_PROJECT, IfcObjectType_NOTDEFINED} IfcObjectTypeEnum;
IFC_PARSE_API const char* ToString(IfcObjectTypeEnum v);
IFC_PARSE_API IfcObjectTypeEnum FromString(const std::string& s);
}
namespace IfcObjectiveEnum {
/// IfcObjectiveEnum is an enumeration used to determine the objective for which purpose the constraint needs to be satisfied. 
/// 
/// HISTORY: IFC2x4 CHANGE: Extended to include CODEWAIVER.
/// 
/// Enumeration 
/// 
/// Value 
///   Definition 
/// 
/// CODECOMPLIANCE 
///   A constraint whose objective is to ensure satisfaction of a code compliance provision. 
/// 
/// CODEWAIVER 
///   A constraint whose objective is to identify an agreement that code compliance requirements (the waiver) will not be enforced. 
/// 
/// DESIGNINTENT 
///   A constraint whose objective is to ensure satisfaction of a design intent provision. 
/// 
/// HEALTHANDSAFETY 
///   A constraint whose objective is to ensure satisfaction of a health and safety provision. 
/// 
/// REQUIREMENT 
///   A constraint whose objective is to ensure satisfaction of a project requirement provision. 
/// 
/// SPECIFICATION 
///   A constraint whose objective is to ensure satisfaction of a specification provision. 
/// 
/// TRIGGERCONDITION 
///   A constraint whose objective is to indicate a limiting value beyond which the condition of an object requires a particular form of attention.
typedef enum {IfcObjective_CODECOMPLIANCE, IfcObjective_CODEWAIVER, IfcObjective_DESIGNINTENT, IfcObjective_EXTERNAL, IfcObjective_HEALTHANDSAFETY, IfcObjective_MERGECONFLICT, IfcObjective_MODELVIEW, IfcObjective_PARAMETER, IfcObjective_REQUIREMENT, IfcObjective_SPECIFICATION, IfcObjective_TRIGGERCONDITION, IfcObjective_USERDEFINED, IfcObjective_NOTDEFINED} IfcObjectiveEnum;
IFC_PARSE_API const char* ToString(IfcObjectiveEnum v);
IFC_PARSE_API IfcObjectiveEnum FromString(const std::string& s);
}
namespace IfcOccupantTypeEnum {
/// IfcOccupantTypeEnum defines the types of occupant from which the type required can be selected. 
///   HISTORY: New Enumeration in IFC Release 2.0 Modified in IFC 2x2 
///   Enumeration: 
/// 
/// ASSIGNEE: Actor receiving the assignment of a property agreement from an assignor  
/// ASSIGNOR: Actor assigning a property agreement to an assignor  
/// LESSEE: Actor receiving the lease of a property from a lessor  
/// LESSOR: Actor leasing a property to a lessee  
/// LETTINGAGENT: Actor participating in a property agreement on behalf of an owner, lessor or assignor  
/// OWNER: Actor that owns a property  
/// TENANT: Actor renting the use of a property fro a period of time  
/// USERDEFINED: User-defined type.  
/// NOTDEFINED: Undefined type.
typedef enum {IfcOccupantType_ASSIGNEE, IfcOccupantType_ASSIGNOR, IfcOccupantType_LESSEE, IfcOccupantType_LESSOR, IfcOccupantType_LETTINGAGENT, IfcOccupantType_OWNER, IfcOccupantType_TENANT, IfcOccupantType_USERDEFINED, IfcOccupantType_NOTDEFINED} IfcOccupantTypeEnum;
IFC_PARSE_API const char* ToString(IfcOccupantTypeEnum v);
IFC_PARSE_API IfcOccupantTypeEnum FromString(const std::string& s);
}
namespace IfcOpeningElementTypeEnum {
/// Definition from IAI: An enumeration defining the basic
/// types for opening elements.
/// 
/// HISTORY New enumeration type in
/// IFC2x4.
/// 
/// Enumeration
/// 
/// OPENING: An opening as subtraction
/// feature that cuts through the element it voids. It thereby
/// creates a hole. An opening in addiion have a particular meaning
/// for either providing a void for doors or windows, or an opening
/// to permit flow of air and passing of light,
/// RECESS: A opening as subtraction
/// feature that does not cut through the element it voids. It
/// creates a niche or similar voiding pattern.
/// USERDEFINED: User-defined opening
/// element
/// NOTDEFINED: Undefined opening
/// element
typedef enum {IfcOpeningElementType_OPENING, IfcOpeningElementType_RECESS, IfcOpeningElementType_USERDEFINED, IfcOpeningElementType_NOTDEFINED} IfcOpeningElementTypeEnum;
IFC_PARSE_API const char* ToString(IfcOpeningElementTypeEnum v);
IFC_PARSE_API IfcOpeningElementTypeEnum FromString(const std::string& s);
}
namespace IfcOutletTypeEnum {
/// The IfcOutletTypeEnum defines the range of different types of outlet that can be specified. 
/// 
/// HISTORY: New type in IFC 2x. Telephone and Data outlets added in IFC 2x4
/// 
/// Enumeration 
/// 
/// AUDIOVISUALOUTLET: An outlet used for an audio or visual device. 
/// COMMUNICATIONSOUTLET: An outlet used for connecting communications equipment. 
/// POWEROUTLET: An outlet used for connecting electrical devices requiring power.  
/// DATAOUTLET: An outlet used for connecting data communications equipment. 
/// TELEPHONEOUTLET: An outlet used for connecting telephone communications equipment.  
/// USERDEFINED: User-defined type. 
/// NOTDEFINED: Undefined type.
typedef enum {IfcOutletType_AUDIOVISUALOUTLET, IfcOutletType_COMMUNICATIONSOUTLET, IfcOutletType_POWEROUTLET, IfcOutletType_DATAOUTLET, IfcOutletType_TELEPHONEOUTLET, IfcOutletType_USERDEFINED, IfcOutletType_NOTDEFINED} IfcOutletTypeEnum;
IFC_PARSE_API const char* ToString(IfcOutletTypeEnum v);
IFC_PARSE_API IfcOutletTypeEnum FromString(const std::string& s);
}
namespace IfcPerformanceHistoryTypeEnum {
/// This enumeration is used to identify the primary purpose of performance history.  The IfcPerformanceHistoryTypeEnum contains the following:
/// 
/// USERDEFINED: User-defined.
/// NOTDEFINED: Undefined.
/// 
/// HISTORY: New enumeration in IFC2x4
typedef enum {IfcPerformanceHistoryType_USERDEFINED, IfcPerformanceHistoryType_NOTDEFINED} IfcPerformanceHistoryTypeEnum;
IFC_PARSE_API const char* ToString(IfcPerformanceHistoryTypeEnum v);
IFC_PARSE_API IfcPerformanceHistoryTypeEnum FromString(const std::string& s);
}
namespace IfcPermeableCoveringOperationEnum {
/// Definition: Enumeration defining the valid types of permeable coverings. 
/// 
/// Enumeration:
/// 
/// GRILL 
///   protective screen of metal bars or wires
/// 
/// LOUVER 
///   set of fixed or movable strips of wood, metal, etc. arranged to let
///   air in while keeping light or rain out
/// 
/// SCREEN 
///   upright, fixed or movable, sometimes folding framework used for
///   protection against heat, light, access or similar
/// 
/// USERDEFINED 
///   user defined permeable covering type
/// 
/// NOTDEFINED 
///   no information available
/// 
/// HISTORY: New Enumeration in IFC Release 2.0
typedef enum {IfcPermeableCoveringOperation_GRILL, IfcPermeableCoveringOperation_LOUVER, IfcPermeableCoveringOperation_SCREEN, IfcPermeableCoveringOperation_USERDEFINED, IfcPermeableCoveringOperation_NOTDEFINED} IfcPermeableCoveringOperationEnum;
IFC_PARSE_API const char* ToString(IfcPermeableCoveringOperationEnum v);
IFC_PARSE_API IfcPermeableCoveringOperationEnum FromString(const std::string& s);
}
namespace IfcPermitTypeEnum {
/// IfcPermitTypeEnum defines the types of permits that can be granted. 
///   HISTORY: New Enumeration in IFC2x4. 
///   Enumeration: 
/// 
/// ACCESS: Enables access to an identified area. 
/// BUILDING: Enables work to proceed by getting regulatory permissions. 
/// WORK: Enables work to be carried out in an identified area. 
/// USERDEFINED: User-defined type. 
/// NOTDEFINED: Undefined type.
typedef enum {IfcPermitType_ACCESS, IfcPermitType_BUILDING, IfcPermitType_WORK, IfcPermitType_USERDEFINED, IfcPermitType_NOTDEFINED} IfcPermitTypeEnum;
IFC_PARSE_API const char* ToString(IfcPermitTypeEnum v);
IFC_PARSE_API IfcPermitTypeEnum FromString(const std::string& s);
}
namespace IfcPhysicalOrVirtualEnum {
/// Definition from IAI: This enumeration defines the
///   different types of space boundaries in terms of its
///   physical manifestation. A space boundary can either be
///   physically dividing or can be a virtual divider.
/// 
/// Enumeration:
/// 
/// PHYSICAL
/// 
/// The space boundary is provided physically, i.e. by an
///   physical element.
/// 
/// VIRTUAL
/// 
/// The space boundary is provided virtually, i.e. by a
///   logical divider that has no physical manifestation.
/// 
/// NOTDEFINED
/// 
/// No information available.
/// 
/// HISTORY: New enumeration in
///   IFC Release 2.0
typedef enum {IfcPhysicalOrVirtual_PHYSICAL, IfcPhysicalOrVirtual_VIRTUAL, IfcPhysicalOrVirtual_NOTDEFINED} IfcPhysicalOrVirtualEnum;
IFC_PARSE_API const char* ToString(IfcPhysicalOrVirtualEnum v);
IFC_PARSE_API IfcPhysicalOrVirtualEnum FromString(const std::string& s);
}
namespace IfcPileConstructionEnum {
/// Definition from IAI: Enumeration defining the construction type
///   for piles. The type is mainly based on how the piles are used and manufactured.
///   Some material information is mixed in because this affects the way the piles
///   are used.  
/// 
/// HISTORY New type in IFC Release 2x2
/// 
/// ENUMERATION 
/// 
/// CAST_IN_PLACE Piles and piers that are excavated and poured in
///   place. 
///   COMPOSITE Piles that are a mix of components, such as a steel
///   outer casing which is driven into the ground with a cast-in-place concrete
///   core. 
///   PRECAST_CONCRETE Piles that are entirely of precast concrete
///   (possibly with some steel or other fixtures). 
///   PREFAB_STEEL Prefabricated piles made entirely out of steel.
///   It will also include steel sheet piles where these are not part of another
///   construction element. 
///   USERDEFINED Special types of pile construction which meet
///   specific local requirements. 
///   NOTDEFINED The type of pile construction is not defined.
typedef enum {IfcPileConstruction_CAST_IN_PLACE, IfcPileConstruction_COMPOSITE, IfcPileConstruction_PRECAST_CONCRETE, IfcPileConstruction_PREFAB_STEEL, IfcPileConstruction_USERDEFINED, IfcPileConstruction_NOTDEFINED} IfcPileConstructionEnum;
IFC_PARSE_API const char* ToString(IfcPileConstructionEnum v);
IFC_PARSE_API IfcPileConstructionEnum FromString(const std::string& s);
}
namespace IfcPileTypeEnum {
/// Definition from IAI: Enumeration defining the pile type. 
/// 
/// HISTORY New type in IFC Release 2x2
/// IFC 2x4 change:  Items BORED, DRIVEN, JETGROUTING added
/// 
/// BORED A bore pile.
///   DRIVEN A rammed, vibrated, or otherwise driven pile.
///   JETGROUTING An injected pile-like construction.
///   COHESION A cohesion pile.
///   FRICTION A friction pile.
///   SUPPORT A support pile.
///   USERDEFINED The type of pile function is user defined.
///   NOTDEFINED The type of pile function is not defined.
typedef enum {IfcPileType_BORED, IfcPileType_DRIVEN, IfcPileType_JETGROUTING, IfcPileType_COHESION, IfcPileType_FRICTION, IfcPileType_SUPPORT, IfcPileType_USERDEFINED, IfcPileType_NOTDEFINED} IfcPileTypeEnum;
IFC_PARSE_API const char* ToString(IfcPileTypeEnum v);
IFC_PARSE_API IfcPileTypeEnum FromString(const std::string& s);
}
namespace IfcPipeFittingTypeEnum {
/// This enumeration is used to identify the primary purpose of a pipe fitting. This is a very basic categorization mechanism
///   to generically identify the pipe fitting type. Subcategories
///   of pipe fittings are not enumerated. 
///   The IfcpipeFittingTypeEnum contains the following:
/// 
/// BEND:		A fitting with typically two ports used to change 
///   the direction of flow between connected elements.
///   CONNECTOR:   Connector fitting, typically used to join two
///   ports together within a flow distribution system 
///   (e.g., a coupling used to join two pipe segments).
///   ENTRY:       Entry fitting, typically unconnected at one port
///   and connected to a flow distribution system at 
///   the other (e.g., a breeching inlet).
///   EXIT:        Exit fitting, typically unconnected at one port
///   and connected to a flow distribution system at 
///   the other (e.g., a hose bibb).
///   JUNCTION:	A fitting with typically more than two ports used
///   to redistribute flow among the ports and/or to
///   change the direction of flow between connected
///   elements (e.g, tee, cross, wye, etc.).
///   OBSTRUCTION: A fitting with typically two ports used to 
///   obstruct or restrict flow between the connected
///   elements (e.g., screen, perforated plate, etc.).
///   TRANSITION:	A fitting with typically two ports having
///   different shapes or sizes. Can also be used to
///   change the direction of flow between connected
///   elements.
///   USERDEFINED: User-defined fitting.
///   NOTDEFINED:  Undefined fitting.
/// 
/// HISTORY: New enumeration in IFC 2x2
typedef enum {IfcPipeFittingType_BEND, IfcPipeFittingType_CONNECTOR, IfcPipeFittingType_ENTRY, IfcPipeFittingType_EXIT, IfcPipeFittingType_JUNCTION, IfcPipeFittingType_OBSTRUCTION, IfcPipeFittingType_TRANSITION, IfcPipeFittingType_USERDEFINED, IfcPipeFittingType_NOTDEFINED} IfcPipeFittingTypeEnum;
IFC_PARSE_API const char* ToString(IfcPipeFittingTypeEnum v);
IFC_PARSE_API IfcPipeFittingTypeEnum FromString(const std::string& s);
}
namespace IfcPipeSegmentTypeEnum {
/// This enumeration is used to identify the primary purpose of a
///   pipe segment. This is a very basic categorization mechanism
///   to generically identify the pipe segment type. Subcategories
///   of pipe segments are not enumerated. 
///   The IfcPipeSegmentTypeEnum contains the following:
/// 
/// CULVERT: A covered channel or large pipe that forms a watercourse below ground level, usually under a road or railway.
///   RIGIDSEGMENT: A rigid segment is continuous linear segment of pipe that cannot be deformed.
///   FLEXIBLESEGMENT:  A flexible segment is a continuous non-linear segment of pipe that can be deformed and change the direction of flow.
///   GUTTER: A gutter segment is a continuous open-channel segment of pipe.
///   SPOOL: A type of rigid segment that is typically shorter and used for providing connectivity within a piping network.
///   USERDEFINED: User-defined segment.
///   NOTDEFINED:  Undefined segment.
/// 
/// HISTORY: New enumeration in IFC 2x2
typedef enum {IfcPipeSegmentType_CULVERT, IfcPipeSegmentType_FLEXIBLESEGMENT, IfcPipeSegmentType_RIGIDSEGMENT, IfcPipeSegmentType_GUTTER, IfcPipeSegmentType_SPOOL, IfcPipeSegmentType_USERDEFINED, IfcPipeSegmentType_NOTDEFINED} IfcPipeSegmentTypeEnum;
IFC_PARSE_API const char* ToString(IfcPipeSegmentTypeEnum v);
IFC_PARSE_API IfcPipeSegmentTypeEnum FromString(const std::string& s);
}
namespace IfcPlateTypeEnum {
/// Definition from IAI: This enumeration
/// defines the different types of planar elements an IfcPlateType
/// object can fulfill:
/// 
/// CURTAIN_PANEL: A planar element within a
/// curtain wall, often consisting of a frame with fixed glazing.
///   SHEET: A planar, flat and thin element,
/// comes usually as metal sheet, and is often used as an additonal part
/// within an assembly.
///   USERDEFINED: User-defined linear element.
///   NOTDEFINED: Undefined linear element
/// 
/// HISTORY  New Enumeration in Release IFC2x Edition 2. 
/// IFC2x
/// Edition 3
/// CHANGE  The additional identifiers CURTAIN_PANEL, SHEET have
/// been
/// added.
typedef enum {IfcPlateType_CURTAIN_PANEL, IfcPlateType_SHEET, IfcPlateType_USERDEFINED, IfcPlateType_NOTDEFINED} IfcPlateTypeEnum;
IFC_PARSE_API const char* ToString(IfcPlateTypeEnum v);
IFC_PARSE_API IfcPlateTypeEnum FromString(const std::string& s);
}
namespace IfcPreferredSurfaceCurveRepresentation {

typedef enum {IfcPreferredSurfaceCurveRepresentation_CURVE3D, IfcPreferredSurfaceCurveRepresentation_PCURVE_S1, IfcPreferredSurfaceCurveRepresentation_PCURVE_S2} IfcPreferredSurfaceCurveRepresentation;
IFC_PARSE_API const char* ToString(IfcPreferredSurfaceCurveRepresentation v);
IFC_PARSE_API IfcPreferredSurfaceCurveRepresentation FromString(const std::string& s);
}
namespace IfcProcedureTypeEnum {
/// The IfcProcedureTypeEnum defines the range of different types of procedure that can be specified.
/// 
/// HISTORY: New type in IFC2x2
/// 
/// Enumeration:
/// 
/// ADVICE_CAUTION: A caution that should be taken note of as a procedure or when carrying out a procedure
/// ADVICE_NOTE: Additional information or advice that should be taken note of as a procedure or when carrying out a procedure
/// ADVICE_WARNING: A warning of potential danger that should be taken note of as a procedure or when carrying out a procedure
/// CALIBRATION: A procedure undertaken to calibrate an artifact
/// SHUTDOWN: A procedure undertaken to shutdown the operation an artifact
/// STARTUP: A procedure undertaken to start up the operation an artifact
/// USERDEFINED
/// NOTDEFINED
typedef enum {IfcProcedureType_ADVICE_CAUTION, IfcProcedureType_ADVICE_NOTE, IfcProcedureType_ADVICE_WARNING, IfcProcedureType_CALIBRATION, IfcProcedureType_DIAGNOSTIC, IfcProcedureType_SHUTDOWN, IfcProcedureType_STARTUP, IfcProcedureType_USERDEFINED, IfcProcedureType_NOTDEFINED} IfcProcedureTypeEnum;
IFC_PARSE_API const char* ToString(IfcProcedureTypeEnum v);
IFC_PARSE_API IfcProcedureTypeEnum FromString(const std::string& s);
}
namespace IfcProfileTypeEnum {
/// The enumeration defines whether the definition of a profile shape shall be geometrically resolved into a curve or into a surface.
/// 
/// HISTORY: New type in IFC 1.5.
/// 
/// Enumeration values:
/// 
/// CURVE: The resulting geometric item is of type curve and closed (with the only exception of the curve created by the IfcArbitraryOpenProfileDef which resolves into an open curve). The resulting geometry after applying a sweeping operation is a swept surface. This can be used to define shapes with thin sheets, such as ducts, where the thickness is not appropriate for geometric representation.
/// AREA: The resulting geometric item is of type surface. The resulting geometry after applying a sweeping operation is a swept solid with defined volume.
typedef enum {IfcProfileType_CURVE, IfcProfileType_AREA} IfcProfileTypeEnum;
IFC_PARSE_API const char* ToString(IfcProfileTypeEnum v);
IFC_PARSE_API IfcProfileTypeEnum FromString(const std::string& s);
}
namespace IfcProjectOrderTypeEnum {
/// An IfcProjectOrderTypeEnum is a list of the types of project order that may be identified. 
///   HISTORY: New type in IFC 2x2  
///   Enumeration 
/// 
/// CHANGEORDER: An instruction to make a change to a product or work being undertaken and a description of the work that is to be performed. 
/// MAINTENANCEWORKORDER: An instruction to carry out maintenance work and a description of the work that is to be performed. 
/// MOVEORDER: An instruction to move persons and artefacts and a description of the move locations, objects to be moved, etc.  
/// PURCHASEORDER: An instruction to purchase goods and/or services and a description of the goods and/or services to be purchased that is to be performed. 
/// WORKORDER: A general instruction to carry out work and a description of the work to be done. Note the difference between a work order generally and a maintenance work order. 
/// USERDEFINED: User-defined type. 
/// NOTDEFINED: Undefined type.
typedef enum {IfcProjectOrderType_CHANGEORDER, IfcProjectOrderType_MAINTENANCEWORKORDER, IfcProjectOrderType_MOVEORDER, IfcProjectOrderType_PURCHASEORDER, IfcProjectOrderType_WORKORDER, IfcProjectOrderType_USERDEFINED, IfcProjectOrderType_NOTDEFINED} IfcProjectOrderTypeEnum;
IFC_PARSE_API const char* ToString(IfcProjectOrderTypeEnum v);
IFC_PARSE_API IfcProjectOrderTypeEnum FromString(const std::string& s);
}
namespace IfcProjectedOrTrueLengthEnum {
/// This enumeration type is needed for load definition and is only considered if the load values are given as global actions and if they define linear or planar loads (that is, one- or two-dimensionally distributed loads).
/// Figure 234 illustrates the interpretation of a load definition depending on the enumeration types IfcGlobalOrLocalEnum and IfcProjectedOrTrueLengthEnum.
/// 
/// HISTORY  New type in IFC2x2. 
/// 
/// Figure 234 — Projected or true length
typedef enum {IfcProjectedOrTrueLength_PROJECTED_LENGTH, IfcProjectedOrTrueLength_TRUE_LENGTH} IfcProjectedOrTrueLengthEnum;
IFC_PARSE_API const char* ToString(IfcProjectedOrTrueLengthEnum v);
IFC_PARSE_API IfcProjectedOrTrueLengthEnum FromString(const std::string& s);
}
namespace IfcProjectionElementTypeEnum {
/// Definition from IAI: An enumeration defining the basic
/// types for projection elements.
/// 
/// HISTORY New enumeration type in
/// IFC2x4.
/// 
/// Enumeration
/// 
/// USERDEFINED: User-defined projection
/// element
/// NOTDEFINED: Undefined projection
/// element
typedef enum {IfcProjectionElementType_USERDEFINED, IfcProjectionElementType_NOTDEFINED} IfcProjectionElementTypeEnum;
IFC_PARSE_API const char* ToString(IfcProjectionElementTypeEnum v);
IFC_PARSE_API IfcProjectionElementTypeEnum FromString(const std::string& s);
}
namespace IfcPropertySetTemplateTypeEnum {
/// This enumeration defines the general
/// applicability of instances of IfcPropertySet, or
/// IfcElementQuantity defined by this
/// IfcPropertySetTemplate, to subtypes of
/// IfcObjectDefinition.
/// 
/// HISTORY New enumeration in IFC2x4.
/// 
/// Enumeration
/// 
/// PSET_TYPEDRIVENONLY: the property sets
/// defined by this IfcPropertySetTemplate can only be assigned
/// to subtypes of IfcTypeObject.
/// PSET_TYPEDRIVENOVERRIDE: the property
/// sets defined by this IfcPropertySetTemplate can be assigned
/// to subtypes of IfcTypeObject and can be overridden by a
/// property set with same name at subtypes of IfcObject.
/// PSET_OCCURRENCEDRIVEN: the property sets
/// defined by this IfcPropertySetTemplate can only be assigned
/// to subtypes of IfcObject.
/// PSET_PERFORMANCEDRIVEN: the property sets
/// defined by this IfcPropertySetTemplate can only be assigned
/// to IfcPerformanceHistory,
/// QTO_TYPEDRIVENONLY: the element quantity
/// defined by this IfcPropertySetTemplate can only be assigned
/// to subtypes of IfcTypeObject.
/// QTO_TYPEDRIVENOVERRIDE: the element
/// quantity defined by this IfcPropertySetTemplate can be
/// assigned to subtypes of IfcTypeObject and can be overridden
/// by an element quantity with same name at subtypes of
/// IfcObject.
/// QTO_OCCURRENCEDRIVEN: the element
/// quantity defined by this IfcPropertySetTemplate can only be
/// assigned to subtypes of IfcObject.
/// NOTDEFINED: No
/// restriction provided, the property sets defined by this
/// IfcPropertySetTemplate can be assigned to any entity, if not
/// otherwise restricted by the ApplicableEntity attribute.
typedef enum {IfcPropertySetTemplateType_PSET_TYPEDRIVENONLY, IfcPropertySetTemplateType_PSET_TYPEDRIVENOVERRIDE, IfcPropertySetTemplateType_PSET_OCCURRENCEDRIVEN, IfcPropertySetTemplateType_PSET_PERFORMANCEDRIVEN, IfcPropertySetTemplateType_QTO_TYPEDRIVENONLY, IfcPropertySetTemplateType_QTO_TYPEDRIVENOVERRIDE, IfcPropertySetTemplateType_QTO_OCCURRENCEDRIVEN, IfcPropertySetTemplateType_NOTDEFINED} IfcPropertySetTemplateTypeEnum;
IFC_PARSE_API const char* ToString(IfcPropertySetTemplateTypeEnum v);
IFC_PARSE_API IfcPropertySetTemplateTypeEnum FromString(const std::string& s);
}
namespace IfcProtectiveDeviceTrippingUnitTypeEnum {
/// Defines the range of different tripping unit types that can be used in conjunction with a protective device. 
/// HISTORY: New enumeration in IFC2x4 
/// 
/// ELECTRONIC: A tripping unit activated by electronic action. 
/// ELECTROMAGNETIC: A tripping unit activated by electromagnetic action. 
/// RESIDUALCURRENT: A tripping unit activated by residual current detection. 
/// THERMAL: A tripping unit activated by thermal action.
typedef enum {IfcProtectiveDeviceTrippingUnitType_ELECTRONIC, IfcProtectiveDeviceTrippingUnitType_ELECTROMAGNETIC, IfcProtectiveDeviceTrippingUnitType_RESIDUALCURRENT, IfcProtectiveDeviceTrippingUnitType_THERMAL, IfcProtectiveDeviceTrippingUnitType_USERDEFINED, IfcProtectiveDeviceTrippingUnitType_NOTDEFINED} IfcProtectiveDeviceTrippingUnitTypeEnum;
IFC_PARSE_API const char* ToString(IfcProtectiveDeviceTrippingUnitTypeEnum v);
IFC_PARSE_API IfcProtectiveDeviceTrippingUnitTypeEnum FromString(const std::string& s);
}
namespace IfcProtectiveDeviceTypeEnum {
/// The IfcProtectiveDeviceTypeEnum specifically defines the range of different breaker unit types that can be used in conjunction with protective device. Types may also be used as a reference to a complete protective device in circumstances where tripping units are not separately identified (typically expected to be the case during earlier stages of design). 
/// 
/// HISTORY: New type in IFC 2x2. Modified definition and usage in IFC 2x4 
/// 
/// Enumeration
/// 
/// FUSEDISCONNECTOR: A device that will electrically open the circuit after a period of prolonged, abnormal current flow.
/// CIRCUITBREAKER: A mechanical switching device capable of making, carrying, and breaking currents under normal circuit conditions and also making, carrying for a specified time and breaking, current under specified abnormal circuit conditions such as those of short circuit.
/// EARTHINGSWITCH: A safety device used to open or close a circuit when there is no current. Used to isolate a part of a circuit, a machine, a part of an overhead line or an underground line so that maintenance can be safely conducted.
/// EARTHLEAKAGECIRCUITBREAKER: A device that opens, closes, or isolates a circuit and has short circuit protection but no overload protection.  It attempts to break the circuit when there is a leakage of current from phase to earth, by measuring voltage on the earth conductor.
/// RESIDUALCURRENTCIRCUITBREAKER: A device that opens, closes, or isolates a circuit and has short circuit and overload protection.  It attempts to break the circuit when there is a difference in current between any two phases.  May also be referred to as 'Ground Fault Interupter (GFI)' or 'Ground Fault Circuit Interuptor (GFCI)'
/// RESIDUALCURRENTSWITCH: A device that opens, closes or isolates a circuit and has no short circuit or overload protection.  May also be identified as a 'ground fault switch'.
/// VARISTOR: A high voltage surge protection device.
/// USERDEFINED: User-defined type.
/// NOTDEFINED: Undefined type.
typedef enum {IfcProtectiveDeviceType_CIRCUITBREAKER, IfcProtectiveDeviceType_EARTHLEAKAGECIRCUITBREAKER, IfcProtectiveDeviceType_EARTHINGSWITCH, IfcProtectiveDeviceType_FUSEDISCONNECTOR, IfcProtectiveDeviceType_RESIDUALCURRENTCIRCUITBREAKER, IfcProtectiveDeviceType_RESIDUALCURRENTSWITCH, IfcProtectiveDeviceType_VARISTOR, IfcProtectiveDeviceType_USERDEFINED, IfcProtectiveDeviceType_NOTDEFINED} IfcProtectiveDeviceTypeEnum;
IFC_PARSE_API const char* ToString(IfcProtectiveDeviceTypeEnum v);
IFC_PARSE_API IfcProtectiveDeviceTypeEnum FromString(const std::string& s);
}
namespace IfcPumpTypeEnum {
/// Defines general types of pumps.
/// 
/// The IfcPumpTypeEnum contains the following:
/// 
/// CIRCULATOR: A Circulator pump is a generic low-pressure, low-capacity pump. It may have a wet rotor and
///   may be driven by a flexible-coupled motor.
/// 
/// ENDSUCTION: An End Suction pump, when mounted horizontally, has a single horizontal inlet on the impeller suction side
///   and a vertical discharge. It may have a direct or close-coupled motor.
/// 
/// SPLITCASE: A Split Case pump, when mounted horizontally, has an inlet and outlet on each side of the impeller.
///   The impeller can be easily accessed by removing the front of the impeller casing. It may have a direct or close-coupled motor.
/// 
/// SUBMERSIBLEPUMP: A pump designed to be immersed in a fluid, typically a collection tank.
/// 
/// SUMPPUMP: A pump designed to sit above a collection tank with a suction inlet extending into the tank.
/// 
/// VERTICALINLINE: A Vertical Inline pump has the pump and motor close-coupled on the pump casing.
///   The pump depends on the connected, horizontal piping for support, with the suction and discharge along the piping axis.
/// 
/// VERTICALTURBINE: A Vertical Turbine pump has a motor mounted vertically on the pump casing for either
///   wet-pit sump mounting or dry-well mounting.
/// 
/// USERDEFINED: User-defined pump type.
/// 
/// NOTDEFINED:  Pump type has not been defined.
/// 
/// HISTORY: New enumeration in IFC R2x.  SUBMERSIBLEPUMP and SUMPPUMP added in IFC2x4.
typedef enum {IfcPumpType_CIRCULATOR, IfcPumpType_ENDSUCTION, IfcPumpType_SPLITCASE, IfcPumpType_SUBMERSIBLEPUMP, IfcPumpType_SUMPPUMP, IfcPumpType_VERTICALINLINE, IfcPumpType_VERTICALTURBINE, IfcPumpType_USERDEFINED, IfcPumpType_NOTDEFINED} IfcPumpTypeEnum;
IFC_PARSE_API const char* ToString(IfcPumpTypeEnum v);
IFC_PARSE_API IfcPumpTypeEnum FromString(const std::string& s);
}
namespace IfcRailingTypeEnum {
/// Definition from IAI: Enumeration defining the valid types of
///   railings that can be predefined using the enumeration values.  
///   HISTORY: New Enumeration in IFC
///   Release 2.0  
///   Enumeration 
/// 
/// HANDRAIL: A type of railing designed to serve as an optional
///   structural support for loads applied by human occupants (at hand height).
///   Generally located adjacent to ramps and stairs. Generally floor or wall
///   mounted. 
///   GUARDRAIL: A type of railing designed to guard human occupants
///   from falling off a stair, ramp or landing where there is a vertical drop at the
///   edge of such floors/landings. 
///   BALUSTRADE: Similar to the definitions of a guardrail except
///   the location is at the edge of a floor, rather then a stair or ramp. Examples
///   are balustrates at roof-tops or balconies. 
///   USERDEFINED: User-defined railing element, a term to identify
///   the user type is given by the attribute IfcRailing.ObjectType. 
///   NOTDEFINED: Undefined railing element, no type information
///   available.
typedef enum {IfcRailingType_HANDRAIL, IfcRailingType_GUARDRAIL, IfcRailingType_BALUSTRADE, IfcRailingType_USERDEFINED, IfcRailingType_NOTDEFINED} IfcRailingTypeEnum;
IFC_PARSE_API const char* ToString(IfcRailingTypeEnum v);
IFC_PARSE_API IfcRailingTypeEnum FromString(const std::string& s);
}
namespace IfcRampFlightTypeEnum {
/// Definition from IAI: This enumeration defines the different types
///   of linear elements an IfcRampFlightType object can fulfill: 
/// 
/// STRAIGHT: A ramp flight with a straight walking line.  
///   SPIRAL: A ramp flight with a circular or elliptic walking
///   line. 
///   USERDEFINED: User-defined ramp flight. 
///   NOTDEFINED: Undefined ramp flight. 
/// 
/// HISTORY: New Enumeration in
///   Release IFC2x Edition 2.
typedef enum {IfcRampFlightType_STRAIGHT, IfcRampFlightType_SPIRAL, IfcRampFlightType_USERDEFINED, IfcRampFlightType_NOTDEFINED} IfcRampFlightTypeEnum;
IFC_PARSE_API const char* ToString(IfcRampFlightTypeEnum v);
IFC_PARSE_API IfcRampFlightTypeEnum FromString(const std::string& s);
}
namespace IfcRampTypeEnum {
/// This enumeration defines the basic configuration of the ramp type in terms of the number and shape of ramp flights, as shown in Figure 67. The type also distinguished turns by landings. In addition the subdivision of the straight and changing direction ramps is included. The ramp configurations are given for ramps without and with one and two landings. 
/// 
/// Ramps which are subdivided into more than two landings have to be defined by the geometry only. Also ramps with non-regular shapes have to be defined by the geometry only. The type of such ramps is USERDEFINED. 
/// 
/// HISTORY New Enumeration in IFC Release 2.0. 
/// 
/// Enumerator 
///   Description 
///   Figure 
/// 
/// StraightRunRamp 
///   A ramp - which is a sloping
///   floor, walk, or roadway - connecting two levels. The straight ramp consists of
///   one straight flight without turns or winders.  
/// 
/// TwoStraightRunRamp 
///   A straight ramp consisting of
///   two straight flights without turns but with one landing. 
/// 
/// QuarterTurnRamp 
///   A ramp making a 90° turn,
///   consisting of two straight flights connected by a quarterspace landing. The
///   direction of the turn is determined by the walking line. 
/// 
/// TwoQuarterTurnRamp 
///   A ramp making a 180°
///   turn, consisting of three straight flights connected by two quarterspace
///   landings. The direction of the turn is determined by the walking line. 
/// 
/// HalfTurnRamp 
///   A ramp making a 180°
///   turn, consisting of two straight flights connected by a halfspace landing. The
///   orientation of the turn is determined by the walking line. 
/// 
/// SpiralRamp 
///   A ramp constructed around a
///   circular or elliptical well without newels and landings. 
/// 
/// UserDefined 
///   Free form ramp (user defined
///   operation type) 
///     
/// 
/// NotDefined 
///     
///     
/// 
/// Figure 67 — Ramp types
typedef enum {IfcRampType_STRAIGHT_RUN_RAMP, IfcRampType_TWO_STRAIGHT_RUN_RAMP, IfcRampType_QUARTER_TURN_RAMP, IfcRampType_TWO_QUARTER_TURN_RAMP, IfcRampType_HALF_TURN_RAMP, IfcRampType_SPIRAL_RAMP, IfcRampType_USERDEFINED, IfcRampType_NOTDEFINED} IfcRampTypeEnum;
IFC_PARSE_API const char* ToString(IfcRampTypeEnum v);
IFC_PARSE_API IfcRampTypeEnum FromString(const std::string& s);
}
namespace IfcRecurrenceTypeEnum {
/// IfcRecurrenceTypeEnum enumerates the recurring pattern type. The following
///   combinations are valid:
/// 
/// DAILY: Interval, Occurrences
/// 
/// WEEKLY: WeekdayComponent, Interval, Occurrences
/// 
/// MONTHLY_BY_DAY_OF_MONTH: DayComponent, Interval, Occurrences
/// 
/// MONTHLY_BY_POSITION: WeekdayComponent, Position, Interval, Occurrences
/// 
/// BY_DAY_COUNT: Interval, Occurrences
/// 
/// BY_WEEKDAY_COUNT: WeekdayComponent, Interval, Occurrences
/// 
/// YEARLY_BY_DAY_OF_MONTH: DayComponent, MonthComponent, Interval, Occurrences
/// 
/// YEARLY_BY_POSITION: WeekdayComponent, MonthComponent, Position, Interval, Occurrences
/// 
/// HISTORY: New enumeration in IFC
///   Release 2x4.
typedef enum {IfcRecurrenceType_DAILY, IfcRecurrenceType_WEEKLY, IfcRecurrenceType_MONTHLY_BY_DAY_OF_MONTH, IfcRecurrenceType_MONTHLY_BY_POSITION, IfcRecurrenceType_BY_DAY_COUNT, IfcRecurrenceType_BY_WEEKDAY_COUNT, IfcRecurrenceType_YEARLY_BY_DAY_OF_MONTH, IfcRecurrenceType_YEARLY_BY_POSITION} IfcRecurrenceTypeEnum;
IFC_PARSE_API const char* ToString(IfcRecurrenceTypeEnum v);
IFC_PARSE_API IfcRecurrenceTypeEnum FromString(const std::string& s);
}
namespace IfcReflectanceMethodEnum {
/// The IfcReflectanceMethodEnum defines the range of different reflectance methods available. 
/// 
/// HISTORY: New type in IFC 2x2.
/// 
/// Enumeration 
/// 
/// BLINN: A reflectance model providing a smooth, slightly shiny appearance.
/// FLAT: A reflectance model providing a constant colour. This model ignores the effect of all light sources. 
/// GLASS: A reflectance model that supports an approximation of glass-like materials that have both reflective and transmissive properties. 
/// MATT: A reflectance model providing a dull matte appearance. 
/// METAL: A reflectance model providing a specular metallic appearance. 
/// MIRROR: A reflectance model that supports secondary mirrored views through ray tracing. 
/// PHONG: A reflectance model conforming with the Phong model in which reflections are greatest in the `mirror' direction of a surface opposite the viewing direction with respect to the surface normal. 
/// PLASTIC: A reflectance model providing a specular effect which is similar to the Phong model. 
/// STRAUSS: A reflectance model for metallic and non-metallic appearance based on a limited set of control parameter.
/// NOTDEFINED
typedef enum {IfcReflectanceMethod_BLINN, IfcReflectanceMethod_FLAT, IfcReflectanceMethod_GLASS, IfcReflectanceMethod_MATT, IfcReflectanceMethod_METAL, IfcReflectanceMethod_MIRROR, IfcReflectanceMethod_PHONG, IfcReflectanceMethod_PLASTIC, IfcReflectanceMethod_STRAUSS, IfcReflectanceMethod_NOTDEFINED} IfcReflectanceMethodEnum;
IFC_PARSE_API const char* ToString(IfcReflectanceMethodEnum v);
IFC_PARSE_API IfcReflectanceMethodEnum FromString(const std::string& s);
}
namespace IfcReinforcingBarRoleEnum {
/// Definition from IAI: Enumeration defining standard types for the
///   role, purpose or usage of the bar, i.e. the kind of loads and stresses they are
///   intended to carry.  
/// 
/// HISTORY New type in IFC Release 2x2.
///   Item ANCHORING (documented since IFC 2x2) added to the EXPRESS definition in IFC 2x4.
/// 
/// ENUMERATION 
/// 
/// MAIN The reinforcing bar is a main bar. 
///   SHEAR The reinforcing bar is a shear bar. 
///   LIGATURE The reinforcing bar is a ligature (link, stirrup). 
///   STUD The reinforcing bar is a stud. 
///   PUNCHING Punching reinforcement. 
///   EDGE Edge reinforcement. 
///   RING Ring reinforcement. 
///   ANCHORING Anchoring reinforcement. 
///   USERDEFINED The type of reinforcement is user defined. 
///   NOTDEFINED The type of reinforcement is not defined.
typedef enum {IfcReinforcingBarRole_MAIN, IfcReinforcingBarRole_SHEAR, IfcReinforcingBarRole_LIGATURE, IfcReinforcingBarRole_STUD, IfcReinforcingBarRole_PUNCHING, IfcReinforcingBarRole_EDGE, IfcReinforcingBarRole_RING, IfcReinforcingBarRole_ANCHORING, IfcReinforcingBarRole_USERDEFINED, IfcReinforcingBarRole_NOTDEFINED} IfcReinforcingBarRoleEnum;
IFC_PARSE_API const char* ToString(IfcReinforcingBarRoleEnum v);
IFC_PARSE_API IfcReinforcingBarRoleEnum FromString(const std::string& s);
}
namespace IfcReinforcingBarSurfaceEnum {
/// Definition from IAI: Enumeration indicating whether the bar has a
///   plain or textured (ribbed) surface.  
/// 
/// HISTORY New type in IFC Release 2x2
/// 
/// ENUMERATION 
/// 
/// PLAIN The reinforcing bar surface is plain. 
///   TEXTURED The reinforcing bar surface is textured (ribbed).
typedef enum {IfcReinforcingBarSurface_PLAIN, IfcReinforcingBarSurface_TEXTURED} IfcReinforcingBarSurfaceEnum;
IFC_PARSE_API const char* ToString(IfcReinforcingBarSurfaceEnum v);
IFC_PARSE_API IfcReinforcingBarSurfaceEnum FromString(const std::string& s);
}
namespace IfcReinforcingBarTypeEnum {

typedef enum {IfcReinforcingBarType_ANCHORING, IfcReinforcingBarType_EDGE, IfcReinforcingBarType_LIGATURE, IfcReinforcingBarType_MAIN, IfcReinforcingBarType_PUNCHING, IfcReinforcingBarType_RING, IfcReinforcingBarType_SHEAR, IfcReinforcingBarType_STUD, IfcReinforcingBarType_USERDEFINED, IfcReinforcingBarType_NOTDEFINED} IfcReinforcingBarTypeEnum;
IFC_PARSE_API const char* ToString(IfcReinforcingBarTypeEnum v);
IFC_PARSE_API IfcReinforcingBarTypeEnum FromString(const std::string& s);
}
namespace IfcReinforcingMeshTypeEnum {

typedef enum {IfcReinforcingMeshType_USERDEFINED, IfcReinforcingMeshType_NOTDEFINED} IfcReinforcingMeshTypeEnum;
IFC_PARSE_API const char* ToString(IfcReinforcingMeshTypeEnum v);
IFC_PARSE_API IfcReinforcingMeshTypeEnum FromString(const std::string& s);
}
namespace IfcRoleEnum {
/// Definition: Roles which may be played by an actor.
/// 
/// HISTORY This type has changes after IFC Release 2.0.  Spelling of COMMISSIONINGENGINEER fixed in IFC 2x4.
/// 
/// ENUMERATION 
/// 
/// SUPPLIER
///   MANUFACTURER
///   CONTRACTOR 
///   SUBCONTRACTOR
///   ARCHITECT
///   STRUCTURALENGINEER
///   COSTENGINEER 
///   CLIENT
///   BUILDINGOWNER
///   BUILDINGOPERATOR
///   MECHANICALENGINEER 
///   ELECTRICALENGINEER
///   PROJECTMANAGER
///   FACILITIESMANAGER
///   CIVILENGINEER
///   COMMISSIONINGENGINEER 
///   ENGINEER
///   OWNER
///   CONSULTANT
///   CONSTRUCTIONMANAGER
///   FIELDCONSTRUCTIONMANAGER 
///   RESELLER
///   USERDEFINED User defined value to be provided.
typedef enum {IfcRole_SUPPLIER, IfcRole_MANUFACTURER, IfcRole_CONTRACTOR, IfcRole_SUBCONTRACTOR, IfcRole_ARCHITECT, IfcRole_STRUCTURALENGINEER, IfcRole_COSTENGINEER, IfcRole_CLIENT, IfcRole_BUILDINGOWNER, IfcRole_BUILDINGOPERATOR, IfcRole_MECHANICALENGINEER, IfcRole_ELECTRICALENGINEER, IfcRole_PROJECTMANAGER, IfcRole_FACILITIESMANAGER, IfcRole_CIVILENGINEER, IfcRole_COMMISSIONINGENGINEER, IfcRole_ENGINEER, IfcRole_OWNER, IfcRole_CONSULTANT, IfcRole_CONSTRUCTIONMANAGER, IfcRole_FIELDCONSTRUCTIONMANAGER, IfcRole_RESELLER, IfcRole_USERDEFINED} IfcRoleEnum;
IFC_PARSE_API const char* ToString(IfcRoleEnum v);
IFC_PARSE_API IfcRoleEnum FromString(const std::string& s);
}
namespace IfcRoofTypeEnum {
/// This enumeration defines the basic configuration of the roof in terms of the different roof shapes, as illustrated in Figure 68.
/// 
/// Roofs which are subdivided into more than these basic shapes have to be defined by the geometry only. Also roofs with non-regular shapes (free form roof) have to be defined by the geometry only. The type of such roofs is FREEFORM. 
/// 
/// HISTORY New Enumeration in IFC Release 2x. 
/// 
/// Enumerator 
///   Description 
///   Figure 
/// 
/// FLAT_ROOF 
///   A roof having no slope, or
///   one with only a slight pitch so as to drain rainwater. 
/// 
/// SHED_ROOF 
///   A roof having a single
///   slope. 
/// 
/// GABLE_ROOF 
///   A roof sloping downward in
///   two parts from a central ridge, so as to form a gable at each end. 
/// 
/// HIP_ROOF 
///   A roof having sloping ends
///   and sides meeting at an inclined projecting angle. 
/// 
/// HIPPED_GABLE_ROOF 
///   A roof having a hipped end
///   truncating a gable. 
/// 
/// GAMBREL_ROOF 
///   A ridged roof divided on each
///   side into a shallower slope above a steeper one. 
/// 
/// MANSARD_ROOF 
///   A roof having on each side a
///   steeper lower part and a shallower upper part. 
/// 
/// BARREL_ROOF 
///   A roof or ceiling having a
///   semicylindrical form. 
/// 
/// RAINBOW_ROOF 
///   A gable roof in the form of a
///   broad Gothic arch, with gently sloping convex surfaces. 
/// 
/// BUTTERFLY_ROOF 
///   A roof having two slopes,
///   each descending inward from the eaves. 
/// 
/// PAVILION_ROOF 
///   A pyramidal hip roof. 
/// 
/// DOME_ROOF 
///   A hemispherical hip
///   roof. 
/// 
/// FREEFORM 
///   Free form roof  
///     
/// 
/// NOTDEFINED 
///   No specification given 
///     
/// 
/// Figure 68 — Roof types
typedef enum {IfcRoofType_FLAT_ROOF, IfcRoofType_SHED_ROOF, IfcRoofType_GABLE_ROOF, IfcRoofType_HIP_ROOF, IfcRoofType_HIPPED_GABLE_ROOF, IfcRoofType_GAMBREL_ROOF, IfcRoofType_MANSARD_ROOF, IfcRoofType_BARREL_ROOF, IfcRoofType_RAINBOW_ROOF, IfcRoofType_BUTTERFLY_ROOF, IfcRoofType_PAVILION_ROOF, IfcRoofType_DOME_ROOF, IfcRoofType_FREEFORM, IfcRoofType_USERDEFINED, IfcRoofType_NOTDEFINED} IfcRoofTypeEnum;
IFC_PARSE_API const char* ToString(IfcRoofTypeEnum v);
IFC_PARSE_API IfcRoofTypeEnum FromString(const std::string& s);
}
namespace IfcSIPrefix {
/// Definition from ISO/CD 10303-41:1992: An SI prefix is the name of a prefix that may be associated 
/// with an SI unit. The definitions of SI prefixes are specified in ISO 1000 (clause 3).
/// 
/// NOTE The prefix defines multiples and submultiples of the SI units.
/// 
/// NOTE Corresponding ISO 10303 name: SI_prefix, please refer to ISO/IS 10303-41 for the final definition of the formal standard.
/// 
/// ENUMERATION 
/// 
/// EXA: 10^18. 
///   PETA: 10^15. 
///   TERA: 10^12. 
///   GIGA: 10^9. 
///   MEGA: 10^6. 
///   KILO: 10^3. 
///   HECTO: 10^2.  
///   DECA: 10. 
///   DECI: 10^-1. 
///   CENTI: 10^-2. 
///   MILLI: 10^-3. 
///   MICRO: 10^-6. 
///   NANO: 10^-9. 
///   PICO: 10^-12. 
///   FEMTO: 10^-15. 
///   ATTO: 10^-18. 
/// 
/// HISTORY New entity in IFC Release 1.5.1.
typedef enum {IfcSIPrefix_EXA, IfcSIPrefix_PETA, IfcSIPrefix_TERA, IfcSIPrefix_GIGA, IfcSIPrefix_MEGA, IfcSIPrefix_KILO, IfcSIPrefix_HECTO, IfcSIPrefix_DECA, IfcSIPrefix_DECI, IfcSIPrefix_CENTI, IfcSIPrefix_MILLI, IfcSIPrefix_MICRO, IfcSIPrefix_NANO, IfcSIPrefix_PICO, IfcSIPrefix_FEMTO, IfcSIPrefix_ATTO} IfcSIPrefix;
IFC_PARSE_API const char* ToString(IfcSIPrefix v);
IFC_PARSE_API IfcSIPrefix FromString(const std::string& s);
}
namespace IfcSIUnitName {
/// Definition from ISO/CD 10303-41:1992: An SI unit name is the name of an SI unit. The definitions of the 
/// names of SI units are specified in ISO 1000 (clause 2).
/// 
/// NOTE Corresponding STEP name: SI_unit_name, please refer to ISO/IS 10303-41 for the final definition of the formal standard.
/// 
/// ENUMERATION 
/// 
/// AMPERE: Unit for electric current. 
///   BECQUEREL: Unit for radioactivity. 
///   CANDELA: Unit for luminousintensity. 
///   COULOMB: Unit for electric charge. 
///   CUBIC_METRE: Unit for volume. 
///   DEGREE_CELSIUS: Unit for thermodynamic temperature. 
///   FARAD: Unit for electric capacitance. 
///   GRAM: Unit for mass. 
///   GRAY: Unit for absorbed radioactive dose. 
///   HENRY: Unit for inductance. 
///   HERTZ: Unit for frequency. 
///   JOULE: Unit for energy. 
///   KELVIN: Unit for thermodynamic temperature. 
///   LUMEN: Unit for luminous flux. 
///   LUX: Unit for illuminance. 
///   METRE: Unit for length. 
///   MOLE: Unit for amount of substance. 
///   NEWTON: Unit for force. 
///   OHM: Unit for electric resistance. 
///   PASCAL: Unit for pressure. 
///   RADIAN: Unit for plane angle. 
///   SECOND: Unit for time. 
///   SIEMENS: Unit for electric conductance. 
///   SIEVERT: Unit for radioactive dose equivalent. 
///   SQUARE_METRE: Unit for area. 
///   STERADIAN: Unit for solid angle. 
///   TESLA: Unit for magnetic flux density. 
///   VOLT: Unit for electric voltage. 
///   WATT: Unit for power. 
///   WEBER: Unit for magnetic flux. 
/// 
/// HISTORY New entity in IFC Release 1.5.1.
typedef enum {IfcSIUnitName_AMPERE, IfcSIUnitName_BECQUEREL, IfcSIUnitName_CANDELA, IfcSIUnitName_COULOMB, IfcSIUnitName_CUBIC_METRE, IfcSIUnitName_DEGREE_CELSIUS, IfcSIUnitName_FARAD, IfcSIUnitName_GRAM, IfcSIUnitName_GRAY, IfcSIUnitName_HENRY, IfcSIUnitName_HERTZ, IfcSIUnitName_JOULE, IfcSIUnitName_KELVIN, IfcSIUnitName_LUMEN, IfcSIUnitName_LUX, IfcSIUnitName_METRE, IfcSIUnitName_MOLE, IfcSIUnitName_NEWTON, IfcSIUnitName_OHM, IfcSIUnitName_PASCAL, IfcSIUnitName_RADIAN, IfcSIUnitName_SECOND, IfcSIUnitName_SIEMENS, IfcSIUnitName_SIEVERT, IfcSIUnitName_SQUARE_METRE, IfcSIUnitName_STERADIAN, IfcSIUnitName_TESLA, IfcSIUnitName_VOLT, IfcSIUnitName_WATT, IfcSIUnitName_WEBER} IfcSIUnitName;
IFC_PARSE_API const char* ToString(IfcSIUnitName v);
IFC_PARSE_API IfcSIUnitName FromString(const std::string& s);
}
namespace IfcSanitaryTerminalTypeEnum {
/// The IfcSanitaryTerminalTypeEnum defines the range of different types of sanitary terminal that can be specified. 
/// 
/// NOTE: The value WCSEAT has been deprecated and should no longer be used; toilet seats should be represented by IfcDiscreteAccessory with ObjectType 'WC Seat'. 
///   HISTORY: New type in IFC 2x2 
/// 
/// Enumeration 
/// 
/// BATH: Sanitary appliance for immersion of the human body or parts of it. 
/// BIDET: Waste water appliance for washing the excretory organs while sitting astride the bowl. 
/// CISTERN: A water storage unit attached to a sanitary terminal that is fitted with a device, operated automatically or by the user, that discharges water to cleanse a water closet (toilet) pan, urinal or slop hopper. 
/// SHOWER: Installation or waste water appliance that emits a spray of water to wash the human body. 
/// SINK: Waste water appliance for receiving, retaining or disposing of domestic, culinary, laboratory or industrial process liquids. 
/// SANITARYFOUNTAIN: A sanitary terminal that provides a low pressure jet of water for a specific purpose. 
/// TOILETPAN: Soil appliance for the disposal of excrement. 
/// URINAL: Soil appliance that receives urine and directs it to a waste outlet (BS6100). 
/// WASHHANDBASIN: Waste water appliance for washing the upper parts of the body. 
/// WCSEAT: [Deprecated] Hinged seat that fits on the top of a water closet (WC) pan. 
/// USERDEFINED: User-defined type. 
/// NOTDEFINED: Undefined type.
typedef enum {IfcSanitaryTerminalType_BATH, IfcSanitaryTerminalType_BIDET, IfcSanitaryTerminalType_CISTERN, IfcSanitaryTerminalType_SHOWER, IfcSanitaryTerminalType_SINK, IfcSanitaryTerminalType_SANITARYFOUNTAIN, IfcSanitaryTerminalType_TOILETPAN, IfcSanitaryTerminalType_URINAL, IfcSanitaryTerminalType_WASHHANDBASIN, IfcSanitaryTerminalType_WCSEAT, IfcSanitaryTerminalType_USERDEFINED, IfcSanitaryTerminalType_NOTDEFINED} IfcSanitaryTerminalTypeEnum;
IFC_PARSE_API const char* ToString(IfcSanitaryTerminalTypeEnum v);
IFC_PARSE_API IfcSanitaryTerminalTypeEnum FromString(const std::string& s);
}
namespace IfcSectionTypeEnum {
/// Definition from IAI: An enumeration indicating whether a
///   specific piece of a cross section is uniform or tapered in longitudinal
///   direction.  
///   HISTORY New type in IFC
///   Release 2x2  
///   ENUMERATION 
/// 
/// UNIFORM The section is uniform in longitudinal direction.
/// 
/// TAPERED The section is tapered in longitudinal direction.
typedef enum {IfcSectionType_UNIFORM, IfcSectionType_TAPERED} IfcSectionTypeEnum;
IFC_PARSE_API const char* ToString(IfcSectionTypeEnum v);
IFC_PARSE_API IfcSectionTypeEnum FromString(const std::string& s);
}
namespace IfcSensorTypeEnum {
/// The IfcSensorTypeEnum defines the range of different types of sensor that can be specified. 
/// 
/// HISTORY: New type in IFC R2.0.  Added missing enumerations in IFC2x4
/// 
/// Enumeration 
/// 
/// CONDUCTANCESENSOR: A device that senses or detects electrical conductance. 
/// CONTACTSENSOR: A device that senses or detects contact, such as for detecting if a door is closed. 
/// FIRESENSOR: A device that senses or detects fire. 
/// FLOWSENSOR: A device that senses or detects flow in a fluid. 
/// GASSENSOR: A device that senses or detects gas concentration. 
/// HEATSENSOR: A device that senses or detects heat. 
/// IONCONCENTRATIONSENSOR: A device that senses or detects ion concentration, such as for water hardness. 
/// LEVELSENSOR: A device that senses or detects fill level, such as for a tank. 
/// HUMIDITYSENSOR: A device that senses or detects humidity. 
/// LIGHTSENSOR: A device that senses or detects light. 
/// MOISTURESENSOR: A device that senses or detects moisture. 
/// MOVEMENTSENSOR: A device that senses or detects movement.  
/// PHSENSOR: A device that senses or detects acidity. 
/// PRESSURESENSOR: A device that senses or detects pressure. 
/// RADIATIONSENSOR: A device that senses or detects electromagnetic radiation. 
/// RADIOACTIVITYSENSOR: A device that senses or detects atomic decay. 
/// SMOKESENSOR: A device that senses or detects smoke. 
/// SOUNDSENSOR: A device that senses or detects sound.  
/// TEMPERATURESENSOR: A device that senses or detects temperature. 
/// WINDSENSOR: A device that senses or detects airflow speed and direction. 
/// USERDEFINED: User-defined type. 
/// NOTDEFINED: Undefined type.
typedef enum {IfcSensorType_COSENSOR, IfcSensorType_CO2SENSOR, IfcSensorType_CONDUCTANCESENSOR, IfcSensorType_CONTACTSENSOR, IfcSensorType_FIRESENSOR, IfcSensorType_FLOWSENSOR, IfcSensorType_FROSTSENSOR, IfcSensorType_GASSENSOR, IfcSensorType_HEATSENSOR, IfcSensorType_HUMIDITYSENSOR, IfcSensorType_IDENTIFIERSENSOR, IfcSensorType_IONCONCENTRATIONSENSOR, IfcSensorType_LEVELSENSOR, IfcSensorType_LIGHTSENSOR, IfcSensorType_MOISTURESENSOR, IfcSensorType_MOVEMENTSENSOR, IfcSensorType_PHSENSOR, IfcSensorType_PRESSURESENSOR, IfcSensorType_RADIATIONSENSOR, IfcSensorType_RADIOACTIVITYSENSOR, IfcSensorType_SMOKESENSOR, IfcSensorType_SOUNDSENSOR, IfcSensorType_TEMPERATURESENSOR, IfcSensorType_WINDSENSOR, IfcSensorType_USERDEFINED, IfcSensorType_NOTDEFINED} IfcSensorTypeEnum;
IFC_PARSE_API const char* ToString(IfcSensorTypeEnum v);
IFC_PARSE_API IfcSensorTypeEnum FromString(const std::string& s);
}
namespace IfcSequenceEnum {
/// IfcSequenceEnum is an
///   enumeration that defines the different ways in which a
///   time lag is applied to a sequence between two processes.
/// 
/// HISTORY  New entity in IFC 1.0
typedef enum {IfcSequence_START_START, IfcSequence_START_FINISH, IfcSequence_FINISH_START, IfcSequence_FINISH_FINISH, IfcSequence_USERDEFINED, IfcSequence_NOTDEFINED} IfcSequenceEnum;
IFC_PARSE_API const char* ToString(IfcSequenceEnum v);
IFC_PARSE_API IfcSequenceEnum FromString(const std::string& s);
}
namespace IfcShadingDeviceTypeEnum {
/// Definition from IAI: Enumeration defining the valid
/// types of shading devices that can be predefined using the
/// enumeration values.
/// 
/// JALOUSIE
/// SHUTTER
/// AWNING
/// 
/// HISTORY  New Enumeration
/// in Release IFC2x4
typedef enum {IfcShadingDeviceType_JALOUSIE, IfcShadingDeviceType_SHUTTER, IfcShadingDeviceType_AWNING, IfcShadingDeviceType_USERDEFINED, IfcShadingDeviceType_NOTDEFINED} IfcShadingDeviceTypeEnum;
IFC_PARSE_API const char* ToString(IfcShadingDeviceTypeEnum v);
IFC_PARSE_API IfcShadingDeviceTypeEnum FromString(const std::string& s);
}
namespace IfcSimplePropertyTemplateTypeEnum {
/// This enumeration defines the correct subtype of instances of IfcSimpleProperty or IfcPhysicalSimpleQuantity that are created and are assigned to this IfcSimplePropertyTemplate. It also determines how the attributes of IfcPropertyTemplate, PrimaryUnit, SecondaryUnit, PrimaryDataType, SecondaryDataType, should be used.
/// 
/// HISTORY New enumeration in IFC2x4.
/// 
/// Enumeration
/// 
/// P_SINGLEVALUE: the properties defined by this IfcPropertyTemplate are of type IfcPropertySingleValue.
/// P_ENUMERATEDVALUE: the properties defined by this IfcPropertyTemplate are of type IfcPropertyEnumeratedValue.
/// P_BOUNDEDVALUE: the properties defined by this IfcPropertyTemplate are of type IfcPropertyBoundedValue.
/// P_LISTVALUE: the properties defined by this IfcPropertyTemplate are of type IfcPropertyListValue.
/// P_TABLEVALUE: the properties defined by this IfcPropertyTemplate are of type IfcPropertyTableValue.
/// P_REFERENCEVALUE: the properties defined by this IfcPropertyTemplate are of type IfcPropertyReferenceValue.
/// Q_LENGTH: the properties defined by this IfcPropertyTemplate are of type IfcQuantityLength.
/// Q_AREA: the properties defined by this IfcPropertyTemplate are of type IfcQuantityArea.
/// Q_VOLUME: the properties defined by this IfcPropertyTemplate are of type IfcQuantityVolume.
/// Q_COUNT: the properties defined by this IfcPropertyTemplate are of type IfcQuantityCount.
/// Q_WEIGHT: the properties defined by this IfcPropertyTemplate are of type IfcQuantityWeight.
/// Q_TIME: the properties defined by this IfcPropertyTemplate are of type IfcQuantityTime.
typedef enum {IfcSimplePropertyTemplateType_P_SINGLEVALUE, IfcSimplePropertyTemplateType_P_ENUMERATEDVALUE, IfcSimplePropertyTemplateType_P_BOUNDEDVALUE, IfcSimplePropertyTemplateType_P_LISTVALUE, IfcSimplePropertyTemplateType_P_TABLEVALUE, IfcSimplePropertyTemplateType_P_REFERENCEVALUE, IfcSimplePropertyTemplateType_Q_LENGTH, IfcSimplePropertyTemplateType_Q_AREA, IfcSimplePropertyTemplateType_Q_VOLUME, IfcSimplePropertyTemplateType_Q_COUNT, IfcSimplePropertyTemplateType_Q_WEIGHT, IfcSimplePropertyTemplateType_Q_TIME} IfcSimplePropertyTemplateTypeEnum;
IFC_PARSE_API const char* ToString(IfcSimplePropertyTemplateTypeEnum v);
IFC_PARSE_API IfcSimplePropertyTemplateTypeEnum FromString(const std::string& s);
}
namespace IfcSlabTypeEnum {
/// Definition from IAI: This enumeration defines the
///   available predefined types of a slab. The
///   IfcSlabTypeEnum can be used for slab occurrences,
///   IfcSlab, and slab types, IfcSlabType. A
///   special property set definition may be provided for each
///   predefined type.
/// 
/// HISTORY  New type in IFC
///   Release 2.0
/// 
/// Floor
/// 
/// The slab is used to represent a floor slab.
/// 
/// Roof
/// 
/// The slab is used to represent a roof slab (either
///   flat or sloped).
/// 
/// Landing
/// 
/// The slab is used to represent a landing within a
///   stair or ramp.
/// 
/// BaseSlab
/// 
/// The slab is used to represent a floor slab against
///   the ground (and thereby being a part of the
///   foundation). Another name is mat foundation.
/// 
/// IFC2x3 CHANGE
///    new enumerator added.
typedef enum {IfcSlabType_FLOOR, IfcSlabType_ROOF, IfcSlabType_LANDING, IfcSlabType_BASESLAB, IfcSlabType_USERDEFINED, IfcSlabType_NOTDEFINED} IfcSlabTypeEnum;
IFC_PARSE_API const char* ToString(IfcSlabTypeEnum v);
IFC_PARSE_API IfcSlabTypeEnum FromString(const std::string& s);
}
namespace IfcSolarDeviceTypeEnum {
/// The IfcSolarDeviceTypeEnum defines the range of types of solar devices available.
///   HISTORY: New type in IFC 2x4. 
/// 
/// Enumeration 
/// 
/// SOLARCOLLECTOR: A device that converts solar radiation into thermal energy (heating water, etc.). 
/// SOLARPANEL: A device that converts solar radiation into electric current. 
/// USERDEFINED: User-defined type.  
/// NOTDEFINED: Undefined type.
typedef enum {IfcSolarDeviceType_SOLARCOLLECTOR, IfcSolarDeviceType_SOLARPANEL, IfcSolarDeviceType_USERDEFINED, IfcSolarDeviceType_NOTDEFINED} IfcSolarDeviceTypeEnum;
IFC_PARSE_API const char* ToString(IfcSolarDeviceTypeEnum v);
IFC_PARSE_API IfcSolarDeviceTypeEnum FromString(const std::string& s);
}
namespace IfcSpaceHeaterTypeEnum {
/// Enumeration defining the functional type of space heater.
/// 
/// The IfcSpaceHeaterTypeEnum contains the following:
/// 
/// CONVECTOR: A heat-distributing unit that operates with gravity-circulated air.
/// RADIATOR: A heat-distributing unit that operates with thermal radiation.
/// USERDEFINED: User-defined space heater type.
/// NOTDEFINED:  Undefined space heater type.
/// 
/// NOTE: This enumeration was revised in IFC 2x4 and was renamed from IfcHydronicHeaterTypeEnum in IFC R2x.
/// 
/// HISTORY: New enumeration in IFC R2x.
typedef enum {IfcSpaceHeaterType_CONVECTOR, IfcSpaceHeaterType_RADIATOR, IfcSpaceHeaterType_USERDEFINED, IfcSpaceHeaterType_NOTDEFINED} IfcSpaceHeaterTypeEnum;
IFC_PARSE_API const char* ToString(IfcSpaceHeaterTypeEnum v);
IFC_PARSE_API IfcSpaceHeaterTypeEnum FromString(const std::string& s);
}
namespace IfcSpaceTypeEnum {
/// Definition from IAI: This enumeration defines the
/// available generic types for IfcSpace and
/// IfcSpaceType.
/// HISTORY New enumeration
/// in IFC2x3.
/// IFC2x4 CHANGE The enumerators
/// INTERNAL and EXTERNAL have been added for upward compatibility to
/// replace InteriorOrExteriorSpace
/// usage.
/// Enumeration
/// 
/// SPACE Any space not falling into another category.
/// 
/// NOTE For classification of spaces according to its
/// function that is often determined by national classification
/// systems use IfcClassificationReference via the
/// relationship IfcRelAssociatesClassification.
/// 
/// PARKING A space dedication for use as a parking spot
/// for vehicles, including access, such as a parking aisle
/// GFA Gross Floor Area - a specific kind of space for
/// each building story that includes all net area and construction
/// area (also the external envelop). Provision of such a specific
/// space is often required by regulations.
/// INTERNAL
/// 
/// NOTE the use is deprecated and
/// only provided for backward compatibility
/// purposes.
/// 
/// EXTERNAL
/// 
/// NOTE the use is deprecated and
/// only provided for backward compatibility
/// purposes.
typedef enum {IfcSpaceType_SPACE, IfcSpaceType_PARKING, IfcSpaceType_GFA, IfcSpaceType_INTERNAL, IfcSpaceType_EXTERNAL, IfcSpaceType_USERDEFINED, IfcSpaceType_NOTDEFINED} IfcSpaceTypeEnum;
IFC_PARSE_API const char* ToString(IfcSpaceTypeEnum v);
IFC_PARSE_API IfcSpaceTypeEnum FromString(const std::string& s);
}
namespace IfcSpatialZoneTypeEnum {
/// Definition from IAI: This enumeration defines the range
/// of different types of spatial zones that can further specify an
/// IfcSpatialZoneTypeEnum.
/// HISTORY New enumeration
/// in IFC Release 2x Edition 4.
/// Enumeration
/// 
/// CONSTRUCTION: the spatial zone is used
/// to represent a construction zone for the production process
/// FIRESAFETY: the spatial zone is used to
/// represent a fire safety zone, or fire compartment
/// LIGHTING: the spatial zone is used to
/// represent a lighting zone, e.g. a daylight zone, or a artificial
/// lighting zone
/// OCCUPANCY: the spatial zone is used to
/// represent a zone of particular occupancy
/// SECURITY: the spatial zone is used to
/// represent a zone for security planning and maintainance
/// work.
/// THERMAL: the spatial zone is used to
/// represent a thermal zone
/// USERDEFINED: user defined type spatial
/// zone
/// NOTDEFINED: undefined type spatial
/// zone
typedef enum {IfcSpatialZoneType_CONSTRUCTION, IfcSpatialZoneType_FIRESAFETY, IfcSpatialZoneType_LIGHTING, IfcSpatialZoneType_OCCUPANCY, IfcSpatialZoneType_SECURITY, IfcSpatialZoneType_THERMAL, IfcSpatialZoneType_TRANSPORT, IfcSpatialZoneType_VENTILATION, IfcSpatialZoneType_USERDEFINED, IfcSpatialZoneType_NOTDEFINED} IfcSpatialZoneTypeEnum;
IFC_PARSE_API const char* ToString(IfcSpatialZoneTypeEnum v);
IFC_PARSE_API IfcSpatialZoneTypeEnum FromString(const std::string& s);
}
namespace IfcStackTerminalTypeEnum {
/// An IfcStackTerminalTypeEnum defines the range of different types of stack terminal that can be specified for use at the top of a vertical stack subsystem. 
///   HISTORY: New type in IFC 2x  
///   Enumeration 
/// 
/// BIRDCAGE: Guard cage, typically wire mesh, at the top of the stack preventing access by birds. 
/// COWL: A cowling placed at the top of a stack to eliminate downdraft. 
/// RAINWATERHOPPER: A box placed at the top of a rainwater downpipe to catch rainwater from guttering. 
/// USERDEFINED: User-defined type. 
/// NOTDEFINED: Undefined type.
typedef enum {IfcStackTerminalType_BIRDCAGE, IfcStackTerminalType_COWL, IfcStackTerminalType_RAINWATERHOPPER, IfcStackTerminalType_USERDEFINED, IfcStackTerminalType_NOTDEFINED} IfcStackTerminalTypeEnum;
IFC_PARSE_API const char* ToString(IfcStackTerminalTypeEnum v);
IFC_PARSE_API IfcStackTerminalTypeEnum FromString(const std::string& s);
}
namespace IfcStairFlightTypeEnum {
/// Definition from IAI: This enumeration defines the different types
///   of stair flights an IfcStairFlightType object can fulfill: 
/// 
/// STRAIGHT: A stair flight with a straight walking line.  
///   WINDER: A stair flight with a straight walking line. 
///   SPIRAL: A stair flight with a circular or elliptic walking
///   line. 
///   CURVED: A stair flight with a curved walking line. 
///   FREEFORM: A stair flight with a free form walking line (and
///   outer boundaries). 
///   USERDEFINED: User-defined stair flight . 
///   NOTDEFINED: Undefined stair flight . 
/// 
/// HISTORY: New Enumeration in
///   Release IFC2x Edition 2.
typedef enum {IfcStairFlightType_STRAIGHT, IfcStairFlightType_WINDER, IfcStairFlightType_SPIRAL, IfcStairFlightType_CURVED, IfcStairFlightType_FREEFORM, IfcStairFlightType_USERDEFINED, IfcStairFlightType_NOTDEFINED} IfcStairFlightTypeEnum;
IFC_PARSE_API const char* ToString(IfcStairFlightTypeEnum v);
IFC_PARSE_API IfcStairFlightTypeEnum FromString(const std::string& s);
}
namespace IfcStairTypeEnum {
/// This enumeration defines the basic configuration of the stair type in terms of the number of stair flights and the number of landings, as illustrated in Figure 69. The type also distinguished turns by windings or by landings. In addition the subdivision of the straight and changing direction stairs is included. The stair configurations are given for stairs without and with one, two or three landings. 
/// 
/// Stairs which are subdivided into more than three landings have to be defined by the geometry only. Also stairs with non-regular shapes have to be defined by the geometry only. The type of such stairs is OTHEROPERATION. 
/// 
/// HISTORY New Enumeration in IFC Release 2.0. 
/// 
/// Enumerator 
///   Description 
///   Figure 
/// 
/// StraightRunStair 
///   A stair extending from
///   one level to another without turns or winders. The stair consists of one
///   straight flight. 
/// 
/// TwoStraightRunStair 
///   A straight stair
///   consisting of two straight flights without turns but with one landing. 
/// 
/// QuarterWindingStair 
///   A stair consisting of one
///   flight with a quarter winder, which is making a 90° turn. The direction of
///   the turn is determined by the walking line. 
/// 
/// QuarterTurnStair 
///   A stair making a 90°
///   turn, consisting of two straight flights connected by a quarterspace landing.
///   The direction of the turn is determined by the walking line. 
/// 
/// HalfWindingStair 
///   A stair consisting of one
///   flight with one half winder, which makes a 180° turn. The orientation of
///   the turn is determined by the walking line. 
/// 
/// HalfTurnStair 
///   A stair making a 180°
///   turn, consisting of two straight flights connected by a halfspace landing. The
///   orientation of the turn is determined by the walking line. 
/// 
/// TwoQuarterWindingStair 
///   A stair consisting of one
///   flight with two quarter winders, which make a 90° turn. The stair makes a
///   180° turn. The direction of the turns is determined by the walking
///   line. 
/// 
/// TwoQuarterTurnStair 
///   A stair making a 180°
///   turn, consisting of three straight flights connected by two quarterspace
///   landings. The direction of the turns is determined by the walking line. 
/// 
/// ThreeQuarterWindingStair
/// 
/// A stair consisting of one
///   flight with three quarter winders, which make a 90° turn. The stair makes a
///   270° turn. The direction of the turns is determined by the walking
///   line. 
/// 
/// ThreeQuarterTurnStair 
///   A stair making a 270°
///   turn, consisting of four straight flights connected by three quarterspace
///   landings. The direction of the turns is determined by the walking line. 
/// 
/// SpiralStair 
///   A stair constructed with
///   winders around a circular newel often without landings. Depending on outer
///   boundary it can be either a circular, elliptical or rectangular spiral stair.
///   The orientation of the winding stairs is determined by the walking line. 
/// 
/// DoubleReturnStair 
///   A stair having one
///   straight flight to a wide quarterspace landing, and two side flights from that
///   landing into opposite directions. The stair is making a 90° turn. The
///   direction of traffic is determined by the walking line. 
/// 
/// CurvedRunStair 
///   A stair extending from one
///   level to another without turns or winders. The stair is consisting of one
///   curved flight. 
/// 
/// TwoCurvedRunStair 
///   A curved stair consisting of
///   two curved flights without turns but with one landing. 
/// 
/// OtherOperation 
///   Free form stair (user defined
///   operation type) 
///     
/// 
/// NotDefined 
///     
///     
/// 
/// Figure 69 — Stair types
typedef enum {IfcStairType_STRAIGHT_RUN_STAIR, IfcStairType_TWO_STRAIGHT_RUN_STAIR, IfcStairType_QUARTER_WINDING_STAIR, IfcStairType_QUARTER_TURN_STAIR, IfcStairType_HALF_WINDING_STAIR, IfcStairType_HALF_TURN_STAIR, IfcStairType_TWO_QUARTER_WINDING_STAIR, IfcStairType_TWO_QUARTER_TURN_STAIR, IfcStairType_THREE_QUARTER_WINDING_STAIR, IfcStairType_THREE_QUARTER_TURN_STAIR, IfcStairType_SPIRAL_STAIR, IfcStairType_DOUBLE_RETURN_STAIR, IfcStairType_CURVED_RUN_STAIR, IfcStairType_TWO_CURVED_RUN_STAIR, IfcStairType_USERDEFINED, IfcStairType_NOTDEFINED} IfcStairTypeEnum;
IFC_PARSE_API const char* ToString(IfcStairTypeEnum v);
IFC_PARSE_API IfcStairTypeEnum FromString(const std::string& s);
}
namespace IfcStateEnum {
/// The IfcStateEnum enumeration identifies the state or accessibility of the object (for example, read/write, locked).
/// 
/// Valid enumerations are:
/// 
/// READWRITE: Object is in a Read-Write state. It may be modified by an application.
/// READONLY: Object is in a Read-Only state. It may be viewed but not modified by an application.
/// LOCKED: Object is in a Locked state. It may not be accessed by an application.
/// READWRITELOCKED: Object is in a Read-Write-Locked state. It may not be accessed by an application.
/// READONLYLOCKED: Object is in a Read-Only-Locked state. It may not be accessed by an application.
/// 
/// HISTORY  New enumeration in IFC R2.0.
/// 
/// IFC2x3 CHANGE  This concept was initially introduced in IFC 2.0 as IfcModifiedFlag of type BINARY(3) FIXED and has been modified in R2x to an enumeration. It was initially introduced as a first step towards providing facilities for partial model exchange from a server as requested by the IFC implementers. It is intended for use primarily by a model server so that an application can identify the state of the object.
typedef enum {IfcState_READWRITE, IfcState_READONLY, IfcState_LOCKED, IfcState_READWRITELOCKED, IfcState_READONLYLOCKED} IfcStateEnum;
IFC_PARSE_API const char* ToString(IfcStateEnum v);
IFC_PARSE_API IfcStateEnum FromString(const std::string& s);
}
namespace IfcStructuralCurveActivityTypeEnum {
/// Definition from IAI: Enumeration defining the distribution of load values in a curve action or reaction.
/// 
/// HISTORY New type in IFC 2x4
/// 
/// ENUMERATION 
/// 
/// CONST The load has a constant value over its entire extent.
///   LINEAR The load value is linearly distributed over the load's extent.
///   POLYGONAL The load consists of several consecutive linear sections.
///   EQUIDISTANT The load consists of n consecutive sections of same length and is specified by n+1 load samples.  The interpolation type over the segments is not defined by this distribution type but may be qualified in IfcObject.ObjectType based on additional agreements.
///   SINUS The load value is distributed as a sinus half wave.
///   PARABOLA The load value is distributed as a half wave described by a symmetric quadratic parabola.
///   DISCRETE The load is specified as a series of discrete load points.
///   USERDEFINED The load distribution is user-defined.
///   NOTDEFINED The load distribution is undefined.
typedef enum {IfcStructuralCurveActivityType_CONST, IfcStructuralCurveActivityType_LINEAR, IfcStructuralCurveActivityType_POLYGONAL, IfcStructuralCurveActivityType_EQUIDISTANT, IfcStructuralCurveActivityType_SINUS, IfcStructuralCurveActivityType_PARABOLA, IfcStructuralCurveActivityType_DISCRETE, IfcStructuralCurveActivityType_USERDEFINED, IfcStructuralCurveActivityType_NOTDEFINED} IfcStructuralCurveActivityTypeEnum;
IFC_PARSE_API const char* ToString(IfcStructuralCurveActivityTypeEnum v);
IFC_PARSE_API IfcStructuralCurveActivityTypeEnum FromString(const std::string& s);
}
namespace IfcStructuralCurveMemberTypeEnum {
/// Definition from IAI: This type definition shall be used to
/// 
/// distinguish between different types of structural 'curve' members, such as
/// 
/// cables. The IfcStructuralCurveTypeEnum type is referenced by the entity
/// 
/// IfcStructuralCurveMember. 
/// 
/// RIGID_JOINED_MEMBER:  A member with capacity to carry transverse and axial loads, i.e. a beam. Its actual joints may be rigid or pinned. Typically used in rigid frames.
/// PIN_JOINED_MEMBER:    A member with capacity to carry axial loads only, i.e. a link. Typically used in trusses.
/// CABLE:                A tension member which is able to carry transverse loads only under large deflection.
/// TENSION_MEMBER:       A member without compressional stiffness.
/// COMPRESSION_MEMBER:   A member without tensional stiffness.
/// USERDEFINED:          A specially defined member.
/// NOTDEFINED:           A member without further categorization.
/// 
/// HISTORY New type in IFC 2x2.
/// IFC 2x4 change:  Renamed from IfcStructuralCurveTypeEnum.
typedef enum {IfcStructuralCurveMemberType_RIGID_JOINED_MEMBER, IfcStructuralCurveMemberType_PIN_JOINED_MEMBER, IfcStructuralCurveMemberType_CABLE, IfcStructuralCurveMemberType_TENSION_MEMBER, IfcStructuralCurveMemberType_COMPRESSION_MEMBER, IfcStructuralCurveMemberType_USERDEFINED, IfcStructuralCurveMemberType_NOTDEFINED} IfcStructuralCurveMemberTypeEnum;
IFC_PARSE_API const char* ToString(IfcStructuralCurveMemberTypeEnum v);
IFC_PARSE_API IfcStructuralCurveMemberTypeEnum FromString(const std::string& s);
}
namespace IfcStructuralSurfaceActivityTypeEnum {
/// Definition from IAI: Enumeration defining the distribution of load values in a surface action or reaction.
/// 
/// HISTORY New type in IFC 2x4
/// 
/// ENUMERATION 
/// 
/// CONST The load has a constant value over its entire extent.
///   BILINEAR The load value is bilinearly distributed over the load's extent.
///   DISCRETE The load is specified as a series of discrete load points.
///   ISOCONTOUR The load is specified by a series of iso-curves (level sets), i.e. curves at which the load value is constant.  These curves run perpendicularly to the load gradient.
///   USERDEFINED The load distribution is user-defined.
///   NOTDEFINED The load distribution is undefined.
typedef enum {IfcStructuralSurfaceActivityType_CONST, IfcStructuralSurfaceActivityType_BILINEAR, IfcStructuralSurfaceActivityType_DISCRETE, IfcStructuralSurfaceActivityType_ISOCONTOUR, IfcStructuralSurfaceActivityType_USERDEFINED, IfcStructuralSurfaceActivityType_NOTDEFINED} IfcStructuralSurfaceActivityTypeEnum;
IFC_PARSE_API const char* ToString(IfcStructuralSurfaceActivityTypeEnum v);
IFC_PARSE_API IfcStructuralSurfaceActivityTypeEnum FromString(const std::string& s);
}
namespace IfcStructuralSurfaceMemberTypeEnum {
/// Definition from IAI: This type definition shall be used to
/// 
/// distinguish between different types of structural surface members, such as the
/// 
/// typical mechanical function of walls, slabs and shells.
/// 
/// BENDING_ELEMENT:   A member with capacity to carry out-of-plane loads, i.e. a plate.
/// MEMBRANE_ELEMENT:  A member with capacity to carry in-plane loads, for example a shear wall.
/// SHELL:             A member with capacity to carry in-plane and out-of-plane loads, i.e. a combination of bending element and membrane element.
/// USERDEFINED:       A specially defined member.
/// NOTDEFINED:        A member without further categorization.
/// 
/// HISTORY New type in IFC 2x2.
/// IFC 2x4 change:  Renamed from IfcStructuralSurfaceTypeEnum.
typedef enum {IfcStructuralSurfaceMemberType_BENDING_ELEMENT, IfcStructuralSurfaceMemberType_MEMBRANE_ELEMENT, IfcStructuralSurfaceMemberType_SHELL, IfcStructuralSurfaceMemberType_USERDEFINED, IfcStructuralSurfaceMemberType_NOTDEFINED} IfcStructuralSurfaceMemberTypeEnum;
IFC_PARSE_API const char* ToString(IfcStructuralSurfaceMemberTypeEnum v);
IFC_PARSE_API IfcStructuralSurfaceMemberTypeEnum FromString(const std::string& s);
}
namespace IfcSubContractResourceTypeEnum {
/// This enumeration is used to identify the primary purpose of a subcontract resource.  The IfcSubContractResourceTypeEnum contains the following:
/// 
/// PURCHASE: Furnishing or supplying products.
/// WORK: Performing work onsite.
/// USERDEFINED: User-defined resource.
/// NOTDEFINED: Undefined resource.
/// 
/// HISTORY: New enumeration in IFC2x4
typedef enum {IfcSubContractResourceType_PURCHASE, IfcSubContractResourceType_WORK, IfcSubContractResourceType_USERDEFINED, IfcSubContractResourceType_NOTDEFINED} IfcSubContractResourceTypeEnum;
IFC_PARSE_API const char* ToString(IfcSubContractResourceTypeEnum v);
IFC_PARSE_API IfcSubContractResourceTypeEnum FromString(const std::string& s);
}
namespace IfcSurfaceFeatureTypeEnum {
/// Definition from IAI: This enumeration indicates the type of a surface feature.
/// 
/// HISTORY New type in IFC 2x4.
/// 
/// ENUMERATION
/// 
/// MARK A point, line, cross, or other mark, applied for example for easier adjustment of elements during assembly.
///   TAG A name tag, which allows to identify an element during production, delivery and assembly.  May be manufactured in different ways, e.g. by printing or punching the tracking code onto the element or by attaching an actual tag.
///   TREATMENT A subtractive surface feature, e.g. grinding, or an additive surface feature, e.g. coating, or an impregnating treatment, or a series of any of these kinds of treatments.
///   USERDEFINED A user-defined type of surface feature.
///   NOTDEFINED An undefined type of surface feature.
typedef enum {IfcSurfaceFeatureType_MARK, IfcSurfaceFeatureType_TAG, IfcSurfaceFeatureType_TREATMENT, IfcSurfaceFeatureType_USERDEFINED, IfcSurfaceFeatureType_NOTDEFINED} IfcSurfaceFeatureTypeEnum;
IFC_PARSE_API const char* ToString(IfcSurfaceFeatureTypeEnum v);
IFC_PARSE_API IfcSurfaceFeatureTypeEnum FromString(const std::string& s);
}
namespace IfcSurfaceSide {
/// IfcSurfaceSide is a denotion of whether negative, positive or both sides of a surface are being referenced. 
/// 
/// ENUMERATION Definition from ISO/CD 10303-46:1992: 
/// 
/// POSITIVE: The side of a surface which is in the same direction as the surface normal derived from the mathematical definition.  
/// NEGATIVE: The side of a surface which is in the opposite direction than the surface normal derived from the mathematical definition. 
/// BOTH: Both, positive and negative side. 
/// 
/// NOTE Corresponding ISO 10303 type: surface_side. Please refer to ISO/IS 10303-46:1994 for the final definition of the formal standard.
/// 
/// HISTORY: New Enumeration in IFC 2.0
typedef enum {IfcSurfaceSide_POSITIVE, IfcSurfaceSide_NEGATIVE, IfcSurfaceSide_BOTH} IfcSurfaceSide;
IFC_PARSE_API const char* ToString(IfcSurfaceSide v);
IFC_PARSE_API IfcSurfaceSide FromString(const std::string& s);
}
namespace IfcSwitchingDeviceTypeEnum {
/// The IfcSwitchingDeviceTypeEnum defines the range of different types of switch that can be specified. 
///   HISTORY: New type in IFC 2x2 
///   Enumeration 
/// 
/// CONTACTOR: An electrical device used to control the flow of power in a circuit on or off. 
/// DIMMERSWITCH: A dimmer switch has variable positions, and may adjust electrical power or other setting (according to the switched port type). 
/// EMERGENCYSTOP: An emergency stop device acts to remove as quickly as possible any danger that may have arisen unexpectedly. 
/// KEYPAD: A set of buttons or switches, each potentially applicable to a different device.  
/// MOMENTARYSWITCH: A momentary switch has no position, and may trigger some action to occur.  
/// SELECTORSWITCH: A selector switch has multiple positions, and may switch connectivity or other setting.  
/// STARTER: A starter is a switch which in the closed position controls the application of power to an electrical device. 
/// SWITCHDISCONNECTOR: A switch disconnector is a switch which in the open position satisfies the isolating requirements specified for a disconnector. 
/// SELECTORSWITCH: A selector switch has multiple positions, and may change the source or level of power or other setting (according to the switched port type). 
/// TOGGLESWITCH: A toggle switch has two positions, and may enable or isolate electrical power or other setting (according to the switched port type). 
/// USERDEFINED: User-defined type. 
/// NOTDEFINED: Undefined type.
typedef enum {IfcSwitchingDeviceType_CONTACTOR, IfcSwitchingDeviceType_DIMMERSWITCH, IfcSwitchingDeviceType_EMERGENCYSTOP, IfcSwitchingDeviceType_KEYPAD, IfcSwitchingDeviceType_MOMENTARYSWITCH, IfcSwitchingDeviceType_SELECTORSWITCH, IfcSwitchingDeviceType_STARTER, IfcSwitchingDeviceType_SWITCHDISCONNECTOR, IfcSwitchingDeviceType_TOGGLESWITCH, IfcSwitchingDeviceType_USERDEFINED, IfcSwitchingDeviceType_NOTDEFINED} IfcSwitchingDeviceTypeEnum;
IFC_PARSE_API const char* ToString(IfcSwitchingDeviceTypeEnum v);
IFC_PARSE_API IfcSwitchingDeviceTypeEnum FromString(const std::string& s);
}
namespace IfcSystemFurnitureElementTypeEnum {
/// IfcSystemFurnitureTypeEnum defines the types of system furniture from which the type required can be selected. 
///   HISTORY: New Enumeration in IFC 2x4 
///   Enumeration: 
/// 
/// PANEL: Vertical panel used to divide work spaces.  
/// WORKSURFACE: Workstation countertop.  
/// USERDEFINED: User-defined type.  
/// NOTDEFINED: Undefined type.
typedef enum {IfcSystemFurnitureElementType_PANEL, IfcSystemFurnitureElementType_WORKSURFACE, IfcSystemFurnitureElementType_USERDEFINED, IfcSystemFurnitureElementType_NOTDEFINED} IfcSystemFurnitureElementTypeEnum;
IFC_PARSE_API const char* ToString(IfcSystemFurnitureElementTypeEnum v);
IFC_PARSE_API IfcSystemFurnitureElementTypeEnum FromString(const std::string& s);
}
namespace IfcTankTypeEnum {
/// Enumeration defining the typical types of tanks.
/// 
/// The IfcTankTypeEnum contains the following:
/// 
/// BASIN:  An arbitrary open tank type.
/// 
/// BREAKPRESSURE:  An open container that breaks the hydraulic pressure in a distribution system, typically located between the fluid reservoir and the fluid supply points. A typical break pressure tank allows the flow to discharge into the atmosphere, thereby reducing its hydrostatic pressure to zero.
/// 
/// EXPANSION:  A closed container used in a closed fluid distribution system to mitigate the effects of thermal expansion or water hammer. The tank is typically constructed with a diaphragm dividing the tank into two sections, with fluid on one side of the diaphragm and air on the other. One example application is when connected to the primary circuit of a hot water system to accommodate the increase in volume of the water when it is heated.
/// 
/// FEEDANDEXPANSION:  An open tank that is used for both storage and thermal expansion. A typical example is a tank used to store make-up water at ambient pressure for supply to a hot water system, simultaneously accommodating increases in volume of the water when heated.
/// 
/// PRESSUREVESSEL:  A closed container used for storing fluids or gases at a pressure different from the ambient pressure. A pressure vessel is typically rated by an authority having jurisdiction for the operational pressure.
/// 
/// STORAGE:  An open or closed containter used for storing a fluid at ambient pressure and from which it can be supplied to the fluid distribution system. There are many examples of storage tanks, such as potable water storage tanks, fuel storage tanks, etc.
/// 
/// VESSEL:  An arbitrary closed tank type.
/// 
/// USERDEFINED:  User-defined tank type.
/// 
/// NOTDEFINED:  Undefined tank type.
/// 
/// HISTORY: New enumeration in IFC 2x2.  BASIN and VESSEL added in IFC2x4.
typedef enum {IfcTankType_BASIN, IfcTankType_BREAKPRESSURE, IfcTankType_EXPANSION, IfcTankType_FEEDANDEXPANSION, IfcTankType_PRESSUREVESSEL, IfcTankType_STORAGE, IfcTankType_VESSEL, IfcTankType_USERDEFINED, IfcTankType_NOTDEFINED} IfcTankTypeEnum;
IFC_PARSE_API const char* ToString(IfcTankTypeEnum v);
IFC_PARSE_API IfcTankTypeEnum FromString(const std::string& s);
}
namespace IfcTaskDurationEnum {
/// IfcTaskDurationEnum identifies how a time duration is measured:
/// 
/// ELAPSEDTIME: The time duration is based on elapsed time (24 hours per day, independent of calendar).
///   WORKTIME: The time duration is based on work time (calendar-dependent).
///   NOTDEFINED: The time duration is undefined.
/// 
/// HISTORY: New enumeration in IFC2x4.
typedef enum {IfcTaskDuration_ELAPSEDTIME, IfcTaskDuration_WORKTIME, IfcTaskDuration_NOTDEFINED} IfcTaskDurationEnum;
IFC_PARSE_API const char* ToString(IfcTaskDurationEnum v);
IFC_PARSE_API IfcTaskDurationEnum FromString(const std::string& s);
}
namespace IfcTaskTypeEnum {
/// The IfcTaskTypeEnum defines the range of different types of task that can be specified.
/// 
/// HISTORY  New type in IFC2x4
/// 
/// Enumeration:
/// 
/// ATTENDANCE: Attendance or waiting on other things happening
/// CONSTRUCTION: Constructing or building something
/// DEMOLITION: Demolishing or breaking down something
/// DISMANTLE: Taking something apart carefully so that it can be recycled or reused
/// DISPOSAL: Disposing or getting rid of something
/// INSTALLATION: Installing something (equivalent to construction but more commonly used for engineering tasks)
/// LOGISTIC: Transporation or delivery of something
/// MAINTENANCE: Keeping something in good working order
/// MOVE: Moving things from one place to another
/// OPERATION: A procedure undertaken to start up the operation an artifact
/// REMOVAL: Removal of an item from use and taking it from its place of use
/// RENOVATION: Bringing something to an 'as-new' state
typedef enum {IfcTaskType_ATTENDANCE, IfcTaskType_CONSTRUCTION, IfcTaskType_DEMOLITION, IfcTaskType_DISMANTLE, IfcTaskType_DISPOSAL, IfcTaskType_INSTALLATION, IfcTaskType_LOGISTIC, IfcTaskType_MAINTENANCE, IfcTaskType_MOVE, IfcTaskType_OPERATION, IfcTaskType_REMOVAL, IfcTaskType_RENOVATION, IfcTaskType_USERDEFINED, IfcTaskType_NOTDEFINED} IfcTaskTypeEnum;
IFC_PARSE_API const char* ToString(IfcTaskTypeEnum v);
IFC_PARSE_API IfcTaskTypeEnum FromString(const std::string& s);
}
namespace IfcTendonAnchorTypeEnum {

typedef enum {IfcTendonAnchorType_COUPLER, IfcTendonAnchorType_FIXED_END, IfcTendonAnchorType_TENSIONING_END, IfcTendonAnchorType_USERDEFINED, IfcTendonAnchorType_NOTDEFINED} IfcTendonAnchorTypeEnum;
IFC_PARSE_API const char* ToString(IfcTendonAnchorTypeEnum v);
IFC_PARSE_API IfcTendonAnchorTypeEnum FromString(const std::string& s);
}
namespace IfcTendonTypeEnum {

typedef enum {IfcTendonType_BAR, IfcTendonType_COATED, IfcTendonType_STRAND, IfcTendonType_WIRE, IfcTendonType_USERDEFINED, IfcTendonType_NOTDEFINED} IfcTendonTypeEnum;
IFC_PARSE_API const char* ToString(IfcTendonTypeEnum v);
IFC_PARSE_API IfcTendonTypeEnum FromString(const std::string& s);
}
namespace IfcTextPath {
/// The text path determines the direction of the text characters in respect to each other.
/// 
/// NOTE: The IfcTextPath is an entity that had been adopted from ISO 10303, Industrial automation systems and integration&#151;Product data representation and exchange, Part 46: Integrated generic resources: Visual presentation.
/// 
/// NOTE Corresponding ISO 10303 name:text_path . Please refer to ISO/IS 10303-46:1994 for the final definition of the formal standard.
/// 
/// HISTORY New entity in IFC2x2.
typedef enum {IfcTextPath_LEFT, IfcTextPath_RIGHT, IfcTextPath_UP, IfcTextPath_DOWN} IfcTextPath;
IFC_PARSE_API const char* ToString(IfcTextPath v);
IFC_PARSE_API IfcTextPath FromString(const std::string& s);
}
namespace IfcTimeSeriesDataTypeEnum {
/// IfcTimeSeriesDataTypeEnum describes a type of time series data and is used to determine a value during the time series which is not explicitly specified: 
/// 
/// CONTINUOUS: The time series data is continuous. 
///   DISCRETE: The time series data is discrete. 
///   DISCRETEBINARY: The time series data is discrete binary. 
///   PIECEWISEBINARY: The time series data is piecewise binary. 
///   PIECEWISECONSTANT: The time series data is piecewise constant. 
///   PIECEWISECONTINUOUS: The time series data is piecewise continuous. 
///   NOTDEFINED: The time series data is not defined. 
/// 
/// HISTORY: New enumeration in IFC2x2.
typedef enum {IfcTimeSeriesDataType_CONTINUOUS, IfcTimeSeriesDataType_DISCRETE, IfcTimeSeriesDataType_DISCRETEBINARY, IfcTimeSeriesDataType_PIECEWISEBINARY, IfcTimeSeriesDataType_PIECEWISECONSTANT, IfcTimeSeriesDataType_PIECEWISECONTINUOUS, IfcTimeSeriesDataType_NOTDEFINED} IfcTimeSeriesDataTypeEnum;
IFC_PARSE_API const char* ToString(IfcTimeSeriesDataTypeEnum v);
IFC_PARSE_API IfcTimeSeriesDataTypeEnum FromString(const std::string& s);
}
namespace IfcTransformerTypeEnum {
/// The IfcTransformerTypeEnum defines the range of different types of transformer that can be specified. 
///   HISTORY: New type in IFC 2x2 
///   Enumeration 
/// 
/// CURRENT: A transformer that changes the current between circuits. 
/// FREQUENCY: A transformer that changes the frequency between circuits. 
/// INVERTER: A transformer that converts from direct current (DC) to alternating current (AC). 
/// RECTIFIER: A transformer that converts from alternating current (AC) to direct current (DC).  
/// VOLTAGE: A transformer that changes the voltage between circuits.  
/// USERDEFINED: User-defined type. 
/// NOTDEFINED: Undefined type.
typedef enum {IfcTransformerType_CURRENT, IfcTransformerType_FREQUENCY, IfcTransformerType_INVERTER, IfcTransformerType_RECTIFIER, IfcTransformerType_VOLTAGE, IfcTransformerType_USERDEFINED, IfcTransformerType_NOTDEFINED} IfcTransformerTypeEnum;
IFC_PARSE_API const char* ToString(IfcTransformerTypeEnum v);
IFC_PARSE_API IfcTransformerTypeEnum FromString(const std::string& s);
}
namespace IfcTransitionCode {
/// Definition from ISO/CD 10303-42:1992: This type conveys the continuity properties of a composite curve or surface. The continuity referred to is geometric, not parametric continuity. For example, in ContSameGradient the tangent vectors of successive segments will have the same direction, but may have different magnitude.  
/// 
/// NOTE  Corresponding ISO 10303 type: transition_code, please refer to ISO/IS 10303-42:1994, p. 14 for the final definition of the formal standard.
/// 
/// HISTORY  New Type in IFC Release 1.0
/// 
/// Figure 273 (quoted from ISO/CD 10303-42:1992, p.55) illustrates transition types.
/// 
/// Figure 273 — Transition code
/// 
/// ENUMERATION 
/// 
/// DISCONTINUOUS: The segments do not join. This is permitted only at the boundary of the curve or surface to indicate that it is not closed.
/// CONTINUOUS: The segments join but no condition on their tangents is implied. 
/// CONTSAMEGRADIENT: The segments join and their tangent vectors or tangent planes are parallel and have the same direction at the joint: equality of derivatives is not required. 
/// CONTSAMEGRADIENTSAMECURVATURE: For a curve, the segments join, their tangent vectors are parallel and in the same direction and their curvatures are equal at the joint: equality of derivatives is not required. For a surface this implies that the principle curvatures are the same and the principle directions are coincident along the common boundary.
typedef enum {IfcTransitionCode_DISCONTINUOUS, IfcTransitionCode_CONTINUOUS, IfcTransitionCode_CONTSAMEGRADIENT, IfcTransitionCode_CONTSAMEGRADIENTSAMECURVATURE} IfcTransitionCode;
IFC_PARSE_API const char* ToString(IfcTransitionCode v);
IFC_PARSE_API IfcTransitionCode FromString(const std::string& s);
}
namespace IfcTransportElementTypeEnum {
/// Definition from IAI: This enumeration is used to
/// identify primary transport element types. The
/// IfcTransportElementTypeEnum contains the following:
/// 
/// ELEVATOR: Elevator or lift being a transport device to
/// move people of good vertically.
/// ESCALATOR: Escalator being a transport device to move
/// people. It consists of individual linked steps that move up and
/// down on tracks while keeping the threads horizontal.
/// MOVINGWALKWAY: Moving walkway being a transport device
/// to move people horizontally or on an incline. It is a slow
/// conveyor belt that transports people.
/// CRANEWAY: A crane way system, normally including the
/// crane rails, fasteners and the crane. It is primarily used to
/// move heavy goods in a factory or other industry buildings.
/// LIFTINGGEAR: A device used for lifting or lowering
/// heavy goods. It may be manually operated or electrically or
/// pneumatically driven.
/// 
/// HISTORY  New enumeration
/// in IFC Release 2x.
/// IFC2x4 CHANGE  New enumerators
/// CRANEWAY and LIFTINGGEAR added in
/// IFC2x4.
typedef enum {IfcTransportElementType_ELEVATOR, IfcTransportElementType_ESCALATOR, IfcTransportElementType_MOVINGWALKWAY, IfcTransportElementType_CRANEWAY, IfcTransportElementType_LIFTINGGEAR, IfcTransportElementType_USERDEFINED, IfcTransportElementType_NOTDEFINED} IfcTransportElementTypeEnum;
IFC_PARSE_API const char* ToString(IfcTransportElementTypeEnum v);
IFC_PARSE_API IfcTransportElementTypeEnum FromString(const std::string& s);
}
namespace IfcTrimmingPreference {
/// Definition from ISO/CD 10303-42:1992: This type is used to describe the preferred way of trimming a parametric curve where the trimming is multiply defined. 
/// 
/// NOTE Corresponding ISO 10303 type: trimming_preference, please refer to ISO/IS 10303-42:1994, p. 18 for the final definition of the formal standard.
/// 
/// HISTORY New Type in IFC Release 1.0
/// 
/// ENUMERATION 
/// 
/// CARTESIAN: Indicates that trimming by Cartesian point is preferred. 
/// PARAMETER: Indicates the preference for the parameter value. 
/// UNSPECIFIED: Indicates that no preference is communicated.
typedef enum {IfcTrimmingPreference_CARTESIAN, IfcTrimmingPreference_PARAMETER, IfcTrimmingPreference_UNSPECIFIED} IfcTrimmingPreference;
IFC_PARSE_API const char* ToString(IfcTrimmingPreference v);
IFC_PARSE_API IfcTrimmingPreference FromString(const std::string& s);
}
namespace IfcTubeBundleTypeEnum {
/// Enumeration defining the typical types of tube bundles. 
///   The IfcTubeBundleTypeEnum contains the following:
/// 
/// FINNED:  Finned tube bundle type.
///   USERDEFINED:  User-defined tube bundle type.
///   NOTDEFINED:  Undefined tube bundle type.
/// 
/// HISTORY: New enumeration in IFC 2x2.
typedef enum {IfcTubeBundleType_FINNED, IfcTubeBundleType_USERDEFINED, IfcTubeBundleType_NOTDEFINED} IfcTubeBundleTypeEnum;
IFC_PARSE_API const char* ToString(IfcTubeBundleTypeEnum v);
IFC_PARSE_API IfcTubeBundleTypeEnum FromString(const std::string& s);
}
namespace IfcUnitEnum {
/// IfcUnitEnum is an enumeration type for allowed unit types of IfcNamedUnit.
/// 
/// ENUMERATION 
/// 
/// ABSORBEDDOSEUNIT
///   AMOUNTOFSUBSTANCEUNIT
///   AREAUNIT
///   DOSEEQUIVALENTUNIT
///   ELECTRICCAPACITANCEUNIT
///   ELECTRICCHARGEUNIT
///   ELECTRICCONDUCTANCEUNIT
///   ELECTRICCURRENTUNIT
///   ELECTRICRESISTANCEUNIT
///   ELECTRICVOLTAGEUNIT
///   ENERGYUNIT
///   FORCEUNIT
///   FREQUENCYUNIT
///   ILLUMINANCEUNIT
///   INDUCTANCEUNIT
///   LENGTHUNIT
///   LUMINOUSFLUXUNIT
///   LUMINOUSINTENSITYUNIT
///   MAGNETICFLUXDENSITYUNIT
///   MAGNETICFLUXUNIT
///   MASSUNIT
///   PLANEANGLEUNIT
///   POWERUNIT
///   PRESSUREUNIT
///   RADIOACTIVITYUNIT
///   SOLIDANGLEUNIT
///   THERMODYNAMICTEMPERATUREUNIT
///   TIMEUNIT
///   VOLUMEUNIT
///   USERDEFINED: User defined unit type. The type of unit is only implied by its name or the usage context.
/// 
/// HISTORY New type in IFC Release 1.5.1.
typedef enum {IfcUnit_ABSORBEDDOSEUNIT, IfcUnit_AMOUNTOFSUBSTANCEUNIT, IfcUnit_AREAUNIT, IfcUnit_DOSEEQUIVALENTUNIT, IfcUnit_ELECTRICCAPACITANCEUNIT, IfcUnit_ELECTRICCHARGEUNIT, IfcUnit_ELECTRICCONDUCTANCEUNIT, IfcUnit_ELECTRICCURRENTUNIT, IfcUnit_ELECTRICRESISTANCEUNIT, IfcUnit_ELECTRICVOLTAGEUNIT, IfcUnit_ENERGYUNIT, IfcUnit_FORCEUNIT, IfcUnit_FREQUENCYUNIT, IfcUnit_ILLUMINANCEUNIT, IfcUnit_INDUCTANCEUNIT, IfcUnit_LENGTHUNIT, IfcUnit_LUMINOUSFLUXUNIT, IfcUnit_LUMINOUSINTENSITYUNIT, IfcUnit_MAGNETICFLUXDENSITYUNIT, IfcUnit_MAGNETICFLUXUNIT, IfcUnit_MASSUNIT, IfcUnit_PLANEANGLEUNIT, IfcUnit_POWERUNIT, IfcUnit_PRESSUREUNIT, IfcUnit_RADIOACTIVITYUNIT, IfcUnit_SOLIDANGLEUNIT, IfcUnit_THERMODYNAMICTEMPERATUREUNIT, IfcUnit_TIMEUNIT, IfcUnit_VOLUMEUNIT, IfcUnit_USERDEFINED} IfcUnitEnum;
IFC_PARSE_API const char* ToString(IfcUnitEnum v);
IFC_PARSE_API IfcUnitEnum FromString(const std::string& s);
}
namespace IfcUnitaryControlElementTypeEnum {
/// The IfcUnitaryControlElementTypeEnum defines the range of different types and/or functions of unitary control elements possible. 
/// 
/// HISTORY: New type in IFC 2x4. 
/// 
/// Enumeration 
/// 
/// ALARMPANEL: A control element at which alarms are annunciated. 
/// CONTROLPANEL: A control element at which devices that control or monitor the operation of a site, building or part of a building are located. 
/// GASDETECTORPANEL: A control element at which the detection of gas is annunciated. 
/// INDICATORPANEL: A control element at which equipment operational status, condition, safety state or other required parameters are indicated. 
/// MIMICPANEL: A control element at which information that is available elsewhere is repeated or 'mimicked'. 
/// HUMIDISTAT: A control element that senses and regulates the humidity of a system or space so that the humidity is maintained near a desired setpoint. 
/// THERMOSTAT: A control element that senses and regulates the temperature of an element, system or space so that the temperature is maintained near a desired setpoint. 
/// WEATHERSTATION: A control element that senses multiple climate properties such as temperature, humidity, pressure, wind, and rain. 
/// USERDEFINED: User-defined type. 
/// NOTDEFINED: Undefined type.
typedef enum {IfcUnitaryControlElementType_ALARMPANEL, IfcUnitaryControlElementType_CONTROLPANEL, IfcUnitaryControlElementType_GASDETECTIONPANEL, IfcUnitaryControlElementType_INDICATORPANEL, IfcUnitaryControlElementType_MIMICPANEL, IfcUnitaryControlElementType_HUMIDISTAT, IfcUnitaryControlElementType_THERMOSTAT, IfcUnitaryControlElementType_WEATHERSTATION, IfcUnitaryControlElementType_USERDEFINED, IfcUnitaryControlElementType_NOTDEFINED} IfcUnitaryControlElementTypeEnum;
IFC_PARSE_API const char* ToString(IfcUnitaryControlElementTypeEnum v);
IFC_PARSE_API IfcUnitaryControlElementTypeEnum FromString(const std::string& s);
}
namespace IfcUnitaryEquipmentTypeEnum {
/// Enumeration defining the functional type of unitary equipment. 
///   The IfcUnitaryEquipmentTypeEnum contains the following:
/// 
/// AIRHANDLER: A unitary air handling unit typically containing a fan, economizer, and coils.
///   AIRCONDITIONINGUNIT: A unitary packaged air-conditioning unit typically used in residential or light commercial applications.
///   DEHUMIDIFIER: A unitary packaged dehumidification unit.  Note: units supporting multiple modes (dehumidification, cooling, and/or heating) should use AIRCONDITIONINGUNIT.
///   SPLITSYSTEM: A system which separates the compressor from the evaporator, but acts as a unitary component typically within residential or light commercial applications.
///   ROOFTOPUNIT: A packaged assembly that is either field-erected or manufactured atop the roof of a large residential or commercial building and acts as a unitary component.
///   USERDEFINED: User-defined unitary equipment type.
///   NOTDEFINED:  Undefined unitary equipment type.
/// 
/// HISTORY: New enumeration in IFC R2x.  DEHUMIDIFIER added in IFC 2x4
typedef enum {IfcUnitaryEquipmentType_AIRHANDLER, IfcUnitaryEquipmentType_AIRCONDITIONINGUNIT, IfcUnitaryEquipmentType_DEHUMIDIFIER, IfcUnitaryEquipmentType_SPLITSYSTEM, IfcUnitaryEquipmentType_ROOFTOPUNIT, IfcUnitaryEquipmentType_USERDEFINED, IfcUnitaryEquipmentType_NOTDEFINED} IfcUnitaryEquipmentTypeEnum;
IFC_PARSE_API const char* ToString(IfcUnitaryEquipmentTypeEnum v);
IFC_PARSE_API IfcUnitaryEquipmentTypeEnum FromString(const std::string& s);
}
namespace IfcValveTypeEnum {
/// The IfcValveTypeEnum defines the
///   range of different types of valve that can be specified. These are typically
///   used in conjunction with Pset_ValveTypeCommon, which contains common
///   properties for all valve types. The IfcValveTypeEnum contains:
/// 
/// AIRRELEASE: Valve used to release air from a pipe or fitting.  
///   ANTIVACUUM: Valve that opens to admit air if the pressure falls below
///   atmospheric pressure (BS6100 330 4104) 
///   CHANGEOVER: Valve that enables flow to be switched between pipelines (3 or 4
///   port). 
///   CHECK: Valve that permits water to flow in one direction only and is
///   enclosed when there is no flow (2 port). 
///   COMMISSIONING: Valve used to facilitate commissioning of a system (2 port). 
///   DIVERTING: Valve that enables flow to be diverted from one branch of a
///   pipeline to another (3 port). 
///   DOUBLECHECK: An assembly that incorporates two valves used to prevent backflow
///   (BS6100 330 4106). 
///   DOUBLEREGULATING: Valve used to facilitate regulation of fluid flow in a system.
///   DRAWOFFCOCK: A valve used to remove fluid from a piping system.
///   FAUCET: Faucet valve typically used as a flow discharge.
///   FLUSHING: Valve that flushes a predetermined quantity of water to cleanse a
///   toilet, urinal, etc.
///   GASCOCK: Valve that is used for controlling the flow of gas. 
///   GASTAP: Gas tap typically used for venting or discharging gas from a system.
///   ISOLATING: Valve that closes off flow in a pipeline. 
///   MIXING: Valve that enables flow from two branches of a pipeline to be mixed
///   together (3 port). 
///   PRESSUREREDUCING: Valve that reduces the pressure of a fluid immediately downstream
///   of its position in a pipeline to a preselected value or by a predetermined
///   ratio. 
///   PRESSURERELIEF: Spring or weight loaded valve that automatically discharges to a
///   safe place fluid that has built up to excessive pressure in pipes or
///   fittings 
///   REGULATING: Valve used to facilitate regulation of fluid flow in a system.
///   SAFETYCUTOFF: Valve that closes under the action of a safety mechanism such as a
///   drop weight, solenoid etc. 
///   STEAMTRAP: Valve that restricts flow of steam while allowing condensate to 
///   pass through. 
///   STOPCOCK: An isolating valve used on a domestic water service. 
///   USERDEFINED: User-defined valve type. 
///   NOTDEFINED: Undefined valve type. 
/// 
/// HISTORY: New type in IFC R2.0
typedef enum {IfcValveType_AIRRELEASE, IfcValveType_ANTIVACUUM, IfcValveType_CHANGEOVER, IfcValveType_CHECK, IfcValveType_COMMISSIONING, IfcValveType_DIVERTING, IfcValveType_DRAWOFFCOCK, IfcValveType_DOUBLECHECK, IfcValveType_DOUBLEREGULATING, IfcValveType_FAUCET, IfcValveType_FLUSHING, IfcValveType_GASCOCK, IfcValveType_GASTAP, IfcValveType_ISOLATING, IfcValveType_MIXING, IfcValveType_PRESSUREREDUCING, IfcValveType_PRESSURERELIEF, IfcValveType_REGULATING, IfcValveType_SAFETYCUTOFF, IfcValveType_STEAMTRAP, IfcValveType_STOPCOCK, IfcValveType_USERDEFINED, IfcValveType_NOTDEFINED} IfcValveTypeEnum;
IFC_PARSE_API const char* ToString(IfcValveTypeEnum v);
IFC_PARSE_API IfcValveTypeEnum FromString(const std::string& s);
}
namespace IfcVibrationIsolatorTypeEnum {
/// Enumeration defining the typical types of vibration isolators. 
///   The IfcVibrationIsolatorTypeEnum contains the following:
/// 
/// COMPRESSION:  Compression type vibration isolator.
///   SPRING:  Spring type vibration isolator.
///   USERDEFINED:  User-defined vibration isolator type.
///   NOTDEFINED:  Undefined vibration isolator type.
/// 
/// HISTORY: New enumeration in IFC 2x2.
typedef enum {IfcVibrationIsolatorType_COMPRESSION, IfcVibrationIsolatorType_SPRING, IfcVibrationIsolatorType_USERDEFINED, IfcVibrationIsolatorType_NOTDEFINED} IfcVibrationIsolatorTypeEnum;
IFC_PARSE_API const char* ToString(IfcVibrationIsolatorTypeEnum v);
IFC_PARSE_API IfcVibrationIsolatorTypeEnum FromString(const std::string& s);
}
namespace IfcVoidingFeatureTypeEnum {
/// Definition from IAI: This enumeration qualifies a voiding feature regarding its shape and configuration relative to the voided element.
/// 
/// HISTORY New type in IFC 2x4.
/// 
/// ENUMERATION
/// 
/// CUTOUT An internal cutout (creating an opening) or external cutout (creating a recess) of arbitrary shape.  The edges between cutting planes may be overcut or undercut, i.e. rounded.
///   NOTCH An external cutout of with a mostly rectangular cutting profile.  The edges between cutting planes may be overcut or undercut, i.e. rounded.
///   HOLE A circular or slotted or threaded hole, typically but not necessarily of smaller dimension than what would be considered a cutout.
///   MITER A skewed plane end cut, removing material across the entire profile of the voided element.
///   CHAMFER A skewed plane end cut, removing material only across a part of the profile of the voided element.
///   EDGE A shape modification along an edge of the element with the edge length as the predominant dimension of the feature, and feature profile dimensions which are typically much smaller than the edge length.  Can for example be a chamfer edge (differentiated from a chamfer by its ratio of dimensions and thus usually manufactured differently), rounded edge (a convex edge feature), or fillet edge (a concave edge feature).
///   USERDEFINED A user-defined type of voiding feature.
///   NOTDEFINED An undefined type of voiding feature.
typedef enum {IfcVoidingFeatureType_CUTOUT, IfcVoidingFeatureType_NOTCH, IfcVoidingFeatureType_HOLE, IfcVoidingFeatureType_MITER, IfcVoidingFeatureType_CHAMFER, IfcVoidingFeatureType_EDGE, IfcVoidingFeatureType_USERDEFINED, IfcVoidingFeatureType_NOTDEFINED} IfcVoidingFeatureTypeEnum;
IFC_PARSE_API const char* ToString(IfcVoidingFeatureTypeEnum v);
IFC_PARSE_API IfcVoidingFeatureTypeEnum FromString(const std::string& s);
}
namespace IfcWallTypeEnum {
/// Definition from IAI: This enumeration defines the
/// different types of walls an IfcWallType object can
/// fulfill:
/// 
/// STANDARD: A standard wall, extruded vertically with a
/// constant thickness along the wall path.
/// POLYGONAL: A polygonal wall, extruded vertically,
/// where the wall thickness varies along the wall path.
/// SHEAR: A wall having a non-rectangular cross section
/// along the wall path.
/// 
/// NOTE The potentially misleading term shall not impose
/// a particular resistance against shear forces, but a particular
/// shape.
/// 
/// ELEMENTEDWALL: A stud wall framed with studs and faced
/// with sheatings, sidings, wallboard, or plasterwork.
/// PLUMBINGWALL: A pier, or enclosure, or encasement,
/// normally used to enclose plumbing in sanitary rooms.
/// MOVABLE: A movable wall that is either movable, e.g. a
/// folding wall, or a sliding wall, or can be easily removed as a
/// removable partitioning or mounting wall. Movable walls do
/// normally not define space boundaries and often belong to the
/// furnishing system.
/// USERDEFINED: User-defined wall element.
/// NOTDEFINED: Undefined wall element
/// 
/// HISTORY  New
/// Enumeration in Release IFC2x Edition 2.
/// IFC2x2 ADDENDUM CHANGE 
/// The enumerator POLYGON has been changed to
/// POLYGONAL.
/// IFC2x3 CHANGE  The enumerators
/// ELEMENTEDWALL and PLUMBINGWALL have been
/// added.
/// IFC2x4 CHANGE  New enumerator
/// MOVABLE has been added.
typedef enum {IfcWallType_MOVABLE, IfcWallType_PARAPET, IfcWallType_PARTITIONING, IfcWallType_PLUMBINGWALL, IfcWallType_SHEAR, IfcWallType_SOLIDWALL, IfcWallType_STANDARD, IfcWallType_POLYGONAL, IfcWallType_ELEMENTEDWALL, IfcWallType_USERDEFINED, IfcWallType_NOTDEFINED} IfcWallTypeEnum;
IFC_PARSE_API const char* ToString(IfcWallTypeEnum v);
IFC_PARSE_API IfcWallTypeEnum FromString(const std::string& s);
}
namespace IfcWasteTerminalTypeEnum {
/// The IfcWasteTerminalTypeEnum defines the range of different types of waste terminal that can be specified. 
///   HISTORY: New type in IFC 2x2.  GREASEINTERCEPTOR, OILINTERCEPTOR, PETROLINTERCEPTOR moved to IfcInterceptorTypeEnum in IFC2x4.
/// 
/// Enumeration 	 
/// 
/// FLOORTRAP: Pipe fitting, set into the floor, that retains liquid to prevent the passage of foul air 
/// FLOOORWASTE: Pipe fitting, set into the floor, that collects waste water and discharges it to a separate trap. 
/// GULLYSUMP: Pipe fitting or assembly of fittings to receive surface water or waste water, fitted with a grating or sealed cover. 
/// GULLYTRAP: Pipe fitting or assembly of fittings to receive surface water or waste water, fitted with a grating or sealed cover and discharging through a trap (BS6100 330 3504 modified). 
/// ROOFDRAIN: Pipe fitting, set into the roof, that collects rainwater for discharge into the rainwater system.  
/// WASTEDISPOSALUNIT: Electrically operated device that reduces kitchen or other waste into fragments small enough to be flushed into a drainage system. 
/// WASTETRAP: Pipe fitting, set adjacent to a sanitary terminal, that retains liquid to prevent the passage of foul air. 
/// USERDEFINED: User-defined type. 
/// NOTDEFINED: Undefined type.
typedef enum {IfcWasteTerminalType_FLOORTRAP, IfcWasteTerminalType_FLOORWASTE, IfcWasteTerminalType_GULLYSUMP, IfcWasteTerminalType_GULLYTRAP, IfcWasteTerminalType_ROOFDRAIN, IfcWasteTerminalType_WASTEDISPOSALUNIT, IfcWasteTerminalType_WASTETRAP, IfcWasteTerminalType_USERDEFINED, IfcWasteTerminalType_NOTDEFINED} IfcWasteTerminalTypeEnum;
IFC_PARSE_API const char* ToString(IfcWasteTerminalTypeEnum v);
IFC_PARSE_API IfcWasteTerminalTypeEnum FromString(const std::string& s);
}
namespace IfcWindowPanelOperationEnum {
/// This enumeration defines the basic ways to describe how window panels operate, as shown in Figure 168. 
/// 
/// HISTORY New Enumeration in IFC Release 2.0
/// 
/// Enumerator 
///   Description 
///   Figure 
/// 
/// SideHungRightHand 
///   panel that opens to the right
///   when viewed from the outside 
///     
/// 
/// SideHungLeftHand 
///   panel that opens to the left
///   when viewed from the outside 
///     
/// 
/// TiltAndTurnRightHand 
///   panel that opens to the right
///   and is bottom hung 
///     
/// 
/// TiltAndTurnLeftHand 
///   panel that opens to the left
///   and is bottom hung 
///     
/// 
/// TopHung 
///   panel is top hung 
///     
/// 
/// BottomHung 
///   panel is bottom hung 
///     
/// 
/// PivotHorizontal 
///   panel is swinging
///   horizontally (hinges are in the middle) 
///     
/// 
/// PivotVertical 
///   panel is swinging vertically
///   (hinges are in the middle) 
///     
/// 
/// SlidingHorizontal 
///   panel is sliding horizontally
/// 
///   
/// 
/// SlidingVertical 
///   panel is sliding
///   vertically 
///     
/// 
/// RemovableCasement 
///   panel is removable 
///     
/// 
/// FixedCasement 
///   panel is fixed 
///     
/// 
/// OtherOperation 
///   user defined operation type 
///     
/// 
/// NotDefined 
///     
///     
/// 
/// Figure 168 — Window panel operations
/// 
/// The opening direction of the window panels is given by the local placement of the IfcWindow. The positive y-axis determines the direction as shown in Figure 169.
///   NOTE 
/// 
/// Figures are shown as viewed from the outside (in direction of the
///   positive y-axis). 
///   Figures (symbolic representation) depend on the national building
///   code 
///   These figures are only shown as illustrations 
/// 
/// Figure 169 — Window panel directions
typedef enum {IfcWindowPanelOperation_SIDEHUNGRIGHTHAND, IfcWindowPanelOperation_SIDEHUNGLEFTHAND, IfcWindowPanelOperation_TILTANDTURNRIGHTHAND, IfcWindowPanelOperation_TILTANDTURNLEFTHAND, IfcWindowPanelOperation_TOPHUNG, IfcWindowPanelOperation_BOTTOMHUNG, IfcWindowPanelOperation_PIVOTHORIZONTAL, IfcWindowPanelOperation_PIVOTVERTICAL, IfcWindowPanelOperation_SLIDINGHORIZONTAL, IfcWindowPanelOperation_SLIDINGVERTICAL, IfcWindowPanelOperation_REMOVABLECASEMENT, IfcWindowPanelOperation_FIXEDCASEMENT, IfcWindowPanelOperation_OTHEROPERATION, IfcWindowPanelOperation_NOTDEFINED} IfcWindowPanelOperationEnum;
IFC_PARSE_API const char* ToString(IfcWindowPanelOperationEnum v);
IFC_PARSE_API IfcWindowPanelOperationEnum FromString(const std::string& s);
}
namespace IfcWindowPanelPositionEnum {
/// This enumeration defines the basic configuration of the window type in terms of the location of window panels. The window configurations are given for windows with one, two or three panels (including fixed panels) as shown in Figure 170. It corresponds to the OperationType of the IfcWindowStyle definition, which references the IfcWindowPanelProperties. 
/// 
/// Windows which are subdivided into more than three panels have to be defined by the geometry only. The type of such windows is given by an IfcWindowStyle.OperationType = USERDEFINED or NOTDEFINED (see IfcWindowStyleOperationEnum for details). 
/// 
/// HISTORY New Enumeration in IFC Release 2.0.
/// 
/// Enumerator from IfcWindowStyleOperationEnum 
///   Use of enumerators from IfcWindowPanelPositionEnum 
///   Figure 
/// 
/// DoublePanelVertical 
///   first
///   IfcWindowPanelProperties with PanelPosition = LEFTsecond
///   IfcWindowPanelProperties with PanelPosition = RIGHT 
/// 
/// DoublePanelHorizontal 
///   first
///   IfcWindowPanelProperties with PanelPosition = TOPsecond
///   IfcWindowPanelProperties with PanelPosition = BOTTOM 
/// 
/// TriplePanelVertical 
///   first
///   IfcWindowPanelProperties with PanelPosition = LEFTsecond
///   IfcWindowPanelProperties with PanelPosition = MIDDLEthird
///   IfcWindowPanelProperties with PanelPosition = RIGHT 
/// 
/// TriplePanelHorizontal  
///   first
///   IfcWindowPanelProperties with PanelPosition = TOPsecond
///   IfcWindowPanelProperties with PanelPosition = MIDDLEthird
///   IfcWindowPanelProperties with PanelPosition = BOTTOM 
/// 
/// TriplePanelBottom 
///   first
///   IfcWindowPanelProperties with PanelPosition = LEFTsecond
///   IfcWindowPanelProperties with PanelPosition = RIGHTthird
///   IfcWindowPanelProperties with PanelPosition = BOTTOM 
/// 
/// TriplePanelTop 
///   first
///   IfcWindowPanelProperties with PanelPosition = TOPsecond
///   IfcWindowPanelProperties with PanelPosition = LEFTthird
///   IfcWindowPanelProperties with PanelPosition = RIGHT 
/// 
/// TriplePanelLeft 
///   first
///   IfcWindowPanelProperties with PanelPosition = LEFTsecond
///   IfcWindowPanelProperties with PanelPosition = TOPthird
///   IfcWindowPanelProperties with PanelPosition = BOTTOM 
/// 
/// TriplePanelRight 
///   first
///   IfcWindowPanelProperties with PanelPosition = TOPsecond
///   IfcWindowPanelProperties with PanelPosition = BOTTOMthird
///   IfcWindowPanelProperties with PanelPosition = RIGHT 
/// 
/// Figure 170 — Window panel positions
/// 
/// NOTE 
/// 
/// The figures are shown as elevations in the XZ plane of the local
///   placement of the window, looking into the direction of the positive Y
///   axis. 
///   These figures are only shown as illustrations.
typedef enum {IfcWindowPanelPosition_LEFT, IfcWindowPanelPosition_MIDDLE, IfcWindowPanelPosition_RIGHT, IfcWindowPanelPosition_BOTTOM, IfcWindowPanelPosition_TOP, IfcWindowPanelPosition_NOTDEFINED} IfcWindowPanelPositionEnum;
IFC_PARSE_API const char* ToString(IfcWindowPanelPositionEnum v);
IFC_PARSE_API IfcWindowPanelPositionEnum FromString(const std::string& s);
}
namespace IfcWindowStyleConstructionEnum {
/// Definition from IAI: This enumeration defines the
///   basic types of construction of windows. The construction
///   type relates to the main material (or material combination)
///   used for making the window.
/// 
/// HISTORY New Enumeration in
///   IFC Release 2x .
typedef enum {IfcWindowStyleConstruction_ALUMINIUM, IfcWindowStyleConstruction_HIGH_GRADE_STEEL, IfcWindowStyleConstruction_STEEL, IfcWindowStyleConstruction_WOOD, IfcWindowStyleConstruction_ALUMINIUM_WOOD, IfcWindowStyleConstruction_PLASTIC, IfcWindowStyleConstruction_OTHER_CONSTRUCTION, IfcWindowStyleConstruction_NOTDEFINED} IfcWindowStyleConstructionEnum;
IFC_PARSE_API const char* ToString(IfcWindowStyleConstructionEnum v);
IFC_PARSE_API IfcWindowStyleConstructionEnum FromString(const std::string& s);
}
namespace IfcWindowStyleOperationEnum {
/// This enumeration defines the basic
///   configuration of the window type in terms of the number of window panels and
///   the subdivision of the total window. The window configurations are given for
///   windows with one, two or three panels (including fixed panels) as shown in Figure 171. 
///   Windows which are subdivided into more than three panels have to be
///   defined by the geometry only. The type of such windows is USERDEFINED. 
///   HISTORY New Enumeration in IFC Release 2.0. 
/// 
/// Enumerator 
///   Description 
///   Figure 
/// 
/// SinglePanel 
///   Window with one
///   panel. 
/// 
/// DoublePanelVertical 
///   Window with two panels. The
///   configuration of the panels is vertically. 
/// 
/// DoublePanelHorizontal 
///   Window with two panels. The
///   configuration of the panels is horizontally. 
/// 
/// TriplePanelVertical 
///   Window with three panels. The
///   configuration of the panels is vertically. 
/// 
/// TriplePanelHorizontal  
///   Window with three panels. The
///   configuration of the panels is horizontally. 
/// 
/// TriplePanelBottom 
///   Window with three panels. The
///   configuration of two panels is vertically and the third one is horizontally at
///   the bottom. 
/// 
/// TriplePanelTop 
///   Window with three panels. The
///   configuration of two panels is vertically and the third one is horizontally at
///   the top. 
/// 
/// TriplePanelLeft 
///   Window with three panels. The
///   configuration of two panels is horizontally and the third one is vertically at
///   the left hand side. 
/// 
/// TriplePanelRight 
///   Window with three panels. The
///   configuration of two panels is horizontally and the third one is vertically at
///   the right hand side. 
/// 
/// UserDefined 
///   user defined operation
///   type 
///     
/// 
/// NotDefined 
///     
///     
/// 
/// Figure 171 — Window style operations
/// 
/// NOTE 
/// 
/// The way how each panel operates is defined at the
///   IfcWindowPanelProperties.OperationType. 
///   The reference from the window panel to the location of that panel in
///   the window style configuration is handled by the
///   IfcWindowPanelProperties.PanelPosition. 
///   The figures are shown as elevations in the XZ plane of the local
///   placement of the window, looking into the direction of the positive Y
///   axis. 
///   These figures are only shown as illustrations
typedef enum {IfcWindowStyleOperation_SINGLE_PANEL, IfcWindowStyleOperation_DOUBLE_PANEL_VERTICAL, IfcWindowStyleOperation_DOUBLE_PANEL_HORIZONTAL, IfcWindowStyleOperation_TRIPLE_PANEL_VERTICAL, IfcWindowStyleOperation_TRIPLE_PANEL_BOTTOM, IfcWindowStyleOperation_TRIPLE_PANEL_TOP, IfcWindowStyleOperation_TRIPLE_PANEL_LEFT, IfcWindowStyleOperation_TRIPLE_PANEL_RIGHT, IfcWindowStyleOperation_TRIPLE_PANEL_HORIZONTAL, IfcWindowStyleOperation_USERDEFINED, IfcWindowStyleOperation_NOTDEFINED} IfcWindowStyleOperationEnum;
IFC_PARSE_API const char* ToString(IfcWindowStyleOperationEnum v);
IFC_PARSE_API IfcWindowStyleOperationEnum FromString(const std::string& s);
}
namespace IfcWindowTypeEnum {
/// Definition from IAI: This enumeration defines the
/// different predefined types of an IfcWindowType object can
/// fulfill:
/// 
/// WINDOW: A standard window usually within a wall
/// opening, as a window panel in a curtain wall, or as a "free
/// standing" window.
/// SKYLIGHT: A window within a sloped building element,
/// usually a roof slab.
/// LIGHTDOME: A special window that lies horizonally in a
/// roof slab opening.
/// USERDEFINED: User-defined window element.
/// NOTDEFINED: Undefined window element
/// 
/// HISTORY  New Enumeration
/// in IFC2x4.
typedef enum {IfcWindowType_WINDOW, IfcWindowType_SKYLIGHT, IfcWindowType_LIGHTDOME, IfcWindowType_USERDEFINED, IfcWindowType_NOTDEFINED} IfcWindowTypeEnum;
IFC_PARSE_API const char* ToString(IfcWindowTypeEnum v);
IFC_PARSE_API IfcWindowTypeEnum FromString(const std::string& s);
}
namespace IfcWindowTypePartitioningEnum {
/// This enumeration defines the basic configuration of the window type in terms of the number of window panels and the subdivision of the total window as shown in Figure 70. The window configurations are given for windows with one, two or three panels (including fixed panels).
/// 
/// Windows which are subdivided into more than three panels have to be defined by the geometry only. The type of such windows is USERDEFINED.
/// 
/// HISTORY  New Enumeration in IFC2x4.
/// NOTE The new IfcWindowTypePartitioningEnum replaces the use of
/// IfcWindowStyleOperationEnum that is deprecated from IFC2x4 onwards.
/// 
/// Enumerator
/// Description
/// Figure
/// 
/// SinglePanel
/// Window with one
/// panel.
/// 
/// DoublePanelVertical
/// Window with two panels.
/// The configuration of the panels is vertically.
/// 
/// DoublePanelHorizontal
/// Window with two panels.
/// The configuration of the panels is horizontally.
/// 
/// TriplePanelVertical
/// Window with three
/// panels. The configuration of the panels is vertically.
/// 
/// TriplePanelHorizontal
/// Window with three
/// panels. The configuration of the panels is horizontally.
/// 
/// TriplePanelBottom
/// Window with three
/// panels. The configuration of two panels is vertically and the
/// third one is horizontally at the bottom.
/// 
/// TriplePanelTop
/// Window with three
/// panels. The configuration of two panels is vertically and the
/// third one is horizontally at the top.
/// 
/// TriplePanelLeft
/// Window with three
/// panels. The configuration of two panels is horizontally and the
/// third one is vertically at the left hand side.
/// 
/// TriplePanelRight
/// Window with three
/// panels. The configuration of two panels is horizontally and the
/// third one is vertically at the right hand side.
/// 
/// UserDefined
/// user defined operation
/// type
///  
/// 
/// NotDefined
///  
///  
/// 
/// Figure 70 — Window partitioning
/// 
/// NOTE
/// 
/// The way how each panel operates is defined at the
/// IfcWindowPanelProperties.OperationType.
/// The reference from the window panel to the location of that
/// panel in the window style configuration is handled by the
/// IfcWindowPanelProperties.PanelPosition.
/// The figures are shown as elevations in the XZ plane of the
/// local placement of the window, looking into the direction of the
/// positive Y axis.
/// These figures are only shown as illustrations
typedef enum {IfcWindowTypePartitioning_SINGLE_PANEL, IfcWindowTypePartitioning_DOUBLE_PANEL_VERTICAL, IfcWindowTypePartitioning_DOUBLE_PANEL_HORIZONTAL, IfcWindowTypePartitioning_TRIPLE_PANEL_VERTICAL, IfcWindowTypePartitioning_TRIPLE_PANEL_BOTTOM, IfcWindowTypePartitioning_TRIPLE_PANEL_TOP, IfcWindowTypePartitioning_TRIPLE_PANEL_LEFT, IfcWindowTypePartitioning_TRIPLE_PANEL_RIGHT, IfcWindowTypePartitioning_TRIPLE_PANEL_HORIZONTAL, IfcWindowTypePartitioning_USERDEFINED, IfcWindowTypePartitioning_NOTDEFINED} IfcWindowTypePartitioningEnum;
IFC_PARSE_API const char* ToString(IfcWindowTypePartitioningEnum v);
IFC_PARSE_API IfcWindowTypePartitioningEnum FromString(const std::string& s);
}
namespace IfcWorkCalendarTypeEnum {
/// An IfcWorkCalendarTypeEnum is an enumeration data type that specifies the types of work calendar from which the relevant control can be selected. If given it should help to identify base calendars.
/// 
/// HISTORY: Introduced in IFC2x4.
/// 
/// Enumeration:
/// 
/// FIRSTSHIFT: Belongs to the first shift
/// SECONDSHIFT: Belongs to the second shift
/// THIRDSHIFT: Belongs to the third shift
/// USERDEFINED
/// NOTDEFINED
typedef enum {IfcWorkCalendarType_FIRSTSHIFT, IfcWorkCalendarType_SECONDSHIFT, IfcWorkCalendarType_THIRDSHIFT, IfcWorkCalendarType_USERDEFINED, IfcWorkCalendarType_NOTDEFINED} IfcWorkCalendarTypeEnum;
IFC_PARSE_API const char* ToString(IfcWorkCalendarTypeEnum v);
IFC_PARSE_API IfcWorkCalendarTypeEnum FromString(const std::string& s);
}
namespace IfcWorkPlanTypeEnum {
/// An IfcWorkPlanTypeEnum is an enumeration data type that specifies the types of work plan from which the relevant control can be selected.
/// 
/// HISTORY  Introduced in IFC2x4. Derived from IfcWorkControlTypeEnum that was introduced in IFC Release 2.0.
/// 
/// Enumeration:
/// 
/// ACTUAL: A control in which actual items undertaken are indicated.
/// BASELINE: A control that is a baseline from which changes that are made later can be recognized.
/// PLANNED: A control showing planned items.
/// USERDEFINED
/// NOTDEFINED
typedef enum {IfcWorkPlanType_ACTUAL, IfcWorkPlanType_BASELINE, IfcWorkPlanType_PLANNED, IfcWorkPlanType_USERDEFINED, IfcWorkPlanType_NOTDEFINED} IfcWorkPlanTypeEnum;
IFC_PARSE_API const char* ToString(IfcWorkPlanTypeEnum v);
IFC_PARSE_API IfcWorkPlanTypeEnum FromString(const std::string& s);
}
namespace IfcWorkScheduleTypeEnum {
/// An IfcWorkScheduleTypeEnum is an enumeration data type that specifies the types of work schedule from which the relevant control can be selected.
/// 
/// HISTORY  Introduced in IFC2x4. Derived from IfcWorkControlTypeEnum that was introduced in IFC Release 2.0.
/// 
/// Enumeration:
/// 
/// ACTUAL: A control in which actual items undertaken are indicated
/// BASELINE: A control that is a baseline from which changes that are made later can be recognized
/// PLANNED: A control showing planned items
/// USERDEFINED
/// NOTDEFINED
typedef enum {IfcWorkScheduleType_ACTUAL, IfcWorkScheduleType_BASELINE, IfcWorkScheduleType_PLANNED, IfcWorkScheduleType_USERDEFINED, IfcWorkScheduleType_NOTDEFINED} IfcWorkScheduleTypeEnum;
IFC_PARSE_API const char* ToString(IfcWorkScheduleTypeEnum v);
IFC_PARSE_API IfcWorkScheduleTypeEnum FromString(const std::string& s);
}
/// IfcAbsorbedDoseMeasure is a measure of the absorbed radioactivity dose.
/// Usually measured in Gray (Gy, J/kg).
/// Type: REAL
/// 
/// HISTORY New type in IFC Release 2x.
class IFC_PARSE_API IfcAbsorbedDoseMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcAbsorbedDoseMeasure (IfcEntityInstanceData* e);
    IfcAbsorbedDoseMeasure (double v);
    operator double() const;
};
/// IfcAccelerationMeasure is a measure of acceleration.
/// Usually measured in m/s2.
/// Type: REAL
/// 
/// HISTORY New type in IFC Release 2x.
class IFC_PARSE_API IfcAccelerationMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcAccelerationMeasure (IfcEntityInstanceData* e);
    IfcAccelerationMeasure (double v);
    operator double() const;
};
/// Definition from ISO/CD 10303-41:1992: An amount of substance measure is the value for the quantity  of a substance when compared with the number of atoms in 0.012kilogram of carbon 12.
/// 
/// Usually measure in mole (mol).
/// Type: REAL
/// 
/// NOTE Corresponding ISO 10303 name: amount_of_substance_measure, please refer to ISO/IS 10303-41 for the final definition of the formal standard.
/// 
/// HISTORY New type in IFC Release 1.5.1.
class IFC_PARSE_API IfcAmountOfSubstanceMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcAmountOfSubstanceMeasure (IfcEntityInstanceData* e);
    IfcAmountOfSubstanceMeasure (double v);
    operator double() const;
};
/// IfcAngularVelocityMeasure is a measure of the velocity of a body measured in terms of angle subtended per unit time.
/// Usually measured in radians/s.
/// Type: REAL
/// 
/// HISTORY New type in IFC Release 2.0.
class IFC_PARSE_API IfcAngularVelocityMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcAngularVelocityMeasure (IfcEntityInstanceData* e);
    IfcAngularVelocityMeasure (double v);
    operator double() const;
};

class IFC_PARSE_API IfcArcIndex : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcArcIndex (IfcEntityInstanceData* e);
    IfcArcIndex (std::vector< int > /*[3:3]*/ v);
    operator std::vector< int > /*[3:3]*/() const;
};

class IFC_PARSE_API IfcAreaDensityMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcAreaDensityMeasure (IfcEntityInstanceData* e);
    IfcAreaDensityMeasure (double v);
    operator double() const;
};
/// Definition from ISO/CD 10303-41:1992: An area measure is the value of the extent of a surface.
/// Usually measured in square metre (m2).
/// Type: REAL
/// 
/// NOTE Corresponding ISO 10303 name: area_measure, please refer to ISO/IS 10303-41 for the final definition of the formal standard.
/// 
/// HISTORY New type in IFC Release 1.5.1.
class IFC_PARSE_API IfcAreaMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcAreaMeasure (IfcEntityInstanceData* e);
    IfcAreaMeasure (double v);
    operator double() const;
};

class IFC_PARSE_API IfcBinary : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcBinary (IfcEntityInstanceData* e);
    IfcBinary (boost::dynamic_bitset<> v);
    operator boost::dynamic_bitset<>() const;
};
/// IfcBoolean is a defined data type of simple data type Boolean. It is required since a select type (IfcSimpleValue) cannot directly include simple types in its select list.  A boolean type can have value TRUE or FALSE.
/// 
/// Type: BOOLEAN
/// 
/// HISTORY New type in IFC Release 1.5.1.
class IFC_PARSE_API IfcBoolean : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcBoolean (IfcEntityInstanceData* e);
    IfcBoolean (bool v);
    operator bool() const;
};
/// An IfcCardinalPointReference is an index reference to
/// significant points of a section profile. This index is used to
/// describe the spatial relationship between the section of a member
/// and a reference axis of the same member.
/// 
/// HISTORY  New Type in IFC2x4.
/// 
/// Indexes 1...9 refer to points at the bounding box of a
/// profile. Indexes 10...19 refer to points defined by geometric
/// centroid (usually centre of gravity) and shear centre, and their
/// combinations with bounding box coordinates. In particular, the
/// following index values are specified in this IFC Release:
/// 
/// bottom left
/// bottom centre
/// bottom right
/// mid-depth left
/// mid-depth centre
/// mid-depth right
/// top left
/// top centre
/// top right
/// geometric centroid
/// bottom in line with the geometric centroid
/// left in line with the geometric centroid
/// right in line with the geometric centroid
/// top in line with the geometric centroid
/// shear centre
/// bottom in line with the shear centre
/// left in line with the shear centre
/// right in line with the shear centre
/// top in line with the shear centre
/// 
/// Other index values are possible but outside the scope of this
/// specification.
/// 
/// Figure 283 illustrates cardinal point values.
/// 
/// Figure 283 — Cardinal point values
/// 
/// Figure 284 illustrates an example extrusion shape with arbitrary profile (IfcArbitraryClosedProfileDef), aligned "mid-depth right" on the member axis. The line of sight follows the extrusion direction Z which points into the drawing plane of above illustration. Hence, "left" is in the positive X direction of the IfcProfileDef. "Top" is in the positive Y direction of the IfcProfileDef.
/// 
/// Figure 284 — Cardinal point extrusion
class IFC_PARSE_API IfcCardinalPointReference : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcCardinalPointReference (IfcEntityInstanceData* e);
    IfcCardinalPointReference (int v);
    operator int() const;
};
/// IfcComplexNumber is a representation of a complex number expressed as an array with two elements.
///   The first element (index 1) denotes the real component which is the numerical
///   component of a complex number whose square roots can be calculated explicitly.
///   The second element (index 2) denotes the imaginary component which is the numerical
///   component of a complex number whose square roots cannot be determined other
///   than through the provision of the square of the imaginary number j where j^2 = -1.
///   Note that the imaginary component may be referred to as i in certain references.
/// 
/// Type: ARRAY [1:2] OF REAL
/// 
/// HISTORY New type in IFC Release 2x2.
class IFC_PARSE_API IfcComplexNumber : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcComplexNumber (IfcEntityInstanceData* e);
    IfcComplexNumber (std::vector< double > /*[1:2]*/ v);
    operator std::vector< double > /*[1:2]*/() const;
};
/// IfcCompoundPlaneAngleMeasure is a compound measure of plane angle in degrees, minutes, seconds, and optionally millionth-seconds of arc.
/// 
/// NOTE: IfcCompoundPlaneAngleMeasure is used where angles need to be described to an accuracy as fine as one millionth of a degree and expressed as parts of an arc. It may be used for angular measurement by surveyors or for other angular measurements where precision is required. Another usage is exact or approximate global positioning against a geographic coordinate systems using longitude and latitude.
/// 
/// NOTE: While the unit of measurement of the type IfcPlaneAngleMeasure depends on unit assignment (radian or degree or other derived units; globally at the IfcPoject or locally at an IfcMeasureWithUnit), the units of IfcCompoundPlaneAngleMeasure are always degrees, minutes, seconds, and millionth-seconds irrespective of unit assignments.
/// 
/// HISTORY New type in IFC Release 1.5.1.
/// 
/// Type: LIST [3:4] OF INTEGER
/// 
/// Value restrictions
/// 
/// The first integer measure is the number of degrees and is generally not range-restricted.  However, when IfcCompoundPlaneAngleMeasure is used to express geographic coordinates, only latitudes of [-90, 90] and longitudes of [-180, 180] are used in practice.
/// The second integer measure is the number of minutes and shall be in the range (-60, 60).
/// The third integer measure is the number of seconds and shall be in the range (-60, 60).
/// The optional fourth integer measure is the number of millionth-seconds and shall be in the range (-1 000 000, 1 000 000).
/// 
/// Signedness
/// 
/// All measure components have the same sign (positive or negative).  It is therefore trivial to convert between floating point representation (decimal degrees) and compound representation regardless whether the angle is greater or smaller than zero.  Example:
/// 
/// LOCAL
///   a : IfcPlaneAngleMeasure := -50.975864;  (* decimal degrees, -50° 58' 33" 110400 *)
///   b : IfcPlaneAngleMeasure;
///   c : IfcCompoundPlaneAngleMeasure;
///   s : IfcText;
/// END_LOCAL;
/// 
/// (* convert from float to compound *)
///   c[1] :=    a;                                           -- -50
///   c[2] :=   (a - c[1]) * 60;                              -- -58
///   c[3] :=  ((a - c[1]) * 60 - c[2]) * 60;                 -- -33
///   c[4] := (((a - c[1]) * 60 - c[2]) * 60 - c[3]) * 1.e6;  -- -110400
/// 
/// (* convert from compound to float *)
///   b := c[1] + c[2]/60. + c[3]/3600. + c[4]/3600.e6;       -- -50.975864
/// 
/// Use in string representations
/// 
/// When a compound plane angle measure is formatted for display or printout, the signs of the fractional components will usually be discarded because, to a human reader, the sign of the first component alone already indicates the sense of the angle:
/// 
/// (* convert from compound to human-readable string *)
///   s := FORMAT(c[1], '+##')     + "000000B0"
///      + FORMAT(ABS(c[2]), '##') + ''''
///      + FORMAT(ABS(c[3]), '##') + '"'
///      + FORMAT(ABS(c[4]), '##');  -- -50° 58' 33" 110400
/// 
/// Another often encountered display format of latitudes and longitudes is to omit the signs and print N, S, E, W indicators instead, for example, 50°58'33"S.  When stored as IfcCompoundPlaneAngleMeasure however, a compound plane angle measure is always signed, with same sign of all components.
class IFC_PARSE_API IfcCompoundPlaneAngleMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcCompoundPlaneAngleMeasure (IfcEntityInstanceData* e);
    IfcCompoundPlaneAngleMeasure (std::vector< int > /*[3:4]*/ v);
    operator std::vector< int > /*[3:4]*/() const;
};
/// Definition from ISO/CD 10303-41:1992: Is the value of a physical quantity as defined by an application context.
/// Type: REAL
/// 
/// NOTE Corresponding ISO 10303 name: context_dependent_measure, please refer to ISO/IS 10303-41 for the final definition of the formal standard.
/// 
/// HISTORY New type in IFC Release 1.5.1.
class IFC_PARSE_API IfcContextDependentMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcContextDependentMeasure (IfcEntityInstanceData* e);
    IfcContextDependentMeasure (double v);
    operator double() const;
};
/// Definition from ISO/CD 10303-41:1992: A count measure is the value of a count.
/// Type: NUMBER
/// 
/// NOTE Corresponding ISO 10303 name: count_measure, please refer to ISO/IS 10303-41 for the final definition of the formal standard.
/// 
/// HISTORY New type in IFC Release 1.5.1.
class IFC_PARSE_API IfcCountMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcCountMeasure (IfcEntityInstanceData* e);
    IfcCountMeasure (double v);
    operator double() const;
};
/// IfcCurvatureMeasure is a measure for curvature, which is defined as the change of slope per length.
///   This is typically a computed value in structural analysis.
///   It is usually measured in rad/m.
/// 
/// Type: REAL
/// 
/// HISTORY New type in IFC2x2.
class IFC_PARSE_API IfcCurvatureMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcCurvatureMeasure (IfcEntityInstanceData* e);
    IfcCurvatureMeasure (double v);
    operator double() const;
};
/// The lexical representation for date is the reduced (right truncated) lexical representation for dateTime: CCYY-MM-DD. No left truncation is allowed. An optional following time zone qualifier is allowed as for dateTime. To accommodate year values outside the range from 0001 to 9999, additional digits can be added to the left of this representation and a preceding "-" sign is allowed.
/// 
/// HISTORY: New type in IFC2x4
/// 
/// Use definitions
/// All given values should be provided in context and converted into a Gregorian date context and be shall be processable by a receiving application.
class IFC_PARSE_API IfcDate : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcDate (IfcEntityInstanceData* e);
    IfcDate (std::string v);
    operator std::string() const;
};
/// This lexical representation is the [ISO 8601] extended
///   format CCYY-MM-DDThh:mm:ss where "CC" represents the
///   century, "YY" the year, "MM" the month and "DD" the day,
///   preceded by an optional leading "-" sign to indicate a
///   negative number. If the sign is omitted, "+" is assumed.
///   The letter "T" is the date/time separator and "hh", "mm",
///   "ss" represent hour, minute and second respectively.
///   Additional digits can be used to increase the precision of
///   fractional seconds if desired i.e the format ss.ss... with
///   any number of digits after the decimal point is supported.
///   The fractional seconds part is optional; other parts of the
///   lexical form are not optional. To accommodate year values
///   greater than 9999 additional digits can be added to the
///   left of this representation. Leading zeros are required if
///   the year value would otherwise have fewer than four digits;
///   otherwise they are forbidden. The year 0000 is prohibited.
/// 
/// HISTORY: New type in IFC2x4
class IFC_PARSE_API IfcDateTime : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcDateTime (IfcEntityInstanceData* e);
    IfcDateTime (std::string v);
    operator std::string() const;
};
/// Definition from IAI: The IfcDayInMonthNumber is
/// an integer that defines the position of the specified day in a
/// month.
/// Type: INTEGER
/// NOTE Corresponding STEP
/// name: day_in_month_number, please refer to ISO/IS 10303-41:1994
/// for the final definition of the formal
/// standard.
/// HISTORY New type in IFC
/// Release 1.5.1.
/// IFC2x4 CHANGE Where rule
/// ValidRange added.
class IFC_PARSE_API IfcDayInMonthNumber : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcDayInMonthNumber (IfcEntityInstanceData* e);
    IfcDayInMonthNumber (int v);
    operator int() const;
};
/// Definition from IAI: The IfcDayInWeekNumber is
/// an integer that defines the position of the specified day in a
/// week. The positions have the following meaning (according to
/// ISO8601 "the calendar week") that assigns the ordinal day number
/// in the week to the Calender day name.
/// 
/// Ordinal day number
/// Calendar day
/// name
/// 
/// 01
/// Monday
/// 
/// 02
/// Tuesday
/// 
/// 03
/// Wednesday
/// 
/// 04
/// Thursday
/// 
/// 05
/// Friday
/// 
/// 06
/// Saturday
/// 
/// 07
/// Sunday
/// 
/// Type: INTEGER
/// HISTORY New type in
/// IFC2x4.
class IFC_PARSE_API IfcDayInWeekNumber : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcDayInWeekNumber (IfcEntityInstanceData* e);
    IfcDayInWeekNumber (int v);
    operator int() const;
};
/// Definition from ISO/CD 10303-41:1992: A descriptive measure is a human interpretable definition of a quantifiable value.
/// Type: STRING
/// 
/// NOTE Corresponding ISO 10303 name:descriptive_measure, please refer to ISO/IS 10303-41 for the final definition of the formal standard.
/// 
/// HISTORY New type in IFC Release 1.5.1.
class IFC_PARSE_API IfcDescriptiveMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcDescriptiveMeasure (IfcEntityInstanceData* e);
    IfcDescriptiveMeasure (std::string v);
    operator std::string() const;
};
/// Definition from ISO/CD 10303-42:1992: A dimension count is a positive integer used to define the coordinate space dimensionality.  
/// 
/// The IfcDimensionCount is restricted to have the dimensionality of either 1, 2, or 3 - the WR1 had been added as an addition to the ISO 10303:42 entity dimension_count. In contrary to the ISO 10303:42 constraint, that all geometric representation items within a geometric representation context are forced to have the same dimension count, the IFC geometry allows mixed dimensions, particularly when defining the boundary of planar surfaces.  
/// 
/// NOTE Corresponding ISO 10303 type: dimension_count, please refer to ISO/IS 10303-42:1994, p. 14 for the final definition of the formal standard.
/// 
/// HISTORY New Type in IFC Release 1.5
class IFC_PARSE_API IfcDimensionCount : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcDimensionCount (IfcEntityInstanceData* e);
    IfcDimensionCount (int v);
    operator int() const;
};
/// IfcDoseEquivalentMeasure is a measure of the radioactive dose equivalent.
/// Usually measured in Sievert (Sv, J/kg).
/// Type: REAL
/// 
/// HISTORY New type in IFC Release 2x.
class IFC_PARSE_API IfcDoseEquivalentMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcDoseEquivalentMeasure (IfcEntityInstanceData* e);
    IfcDoseEquivalentMeasure (double v);
    operator double() const;
};
/// String representation of a time duration according to ISO8601:2000 "Data elements and interchange formats - Information interchange - Representation of dates and times" as defined in section 5.5.3 "Representation of duration".
/// It is recommended to use the alternative format (section 5.5.4.2.2) in its extended version: PYYYY-MM-DDThh:mm:ss.
/// EXAMPLE: P0002-10-15T10:30:20 (duration of two years, 10 months, 15 days, 10 hours, 30 minutes and 20 seconds).
/// 
/// HISTORY: New type in IFC2x4
class IFC_PARSE_API IfcDuration : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcDuration (IfcEntityInstanceData* e);
    IfcDuration (std::string v);
    operator std::string() const;
};
/// IfcDynamicViscosityMeasure is a measure of the viscous resistance of a medium.
/// 
/// Usually measured in Pascal second (Pa s).
/// Type: REAL 
/// 
/// HISTORY New type in IFC Release 2.0.
class IFC_PARSE_API IfcDynamicViscosityMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcDynamicViscosityMeasure (IfcEntityInstanceData* e);
    IfcDynamicViscosityMeasure (double v);
    operator double() const;
};
/// IfcElectricCapacitanceMeasure is a measure of the electric capacitance.
/// Usually measured in Farad (F, C/V = A s/V).
/// Type: REAL
/// 
/// HISTORY New type in IFC Release 2x.
class IFC_PARSE_API IfcElectricCapacitanceMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcElectricCapacitanceMeasure (IfcEntityInstanceData* e);
    IfcElectricCapacitanceMeasure (double v);
    operator double() const;
};
/// IfcElectricChargeMeasure is a measure of the electric charge.
/// Usually measured in Coulomb (C, A s).
/// Type: REAL
/// 
/// HISTORY New type in IFC Release 2x.
class IFC_PARSE_API IfcElectricChargeMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcElectricChargeMeasure (IfcEntityInstanceData* e);
    IfcElectricChargeMeasure (double v);
    operator double() const;
};
/// IfcElectricConductanceMeasure is a measure of the electric conductance.
/// Usually measured in Siemens (S, 1/Ohm = A/V).
/// Type: REAL
/// 
/// HISTORY New type in IFC Release 2x.
class IFC_PARSE_API IfcElectricConductanceMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcElectricConductanceMeasure (IfcEntityInstanceData* e);
    IfcElectricConductanceMeasure (double v);
    operator double() const;
};
/// Definition from ISO/CD 10303-41:1992: The value for the movement of electrically charged particles.
/// Usually measured in Ampere (A).
/// Type: REAL
/// 
/// NOTE Corresponding ISO 10303 name: electric_current_measure, please refer to ISO/IS 10303-41 for the final definition of the formal standard.
/// 
/// HISTORY New type in IFC Release 1.5.1.
class IFC_PARSE_API IfcElectricCurrentMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcElectricCurrentMeasure (IfcEntityInstanceData* e);
    IfcElectricCurrentMeasure (double v);
    operator double() const;
};
/// IfcElectricResistanceMeasure is a measure of the electric resistance.
/// Usually measured in Ohm (V/A).
/// Type: REAL
/// 
/// HISTORY New type in IFC Release 2x.
class IFC_PARSE_API IfcElectricResistanceMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcElectricResistanceMeasure (IfcEntityInstanceData* e);
    IfcElectricResistanceMeasure (double v);
    operator double() const;
};
/// IfcElectricVoltageMeasure is a measure of electromotive force.
/// Usually measured in Volts (V, W/A).
/// Type: REAL
/// 
/// HISTORY New type in IFC Release 2.0.
class IFC_PARSE_API IfcElectricVoltageMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcElectricVoltageMeasure (IfcEntityInstanceData* e);
    IfcElectricVoltageMeasure (double v);
    operator double() const;
};
/// IfcEnergyMeasure is a measure of energy required or used.
/// Usually measured in Joules, (J, Nm).
/// Type: REAL
/// 
/// HISTORY New type in IFC Release 2.0.
class IFC_PARSE_API IfcEnergyMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcEnergyMeasure (IfcEntityInstanceData* e);
    IfcEnergyMeasure (double v);
    operator double() const;
};
/// Definition from CSS1 (W3C Recommendation): The font-style property selects between normal (sometimes
/// referred to as "roman" or "upright"), italic and oblique faces within a font family. Values are:
/// 
/// normal 
///   italic 
///   oblique
/// 
/// A value of 'normal' selects a font that is classified as 'normal' in the user agents font database, while 'oblique' selects a font that is labeled 'oblique'. A value of 'italic' selects a font that is labeled 'italic', or, if that is not available, one labeled 'oblique'. The font that is labeled 'oblique' in the user agents font database may actually have been generated by electronically slanting a normal font.
/// 
/// Fonts with Oblique, Slanted or Incline in their names will typically be labeled 'oblique' in the user agents font database. Fonts with Italic, Cursive or Kursiv in their names will typically be labeled 'italic'.
/// 
/// NOTE  Corresponding CSS1 definitions is font-style.
/// 
/// HISTORY  New type in IFC2x3.
class IFC_PARSE_API IfcFontStyle : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcFontStyle (IfcEntityInstanceData* e);
    IfcFontStyle (std::string v);
    operator std::string() const;
};
/// Definition from CSS1 (W3C Recommendation): The font-style property selects between normal and small-caps within a font family. Values are:
/// 
/// normal 
///   small-caps 
/// 
/// Another type of variation within a font family is the small-caps. In a small-caps font the lower case letters look similar to the uppercase ones, but in a smaller size and with slightly different proportions. The 'font-variant' property selects that font.
/// 
/// A value of 'normal' selects a font that is not a small-caps font, 'small-caps' selects a small-caps font. It is acceptable (but not required) in CSS1 if the small-caps font is a created by taking a normal font and replacing the lower case letters by scaled uppercase characters. As a last resort, uppercase letters will be used as replacement for a small-caps font.
/// 
/// NOTE  Corresponding CSS1 definitions is font-variant.
/// 
/// HISTORY  New type in IFC2x3.
class IFC_PARSE_API IfcFontVariant : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcFontVariant (IfcEntityInstanceData* e);
    IfcFontVariant (std::string v);
    operator std::string() const;
};
/// Definition from CSS1 (W3C Recommendation): The 'font-weight' property selects the weight of the font. The values '100' to '900' form an ordered sequence, where each number indicates a weight that is at least as dark as its predecessor. The keyword 'normal' is synonymous with '400', and 'bold' is synonymous with '700'. Keywords other than 'normal' and 'bold' have been shown to be often confused with font names and a numerical scale was therefore chosen for the 9-value list. Values are:
/// 
/// normal 
///   bold 
///   100 | 200 | 300 | 400 | 500 | 600 | 700 | 800 | 900
/// 
/// Fonts (the font data) typically have one or more properties whose values are names that are descriptive of the "weight" of a font. There is no accepted, universal meaning to these weight names. Their primary role is to distinguish faces of differing darkness within a single font family. Usage across font families is quite variant; for example a font that you might think of as being bold might be described as being Regular, Roman, Book, Medium, Semi- or DemiBold, Bold, or Black, depending on how black the "normal" face of the font is within the design. Because there is no standard usage of names, the weight property values in CSS1 are given on a numerical scale in which the value '400' (or 'normal') corresponds to the "normal" text face for that family. The weight name associated with that face will typically be Book, Regular, Roman, Normal or sometimes Medium.
/// 
/// The association of other weights within a family to the numerical weight values is intended only to preserve the ordering of darkness within that family. However, the following heuristics tell how the assignment is done in typical cases:
/// 
/// If the font family already uses a numerical scale with nine values (such as with OpenType), the font weights should be mapped directly. 
///   If there is both a face labeled Medium and one labeled Book, Regular, Roman or Normal, then the Medium is normally assigned to the '500'. 
///   The font labeled "Bold" will often correspond to the weight value '700'. 
///   If there are fewer then 9 weights in the family, the default algorithm for filling the "holes" is as follows. If '500' is unassigned, it will be assigned the same font as '400'. If any of the values '600', '700', '800' or '900' remains unassigned, they are assigned to the same face as the next darker assigned keyword, if any, or the next lighter one otherwise. If any of '300', '200' or '100' remains unassigned, it is assigned to the next lighter assigned keyword, if any, or the next darker otherwise. 
/// 
/// The following two examples illustrate the process. Assume four weights in the "Example1" family, from lightest to darkest: Regular, Medium, Bold, Heavy. And assume six weights in the "Example2" family: Book, Medium, Bold, Heavy, Black, ExtraBlack. Note how in the second example it has been decided not to assign "Example2 ExtraBlack" to anything.
/// 
/// Available faces       | Assignments   | Filling the holes----------------------+---------------+-------------------"Example1 Regular"    | 400           | 100, 200, 300"Example1 Medium"     | 500           |"Example1 Bold"       | 700           | 600"Example1 Heavy"      | 800           | 900
/// Available faces       | Assignments   | Filling the holes----------------------+---------------+-------------------"Example2 Book"       | 400           | 100, 200, 300"Example2 Medium"     | 500           |"Example2 Bold"       | 700           | 600 "Example2 Heavy"      | 800           |"Example2 Black"      | 900           |"Example2 ExtraBlack" | (none)        |
/// 
/// NOTE  Corresponding CSS1 definitions is font-weight.
/// 
/// HISTORY  New type in IFC2x2 Addendum 2.
class IFC_PARSE_API IfcFontWeight : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcFontWeight (IfcEntityInstanceData* e);
    IfcFontWeight (std::string v);
    operator std::string() const;
};
/// IfcForceMeasure is a measure of the force.
/// Usually measured in Newton (N, kg m/s2).
/// Type: REAL
/// 
/// HISTORY New type in IFC Release 2x.
class IFC_PARSE_API IfcForceMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcForceMeasure (IfcEntityInstanceData* e);
    IfcForceMeasure (double v);
    operator double() const;
};
/// IfcFrequencyMeasure is a measure of the number of times that an item vibrates in unit time.
/// Usually measured in cycles/s or Herz (Hz).
/// Type: REAL
/// 
/// HISTORY New type in IFC Release 2.0.
class IFC_PARSE_API IfcFrequencyMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcFrequencyMeasure (IfcEntityInstanceData* e);
    IfcFrequencyMeasure (double v);
    operator double() const;
};
/// An IfcGloballyUniqueId holds an encoded string identifier that is used to uniquely identify an IFC object. An IfcGloballyUniqueId is a Globally
///   Unique Identifier (GUID) which is an auto-generated 128-bit number. Since this identifier is
///   required for all IFC object instances, it is desirable to compress it to reduce overhead. The encoding of the base 64 character set is shown below:
/// 
///            1         2         3         4         5         6
/// 
///  0123456789012345678901234567890123456789012345678901234567890123
/// 
/// "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_$";
/// 
/// The resulting string is a fixed 22 character length string to be exchanged within the IFC exchange file structure.
/// 
/// Refer to the BuildingSMART website (www.buildingsmart-tech.org) for more information and sample encoding algorithms.
/// 
/// HISTORY  New type in IFC R1.5.1.
class IFC_PARSE_API IfcGloballyUniqueId : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcGloballyUniqueId (IfcEntityInstanceData* e);
    IfcGloballyUniqueId (std::string v);
    operator std::string() const;
};
/// IfcHeatFluxDensityMeasure is a measure of the density of heat flux within a body.
/// Usually measured in W/m2 (J/s m2).
/// Type: REAL
/// 
/// HISTORY New type in IFC Release 2.0.
class IFC_PARSE_API IfcHeatFluxDensityMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcHeatFluxDensityMeasure (IfcEntityInstanceData* e);
    IfcHeatFluxDensityMeasure (double v);
    operator double() const;
};
/// IfcHeatingValueMeasure defines the amount of energy released (usually in MJ/kg) when a fuel is burned.
/// 
/// HISTORY: This is new type in IFC2x2.
class IFC_PARSE_API IfcHeatingValueMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcHeatingValueMeasure (IfcEntityInstanceData* e);
    IfcHeatingValueMeasure (double v);
    operator double() const;
};
/// Definition from ISO/CD 10303-41:1992: An identifier is an alphanumeric string which allows an individual thing to be identified. It may not provide natural-language meaning.
/// 
/// Type: STRING of up to 255 characters
/// 
/// NOTE Corresponding STEP name: identifier, please refer to ISO/IS 10303-41 for the final definition of the formal standard.
/// 
/// HISTORY New type in IFC Release 2x.
/// IFC 2x4 CHANGE: Previously recommended size restriction of 255 characters is now mandatory.
/// 
/// As a merely machine-readable string for identification purposes, an identifier is usually machine-generated and locale-independent (in contrast to human-readable labels, IfcLabel).
/// 
/// Per ISO 10303-11, the set of characters that may appear in STRINGs is defined in ISO 10646.  The encoding of characters in case of file-based exchange is defined in ISO 10303-21 (STEP physical files) and ISO 10303-28 (XML files).  Among else, these specifications define the encoding of 8-bit characters from ISO 8859-1...-16 and of 2-byte Unicode characters.
/// 
/// Note that while IfcIdentifier is restricted to 255 characters, the size in exchange files after encoding may be considerably larger than 255 octets, depending on the particular encoding and on the contents of the identifier.
class IFC_PARSE_API IfcIdentifier : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcIdentifier (IfcEntityInstanceData* e);
    IfcIdentifier (std::string v);
    operator std::string() const;
};
/// IfcIlluminanceMeasure is a measure of the illuminance.
/// Usually measured in Lux (lx, Lumen/m2 = Candela Steradian/m2).
/// Type: REAL
/// 
/// HISTORY New type in IFC Release 2x.
class IFC_PARSE_API IfcIlluminanceMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcIlluminanceMeasure (IfcEntityInstanceData* e);
    IfcIlluminanceMeasure (double v);
    operator double() const;
};
/// IfcInductanceMeasure is a measure of the inductance.
/// Usually measure in Henry (H, Weber/A = V s/A).
/// Type: REAL
/// 
/// HISTORY New type in IFC Release 2x.
class IFC_PARSE_API IfcInductanceMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcInductanceMeasure (IfcEntityInstanceData* e);
    IfcInductanceMeasure (double v);
    operator double() const;
};
/// IfcInteger is a defined type of simple data type Integer. It is required since a select type (IfcSimpleValue) cannot include directly simple types in its select list.
/// 
/// In principle, the domain of IfcInteger (being an Integer) is all integer numbers. Here the number of bits used for the IfcInteger representation is unconstrained, but in practice it is implementation specific.
/// 
/// Type: INTEGER
/// 
/// HISTORY New type in IFC Release 1.5.1.
class IFC_PARSE_API IfcInteger : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcInteger (IfcEntityInstanceData* e);
    IfcInteger (int v);
    operator int() const;
};
/// IfcIntegerCountRateMeasure is a measure of the integer number of units flowing per unit time.
/// 
/// EXAMPLE: This measure may be used for measuring integer units per second or per hour. For example, it may be used to measure the number of books per hour passing along a part of a mechanical book handling system, the number of people per hour travelling along a moving walkway or the number of vehicles per hour travelling along a section of road.
/// 
/// Type: INTEGER
/// 
/// HISTORY New type in IFC Release 2.0.
class IFC_PARSE_API IfcIntegerCountRateMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcIntegerCountRateMeasure (IfcEntityInstanceData* e);
    IfcIntegerCountRateMeasure (int v);
    operator int() const;
};
/// IfcIonConcentrationMeasure is a measure of particular ion concentration in a liquid, given in mg/L.
/// 
/// HISTORY: New type in IFC2x2.
class IFC_PARSE_API IfcIonConcentrationMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcIonConcentrationMeasure (IfcEntityInstanceData* e);
    IfcIonConcentrationMeasure (double v);
    operator double() const;
};
/// IfcIsothermalMoistureCapacityMeasure is a measure of isothermal moisture capacity.
/// Usually measured in m3/kg.
/// Type: REAL
/// 
/// HISTORY New type in IFC Release 2x.
class IFC_PARSE_API IfcIsothermalMoistureCapacityMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcIsothermalMoistureCapacityMeasure (IfcEntityInstanceData* e);
    IfcIsothermalMoistureCapacityMeasure (double v);
    operator double() const;
};
/// IfcKinematicViscosityMeasure is a measure of the viscous resistance of a medium to a moving body.
/// Usually measured in m2/s.
/// Type: REAL
/// 
/// HISTORY New type in IFC Release 2.0.
class IFC_PARSE_API IfcKinematicViscosityMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcKinematicViscosityMeasure (IfcEntityInstanceData* e);
    IfcKinematicViscosityMeasure (double v);
    operator double() const;
};
/// Definition from ISO/CD 10303-41:1992: A label is the term by which something may be referred to.  It is a string which represents the human-interpretable name of something and shall have a natural-language meaning.
/// 
/// Type: STRING of up to 255 characters
/// 
/// NOTE Corresponding STEP name: label, please refer to ISO/IS 10303-41 for the final definition of the formal standard.
/// 
/// HISTORY New type in IFC Release 2x.
/// IFC 2x4 CHANGE: Previously recommended size restriction of 255 characters is now mandatory.
/// 
/// As a human-readable string for naming purposes, a label is usually human-specified and locale-dependent (in contrast to purely machine-readable identifiers, IfcIdentifier).
/// 
/// Per ISO 10303-11, the set of characters that may appear in STRINGs is defined in ISO 10646.  The encoding of characters in case of file-based exchange is defined in ISO 10303-21 (STEP physical files) and ISO 10303-28 (XML files).  Among else, these specifications define the encoding of 8-bit characters from ISO 8859-1...-16 and of 2-byte Unicode characters.
/// 
/// Note that while IfcLabel is restricted to 255 characters, the size in exchange files after encoding may be considerably larger than 255 octets, depending on the particular encoding and on the contents of the label.
class IFC_PARSE_API IfcLabel : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcLabel (IfcEntityInstanceData* e);
    IfcLabel (std::string v);
    operator std::string() const;
};
/// IfcLanguageId identifies the language in which a natural language text is expressed. It uses a language tag to identify the language.
/// The tag shall comply to the Internet Engineering Task Force (IETF) language tag as expressed in RFC 5646. A conforming program shall support the "simple language" subtag and the "language-region" tag format.
/// 
/// EXAMPLE  for simple language tags en (English), de (German), fr (France), or ja (Japanese), and for language-region tags en-US (English as used in United States), de-CH (German as used in German speaking part of Switzerland).
/// 
/// Type: IfcIdentifier
/// 
/// NOTE  The use of IfcLanguageId should conform to the use of language tags in HTML and XML as published by the W3C consortium.
/// 
/// HISTORY  New defined datatype in IFC2x4.
class IFC_PARSE_API IfcLanguageId : public IfcIdentifier {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcLanguageId (IfcEntityInstanceData* e);
    IfcLanguageId (std::string v);
    operator std::string() const;
};
/// Definition from ISO/CD 10303-41:1992: A length measure is the value of a distance.
/// Usually measured in millimeters (mm).
/// Type: REAL
/// 
/// NOTE Corresponding ISO 10303 name: length_measure, please refer to ISO/IS 10303-41 for the final definition of the formal standard.
/// 
/// HISTORY New type in IFC Release 1.5.1.
class IFC_PARSE_API IfcLengthMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcLengthMeasure (IfcEntityInstanceData* e);
    IfcLengthMeasure (double v);
    operator double() const;
};

class IFC_PARSE_API IfcLineIndex : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcLineIndex (IfcEntityInstanceData* e);
    IfcLineIndex (std::vector< int > /*[2:?]*/ v);
    operator std::vector< int > /*[2:?]*/() const;
};
/// IfcLinearForceMeasure is a measure of linear force.
/// Usually measured in N/m.
/// Type: REAL
/// 
/// HISTORY New type in IFC Release 2x.
class IFC_PARSE_API IfcLinearForceMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcLinearForceMeasure (IfcEntityInstanceData* e);
    IfcLinearForceMeasure (double v);
    operator double() const;
};
/// IfcLinearMomentMeasure is a measure of linear moment.
/// Usually measured in Nm/m.
/// Type: REAL
/// 
/// HISTORY New type in IFC Release 2x.
class IFC_PARSE_API IfcLinearMomentMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcLinearMomentMeasure (IfcEntityInstanceData* e);
    IfcLinearMomentMeasure (double v);
    operator double() const;
};
/// IfcLinearStiffnessMeasureA measure of linear stiffness.
/// Usually measured in N/m.
/// Type: REAL
/// 
/// HISTORY New type in IFC Release 2x.
class IFC_PARSE_API IfcLinearStiffnessMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcLinearStiffnessMeasure (IfcEntityInstanceData* e);
    IfcLinearStiffnessMeasure (double v);
    operator double() const;
};
/// IfcLinearVelocityMeasure is a measure of the velocity of a body measured in terms of distance moved per unit time.
/// Usually measured in m/s.
/// Type: REAL
/// 
/// HISTORY New type in IFC Release 2.0.
class IFC_PARSE_API IfcLinearVelocityMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcLinearVelocityMeasure (IfcEntityInstanceData* e);
    IfcLinearVelocityMeasure (double v);
    operator double() const;
};
/// IfcLogical</iL is a defined type of simple type Logical. It is required since a select type (IfcSimpleValue) cannot directly include simple types in its select list). Logical datatype can have values TRUE, FALSE or UNKNOWN.
/// 
/// Type: LOGICAL
/// 
/// HISTORY New type in IFC Release 2x.
class IFC_PARSE_API IfcLogical : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcLogical (IfcEntityInstanceData* e);
    IfcLogical (bool v);
    operator bool() const;
};
/// IfcLuminousFluxMeasure is a measure of the luminous flux.
/// Usually measured in Lumen (lm, Candela Steradian).
/// Type: REAL
/// 
/// HISTORY New type in IFC Release 2x.
class IFC_PARSE_API IfcLuminousFluxMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcLuminousFluxMeasure (IfcEntityInstanceData* e);
    IfcLuminousFluxMeasure (double v);
    operator double() const;
};
/// IfcLuminousIntensityDistributionMeasure is a measure of the luminous intensity of a light source that changes according to the direction of the ray. It is normally based on some standardized distribution light distribution curves. 
/// 
/// Usually measured in Candela/Lumen (cd/lm) or (cd/klm).  
/// 
/// Type: REAL  
/// 
/// HISTORY New type in IFC2x2.
class IFC_PARSE_API IfcLuminousIntensityDistributionMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcLuminousIntensityDistributionMeasure (IfcEntityInstanceData* e);
    IfcLuminousIntensityDistributionMeasure (double v);
    operator double() const;
};
/// Definition from ISO/CD 10303-41:1992: A luminous intensity measure is the value for the brightness of a body.
/// Usually measured in candela (cd).
/// Type: REAL
/// 
/// NOTE Corresponding ISO 10303 name: luminous_intensity_measure, please refer to ISO/IS 10303-41 for the final definition of the formal standard.
/// 
/// HISTORY New type in IFC Release 1.5.1.
class IFC_PARSE_API IfcLuminousIntensityMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcLuminousIntensityMeasure (IfcEntityInstanceData* e);
    IfcLuminousIntensityMeasure (double v);
    operator double() const;
};
/// IfcMagneticFluxDensityMeasure is a measure of the magnetic flux density.
/// Usually measured in Tesla (T, Weber/m2 = V s/m2).
/// Type: REAL
/// 
/// HISTORY New type in IFC Release 2x.
class IFC_PARSE_API IfcMagneticFluxDensityMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcMagneticFluxDensityMeasure (IfcEntityInstanceData* e);
    IfcMagneticFluxDensityMeasure (double v);
    operator double() const;
};
/// IfcMagneticFluxMeasure is a measure of the magnetic flux.
/// Usually measured in Weber (Wb, V s).
/// Type: REAL
/// 
/// HISTORY New type in IFC Release 2x.
class IFC_PARSE_API IfcMagneticFluxMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcMagneticFluxMeasure (IfcEntityInstanceData* e);
    IfcMagneticFluxMeasure (double v);
    operator double() const;
};
/// IfcMassDensityMeasure is a measure of the density of a medium.
/// Usually measured in kg/m3.
/// Type: REAL
/// 
/// HISTORY New type in IFC Release 2.0.
class IFC_PARSE_API IfcMassDensityMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcMassDensityMeasure (IfcEntityInstanceData* e);
    IfcMassDensityMeasure (double v);
    operator double() const;
};
/// IfcMassFlowRateMeasure is a measure of the mass of a medium flowing per unit time.
/// Usually measured in kg/s.
/// Type: REAL
/// 
/// HISTORY New type in IFC Release 2.0.
class IFC_PARSE_API IfcMassFlowRateMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcMassFlowRateMeasure (IfcEntityInstanceData* e);
    IfcMassFlowRateMeasure (double v);
    operator double() const;
};
/// Definition from ISO/CD 10303-41:1992: A mass measure is the value of the amount of matter that a body contains.
/// Usually measured in kilograms (kg) or grams (g).
/// Type: REAL
/// 
/// NOTE Corresponding ISO 10303 name: mass_measure, please refer to ISO/IS 10303-41 for the final definition of the formal standard.
/// 
/// HISTORY New type in IFC Release 1.5.1.
class IFC_PARSE_API IfcMassMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcMassMeasure (IfcEntityInstanceData* e);
    IfcMassMeasure (double v);
    operator double() const;
};
/// IfcMassPerLengthMeasure is a measure for mass per length. For example for rolled steel profiles the weight of
///   an imaginary beam is usually expressed by kg/m length for cost calculation and
///   structural analysis purposes.
/// 
/// Type: REAL
/// 
/// HISTORY New type in IFC2x2.
class IFC_PARSE_API IfcMassPerLengthMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcMassPerLengthMeasure (IfcEntityInstanceData* e);
    IfcMassPerLengthMeasure (double v);
    operator double() const;
};
/// IfcModulusOfElasticityMeasure is a measure of modulus of elasticity.
/// Usually measured in N/m2.
/// Type: REAL
/// 
/// HISTORY New type in IFC Release 2x.
class IFC_PARSE_API IfcModulusOfElasticityMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcModulusOfElasticityMeasure (IfcEntityInstanceData* e);
    IfcModulusOfElasticityMeasure (double v);
    operator double() const;
};
/// IfcModulusOfLinearSubgradeReactionMeasure is a measure for modulus of linear subgrade reaction, which expresses the elastic bedding of a linear structural element per length, such as for a beam. It is typically measured in N/m^2.
/// 
/// Type: REAL  
/// 
/// HISTORY New type in IFC Release 2x2.
class IFC_PARSE_API IfcModulusOfLinearSubgradeReactionMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcModulusOfLinearSubgradeReactionMeasure (IfcEntityInstanceData* e);
    IfcModulusOfLinearSubgradeReactionMeasure (double v);
    operator double() const;
};
/// IfcModulusOfRotationalSubgradeReactionMeasure is a measure for modulus of rotational subgrade reaction, which expresses the rotational elastic bedding of a linear structural element per length, such as for a beam. It is typically measured in Nm/(m*rad). 
/// 
/// Type: REAL  
/// 
/// HISTORY New type in IFC2x2.
class IFC_PARSE_API IfcModulusOfRotationalSubgradeReactionMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcModulusOfRotationalSubgradeReactionMeasure (IfcEntityInstanceData* e);
    IfcModulusOfRotationalSubgradeReactionMeasure (double v);
    operator double() const;
};
/// IfcModulusOfSubgradeReactionMeasure is a geotechnical measure describing interaction between foundation structures and the soil. May also be known as bedding measure. 
///   Usually measured in N/m3.  
///   Type: REAL  
/// 
/// HISTORY New type in IFC Release 2x.
/// 
/// Figure 290 illustrates elastic support of a planar member.
/// 
/// Figure 290 — Modulus of subgrade reaction measure
class IFC_PARSE_API IfcModulusOfSubgradeReactionMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcModulusOfSubgradeReactionMeasure (IfcEntityInstanceData* e);
    IfcModulusOfSubgradeReactionMeasure (double v);
    operator double() const;
};
/// IfcMoistureDiffusivityMeasure is a measure of moisture diffusivity.
/// Usually measured in m3/s.
/// Type: REAL
/// 
/// HISTORY New type in IFC Release 2x.
class IFC_PARSE_API IfcMoistureDiffusivityMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcMoistureDiffusivityMeasure (IfcEntityInstanceData* e);
    IfcMoistureDiffusivityMeasure (double v);
    operator double() const;
};
/// IfcMolecularWeightMeasure is a measure of molecular weight of material (typically gas).
/// Usually measured in g/mole.
/// Type: REAL
/// 
/// HISTORY New type in IFC Release 2x.
class IFC_PARSE_API IfcMolecularWeightMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcMolecularWeightMeasure (IfcEntityInstanceData* e);
    IfcMolecularWeightMeasure (double v);
    operator double() const;
};
/// IfcMomentOfInertiaMeasure is a measure of moment of inertia.
/// Usually measured in m4.
/// Type: REAL
/// 
/// HISTORY New type in IFC Release 2x.
class IFC_PARSE_API IfcMomentOfInertiaMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcMomentOfInertiaMeasure (IfcEntityInstanceData* e);
    IfcMomentOfInertiaMeasure (double v);
    operator double() const;
};
/// A monetary measure is the value of an amount of money without regard to its currency.
/// Type: REAL
/// 
/// HISTORY New type in IFC Release 2.0.
class IFC_PARSE_API IfcMonetaryMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcMonetaryMeasure (IfcEntityInstanceData* e);
    IfcMonetaryMeasure (double v);
    operator double() const;
};
/// Definition from IAI: The IfcDayInMonthNumber is
/// an integer that defines the position of the specified month in a
/// year. The positions have the following meaning (according to
/// ISO8601 "calendar month") that assigns the Calendar month number
/// to the Calender month name.
/// NOTE Refer to ISO 8601 for the definitions for
/// using the Gregorian calendar as the standard for the
/// identification of calendar days.
/// 
/// Calendar month number
/// Calendar month
/// name
/// 
/// 01
/// January
/// 
/// 02
/// February
/// 
/// 03
/// March
/// 
/// 04
/// April
/// 
/// 05
/// May
/// 
/// 06
/// June
/// 
/// 07
/// July
/// 
/// 08
/// August
/// 
/// 09
/// September
/// 
/// 10
/// October
/// 
/// 11
/// November
/// 
/// 12
/// December
/// 
/// Type: INTEGER
/// NOTE Corresponding STEP
/// name: month_in_year_number, please refer to ISO/IS 10303-41:1994
/// for the final definition of the formal
/// standard.
/// HISTORY New type in IFC
/// Release 1.5.1.
class IFC_PARSE_API IfcMonthInYearNumber : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcMonthInYearNumber (IfcEntityInstanceData* e);
    IfcMonthInYearNumber (int v);
    operator int() const;
};
/// A non-negative length measure is a length measure that is greater than or equal to zero.
/// 
/// Type: IfcLengthMeasure
/// 
/// HISTORY New type in IFC Release 2x4.
class IFC_PARSE_API IfcNonNegativeLengthMeasure : public IfcLengthMeasure {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcNonNegativeLengthMeasure (IfcEntityInstanceData* e);
    IfcNonNegativeLengthMeasure (double v);
    operator double() const;
};
/// Definition from ISO/CD 10303-41:1992: A numeric measure is the numeric value of a physical quantity.
/// Type: NUMBER
/// 
/// NOTE Corresponding ISO 10303 name: numeric_measure, please refer to ISO/IS 10303-41 for the final definition of the formal standard.
/// 
/// HISTORY New type in IFC Release 1.5.1.
class IFC_PARSE_API IfcNumericMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcNumericMeasure (IfcEntityInstanceData* e);
    IfcNumericMeasure (double v);
    operator double() const;
};
/// IfcPHMeasure is a measure of the molar hydrogen ion concentration in a liquid (usually defined as the measure of acidity) in a range from 0 to 14.
/// 
/// HISTORY: New type in IFC 2x2.
class IFC_PARSE_API IfcPHMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcPHMeasure (IfcEntityInstanceData* e);
    IfcPHMeasure (double v);
    operator double() const;
};
/// Definition from ISO/CD 10303-41:1992: A parameter value is the value which specifies the amount of a 
/// parameter in some parameter space.
/// Type: REAL
/// 
/// NOTE Corresponding STEP name: parameter_value, please refer to ISO/IS 10303-41 for the final definition of the formal standard.
/// 
/// HISTORY New type in IFC Release 1.5.1.
class IFC_PARSE_API IfcParameterValue : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcParameterValue (IfcEntityInstanceData* e);
    IfcParameterValue (double v);
    operator double() const;
};
/// IfcPlanarForceMeasure is a measure of force on an area.
/// Usually measured in N/m2.
/// Type: REAL
/// 
/// HISTORY New type in IFC Release 2x.
class IFC_PARSE_API IfcPlanarForceMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcPlanarForceMeasure (IfcEntityInstanceData* e);
    IfcPlanarForceMeasure (double v);
    operator double() const;
};
/// Definition from ISO/CD 10303-41:1992: A plane angle measure is the value of an angle in a plane.
/// 
/// Usually measured in radian (rad, m/m = 1), but also grads may be used. The grad unit may be declared as a conversion based unit based on radian unit.
/// 
/// NOTE IfcPlaneAngleMeasure is used where angles need to be described to an accuracy of less than one degree and expressed as decimal parts of an angle. It is widely used for angular measurement except for situations where accuracy needs to be defined using arc measurement; for which purpose the IfcCompoundPlaneAngleMeasure is provided.
/// 
/// Type: REAL
/// 
/// NOTE Corresponding ISO 10303 name: plane_angle_measure, please refer to ISO/IS 10303-41 for the final definition of the formal standard.
/// 
/// HISTORY New type in IFC Release 1.5.1.
class IFC_PARSE_API IfcPlaneAngleMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcPlaneAngleMeasure (IfcEntityInstanceData* e);
    IfcPlaneAngleMeasure (double v);
    operator double() const;
};

class IFC_PARSE_API IfcPositiveInteger : public IfcInteger {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcPositiveInteger (IfcEntityInstanceData* e);
    IfcPositiveInteger (int v);
    operator int() const;
};
/// Definition from ISO/CD 10303-41:1992: A positive length measure is a length measure that is greater than zero.
/// Type: IfcLengthMeasure
/// 
/// NOTE Corresponding ISO 10303 name: positive_length_measure, please refer to ISO/IS 10303-41 for the final definition of the formal standard.
/// 
/// HISTORY New type in IFC Release 1.5.1.
class IFC_PARSE_API IfcPositiveLengthMeasure : public IfcLengthMeasure {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcPositiveLengthMeasure (IfcEntityInstanceData* e);
    IfcPositiveLengthMeasure (double v);
    operator double() const;
};
/// Definition from ISO/CD 10303-41:1992: Positive plane angle measure is a plane angle measure that is greater than zero.
/// Type: IfcPlaneAngleMeasure 
/// 
/// NOTE Corresponding STEP name: positive_plane_angle_measure, please refer to ISO/IS 10303-41 for the final definition of the formal standard.
/// 
/// HISTORY New type in IFC Release 1.5.1.
class IFC_PARSE_API IfcPositivePlaneAngleMeasure : public IfcPlaneAngleMeasure {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcPositivePlaneAngleMeasure (IfcEntityInstanceData* e);
    IfcPositivePlaneAngleMeasure (double v);
    operator double() const;
};
/// IfcPowerMeasure is a measure of power required or used.
/// Usually measured in Watts (W, J/s).
/// Type: REAL
/// 
/// HISTORY New type in IFC Release 2.0.
class IFC_PARSE_API IfcPowerMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcPowerMeasure (IfcEntityInstanceData* e);
    IfcPowerMeasure (double v);
    operator double() const;
};
/// IfcPresentableText is a text string used to capture the content of a text literal for the purpose of presentation. The IfcPresentableText can include multiple lines of text, for which the line feed character LF, 0x0A, should be used to separate lines.
/// 
/// NOTE  The non printable characters are converted within the standard exchange format ISO 10303-21 (STEP physical file format), commonly the \X\09 represents the TAB, and \X\0A the LF character.
/// 
/// NOTE  The IfcPresentableText is an entity that had been adopted from ISO 10303, Industrial automation systems and integration—Product data representation and exchange, Part 46: Integrated generic resources: Visual presentation.
/// 
/// NOTE  Corresponding ISO 10303 name: presentable_text. Please refer to ISO/IS 10303-46:1994, p. 133 for the final definition of the formal standard.
/// 
/// HISTORY  New type in IFC2x2.
class IFC_PARSE_API IfcPresentableText : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcPresentableText (IfcEntityInstanceData* e);
    IfcPresentableText (std::string v);
    operator std::string() const;
};
/// IfcPressureMeasure is a measure of the quantity of a medium acting on a unit area.
/// Usually measured in Pascals (Pa, N/m2).
/// Type: REAL
/// 
/// HISTORY New type in IFC Release 2.0.
class IFC_PARSE_API IfcPressureMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcPressureMeasure (IfcEntityInstanceData* e);
    IfcPressureMeasure (double v);
    operator double() const;
};

class IFC_PARSE_API IfcPropertySetDefinitionSet : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcPropertySetDefinitionSet (IfcEntityInstanceData* e);
    IfcPropertySetDefinitionSet (IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr v);
    operator IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr() const;
};
/// IfcRadioActivityMeasure is a measure of activity of radionuclide.
/// Usually measured in Becquerel (Bq, 1/s).
/// Type: REAL
/// 
/// HISTORY New type in IFC Release 2x.
class IFC_PARSE_API IfcRadioActivityMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcRadioActivityMeasure (IfcEntityInstanceData* e);
    IfcRadioActivityMeasure (double v);
    operator double() const;
};
/// Definition from ISO/CD 10303-41:1992: A ratio measure is the value of the relation between two 
/// physical quantities that are of the same kind.
/// 
/// NOTE: Input given in percent is to be divided by 100% when stored as an IfcRatioMeasure. For example, 25% becomes 0.25.
/// 
/// Type: REAL
/// 
/// NOTE Corresponding STEP name: ratio_measure, please refer to ISO/IS 10303-41 for the final definition of the formal standard.
/// 
/// HISTORY New type in IFC Release 1.5.1.
class IFC_PARSE_API IfcRatioMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcRatioMeasure (IfcEntityInstanceData* e);
    IfcRatioMeasure (double v);
    operator double() const;
};
/// IfcReal is a defined type of simple data type REAL.  It is required since a select type (IfcSimpleValue), cannot directly include simple types in its select list.
/// 
/// In principle, the domain of IfcReal (being a Real) is all rational, irrational and scientific real numbers. Here the precision is unconstrained, but in practice it is implementation specific.
/// 
/// Type: REAL
/// 
/// HISTORY: New type in IFC Release 1.5.1.
class IFC_PARSE_API IfcReal : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcReal (IfcEntityInstanceData* e);
    IfcReal (double v);
    operator double() const;
};
/// IfcRotationalFrequencyMeasure is a measure of the number of cycles that an item revolves in unit time.
/// Usually measured in cycles/s.
/// Type: REAL
/// 
/// HISTORY New type in IFC Release 2x.
class IFC_PARSE_API IfcRotationalFrequencyMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcRotationalFrequencyMeasure (IfcEntityInstanceData* e);
    IfcRotationalFrequencyMeasure (double v);
    operator double() const;
};
/// The rotational mass measure denotes the inertia of a body with respect to angular acceleration.
/// It is usually measured in kg*m^2.
/// 
/// Type: REAL  
/// 
/// HISTORY New type in IFC2x2.
class IFC_PARSE_API IfcRotationalMassMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcRotationalMassMeasure (IfcEntityInstanceData* e);
    IfcRotationalMassMeasure (double v);
    operator double() const;
};
/// IfcRotationalStiffnessMeasure is a measure of rotational stiffness.
/// Usually measured in Nm/rad.
/// Type: REAL
/// 
/// HISTORY New type in IFC Release 2x.
class IFC_PARSE_API IfcRotationalStiffnessMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcRotationalStiffnessMeasure (IfcEntityInstanceData* e);
    IfcRotationalStiffnessMeasure (double v);
    operator double() const;
};
/// IfcSectionModulusMeasure is a measure for the resistance of a cross section against bending or torsional moment.  It is usually measured in m^3.
/// 
/// Type: REAL 
/// 
/// HISTORY New type in IFC Release 2x2.
class IFC_PARSE_API IfcSectionModulusMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcSectionModulusMeasure (IfcEntityInstanceData* e);
    IfcSectionModulusMeasure (double v);
    operator double() const;
};
/// The sectional area integral measure is typically used in torsional analysis. It is usually measured in m^5.
/// 
/// Type: REAL  
/// 
/// HISTORY New type in IFC2x2.
class IFC_PARSE_API IfcSectionalAreaIntegralMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcSectionalAreaIntegralMeasure (IfcEntityInstanceData* e);
    IfcSectionalAreaIntegralMeasure (double v);
    operator double() const;
};
/// IfcShearModulusMeasure is a measure of shear modulus.
/// Usually measured in N/m2.
/// Type: REAL
/// 
/// HISTORY New type in IFC Release 2x.
class IFC_PARSE_API IfcShearModulusMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcShearModulusMeasure (IfcEntityInstanceData* e);
    IfcShearModulusMeasure (double v);
    operator double() const;
};
/// Definition from ISO/CD 10303-41:1992: A solid angle measure is the value of an angle in a solid.
/// Usually measured in Steradians, (sr, m2/m2).
/// Type: REAL
/// 
/// NOTE Corresponding ISO 10303 name: solid_angle_measure, please refer to ISO/IS 10303-41 for the final definition of the formal standard.
/// 
/// HISTORY New type in IFC Release 1.5.1.
class IFC_PARSE_API IfcSolidAngleMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcSolidAngleMeasure (IfcEntityInstanceData* e);
    IfcSolidAngleMeasure (double v);
    operator double() const;
};

class IFC_PARSE_API IfcSoundPowerLevelMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcSoundPowerLevelMeasure (IfcEntityInstanceData* e);
    IfcSoundPowerLevelMeasure (double v);
    operator double() const;
};
/// A sound power measure is a measure of total radiated noise with units of decibels with a reference value of picowatts.
/// 
/// Type: REAL  
/// 
/// HISTORY New type in IFC2x2.
class IFC_PARSE_API IfcSoundPowerMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcSoundPowerMeasure (IfcEntityInstanceData* e);
    IfcSoundPowerMeasure (double v);
    operator double() const;
};

class IFC_PARSE_API IfcSoundPressureLevelMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcSoundPressureLevelMeasure (IfcEntityInstanceData* e);
    IfcSoundPressureLevelMeasure (double v);
    operator double() const;
};
/// A sound pressure measure is a measure of the pressure fluctuations superimposed over the ambient pressure level with units of decibels with a reference value of micropascals. 
/// 
/// Type: REAL  
/// 
/// HISTORY New type in IFC2x2.
class IFC_PARSE_API IfcSoundPressureMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcSoundPressureMeasure (IfcEntityInstanceData* e);
    IfcSoundPressureMeasure (double v);
    operator double() const;
};
/// IfcSpecificHeatCapacityMeasure defines the specific heat of material: The heat energy absorbed per temperature unit.
/// Usually measured in J / kg Kelvin.
/// Type: REAL
/// 
/// HISTORY New type in IFC Release 2x.
class IFC_PARSE_API IfcSpecificHeatCapacityMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcSpecificHeatCapacityMeasure (IfcEntityInstanceData* e);
    IfcSpecificHeatCapacityMeasure (double v);
    operator double() const;
};
/// The IfcSpecularExponent defines the datatype for exponent determining the sharpness of the 'reflection'. reflection is made sharper with large values of the exponent, such as 10.0. Small values, such as 1.0, decrease the specular fall-off. 
/// 
/// IfcSpecularExponent is of type REAL.
/// 
/// NOTE: The datatype relates to the definition of specular_exponent in ISO 10303-46 entity surface_style_reflectance_ambient_diffuse_specular.
/// 
/// HISTORY: New type in IFC2x2.
class IFC_PARSE_API IfcSpecularExponent : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcSpecularExponent (IfcEntityInstanceData* e);
    IfcSpecularExponent (double v);
    operator double() const;
};
/// The IfcSpecularRoughness defines the datatype for the reflection resulting from the roughness of a surface through the height of surface impurities where the specular highlight is made sharper with small values for the roughness, such as 0.1.  
/// 
/// Applies to "glass", "metal", "mirror" and "plastic" reflection models. Larger values, close to 1.0 decrease the specular fall-off. 
/// 
/// IfcSpecularRoughness is of type REAL. It is constraint to values between (and including) 0 and 1.
/// 
/// NOTE: The datatype relates to the definition of "shiness" in VRML97, which is the reciprocate value to the specular roughness.
/// 
/// HISTORY: New type in Release IFC2x2.
class IFC_PARSE_API IfcSpecularRoughness : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcSpecularRoughness (IfcEntityInstanceData* e);
    IfcSpecularRoughness (double v);
    operator double() const;
};
/// The temperature gradient measures the difference of a temperature per lenght, as for instance used in an external wall or its layers.  It is usually measured in K/m.
/// 
/// Type: REAL  
/// 
/// HISTORY New type in IFC2x2.
class IFC_PARSE_API IfcTemperatureGradientMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcTemperatureGradientMeasure (IfcEntityInstanceData* e);
    IfcTemperatureGradientMeasure (double v);
    operator double() const;
};
/// The temperature rate of change measures the difference of a temperature per time (positive: rise, negative: fall), as for instance used with heat sensors. It is for example measured in K/s (Kelvin per second).
/// 
/// Type: REAL 
/// 
/// HISTORY  New type in IFC2x4.
class IFC_PARSE_API IfcTemperatureRateOfChangeMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcTemperatureRateOfChangeMeasure (IfcEntityInstanceData* e);
    IfcTemperatureRateOfChangeMeasure (double v);
    operator double() const;
};
/// Definition from ISO/CD 10303-41:1992: A text is an alphanumeric string of characters which is intended to be read and understood by a human being. It is for information purposes only.
/// 
/// Type: STRING
/// 
/// NOTE Corresponding STEP name: text, please refer to ISO/IS 10303-41 for the final definition of the formal standard.
/// 
/// HISTORY New type in IFC Release 2x.
/// 
/// Per ISO 10303-11, the set of characters that may appear in STRINGs is defined in ISO 10646.  The encoding of characters in case of file-based exchange is defined in ISO 10303-21 (STEP physical files) and ISO 10303-28 (XML files).  Among else, these specifications define the encoding of 8-bit characters from ISO 8859-1...-16 and of 2-byte Unicode characters.
/// 
/// Note that while IfcText is not formally restricted in length, the size of a string in ISO 10303-21:2002 conforming exchange files must not exceed 32767 octets after encoding and escaping.
class IFC_PARSE_API IfcText : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcText (IfcEntityInstanceData* e);
    IfcText (std::string v);
    operator std::string() const;
};
/// Definition from CSS1 (W3C Recommendation): This property describes how text is aligned within the element. The actual justification algorithm used is user agent and human language dependent. If 'justify' is not supported, the user agent will supply a replacement. Typically, this will be 'left' for western languages. Values are:
/// 
/// left
///   right
///   center
///   justify
/// 
/// NOTE  Corresponding CSS1 definition is text-align.
/// 
/// HISTORY  New type in IFC2x3.
class IFC_PARSE_API IfcTextAlignment : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcTextAlignment (IfcEntityInstanceData* e);
    IfcTextAlignment (std::string v);
    operator std::string() const;
};
/// Definition from CSS1 (W3C Recommendation): This property describes decorations that are added to the text of an element. A value of 'blink' causes the text to blink.. Values are:
/// 
/// none
///   underline
///   overline
///   line-through
///   blink
/// 
/// User agents must recognize the keyword 'blink', but are not required to support the blink effect.
/// 
/// NOTE  Corresponding CSS1 definition is text-decoration.
/// 
/// HISTORY  New type in IFC2x3.
class IFC_PARSE_API IfcTextDecoration : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcTextDecoration (IfcEntityInstanceData* e);
    IfcTextDecoration (std::string v);
    operator std::string() const;
};
/// Definition from CSS1 (W3C Recommendation): The value is a font family name and/or generic family name. Values are:
/// 
/// The name of a font family of choice. For example, "gill" and "helvetica" are font families.
/// 
/// In the example above, the last value is a generic family name. The following generic families are defined:
/// 
/// 'serif' (Example: Times)
///   'sans-serif' (Example: Helvetica)
///   'cursive' (Example: Zapf-Chancery)
///   'fantasy' (Example: Western)
///   'monospace' (Example: Courier)
/// 
/// It is encouraged to offer a generic font family as a last alternative.
/// 
/// NOTE  Corresponding CSS1 definitions are font-family.
/// 
/// HISTORY  New type in IFC2x2 Addendum 2.
/// 
/// IFC2x2 Addendum 2 CHANGE: The IfcFontFamily has been added.
class IFC_PARSE_API IfcTextFontName : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcTextFontName (IfcEntityInstanceData* e);
    IfcTextFontName (std::string v);
    operator std::string() const;
};
/// Definition from CSS1 (W3C Recommendation): This property describes how the cases of characters are handled. Values are:
/// 
/// capitalize: uppercases the first character of each word
///   uppercase: uppercases all letters of the element
///   lowercase: lowercases all letters of the element
///   none
/// 
/// NOTE  Corresponding CSS1 definition is text-transform.
/// 
/// HISTORY  New type in IFC2x3.
class IFC_PARSE_API IfcTextTransformation : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcTextTransformation (IfcEntityInstanceData* e);
    IfcTextTransformation (std::string v);
    operator std::string() const;
};
/// IfcThermalAdmittanceMeasure is the measure of the ability of a surface to smooth out temperature variations.
/// Usually measured in Watt / m2 Kelvin.
/// Type: REAL
/// 
/// HISTORY New type in IFC Release 2.0.
class IFC_PARSE_API IfcThermalAdmittanceMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcThermalAdmittanceMeasure (IfcEntityInstanceData* e);
    IfcThermalAdmittanceMeasure (double v);
    operator double() const;
};
/// IfcThermalConductivityMeasure is a measure of thermal conductivity.
/// Usually measured in Watt / m Kelvin.
/// Type: REAL
/// 
/// HISTORY New type in IFC Release 2x.
class IFC_PARSE_API IfcThermalConductivityMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcThermalConductivityMeasure (IfcEntityInstanceData* e);
    IfcThermalConductivityMeasure (double v);
    operator double() const;
};
/// IfcThermalExpansionCoeffientMeasure is a measure of the thermal expansion coefficient of a material, which expresses its elongation (as a ratio) per temperature difference. It is usually measured in 1/K. A positive elongation per (positive) rise of temperature is expressed by a positive value.
/// Type: REAL  
/// 
/// HISTORY New type in IFC2x2.
class IFC_PARSE_API IfcThermalExpansionCoefficientMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcThermalExpansionCoefficientMeasure (IfcEntityInstanceData* e);
    IfcThermalExpansionCoefficientMeasure (double v);
    operator double() const;
};
/// IfcThermalResistanceMeasure is a measure of the resistance offered by a body to the flow of energy.
/// Usually measured in m2 Kelvin/Watt.
/// 
/// HISTORY New type in IFC Release 2.0.
class IFC_PARSE_API IfcThermalResistanceMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcThermalResistanceMeasure (IfcEntityInstanceData* e);
    IfcThermalResistanceMeasure (double v);
    operator double() const;
};
/// IfcThermalTransmittanceMeasure is a measure of the rate at which energy is transmitted through a body.
/// Usually measured in Watts/m2 Kelvin.
/// Type: REAL
/// 
/// HISTORY New type in IFC Release 2.0.
class IFC_PARSE_API IfcThermalTransmittanceMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcThermalTransmittanceMeasure (IfcEntityInstanceData* e);
    IfcThermalTransmittanceMeasure (double v);
    operator double() const;
};
/// Definition from ISO/CD 10303-41:1992: A thermodynamic temperature measure is the value for the degree of heat of a body.
/// Usually measured in degrees Kelvin (K).
/// Type: REAL
/// 
/// NOTE Corresponding ISO 10303 name: thermodynamic_temperature_measure, please refer to ISO/IS 10303-41 for the final definition of the formal standard.
/// 
/// HISTORY New type in IFC Release 1.5.1.
class IFC_PARSE_API IfcThermodynamicTemperatureMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcThermodynamicTemperatureMeasure (IfcEntityInstanceData* e);
    IfcThermodynamicTemperatureMeasure (double v);
    operator double() const;
};
/// The lexical representation for time is the left truncated
///   lexical representation for dateTime: hh:mm:ss.sss with
///   optional following time zone indicator. For example, to
///   indicate 1:20 pm for Eastern Standard Time which is 5 hours
///   behind Coordinated Universal Time (UTC), one would write:
///   13:20:00-05:00.
/// 
/// HISTORY: New type in IFC2x4
class IFC_PARSE_API IfcTime : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcTime (IfcEntityInstanceData* e);
    IfcTime (std::string v);
    operator std::string() const;
};
/// Definition from ISO/CD 10303-41:1992: A time measure is the value of the duration of periods.
/// Measured in seconds (s) or days (d) or other units of time.
/// Type: REAL
/// 
/// NOTE Corresponding ISO 10303 name: time_measure, please refer to ISO/IS 10303-41 for the final definition of the formal standard.
/// 
/// HISTORY New type in IFC Release 1.5.1.
class IFC_PARSE_API IfcTimeMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcTimeMeasure (IfcEntityInstanceData* e);
    IfcTimeMeasure (double v);
    operator double() const;
};
/// IfcTimeStamp is an indication of date and time by measuring the number of seconds which have elapsed since the beginning of the year 1970.
/// Type: INTEGER
/// 
/// HISTORY New type in IFC Release 1.5.1.
class IFC_PARSE_API IfcTimeStamp : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcTimeStamp (IfcEntityInstanceData* e);
    IfcTimeStamp (int v);
    operator int() const;
};
/// IfcTorqueMeasure is a measure of the torque or moment of a couple.
/// Usually measured in N m.
/// Type: REAL
/// 
/// HISTORY New type in IFC Release 2x.
class IFC_PARSE_API IfcTorqueMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcTorqueMeasure (IfcEntityInstanceData* e);
    IfcTorqueMeasure (double v);
    operator double() const;
};
/// IfcURIReference provides for identifying a Uniform Resource Identifier, URI, as defined by the RFC3986 of the Network Working Group. A URI can be classified as a locator or a name or both, that is it may comprise a Uniform Resource Locator (URL) and/or a Uniform Resource Name (URN).
/// 
/// A Uniform Resource Locator, URL, is a string conforming to a standardized format, which refers to a resource on the internet (such as a document or an image) by its location.
/// A Uniform Resource Name, URN, is intended to serve as persistent, location-independent resource identifier and is
/// designed to make it easy to map other namespaces (that share the properties of URNs) into URN-space.
/// 
/// HISTORY New defined datatype in IFC 2x4.
class IFC_PARSE_API IfcURIReference : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcURIReference (IfcEntityInstanceData* e);
    IfcURIReference (std::string v);
    operator std::string() const;
};
/// IfcVaporPermeabilityMeasure is a measure of vapor permeability.
/// Usually measured in kg / s m Pascal.
/// Type: REAL
/// 
/// HISTORY New type in IFC Release 2x.
class IFC_PARSE_API IfcVaporPermeabilityMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcVaporPermeabilityMeasure (IfcEntityInstanceData* e);
    IfcVaporPermeabilityMeasure (double v);
    operator double() const;
};
/// Definition from ISO/CD 10303-41:1992: A volume measure is the value of the solid content of a body.
/// Usually measured in cubic metre (m3).
/// Type: REAL
/// 
/// NOTE Corresponding ISO 10303 name: volume_measure, please refer to ISO/IS 10303-41 for the final definition of the formal standard.
/// 
/// HISTORY New type in IFC Release 1.5.1.
class IFC_PARSE_API IfcVolumeMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcVolumeMeasure (IfcEntityInstanceData* e);
    IfcVolumeMeasure (double v);
    operator double() const;
};
/// IfcVolumetricFlowRateMeasure is a measure of the volume of a medium flowing per unit time.
/// Usually measured in m3/s.
/// Type: REAL
/// 
/// HISTORY New type in IFC Release 2.0.
class IFC_PARSE_API IfcVolumetricFlowRateMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcVolumetricFlowRateMeasure (IfcEntityInstanceData* e);
    IfcVolumetricFlowRateMeasure (double v);
    operator double() const;
};
/// IfcWarpingConstantMeasure is a measure for the warping constant or warping resistance of a cross section under torsional loading. It is usually measured in m^6.
/// 
/// Type: REAL  
/// 
/// HISTORY New type in IFC2x2.
class IFC_PARSE_API IfcWarpingConstantMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcWarpingConstantMeasure (IfcEntityInstanceData* e);
    IfcWarpingConstantMeasure (double v);
    operator double() const;
};
/// The warping moment measure is a measure for the warping moment, which occurs in warping torsional analysis. It is usually measured in kN*m^2.
/// 
/// Type: REAL  
/// 
/// HISTORY New type in IFC2x2.
class IFC_PARSE_API IfcWarpingMomentMeasure : public IfcUtil::IfcBaseType {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcWarpingMomentMeasure (IfcEntityInstanceData* e);
    IfcWarpingMomentMeasure (double v);
    operator double() const;
};
/// The box alignment specifies the alignment of the text box relative to its position. The following string values shall be used:
/// 
/// top-left
///   top-middle
///   top-right
///   middle-left
///   center
///   middle-right
///   bottom-left
///   bottom-middle
///   bottom-right
/// 
/// NOTE  The top-left is the default value.
/// 
/// Figure 298 illustrates alignment values.
/// 
/// Figure 298 — Box alignment values
/// 
/// Figure 299 illustrates use of alignment values together with the placement and planar extent.
/// 
/// Figure 299 — Box alignment examples
/// 
/// HISTORY  New type in IFC2x2 Addendum2.
/// 
/// IFC2x3 CHANGE  The IfcBoxAlignment has been added.
class IFC_PARSE_API IfcBoxAlignment : public IfcLabel {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcBoxAlignment (IfcEntityInstanceData* e);
    IfcBoxAlignment (std::string v);
    operator std::string() const;
};
/// IfcNormalisedRatioMeasure is a dimensionless measure to express ratio values ranging from 0.0 to 1.0.
/// 
/// Type: REAL
/// 
/// HISTORY New type in IFC Release 2x.
class IFC_PARSE_API IfcNormalisedRatioMeasure : public IfcRatioMeasure {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcNormalisedRatioMeasure (IfcEntityInstanceData* e);
    IfcNormalisedRatioMeasure (double v);
    operator double() const;
};
/// Definition from ISO/CD 10303-41:1992: A positive ratio measure is a ratio measure that is greater than zero.
/// Type: IfcRatioMeasure
/// 
/// NOTE Corresponding ISO 10303 name: positive_ratio_measure, please refer to ISO/IS 10303-41 for the final definition of the formal standard.
/// 
/// HISTORY New type in IFC Release 1.5.1.
class IFC_PARSE_API IfcPositiveRatioMeasure : public IfcRatioMeasure {
public:
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const;
    virtual Argument* getArgument(unsigned int i) const;
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    explicit IfcPositiveRatioMeasure (IfcEntityInstanceData* e);
    IfcPositiveRatioMeasure (double v);
    operator double() const;
};


/// Definition: A role which is performed by an actor, either a person, an organization or a 
/// person related to an organization.
/// 
/// NOTE: The list of roles of the enumeration values of the Role attribute can never
/// be complete. Therefore using enumeration value USERDEFINED, the user can provide his/her own role as a value 
/// of the attribute UserDefinedRole.
/// 
/// Corresponds to the following entity in ISO-10303-41: organization_role and person_role.
/// 
/// HISTORY New entity in IFC Release 1.5.1
class IFC_PARSE_API IfcActorRole : public IfcUtil::IfcBaseEntity {
public:
    /// The name of the role played by an actor. If the Role has value USERDEFINED, then
    /// the user defined role shall be provided as a value of the attribute UserDefinedRole.
    IfcRoleEnum::IfcRoleEnum Role() const;
    void setRole(IfcRoleEnum::IfcRoleEnum v);
    /// Whether the optional attribute UserDefinedRole is defined for this IfcActorRole
    bool hasUserDefinedRole() const;
    /// Allows for specification of user defined roles beyond the 
    /// enumeration values provided by Role attribute of type IfcRoleEnum. 
    /// When a value is provided for attribute UserDefinedRole in parallel 
    /// the attribute Role shall have enumeration value USERDEFINED.
    std::string UserDefinedRole() const;
    void setUserDefinedRole(std::string v);
    /// Whether the optional attribute Description is defined for this IfcActorRole
    bool hasDescription() const;
    /// A textual description relating the nature of the role played by an actor.
    std::string Description() const;
    void setDescription(std::string v);
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENUMERATION; case 1: return IfcUtil::Argument_STRING; case 2: return IfcUtil::Argument_STRING; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcRoleEnum; case 1: return Type::IfcLabel; case 2: return Type::IfcText; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Role"; case 1: return "UserDefinedRole"; case 2: return "Description"; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcExternalReferenceRelationship >::ptr HasExternalReference() const; // INVERSE IfcExternalReferenceRelationship::RelatedResourceObjects
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcActorRole (IfcEntityInstanceData* e);
    IfcActorRole (IfcRoleEnum::IfcRoleEnum v1_Role, boost::optional< std::string > v2_UserDefinedRole, boost::optional< std::string > v3_Description);
    typedef IfcTemplatedEntityList< IfcActorRole > list;
};
/// Definition: An abstract entity type for various kinds of postal and telecom addresses.
/// 
/// NOTE Corresponds to the following entity in ISO-10303-41: address.
/// 
/// HISTORY New entity in IFC Release 1.5.1.
class IFC_PARSE_API IfcAddress : public IfcUtil::IfcBaseEntity {
public:
    /// Whether the optional attribute Purpose is defined for this IfcAddress
    bool hasPurpose() const;
    /// Identifies the logical location of the address.
    IfcAddressTypeEnum::IfcAddressTypeEnum Purpose() const;
    void setPurpose(IfcAddressTypeEnum::IfcAddressTypeEnum v);
    /// Whether the optional attribute Description is defined for this IfcAddress
    bool hasDescription() const;
    /// Text that relates the nature of the address.
    std::string Description() const;
    void setDescription(std::string v);
    /// Whether the optional attribute UserDefinedPurpose is defined for this IfcAddress
    bool hasUserDefinedPurpose() const;
    /// Allows for specification of user specific purpose of the address beyond the 
    /// enumeration values provided by Purpose attribute of type IfcAddressTypeEnum. 
    /// When a value is provided for attribute UserDefinedPurpose, in parallel the 
    /// attribute Purpose shall have enumeration value USERDEFINED.
    std::string UserDefinedPurpose() const;
    void setUserDefinedPurpose(std::string v);
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENUMERATION; case 1: return IfcUtil::Argument_STRING; case 2: return IfcUtil::Argument_STRING; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcAddressTypeEnum; case 1: return Type::IfcText; case 2: return Type::IfcLabel; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Purpose"; case 1: return "Description"; case 2: return "UserDefinedPurpose"; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcPerson >::ptr OfPerson() const; // INVERSE IfcPerson::Addresses
    IfcTemplatedEntityList< IfcOrganization >::ptr OfOrganization() const; // INVERSE IfcOrganization::Addresses
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcAddress (IfcEntityInstanceData* e);
    IfcAddress (boost::optional< IfcAddressTypeEnum::IfcAddressTypeEnum > v1_Purpose, boost::optional< std::string > v2_Description, boost::optional< std::string > v3_UserDefinedPurpose);
    typedef IfcTemplatedEntityList< IfcAddress > list;
};
/// IfcApplication holds the information about an IFC compliant application developed by an application developer. The IfcApplication utilizes a short identifying name as provided by the application developer.
/// 
/// HISTORY  New entity in IFC R1.5.
class IFC_PARSE_API IfcApplication : public IfcUtil::IfcBaseEntity {
public:
    /// Name of the application developer, being requested to be member of the IAI.
    IfcOrganization* ApplicationDeveloper() const;
    void setApplicationDeveloper(IfcOrganization* v);
    /// The version number of this software as specified by the developer of the application.
    std::string Version() const;
    void setVersion(std::string v);
    /// The full name of the application as specified by the application developer.
    std::string ApplicationFullName() const;
    void setApplicationFullName(std::string v);
    /// Short identifying name for the application.
    std::string ApplicationIdentifier() const;
    void setApplicationIdentifier(std::string v);
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_STRING; case 2: return IfcUtil::Argument_STRING; case 3: return IfcUtil::Argument_STRING; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcOrganization; case 1: return Type::IfcLabel; case 2: return Type::IfcLabel; case 3: return Type::IfcIdentifier; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "ApplicationDeveloper"; case 1: return "Version"; case 2: return "ApplicationFullName"; case 3: return "ApplicationIdentifier"; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcApplication (IfcEntityInstanceData* e);
    IfcApplication (IfcOrganization* v1_ApplicationDeveloper, std::string v2_Version, std::string v3_ApplicationFullName, std::string v4_ApplicationIdentifier);
    typedef IfcTemplatedEntityList< IfcApplication > list;
};
/// IfcAppliedValue is an abstract supertype that specifies the common attributes for cost values. 
/// 
/// HISTORY: New Entity in IFC2x2.  Modifed in IFC2x4 to use IfcDate for date values.
/// 
/// Use definitions 
/// The extent of the IfcAppliedValue is determined by the AppliedValue attribute which may be defined either as an IfcMeasureWithUnit or as an IfcMonetaryMeasure or as an IfcRatioMeasure via the IfcAppliedValueSelect type.  
/// 
/// Optionally, an IfcAppliedValue may have an applicable date. This is intended to fix the date on which the value became relevant for use. It may be the date on which the value was set in the model or it may be a prior or future date when the value becomes operable.
/// 
/// Similarly, an IfcAppliedValue may have a 'fixed until' date. This is intended to fix the date on which the value ceases to be relevant for use. 
/// 
/// An instance of IfcAppliedValue may have a unit basis asserted.  This is defined as an IfcMeasureWithUnit that determines the extent of the unit value for application purposes. It is assumed that when this attribute is asserted, then the value given to IfcAppliedValue is that for unit quantity. This is not enforced within the IFC schema and thus needs to be controlled within an application.
/// 
/// Applied values may be referenced from a document (such as a price list). The relationship between one or more occurrences of IfcAppliedValue (or its subtypes) is achieved through the use of the IfcExternalReferenceRelationship in which the document provides the IfcExternalReferenceRelationship.RelatingExtReference and the value occurrences are the IfcExternalReferenceRelationship.RelatedResourceObjects.
class IFC_PARSE_API IfcAppliedValue : public IfcUtil::IfcBaseEntity {
public:
    /// Whether the optional attribute Name is defined for this IfcAppliedValue
    bool hasName() const;
    /// A name or additional clarification given to a cost value.
    std::string Name() const;
    void setName(std::string v);
    /// Whether the optional attribute Description is defined for this IfcAppliedValue
    bool hasDescription() const;
    /// The description that may apply additional information about a cost value.
    std::string Description() const;
    void setDescription(std::string v);
    /// Whether the optional attribute AppliedValue is defined for this IfcAppliedValue
    bool hasAppliedValue() const;
    /// The extent or quantity or amount of an applied value.
    IfcAppliedValueSelect* AppliedValue() const;
    void setAppliedValue(IfcAppliedValueSelect* v);
    /// Whether the optional attribute UnitBasis is defined for this IfcAppliedValue
    bool hasUnitBasis() const;
    /// The number and unit of measure on which the unit cost is based.
    /// 
    /// Note: As well as the normally expected units of measure such as length, area, volume etc., costs may be based on units of measure which need to be defined e.g. sack, drum, pallet, item etc. Unit costs may be based on quantities greater (or lesser) than a unitary value of the basis measure. For instance, timber may have a unit cost rate per X meters where X > 1; similarly for cable, piping and many other items. The basis number may be either an integer or a real value.
    /// 
    /// Note: This attribute should be asserted for all circumstances where the cost to be applied is per unit quantity. It may be asserted even for circumstances where an item price is used, in which case the unit cost basis should be by item (or equivalent definition).
    IfcMeasureWithUnit* UnitBasis() const;
    void setUnitBasis(IfcMeasureWithUnit* v);
    /// Whether the optional attribute ApplicableDate is defined for this IfcAppliedValue
    bool hasApplicableDate() const;
    /// The date on or from which an applied value is applicable.
    /// 
    /// IFC2x4 CHANGE Type changed from IfcDateTimeSelect.
    std::string ApplicableDate() const;
    void setApplicableDate(std::string v);
    /// Whether the optional attribute FixedUntilDate is defined for this IfcAppliedValue
    bool hasFixedUntilDate() const;
    /// The date until which applied value is applicable.
    /// 
    /// IFC2x4 CHANGE Type changed from IfcDateTimeSelect.
    std::string FixedUntilDate() const;
    void setFixedUntilDate(std::string v);
    /// Whether the optional attribute Category is defined for this IfcAppliedValue
    bool hasCategory() const;
    std::string Category() const;
    void setCategory(std::string v);
    /// Whether the optional attribute Condition is defined for this IfcAppliedValue
    bool hasCondition() const;
    std::string Condition() const;
    void setCondition(std::string v);
    /// Whether the optional attribute ArithmeticOperator is defined for this IfcAppliedValue
    bool hasArithmeticOperator() const;
    IfcArithmeticOperatorEnum::IfcArithmeticOperatorEnum ArithmeticOperator() const;
    void setArithmeticOperator(IfcArithmeticOperatorEnum::IfcArithmeticOperatorEnum v);
    /// Whether the optional attribute Components is defined for this IfcAppliedValue
    bool hasComponents() const;
    IfcTemplatedEntityList< IfcAppliedValue >::ptr Components() const;
    void setComponents(IfcTemplatedEntityList< IfcAppliedValue >::ptr v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_STRING; case 1: return IfcUtil::Argument_STRING; case 2: return IfcUtil::Argument_ENTITY_INSTANCE; case 3: return IfcUtil::Argument_ENTITY_INSTANCE; case 4: return IfcUtil::Argument_STRING; case 5: return IfcUtil::Argument_STRING; case 6: return IfcUtil::Argument_STRING; case 7: return IfcUtil::Argument_STRING; case 8: return IfcUtil::Argument_ENUMERATION; case 9: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcLabel; case 1: return Type::IfcText; case 2: return Type::IfcAppliedValueSelect; case 3: return Type::IfcMeasureWithUnit; case 4: return Type::IfcDate; case 5: return Type::IfcDate; case 6: return Type::IfcLabel; case 7: return Type::IfcLabel; case 8: return Type::IfcArithmeticOperatorEnum; case 9: return Type::IfcAppliedValue; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Name"; case 1: return "Description"; case 2: return "AppliedValue"; case 3: return "UnitBasis"; case 4: return "ApplicableDate"; case 5: return "FixedUntilDate"; case 6: return "Category"; case 7: return "Condition"; case 8: return "ArithmeticOperator"; case 9: return "Components"; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcExternalReferenceRelationship >::ptr HasExternalReference() const; // INVERSE IfcExternalReferenceRelationship::RelatedResourceObjects
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcAppliedValue (IfcEntityInstanceData* e);
    IfcAppliedValue (boost::optional< std::string > v1_Name, boost::optional< std::string > v2_Description, IfcAppliedValueSelect* v3_AppliedValue, IfcMeasureWithUnit* v4_UnitBasis, boost::optional< std::string > v5_ApplicableDate, boost::optional< std::string > v6_FixedUntilDate, boost::optional< std::string > v7_Category, boost::optional< std::string > v8_Condition, boost::optional< IfcArithmeticOperatorEnum::IfcArithmeticOperatorEnum > v9_ArithmeticOperator, boost::optional< IfcTemplatedEntityList< IfcAppliedValue >::ptr > v10_Components);
    typedef IfcTemplatedEntityList< IfcAppliedValue > list;
};
/// Definition: An IfcApproval represents information about approval processes such as for a plan, a design, a proposal, or a change order in a construction or facilities management project. IfcApproval is referenced by IfcRelAssociatesApproval in IfcControlExtension schema, and thereby can be related to all subtypes of IfcRoot. An approval may also be given to resource objects using IfcResourceApprovalRelationship
/// 
/// HISTORY New Entity in IFC Release 2.0
/// 
/// IFC2x Edition 4 CHANGE  Attributes Identifier and Name made optional, where rule added to require at least one of them being asserted. Inverse attributes ApprovedObjects, ApprovedResources and HasExternalReferences added. Inverse attribute Properties deleted (more general relationship via inverse ApprovedResources to be used instead).
class IFC_PARSE_API IfcApproval : public IfcUtil::IfcBaseEntity {
public:
    /// Whether the optional attribute Identifier is defined for this IfcApproval
    bool hasIdentifier() const;
    /// A computer interpretable identifier by which the approval is known.
    std::string Identifier() const;
    void setIdentifier(std::string v);
    /// Whether the optional attribute Name is defined for this IfcApproval
    bool hasName() const;
    /// A human readable name given to an approval.
    std::string Name() const;
    void setName(std::string v);
    /// Whether the optional attribute Description is defined for this IfcApproval
    bool hasDescription() const;
    /// A general textual description of a design, work task, plan, etc. that is being approved for.
    std::string Description() const;
    void setDescription(std::string v);
    /// Whether the optional attribute TimeOfApproval is defined for this IfcApproval
    bool hasTimeOfApproval() const;
    /// Date and time when the result of the approval process is produced.
    /// 
    /// IFC2x4 CHANGE  Attribute data type changed to IfcDateTime using ISO 8601 representation, renamed from ApprovalDateTime and made OPTIONAL.
    std::string TimeOfApproval() const;
    void setTimeOfApproval(std::string v);
    /// Whether the optional attribute Status is defined for this IfcApproval
    bool hasStatus() const;
    /// The result or current status of the approval, e.g. Requested, Processed, Approved, Not Approved.
    std::string Status() const;
    void setStatus(std::string v);
    /// Whether the optional attribute Level is defined for this IfcApproval
    bool hasLevel() const;
    /// Level of the approval e.g. Draft v.s. Completed design.
    std::string Level() const;
    void setLevel(std::string v);
    /// Whether the optional attribute Qualifier is defined for this IfcApproval
    bool hasQualifier() const;
    /// Textual description of special constraints or conditions for the approval.
    std::string Qualifier() const;
    void setQualifier(std::string v);
    /// Whether the optional attribute RequestingApproval is defined for this IfcApproval
    bool hasRequestingApproval() const;
    /// The actor that is acting in the role specified at IfcOrganization or individually at IfcPerson and requesting an approval.
    /// 
    /// IFC2x4 CHANGE  New attribute for approval request replacing IfcApprovalActorRelationship (being deleted).
    IfcActorSelect* RequestingApproval() const;
    void setRequestingApproval(IfcActorSelect* v);
    /// Whether the optional attribute GivingApproval is defined for this IfcApproval
    bool hasGivingApproval() const;
    /// The actor that is acting in the role specified at IfcOrganization or individually at IfcPerson and giving an approval.
    /// 
    /// IFC2x4 CHANGE  New attribute for approval provision replacing IfcApprovalActorRelationship (being deleted).
    IfcActorSelect* GivingApproval() const;
    void setGivingApproval(IfcActorSelect* v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_STRING; case 1: return IfcUtil::Argument_STRING; case 2: return IfcUtil::Argument_STRING; case 3: return IfcUtil::Argument_STRING; case 4: return IfcUtil::Argument_STRING; case 5: return IfcUtil::Argument_STRING; case 6: return IfcUtil::Argument_STRING; case 7: return IfcUtil::Argument_ENTITY_INSTANCE; case 8: return IfcUtil::Argument_ENTITY_INSTANCE; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcIdentifier; case 1: return Type::IfcLabel; case 2: return Type::IfcText; case 3: return Type::IfcDateTime; case 4: return Type::IfcLabel; case 5: return Type::IfcLabel; case 6: return Type::IfcText; case 7: return Type::IfcActorSelect; case 8: return Type::IfcActorSelect; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Identifier"; case 1: return "Name"; case 2: return "Description"; case 3: return "TimeOfApproval"; case 4: return "Status"; case 5: return "Level"; case 6: return "Qualifier"; case 7: return "RequestingApproval"; case 8: return "GivingApproval"; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcExternalReferenceRelationship >::ptr HasExternalReferences() const; // INVERSE IfcExternalReferenceRelationship::RelatedResourceObjects
    IfcTemplatedEntityList< IfcRelAssociatesApproval >::ptr ApprovedObjects() const; // INVERSE IfcRelAssociatesApproval::RelatingApproval
    IfcTemplatedEntityList< IfcResourceApprovalRelationship >::ptr ApprovedResources() const; // INVERSE IfcResourceApprovalRelationship::RelatingApproval
    IfcTemplatedEntityList< IfcApprovalRelationship >::ptr IsRelatedWith() const; // INVERSE IfcApprovalRelationship::RelatedApprovals
    IfcTemplatedEntityList< IfcApprovalRelationship >::ptr Relates() const; // INVERSE IfcApprovalRelationship::RelatingApproval
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcApproval (IfcEntityInstanceData* e);
    IfcApproval (boost::optional< std::string > v1_Identifier, boost::optional< std::string > v2_Name, boost::optional< std::string > v3_Description, boost::optional< std::string > v4_TimeOfApproval, boost::optional< std::string > v5_Status, boost::optional< std::string > v6_Level, boost::optional< std::string > v7_Qualifier, IfcActorSelect* v8_RequestingApproval, IfcActorSelect* v9_GivingApproval);
    typedef IfcTemplatedEntityList< IfcApproval > list;
};
/// Definition
/// from IAI: The abstract entity IfcBoundaryCondition
/// is the supertype of all boundary conditions that can be applied to
/// structural connection definitions, either directly for the connection
/// (e.g. the joint) or for the relation between a structural member and
/// the connection.
/// NOTE: The boundary conditions are used
/// within other parts, mainly by instances of IfcStructuralConnection
/// (for the definition of supports) and instances of IfcRelConnectsStructuralMember
/// (for the definition of connections between structural members and
/// structural connections). 
/// 
/// HISTORY: New entity
/// in Release IFC2x Edition
/// 2.
class IFC_PARSE_API IfcBoundaryCondition : public IfcUtil::IfcBaseEntity {
public:
    /// Whether the optional attribute Name is defined for this IfcBoundaryCondition
    bool hasName() const;
    /// Optionally defines a name for this boundary condition.
    std::string Name() const;
    void setName(std::string v);
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_STRING; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcLabel; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Name"; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcBoundaryCondition (IfcEntityInstanceData* e);
    IfcBoundaryCondition (boost::optional< std::string > v1_Name);
    typedef IfcTemplatedEntityList< IfcBoundaryCondition > list;
};
/// Definition from IAI: Describes linearly elastic support conditions or connection conditions.
/// 
/// Applicability:
/// 
/// Curve supports and connections.
/// 
/// HISTORY: New entity in IFC 2x2.
/// IFC 2x4 change: Attributes LinearStiffnessX/Y/Z renamed to TranslationalStiffnessX/Y/Z.
/// 
/// IFC 2x4 change: All attribute data types changed from numeric to SELECT between Boolean and numeric.  Stiffnesses may now also be negative, for example to capture destabilizing effects in boundary conditions.  The IFC 2x3 convention of -1. representing infinite stiffness is no longer valid and must not be used.  Infinite stiffness, i.e. fixed supports, are now modeled by the Boolean value TRUE.
class IFC_PARSE_API IfcBoundaryEdgeCondition : public IfcBoundaryCondition {
public:
    /// Whether the optional attribute TranslationalStiffnessByLengthX is defined for this IfcBoundaryEdgeCondition
    bool hasTranslationalStiffnessByLengthX() const;
    /// Translational stiffness value in x-direction of the coordinate system defined by the instance which uses this resource object.
    IfcModulusOfTranslationalSubgradeReactionSelect* TranslationalStiffnessByLengthX() const;
    void setTranslationalStiffnessByLengthX(IfcModulusOfTranslationalSubgradeReactionSelect* v);
    /// Whether the optional attribute TranslationalStiffnessByLengthY is defined for this IfcBoundaryEdgeCondition
    bool hasTranslationalStiffnessByLengthY() const;
    /// Translational stiffness value in y-direction of the coordinate system defined by the instance which uses this resource object.
    IfcModulusOfTranslationalSubgradeReactionSelect* TranslationalStiffnessByLengthY() const;
    void setTranslationalStiffnessByLengthY(IfcModulusOfTranslationalSubgradeReactionSelect* v);
    /// Whether the optional attribute TranslationalStiffnessByLengthZ is defined for this IfcBoundaryEdgeCondition
    bool hasTranslationalStiffnessByLengthZ() const;
    /// Translational stiffness value in z-direction of the coordinate system defined by the instance which uses this resource object.
    IfcModulusOfTranslationalSubgradeReactionSelect* TranslationalStiffnessByLengthZ() const;
    void setTranslationalStiffnessByLengthZ(IfcModulusOfTranslationalSubgradeReactionSelect* v);
    /// Whether the optional attribute RotationalStiffnessByLengthX is defined for this IfcBoundaryEdgeCondition
    bool hasRotationalStiffnessByLengthX() const;
    /// Rotational stiffness value about the x-axis of the coordinate system defined by the instance which uses this resource object.
    IfcModulusOfRotationalSubgradeReactionSelect* RotationalStiffnessByLengthX() const;
    void setRotationalStiffnessByLengthX(IfcModulusOfRotationalSubgradeReactionSelect* v);
    /// Whether the optional attribute RotationalStiffnessByLengthY is defined for this IfcBoundaryEdgeCondition
    bool hasRotationalStiffnessByLengthY() const;
    /// Rotational stiffness value about the y-axis of the coordinate system defined by the instance which uses this resource object.
    IfcModulusOfRotationalSubgradeReactionSelect* RotationalStiffnessByLengthY() const;
    void setRotationalStiffnessByLengthY(IfcModulusOfRotationalSubgradeReactionSelect* v);
    /// Whether the optional attribute RotationalStiffnessByLengthZ is defined for this IfcBoundaryEdgeCondition
    bool hasRotationalStiffnessByLengthZ() const;
    /// Rotational stiffness value about the z-axis of the coordinate system defined by the instance which uses this resource object.
    IfcModulusOfRotationalSubgradeReactionSelect* RotationalStiffnessByLengthZ() const;
    void setRotationalStiffnessByLengthZ(IfcModulusOfRotationalSubgradeReactionSelect* v);
    virtual unsigned int getArgumentCount() const { return 7; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 1: return IfcUtil::Argument_ENTITY_INSTANCE; case 2: return IfcUtil::Argument_ENTITY_INSTANCE; case 3: return IfcUtil::Argument_ENTITY_INSTANCE; case 4: return IfcUtil::Argument_ENTITY_INSTANCE; case 5: return IfcUtil::Argument_ENTITY_INSTANCE; case 6: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcBoundaryCondition::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 1: return Type::IfcModulusOfTranslationalSubgradeReactionSelect; case 2: return Type::IfcModulusOfTranslationalSubgradeReactionSelect; case 3: return Type::IfcModulusOfTranslationalSubgradeReactionSelect; case 4: return Type::IfcModulusOfRotationalSubgradeReactionSelect; case 5: return Type::IfcModulusOfRotationalSubgradeReactionSelect; case 6: return Type::IfcModulusOfRotationalSubgradeReactionSelect; } return IfcBoundaryCondition::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 1: return "TranslationalStiffnessByLengthX"; case 2: return "TranslationalStiffnessByLengthY"; case 3: return "TranslationalStiffnessByLengthZ"; case 4: return "RotationalStiffnessByLengthX"; case 5: return "RotationalStiffnessByLengthY"; case 6: return "RotationalStiffnessByLengthZ"; } return IfcBoundaryCondition::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcBoundaryEdgeCondition (IfcEntityInstanceData* e);
    IfcBoundaryEdgeCondition (boost::optional< std::string > v1_Name, IfcModulusOfTranslationalSubgradeReactionSelect* v2_TranslationalStiffnessByLengthX, IfcModulusOfTranslationalSubgradeReactionSelect* v3_TranslationalStiffnessByLengthY, IfcModulusOfTranslationalSubgradeReactionSelect* v4_TranslationalStiffnessByLengthZ, IfcModulusOfRotationalSubgradeReactionSelect* v5_RotationalStiffnessByLengthX, IfcModulusOfRotationalSubgradeReactionSelect* v6_RotationalStiffnessByLengthY, IfcModulusOfRotationalSubgradeReactionSelect* v7_RotationalStiffnessByLengthZ);
    typedef IfcTemplatedEntityList< IfcBoundaryEdgeCondition > list;
};
/// Definition from IAI: Describes linearly elastic support conditions or connection conditions.
/// 
/// Applicability:
/// 
/// Surface supports and connections.
/// 
/// HISTORY: New entity in IFC 2x2.
/// IFC 2x4 change: Attributes LinearStiffnessX/Y/Z renamed to TranslationalStiffnessX/Y/Z.
/// 
/// IFC 2x4 change: All attribute data types changed from numeric to SELECT between Boolean and numeric.  Stiffnesses may now also be negative, for example to capture destabilizing effects in boundary conditions.  The IFC 2x3 convention of -1. representing infinite stiffness is no longer valid and must not be used.  Infinite stiffness, i.e. fixed supports, are now modeled by the Boolean value TRUE.
class IFC_PARSE_API IfcBoundaryFaceCondition : public IfcBoundaryCondition {
public:
    /// Whether the optional attribute TranslationalStiffnessByAreaX is defined for this IfcBoundaryFaceCondition
    bool hasTranslationalStiffnessByAreaX() const;
    /// Translational stiffness value in x-direction of the coordinate system defined by the instance which uses this resource object.
    IfcModulusOfSubgradeReactionSelect* TranslationalStiffnessByAreaX() const;
    void setTranslationalStiffnessByAreaX(IfcModulusOfSubgradeReactionSelect* v);
    /// Whether the optional attribute TranslationalStiffnessByAreaY is defined for this IfcBoundaryFaceCondition
    bool hasTranslationalStiffnessByAreaY() const;
    /// Translational stiffness value in y-direction of the coordinate system defined by the instance which uses this resource object.
    IfcModulusOfSubgradeReactionSelect* TranslationalStiffnessByAreaY() const;
    void setTranslationalStiffnessByAreaY(IfcModulusOfSubgradeReactionSelect* v);
    /// Whether the optional attribute TranslationalStiffnessByAreaZ is defined for this IfcBoundaryFaceCondition
    bool hasTranslationalStiffnessByAreaZ() const;
    /// Translational stiffness value in z-direction of the coordinate system defined by the instance which uses this resource object.
    IfcModulusOfSubgradeReactionSelect* TranslationalStiffnessByAreaZ() const;
    void setTranslationalStiffnessByAreaZ(IfcModulusOfSubgradeReactionSelect* v);
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 1: return IfcUtil::Argument_ENTITY_INSTANCE; case 2: return IfcUtil::Argument_ENTITY_INSTANCE; case 3: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcBoundaryCondition::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 1: return Type::IfcModulusOfSubgradeReactionSelect; case 2: return Type::IfcModulusOfSubgradeReactionSelect; case 3: return Type::IfcModulusOfSubgradeReactionSelect; } return IfcBoundaryCondition::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 1: return "TranslationalStiffnessByAreaX"; case 2: return "TranslationalStiffnessByAreaY"; case 3: return "TranslationalStiffnessByAreaZ"; } return IfcBoundaryCondition::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcBoundaryFaceCondition (IfcEntityInstanceData* e);
    IfcBoundaryFaceCondition (boost::optional< std::string > v1_Name, IfcModulusOfSubgradeReactionSelect* v2_TranslationalStiffnessByAreaX, IfcModulusOfSubgradeReactionSelect* v3_TranslationalStiffnessByAreaY, IfcModulusOfSubgradeReactionSelect* v4_TranslationalStiffnessByAreaZ);
    typedef IfcTemplatedEntityList< IfcBoundaryFaceCondition > list;
};
/// Definition from IAI: Describes linearly elastic support conditions or connection conditions.
/// 
/// Applicability:
/// 
/// Point supports and connections.
/// 
/// HISTORY: New entity in IFC 2x2.
/// IFC 2x4 change: Attributes LinearStiffnessX/Y/Z renamed to TranslationalStiffnessX/Y/Z.
/// 
/// IFC 2x4 change: All attribute data types changed from numeric to SELECT between Boolean and numeric.  Stiffnesses may now also be negative, for example to capture destabilizing effects in boundary conditions.  The IFC 2x3 convention of -1. representing infinite stiffness is no longer valid and must not be used.  Infinite stiffness, i.e. fixed supports, are now modeled by the Boolean value TRUE.
class IFC_PARSE_API IfcBoundaryNodeCondition : public IfcBoundaryCondition {
public:
    /// Whether the optional attribute TranslationalStiffnessX is defined for this IfcBoundaryNodeCondition
    bool hasTranslationalStiffnessX() const;
    /// Translational stiffness value in x-direction of the coordinate system defined by the instance which uses this resource object.
    IfcTranslationalStiffnessSelect* TranslationalStiffnessX() const;
    void setTranslationalStiffnessX(IfcTranslationalStiffnessSelect* v);
    /// Whether the optional attribute TranslationalStiffnessY is defined for this IfcBoundaryNodeCondition
    bool hasTranslationalStiffnessY() const;
    /// Translational stiffness value in y-direction of the coordinate system defined by the instance which uses this resource object.
    IfcTranslationalStiffnessSelect* TranslationalStiffnessY() const;
    void setTranslationalStiffnessY(IfcTranslationalStiffnessSelect* v);
    /// Whether the optional attribute TranslationalStiffnessZ is defined for this IfcBoundaryNodeCondition
    bool hasTranslationalStiffnessZ() const;
    /// Translational stiffness value in z-direction of the coordinate system defined by the instance which uses this resource object.
    IfcTranslationalStiffnessSelect* TranslationalStiffnessZ() const;
    void setTranslationalStiffnessZ(IfcTranslationalStiffnessSelect* v);
    /// Whether the optional attribute RotationalStiffnessX is defined for this IfcBoundaryNodeCondition
    bool hasRotationalStiffnessX() const;
    /// Rotational stiffness value about the x-axis of the coordinate system defined by the instance which uses this resource object.
    IfcRotationalStiffnessSelect* RotationalStiffnessX() const;
    void setRotationalStiffnessX(IfcRotationalStiffnessSelect* v);
    /// Whether the optional attribute RotationalStiffnessY is defined for this IfcBoundaryNodeCondition
    bool hasRotationalStiffnessY() const;
    /// Rotational stiffness value about the y-axis of the coordinate system defined by the instance which uses this resource object.
    IfcRotationalStiffnessSelect* RotationalStiffnessY() const;
    void setRotationalStiffnessY(IfcRotationalStiffnessSelect* v);
    /// Whether the optional attribute RotationalStiffnessZ is defined for this IfcBoundaryNodeCondition
    bool hasRotationalStiffnessZ() const;
    /// Rotational stiffness value about the z-axis of the coordinate system defined by the instance which uses this resource object.
    IfcRotationalStiffnessSelect* RotationalStiffnessZ() const;
    void setRotationalStiffnessZ(IfcRotationalStiffnessSelect* v);
    virtual unsigned int getArgumentCount() const { return 7; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 1: return IfcUtil::Argument_ENTITY_INSTANCE; case 2: return IfcUtil::Argument_ENTITY_INSTANCE; case 3: return IfcUtil::Argument_ENTITY_INSTANCE; case 4: return IfcUtil::Argument_ENTITY_INSTANCE; case 5: return IfcUtil::Argument_ENTITY_INSTANCE; case 6: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcBoundaryCondition::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 1: return Type::IfcTranslationalStiffnessSelect; case 2: return Type::IfcTranslationalStiffnessSelect; case 3: return Type::IfcTranslationalStiffnessSelect; case 4: return Type::IfcRotationalStiffnessSelect; case 5: return Type::IfcRotationalStiffnessSelect; case 6: return Type::IfcRotationalStiffnessSelect; } return IfcBoundaryCondition::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 1: return "TranslationalStiffnessX"; case 2: return "TranslationalStiffnessY"; case 3: return "TranslationalStiffnessZ"; case 4: return "RotationalStiffnessX"; case 5: return "RotationalStiffnessY"; case 6: return "RotationalStiffnessZ"; } return IfcBoundaryCondition::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcBoundaryNodeCondition (IfcEntityInstanceData* e);
    IfcBoundaryNodeCondition (boost::optional< std::string > v1_Name, IfcTranslationalStiffnessSelect* v2_TranslationalStiffnessX, IfcTranslationalStiffnessSelect* v3_TranslationalStiffnessY, IfcTranslationalStiffnessSelect* v4_TranslationalStiffnessZ, IfcRotationalStiffnessSelect* v5_RotationalStiffnessX, IfcRotationalStiffnessSelect* v6_RotationalStiffnessY, IfcRotationalStiffnessSelect* v7_RotationalStiffnessZ);
    typedef IfcTemplatedEntityList< IfcBoundaryNodeCondition > list;
};
/// Definition from IAI: Describes linearly elastic support conditions or connection conditions, including linearly elastic warping restraints.
/// 
/// Applicability:
/// 
/// Point supports and connections.
/// 
/// HISTORY: New entity in IFC 2x2. 
/// 
/// IFC 2x4 change: All attribute data types changed from numeric to SELECT between Boolean and numeric.  Stiffnesses may now also be negative, for example to capture destabilizing effects in boundary conditions.  The IFC 2x3 convention of -1. representing infinite stiffness is no longer valid and must not be used.  Infinite stiffness, i.e. fixed supports, are now modeled by the Boolean value TRUE.
class IFC_PARSE_API IfcBoundaryNodeConditionWarping : public IfcBoundaryNodeCondition {
public:
    /// Whether the optional attribute WarpingStiffness is defined for this IfcBoundaryNodeConditionWarping
    bool hasWarpingStiffness() const;
    /// Defines the warping stiffness value.
    IfcWarpingStiffnessSelect* WarpingStiffness() const;
    void setWarpingStiffness(IfcWarpingStiffnessSelect* v);
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 7: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcBoundaryNodeCondition::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 7: return Type::IfcWarpingStiffnessSelect; } return IfcBoundaryNodeCondition::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 7: return "WarpingStiffness"; } return IfcBoundaryNodeCondition::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcBoundaryNodeConditionWarping (IfcEntityInstanceData* e);
    IfcBoundaryNodeConditionWarping (boost::optional< std::string > v1_Name, IfcTranslationalStiffnessSelect* v2_TranslationalStiffnessX, IfcTranslationalStiffnessSelect* v3_TranslationalStiffnessY, IfcTranslationalStiffnessSelect* v4_TranslationalStiffnessZ, IfcRotationalStiffnessSelect* v5_RotationalStiffnessX, IfcRotationalStiffnessSelect* v6_RotationalStiffnessY, IfcRotationalStiffnessSelect* v7_RotationalStiffnessZ, IfcWarpingStiffnessSelect* v8_WarpingStiffness);
    typedef IfcTemplatedEntityList< IfcBoundaryNodeConditionWarping > list;
};
/// IfcConnectionGeometry is used to describe the geometric and topological constraints that facilitate the physical connection of two objects. It is envisioned as a control that applies to the element connection relationships.
/// 
/// NOTE  The element connection relationship normally provides for a logical connection information, by referencing the relating and related elements. If in addition an IfcConnectionGeometry is provided, physical connection information is given by specifying exactly where at the relating and related element the element connection occurs. 
/// Using the eccentricity subtypes, the connection can also be described when there is a physical distance (or eccentricity) between the connection elements.
/// 
/// The IfcConnectionGeometry allows for the provision of connection constraints between geometric and topological elements, the following connection geometry/topology types are in scope:
/// 
/// point | vertex point,
///   curve | edge curve,
///   surface | face surface,
/// 
/// HISTORY  New entity in IFC Release 1.5.
/// 
/// IFC2x Edition 3 CHANGE  The definition of the subtypes has been enhanced by allowing either geometric representation items (point | curve | surface) or topological representation items with associated geometry (vertex point | edge curve | face  surface).
class IFC_PARSE_API IfcConnectionGeometry : public IfcUtil::IfcBaseEntity {
public:
    virtual unsigned int getArgumentCount() const { return 0; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcConnectionGeometry (IfcEntityInstanceData* e);
    IfcConnectionGeometry ();
    typedef IfcTemplatedEntityList< IfcConnectionGeometry > list;
};
/// IfcConnectionPointGeometry
/// is used to describe the geometric constraints that facilitate the
/// physical connection of two objects at a point (here IfcCartesianPoint) or at an vertex with point
/// coordinates associated. It is envisioned as a control that applies to the element connection relationships. 
/// 
/// EXAMPLE  The connection relationship between two path based elements (like a column and a beam) has a geometric constraint which describes the connection points by a PointOnRelatingElement for the column and a PointOnRelatedElement for the beam. The exact usage of the IfcConnectionPointGeometry is further defined in the geometry use sections of the elements that use it.
/// 
/// NOTE  If the point connection has an offset (if the two points or vertex points at the relating and related element do not physically match), the subtype IfcConnectionPointEccentricity shall be used.
/// 
/// HISTORY  New entity in IFC Release 1.5, has been renamed from IfcPointConnectionGeometry in IFC Release 2x.
/// 
/// IFC2x Edition 3 CHANGE  The provision of topology with associated geometry, IfcVertexPoint, is
/// enabled by using the IfcPointOrVertexPoint.
/// 
/// Geometry use definitions
/// The IfcPoint (or the IfcVertexPoint with an associated IfcPoint) at the PointOnRelatingElement attribute defines the point where the basic geometry items of the connected elements connect. The point coordinates are provided within the local coordinate system of the RelatingElement, as specified at the IfcRelConnectsSubtype that utilizes the IfcConnectionPointGeometry. Optionally, the same point coordinates can also be provided within the local coordinate system of the RelatedElement by using the PointOnRelatedElement attribute. If both point coordinates are not identical within a common parent coordinate system (ultimately within the world coordinate system), the subtype IfcConnectionPointEccentricity shall be used.
class IFC_PARSE_API IfcConnectionPointGeometry : public IfcConnectionGeometry {
public:
    /// Point at which the connected object is aligned at the relating element, given in the LCS of the relating element.
    IfcPointOrVertexPoint* PointOnRelatingElement() const;
    void setPointOnRelatingElement(IfcPointOrVertexPoint* v);
    /// Whether the optional attribute PointOnRelatedElement is defined for this IfcConnectionPointGeometry
    bool hasPointOnRelatedElement() const;
    /// Point at which connected objects are aligned at the related element, given in the LCS of the related element. If the information is omitted, then the origin of the related element is used.
    IfcPointOrVertexPoint* PointOnRelatedElement() const;
    void setPointOnRelatedElement(IfcPointOrVertexPoint* v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcConnectionGeometry::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcPointOrVertexPoint; case 1: return Type::IfcPointOrVertexPoint; } return IfcConnectionGeometry::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "PointOnRelatingElement"; case 1: return "PointOnRelatedElement"; } return IfcConnectionGeometry::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcConnectionPointGeometry (IfcEntityInstanceData* e);
    IfcConnectionPointGeometry (IfcPointOrVertexPoint* v1_PointOnRelatingElement, IfcPointOrVertexPoint* v2_PointOnRelatedElement);
    typedef IfcTemplatedEntityList< IfcConnectionPointGeometry > list;
};
/// IfcConnectionSurfaceGeometry is used to describe the geometric constraints that facilitate the physical connection of two objects at a surface or at a face with surface geometry associated. It is envisioned as a control that applies to the element connection relationships. 
/// 
/// HISTORY  New entity in IFC Release 2x.
/// 
/// IFC2x Edition 3 CHANGE  The provision of topology with associated geometry, IfcFaceSurface, is enabled by using the IfcSurfaceOrFaceSurface.
/// 
/// Geometry use definitions 
/// The IfcSurface (or the IfcFaceSurface with an associated IfcSurface) at the SurfaceOnRelatingElement attribute defines the surface where the basic geometry items of the connected elements connects. The surface geometry and coordinates are provided within the local coordinate system of the RelatingElement, as specified at the IfcRelConnectsSubtype that utilizes the IfcConnectionSurfaceGeometry. Optionally, the same surface geometry and coordinates can also be provided within the local coordinate system of the RelatedElement by using the SurfaceOnRelatedElement attribute.
class IFC_PARSE_API IfcConnectionSurfaceGeometry : public IfcConnectionGeometry {
public:
    /// Surface at which related object is aligned at the relating element, given in the LCS of the relating element.
    IfcSurfaceOrFaceSurface* SurfaceOnRelatingElement() const;
    void setSurfaceOnRelatingElement(IfcSurfaceOrFaceSurface* v);
    /// Whether the optional attribute SurfaceOnRelatedElement is defined for this IfcConnectionSurfaceGeometry
    bool hasSurfaceOnRelatedElement() const;
    /// Surface at which the relating element is aligned at the related element, given in the LCS of the related element. If the information is omitted, then the origin of the related element is used.
    IfcSurfaceOrFaceSurface* SurfaceOnRelatedElement() const;
    void setSurfaceOnRelatedElement(IfcSurfaceOrFaceSurface* v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcConnectionGeometry::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcSurfaceOrFaceSurface; case 1: return Type::IfcSurfaceOrFaceSurface; } return IfcConnectionGeometry::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "SurfaceOnRelatingElement"; case 1: return "SurfaceOnRelatedElement"; } return IfcConnectionGeometry::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcConnectionSurfaceGeometry (IfcEntityInstanceData* e);
    IfcConnectionSurfaceGeometry (IfcSurfaceOrFaceSurface* v1_SurfaceOnRelatingElement, IfcSurfaceOrFaceSurface* v2_SurfaceOnRelatedElement);
    typedef IfcTemplatedEntityList< IfcConnectionSurfaceGeometry > list;
};
/// IfcConnectionVolumeGeometry is used to describe the geometric constraints that facilitate the physical connection (or overlap) of two objects at a volume defined by a solid or closed shell. It is envisioned as a control that applies to the element connection or interference relationships.
/// 
/// HISTORYÿ New entity in IFC2x4.
/// 
/// Geometry use definitions 
/// The IfcSolidModel (or the IfcClosedShell) at the VolumeOnRelatingElement attribute defines the volume where the basic geometry items of the interfering elements overlap. The volume geometry and coordinates are provided within the local coordinate system of the RelatingElement, as specified at the subtypes of the relationship IfcRelConnects that utilizes the IfcConnectionSurfaceGeometry. Optionally, the sameÿvolume geometry and coordinates can also be provided within the local coordinate system of the RelatedElement by using the VolumeOnRelatedElement attribute.
class IFC_PARSE_API IfcConnectionVolumeGeometry : public IfcConnectionGeometry {
public:
    /// Volume at which related object overlaps with the relating element, given in the LCS of the relating element.
    IfcSolidOrShell* VolumeOnRelatingElement() const;
    void setVolumeOnRelatingElement(IfcSolidOrShell* v);
    /// Whether the optional attribute VolumeOnRelatedElement is defined for this IfcConnectionVolumeGeometry
    bool hasVolumeOnRelatedElement() const;
    /// Volume at which related object overlaps with the relating element, given in the LCS of the related element.
    IfcSolidOrShell* VolumeOnRelatedElement() const;
    void setVolumeOnRelatedElement(IfcSolidOrShell* v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcConnectionGeometry::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcSolidOrShell; case 1: return Type::IfcSolidOrShell; } return IfcConnectionGeometry::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "VolumeOnRelatingElement"; case 1: return "VolumeOnRelatedElement"; } return IfcConnectionGeometry::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcConnectionVolumeGeometry (IfcEntityInstanceData* e);
    IfcConnectionVolumeGeometry (IfcSolidOrShell* v1_VolumeOnRelatingElement, IfcSolidOrShell* v2_VolumeOnRelatedElement);
    typedef IfcTemplatedEntityList< IfcConnectionVolumeGeometry > list;
};
/// An IfcConstraint is used to define a constraint or limiting value or boundary condition that may be applied to an object or to the value of a property.  
/// 
/// HISTORY: New Entity in IFC Release 2.0
/// 
/// Use Definition 
/// IfcConstraint may be associated with any subtype of IfcRoot (unless restricted in specific subtypes) through the IfcRelAssociatesConstraint relationship in the IfcControlExtension schema, or may be associated with IfcProperty by IfcPropertyConstraintRelationship. 
/// 
/// A constraint may aggregate other constraints through the IfcConstraintAggregationRelationship through which a logical association between constraints may be applied, or constraints may have other defined relationship to other constraints via IfcConstraintRelationship. 
/// 
/// A constraint must have a name applied through the IfcConstraint.Name attribute and optionally, a description through IfcConstraint.Description. The grade of the constraint (hard, soft, advisory) must be specified through IfcConstraint.ConstraintGrade or IfcConstraint.UserDefinedGrade whilst the source, creating actor and time at which the constraint is created may be optionally asserted through IfcConstraint.ConstraintSource, IfcConstraint.CreatingActor and IfcConstraint.CreationTime. 
/// 
/// A constraint may also have additional external information (such as classification or document information) associated to it by IfcExternalReferenceRelationship, accessible through inverse attribute IfcConstraint.HasExternalReferences
class IFC_PARSE_API IfcConstraint : public IfcUtil::IfcBaseEntity {
public:
    /// A name to be used for the constraint (e.g., ChillerCoefficientOfPerformance).
    std::string Name() const;
    void setName(std::string v);
    /// Whether the optional attribute Description is defined for this IfcConstraint
    bool hasDescription() const;
    /// A description that may apply additional information about a constraint.
    std::string Description() const;
    void setDescription(std::string v);
    /// Enumeration that qualifies the type of constraint.
    IfcConstraintEnum::IfcConstraintEnum ConstraintGrade() const;
    void setConstraintGrade(IfcConstraintEnum::IfcConstraintEnum v);
    /// Whether the optional attribute ConstraintSource is defined for this IfcConstraint
    bool hasConstraintSource() const;
    /// Any source material, such as a code or standard, from which the constraint originated.
    std::string ConstraintSource() const;
    void setConstraintSource(std::string v);
    /// Whether the optional attribute CreatingActor is defined for this IfcConstraint
    bool hasCreatingActor() const;
    /// Person and/or organization that has created the constraint.
    IfcActorSelect* CreatingActor() const;
    void setCreatingActor(IfcActorSelect* v);
    /// Whether the optional attribute CreationTime is defined for this IfcConstraint
    bool hasCreationTime() const;
    /// Time when information specifying the constraint instance was created.
    /// 
    /// Note IFC2x4 CHANGE: Attribute data type changed to IfcDateTime using ISO 8601 representation
    std::string CreationTime() const;
    void setCreationTime(std::string v);
    /// Whether the optional attribute UserDefinedGrade is defined for this IfcConstraint
    bool hasUserDefinedGrade() const;
    /// Allows for specification of user defined grade of the constraint  beyond the enumeration values (hard, soft, advisory) provided by ConstraintGrade attribute of type IfcConstraintEnum. 
    /// When a value is provided for attribute UserDefinedGrade in parallel the attribute ConstraintGrade shall have enumeration value USERDEFINED.
    std::string UserDefinedGrade() const;
    void setUserDefinedGrade(std::string v);
    virtual unsigned int getArgumentCount() const { return 7; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_STRING; case 1: return IfcUtil::Argument_STRING; case 2: return IfcUtil::Argument_ENUMERATION; case 3: return IfcUtil::Argument_STRING; case 4: return IfcUtil::Argument_ENTITY_INSTANCE; case 5: return IfcUtil::Argument_STRING; case 6: return IfcUtil::Argument_STRING; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcLabel; case 1: return Type::IfcText; case 2: return Type::IfcConstraintEnum; case 3: return Type::IfcLabel; case 4: return Type::IfcActorSelect; case 5: return Type::IfcDateTime; case 6: return Type::IfcLabel; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Name"; case 1: return "Description"; case 2: return "ConstraintGrade"; case 3: return "ConstraintSource"; case 4: return "CreatingActor"; case 5: return "CreationTime"; case 6: return "UserDefinedGrade"; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcExternalReferenceRelationship >::ptr HasExternalReferences() const; // INVERSE IfcExternalReferenceRelationship::RelatedResourceObjects
    IfcTemplatedEntityList< IfcResourceConstraintRelationship >::ptr PropertiesForConstraint() const; // INVERSE IfcResourceConstraintRelationship::RelatingConstraint
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcConstraint (IfcEntityInstanceData* e);
    IfcConstraint (std::string v1_Name, boost::optional< std::string > v2_Description, IfcConstraintEnum::IfcConstraintEnum v3_ConstraintGrade, boost::optional< std::string > v4_ConstraintSource, IfcActorSelect* v5_CreatingActor, boost::optional< std::string > v6_CreationTime, boost::optional< std::string > v7_UserDefinedGrade);
    typedef IfcTemplatedEntityList< IfcConstraint > list;
};
/// Definition from OpenGIS® Abstract Specification,
///   Topic 2: If the relationship between any two coordinate
///   reference systems is known, coordinates can be transformed
///   or converted to another coordinate reference system.
///   Coordinate operations are divided into two subtypes:
/// 
/// Coordinate conversion – mathematical
///   operation on coordinates that does not include any change
///   of datum. The best-known example of a coordinate
///   conversion is a map projection. The parameters describing
///   coordinate conversions are defined rather than
///   empirically derived. Note that some conversions have no
///   parameters.
/// 
/// Coordinate transformation – mathematical
///   operation on coordinates that usually includes a change
///   of datum. The parameters of a coordinate transformation
///   are empirically derived from data containing the
///   coordinates of a series of points in both coordinate
///   reference systems. This computational process is usually
///   ‘over-determined’, allowing derivation of
///   error (or accuracy) estimates for the transformation.
///   Also, the stochastic nature of the parameters may result
///   in multiple (different) versions of the same coordinate
///   transformation. Because of this several transformations
///   may exist for a given pair of coordinate reference
///   systems, differing in their transformation method,
///   parameter values and accuracy characteristics.
/// 
/// The coordinate operation is an
///   abstract supertype to handle any operation (transformation
///   or conversion) between two coordinate reference systems. It
///   is meant to provide expandability for future versions,
///   since currently only the conversion of a local engineering
///   coordinate system into a map coordinate reference system is
///   dealt with by the subtype IfcMapConversion.
/// 
/// By convention, a coordinate operation is given between the
///   SourceCRS being the more local, or child coordinate
///   reference system, and the TargetCRS being the more
///   remote or parent coordinate reference system, in
///   theÿspecial case the coordinate operation between the local
///   engineering coordinate system of the construction project
///   and any map or other coordinate reference system.
/// 
/// HISTORY  New entity in IFC2x4.
class IFC_PARSE_API IfcCoordinateOperation : public IfcUtil::IfcBaseEntity {
public:
    /// Source coordinate reference system for the operation.
    IfcCoordinateReferenceSystemSelect* SourceCRS() const;
    void setSourceCRS(IfcCoordinateReferenceSystemSelect* v);
    /// Target coordinate reference system for the operation.
    IfcCoordinateReferenceSystem* TargetCRS() const;
    void setTargetCRS(IfcCoordinateReferenceSystem* v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_ENTITY_INSTANCE; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcCoordinateReferenceSystemSelect; case 1: return Type::IfcCoordinateReferenceSystem; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "SourceCRS"; case 1: return "TargetCRS"; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCoordinateOperation (IfcEntityInstanceData* e);
    IfcCoordinateOperation (IfcCoordinateReferenceSystemSelect* v1_SourceCRS, IfcCoordinateReferenceSystem* v2_TargetCRS);
    typedef IfcTemplatedEntityList< IfcCoordinateOperation > list;
};
/// Definition from OpenGIS® Abstract Specification, Topic
/// 2: A coordinate reference system is a coordinate system which
/// is related to the real world by a datum. The coordinate system is
/// composed of a set of coordinate axes with specified units of
/// measure. The datum specifies the relationship of a coordinate
/// system to the earth. The resulting combination of coordinate
/// system and datum is a coordinate reference system.
/// 
/// IfcCoordinateReferenceSystem is a definition of a coordinate
/// reference system by means of qualified identifiers only. The
/// interpretation of the identifier is expected to be well-known to
/// the receiving software.
/// 
/// NOTE  One widely-used, publicly-available
/// authority is the European Petroleum Survey Group (EPSG), and use
/// of this authority is currently specified in several OGC
/// Implementation Specifications. Software used to transport IFC
/// engineering models into GIS applications (and vice versa) is
/// expected to have knowledge about the OGC Implementation
/// Specifications.
/// 
/// HISTORY  New entity in IFC2x4.
class IFC_PARSE_API IfcCoordinateReferenceSystem : public IfcUtil::IfcBaseEntity {
public:
    /// Name by which the coordinate reference system is identified.
    /// Note  The name shall be taken from the list recognized by the European Petroleum Survey Group EPSG.
    std::string Name() const;
    void setName(std::string v);
    /// Whether the optional attribute Description is defined for this IfcCoordinateReferenceSystem
    bool hasDescription() const;
    /// Informal description of this coordinate reference system.
    std::string Description() const;
    void setDescription(std::string v);
    /// Whether the optional attribute GeodeticDatum is defined for this IfcCoordinateReferenceSystem
    bool hasGeodeticDatum() const;
    /// Name by which this datum is identified. The geodetic datum is associated with the coordinate reference system and indicates the shape and size of the rotation ellipsoid and this ellipsoid's connection and orientation to the actual globe/earth. Examples for geodetic datums include:
    /// 
    /// ED50
    ///   EUREF89
    ///   WSG84
    std::string GeodeticDatum() const;
    void setGeodeticDatum(std::string v);
    /// Whether the optional attribute VerticalDatum is defined for this IfcCoordinateReferenceSystem
    bool hasVerticalDatum() const;
    /// Name by which the vertical datum is identified. The vertical datum is associated with the height axis of the coordinate reference system and indicates the reference plane and fundamental point defining the origin of a height system. Examples for vertical datums include:
    /// 
    /// height above mean sea level at Dover in 1952
    ///   other sea levels
    std::string VerticalDatum() const;
    void setVerticalDatum(std::string v);
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_STRING; case 1: return IfcUtil::Argument_STRING; case 2: return IfcUtil::Argument_STRING; case 3: return IfcUtil::Argument_STRING; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcLabel; case 1: return Type::IfcText; case 2: return Type::IfcIdentifier; case 3: return Type::IfcIdentifier; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Name"; case 1: return "Description"; case 2: return "GeodeticDatum"; case 3: return "VerticalDatum"; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcCoordinateOperation >::ptr HasCoordinateOperation() const; // INVERSE IfcCoordinateOperation::SourceCRS
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCoordinateReferenceSystem (IfcEntityInstanceData* e);
    IfcCoordinateReferenceSystem (std::string v1_Name, boost::optional< std::string > v2_Description, boost::optional< std::string > v3_GeodeticDatum, boost::optional< std::string > v4_VerticalDatum);
    typedef IfcTemplatedEntityList< IfcCoordinateReferenceSystem > list;
};
/// IfcCostValue is an amount of money or a value that affects an amount of money. 
/// 
/// HISTORY: New Entity in IFC Release 1.0
/// 
/// Use definitions 
/// Each instance of IfcCostValue may also have a CostType. There are many possible types of cost value that may be identified. While there is a broad understanding of the meaning of names that may be assigned to different types of costs, there is no general standard for naming cost types nor are there any broadly defined classifications. To allow for any type of cost value, the IfcLabel datatype is assigned.
/// 
/// The following defines some cost types that might be applied:  
/// 
/// Annual rate of return
/// Bonus
/// Bulk purchase rebate
/// Contract
/// Consultancy
/// Delivery
/// Estimated cost
/// Hire
/// Installation
/// Interest rate
/// Labor
/// Lease
/// List price
/// Maintenance
/// Material
/// Overhead
/// Postage and packing
/// Profit
/// Purchase 
/// Rental
/// Repair
/// Replacement
/// Sale
/// Small quantity surcharge
/// Spares
/// Storage
/// Sub-Contract
/// Trade discount
/// Transportation
/// Waste allowance
/// Whole life
/// 
/// In the absence of any well-defined standard, it is recommended that local agreements should be made to define allowable and understandable cost value types within a project or region.
class IFC_PARSE_API IfcCostValue : public IfcAppliedValue {
public:
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcAppliedValue::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcAppliedValue::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcAppliedValue::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCostValue (IfcEntityInstanceData* e);
    IfcCostValue (boost::optional< std::string > v1_Name, boost::optional< std::string > v2_Description, IfcAppliedValueSelect* v3_AppliedValue, IfcMeasureWithUnit* v4_UnitBasis, boost::optional< std::string > v5_ApplicableDate, boost::optional< std::string > v6_FixedUntilDate, boost::optional< std::string > v7_Category, boost::optional< std::string > v8_Condition, boost::optional< IfcArithmeticOperatorEnum::IfcArithmeticOperatorEnum > v9_ArithmeticOperator, boost::optional< IfcTemplatedEntityList< IfcAppliedValue >::ptr > v10_Components);
    typedef IfcTemplatedEntityList< IfcCostValue > list;
};
/// Definition from ISO/CD 10303-41:1992: A derived unit is an expression of units.
/// 
/// EXAMPLE: Newton per square millimetre is a derived unit.
/// 
/// NOTE: Corresponding ISO 10303 name: derived_unit, please refer to ISO/IS 10303-41 for the final definition of the formal standard.
/// 
/// HISTORY: New entity in IFC Release 1.5.1.
class IFC_PARSE_API IfcDerivedUnit : public IfcUtil::IfcBaseEntity {
public:
    /// The group of units and their exponents that define the derived unit.
    IfcTemplatedEntityList< IfcDerivedUnitElement >::ptr Elements() const;
    void setElements(IfcTemplatedEntityList< IfcDerivedUnitElement >::ptr v);
    /// Name of the derived unit chosen from an enumeration of derived unit types for use in IFC models.
    IfcDerivedUnitEnum::IfcDerivedUnitEnum UnitType() const;
    void setUnitType(IfcDerivedUnitEnum::IfcDerivedUnitEnum v);
    /// Whether the optional attribute UserDefinedType is defined for this IfcDerivedUnit
    bool hasUserDefinedType() const;
    std::string UserDefinedType() const;
    void setUserDefinedType(std::string v);
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_ENUMERATION; case 2: return IfcUtil::Argument_STRING; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcDerivedUnitElement; case 1: return Type::IfcDerivedUnitEnum; case 2: return Type::IfcLabel; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Elements"; case 1: return "UnitType"; case 2: return "UserDefinedType"; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcDerivedUnit (IfcEntityInstanceData* e);
    IfcDerivedUnit (IfcTemplatedEntityList< IfcDerivedUnitElement >::ptr v1_Elements, IfcDerivedUnitEnum::IfcDerivedUnitEnum v2_UnitType, boost::optional< std::string > v3_UserDefinedType);
    typedef IfcTemplatedEntityList< IfcDerivedUnit > list;
};
/// Definition from ISO/CD 10303-41:1992: A derived unit element is one of the unit quantities 
/// which makes up a derived unit.
/// 
/// EXAMPLE: Newtons per square millimetre is a derived unit. 
/// It has two elements, Newton whose exponent has a value of 1 and millimetre whose exponent is -2.
/// 
/// NOTE: Corresponding ISO 10303 name: derived_unit_element, please refer to ISO/IS 10303-41 for the final definition of the formal standard.
/// 
/// HISTORY New entity in IFC Release 1.5.1.
class IFC_PARSE_API IfcDerivedUnitElement : public IfcUtil::IfcBaseEntity {
public:
    /// The fixed quantity which is used as the mathematical factor.
    IfcNamedUnit* Unit() const;
    void setUnit(IfcNamedUnit* v);
    /// The power that is applied to the unit attribute.
    int Exponent() const;
    void setExponent(int v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_INT; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcNamedUnit; case 1: return Type::UNDEFINED; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Unit"; case 1: return "Exponent"; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcDerivedUnitElement (IfcEntityInstanceData* e);
    IfcDerivedUnitElement (IfcNamedUnit* v1_Unit, int v2_Exponent);
    typedef IfcTemplatedEntityList< IfcDerivedUnitElement > list;
};
/// Definition from ISO/CD 10303-41:1992: The dimensionality of any quantity can be expressed as a product of powers of the dimensions of base quantities. 
/// The dimensional exponents entity defines the powers of the dimensions of the base quantities. All the physical 
/// quantities are founded on seven base quantities (ISO 31 (clause 2)).
/// 
/// NOTE: Length, mass, time, electric current, thermodynamic temperature, amount of substance, 
/// and luminous intensity are the seven base quantities.
/// 
/// EXAMPLE: A length of 2 millimetres has a length exponent of 1. The remaining exponents 
/// are equal to 0.
/// 
/// EXAMPLE: A velocity of 2 millimetres per second has a length exponent of 1 and 
/// a time exponent of -1. The remaining exponents are equal to 0.
/// 
/// NOTE Corresponding STEP name: dimensional_exponents, please refer to ISO/IS 10303-41
///   for the final definition of the formal standard.
/// 
/// HISTORY New entity in IFC Release 1.5.1.
class IFC_PARSE_API IfcDimensionalExponents : public IfcUtil::IfcBaseEntity {
public:
    /// The power of the length base quantity.
    int LengthExponent() const;
    void setLengthExponent(int v);
    /// The power of the mass base quantity.
    int MassExponent() const;
    void setMassExponent(int v);
    /// The power of the time base quantity.
    int TimeExponent() const;
    void setTimeExponent(int v);
    /// The power of the electric current base quantity.
    int ElectricCurrentExponent() const;
    void setElectricCurrentExponent(int v);
    /// The power of the thermodynamic temperature base quantity.
    int ThermodynamicTemperatureExponent() const;
    void setThermodynamicTemperatureExponent(int v);
    /// The power of the amount of substance base quantity.
    int AmountOfSubstanceExponent() const;
    void setAmountOfSubstanceExponent(int v);
    /// The power of the luminous intensity base quantity.
    int LuminousIntensityExponent() const;
    void setLuminousIntensityExponent(int v);
    virtual unsigned int getArgumentCount() const { return 7; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_INT; case 1: return IfcUtil::Argument_INT; case 2: return IfcUtil::Argument_INT; case 3: return IfcUtil::Argument_INT; case 4: return IfcUtil::Argument_INT; case 5: return IfcUtil::Argument_INT; case 6: return IfcUtil::Argument_INT; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::UNDEFINED; case 1: return Type::UNDEFINED; case 2: return Type::UNDEFINED; case 3: return Type::UNDEFINED; case 4: return Type::UNDEFINED; case 5: return Type::UNDEFINED; case 6: return Type::UNDEFINED; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "LengthExponent"; case 1: return "MassExponent"; case 2: return "TimeExponent"; case 3: return "ElectricCurrentExponent"; case 4: return "ThermodynamicTemperatureExponent"; case 5: return "AmountOfSubstanceExponent"; case 6: return "LuminousIntensityExponent"; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcDimensionalExponents (IfcEntityInstanceData* e);
    IfcDimensionalExponents (int v1_LengthExponent, int v2_MassExponent, int v3_TimeExponent, int v4_ElectricCurrentExponent, int v5_ThermodynamicTemperatureExponent, int v6_AmountOfSubstanceExponent, int v7_LuminousIntensityExponent);
    typedef IfcTemplatedEntityList< IfcDimensionalExponents > list;
};
/// An IfcExternalInformation is the identification of an information source that is not explicitly represented in the current model or in the project database (as an implementation of the current model). The IfcExternalInformation identifies the external source (classification, document, or library), but not the particular items such as a dictionary entry, a classification notation, or a document reference within the external source
/// 
/// The IfcExternalInformation is an abstract supertype of
/// all external information entities.
/// 
/// HISTORY New entity in IFC2x4.
class IFC_PARSE_API IfcExternalInformation : public IfcUtil::IfcBaseEntity {
public:
    virtual unsigned int getArgumentCount() const { return 0; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcExternalInformation (IfcEntityInstanceData* e);
    IfcExternalInformation ();
    typedef IfcTemplatedEntityList< IfcExternalInformation > list;
};
/// An IfcExternalReference is the identification of information that is not explicitly represented in the current model or in the project database (as an implementation of the current model). Such information may be contained in classifications, documents or libraries. The IfcExternalReference identifies a particular item, such as a
/// dictionary entry, a classification notation, or a document reference within the external source.
/// 
/// Only the Location (as a URL) is given to describe the place where the information can be found. Also an optional
/// Identification as a key to allow more specific references (as to sections or tables) is provided. The Identification defines a system interpretable method to identify the relevant part of information at the source. In addition a human interpretable Name can be assigned to identify the information subject, such as a classification code.
/// 
/// IfcExternalReference is an abstract supertype of all external reference entities.
/// 
/// HISTORY New entity in IFC2x.
class IFC_PARSE_API IfcExternalReference : public IfcUtil::IfcBaseEntity {
public:
    /// Whether the optional attribute Location is defined for this IfcExternalReference
    bool hasLocation() const;
    /// Location, where the external source (classification, document or library) can be accessed by electronic means. The electronic location is provided as an URI, and would normally be given as an URL location string.
    /// 
    /// IFC2x4 CHANGE  The data type has been changed from IfcLabel to IfcURIReference.
    std::string Location() const;
    void setLocation(std::string v);
    /// Whether the optional attribute Identification is defined for this IfcExternalReference
    bool hasIdentification() const;
    /// The Identification provides a unique identifier of the referenced item within the external source (classification, document or library). It may be provided as 
    /// 
    /// a key, e.g. a classification notation, like NF2.3
    ///   a handle
    ///   a uuid or guid
    /// 
    /// It may be human readable (such as a key) or not (such as a handle or uuid) depending on the context of its usage (which has to be determined by local agreement).
    /// 
    /// IFC2x4 CHANGE  Attribute renamed from ItemReference for consistency.
    std::string Identification() const;
    void setIdentification(std::string v);
    /// Whether the optional attribute Name is defined for this IfcExternalReference
    bool hasName() const;
    /// Optional name to further specify the reference. It can provide a human readable identifier (which does not necessarily need to have a counterpart in the internal structure of the document).
    std::string Name() const;
    void setName(std::string v);
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_STRING; case 1: return IfcUtil::Argument_STRING; case 2: return IfcUtil::Argument_STRING; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcURIReference; case 1: return Type::IfcIdentifier; case 2: return Type::IfcLabel; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Location"; case 1: return "Identification"; case 2: return "Name"; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcExternalReferenceRelationship >::ptr ExternalReferenceForResources() const; // INVERSE IfcExternalReferenceRelationship::RelatingReference
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcExternalReference (IfcEntityInstanceData* e);
    IfcExternalReference (boost::optional< std::string > v1_Location, boost::optional< std::string > v2_Identification, boost::optional< std::string > v3_Name);
    typedef IfcTemplatedEntityList< IfcExternalReference > list;
};
/// Definition from ISO/CD 10303-46:1992: The externally defined hatch style is an entity which makes an external reference to a hatching style.
/// 
/// NOTE: The allowable values for the name source and item reference, by which the externally defined hatch style is identified, need to be determined by implementer agreements.
/// 
/// NOTE: Corresponding ISO 10303 name: fill_style_select. Please refer to ISO/IS 10303-46:1994 for
/// the final definition of the formal standard.
/// 
/// HISTORY: New entity in IFC2x2.
class IFC_PARSE_API IfcExternallyDefinedHatchStyle : public IfcExternalReference {
public:
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcExternalReference::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcExternalReference::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcExternalReference::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcExternallyDefinedHatchStyle (IfcEntityInstanceData* e);
    IfcExternallyDefinedHatchStyle (boost::optional< std::string > v1_Location, boost::optional< std::string > v2_Identification, boost::optional< std::string > v3_Name);
    typedef IfcTemplatedEntityList< IfcExternallyDefinedHatchStyle > list;
};
/// IfcExternallyDefinedSurfaceStyle is a definition of a surface style through referencing an external source, such as a material library for rendering information.
/// 
/// NOTE  In order to achieve expected results, the externally defined surface style should normally only be given in addition to an explicitly defined surface styles.
/// 
/// HISTORY  New entity in IFC2x2.
/// 
/// IFC2x3 CHANGE  The spelling has been corrected from IfcExternallyDefinedSufaceStyle with no upward compatibility.
class IFC_PARSE_API IfcExternallyDefinedSurfaceStyle : public IfcExternalReference {
public:
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcExternalReference::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcExternalReference::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcExternalReference::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcExternallyDefinedSurfaceStyle (IfcEntityInstanceData* e);
    IfcExternallyDefinedSurfaceStyle (boost::optional< std::string > v1_Location, boost::optional< std::string > v2_Identification, boost::optional< std::string > v3_Name);
    typedef IfcTemplatedEntityList< IfcExternallyDefinedSurfaceStyle > list;
};
/// Definition from ISO/CD 10303-46:1992: The externally defined text font is an external reference to a text font 
/// 
/// NOTE  Restrictions of the font source and font names to be used may be exposed by implementation guidelines.
/// 
/// NOTE  Corresponding ISO 10303 name: externally_defined_text_font. Please refer to ISO/IS 10303-46:1994, p. 137 for the final definition of the formal standard.
/// 
/// HISTORY  New entity in IFC2x2.
class IFC_PARSE_API IfcExternallyDefinedTextFont : public IfcExternalReference {
public:
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcExternalReference::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcExternalReference::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcExternalReference::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcExternallyDefinedTextFont (IfcEntityInstanceData* e);
    IfcExternallyDefinedTextFont (boost::optional< std::string > v1_Location, boost::optional< std::string > v2_Identification, boost::optional< std::string > v3_Name);
    typedef IfcTemplatedEntityList< IfcExternallyDefinedTextFont > list;
};
/// An individual axis, IfcGridAxis, is defined in the context of a design grid.  The axis definition is based on a curve of dimensionality 2. The grid axis is positioned within the XY plane of the position coordinate system defined by the IfcDesignGrid.
/// 
/// HISTORY  New entity in IFC Release 1.0
/// 
/// Geometry use definitions
/// The standard geometric representation of IfcGridAxis is
/// defined using a 2D curve entity. Grid axes are normally defined
/// by an offset to another axis. The IfcOffsetCurve2D
/// supports this concept.
/// Each grid axis has a sense given by the parameterization of
/// the curve. The attribute SameSense is an indicator of
/// whether or not the sense of the grid axis agrees with, or
/// opposes, that of the underlying curve.
/// As shown in Figure 242, the grid axis is defined as a 2D curve within
/// the xy plane of the position coordinate system. Any curve can be
/// used to define a grid axis, most common is the use of IfcLine for
/// linear grids and IfcCircle for radial grids.
/// Most grids are defined by a pair of axis
/// lists, each defined by a base grid axis and axes given by an
/// offset to the base axis. The use of IfcOffsetCurve2D as
/// underlying AxisCurve supports this concept.
/// 
/// Figure 242 — Grid axis
class IFC_PARSE_API IfcGridAxis : public IfcUtil::IfcBaseEntity {
public:
    /// Whether the optional attribute AxisTag is defined for this IfcGridAxis
    bool hasAxisTag() const;
    /// The tag or name for this grid axis.
    std::string AxisTag() const;
    void setAxisTag(std::string v);
    /// Underlying curve which provides the geometry for this grid axis.
    IfcCurve* AxisCurve() const;
    void setAxisCurve(IfcCurve* v);
    /// Defines whether the original sense of curve is used or whether it is reversed in the context of the grid axis.
    bool SameSense() const;
    void setSameSense(bool v);
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_STRING; case 1: return IfcUtil::Argument_ENTITY_INSTANCE; case 2: return IfcUtil::Argument_BOOL; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcLabel; case 1: return Type::IfcCurve; case 2: return Type::IfcBoolean; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "AxisTag"; case 1: return "AxisCurve"; case 2: return "SameSense"; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcGrid >::ptr PartOfW() const; // INVERSE IfcGrid::WAxes
    IfcTemplatedEntityList< IfcGrid >::ptr PartOfV() const; // INVERSE IfcGrid::VAxes
    IfcTemplatedEntityList< IfcGrid >::ptr PartOfU() const; // INVERSE IfcGrid::UAxes
    IfcTemplatedEntityList< IfcVirtualGridIntersection >::ptr HasIntersections() const; // INVERSE IfcVirtualGridIntersection::IntersectingAxes
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcGridAxis (IfcEntityInstanceData* e);
    IfcGridAxis (boost::optional< std::string > v1_AxisTag, IfcCurve* v2_AxisCurve, bool v3_SameSense);
    typedef IfcTemplatedEntityList< IfcGridAxis > list;
};
/// The IfcIrregularTimeSeriesValue describes a value (or set of values) at a particular time point. 
/// 
/// HISTORY: New entity in IFC 2x2.
class IFC_PARSE_API IfcIrregularTimeSeriesValue : public IfcUtil::IfcBaseEntity {
public:
    /// The specification of the time point.
    std::string TimeStamp() const;
    void setTimeStamp(std::string v);
    /// A list of time-series values. At least one value is required.
    IfcEntityList::ptr ListValues() const;
    void setListValues(IfcEntityList::ptr v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_STRING; case 1: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcDateTime; case 1: return Type::IfcValue; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "TimeStamp"; case 1: return "ListValues"; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcIrregularTimeSeriesValue (IfcEntityInstanceData* e);
    IfcIrregularTimeSeriesValue (std::string v1_TimeStamp, IfcEntityList::ptr v2_ListValues);
    typedef IfcTemplatedEntityList< IfcIrregularTimeSeriesValue > list;
};
/// An IfcLibraryInformation describes a library where a library is a structured store of information, normally organized in a manner which allows information lookup through an index or reference value. IfcLibraryInformation provides the library Name and optional Version, VersionDate and Publisher attributes. A Location may be added for electronic access to the library.
/// 
/// NOTE  The complete definition of the information in an external library is out of scope in this IFC release.
/// 
/// HISTORY  New
/// Entity in IFC2x.
/// 
/// IFC2x4 CHANGE  Location attribute added, HasLibraryReferences inverse attribute added (previous LibraryReference changed to inverse).
class IFC_PARSE_API IfcLibraryInformation : public IfcExternalInformation {
public:
    /// The name which is used to identify the library.
    std::string Name() const;
    void setName(std::string v);
    /// Whether the optional attribute Version is defined for this IfcLibraryInformation
    bool hasVersion() const;
    /// Identifier for the library version used for reference.
    std::string Version() const;
    void setVersion(std::string v);
    /// Whether the optional attribute Publisher is defined for this IfcLibraryInformation
    bool hasPublisher() const;
    /// Information of the organization that acts as the library publisher.
    IfcActorSelect* Publisher() const;
    void setPublisher(IfcActorSelect* v);
    /// Whether the optional attribute VersionDate is defined for this IfcLibraryInformation
    bool hasVersionDate() const;
    /// Date of the referenced version of the library.
    /// 
    /// IFC2x4 CHANGE  The data type has been changed to IfcDate, the date string according to ISO8601.
    std::string VersionDate() const;
    void setVersionDate(std::string v);
    /// Whether the optional attribute Location is defined for this IfcLibraryInformation
    bool hasLocation() const;
    /// Resource identifier or locator, provided as URI, URN or URL, of the library information for online references.
    /// 
    /// IFC2x4 CHANGE  New attribute added at the end of the attribute list.
    std::string Location() const;
    void setLocation(std::string v);
    /// Whether the optional attribute Description is defined for this IfcLibraryInformation
    bool hasDescription() const;
    std::string Description() const;
    void setDescription(std::string v);
    virtual unsigned int getArgumentCount() const { return 6; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_STRING; case 1: return IfcUtil::Argument_STRING; case 2: return IfcUtil::Argument_ENTITY_INSTANCE; case 3: return IfcUtil::Argument_STRING; case 4: return IfcUtil::Argument_STRING; case 5: return IfcUtil::Argument_STRING; } return IfcExternalInformation::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcLabel; case 1: return Type::IfcLabel; case 2: return Type::IfcActorSelect; case 3: return Type::IfcDateTime; case 4: return Type::IfcURIReference; case 5: return Type::IfcText; } return IfcExternalInformation::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Name"; case 1: return "Version"; case 2: return "Publisher"; case 3: return "VersionDate"; case 4: return "Location"; case 5: return "Description"; } return IfcExternalInformation::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcRelAssociatesLibrary >::ptr LibraryInfoForObjects() const; // INVERSE IfcRelAssociatesLibrary::RelatingLibrary
    IfcTemplatedEntityList< IfcLibraryReference >::ptr HasLibraryReferences() const; // INVERSE IfcLibraryReference::ReferencedLibrary
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcLibraryInformation (IfcEntityInstanceData* e);
    IfcLibraryInformation (std::string v1_Name, boost::optional< std::string > v2_Version, IfcActorSelect* v3_Publisher, boost::optional< std::string > v4_VersionDate, boost::optional< std::string > v5_Location, boost::optional< std::string > v6_Description);
    typedef IfcTemplatedEntityList< IfcLibraryInformation > list;
};
/// An IfcLibraryReference is a reference into a library of information by Location (provided as a URI). It also provides an optional inherited Identification key to allow more specific references to library sections or tables. The inherited Name attribute allows for a human interpretable identification of the library item. Also, general information on the library from which the reference is taken, is given by the ReferencedLibrary relation which identifies the relevant occurrence of IfcLibraryInformation.
/// 
/// The ifcLibraryReference additionally provides the capability to handle multilingual library entries. The Language attribute then holds the language tag for the language used by the strings kept in the Name and the Description attribute.
/// 
/// HISTORY  New Entity in IFC2.0.
/// 
/// IFC2x4 CHANGE  Description and Language attribute added; ReferencedLibrary attribute added (reversing previous ReferenceIntoLibrary inverse relationship).
class IFC_PARSE_API IfcLibraryReference : public IfcExternalReference {
public:
    /// Whether the optional attribute Description is defined for this IfcLibraryReference
    bool hasDescription() const;
    /// Additional description provided for the library reference.
    /// 
    /// IFC2x4 CHANGE  New attribute added at the end of the attribute list.
    std::string Description() const;
    void setDescription(std::string v);
    /// Whether the optional attribute Language is defined for this IfcLibraryReference
    bool hasLanguage() const;
    /// The language in which a library reference is expressed.
    /// 
    /// IFC2x4 CHANGE  New attribute added at the end of the attribute list.
    std::string Language() const;
    void setLanguage(std::string v);
    /// Whether the optional attribute ReferencedLibrary is defined for this IfcLibraryReference
    bool hasReferencedLibrary() const;
    /// The library information that is being referenced.
    IfcLibraryInformation* ReferencedLibrary() const;
    void setReferencedLibrary(IfcLibraryInformation* v);
    virtual unsigned int getArgumentCount() const { return 6; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 3: return IfcUtil::Argument_STRING; case 4: return IfcUtil::Argument_STRING; case 5: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcExternalReference::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 3: return Type::IfcText; case 4: return Type::IfcLanguageId; case 5: return Type::IfcLibraryInformation; } return IfcExternalReference::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 3: return "Description"; case 4: return "Language"; case 5: return "ReferencedLibrary"; } return IfcExternalReference::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcRelAssociatesLibrary >::ptr LibraryRefForObjects() const; // INVERSE IfcRelAssociatesLibrary::RelatingLibrary
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcLibraryReference (IfcEntityInstanceData* e);
    IfcLibraryReference (boost::optional< std::string > v1_Location, boost::optional< std::string > v2_Identification, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_Language, IfcLibraryInformation* v6_ReferencedLibrary);
    typedef IfcTemplatedEntityList< IfcLibraryReference > list;
};
/// IfcLightDistributionData defines the luminous intensity of a light source given at a particular main plane angle. It is based on some standardized light distribution curves; the MainPlaneAngle is either the 
/// 
/// A angle; if the IfcLightDistributionCurveEnum is set to TYPE_A 
/// B angle; if the IfcLightDistributionCurveEnum is set to TYPE_B 
/// C angle; if the IfcLightDistributionCurveEnum is set to TYPE_C 
/// 
/// For each MainPlaneAngle (considered as being the row of a table) a list of SecondaryPlaneAngle's are given (considered to be the columns of a table). They are either the: 
/// 
/// &#945; angle; if the IfcLightDistributionCurveEnum is set to TYPE_A 
/// &#946; angle; if the IfcLightDistributionCurveEnum is set to TYPE_B 
/// &#947; angle; if the IfcLightDistributionCurveEnum is set to TYPE_C 
/// 
/// For each pair of MainPlaneAngle and SecondaryPlaneAngle the LuminousIntensity is provided (the unit is given by the IfcUnitAssignment referring to the LuminousIntensityDistributionUnit, normally cd/klm). 
/// 
/// HISTORY: New entity in IFC2x2.
class IFC_PARSE_API IfcLightDistributionData : public IfcUtil::IfcBaseEntity {
public:
    /// The main plane angle (A, B or C angles, according to the light distribution curve chosen).
    double MainPlaneAngle() const;
    void setMainPlaneAngle(double v);
    /// The list of secondary plane angles (the &#945;, &#946; or &#947; angles) according to the light distribution curve chosen.
    /// 
    /// NOTE: The SecondaryPlaneAngle and LuminousIntensity lists are corresponding lists.
    std::vector< double > /*[1:?]*/ SecondaryPlaneAngle() const;
    void setSecondaryPlaneAngle(std::vector< double > /*[1:?]*/ v);
    /// The luminous intensity distribution measure for this pair of main and secondary plane angles according to the light distribution curve chosen.
    std::vector< double > /*[1:?]*/ LuminousIntensity() const;
    void setLuminousIntensity(std::vector< double > /*[1:?]*/ v);
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_DOUBLE; case 1: return IfcUtil::Argument_AGGREGATE_OF_DOUBLE; case 2: return IfcUtil::Argument_AGGREGATE_OF_DOUBLE; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcPlaneAngleMeasure; case 1: return Type::IfcPlaneAngleMeasure; case 2: return Type::IfcLuminousIntensityDistributionMeasure; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "MainPlaneAngle"; case 1: return "SecondaryPlaneAngle"; case 2: return "LuminousIntensity"; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcLightDistributionData (IfcEntityInstanceData* e);
    IfcLightDistributionData (double v1_MainPlaneAngle, std::vector< double > /*[1:?]*/ v2_SecondaryPlaneAngle, std::vector< double > /*[1:?]*/ v3_LuminousIntensity);
    typedef IfcTemplatedEntityList< IfcLightDistributionData > list;
};
/// IfcLightIntensityDistribution defines the the luminous intensity of a light source that changes according to the direction of the ray. It is based on some standardized light distribution curves, which are defined by the LightDistributionCurve attribute. 
/// 
/// New entity in IFC2x2.
class IFC_PARSE_API IfcLightIntensityDistribution : public IfcUtil::IfcBaseEntity {
public:
    /// Standardized  light distribution curve used to define the luminous intensity of the light in all directions.
    IfcLightDistributionCurveEnum::IfcLightDistributionCurveEnum LightDistributionCurve() const;
    void setLightDistributionCurve(IfcLightDistributionCurveEnum::IfcLightDistributionCurveEnum v);
    /// Light distribution data applied to the light source. It is defined by a list of main plane angles (B or C according to the light distribution curve chosen) that includes (for each B or C angle) a second list of secondary plane angles (the &#946; or &#947; angles) and the according luminous intensity distribution measures.
    IfcTemplatedEntityList< IfcLightDistributionData >::ptr DistributionData() const;
    void setDistributionData(IfcTemplatedEntityList< IfcLightDistributionData >::ptr v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENUMERATION; case 1: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcLightDistributionCurveEnum; case 1: return Type::IfcLightDistributionData; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "LightDistributionCurve"; case 1: return "DistributionData"; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcLightIntensityDistribution (IfcEntityInstanceData* e);
    IfcLightIntensityDistribution (IfcLightDistributionCurveEnum::IfcLightDistributionCurveEnum v1_LightDistributionCurve, IfcTemplatedEntityList< IfcLightDistributionData >::ptr v2_DistributionData);
    typedef IfcTemplatedEntityList< IfcLightIntensityDistribution > list;
};
/// The map conversion deals with transforming the local engineering coordinate system, often called world coordinate system, into the coordinate reference system of the underlying map.
/// 
/// NOTE  The IfcMapConversion does not handle the projection of a map from the geodetic coordinate reference system.
/// 
/// The map conversion allows to convert the local origin of the local engineering coordinate system to its place within a map (easting, northing, orthogonal height) and to rotate the x-axis of the local engineering coordinate system within the horizontal (easting/westing) plane of the map.
/// 
/// NOTE  The z axis of the local engineering coordinate system is always parallel to the z axis of the map coordinate system.
/// 
/// The scale factor can be used when the length unit for the 3 axes of the map coordinate system are not identical with the length unit established for this project (seeÿIfcProject.UnitsInContext), if omitted, the scale factor 1.0 is assumed.
/// 
/// HISTORY  New entity in IFC2x4.
class IFC_PARSE_API IfcMapConversion : public IfcCoordinateOperation {
public:
    /// Specifies the location along the easting of the coordinate system of the target map coordinate reference system.
    /// NOTE  for right-handed Cartesian coordinate systems this would establish the location along the x axis
    double Eastings() const;
    void setEastings(double v);
    /// Specifies the location along the northing of the coordinate system of the target map coordinate reference system.
    /// NOTE  for right-handed Cartesian coordinate systems this would establish the location along the y axis
    double Northings() const;
    void setNorthings(double v);
    /// Orthogonal height relativ to the vertical datum specified.
    /// NOTE  for right-handed Cartesian coordinate systems this would establish the location along the z axis
    double OrthogonalHeight() const;
    void setOrthogonalHeight(double v);
    /// Whether the optional attribute XAxisAbscissa is defined for this IfcMapConversion
    bool hasXAxisAbscissa() const;
    /// Specifies the value along the easing axis of the end point of a vector indicating the position of the local x axis of the engineering coordinate reference system.
    /// NOTE  for right-handed Cartesian coordinate systems this would establish the location along the x axis
    /// NOTE  together with the XAxisOrdinate it provides the direction of the local x axis within the horizontal plane of the map coordinate system
    double XAxisAbscissa() const;
    void setXAxisAbscissa(double v);
    /// Whether the optional attribute XAxisOrdinate is defined for this IfcMapConversion
    bool hasXAxisOrdinate() const;
    /// Specifies the value along the northing axis of the end point of a vector indicating the position of the local x axis of the engineering coordinate reference system.
    /// NOTE  for right-handed Cartesian coordinate systems this would establish the location along the y axis
    /// NOTE  together with the XAxisAbscissa it provides the direction of the local x axis within the horizontal plane of the map coordinate system
    double XAxisOrdinate() const;
    void setXAxisOrdinate(double v);
    /// Whether the optional attribute Scale is defined for this IfcMapConversion
    bool hasScale() const;
    /// Scale to be used, when the units of the CRS are not identical to the units of the engineering coordinate system. If omited, the value of 1.0 is assumed.
    double Scale() const;
    void setScale(double v);
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 2: return IfcUtil::Argument_DOUBLE; case 3: return IfcUtil::Argument_DOUBLE; case 4: return IfcUtil::Argument_DOUBLE; case 5: return IfcUtil::Argument_DOUBLE; case 6: return IfcUtil::Argument_DOUBLE; case 7: return IfcUtil::Argument_DOUBLE; } return IfcCoordinateOperation::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 2: return Type::IfcLengthMeasure; case 3: return Type::IfcLengthMeasure; case 4: return Type::IfcLengthMeasure; case 5: return Type::IfcReal; case 6: return Type::IfcReal; case 7: return Type::IfcReal; } return IfcCoordinateOperation::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 2: return "Eastings"; case 3: return "Northings"; case 4: return "OrthogonalHeight"; case 5: return "XAxisAbscissa"; case 6: return "XAxisOrdinate"; case 7: return "Scale"; } return IfcCoordinateOperation::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcMapConversion (IfcEntityInstanceData* e);
    IfcMapConversion (IfcCoordinateReferenceSystemSelect* v1_SourceCRS, IfcCoordinateReferenceSystem* v2_TargetCRS, double v3_Eastings, double v4_Northings, double v5_OrthogonalHeight, boost::optional< double > v6_XAxisAbscissa, boost::optional< double > v7_XAxisOrdinate, boost::optional< double > v8_Scale);
    typedef IfcTemplatedEntityList< IfcMapConversion > list;
};
/// IfcMaterialClassificationRelationship is a relationship assigning classifications to materials.
/// 
/// HISTORYÿ New entity in IFC2x.
/// 
/// IFC2x4 CHANGEÿ The entity IfcMaterialClassificationRelationship is deprecated since IFC2x4 and shall no longer be used. Use IfcExternalReferenceRelationship instead.
class IFC_PARSE_API IfcMaterialClassificationRelationship : public IfcUtil::IfcBaseEntity {
public:
    /// The material classifications identifying the type of material.
    IfcEntityList::ptr MaterialClassifications() const;
    void setMaterialClassifications(IfcEntityList::ptr v);
    /// Material being classified.
    IfcMaterial* ClassifiedMaterial() const;
    void setClassifiedMaterial(IfcMaterial* v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_ENTITY_INSTANCE; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcClassificationSelect; case 1: return Type::IfcMaterial; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "MaterialClassifications"; case 1: return "ClassifiedMaterial"; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcMaterialClassificationRelationship (IfcEntityInstanceData* e);
    IfcMaterialClassificationRelationship (IfcEntityList::ptr v1_MaterialClassifications, IfcMaterial* v2_ClassifiedMaterial);
    typedef IfcTemplatedEntityList< IfcMaterialClassificationRelationship > list;
};
/// IfcMaterialDefinition is a general supertype for all
/// material related information items in IFC that have common
/// material related properties that may include association of
/// material with some shape parameters or assignments to identified
/// parts of a component.
/// There are three ways of assigning materials to a single component or
/// multiple components; they are characterized as:
/// 
/// by layer - assigning a material to a layer with constant
/// thickness
/// by profile - assigning a material to a profile with a
/// constant of varying shape along an extrusion
/// by constituents - assigning a material to an identified part
/// of a component shape; the identification is by a keyword rather than 
/// by a shape parameter
/// 
/// Each instantiable subtype of IfcMaterialDefinition may
/// have material properties assigned, or have an external
/// classification of its definition. It can be assigned to either a
/// subtype of IfcElement, or a subtype of
/// IfcElementType by using the objectified relationship
/// IfcRelAssociatesMaterial.
/// 
/// HISTORYÿ New entity in IFC2x4
class IFC_PARSE_API IfcMaterialDefinition : public IfcUtil::IfcBaseEntity {
public:
    virtual unsigned int getArgumentCount() const { return 0; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcRelAssociatesMaterial >::ptr AssociatedTo() const; // INVERSE IfcRelAssociatesMaterial::RelatingMaterial
    IfcTemplatedEntityList< IfcExternalReferenceRelationship >::ptr HasExternalReferences() const; // INVERSE IfcExternalReferenceRelationship::RelatedResourceObjects
    IfcTemplatedEntityList< IfcMaterialProperties >::ptr HasProperties() const; // INVERSE IfcMaterialProperties::Material
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcMaterialDefinition (IfcEntityInstanceData* e);
    IfcMaterialDefinition ();
    typedef IfcTemplatedEntityList< IfcMaterialDefinition > list;
};
/// IfcMaterialLayer is a single and identifiable part of an element which is constructed of a number of layers (one or more). Each IfcMaterialLayer has a constant thickness and is located relative to the referencing IfcMaterialLayerSet along the MlsBase.
/// 
/// EXAMPLE  A cavity wall with brick masonry used with
/// an air gap in between would be modeled using three
/// IfcMaterialLayer's: [1] Brick, [2] Air gap, [3] Brick. The
/// inner layer "Brick" would have a Name = "Brick", an
/// individual LayerThickness, and potentially a
/// Category indicating it as "load bearing", and a
/// Priority that controls how this material layer interacts
/// with other material layers in wall connections.
/// 
/// The IfcMaterialLayer may have a material layer name,
/// that might be different to the IfcMaterial name
/// referenced.
/// 
/// EXAMPLE  The IfcMaterialLayer name of an
/// insulation layer can be "Insulation", whereas the
/// IfcMaterial name is "polystyrene insulating
/// boards".
/// 
/// HISTORY  New entity in IFC 1.5
/// 
/// IFC2x4 CHANGE  The attributes Name, Description, Category, Priority have been added at the end of attribute list. Data type of LayerThickness relaxed to IfcNonNegativeLengthMeasure.
class IFC_PARSE_API IfcMaterialLayer : public IfcMaterialDefinition {
public:
    /// Whether the optional attribute Material is defined for this IfcMaterialLayer
    bool hasMaterial() const;
    /// Optional reference to the material from which the layer is constructed. Note that if this value is not given, it does not denote a layer with no material (an air gap), it only means that the material is not specified at that point.
    IfcMaterial* Material() const;
    void setMaterial(IfcMaterial* v);
    /// The thickness of the material layer. The dimension is measured along the positive MlsDirection as specified in IfcMaterialLayerSet (that is mapped to AXIS-2, as specified in IfcMaterialLayerSetUsage for element occurrences supporting IfcMaterialLayerSetUsage.
    /// 
    /// NOTE  The attribute value can be 0. for material thicknesses very close to zero, such as for a membrane. Material layers with thickess 0. shall not be rendered in the geometric representation.
    /// 
    /// IFC2x4 CHANGE  The attribute datatype has been changed to IfcNonNegativeLengthMeasure allowing for 0. as thickness.
    double LayerThickness() const;
    void setLayerThickness(double v);
    /// Whether the optional attribute IsVentilated is defined for this IfcMaterialLayer
    bool hasIsVentilated() const;
    /// Indication of whether the material layer represents an air layer (or cavity). 
    /// 
    /// set to TRUE if the material layer is an air gap and provides air exchange from the layer to the outside air.
    ///   set to UNKNOWN if the material layer is an air gap and does not provide air exchange (or when this information about air exchange of the air gap is not available).
    ///   set to FALSE if the material layer is a solid material layer (the default).
    bool IsVentilated() const;
    void setIsVentilated(bool v);
    /// Whether the optional attribute Name is defined for this IfcMaterialLayer
    bool hasName() const;
    /// The name by which the material layer is known.
    std::string Name() const;
    void setName(std::string v);
    /// Whether the optional attribute Description is defined for this IfcMaterialLayer
    bool hasDescription() const;
    /// Definition of the material layer in more descriptive terms than given by attributes Name or Category.
    std::string Description() const;
    void setDescription(std::string v);
    /// Whether the optional attribute Category is defined for this IfcMaterialLayer
    bool hasCategory() const;
    /// Category of the material layer, e.g. the role it has in the layer set it belongs to (such as 'load bearing', 'thermal insulation' etc.).
    std::string Category() const;
    void setCategory(std::string v);
    /// Whether the optional attribute Priority is defined for this IfcMaterialLayer
    bool hasPriority() const;
    /// The relative priority of the layer, expressed as ratio measure, normalised to 0..1. Controls how layers intersect in connections and corners of building elements: a layer from one element protrudes into (i.e. displaces) a layer from another element in a joint of these elements if the former element's layer has higher priority than the latter. The priorty value for a material layer in an element has to be set and maintained by software applications, in relation to the material layers in connected elements. The usage has to be further specified for each element, especially to avoid simultanious use with IfcLayerOffset.
    int Priority() const;
    void setPriority(int v);
    virtual unsigned int getArgumentCount() const { return 7; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_DOUBLE; case 2: return IfcUtil::Argument_BOOL; case 3: return IfcUtil::Argument_STRING; case 4: return IfcUtil::Argument_STRING; case 5: return IfcUtil::Argument_STRING; case 6: return IfcUtil::Argument_INT; } return IfcMaterialDefinition::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcMaterial; case 1: return Type::IfcNonNegativeLengthMeasure; case 2: return Type::IfcLogical; case 3: return Type::IfcLabel; case 4: return Type::IfcText; case 5: return Type::IfcLabel; case 6: return Type::IfcInteger; } return IfcMaterialDefinition::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Material"; case 1: return "LayerThickness"; case 2: return "IsVentilated"; case 3: return "Name"; case 4: return "Description"; case 5: return "Category"; case 6: return "Priority"; } return IfcMaterialDefinition::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcMaterialLayerSet >::ptr ToMaterialLayerSet() const; // INVERSE IfcMaterialLayerSet::MaterialLayers
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcMaterialLayer (IfcEntityInstanceData* e);
    IfcMaterialLayer (IfcMaterial* v1_Material, double v2_LayerThickness, boost::optional< bool > v3_IsVentilated, boost::optional< std::string > v4_Name, boost::optional< std::string > v5_Description, boost::optional< std::string > v6_Category, boost::optional< int > v7_Priority);
    typedef IfcTemplatedEntityList< IfcMaterialLayer > list;
};
/// IfcMaterialLayerSet is a designation by which materials of an element constructed of a number of material layers is known and through which the relative positioning of individual layers can be expressed.
/// 
/// The Material Layer Set Base (MlsBase) describes the axis along
/// which the material layers are positioned. The MlsBase is positioned
/// along the reference axis or reference plane of the element
/// supporting the IfcMaterialLayerSetUsage concept with a
/// potential offset (see here). The positive Material Layer Set
/// Direction (MlsDirection) describes the direction by which the
/// individual material layers, with their material layer thicknesses
/// are stacked. IfcMaterialLayer's are stacked with no gap,
/// gaps within a material layer set are expresses as layers by
/// themselves.
/// 
/// EXAMPLE A cavity brick wall would be modeled as
/// IfcMaterialLayerSet consisting of three
/// IfcMaterialLayer's: brick, air cavity and brick. The air
/// gap is identified, using the IsVentilated flag at
/// IfcMaterialLayer.
/// 
/// HISTORY  New entity in IFC 1.0
/// 
/// IFC2x4 CHANGE  Subtyped from IfcMaterialDefinition, the attribute Description
/// has been added at the end of attribute list.
/// 
/// Attribute use definition
/// As shown in Figure 285, each IfcMaterialLayerSet implicitly defines a material
/// layer set base line (MlsBase), to which the start of the first
/// IfcMaterialLayer is aligned. The total thickness of a
/// layer set is calculated from the individual layer thicknesses, the
/// first layer starting from the MlsBase and following layers being
/// placed on top of the previous (no gaps or overlaps).
/// 
/// Figure 285 — Material layer set
class IFC_PARSE_API IfcMaterialLayerSet : public IfcMaterialDefinition {
public:
    /// Identification of the layers from which the material layer set is composed.
    IfcTemplatedEntityList< IfcMaterialLayer >::ptr MaterialLayers() const;
    void setMaterialLayers(IfcTemplatedEntityList< IfcMaterialLayer >::ptr v);
    /// Whether the optional attribute LayerSetName is defined for this IfcMaterialLayerSet
    bool hasLayerSetName() const;
    /// The name by which the material layer set is known.
    std::string LayerSetName() const;
    void setLayerSetName(std::string v);
    /// Whether the optional attribute Description is defined for this IfcMaterialLayerSet
    bool hasDescription() const;
    /// Definition of the material layer set in descriptive terms.
    /// 
    /// IFC2x4 CHANGE  The attribute has been added at the end of attribute list.
    std::string Description() const;
    void setDescription(std::string v);
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_STRING; case 2: return IfcUtil::Argument_STRING; } return IfcMaterialDefinition::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcMaterialLayer; case 1: return Type::IfcLabel; case 2: return Type::IfcText; } return IfcMaterialDefinition::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "MaterialLayers"; case 1: return "LayerSetName"; case 2: return "Description"; } return IfcMaterialDefinition::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcMaterialLayerSet (IfcEntityInstanceData* e);
    IfcMaterialLayerSet (IfcTemplatedEntityList< IfcMaterialLayer >::ptr v1_MaterialLayers, boost::optional< std::string > v2_LayerSetName, boost::optional< std::string > v3_Description);
    typedef IfcTemplatedEntityList< IfcMaterialLayerSet > list;
};
/// IfcMaterialLayerWithOffsets is a specialization of IfcMaterialLayer enabling definition
/// of offset values along edges (within the material layer set usage in parent layer set).
/// 
/// It defines the assignment of two offset values for a material
/// layer in its intended use within a material layer set. Offsets are
/// applied to the edges of layered elements (that is, in directions
/// perpendicular to the layer set direction). Offsets shall not be
/// used in layer set direction, that is, for modelling gaps (or overlaps)
/// between layers; gaps shall be modeled as layers with appropriate
/// material assignment for the void.
/// 
/// EXAMPLE   At the top of a standard wall,
/// with shape representation SweptSolid, offset of a given layer can
/// be specified in the direction of the extrusion (positive Z axis),
/// applied at the start or end (extruded from bottom to top), and with
/// a positive (extending above extrusion) or negative (ending below
/// extrusion).
/// 
/// Take a standard wall with the outer material layer for the
/// external isolation extending above extrusion by 100mm, but starting
/// at the same base height. In this case the following values are
/// set:
/// 
/// OffsetDirection = .AXIS3.
/// OffsetValues[1] = 0.0
/// OffsetValues[2] = 100.0 (default unit assumed to
/// be mm)
/// 
/// HISTORY  New Entity in IFC2x4.
/// 
/// Informal propositions
/// 
/// The OffestDirection shall not be identical to the
/// LayerSetDirection of the corresponding
/// IfcMaterialLayerSetUsage
/// The attribute ReferenceExtent shall be asserted at the
/// corresponding IfcMaterialLayerSetUsage
/// 
/// Attribute use definition
/// The OffsetValues and OffsetDirection correspond to the definitions ReferenceExtent and LayerSetDirection at the IfcMaterialLayerSetUsage.
/// Figure 289 shows an example of applying the OffsetValues to the material layers of a standard wall.
/// 
/// Figure 289 — Material layer with offsets
class IFC_PARSE_API IfcMaterialLayerWithOffsets : public IfcMaterialLayer {
public:
    /// Orientation of the offset; shall be perpendicular to the parent layer set direction.
    IfcLayerSetDirectionEnum::IfcLayerSetDirectionEnum OffsetDirection() const;
    void setOffsetDirection(IfcLayerSetDirectionEnum::IfcLayerSetDirectionEnum v);
    /// The numerical value of layer offset, in the direction of the axis assigned by the attribute OffsetDirection. The OffsetValues[1] identifies the offset from the lower position along the axis direction (normally the start of the standard extrusion), the OffsetValues[2] identifies the offset from the upper position along the axis direction (normally the end of the standard extrusion),
    std::vector< double > /*[1:2]*/ OffsetValues() const;
    void setOffsetValues(std::vector< double > /*[1:2]*/ v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 7: return IfcUtil::Argument_ENUMERATION; case 8: return IfcUtil::Argument_AGGREGATE_OF_DOUBLE; } return IfcMaterialLayer::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 7: return Type::IfcLayerSetDirectionEnum; case 8: return Type::IfcLengthMeasure; } return IfcMaterialLayer::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 7: return "OffsetDirection"; case 8: return "OffsetValues"; } return IfcMaterialLayer::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcMaterialLayerWithOffsets (IfcEntityInstanceData* e);
    IfcMaterialLayerWithOffsets (IfcMaterial* v1_Material, double v2_LayerThickness, boost::optional< bool > v3_IsVentilated, boost::optional< std::string > v4_Name, boost::optional< std::string > v5_Description, boost::optional< std::string > v6_Category, boost::optional< int > v7_Priority, IfcLayerSetDirectionEnum::IfcLayerSetDirectionEnum v8_OffsetDirection, std::vector< double > /*[1:2]*/ v9_OffsetValues);
    typedef IfcTemplatedEntityList< IfcMaterialLayerWithOffsets > list;
};
/// IfcMaterialList is a list of the different materials
/// that are used in an element.
/// 
/// NOTE: The class IfcMaterialList will
/// normally be used where an element is described at a more abstract
/// level. For example, for an architectural specification writer,
/// the only information that may be needed about a concrete column
/// is that it contains concrete, reinforcing steel and mild steel
/// ligatures. It shall not be used for elements consisting of
/// material layers when the different layers can be defined and the
/// class IfcMaterialLayerSet can be used. Also,
/// IfcMaterialList shall not be used for elements consisting
/// of a single identifiable material (for example, to represent anisotropic
/// material).
/// 
/// IFC2x4 CHANGEÿ The entity IfcMaterialList is deprecated and shall no longer
/// be used. Use IfcMaterialConstituentSet instead.
class IFC_PARSE_API IfcMaterialList : public IfcUtil::IfcBaseEntity {
public:
    /// Materials used in a composition of substances.
    IfcTemplatedEntityList< IfcMaterial >::ptr Materials() const;
    void setMaterials(IfcTemplatedEntityList< IfcMaterial >::ptr v);
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcMaterial; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Materials"; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcMaterialList (IfcEntityInstanceData* e);
    IfcMaterialList (IfcTemplatedEntityList< IfcMaterial >::ptr v1_Materials);
    typedef IfcTemplatedEntityList< IfcMaterialList > list;
};
/// IfcMaterialProfile is a single and identifiable part of an element which is constructed of a number of profiles (one or more).
/// 
/// NOTE ÿ In case of multiple MaterialProfiles, the relative positioning of individual profiles in IfcMaterialProfileSet are defined using the concept of IfcCompositeProfileDef in IfcProfileResource schema; otherwise, only one MaterialProfile is given and defined by an individual IfcProfileDef (subtype).
/// 
/// HISTORYÿNew Entity in IFC2x4
class IFC_PARSE_API IfcMaterialProfile : public IfcMaterialDefinition {
public:
    /// Whether the optional attribute Name is defined for this IfcMaterialProfile
    bool hasName() const;
    /// The name by which the material profile is known.
    std::string Name() const;
    void setName(std::string v);
    /// Whether the optional attribute Description is defined for this IfcMaterialProfile
    bool hasDescription() const;
    /// Definition of the material profile in descriptive terms.
    std::string Description() const;
    void setDescription(std::string v);
    /// Whether the optional attribute Material is defined for this IfcMaterialProfile
    bool hasMaterial() const;
    /// Optional reference to the material from which the profile is constructed.
    IfcMaterial* Material() const;
    void setMaterial(IfcMaterial* v);
    /// Identification of the profile for which this material profile is associating material.
    IfcProfileDef* Profile() const;
    void setProfile(IfcProfileDef* v);
    /// Whether the optional attribute Priority is defined for this IfcMaterialProfile
    bool hasPriority() const;
    /// The relative priority of the profile, expressed as ratio measure, normalised to 0..1. Controls how profiles intersect in connections and corners of building elements: a profile from one element protrudes into (i.e. displaces) a profile from another element in a joint of these elements if the former element's profile has higher priority than the latter. The priorty value for a material profile in an element has to be set and maintained by software applications, in relation to the material profiles in connected elements.
    int Priority() const;
    void setPriority(int v);
    /// Whether the optional attribute Category is defined for this IfcMaterialProfile
    bool hasCategory() const;
    /// Category of the material profile, e.g. the role it has in the profile set it belongs to.
    std::string Category() const;
    void setCategory(std::string v);
    virtual unsigned int getArgumentCount() const { return 6; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_STRING; case 1: return IfcUtil::Argument_STRING; case 2: return IfcUtil::Argument_ENTITY_INSTANCE; case 3: return IfcUtil::Argument_ENTITY_INSTANCE; case 4: return IfcUtil::Argument_INT; case 5: return IfcUtil::Argument_STRING; } return IfcMaterialDefinition::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcLabel; case 1: return Type::IfcText; case 2: return Type::IfcMaterial; case 3: return Type::IfcProfileDef; case 4: return Type::IfcInteger; case 5: return Type::IfcLabel; } return IfcMaterialDefinition::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Name"; case 1: return "Description"; case 2: return "Material"; case 3: return "Profile"; case 4: return "Priority"; case 5: return "Category"; } return IfcMaterialDefinition::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcMaterialProfileSet >::ptr ToMaterialProfileSet() const; // INVERSE IfcMaterialProfileSet::MaterialProfiles
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcMaterialProfile (IfcEntityInstanceData* e);
    IfcMaterialProfile (boost::optional< std::string > v1_Name, boost::optional< std::string > v2_Description, IfcMaterial* v3_Material, IfcProfileDef* v4_Profile, boost::optional< int > v5_Priority, boost::optional< std::string > v6_Category);
    typedef IfcTemplatedEntityList< IfcMaterialProfile > list;
};
/// IfcMaterialProfileSet is a designation by which individual material(s) of a prismatic element (for example, beam or column) constructed of a single or multiple material profiles is known. If only a single material profile is used (the most typical case) then no CompositeProfile is asserted.
/// 
/// NOTE ÿ In case of multiple MaterialProfiles, the relative positioning of individual profiles in IfcMaterialProfileSet are defined using the concept of IfcCompositeProfileDef in IfcProfileResource schema; otherwise, only one MaterialProfile is given and defined by an individual IfcProfileDef (subtype).
/// 
/// HISTORYÿNew Entity in IFC2x4.
class IFC_PARSE_API IfcMaterialProfileSet : public IfcMaterialDefinition {
public:
    /// Whether the optional attribute Name is defined for this IfcMaterialProfileSet
    bool hasName() const;
    /// The name by which the material profile set is known.
    std::string Name() const;
    void setName(std::string v);
    /// Whether the optional attribute Description is defined for this IfcMaterialProfileSet
    bool hasDescription() const;
    /// Definition of the material profile set in descriptive terms.
    std::string Description() const;
    void setDescription(std::string v);
    /// Identification of the profiles from which the material profile set is composed.
    IfcTemplatedEntityList< IfcMaterialProfile >::ptr MaterialProfiles() const;
    void setMaterialProfiles(IfcTemplatedEntityList< IfcMaterialProfile >::ptr v);
    /// Whether the optional attribute CompositeProfile is defined for this IfcMaterialProfileSet
    bool hasCompositeProfile() const;
    /// Reference to the composite profile definition for which this material profile set associates material to each of its individual profile. 
    /// 
    /// NOTE   
    /// The referenced IfcCompositeProfileDef instance shall be composed of all of the IfcProfileDef instances which are used via the MaterialProfiles list in the current IfcMaterialProfileSet .
    IfcCompositeProfileDef* CompositeProfile() const;
    void setCompositeProfile(IfcCompositeProfileDef* v);
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_STRING; case 1: return IfcUtil::Argument_STRING; case 2: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 3: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcMaterialDefinition::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcLabel; case 1: return Type::IfcText; case 2: return Type::IfcMaterialProfile; case 3: return Type::IfcCompositeProfileDef; } return IfcMaterialDefinition::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Name"; case 1: return "Description"; case 2: return "MaterialProfiles"; case 3: return "CompositeProfile"; } return IfcMaterialDefinition::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcMaterialProfileSet (IfcEntityInstanceData* e);
    IfcMaterialProfileSet (boost::optional< std::string > v1_Name, boost::optional< std::string > v2_Description, IfcTemplatedEntityList< IfcMaterialProfile >::ptr v3_MaterialProfiles, IfcCompositeProfileDef* v4_CompositeProfile);
    typedef IfcTemplatedEntityList< IfcMaterialProfileSet > list;
};
/// IfcMaterialProfileWithOffsets is a specialization of IfcMaterialProfile enabling definition offset values for profile start or end in its use in parent material profile set usage.
/// 
/// Relative positions of IfcMaterialProfileWithOffsets in the longitudinal direction of an element can be defined giving offsets at the start and end. This shall not be used for relative positions of individual profiles in the plane of profile definition, which is given in composite profile definition itself. Also, care should be taken especially when used with IfcMaterialProfileSetUsageTapering for correct start and end offset assignement.
/// 
/// HISTORYÿ New Entity in IFC2x4.
class IFC_PARSE_API IfcMaterialProfileWithOffsets : public IfcMaterialProfile {
public:
    /// The numerical value of profile offset, in the direction of the axis direction - always AXIS1 i.e. the axis along the extrusion path. The OffsetValues[1] identifies the offset from the lower position along the axis direction (normally the start of the standard extrusion), the OffsetValues[2] identifies the offset from the upper position along the axis direction (normally the end of the standard extrusion),
    std::vector< double > /*[1:2]*/ OffsetValues() const;
    void setOffsetValues(std::vector< double > /*[1:2]*/ v);
    virtual unsigned int getArgumentCount() const { return 7; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 6: return IfcUtil::Argument_AGGREGATE_OF_DOUBLE; } return IfcMaterialProfile::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 6: return Type::IfcLengthMeasure; } return IfcMaterialProfile::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 6: return "OffsetValues"; } return IfcMaterialProfile::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcMaterialProfileWithOffsets (IfcEntityInstanceData* e);
    IfcMaterialProfileWithOffsets (boost::optional< std::string > v1_Name, boost::optional< std::string > v2_Description, IfcMaterial* v3_Material, IfcProfileDef* v4_Profile, boost::optional< int > v5_Priority, boost::optional< std::string > v6_Category, std::vector< double > /*[1:2]*/ v7_OffsetValues);
    typedef IfcTemplatedEntityList< IfcMaterialProfileWithOffsets > list;
};
/// IfcMaterialUsageDefinition is a general supertype for all
/// material related information items in IFC that have occurrence
/// specific assignment parameters to assign a set of materials with
/// shape parameters to a reference geometry item of that
/// component.
/// There are two ways of assigning a set of materials with shape
/// parameters:
/// 
/// a layer set to a reference curve - assigning a material layer
/// set with material layers having a sequence and thickness
/// parameter to a reference curve of an element - represented by the
/// 'Axis' shape representation of that element
/// a profile set to a cardinal point - assigning a material
/// profile set with assigned profile geometry and insertion points
/// to a reference curve by an offset, called "cardinal point" - the
/// reference curve is represented by the 'Axis' shape representation
/// of that element
/// 
/// Each instantiable subtype of IfcMaterialUsageDefinition
/// has to be assigned to a subtype of IfcElement by using the
/// objectified relationship IfcRelAssociatesMaterial; it is
/// only valid in conjunction with an element occurrence.
/// 
/// HISTORYÿ New entity in IFC2x4
/// 
/// Informal proposition
/// 
/// It is illegal to assign a subtype of
/// IfcMaterialUsageDefinition to a subtype of
/// IfcElementType, it shall only be assigned to an element
/// occurrence.
class IFC_PARSE_API IfcMaterialUsageDefinition : public IfcUtil::IfcBaseEntity {
public:
    virtual unsigned int getArgumentCount() const { return 0; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcRelAssociatesMaterial >::ptr AssociatedTo() const; // INVERSE IfcRelAssociatesMaterial::RelatingMaterial
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcMaterialUsageDefinition (IfcEntityInstanceData* e);
    IfcMaterialUsageDefinition ();
    typedef IfcTemplatedEntityList< IfcMaterialUsageDefinition > list;
};
/// Definition from ISO/CD 10303-41:1992: A measure with unit is the specification of a physical quantity  as defined in ISO 31 (clause 2).
/// 
/// IfcMeasureWithUnit has two usages:
/// 1. For representing measure value together with its unit on the entity type attribute level; thus
///   overriding the IFC model global unit assignments.
/// 2. For conversion based unit to give the conversion rate and its base.
/// 
/// NOTE Corresponding ISO 10303 name: measure_with_unit, please refer to ISO/IS 10303-41 for the final definition of the formal standard.
/// 
/// HISTORY New entity in IFC Release 1.5.1.
class IFC_PARSE_API IfcMeasureWithUnit : public IfcUtil::IfcBaseEntity {
public:
    /// The value of the physical quantity when expressed in the specified units.
    IfcValue* ValueComponent() const;
    void setValueComponent(IfcValue* v);
    /// The unit in which the physical quantity is expressed.
    IfcUnit* UnitComponent() const;
    void setUnitComponent(IfcUnit* v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_ENTITY_INSTANCE; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcValue; case 1: return Type::IfcUnit; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "ValueComponent"; case 1: return "UnitComponent"; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcMeasureWithUnit (IfcEntityInstanceData* e);
    IfcMeasureWithUnit (IfcValue* v1_ValueComponent, IfcUnit* v2_UnitComponent);
    typedef IfcTemplatedEntityList< IfcMeasureWithUnit > list;
};
/// An IfcMetric is used to capture quantitative resultant metrics that can be applied to objectives. 
/// 
/// HISTORY: New Entity in IFC Release 2.0
/// 
/// Use Definition 
/// IfcMetric is a subtype of IfcConstraint and may be associated with any subtype of IfcRoot through the IfcRelAssociatesConstraint relationship in the IfcControlExtension schema, or may be associated with IfcProperty by IfcPropertyConstraintRelationship. 
/// 
/// The aim of IfcMetric is to capture the quantitative aspects of a constraint. 
/// 
/// For instance, when undertaking a move (instantiated through the IfcTask class), a constraint is instantiated as the class IfcMetric and may be named as a 'Move Start Constraint' or 'Move End Constraint' and described using one of a possible range of move constraints as shown in the table below. 
/// 
/// Constraint 
///   Description 
///   Benchmark 
///   Grade 
/// 
/// ASSOONASPOSSIBLE 
///   Action should commence at the earliest possible opportunity. 
///   GREATERTHANOREQUALTO 
///   SOFT 
/// 
/// MUSTSTARTON 
///   Action must start at a prescribed date/time. 
///   EQUALTO 
///   HARD 
/// 
/// MUSTSTARTBEFORE 
///   Action must start before a prescribed date/time. 
///   LESSTHANOREQUALTO 
///   HARD 
/// 
/// MUSTSTARTAFTER 
///   Action must not start before a prescribed date/time. 
///   GREATERTHANOREQUALTO 
///   HARD 
/// 
/// MAYSTARTAFTER 
///   Action may start at any time following a prescribed date/time. 
///   GREATERTHANOREQUALTO 
///   SOFT 
/// 
/// MUSTFINISHON 
///   Action must be complete at or by a prescribed date/time. 
///   EQUALTO 
///   HARD 
/// 
/// MUSTFINISHBEFORE 
///   Action must be complete before a prescribed date/time. 
///   LESSTHANOREQUALTO 
///   HARD 
/// 
/// This constraint (instantiated as IfcMetric) uses a Date/Time value in IfcMetric.DataValue through IfcMetricValueSelect. An appropriate benchmark is applied according to the requirement of the constraint (as indicated) by IfcMetric.Benchmark. The grade of the constraint (hard, soft, advisory) must be specified through		IfcConstraint.ConstraintGrade whilst the time at which the constraint is	created may be optionally asserted through IfcConstraint.CreationTime.
class IFC_PARSE_API IfcMetric : public IfcConstraint {
public:
    /// Enumeration that identifies the type of benchmark data.
    IfcBenchmarkEnum::IfcBenchmarkEnum Benchmark() const;
    void setBenchmark(IfcBenchmarkEnum::IfcBenchmarkEnum v);
    /// Whether the optional attribute ValueSource is defined for this IfcMetric
    bool hasValueSource() const;
    /// Reference source for data values.
    std::string ValueSource() const;
    void setValueSource(std::string v);
    /// Whether the optional attribute DataValue is defined for this IfcMetric
    bool hasDataValue() const;
    /// The value with data type defined by the underlying type accesses via IfcMetricValueSelect.
    IfcMetricValueSelect* DataValue() const;
    void setDataValue(IfcMetricValueSelect* v);
    /// Whether the optional attribute ReferencePath is defined for this IfcMetric
    bool hasReferencePath() const;
    IfcReference* ReferencePath() const;
    void setReferencePath(IfcReference* v);
    virtual unsigned int getArgumentCount() const { return 11; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 7: return IfcUtil::Argument_ENUMERATION; case 8: return IfcUtil::Argument_STRING; case 9: return IfcUtil::Argument_ENTITY_INSTANCE; case 10: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcConstraint::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 7: return Type::IfcBenchmarkEnum; case 8: return Type::IfcLabel; case 9: return Type::IfcMetricValueSelect; case 10: return Type::IfcReference; } return IfcConstraint::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 7: return "Benchmark"; case 8: return "ValueSource"; case 9: return "DataValue"; case 10: return "ReferencePath"; } return IfcConstraint::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcMetric (IfcEntityInstanceData* e);
    IfcMetric (std::string v1_Name, boost::optional< std::string > v2_Description, IfcConstraintEnum::IfcConstraintEnum v3_ConstraintGrade, boost::optional< std::string > v4_ConstraintSource, IfcActorSelect* v5_CreatingActor, boost::optional< std::string > v6_CreationTime, boost::optional< std::string > v7_UserDefinedGrade, IfcBenchmarkEnum::IfcBenchmarkEnum v8_Benchmark, boost::optional< std::string > v9_ValueSource, IfcMetricValueSelect* v10_DataValue, IfcReference* v11_ReferencePath);
    typedef IfcTemplatedEntityList< IfcMetric > list;
};
/// IfcMonetaryUnit is a unit to define currency for money.
/// 
/// HISTORY: New entity in IFC Release 2x.
/// 
/// IFC2x4 CHANGE: Type of the attribute Currency changed.
class IFC_PARSE_API IfcMonetaryUnit : public IfcUtil::IfcBaseEntity {
public:
    /// Code or name of the currency.  Permissible values are the three-letter alphabetic currency codes as per ISO 4217, for example CNY, EUR, GBP, JPY, USD.
    std::string Currency() const;
    void setCurrency(std::string v);
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_STRING; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcLabel; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Currency"; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcMonetaryUnit (IfcEntityInstanceData* e);
    IfcMonetaryUnit (std::string v1_Currency);
    typedef IfcTemplatedEntityList< IfcMonetaryUnit > list;
};
/// Definition from ISO/CD 10303-41:1992: A named unit is a unit quantity associated with the word, or group of words, by which the unit is identified.
/// 
/// NOTE Corresponding ISO 10303 name: named_unit, please refer to ISO/IS 10303-41 for the final definition of the formal standard.
/// 
/// HISTORY New type in IFC Release 1.5.1.
class IFC_PARSE_API IfcNamedUnit : public IfcUtil::IfcBaseEntity {
public:
    /// The dimensional exponents of the SI base units by which the named unit is defined.
    IfcDimensionalExponents* Dimensions() const;
    void setDimensions(IfcDimensionalExponents* v);
    /// The type of the unit.
    IfcUnitEnum::IfcUnitEnum UnitType() const;
    void setUnitType(IfcUnitEnum::IfcUnitEnum v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_ENUMERATION; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcDimensionalExponents; case 1: return Type::IfcUnitEnum; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Dimensions"; case 1: return "UnitType"; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcNamedUnit (IfcEntityInstanceData* e);
    IfcNamedUnit (IfcDimensionalExponents* v1_Dimensions, IfcUnitEnum::IfcUnitEnum v2_UnitType);
    typedef IfcTemplatedEntityList< IfcNamedUnit > list;
};
/// IfcObjectPlacement is an abstract supertype for the special types defining the object coordinate system. The
/// IfcObjectPlacement has to be provided for each product that has a shape representation.
/// The object placement can be given:
/// 
/// absolute: by an axis2 placement, relative to the world coordinate system,
/// relative: by an axis2 placement, relative to the object placement of another product,
/// by grid reference: by the virtual intersection and reference direction given by two axes of a design grid.
/// 
/// In any case the object placement has to unambiguously define the object coordinate system as either two-dimensional axis placement (IfcAxis2Placement2D) or three-dimensional axis placement (IfcAxis2Placement3D). The axis placement may have to be calculated.
/// 
/// HISTORY New entity in IFC Release 2x.
class IFC_PARSE_API IfcObjectPlacement : public IfcUtil::IfcBaseEntity {
public:
    virtual unsigned int getArgumentCount() const { return 0; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcProduct >::ptr PlacesObject() const; // INVERSE IfcProduct::ObjectPlacement
    IfcTemplatedEntityList< IfcLocalPlacement >::ptr ReferencedByPlacements() const; // INVERSE IfcLocalPlacement::PlacementRelTo
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcObjectPlacement (IfcEntityInstanceData* e);
    IfcObjectPlacement ();
    typedef IfcTemplatedEntityList< IfcObjectPlacement > list;
};
/// An IfcObjective captures qualitative information for an objective-based constraint. 
/// 
/// HISTORY: New Entity in IFC Release 2.0
/// 
/// Use definition 
/// 
/// IfcObjective is a subtype of IfcConstraint and may be associated with any subtype of IfcRoot through the IfcRelAssociatesConstraint relationship in the IfcControlExtension schema, or may be associated with IfcProperty by IfcPropertyConstraintRelationship.
/// 
/// The aim of IfcObjective is to specify the purpose for which the constraint is applied and to capture the values of the constraint. These may be both the benchmark values that are intended to indicate the constraint extent and the resulting values in use that enable performance comparisons to be applied.
class IFC_PARSE_API IfcObjective : public IfcConstraint {
public:
    /// Whether the optional attribute BenchmarkValues is defined for this IfcObjective
    bool hasBenchmarkValues() const;
    /// A list of any benchmark values used for comparison purposes.
    IfcTemplatedEntityList< IfcConstraint >::ptr BenchmarkValues() const;
    void setBenchmarkValues(IfcTemplatedEntityList< IfcConstraint >::ptr v);
    /// Whether the optional attribute LogicalAggregator is defined for this IfcObjective
    bool hasLogicalAggregator() const;
    IfcLogicalOperatorEnum::IfcLogicalOperatorEnum LogicalAggregator() const;
    void setLogicalAggregator(IfcLogicalOperatorEnum::IfcLogicalOperatorEnum v);
    /// Enumeration that qualifies the type of objective constraint.
    IfcObjectiveEnum::IfcObjectiveEnum ObjectiveQualifier() const;
    void setObjectiveQualifier(IfcObjectiveEnum::IfcObjectiveEnum v);
    /// Whether the optional attribute UserDefinedQualifier is defined for this IfcObjective
    bool hasUserDefinedQualifier() const;
    /// A user defined value that qualifies the type of objective constraint when ObjectiveQualifier attribute of type IfcObjectiveEnum has value USERDEFINED.
    std::string UserDefinedQualifier() const;
    void setUserDefinedQualifier(std::string v);
    virtual unsigned int getArgumentCount() const { return 11; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 7: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 8: return IfcUtil::Argument_ENUMERATION; case 9: return IfcUtil::Argument_ENUMERATION; case 10: return IfcUtil::Argument_STRING; } return IfcConstraint::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 7: return Type::IfcConstraint; case 8: return Type::IfcLogicalOperatorEnum; case 9: return Type::IfcObjectiveEnum; case 10: return Type::IfcLabel; } return IfcConstraint::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 7: return "BenchmarkValues"; case 8: return "LogicalAggregator"; case 9: return "ObjectiveQualifier"; case 10: return "UserDefinedQualifier"; } return IfcConstraint::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcObjective (IfcEntityInstanceData* e);
    IfcObjective (std::string v1_Name, boost::optional< std::string > v2_Description, IfcConstraintEnum::IfcConstraintEnum v3_ConstraintGrade, boost::optional< std::string > v4_ConstraintSource, IfcActorSelect* v5_CreatingActor, boost::optional< std::string > v6_CreationTime, boost::optional< std::string > v7_UserDefinedGrade, boost::optional< IfcTemplatedEntityList< IfcConstraint >::ptr > v8_BenchmarkValues, boost::optional< IfcLogicalOperatorEnum::IfcLogicalOperatorEnum > v9_LogicalAggregator, IfcObjectiveEnum::IfcObjectiveEnum v10_ObjectiveQualifier, boost::optional< std::string > v11_UserDefinedQualifier);
    typedef IfcTemplatedEntityList< IfcObjective > list;
};
/// A named and structured grouping with a corporate identity.
/// 
/// NOTE: The relationships between IfcOrganizations, like a Department within a Company, can be expressed using IfcOrganizationRelationship.
/// 
/// NOTE Corresponds to the following entity in ISO-10303-41: organization.
/// 
/// HISTORY New entity in IFC Release 1.5.1.
/// IFC 2x4 change: attribute Id renamed to Identification.
class IFC_PARSE_API IfcOrganization : public IfcUtil::IfcBaseEntity {
public:
    /// Whether the optional attribute Identification is defined for this IfcOrganization
    bool hasIdentification() const;
    /// Identification of the organization.
    std::string Identification() const;
    void setIdentification(std::string v);
    /// The word, or group of words, by which the organization is referred to.
    std::string Name() const;
    void setName(std::string v);
    /// Whether the optional attribute Description is defined for this IfcOrganization
    bool hasDescription() const;
    /// Text that relates the nature of the organization.
    std::string Description() const;
    void setDescription(std::string v);
    /// Whether the optional attribute Roles is defined for this IfcOrganization
    bool hasRoles() const;
    /// Roles played by the organization.
    IfcTemplatedEntityList< IfcActorRole >::ptr Roles() const;
    void setRoles(IfcTemplatedEntityList< IfcActorRole >::ptr v);
    /// Whether the optional attribute Addresses is defined for this IfcOrganization
    bool hasAddresses() const;
    /// Postal and telecom addresses of an organization.
    /// NOTE: There may be several addresses related to an organization.
    IfcTemplatedEntityList< IfcAddress >::ptr Addresses() const;
    void setAddresses(IfcTemplatedEntityList< IfcAddress >::ptr v);
    virtual unsigned int getArgumentCount() const { return 5; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_STRING; case 1: return IfcUtil::Argument_STRING; case 2: return IfcUtil::Argument_STRING; case 3: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 4: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcIdentifier; case 1: return Type::IfcLabel; case 2: return Type::IfcText; case 3: return Type::IfcActorRole; case 4: return Type::IfcAddress; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Identification"; case 1: return "Name"; case 2: return "Description"; case 3: return "Roles"; case 4: return "Addresses"; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcOrganizationRelationship >::ptr IsRelatedBy() const; // INVERSE IfcOrganizationRelationship::RelatedOrganizations
    IfcTemplatedEntityList< IfcOrganizationRelationship >::ptr Relates() const; // INVERSE IfcOrganizationRelationship::RelatingOrganization
    IfcTemplatedEntityList< IfcPersonAndOrganization >::ptr Engages() const; // INVERSE IfcPersonAndOrganization::TheOrganization
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcOrganization (IfcEntityInstanceData* e);
    IfcOrganization (boost::optional< std::string > v1_Identification, std::string v2_Name, boost::optional< std::string > v3_Description, boost::optional< IfcTemplatedEntityList< IfcActorRole >::ptr > v4_Roles, boost::optional< IfcTemplatedEntityList< IfcAddress >::ptr > v5_Addresses);
    typedef IfcTemplatedEntityList< IfcOrganization > list;
};
/// IfcOwnerHistory defines all history and identification related information. In order to provide fast access it is directly attached to all independent objects, relationships and properties.
/// 
/// IfcOwnerHistory is used to identify the creating and owning application and user for the associated object, as well as capture the last modifying application and user.
/// 
/// HISTORY  New entity in IFC R1.0. Modified in IFC R2x4.
/// 
/// Informal propositions
/// 
/// If LastModifiedDate is defined but ChangeAction is not asserted, then the state of ChangeAction is assumed to be UNDEFINED.	  
/// If both LastModifiedDate and ChangeAction are asserted, then the state of ChangeAction applies to the value asserted in LastModifiedDate.
class IFC_PARSE_API IfcOwnerHistory : public IfcUtil::IfcBaseEntity {
public:
    /// Direct reference to the end user who currently "owns" this object. Note that IFC includes the concept of ownership transfer from one user to another and therefore distinguishes between the Owning User and Creating User.
    IfcPersonAndOrganization* OwningUser() const;
    void setOwningUser(IfcPersonAndOrganization* v);
    /// Direct reference to the application which currently "Owns" this object on behalf of the owning user, who uses this application. Note that IFC includes the concept of ownership transfer from one application to another and therefore distinguishes between the Owning Application and Creating Application.
    IfcApplication* OwningApplication() const;
    void setOwningApplication(IfcApplication* v);
    /// Whether the optional attribute State is defined for this IfcOwnerHistory
    bool hasState() const;
    /// Enumeration that defines the current access state of the object.
    IfcStateEnum::IfcStateEnum State() const;
    void setState(IfcStateEnum::IfcStateEnum v);
    /// Whether the optional attribute ChangeAction is defined for this IfcOwnerHistory
    bool hasChangeAction() const;
    /// Enumeration that defines the actions associated with changes made to the object.
    IfcChangeActionEnum::IfcChangeActionEnum ChangeAction() const;
    void setChangeAction(IfcChangeActionEnum::IfcChangeActionEnum v);
    /// Whether the optional attribute LastModifiedDate is defined for this IfcOwnerHistory
    bool hasLastModifiedDate() const;
    /// Date and Time expressed in UTC (Universal Time Coordinated, formerly Greenwich Mean Time or GMT) at which the last modification was made by LastModifyingUser and LastModifyingApplication.
    int LastModifiedDate() const;
    void setLastModifiedDate(int v);
    /// Whether the optional attribute LastModifyingUser is defined for this IfcOwnerHistory
    bool hasLastModifyingUser() const;
    /// User who carried out the last modification using LastModifyingApplication.
    IfcPersonAndOrganization* LastModifyingUser() const;
    void setLastModifyingUser(IfcPersonAndOrganization* v);
    /// Whether the optional attribute LastModifyingApplication is defined for this IfcOwnerHistory
    bool hasLastModifyingApplication() const;
    /// Application used to make the last modification.
    IfcApplication* LastModifyingApplication() const;
    void setLastModifyingApplication(IfcApplication* v);
    /// The date and time expressed in UTC (Universal Time Coordinated, formerly Greenwich Mean Time or GMT) when first created by the original OwningApplication. Once defined this value remains unchanged through the lifetime of the entity.
    int CreationDate() const;
    void setCreationDate(int v);
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_ENTITY_INSTANCE; case 2: return IfcUtil::Argument_ENUMERATION; case 3: return IfcUtil::Argument_ENUMERATION; case 4: return IfcUtil::Argument_INT; case 5: return IfcUtil::Argument_ENTITY_INSTANCE; case 6: return IfcUtil::Argument_ENTITY_INSTANCE; case 7: return IfcUtil::Argument_INT; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcPersonAndOrganization; case 1: return Type::IfcApplication; case 2: return Type::IfcStateEnum; case 3: return Type::IfcChangeActionEnum; case 4: return Type::IfcTimeStamp; case 5: return Type::IfcPersonAndOrganization; case 6: return Type::IfcApplication; case 7: return Type::IfcTimeStamp; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "OwningUser"; case 1: return "OwningApplication"; case 2: return "State"; case 3: return "ChangeAction"; case 4: return "LastModifiedDate"; case 5: return "LastModifyingUser"; case 6: return "LastModifyingApplication"; case 7: return "CreationDate"; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcOwnerHistory (IfcEntityInstanceData* e);
    IfcOwnerHistory (IfcPersonAndOrganization* v1_OwningUser, IfcApplication* v2_OwningApplication, boost::optional< IfcStateEnum::IfcStateEnum > v3_State, boost::optional< IfcChangeActionEnum::IfcChangeActionEnum > v4_ChangeAction, boost::optional< int > v5_LastModifiedDate, IfcPersonAndOrganization* v6_LastModifyingUser, IfcApplication* v7_LastModifyingApplication, int v8_CreationDate);
    typedef IfcTemplatedEntityList< IfcOwnerHistory > list;
};
/// Definition: an individual human being.
/// 
/// NOTE Many countries have legislation concerning the identification of individual persons within databases. Although the intent of the IFC Model is to act as a specification for data exchange 
/// and sharing, an IFC file might in some situations be considered to be a database that enables identification of a particular person under the terms of such legislation. Users should be aware of the constraints of legislation that might apply in the places where IFC files are used.
/// 
/// NOTE Corresponds to the following entity in ISO-10303-41: person.
/// 
/// HISTORY New entity in IFC Release 1.5.1.
/// IFC 2x4 change: attribute Id renamed to Identification.  WHERE rule relaxed to allow omission of names if Identification is provided.
class IFC_PARSE_API IfcPerson : public IfcUtil::IfcBaseEntity {
public:
    /// Whether the optional attribute Identification is defined for this IfcPerson
    bool hasIdentification() const;
    /// Identification of the person.
    std::string Identification() const;
    void setIdentification(std::string v);
    /// Whether the optional attribute FamilyName is defined for this IfcPerson
    bool hasFamilyName() const;
    /// The name by which the family identity of the person may be recognized.
    /// NOTE: Depending on geographical location and culture, family name may appear either as the first or last component of a name.
    std::string FamilyName() const;
    void setFamilyName(std::string v);
    /// Whether the optional attribute GivenName is defined for this IfcPerson
    bool hasGivenName() const;
    /// The name by which a person is known within a family and by which he or she may be familiarly recognized.
    /// NOTE: Depending on geographical location and culture, given name may appear either as the first or last component of a name.
    std::string GivenName() const;
    void setGivenName(std::string v);
    /// Whether the optional attribute MiddleNames is defined for this IfcPerson
    bool hasMiddleNames() const;
    /// Additional names given to a person that enable their identification apart from others who may have the same or similar family and given names.
    /// NOTE: Middle names are not normally used in familiar communication but may be asserted to provide additional 
    /// identification of a particular person if necessary. They may be particularly useful in situations where the person concerned has a 
    /// family name that occurs commonly in the geographical region.
    std::vector< std::string > /*[1:?]*/ MiddleNames() const;
    void setMiddleNames(std::vector< std::string > /*[1:?]*/ v);
    /// Whether the optional attribute PrefixTitles is defined for this IfcPerson
    bool hasPrefixTitles() const;
    /// The word, or group of words, which specify the person's social and/or professional standing and appear before his/her names.
    std::vector< std::string > /*[1:?]*/ PrefixTitles() const;
    void setPrefixTitles(std::vector< std::string > /*[1:?]*/ v);
    /// Whether the optional attribute SuffixTitles is defined for this IfcPerson
    bool hasSuffixTitles() const;
    /// The word, or group of words, which specify the person's social and/or professional standing and appear after his/her names.
    std::vector< std::string > /*[1:?]*/ SuffixTitles() const;
    void setSuffixTitles(std::vector< std::string > /*[1:?]*/ v);
    /// Whether the optional attribute Roles is defined for this IfcPerson
    bool hasRoles() const;
    /// Roles played by the person.
    IfcTemplatedEntityList< IfcActorRole >::ptr Roles() const;
    void setRoles(IfcTemplatedEntityList< IfcActorRole >::ptr v);
    /// Whether the optional attribute Addresses is defined for this IfcPerson
    bool hasAddresses() const;
    /// Postal and telecommunication addresses of a person.
    /// NOTE - A person may have several addresses.
    IfcTemplatedEntityList< IfcAddress >::ptr Addresses() const;
    void setAddresses(IfcTemplatedEntityList< IfcAddress >::ptr v);
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_STRING; case 1: return IfcUtil::Argument_STRING; case 2: return IfcUtil::Argument_STRING; case 3: return IfcUtil::Argument_AGGREGATE_OF_STRING; case 4: return IfcUtil::Argument_AGGREGATE_OF_STRING; case 5: return IfcUtil::Argument_AGGREGATE_OF_STRING; case 6: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 7: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcIdentifier; case 1: return Type::IfcLabel; case 2: return Type::IfcLabel; case 3: return Type::IfcLabel; case 4: return Type::IfcLabel; case 5: return Type::IfcLabel; case 6: return Type::IfcActorRole; case 7: return Type::IfcAddress; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Identification"; case 1: return "FamilyName"; case 2: return "GivenName"; case 3: return "MiddleNames"; case 4: return "PrefixTitles"; case 5: return "SuffixTitles"; case 6: return "Roles"; case 7: return "Addresses"; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcPersonAndOrganization >::ptr EngagedIn() const; // INVERSE IfcPersonAndOrganization::ThePerson
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPerson (IfcEntityInstanceData* e);
    IfcPerson (boost::optional< std::string > v1_Identification, boost::optional< std::string > v2_FamilyName, boost::optional< std::string > v3_GivenName, boost::optional< std::vector< std::string > /*[1:?]*/ > v4_MiddleNames, boost::optional< std::vector< std::string > /*[1:?]*/ > v5_PrefixTitles, boost::optional< std::vector< std::string > /*[1:?]*/ > v6_SuffixTitles, boost::optional< IfcTemplatedEntityList< IfcActorRole >::ptr > v7_Roles, boost::optional< IfcTemplatedEntityList< IfcAddress >::ptr > v8_Addresses);
    typedef IfcTemplatedEntityList< IfcPerson > list;
};
/// Definition: Identification of a person within an organization.
/// 
/// NOTE Corresponds to the following entity in ISO-10303-41: person_and_organization.
/// 
/// HISTORY New entity in IFC Release 1.5.1
class IFC_PARSE_API IfcPersonAndOrganization : public IfcUtil::IfcBaseEntity {
public:
    /// The person who is related to the organization.
    IfcPerson* ThePerson() const;
    void setThePerson(IfcPerson* v);
    /// The organization to which the person is related.
    IfcOrganization* TheOrganization() const;
    void setTheOrganization(IfcOrganization* v);
    /// Whether the optional attribute Roles is defined for this IfcPersonAndOrganization
    bool hasRoles() const;
    /// Roles played by the person within the context of an organization.  These may differ from the roles in ThePerson.Roles which may be asserted without organizational context.
    IfcTemplatedEntityList< IfcActorRole >::ptr Roles() const;
    void setRoles(IfcTemplatedEntityList< IfcActorRole >::ptr v);
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_ENTITY_INSTANCE; case 2: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcPerson; case 1: return Type::IfcOrganization; case 2: return Type::IfcActorRole; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "ThePerson"; case 1: return "TheOrganization"; case 2: return "Roles"; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPersonAndOrganization (IfcEntityInstanceData* e);
    IfcPersonAndOrganization (IfcPerson* v1_ThePerson, IfcOrganization* v2_TheOrganization, boost::optional< IfcTemplatedEntityList< IfcActorRole >::ptr > v3_Roles);
    typedef IfcTemplatedEntityList< IfcPersonAndOrganization > list;
};
/// The physical quantity, IfcPhysicalQuantity, is an abstract entity that holds a complex or simple quantity measure together with a semantic definition of the usage for the single or several measure value. 
/// 
/// The Name attribute defines the actual usage or kind of measure. The interpretation of the name label has to be established within the actual exchange context. In addition an informative text may be associated to each quantity by the Description attribute. 
/// 
/// HISTORY  New entity in IFC2x. It replaces the calcXxx attributes used in previous IFC Releases.
class IFC_PARSE_API IfcPhysicalQuantity : public IfcUtil::IfcBaseEntity {
public:
    /// Name of the element quantity or measure. The name attribute has to be made recognizable by further agreements.
    std::string Name() const;
    void setName(std::string v);
    /// Whether the optional attribute Description is defined for this IfcPhysicalQuantity
    bool hasDescription() const;
    /// Further explanation that might be given to the quantity.
    std::string Description() const;
    void setDescription(std::string v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_STRING; case 1: return IfcUtil::Argument_STRING; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcLabel; case 1: return Type::IfcText; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Name"; case 1: return "Description"; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcExternalReferenceRelationship >::ptr HasExternalReferences() const; // INVERSE IfcExternalReferenceRelationship::RelatedResourceObjects
    IfcTemplatedEntityList< IfcPhysicalComplexQuantity >::ptr PartOfComplex() const; // INVERSE IfcPhysicalComplexQuantity::HasQuantities
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPhysicalQuantity (IfcEntityInstanceData* e);
    IfcPhysicalQuantity (std::string v1_Name, boost::optional< std::string > v2_Description);
    typedef IfcTemplatedEntityList< IfcPhysicalQuantity > list;
};
/// The physical quantity, IfcPhysicalSimpleQuantity, is an entity that holds a single quantity measure value (as defined at the subtypes of IfcPhysicalSimpleQuantity) together with a semantic definition of the usage for the measure value. 
/// 
/// EXAMPLE  An element, like a wall, may have several area measures, like footprint area, left wall face area, right wall face area. These areas would be given by three instances of the area quantity subtype, with different Name string values.
/// 
/// A section "Quantity Use Definition" at individual entities as subtypes of IfcBuildingElement gives guidance to the usage of the Name attribute to characterize the individual quantities. If the Unit attribute is given, the value attribute (introduced at the level of subtypes of IfcPhysicalSimpleQuantity) are given as quantities of this unit, otherwise the global unit definitions (given by IfcUnitAssignment) are used.
/// 
/// HISTORY New entity in IFC2x2 Addendum 1.
/// 
/// IFC2x2 ADDENDUM 1 CHANGE  The abstract entity IfcPhysicalSimpleQuantity has been added. Upward compatibility for file based exchange is guaranteed.
class IFC_PARSE_API IfcPhysicalSimpleQuantity : public IfcPhysicalQuantity {
public:
    /// Whether the optional attribute Unit is defined for this IfcPhysicalSimpleQuantity
    bool hasUnit() const;
    /// Optional assignment of a unit. If no unit is given, then the global unit assignment, as established at the IfcProject, applies to the quantity measures.
    IfcNamedUnit* Unit() const;
    void setUnit(IfcNamedUnit* v);
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 2: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcPhysicalQuantity::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 2: return Type::IfcNamedUnit; } return IfcPhysicalQuantity::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 2: return "Unit"; } return IfcPhysicalQuantity::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPhysicalSimpleQuantity (IfcEntityInstanceData* e);
    IfcPhysicalSimpleQuantity (std::string v1_Name, boost::optional< std::string > v2_Description, IfcNamedUnit* v3_Unit);
    typedef IfcTemplatedEntityList< IfcPhysicalSimpleQuantity > list;
};
/// Definition: The address for delivery of paper based mail.
/// 
/// HISTORY New entity in IFC Release 2x.
class IFC_PARSE_API IfcPostalAddress : public IfcAddress {
public:
    /// Whether the optional attribute InternalLocation is defined for this IfcPostalAddress
    bool hasInternalLocation() const;
    /// An organization defined address for internal mail delivery.
    std::string InternalLocation() const;
    void setInternalLocation(std::string v);
    /// Whether the optional attribute AddressLines is defined for this IfcPostalAddress
    bool hasAddressLines() const;
    /// The postal address.
    /// NOTE: A postal address may occupy several lines (or elements) when recorded. 
    /// It is expected that normal usage will incorporate relevant elements of the following address concepts: 
    /// A location within a building (e.g. 3rd Floor) Building name (e.g. Interoperability House) Street number 
    /// (e.g. 6400) Street name (e.g. Alliance Boulevard). Typical content of address lines may vary in different 
    /// countries.
    std::vector< std::string > /*[1:?]*/ AddressLines() const;
    void setAddressLines(std::vector< std::string > /*[1:?]*/ v);
    /// Whether the optional attribute PostalBox is defined for this IfcPostalAddress
    bool hasPostalBox() const;
    /// An address that is implied by an identifiable mail drop.
    std::string PostalBox() const;
    void setPostalBox(std::string v);
    /// Whether the optional attribute Town is defined for this IfcPostalAddress
    bool hasTown() const;
    /// The name of a town.
    std::string Town() const;
    void setTown(std::string v);
    /// Whether the optional attribute Region is defined for this IfcPostalAddress
    bool hasRegion() const;
    /// The name of a region.
    /// NOTE: The counties of the United Kingdom and the states of North America are examples of regions.
    std::string Region() const;
    void setRegion(std::string v);
    /// Whether the optional attribute PostalCode is defined for this IfcPostalAddress
    bool hasPostalCode() const;
    /// The code that is used by the country's postal service.
    std::string PostalCode() const;
    void setPostalCode(std::string v);
    /// Whether the optional attribute Country is defined for this IfcPostalAddress
    bool hasCountry() const;
    /// The name of a country.
    std::string Country() const;
    void setCountry(std::string v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 3: return IfcUtil::Argument_STRING; case 4: return IfcUtil::Argument_AGGREGATE_OF_STRING; case 5: return IfcUtil::Argument_STRING; case 6: return IfcUtil::Argument_STRING; case 7: return IfcUtil::Argument_STRING; case 8: return IfcUtil::Argument_STRING; case 9: return IfcUtil::Argument_STRING; } return IfcAddress::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 3: return Type::IfcLabel; case 4: return Type::IfcLabel; case 5: return Type::IfcLabel; case 6: return Type::IfcLabel; case 7: return Type::IfcLabel; case 8: return Type::IfcLabel; case 9: return Type::IfcLabel; } return IfcAddress::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 3: return "InternalLocation"; case 4: return "AddressLines"; case 5: return "PostalBox"; case 6: return "Town"; case 7: return "Region"; case 8: return "PostalCode"; case 9: return "Country"; } return IfcAddress::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPostalAddress (IfcEntityInstanceData* e);
    IfcPostalAddress (boost::optional< IfcAddressTypeEnum::IfcAddressTypeEnum > v1_Purpose, boost::optional< std::string > v2_Description, boost::optional< std::string > v3_UserDefinedPurpose, boost::optional< std::string > v4_InternalLocation, boost::optional< std::vector< std::string > /*[1:?]*/ > v5_AddressLines, boost::optional< std::string > v6_PostalBox, boost::optional< std::string > v7_Town, boost::optional< std::string > v8_Region, boost::optional< std::string > v9_PostalCode, boost::optional< std::string > v10_Country);
    typedef IfcTemplatedEntityList< IfcPostalAddress > list;
};

class IFC_PARSE_API IfcPresentationItem : public IfcUtil::IfcBaseEntity {
public:
    virtual unsigned int getArgumentCount() const { return 0; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPresentationItem (IfcEntityInstanceData* e);
    IfcPresentationItem ();
    typedef IfcTemplatedEntityList< IfcPresentationItem > list;
};
/// The presentation layer assignment provides the layer name (and optionally a description and an identifier) for a collection of geometric representation items. The IfcPresentationLayerAssignment corresponds to the term "CAD Layer" and is used mainly for grouping and visibility control.
/// 
/// NOTE  The use of presentation layer shall be restricted to simple grouping and displaying purposes.
/// 
/// Visibility and access control and layer style assignment (colour, line style, line width) is handled by the subtype IfcPresentationLayerAssignmentWithStyle.
/// 
/// NOTE  Corresponding ISO 10303 name: presentation layer assignment. Please refer to ISO/IS 10303-46:1994, p. 36 for the final definition of the formal standard.
/// 
/// HISTORY  New entity in IFC2x2.
/// 
/// Attribute use definition
/// 
/// Figure 305 illustrates assignment of items by shape representation or representation item. The set of AssignedItems can either include a whole shape representation, or individual geometric representation items. If both, the IfcShapeRepresentation has a layer assignment, and an individual geometric representation item in the set of IfcShapeRepresentation.Items, then the layer assignment of the IfcGeometricRepresentationItem overides the layer assignment of the IfcShapeRepresentation.
/// 
/// Figure 305 — Presentation layer assignment
class IFC_PARSE_API IfcPresentationLayerAssignment : public IfcUtil::IfcBaseEntity {
public:
    /// Name of the layer.
    std::string Name() const;
    void setName(std::string v);
    /// Whether the optional attribute Description is defined for this IfcPresentationLayerAssignment
    bool hasDescription() const;
    /// Additional description of the layer.
    std::string Description() const;
    void setDescription(std::string v);
    /// The set of layered items, which are assigned to this layer.
    IfcEntityList::ptr AssignedItems() const;
    void setAssignedItems(IfcEntityList::ptr v);
    /// Whether the optional attribute Identifier is defined for this IfcPresentationLayerAssignment
    bool hasIdentifier() const;
    /// An (internal) identifier assigned to the layer.
    std::string Identifier() const;
    void setIdentifier(std::string v);
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_STRING; case 1: return IfcUtil::Argument_STRING; case 2: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 3: return IfcUtil::Argument_STRING; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcLabel; case 1: return Type::IfcText; case 2: return Type::IfcLayeredItem; case 3: return Type::IfcIdentifier; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Name"; case 1: return "Description"; case 2: return "AssignedItems"; case 3: return "Identifier"; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPresentationLayerAssignment (IfcEntityInstanceData* e);
    IfcPresentationLayerAssignment (std::string v1_Name, boost::optional< std::string > v2_Description, IfcEntityList::ptr v3_AssignedItems, boost::optional< std::string > v4_Identifier);
    typedef IfcTemplatedEntityList< IfcPresentationLayerAssignment > list;
};
/// An IfcPresentationLayerAssignmentWithStyle extends the presentation layer assignment with capabilities to define visibility control, access control and common style information.
/// 
/// The visibility control allows to define a layer to be either 'on' or 'off', and/or 'frozen' or 'not frozen'. The access control allows to block graphical entities from manipulations by setting a layer to be either 'blocked' or 'not blocked'. Common style information can be given to the layer.
/// 
/// NOTE  Style information assigned to layers is often restricted to 'layer colour', 'curve font', and/or 'curve width'. These styles are assigned by using the IfcCurveStyle within the LayerStyles.
/// 
/// NOTE: If a styled item is assigned to a layer using the IfcPresentationLayerAssignmentWithStyle, it inherits the style information from the layer. In this case, it should omit its own style information. If the styled item has style information assigned (such as by IfcCurveStyle, IfcFillAreaStyle, IfcTextStyle, IfcSurfaceStyle, IfcSymbolStyle), then it overrides the style provided by the IfcPresentationLayerAssignmentWithStyle.
/// 
/// NOTE  The IfcPresentationLayerAssignmentWithStyle extends the presentation_layer_assignment entity as defined in ISO/IS 10303-46:1994, p. 36.
/// 
/// HISTORY  New entity in IFC2x2.
/// 
/// IFC2x3 CHANGE  The attributes have been modified without upward compatibility.
class IFC_PARSE_API IfcPresentationLayerWithStyle : public IfcPresentationLayerAssignment {
public:
    /// A logical setting, TRUE indicates that the layer is set to 'On', FALSE that the layer is set to 'Off', UNKNOWN that such information is not available.
    bool LayerOn() const;
    void setLayerOn(bool v);
    /// A logical setting, TRUE indicates that the layer is set to 'Frozen', FALSE that the layer is set to 'Not frozen', UNKNOWN that such information is not available.
    bool LayerFrozen() const;
    void setLayerFrozen(bool v);
    /// A logical setting, TRUE indicates that the layer is set to 'Blocked', FALSE that the layer is set to 'Not blocked', UNKNOWN that such information is not available.
    bool LayerBlocked() const;
    void setLayerBlocked(bool v);
    /// Assignment of presentation styles to the layer to provide a default style for representation items.
    /// 
    /// NOTE  In most cases the assignment of styles to a layer is restricted to an IfcCurveStyle representing the layer curve colour, layer curve thickness, and layer curve type.
    /// 
    /// IFC2x4 CHANGE  The data type has been changed from IfcPresentationStyleSelect (now deprecated) to IfcPresentationStyle.
    IfcTemplatedEntityList< IfcPresentationStyle >::ptr LayerStyles() const;
    void setLayerStyles(IfcTemplatedEntityList< IfcPresentationStyle >::ptr v);
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 4: return IfcUtil::Argument_BOOL; case 5: return IfcUtil::Argument_BOOL; case 6: return IfcUtil::Argument_BOOL; case 7: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } return IfcPresentationLayerAssignment::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 4: return Type::IfcLogical; case 5: return Type::IfcLogical; case 6: return Type::IfcLogical; case 7: return Type::IfcPresentationStyle; } return IfcPresentationLayerAssignment::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 4: return "LayerOn"; case 5: return "LayerFrozen"; case 6: return "LayerBlocked"; case 7: return "LayerStyles"; } return IfcPresentationLayerAssignment::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPresentationLayerWithStyle (IfcEntityInstanceData* e);
    IfcPresentationLayerWithStyle (std::string v1_Name, boost::optional< std::string > v2_Description, IfcEntityList::ptr v3_AssignedItems, boost::optional< std::string > v4_Identifier, bool v5_LayerOn, bool v6_LayerFrozen, bool v7_LayerBlocked, IfcTemplatedEntityList< IfcPresentationStyle >::ptr v8_LayerStyles);
    typedef IfcTemplatedEntityList< IfcPresentationLayerWithStyle > list;
};
/// IfcPresentationStyle is an abstract generalization of style table for presentation information assigned to geometric representation items. It includes styles for curves, areas, surfaces, text and symbols. Style information may include colour, hatching, rendering, and text fonts.
/// 
/// Each subtype of  IfcPresentationStyle can be assigned to IfcGeometricRepresentationItem's via the IfcPresentationStyleAssignment through an intermediate IfcStyledItem or one of its subtypes.
/// 
/// HISTORY  New entity in IFC2x3.
class IFC_PARSE_API IfcPresentationStyle : public IfcUtil::IfcBaseEntity {
public:
    /// Whether the optional attribute Name is defined for this IfcPresentationStyle
    bool hasName() const;
    /// Name of the presentation style.
    std::string Name() const;
    void setName(std::string v);
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_STRING; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcLabel; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Name"; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPresentationStyle (IfcEntityInstanceData* e);
    IfcPresentationStyle (boost::optional< std::string > v1_Name);
    typedef IfcTemplatedEntityList< IfcPresentationStyle > list;
};
/// Definition from ISO/CD 10303-46:1992: The presentation style assignment is a set of styles which are assigned to styled items for the purpose of presenting these styled items. 
/// 
/// NOTE Corresponding ISO 10303 name: presentation_style_assignment. Please refer to ISO/IS 10303-46:1994 for the final definition of the formal standard.
/// 
/// HISTORY New entity in Release IFC2x2.
class IFC_PARSE_API IfcPresentationStyleAssignment : public IfcUtil::IfcBaseEntity {
public:
    /// A set of presentation styles that are assigned to styled items.
    IfcEntityList::ptr Styles() const;
    void setStyles(IfcEntityList::ptr v);
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcPresentationStyleSelect; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Styles"; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPresentationStyleAssignment (IfcEntityInstanceData* e);
    IfcPresentationStyleAssignment (IfcEntityList::ptr v1_Styles);
    typedef IfcTemplatedEntityList< IfcPresentationStyleAssignment > list;
};
/// IfcProductRepresentation defines a representation of a
/// product, including its (geometric or topological) representation.
/// A product can have zero, one or many geometric representations,
/// and a single geometric representation can be shared among various
/// products using mapped representations.
/// 
/// NOTE: The definition
/// of this entity relates to the ISO 10303 entity property_definition.
/// The use of the term ‘property’ was avoided since it
/// conflicts with the property, property type, and property set
/// definitions elsewhere in the IFC model.
/// 
/// HISTORY New entity in IFC Release 2.0
/// 
/// IFC2x3 NOTE ÿUsers should not instantiate the entity from IFC2x Edition 3 onwards.
/// 
/// IFC2x4 CHANGE  Entity made abstract.
class IFC_PARSE_API IfcProductRepresentation : public IfcUtil::IfcBaseEntity {
public:
    /// Whether the optional attribute Name is defined for this IfcProductRepresentation
    bool hasName() const;
    /// The word or group of words by which the product representation is known.
    std::string Name() const;
    void setName(std::string v);
    /// Whether the optional attribute Description is defined for this IfcProductRepresentation
    bool hasDescription() const;
    /// The word or group of words that characterize the product representation. It can be used to add additional meaning to the name of the product representation.
    std::string Description() const;
    void setDescription(std::string v);
    /// Contained list of representations (including shape representations). Each member defines a valid representation of a particular type within a particular representation context.
    IfcTemplatedEntityList< IfcRepresentation >::ptr Representations() const;
    void setRepresentations(IfcTemplatedEntityList< IfcRepresentation >::ptr v);
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_STRING; case 1: return IfcUtil::Argument_STRING; case 2: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcLabel; case 1: return Type::IfcText; case 2: return Type::IfcRepresentation; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Name"; case 1: return "Description"; case 2: return "Representations"; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcProductRepresentation (IfcEntityInstanceData* e);
    IfcProductRepresentation (boost::optional< std::string > v1_Name, boost::optional< std::string > v2_Description, IfcTemplatedEntityList< IfcRepresentation >::ptr v3_Representations);
    typedef IfcTemplatedEntityList< IfcProductRepresentation > list;
};
/// IfcProfileDef
/// is the supertype of all definitions of standard and arbitrary profiles
/// within IFC. It is used to define a standard set of commonly used
/// section profiles by their parameters or by their explicit curve geometry.
/// 
/// Parameterized profiles are 2D primitives, which are used within the industry to describe cross
///   sections by a description of its parameters.
///   Arbitrary profiles are cross
///   sections defined by an outer boundary as bounded curve, which may also
///   include holes, defined by inner boundaries.
///   Derived profiles, based on a
///   transformation of a parent profile, are also part of the profile
///   definitions available.
///   In addition composite
///   profiles can be defined, which include two or more profile definitions
///   to define the resulting profile.
/// 
/// HISTORY  New class in IFC Release 1.5, the capabilities have been extended in IFC Release 2x.
/// Profiles can now support swept surfaces and swept area solids with
/// inner boundaries. It had been renamed from IfcAttDrivenProfileDef.
/// 
/// IFC2x4 CHANGE  Changed from ABSTRACT to non-abstract for uses which do not
/// require an explicitly defined geometry.  Added inverse attributes HasProperties and HasExternalReference.
/// 
/// Use in material association
/// 
/// Beams, columns, and similarly shaped building elements and their type objects may
/// be associated with a section profile definition, combined with material definition,
/// by means of IfcRelAssociatesMaterial together with IfcMaterialProfileSet
/// and IfcMaterialProfileSetUsage. This way, building elements and element types
/// with same section and material can share a common section profile definition and
/// association.
/// 
/// The profile definition in material association is required to be consistent with
/// shape representations of the respective building elements.
/// 
/// A higher-level description of spatial aligment of the section profile of a member
/// (such as centered, bottom-left, in the geometric centroid, and more) can be provided
/// within IfcMaterialProfileSetUsage by means of a cardinal point reference.
/// This can be used redundant to geometric data in order to convey design intent.
/// 
/// Use in shape models
/// 
/// Profile definitions are used within the geometry and geometric model
/// resource to create either swept surfaces, swept area solids, or
/// sectioned spines.
/// 
/// The purpose of the profile
/// definition within the swept surfaces or swept area solids is to define
/// a uniform cross section being swept:
/// 
/// along a line (extrusion) using IfcSurfaceOfLinearExtrusion or IfcExtrudedAreaSolid
///   along a circular arc (revolution) using IfcSurfaceOfRevolution or IfcRevolvedAreaSolid
///   along a directrix lying on a reference surface using IfcSurfaceCurveSweptAreaSolid
/// 
/// The purpose fo the profile
/// definition within the sectioned spine is to define a varying cross
/// sections at several positions along a spine curve. The subtype IfcDerivedProfileDef
/// is particularly suited to provide the consecutive profiles to be based
/// on transformations of the start profile and thus maintaining the
/// identity of vertices and edges.
/// 
/// NOTE  Subtypes of the IfcProfileDef
/// contain parameterized profiles (as subtypes of IfcParameterizedProfileDef)
/// which establish their own 2D position coordinate system, profiles given
/// by explicit curve geometry (either open or closed profiles) and two
/// special types for composite profiles and derived profiles, based on a
/// 2D Cartesian transformation.
/// 
/// An IfcProfileDef
/// is treated as bounded area if it is used within swept area solids. In
/// this case, the inside of the profile is part of the profile. The
/// attribute ProfileType is set to AREA. An IfcProfileDef
/// is treated as a curve if it is used within swept surfaces. In this
/// case, the inside of the profile (if the curve is closed) is not part of
/// the profile. The attribute ProfileType
/// is set to CURVE.
/// 
/// Figure 320 illustrates use of parameterized profiles within a swept area solid.
/// 
/// Position
/// The IfcProfileDef is defined within the underlying
/// coordinate system which is defined by the swept surface or swept area solid
/// that uses the profile definition. It is the xy plane
/// 
/// of IfcSweptSurface.Position or
///   of IfcSweptAreaSolid.Position or
///   of each list member of IfcSectionedSpine.CrossSectionPositions.
/// 
/// In the figure to the left, the z axis of the position coordinate system points outwards of the drawing plane.
/// 
/// Note: The subtype IfcParameterizedProfileDef optionally provides an additional 2D position coordinate system relative to the underlying coordinate system of the IfcProfileDef.
/// 
/// Sweeping
/// 
/// In the later use of the IfcProfileDef
/// within the swept surface or swept area solid,  e.g. the IfcExtrudedAreaSolid
/// (here used as an example), the profile boundaries (here based on the 2D
/// position coordinate system of IfcParameterizedProfileDef)
/// are placed within the xy plane of the 3D position coordinate system of
/// the swept surface or swept area solid.
/// 
/// The profile is inserted into the underlying coordinate system either:
/// 
/// directly in case of using IfcArbitraryClosedProfileDef
///   and IfcArbitraryOpenProfileDef,
/// 
/// through an intermediate position coordinate system in case of
///   using IfcParameterizedProfileDef.
/// 
/// through an 2D Cartesian transformation operator (applied directly
///   to the curve position when using arbitrary profile definitions,
///   or applied to the position coordinate system when using parameterized
///   profile definitions) in case of using IfcDerivedProfileDef.
/// 
/// when using IfcCompositeProfileDef the insertion depends on
///   the subtype of the included sub-profiles.
/// 
/// Figure 320 — Profile sweeping
/// 
/// Profile types
/// 
/// Results of the different usage of the ProfileType attribute are demonstrated here. The ProfileType defines whether the inside (the bounded area) is part of the profile definition (Area) or not (Curve). Figure 321 illustrates the resulting area or curve depending on ProfileType.
/// 
/// ProfileType = AREA
/// 
/// ProfileType = CURVE
/// 
/// Figure 321 — Profile types
/// 
/// Profile specification by external reference
/// 
/// If the profile is standardized by a norm or a catalogue, a reference
/// to this norm or catalogue should be provided by means of HasExternalReference.
/// This inverse relationship is used to associate an IfcExternalReference (notably
/// IfcClassificationReference or IfcLibraryReference) with the
/// profile.
/// 
/// IfcClassificationReference is used to refer to a profile norm (a common standard or
/// manufacturer's standard).  In this case,
/// 
/// IfcClassificationReference.ItemReference
/// contains the formal profile designation from the norm.
/// (On the other hand, IfcProfileDef.ProfileName contains a displayable name which may
/// not necessarily be the same as the formal designation.)
/// IfcClassificationReference.Name carries the short name of the profile norm.
/// Optionally, the norm can be further described by
/// IfcClassificationReference.ReferencedSource.
/// 
/// IfcLibraryReference is used to refer to a library which contains profile
/// definitions. In this case,
/// 
/// IfcLibraryReference.ItemReference contains the identifier of the
/// profile within the library and is meant to be machine-readable (in contrast to
/// IfcProfileDef.ProfileName which should be human-readable).
/// IfcLibraryReference.Location and .Name or .ReferencedLibrary
/// further describe the library.
/// 
/// If an external reference is provided, sending systems shall ensure that
/// the shape of the profile definition object agrees with the definitions in the
/// referenced classification or library.
/// 
/// Direct instances of IfcProfileDef
/// 
/// Usually, only subtypes of IfcProfileDef should be instantiated.
/// In some special cases, e.g. if the profile object is used for purposes
/// other than geometric models (e.g. for structural analysis models), it may be
/// possible to directly instantiate IfcProfileDef and further specify
/// the profile only by external reference or by profile properties. The latter
/// are tracked by the inverse attribute HasProperties.
class IFC_PARSE_API IfcProfileDef : public IfcUtil::IfcBaseEntity {
public:
    /// Defines the type of geometry into which this profile definition shall be resolved, either a curve or a surface area. In case of curve the profile should be referenced by a swept surface, in case of area the profile should be referenced by a swept area solid.
    IfcProfileTypeEnum::IfcProfileTypeEnum ProfileType() const;
    void setProfileType(IfcProfileTypeEnum::IfcProfileTypeEnum v);
    /// Whether the optional attribute ProfileName is defined for this IfcProfileDef
    bool hasProfileName() const;
    /// Human-readable name of the profile, for example according to a standard profile table. As noted above, machine-readable standardized profile designations should be provided in IfcExternalReference.ItemReference.
    std::string ProfileName() const;
    void setProfileName(std::string v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENUMERATION; case 1: return IfcUtil::Argument_STRING; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcProfileTypeEnum; case 1: return Type::IfcLabel; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "ProfileType"; case 1: return "ProfileName"; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcExternalReferenceRelationship >::ptr HasExternalReference() const; // INVERSE IfcExternalReferenceRelationship::RelatedResourceObjects
    IfcTemplatedEntityList< IfcProfileProperties >::ptr HasProperties() const; // INVERSE IfcProfileProperties::ProfileDefinition
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcProfileDef (IfcEntityInstanceData* e);
    IfcProfileDef (IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< std::string > v2_ProfileName);
    typedef IfcTemplatedEntityList< IfcProfileDef > list;
};
/// Definition from OpenGIS® Abstract Specification,
///   Topic 2: A 2D (or with vertical coordinate axis 3D)
///   coordinate reference system used to approximate the shape
///   of the earth on a planar surface, but in such a way that
///   the distortion that is inherent to the approximation is
///   carefully controlled and known. Distortion correction is
///   commonly applied to calculated bearings and distances to
///   produce values that are a close match to actual field
///   values.
///   IfcProjectedCRS is a coordinate reference system of
///   the map to which the map translation of the local
///   engineering coordinate system of the construction or
///   facility engineering project relates. The
///   MapProjection and MapZone attributes uniquely
///   identify the projection to the underlying geographic
///   coordinate reference system, provided that they are
///   well-known in the receiving application.
///   The projected coordinate reference system is assumed to be
///   a 2D or 3D right-handed Cartesian coordinate system, the
///   optional MapUnit attribute can be used determine the
///   length unit used by the map.
/// 
/// HISTORY  New entity in IFC2x4.
class IFC_PARSE_API IfcProjectedCRS : public IfcCoordinateReferenceSystem {
public:
    /// Whether the optional attribute MapProjection is defined for this IfcProjectedCRS
    bool hasMapProjection() const;
    /// Name by which the map projection is identified.
    /// 
    /// UTM
    ///   Gaus-Krueger
    std::string MapProjection() const;
    void setMapProjection(std::string v);
    /// Whether the optional attribute MapZone is defined for this IfcProjectedCRS
    bool hasMapZone() const;
    /// Name by which the map zone, relating to the MapProjection, is identified. Examples are
    /// 
    /// for UTM, the zone number, like 32 for UTM32
    ///   for Gaus-Krueger, the zones of longitudinal width, like 3'
    std::string MapZone() const;
    void setMapZone(std::string v);
    /// Whether the optional attribute MapUnit is defined for this IfcProjectedCRS
    bool hasMapUnit() const;
    /// Unit of the coordinate axes composing the map coordinate system.
    /// NOTE  Only length measures are in scope and all two or three axes of the map coordinate system shall have the same length unit.
    IfcNamedUnit* MapUnit() const;
    void setMapUnit(IfcNamedUnit* v);
    virtual unsigned int getArgumentCount() const { return 7; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 4: return IfcUtil::Argument_STRING; case 5: return IfcUtil::Argument_STRING; case 6: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcCoordinateReferenceSystem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 4: return Type::IfcIdentifier; case 5: return Type::IfcIdentifier; case 6: return Type::IfcNamedUnit; } return IfcCoordinateReferenceSystem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 4: return "MapProjection"; case 5: return "MapZone"; case 6: return "MapUnit"; } return IfcCoordinateReferenceSystem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcProjectedCRS (IfcEntityInstanceData* e);
    IfcProjectedCRS (std::string v1_Name, boost::optional< std::string > v2_Description, boost::optional< std::string > v3_GeodeticDatum, boost::optional< std::string > v4_VerticalDatum, boost::optional< std::string > v5_MapProjection, boost::optional< std::string > v6_MapZone, IfcNamedUnit* v7_MapUnit);
    typedef IfcTemplatedEntityList< IfcProjectedCRS > list;
};

class IFC_PARSE_API IfcPropertyAbstraction : public IfcUtil::IfcBaseEntity {
public:
    virtual unsigned int getArgumentCount() const { return 0; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcExternalReferenceRelationship >::ptr HasExternalReferences() const; // INVERSE IfcExternalReferenceRelationship::RelatedResourceObjects
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPropertyAbstraction (IfcEntityInstanceData* e);
    IfcPropertyAbstraction ();
    typedef IfcTemplatedEntityList< IfcPropertyAbstraction > list;
};
/// IfcPropertyEnumeration is a collection of simple
/// or measure values that define a prescribed set of alternatives from
/// which 'enumeration values' are selected. This enables inclusion of
/// enumeration values in property sets. IfcPropertyEnumeration
/// provides a name for the enumeration as well as a list of unique
/// (numeric or descriptive) values (that may have a measure type
/// assigned). The entity defines the list of potential enumerators to be
/// exchanged together (or separately) with properties of type IfcPropertyEnumeratedValue
/// that selects their actual property values from this enumeration. 
/// The unit is handled by the Unit attribute:
/// 
/// If the Unit attribute is not given,
/// than the unit is already implied by the type of IfcMeasureValue
/// or IfcDerivedMeasureValue. The associated unit can
/// be found at the IfcUnitAssignment globally defined
/// at the project level (IfcProject.UnitsInContext).
///   If the Unit attribute is given, the
/// unit assigned by the unit attribute overrides the globally assigned
/// unit.
/// 
/// Name
///   EnumerationValues
///   Type (through IfcValue)
///   Unit
/// 
/// PEnum_DamperBladeAction
///   Parallel
///   IfcString
///   -
/// 
///  
///   Opposed
///   IfcString
///    
/// 
///  
///   Other
///   IfcString
///    
/// 
///  
///   Unset
///   IfcString
///    
/// 
/// HISTORY  New Entity in IFC Release 2.0, capabilities enhanced in IFC Release 2x. Entity has been renamed from IfcEnumeration in IFC Release 2x.
class IFC_PARSE_API IfcPropertyEnumeration : public IfcPropertyAbstraction {
public:
    /// Name of this enumeration.
    std::string Name() const;
    void setName(std::string v);
    /// List of values that form the enumeration.
    IfcEntityList::ptr EnumerationValues() const;
    void setEnumerationValues(IfcEntityList::ptr v);
    /// Whether the optional attribute Unit is defined for this IfcPropertyEnumeration
    bool hasUnit() const;
    /// Unit for the enumerator values, if not given, the default value for the measure type (given by the TYPE of nominal value) is used as defined by the global unit assignment at IfcProject.
    IfcUnit* Unit() const;
    void setUnit(IfcUnit* v);
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_STRING; case 1: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 2: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcPropertyAbstraction::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcLabel; case 1: return Type::IfcValue; case 2: return Type::IfcUnit; } return IfcPropertyAbstraction::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Name"; case 1: return "EnumerationValues"; case 2: return "Unit"; } return IfcPropertyAbstraction::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPropertyEnumeration (IfcEntityInstanceData* e);
    IfcPropertyEnumeration (std::string v1_Name, IfcEntityList::ptr v2_EnumerationValues, IfcUnit* v3_Unit);
    typedef IfcTemplatedEntityList< IfcPropertyEnumeration > list;
};
/// IfcQuantityArea is a physical quantity that defines a derived area measure to provide an element's physical property. It is normally derived from the physical properties of the element under the specific measure rules given by a method of measurement. 
/// 
/// EXAMPLE  An opening may have an opening area used to deduct it from the wall surface area. The actual size of the area depends on the method of measurement used.
/// 
/// HISTORY  New entity in IFC2x. It replaces the calcXxx attributes used in previous IFC Releases.
class IFC_PARSE_API IfcQuantityArea : public IfcPhysicalSimpleQuantity {
public:
    /// Area measure value of this quantity.
    double AreaValue() const;
    void setAreaValue(double v);
    /// Whether the optional attribute Formula is defined for this IfcQuantityArea
    bool hasFormula() const;
    /// A formula by which the quantity has been calculated. It can be assigned in addition to the actual value of the quantity. Formulas could be mathematic calculations (like width x height), database links, or a combination. The formula is for informational purposes only.
    /// 
    /// IFC2x4 CHANGE  Attribute added to the end of the attribute list.
    std::string Formula() const;
    void setFormula(std::string v);
    virtual unsigned int getArgumentCount() const { return 5; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 3: return IfcUtil::Argument_DOUBLE; case 4: return IfcUtil::Argument_STRING; } return IfcPhysicalSimpleQuantity::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 3: return Type::IfcAreaMeasure; case 4: return Type::IfcLabel; } return IfcPhysicalSimpleQuantity::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 3: return "AreaValue"; case 4: return "Formula"; } return IfcPhysicalSimpleQuantity::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcQuantityArea (IfcEntityInstanceData* e);
    IfcQuantityArea (std::string v1_Name, boost::optional< std::string > v2_Description, IfcNamedUnit* v3_Unit, double v4_AreaValue, boost::optional< std::string > v5_Formula);
    typedef IfcTemplatedEntityList< IfcQuantityArea > list;
};
/// IfcQuantityCount is a physical quantity that defines a derived count measure to provide an element's physical property. It is normally derived from the physical properties of the element under the specific measure rules given by a method of measurement.
/// 
/// EXAMPLE  An radiator may be measured according to its number of coils. The actual counting method depends on the method of measurement used.
/// 
/// HISTORY  New entity in IFC2x. It replaces the calcXxx attributes used in previous IFC Releases.
class IFC_PARSE_API IfcQuantityCount : public IfcPhysicalSimpleQuantity {
public:
    /// Count measure value of this quantity.
    double CountValue() const;
    void setCountValue(double v);
    /// Whether the optional attribute Formula is defined for this IfcQuantityCount
    bool hasFormula() const;
    /// A formula by which the quantity has been calculated. It can be assigned in addition to the actual value of the quantity. Formulas could be mathematic calculations (like width x height), database links, or a combination. The formula is for informational purposes only.
    /// 
    /// IFC2x4 CHANGE  Attribute added to the end of the attribute list.
    std::string Formula() const;
    void setFormula(std::string v);
    virtual unsigned int getArgumentCount() const { return 5; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 3: return IfcUtil::Argument_DOUBLE; case 4: return IfcUtil::Argument_STRING; } return IfcPhysicalSimpleQuantity::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 3: return Type::IfcCountMeasure; case 4: return Type::IfcLabel; } return IfcPhysicalSimpleQuantity::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 3: return "CountValue"; case 4: return "Formula"; } return IfcPhysicalSimpleQuantity::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcQuantityCount (IfcEntityInstanceData* e);
    IfcQuantityCount (std::string v1_Name, boost::optional< std::string > v2_Description, IfcNamedUnit* v3_Unit, double v4_CountValue, boost::optional< std::string > v5_Formula);
    typedef IfcTemplatedEntityList< IfcQuantityCount > list;
};
/// IfcQuantityLength is a physical quantity that defines a derived length measure to provide an element's physical property. It is normally derived from the physical properties of the element under the specific measure rules given by a method of measurement.
/// 
/// EXAMPLE  A rafter within a roof construction may be measured according to its length (taking a common cross section into account). The actual size of the length depends on the method of measurement used.
/// 
/// HISTORY  New entity in IFC Release 2.x. It replaces the calcXxx attributes used in previous IFC Releases.
class IFC_PARSE_API IfcQuantityLength : public IfcPhysicalSimpleQuantity {
public:
    /// Length measure value of this quantity.
    double LengthValue() const;
    void setLengthValue(double v);
    /// Whether the optional attribute Formula is defined for this IfcQuantityLength
    bool hasFormula() const;
    /// A formula by which the quantity has been calculated. It can be assigned in addition to the actual value of the quantity. Formulas could be mathematic calculations (like width x height), database links, or a combination. The formula is for informational purposes only.
    /// 
    /// IFC2x4 CHANGE  Attribute added to the end of the attribute list.
    std::string Formula() const;
    void setFormula(std::string v);
    virtual unsigned int getArgumentCount() const { return 5; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 3: return IfcUtil::Argument_DOUBLE; case 4: return IfcUtil::Argument_STRING; } return IfcPhysicalSimpleQuantity::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 3: return Type::IfcLengthMeasure; case 4: return Type::IfcLabel; } return IfcPhysicalSimpleQuantity::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 3: return "LengthValue"; case 4: return "Formula"; } return IfcPhysicalSimpleQuantity::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcQuantityLength (IfcEntityInstanceData* e);
    IfcQuantityLength (std::string v1_Name, boost::optional< std::string > v2_Description, IfcNamedUnit* v3_Unit, double v4_LengthValue, boost::optional< std::string > v5_Formula);
    typedef IfcTemplatedEntityList< IfcQuantityLength > list;
};
/// IfcQuantityTime is an element quantity that defines a time measure to provide an property of time related to an element. It is normally given by the recipe information of the element under the specific measure rules given by a method of measurement.
/// 
/// EXAMPLE  The amount of time needed to pour concrete for a wall is given as a time quantity for the labor part of the recipe information.
/// 
/// HISTORY  New entity in IFC2x2.
class IFC_PARSE_API IfcQuantityTime : public IfcPhysicalSimpleQuantity {
public:
    /// Time measure value of this quantity.
    double TimeValue() const;
    void setTimeValue(double v);
    /// Whether the optional attribute Formula is defined for this IfcQuantityTime
    bool hasFormula() const;
    /// A formula by which the quantity has been calculated. It can be assigned in addition to the actual value of the quantity. Formulas could be mathematic calculations (like width x height), database links, or a combination. The formula is for informational purposes only.
    /// 
    /// IFC2x4 CHANGE  Attribute added to the end of the attribute list.
    std::string Formula() const;
    void setFormula(std::string v);
    virtual unsigned int getArgumentCount() const { return 5; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 3: return IfcUtil::Argument_DOUBLE; case 4: return IfcUtil::Argument_STRING; } return IfcPhysicalSimpleQuantity::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 3: return Type::IfcTimeMeasure; case 4: return Type::IfcLabel; } return IfcPhysicalSimpleQuantity::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 3: return "TimeValue"; case 4: return "Formula"; } return IfcPhysicalSimpleQuantity::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcQuantityTime (IfcEntityInstanceData* e);
    IfcQuantityTime (std::string v1_Name, boost::optional< std::string > v2_Description, IfcNamedUnit* v3_Unit, double v4_TimeValue, boost::optional< std::string > v5_Formula);
    typedef IfcTemplatedEntityList< IfcQuantityTime > list;
};
/// IfcQuantityVolume is a physical quantity that defines a derived volume measure to provide an element's physical property. It is normally derived from the physical properties of the element under the specific measure rules given by a method of measurement. 
/// 
/// EXAMPLE  A thick brick wall may be measured according to its volume. The actual size of the volume depends on the method of measurement used.
/// 
/// HISTORY New entity in IFC2x. It replaces the calcXxx attributes used in previous IFC Releases.
class IFC_PARSE_API IfcQuantityVolume : public IfcPhysicalSimpleQuantity {
public:
    /// Volume measure value of this quantity.
    double VolumeValue() const;
    void setVolumeValue(double v);
    /// Whether the optional attribute Formula is defined for this IfcQuantityVolume
    bool hasFormula() const;
    /// A formula by which the quantity has been calculated. It can be assigned in addition to the actual value of the quantity. Formulas could be mathematic calculations (like width x height), database links, or a combination. The formula is for informational purposes only.
    /// 
    /// IFC2x4 CHANGE  Attribute added to the end of the attribute list.
    std::string Formula() const;
    void setFormula(std::string v);
    virtual unsigned int getArgumentCount() const { return 5; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 3: return IfcUtil::Argument_DOUBLE; case 4: return IfcUtil::Argument_STRING; } return IfcPhysicalSimpleQuantity::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 3: return Type::IfcVolumeMeasure; case 4: return Type::IfcLabel; } return IfcPhysicalSimpleQuantity::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 3: return "VolumeValue"; case 4: return "Formula"; } return IfcPhysicalSimpleQuantity::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcQuantityVolume (IfcEntityInstanceData* e);
    IfcQuantityVolume (std::string v1_Name, boost::optional< std::string > v2_Description, IfcNamedUnit* v3_Unit, double v4_VolumeValue, boost::optional< std::string > v5_Formula);
    typedef IfcTemplatedEntityList< IfcQuantityVolume > list;
};
/// IfcQuantityWeight is a physical element quantity that defines a derived weight measure to provide an element's physical property. It is normally derived from the physical properties of the element under the specific measure rules given by a method of measurement. 
/// 
/// EXAMPLE  The amount of reinforcement used within a building element may be measured according to its weight. The actual size of the weight depends on the method of measurement used.
/// 
/// HISTORY  New entity in IFC2x. It replaces the calcXxx attributes used in previous IFC Releases.
class IFC_PARSE_API IfcQuantityWeight : public IfcPhysicalSimpleQuantity {
public:
    /// Mass measure value of this quantity.
    double WeightValue() const;
    void setWeightValue(double v);
    /// Whether the optional attribute Formula is defined for this IfcQuantityWeight
    bool hasFormula() const;
    /// A formula by which the quantity has been calculated. It can be assigned in addition to the actual value of the quantity. Formulas could be mathematic calculations (like width x height), database links, or a combination. The formula is for informational purposes only.
    /// 
    /// IFC2x4 CHANGE  Attribute added to the end of the attribute list.
    std::string Formula() const;
    void setFormula(std::string v);
    virtual unsigned int getArgumentCount() const { return 5; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 3: return IfcUtil::Argument_DOUBLE; case 4: return IfcUtil::Argument_STRING; } return IfcPhysicalSimpleQuantity::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 3: return Type::IfcMassMeasure; case 4: return Type::IfcLabel; } return IfcPhysicalSimpleQuantity::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 3: return "WeightValue"; case 4: return "Formula"; } return IfcPhysicalSimpleQuantity::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcQuantityWeight (IfcEntityInstanceData* e);
    IfcQuantityWeight (std::string v1_Name, boost::optional< std::string > v2_Description, IfcNamedUnit* v3_Unit, double v4_WeightValue, boost::optional< std::string > v5_Formula);
    typedef IfcTemplatedEntityList< IfcQuantityWeight > list;
};
/// IfcRecurrencePattern defines repetitive time periods on the basis of regular recurrences such as each Monday in a week, or every third Tuesday in a month.  The population of the remaining attributes such as DayComponent, Position, and Interval depend on the specified recurrence type.
/// 
/// HISTORY: New entity in IFC2x4.
/// 
/// Use definitions
/// IfcRecurrencePattern supports various recurrence patterns that are differentiated by a type definition (IfcRecurrencePattern.RecurrenceType), which is required to provide the meaning of the given values. It can be further constrained by applicable times through specified IfcTimePeriod instances, thus enabling time periods such as between 7:00 and 12:00 and between 13:00 and 17:00 for each of the applicable days, weeks or months.
class IFC_PARSE_API IfcRecurrencePattern : public IfcUtil::IfcBaseEntity {
public:
    /// Defines the recurrence type that gives meaning to the used
    ///   attributes and decides about possible attribute
    ///   combinations, i.e. what attributes are needed to fully
    ///   describe the pattern type.
    IfcRecurrenceTypeEnum::IfcRecurrenceTypeEnum RecurrenceType() const;
    void setRecurrenceType(IfcRecurrenceTypeEnum::IfcRecurrenceTypeEnum v);
    /// Whether the optional attribute DayComponent is defined for this IfcRecurrencePattern
    bool hasDayComponent() const;
    /// The position of the specified day in a month.
    std::vector< int > /*[1:?]*/ DayComponent() const;
    void setDayComponent(std::vector< int > /*[1:?]*/ v);
    /// Whether the optional attribute WeekdayComponent is defined for this IfcRecurrencePattern
    bool hasWeekdayComponent() const;
    /// The weekday name of the specified day in a week.
    std::vector< int > /*[1:?]*/ WeekdayComponent() const;
    void setWeekdayComponent(std::vector< int > /*[1:?]*/ v);
    /// Whether the optional attribute MonthComponent is defined for this IfcRecurrencePattern
    bool hasMonthComponent() const;
    /// The position of the specified month in a year.
    std::vector< int > /*[1:?]*/ MonthComponent() const;
    void setMonthComponent(std::vector< int > /*[1:?]*/ v);
    /// Whether the optional attribute Position is defined for this IfcRecurrencePattern
    bool hasPosition() const;
    /// The position of the specified component, e.g. the 3rd
    ///   (position=3) Tuesday (weekday component) in a month. A
    ///   negative position value is used to define the last position 
    ///   of the component (-1), the next to last position (-2) etc.
    int Position() const;
    void setPosition(int v);
    /// Whether the optional attribute Interval is defined for this IfcRecurrencePattern
    bool hasInterval() const;
    /// An interval can be given according to the pattern type. An
    ///   interval value of 2 can for instance every two days, weeks,
    ///   months, years. An empty interval value is regarded as 1. The
    ///   used interval values should be in a reasonable range, e.g.
    ///   not 0 or <0.
    int Interval() const;
    void setInterval(int v);
    /// Whether the optional attribute Occurrences is defined for this IfcRecurrencePattern
    bool hasOccurrences() const;
    /// Defines the number of occurrences of this pattern, e.g. a weekly 
    ///   event might be defined to occur 5 times before it stops.
    int Occurrences() const;
    void setOccurrences(int v);
    /// Whether the optional attribute TimePeriods is defined for this IfcRecurrencePattern
    bool hasTimePeriods() const;
    /// List of time periods that are defined by a start and end time
    ///   of the recurring element (day). The order of the list should
    ///   reflect the sequence of the time periods.
    IfcTemplatedEntityList< IfcTimePeriod >::ptr TimePeriods() const;
    void setTimePeriods(IfcTemplatedEntityList< IfcTimePeriod >::ptr v);
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENUMERATION; case 1: return IfcUtil::Argument_AGGREGATE_OF_INT; case 2: return IfcUtil::Argument_AGGREGATE_OF_INT; case 3: return IfcUtil::Argument_AGGREGATE_OF_INT; case 4: return IfcUtil::Argument_INT; case 5: return IfcUtil::Argument_INT; case 6: return IfcUtil::Argument_INT; case 7: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcRecurrenceTypeEnum; case 1: return Type::IfcDayInMonthNumber; case 2: return Type::IfcDayInWeekNumber; case 3: return Type::IfcMonthInYearNumber; case 4: return Type::IfcInteger; case 5: return Type::IfcInteger; case 6: return Type::IfcInteger; case 7: return Type::IfcTimePeriod; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "RecurrenceType"; case 1: return "DayComponent"; case 2: return "WeekdayComponent"; case 3: return "MonthComponent"; case 4: return "Position"; case 5: return "Interval"; case 6: return "Occurrences"; case 7: return "TimePeriods"; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRecurrencePattern (IfcEntityInstanceData* e);
    IfcRecurrencePattern (IfcRecurrenceTypeEnum::IfcRecurrenceTypeEnum v1_RecurrenceType, boost::optional< std::vector< int > /*[1:?]*/ > v2_DayComponent, boost::optional< std::vector< int > /*[1:?]*/ > v3_WeekdayComponent, boost::optional< std::vector< int > /*[1:?]*/ > v4_MonthComponent, boost::optional< int > v5_Position, boost::optional< int > v6_Interval, boost::optional< int > v7_Occurrences, boost::optional< IfcTemplatedEntityList< IfcTimePeriod >::ptr > v8_TimePeriods);
    typedef IfcTemplatedEntityList< IfcRecurrencePattern > list;
};

class IFC_PARSE_API IfcReference : public IfcUtil::IfcBaseEntity {
public:
    /// Whether the optional attribute TypeIdentifier is defined for this IfcReference
    bool hasTypeIdentifier() const;
    std::string TypeIdentifier() const;
    void setTypeIdentifier(std::string v);
    /// Whether the optional attribute AttributeIdentifier is defined for this IfcReference
    bool hasAttributeIdentifier() const;
    std::string AttributeIdentifier() const;
    void setAttributeIdentifier(std::string v);
    /// Whether the optional attribute InstanceName is defined for this IfcReference
    bool hasInstanceName() const;
    std::string InstanceName() const;
    void setInstanceName(std::string v);
    /// Whether the optional attribute ListPositions is defined for this IfcReference
    bool hasListPositions() const;
    std::vector< int > /*[1:?]*/ ListPositions() const;
    void setListPositions(std::vector< int > /*[1:?]*/ v);
    /// Whether the optional attribute InnerReference is defined for this IfcReference
    bool hasInnerReference() const;
    IfcReference* InnerReference() const;
    void setInnerReference(IfcReference* v);
    virtual unsigned int getArgumentCount() const { return 5; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_STRING; case 1: return IfcUtil::Argument_STRING; case 2: return IfcUtil::Argument_STRING; case 3: return IfcUtil::Argument_AGGREGATE_OF_INT; case 4: return IfcUtil::Argument_ENTITY_INSTANCE; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcIdentifier; case 1: return Type::IfcIdentifier; case 2: return Type::IfcLabel; case 3: return Type::IfcInteger; case 4: return Type::IfcReference; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "TypeIdentifier"; case 1: return "AttributeIdentifier"; case 2: return "InstanceName"; case 3: return "ListPositions"; case 4: return "InnerReference"; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcReference (IfcEntityInstanceData* e);
    IfcReference (boost::optional< std::string > v1_TypeIdentifier, boost::optional< std::string > v2_AttributeIdentifier, boost::optional< std::string > v3_InstanceName, boost::optional< std::vector< int > /*[1:?]*/ > v4_ListPositions, IfcReference* v5_InnerReference);
    typedef IfcTemplatedEntityList< IfcReference > list;
};
/// Definition from ISO/CD 10303-43:1992: A
///   representation is one or more representation items that are
///   related in a specified representation context as the
///   representation of some concept.
/// 
/// IfcRepresentation
///   defines the general concept of representing product
///   properties.
/// 
/// Representation Use Definition
/// 
/// Each representation, either IfcShapeRepresentation, or
///   IfcTopologyRepresentation shall have a well defined:
/// 
/// ContextOfItems: Reference to an
///   IfcGeometricRepresentationContext as agreed for 
///   this representation.
/// 
/// RepresentationIdentifier: Name of the
///   representation, for example, 'Body' for 3D shape, 'FootPrint' for
///   2D ground view, 'Axis' for reference axis.
/// 
/// RepresentationType: Name for the geometric, or
///   topological representation type, for example, 'SweptSolid' for 3D
///   swept solids, 'Brep' for boundary representation.
/// 
/// Values and guidelines for these three items are provided in
///   the geometry use definition section at each subtype of
///   IfcElement, or in view definitions / implementer
///   agreements.
/// 
/// NOTE ÿThe definition of this
///   entity relates to the ISO 10303 entity representation. Please
///   refer to ISO/IS 10303-43:1994 for the final definition of
///   the formal standard.
/// 
/// HISTORY  New entity in IFC Release 2.0
/// 
/// IFC2x3 CHANGE  The
///   inverse attributes LayerAssignments
///   andRepresentationMap have been added with upward
///   compatibility.
/// 
/// IFC2x4 CHANGE  Entity
///   IfcRepresentation has been changed into an ABSTRACT
///   supertype.
class IFC_PARSE_API IfcRepresentation : public IfcUtil::IfcBaseEntity {
public:
    /// Definition of the representation context for which the different subtypes of representation are valid.
    IfcRepresentationContext* ContextOfItems() const;
    void setContextOfItems(IfcRepresentationContext* v);
    /// Whether the optional attribute RepresentationIdentifier is defined for this IfcRepresentation
    bool hasRepresentationIdentifier() const;
    /// The optional identifier of the representation as used within a project.
    std::string RepresentationIdentifier() const;
    void setRepresentationIdentifier(std::string v);
    /// Whether the optional attribute RepresentationType is defined for this IfcRepresentation
    bool hasRepresentationType() const;
    /// The description of the type of a representation context. The representation type defines the type of geometry or topology used for representing the product representation. More information is given at the subtypes IfcShapeRepresentation and IfcTopologyRepresentation.
    /// The supported values for context type are to be specified by implementers agreements.
    std::string RepresentationType() const;
    void setRepresentationType(std::string v);
    /// Set of geometric representation items that are defined for this representation.
    IfcTemplatedEntityList< IfcRepresentationItem >::ptr Items() const;
    void setItems(IfcTemplatedEntityList< IfcRepresentationItem >::ptr v);
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_STRING; case 2: return IfcUtil::Argument_STRING; case 3: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcRepresentationContext; case 1: return Type::IfcLabel; case 2: return Type::IfcLabel; case 3: return Type::IfcRepresentationItem; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "ContextOfItems"; case 1: return "RepresentationIdentifier"; case 2: return "RepresentationType"; case 3: return "Items"; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcRepresentationMap >::ptr RepresentationMap() const; // INVERSE IfcRepresentationMap::MappedRepresentation
    IfcTemplatedEntityList< IfcPresentationLayerAssignment >::ptr LayerAssignments() const; // INVERSE IfcPresentationLayerAssignment::AssignedItems
    IfcTemplatedEntityList< IfcProductRepresentation >::ptr OfProductRepresentation() const; // INVERSE IfcProductRepresentation::Representations
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRepresentation (IfcEntityInstanceData* e);
    IfcRepresentation (IfcRepresentationContext* v1_ContextOfItems, boost::optional< std::string > v2_RepresentationIdentifier, boost::optional< std::string > v3_RepresentationType, IfcTemplatedEntityList< IfcRepresentationItem >::ptr v4_Items);
    typedef IfcTemplatedEntityList< IfcRepresentation > list;
};
/// Definition from ISO/CD 10303-42:1992: A representation context is a context in which a set of representation items are related.
/// 
/// The IfcRepresentationContext defines the context to which the IfcRepresentation of a product is related.
/// 
/// NOTE  The definition of this class relates to the ISO 10303 entity representation_context. Please refer to ISO/IS 10303-43:1994 for the final definition of the formal standard.
/// 
/// HISTORY  New entity in IFC Release 1.5.
/// 
/// IFC2x4 CHANGE Entity made abstract, had been deprecated from instantiation since
/// IFC2x2.
class IFC_PARSE_API IfcRepresentationContext : public IfcUtil::IfcBaseEntity {
public:
    /// Whether the optional attribute ContextIdentifier is defined for this IfcRepresentationContext
    bool hasContextIdentifier() const;
    /// The optional identifier of the representation context as used within a project.
    std::string ContextIdentifier() const;
    void setContextIdentifier(std::string v);
    /// Whether the optional attribute ContextType is defined for this IfcRepresentationContext
    bool hasContextType() const;
    /// The description of the type of a representation context. The supported values for context type are to be specified by implementers agreements.
    std::string ContextType() const;
    void setContextType(std::string v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_STRING; case 1: return IfcUtil::Argument_STRING; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcLabel; case 1: return Type::IfcLabel; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "ContextIdentifier"; case 1: return "ContextType"; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcRepresentation >::ptr RepresentationsInContext() const; // INVERSE IfcRepresentation::ContextOfItems
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRepresentationContext (IfcEntityInstanceData* e);
    IfcRepresentationContext (boost::optional< std::string > v1_ContextIdentifier, boost::optional< std::string > v2_ContextType);
    typedef IfcTemplatedEntityList< IfcRepresentationContext > list;
};
/// Definition from ISO/CD
/// 10303-43:1992: A representation item is an element of
/// product data that participates in one or more representations or
/// contributes to the definition of another representation item. A
/// representation item contributes to the definition of another
/// representation item when it is referenced by that representation
/// item.
/// 
/// NOTE  Corresponding entity in ISO 10303-43:1994: representation_item. Please refer to ISO/IS 10303-43:1994, for the final definition of the formal standard. The following changes have been made: The attribute 'name' and the WR1 have not been incorporated.
/// 
/// The IfcRepresentationItem is used within an IfcRepresentation (directly or indirectly through other IfcRepresentationItem's) to represent an IfcProductRepresentation. Most commonly these IfcRepresentationItem's are geometric or topological representation items, that can (but not need to) have presentation style infomation assigned.
/// 
/// NOTE  The assignment of a style is only applicable
/// to the subtypes IfcGeometricRepresentationItem, IfcMappedItem and some selected subtypes of IfcTopologicalRepresentationItem (IfcVertexPoint, IfcEdgeCurve, IfcFaceSurface).
/// 
/// In case that presentation style information is applied, it can be either applied by an IfcStyledItem, or by an assignment to an IfcPresentationLayerWithStyle. If both are present, and both style assignments include the same subtype of IfcPresentationStyle, then the style assigned by IfcStyledItem takes priority.
/// 
/// Figure 281 shows an instance diagram explaining the use of IfcStyledItem and IfcPresentationLayerWithStyle to apply presentation styles.
/// 
/// EXAMPLE  The assignment of style information by a styled item and a presentation layer with style. Since the presentation styles are different, IfcCurveStyle and IfcSurfaceStyle, both are applied to the geometric representation item.
/// 
/// Figure 281 — Representation item style
/// 
/// Figure 282 shows in instance diagram explaining the override of IfcPresentationLayerWithStyle by IfcStyledItem to apply presentation styles.
/// 
/// EXAMPLE  The assignment of style information by a styled item and a presentation layer with style. Since the presentation styles for curve style are aprovided by both, the IfcCurveStyle provided by the IfcStyledItem overrides the IfcCurveStyle provided by the IfcPresentationLayerWithStyle
/// 
/// Figure 282 — Representation item style override
/// 
/// HISTORY  New entity in IFC Release 2x.
/// 
/// IFC2x3 CHANGE  The inverse attributes StyledByItem and LayerAssignments have been added. Upward compatibility for file based exchange is guaranteed.
class IFC_PARSE_API IfcRepresentationItem : public IfcUtil::IfcBaseEntity {
public:
    virtual unsigned int getArgumentCount() const { return 0; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcPresentationLayerAssignment >::ptr LayerAssignment() const; // INVERSE IfcPresentationLayerAssignment::AssignedItems
    IfcTemplatedEntityList< IfcStyledItem >::ptr StyledByItem() const; // INVERSE IfcStyledItem::Item
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRepresentationItem (IfcEntityInstanceData* e);
    IfcRepresentationItem ();
    typedef IfcTemplatedEntityList< IfcRepresentationItem > list;
};
/// Definition from ISO/CD 10303-43:1992: A representation map is the identification of a representation and a representation item in that representation for the purpose of mapping. The representation item defines the origin of the mapping. The representation map is used as the source of a mapping by a mapped item.
/// 
/// NOTE  Corresponding ISO 10303 entity: representation_map. Please refer to ISO/IS 10303-43:1994, for the final definition of the formal standard. The following changes have been made: The mapping_origin (MappingOrigin) is constrained to be of type axis2_placement (IfcAxis2Placement).
/// 
/// An IfcRepresentationMap defines the base definition (also referred to as block, cell or macro) called MappedRepresentation within the MappingOrigin. The MappingOrigin defines the coordinate system in which the MappedRepresentation is defined.
/// 
/// The RepresentationMap is used through an IfcMappeditem in one or several IfcShapeRepresentation's. An Cartesian transformation operator can be applied to transform the MappedRepresentation into the placement coordinate system of the shape representation. The transformation of the representation map is restricted to be a Cartesian transformation mapping (translation, rotation, mirroring and scaling).
/// 
/// NOTE  The definition of a mapping which is used to specify a new representation item comprises a representation map and a mapped item entity. Without both entities, the mapping is not fully defined. Two entities are specified to allow the same source representation to be mapped into multiple new representations.
/// 
/// HISTORY  New entity in IFC Release 2x.
class IFC_PARSE_API IfcRepresentationMap : public IfcUtil::IfcBaseEntity {
public:
    /// An axis2 placement that defines the position about which the mapped
    /// representation is mapped.
    IfcAxis2Placement* MappingOrigin() const;
    void setMappingOrigin(IfcAxis2Placement* v);
    /// A representation that is mapped to at least one mapped item.
    IfcRepresentation* MappedRepresentation() const;
    void setMappedRepresentation(IfcRepresentation* v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_ENTITY_INSTANCE; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcAxis2Placement; case 1: return Type::IfcRepresentation; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "MappingOrigin"; case 1: return "MappedRepresentation"; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcShapeAspect >::ptr HasShapeAspects() const; // INVERSE IfcShapeAspect::PartOfProductDefinitionShape
    IfcTemplatedEntityList< IfcMappedItem >::ptr MapUsage() const; // INVERSE IfcMappedItem::MappingSource
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRepresentationMap (IfcEntityInstanceData* e);
    IfcRepresentationMap (IfcAxis2Placement* v1_MappingOrigin, IfcRepresentation* v2_MappedRepresentation);
    typedef IfcTemplatedEntityList< IfcRepresentationMap > list;
};
/// IfcResourceLevelRelationship is an abstract base class for relationships between resource-level entities.
/// 
/// HISTORY New Entity in IFC 2x4
class IFC_PARSE_API IfcResourceLevelRelationship : public IfcUtil::IfcBaseEntity {
public:
    /// Whether the optional attribute Name is defined for this IfcResourceLevelRelationship
    bool hasName() const;
    /// A name used to identify or qualify the relationship.
    std::string Name() const;
    void setName(std::string v);
    /// Whether the optional attribute Description is defined for this IfcResourceLevelRelationship
    bool hasDescription() const;
    /// A description that may apply additional information about the relationship.
    std::string Description() const;
    void setDescription(std::string v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_STRING; case 1: return IfcUtil::Argument_STRING; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcLabel; case 1: return Type::IfcText; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Name"; case 1: return "Description"; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcResourceLevelRelationship (IfcEntityInstanceData* e);
    IfcResourceLevelRelationship (boost::optional< std::string > v1_Name, boost::optional< std::string > v2_Description);
    typedef IfcTemplatedEntityList< IfcResourceLevelRelationship > list;
};
/// IfcRoot is the most abstract and root class for all IFC entity definitions that roots in the kernel or in subsequent layers of the IFC object model. It is therefore the common supertype of all IFC entities, beside those defined in an IFC resource schema. All entities that are subtypes of IfcRoot can be used independently, whereas resource schema entities, that are not subtypes of IfcRoot, are not supposed to be independent entities.
/// 
/// IfcRoot assigns the globally unique ID, and the ownership and history information to the entity. In addition it may provide for a name and a description about the concept.
/// 
/// NOTE View definitions and implementation agreement may impose additional restrictions on the use of the OwnerHistory to handle object versioning.
/// 
/// HISTORY New entity in IFC Release 1.0
/// 
/// IFC2x4 CHANGE The attribute OwnerHistory has been made OPTIONAL.
class IFC_PARSE_API IfcRoot : public IfcUtil::IfcBaseEntity {
public:
    /// Assignment of a globally unique identifier within the entire software world.
    std::string GlobalId() const;
    void setGlobalId(std::string v);
    /// Whether the optional attribute OwnerHistory is defined for this IfcRoot
    bool hasOwnerHistory() const;
    /// Assignment of the information about the current ownership of that object, including owning actor, application, local identification and information captured about the recent changes of the object, 
    /// 
    /// NOTE only the last modification in stored - either as addition, deletion or modification.
    /// 
    /// IFC2x4 CHANGE  The attribute has been changed to be OPTIONAL.
    IfcOwnerHistory* OwnerHistory() const;
    void setOwnerHistory(IfcOwnerHistory* v);
    /// Whether the optional attribute Name is defined for this IfcRoot
    bool hasName() const;
    /// Optional name for use by the participating software systems or users. For some subtypes of IfcRoot the insertion of the Name attribute may be required. This would be enforced by a where rule.
    std::string Name() const;
    void setName(std::string v);
    /// Whether the optional attribute Description is defined for this IfcRoot
    bool hasDescription() const;
    /// Optional description, provided for exchanging informative comments.
    std::string Description() const;
    void setDescription(std::string v);
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_STRING; case 1: return IfcUtil::Argument_ENTITY_INSTANCE; case 2: return IfcUtil::Argument_STRING; case 3: return IfcUtil::Argument_STRING; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcGloballyUniqueId; case 1: return Type::IfcOwnerHistory; case 2: return Type::IfcLabel; case 3: return Type::IfcText; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "GlobalId"; case 1: return "OwnerHistory"; case 2: return "Name"; case 3: return "Description"; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRoot (IfcEntityInstanceData* e);
    IfcRoot (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description);
    typedef IfcTemplatedEntityList< IfcRoot > list;
};
/// Definition from ISO/CD 10303-41:1992: An SI unit is the fixed quantity used as a standard in terms of which items are measured as defined by ISO 1000 (clause 2).
/// 
/// IfcSIUnit covers both standard base SI units such as meter and second, and derived SI units such as Pascal, square meter and cubic meter.
/// 
/// NOTE Corresponding ISO 10303 name: si_unit, please refer to ISO/IS 10303-41 for the final definition of the formal standard.
/// 
/// HISTORY New entity in IFC Release 1.5.1.
class IFC_PARSE_API IfcSIUnit : public IfcNamedUnit {
public:
    /// Whether the optional attribute Prefix is defined for this IfcSIUnit
    bool hasPrefix() const;
    /// The SI Prefix for defining decimal multiples and submultiples of the unit.
    IfcSIPrefix::IfcSIPrefix Prefix() const;
    void setPrefix(IfcSIPrefix::IfcSIPrefix v);
    /// The word, or group of words, by which the SI unit is referred to.
    /// 
    /// NOTE  Even though the SI system's base unit for mass is kilogram, the IfcSIUnit for mass is gram if no Prefix is asserted.
    IfcSIUnitName::IfcSIUnitName Name() const;
    void setName(IfcSIUnitName::IfcSIUnitName v);
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_DERIVED; case 2: return IfcUtil::Argument_ENUMERATION; case 3: return IfcUtil::Argument_ENUMERATION; } return IfcNamedUnit::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 2: return Type::IfcSIPrefix; case 3: return Type::IfcSIUnitName; } return IfcNamedUnit::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 2: return "Prefix"; case 3: return "Name"; } return IfcNamedUnit::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcSIUnit (IfcEntityInstanceData* e);
    IfcSIUnit (IfcUnitEnum::IfcUnitEnum v2_UnitType, boost::optional< IfcSIPrefix::IfcSIPrefix > v3_Prefix, IfcSIUnitName::IfcSIUnitName v4_Name);
    typedef IfcTemplatedEntityList< IfcSIUnit > list;
};
/// IfcSchedulingTime is the abstract supertype of entities that capture time-related information of processes.
/// 
/// HISTORY: New entity in IFC2x4.
class IFC_PARSE_API IfcSchedulingTime : public IfcUtil::IfcBaseEntity {
public:
    /// Whether the optional attribute Name is defined for this IfcSchedulingTime
    bool hasName() const;
    /// Optional name for the time definition.
    std::string Name() const;
    void setName(std::string v);
    /// Whether the optional attribute DataOrigin is defined for this IfcSchedulingTime
    bool hasDataOrigin() const;
    /// Specifies the origin of the scheduling time entity. It currently
    ///   differentiates between predicted, simulated, measured, and user defined values.
    IfcDataOriginEnum::IfcDataOriginEnum DataOrigin() const;
    void setDataOrigin(IfcDataOriginEnum::IfcDataOriginEnum v);
    /// Whether the optional attribute UserDefinedDataOrigin is defined for this IfcSchedulingTime
    bool hasUserDefinedDataOrigin() const;
    /// Value of the data origin if DataOrigin attribute is USERDEFINED.
    std::string UserDefinedDataOrigin() const;
    void setUserDefinedDataOrigin(std::string v);
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_STRING; case 1: return IfcUtil::Argument_ENUMERATION; case 2: return IfcUtil::Argument_STRING; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcLabel; case 1: return Type::IfcDataOriginEnum; case 2: return Type::IfcLabel; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Name"; case 1: return "DataOrigin"; case 2: return "UserDefinedDataOrigin"; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcSchedulingTime (IfcEntityInstanceData* e);
    IfcSchedulingTime (boost::optional< std::string > v1_Name, boost::optional< IfcDataOriginEnum::IfcDataOriginEnum > v2_DataOrigin, boost::optional< std::string > v3_UserDefinedDataOrigin);
    typedef IfcTemplatedEntityList< IfcSchedulingTime > list;
};
/// Definition from ISO/CD 10303-41:1992: The shape
///   aspect is an identifiable element of the shape of a
///   product.
/// 
/// IfcShapeAspect
///   allows for grouping of shape representation items that
///   represent aspects (or components) of the shape of a
///   product. Thereby shape representations of components of the
///   product shape represent a distinctive part to a product
///   that can be explicitly addressed.
/// 
/// NOTE ÿThe definition of
///   this class relates to the ISO 10303 entity shape_aspect. Please
///   refer to ISO/IS 10303-41:1994 for the final definition of
///   the formal standard.
/// 
/// HISTORY  New Entity in IFC Release 2.0
/// 
/// IFC 2x4 CHANGE  Attribute
///   PartOfProductDefinitionShape declared OPTIONAL with 
///   upward compatibility for file based exchange.
/// 
/// Informal propositions:
/// 
/// If ShapeRepresentations points to shape
///   representations that are part of an
///   IfcProductDefinitionShape,
///   PartOfProductDefinitionShape must refer to this
///   instance of IfcProductDefinitionShape.
/// 
/// NOTEÿ PartOfProductDefinitionShape is
///   only to be omitted if the shape representations are
///   attached to an IfcRepresentationMap. ÿThis
///   enables the use of IfcShapeAspect with
///   IfcRepresentationMap's that are used by an
///   IfcTypeProduct through the
///   RepresentationMaps attribute.
class IFC_PARSE_API IfcShapeAspect : public IfcUtil::IfcBaseEntity {
public:
    /// List of shape representations. Each member defines a valid representation of a particular type within a particular representation context as being an aspect (or part) of a product definition.
    /// IFC2x Edition 3 CHANGE  The data type has been changed from IfcShapeRepresentation to IfcShapeModel with upward compatibility
    IfcTemplatedEntityList< IfcShapeModel >::ptr ShapeRepresentations() const;
    void setShapeRepresentations(IfcTemplatedEntityList< IfcShapeModel >::ptr v);
    /// Whether the optional attribute Name is defined for this IfcShapeAspect
    bool hasName() const;
    /// The word or group of words by which the shape aspect is known. It is a tag to indicate the particular semantic of a component within the product definition shape, used to provide meaning. Example: use the tag "Glazing" to define which component of a window shape defines the glazing area.
    std::string Name() const;
    void setName(std::string v);
    /// Whether the optional attribute Description is defined for this IfcShapeAspect
    bool hasDescription() const;
    /// The word or group of words that characterize the shape aspect. It can be used to add additional meaning to the name of the aspect.
    std::string Description() const;
    void setDescription(std::string v);
    /// An indication that the shape aspect is on the physical boundary of the product definition shape. If the value of this attribute is TRUE, it shall be asserted that the shape aspect being identified is on such a boundary. If the value is FALSE, it shall be asserted that the shape aspect being identified is not on such a boundary. If the value is UNKNOWN, it shall be asserted that it is not known whether or not the shape aspect being identified is on such a boundary. 
    /// ---
    /// EXAMPLE: Would be FALSE for a center line, identified as shape aspect; would be TRUE for a cantilever.
    /// ---
    bool ProductDefinitional() const;
    void setProductDefinitional(bool v);
    /// Whether the optional attribute PartOfProductDefinitionShape is defined for this IfcShapeAspect
    bool hasPartOfProductDefinitionShape() const;
    /// Reference to the product definition shape of which this class is an aspect.
    IfcProductRepresentationSelect* PartOfProductDefinitionShape() const;
    void setPartOfProductDefinitionShape(IfcProductRepresentationSelect* v);
    virtual unsigned int getArgumentCount() const { return 5; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_STRING; case 2: return IfcUtil::Argument_STRING; case 3: return IfcUtil::Argument_BOOL; case 4: return IfcUtil::Argument_ENTITY_INSTANCE; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcShapeModel; case 1: return Type::IfcLabel; case 2: return Type::IfcText; case 3: return Type::IfcLogical; case 4: return Type::IfcProductRepresentationSelect; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "ShapeRepresentations"; case 1: return "Name"; case 2: return "Description"; case 3: return "ProductDefinitional"; case 4: return "PartOfProductDefinitionShape"; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcShapeAspect (IfcEntityInstanceData* e);
    IfcShapeAspect (IfcTemplatedEntityList< IfcShapeModel >::ptr v1_ShapeRepresentations, boost::optional< std::string > v2_Name, boost::optional< std::string > v3_Description, bool v4_ProductDefinitional, IfcProductRepresentationSelect* v5_PartOfProductDefinitionShape);
    typedef IfcTemplatedEntityList< IfcShapeAspect > list;
};
/// IfcShapeModel represents
/// the concept of a particular geometric and/or topological
/// representation of a product's shape or a product component's shape
/// within a representation context. This representation context has to
/// be a geometric representation context (with the exception of
/// topology representations without associated geometry). The two
/// subtypes are IfcShapeRepresentation to cover geometric
/// models that represent a shape, and IfcTopologyRepresentation
/// to cover the conectivity of a product or product component. The
/// topology may or may not have geometry associated.
/// 
/// The IfcShapeModel can be a shape representation
/// (geometric and/or topologogical) of a product (via
/// IfcProductDefinitionShape), or a shape representation
/// (geometric and/or topologogical)  of a component of a product
/// shape (via IfcShapeAspect).
/// 
/// HISTORY  New entity in IFC2x3.
class IFC_PARSE_API IfcShapeModel : public IfcRepresentation {
public:
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcRepresentation::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcRepresentation::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcRepresentation::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcShapeAspect >::ptr OfShapeAspect() const; // INVERSE IfcShapeAspect::ShapeRepresentations
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcShapeModel (IfcEntityInstanceData* e);
    IfcShapeModel (IfcRepresentationContext* v1_ContextOfItems, boost::optional< std::string > v2_RepresentationIdentifier, boost::optional< std::string > v3_RepresentationType, IfcTemplatedEntityList< IfcRepresentationItem >::ptr v4_Items);
    typedef IfcTemplatedEntityList< IfcShapeModel > list;
};
/// The IfcShapeRepresentation represents the concept of a
/// particular geometric representation of a product or a product
/// component within a specific geometric representation context. The
/// inherited attribute RepresentationType is used to define
/// the geometric model used for the shape representation (for example, 
/// 'SweptSolid', or 'Brep'), the inherited attribute
/// RepresentationIdentifier is used to denote the part of the
/// representation captured by the IfcShapeRepresentation
/// (for example, 'Axis', 'Body').
/// 
/// Several representation identifiers for shape representation are
/// included as predefined values for RepresentationIdentifier:
/// 
/// Box
/// Bounding box as simplified 3D box
/// geometry of an element
/// 
/// Annotation
/// 2D annotations not representing
/// elements
/// 
/// Axis
/// 2D or 3D Axis, or single line,
/// representation of an element
/// 
/// FootPrint
/// 2D Foot print, or double line,
/// representation of an element, projected to ground view
/// 
/// Surface
/// 3D Surface representation, e.g. of an
/// analytical surface, of an elementplane)
/// 
/// Body
/// 3D Body representation, e.g. as
/// wireframe, surface, or solid model, of an element
/// 
/// Lighting
/// Representation of emitting light as a
/// light source within a shape representation
/// 
/// Several representation types for shape representation are
/// included as predefined values for RepresentationType:
/// 
/// Curve2D
/// 2 dimensional curve
/// 
/// Curve3D
/// 3 dimensional curve
/// 
/// Surface2D
/// 2 dimensional surface (a region on
/// ground view)
/// 
/// Surface3D
/// 3 dimensional surface
/// 
/// GeometricSet
/// points, curves, surfaces (2 or 3
/// dimensional)
/// 
/// GeometricCurveSet
/// points, curves (2 or 3
/// dimensional)
/// 
/// Annotation2D
/// points, curves (2 or 3 dimensional), hatches and text (2
/// dimensional)
/// 
/// SurfaceModel
/// face based and shell based surface
/// model
/// 
/// SolidModel
/// including swept solid, Boolean
/// results and Brep bodies
/// more specific types are:
/// 
/// SweptSolid
/// swept area solids, by extrusion and
/// revolution, excluding tapered sweeps
/// 
/// AdvancedSweptSolid
/// swept area solids created by sweeping
/// a profile along a directrix, and tapered sweeps
/// 
/// Brep
/// faceted Brep's with and without
/// voids
/// 
/// AdvancedBrep
/// Brep's based on advanced faces, with
/// b-spline surface geometry, with and without voids
/// 
/// CSG
/// Boolean results of operations between
/// solid models, half spaces and Boolean results
/// 
/// Clipping
/// Boolean differences between swept
/// area solids, half spaces and Boolean results
/// 
/// additional types
/// 
/// some additional representation types are provided:
/// 
/// BoundingBox
/// simplistic 3D representation by a
/// bounding box
/// 
/// SectionedSpine
/// cross section based representation of
/// a spine curve and planar cross sections. It can represent a surface
/// or a solid and the interpolations of the between the cross sections
/// is not defined
/// 
/// LightSource
/// light source with (depending on type)
/// position, orientation, light colour, intensity and attenuation
/// 
/// MappedRepresentation
/// representation based on mapped
/// item(s), referring to a representation map. Note: it can be seen as
/// an inserted block reference. The shape representation of the mapped
/// item has a representation type declaring the type of its
/// representation items.
/// 
/// Table 1: string values for the inherited attribute
/// 'RepresentationType'.
/// 
/// NOTE  The definition of this entity relates to the ISO 10303 entity shape_representation. Please refer to ISO/IS 10303-41:1994 for the final definition of the formal standard.
/// 
/// HISTORY  New entity in IFC Release 1.5.
/// 
/// IFC2x4 CHANGE  The RepresentationType's 'Curve3D', 'Surface2D', 'Surface3D', 'AdvancedBrep', 'LightSource', and the RepresentationIdentifier 'Lighting' have been added.
class IFC_PARSE_API IfcShapeRepresentation : public IfcShapeModel {
public:
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcShapeModel::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcShapeModel::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcShapeModel::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcShapeRepresentation (IfcEntityInstanceData* e);
    IfcShapeRepresentation (IfcRepresentationContext* v1_ContextOfItems, boost::optional< std::string > v2_RepresentationIdentifier, boost::optional< std::string > v3_RepresentationType, IfcTemplatedEntityList< IfcRepresentationItem >::ptr v4_Items);
    typedef IfcTemplatedEntityList< IfcShapeRepresentation > list;
};
/// Definition from IAI: Describe more rarely needed connection properties.
/// 
/// HISTORY: New entity in IFC 2x2.
class IFC_PARSE_API IfcStructuralConnectionCondition : public IfcUtil::IfcBaseEntity {
public:
    /// Whether the optional attribute Name is defined for this IfcStructuralConnectionCondition
    bool hasName() const;
    /// Optionally defines a name for this connection condition.
    std::string Name() const;
    void setName(std::string v);
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_STRING; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcLabel; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Name"; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcStructuralConnectionCondition (IfcEntityInstanceData* e);
    IfcStructuralConnectionCondition (boost::optional< std::string > v1_Name);
    typedef IfcTemplatedEntityList< IfcStructuralConnectionCondition > list;
};
/// Definition from IAI: The abstract entity IfcStructuralLoadOrResult is the supertype of all loads (actions or reactions) or of certain requirements resulting from structural analysis, or certain provisions which influence structural analysis.
/// 
/// HISTORY: New entity in IFC 2x2.
class IFC_PARSE_API IfcStructuralLoad : public IfcUtil::IfcBaseEntity {
public:
    /// Whether the optional attribute Name is defined for this IfcStructuralLoad
    bool hasName() const;
    /// Optionally defines a name for this load.
    std::string Name() const;
    void setName(std::string v);
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_STRING; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcLabel; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Name"; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcStructuralLoad (IfcEntityInstanceData* e);
    IfcStructuralLoad (boost::optional< std::string > v1_Name);
    typedef IfcTemplatedEntityList< IfcStructuralLoad > list;
};
/// Definition from IAI: This class combines one or more load or result values in a 1- or 2-dimensional configuration.
/// 
/// HISTORY: New entity in IFC 2x4.
/// 
/// Informal propositions:
/// 
/// All items in Values shall be of the same type.
///   If the loads or results comprise a curve activity, 1-dimensional locations shall be given, measured locally along the curve.  The location shall not exceed the bounds of the curve actvity.  The load samples and corresponding locations shall be given in ascending order of locations.
///   If the loads or results comprise a surface activity, 2-dimensional locations shall be given, measured in the surface activity's local x and y directions.  The location shall not exceed the bounds of the surface activity.
/// 
/// NOTE  There are no ordering requirements in the 2-dimensional case, but the 1-dimensional case shall be spatially ordered for simplicity.
class IFC_PARSE_API IfcStructuralLoadConfiguration : public IfcStructuralLoad {
public:
    /// List of load or result values.
    IfcTemplatedEntityList< IfcStructuralLoadOrResult >::ptr Values() const;
    void setValues(IfcTemplatedEntityList< IfcStructuralLoadOrResult >::ptr v);
    /// Whether the optional attribute Locations is defined for this IfcStructuralLoadConfiguration
    bool hasLocations() const;
    /// Locations of the load samples or result samples, given within the local coordinate system defined by the instance which uses this resource object.  Each item in the list of locations pertains to the values list item at the same list index.  This attribute is optional for configurations in which the locations are implicitly known from higher-level definitions.
    std::vector< std::vector< double > > Locations() const;
    void setLocations(std::vector< std::vector< double > > v);
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 1: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 2: return IfcUtil::Argument_AGGREGATE_OF_AGGREGATE_OF_DOUBLE; } return IfcStructuralLoad::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 1: return Type::IfcStructuralLoadOrResult; case 2: return Type::IfcLengthMeasure; } return IfcStructuralLoad::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 1: return "Values"; case 2: return "Locations"; } return IfcStructuralLoad::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcStructuralLoadConfiguration (IfcEntityInstanceData* e);
    IfcStructuralLoadConfiguration (boost::optional< std::string > v1_Name, IfcTemplatedEntityList< IfcStructuralLoadOrResult >::ptr v2_Values, boost::optional< std::vector< std::vector< double > > > v3_Locations);
    typedef IfcTemplatedEntityList< IfcStructuralLoadConfiguration > list;
};
/// Definition from IAI: Abstract superclass of simple load or result classes.
/// 
/// HISTORY: New abstract superclass in IFC 2x4, upwards compatibility of all subtypes is preserved.
class IFC_PARSE_API IfcStructuralLoadOrResult : public IfcStructuralLoad {
public:
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcStructuralLoad::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcStructuralLoad::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcStructuralLoad::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcStructuralLoadOrResult (IfcEntityInstanceData* e);
    IfcStructuralLoadOrResult (boost::optional< std::string > v1_Name);
    typedef IfcTemplatedEntityList< IfcStructuralLoadOrResult > list;
};
/// Definition from IAI: The abstract entity IfcStructuralLoadStatic is the supertype of all static loads (actions or reactions) which can be defined.  Within scope are single i.e. concentrated forces and moments, linear i.e. one-dimensionally distributed forces and moments, planar i.e. two-dimensionally distributed forces, furthermore displacements and temperature loads.
/// 
/// HISTORY: New entity in IFC 2x2.
class IFC_PARSE_API IfcStructuralLoadStatic : public IfcStructuralLoadOrResult {
public:
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcStructuralLoadOrResult::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcStructuralLoadOrResult::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcStructuralLoadOrResult::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcStructuralLoadStatic (IfcEntityInstanceData* e);
    IfcStructuralLoadStatic (boost::optional< std::string > v1_Name);
    typedef IfcTemplatedEntityList< IfcStructuralLoadStatic > list;
};
/// An instance of the entity IfcStructuralLoadTemperature shall be used to define actions which are caused by a temperature change. As shown in Figure 332, the change of temperature is given with a constant value which is applied to the complete section and values for temperature differences between outer fibres of the section.
/// 
/// HISTORY  New entity in IFC2x2. 
/// 
/// Figure 332 — Structural load temperature
class IFC_PARSE_API IfcStructuralLoadTemperature : public IfcStructuralLoadStatic {
public:
    /// Whether the optional attribute DeltaTConstant is defined for this IfcStructuralLoadTemperature
    bool hasDeltaTConstant() const;
    /// Temperature change which affects the complete section of the structural member, or the uniform portion of a non-uniform temperature change.
    /// 
    /// A positive value describes an increase in temperature.  I.e. a positive constant temperature change causes elongation of a member, or compression in the member if there are respective restraints.
    double DeltaTConstant() const;
    void setDeltaTConstant(double v);
    /// Whether the optional attribute DeltaTY is defined for this IfcStructuralLoadTemperature
    bool hasDeltaTY() const;
    /// Non-uniform temperature change, specified as the difference of the temperature change at the outer fibre of the positive y direction minus the temperature change at the outer fibre of the negative y direction of the analysis member.
    /// 
    /// I.e. a positive non-uniform temperature change in y induces a negative curvature of the member about z, or a positive bending moment about z if there are respective restraints.  y and z are local member axes.
    double DeltaTY() const;
    void setDeltaTY(double v);
    /// Whether the optional attribute DeltaTZ is defined for this IfcStructuralLoadTemperature
    bool hasDeltaTZ() const;
    /// Non-uniform temperature change, specified as the difference of the temperature change at the outer fibre of the positive z direction minus the temperature change at the outer fibre of the negative z direction of the analysis member.
    /// 
    /// I.e. a positive non-uniform temperature change in z induces a positive curvature of the member about y, or a negative bending moment about y if there are respective restraints.  y and z are local member axes.
    double DeltaTZ() const;
    void setDeltaTZ(double v);
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 1: return IfcUtil::Argument_DOUBLE; case 2: return IfcUtil::Argument_DOUBLE; case 3: return IfcUtil::Argument_DOUBLE; } return IfcStructuralLoadStatic::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 1: return Type::IfcThermodynamicTemperatureMeasure; case 2: return Type::IfcThermodynamicTemperatureMeasure; case 3: return Type::IfcThermodynamicTemperatureMeasure; } return IfcStructuralLoadStatic::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 1: return "DeltaTConstant"; case 2: return "DeltaTY"; case 3: return "DeltaTZ"; } return IfcStructuralLoadStatic::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcStructuralLoadTemperature (IfcEntityInstanceData* e);
    IfcStructuralLoadTemperature (boost::optional< std::string > v1_Name, boost::optional< double > v2_DeltaTConstant, boost::optional< double > v3_DeltaTY, boost::optional< double > v4_DeltaTZ);
    typedef IfcTemplatedEntityList< IfcStructuralLoadTemperature > list;
};
/// IfcStyleModel represents the concept of a particular presentation style defined for a material (or other characteristic) of a product or a product component within a representation context. This representation context may (but has not to be) a geometric representation context.
/// 
/// IfcStyleModel can be a style representation (presentation style) of a material (via IfcMaterialDefinitionRepresentation), potentially differentiated for different representation contexts (for example, different material hatching depending on the scale of the target representation context).
/// 
/// HISTORY  New entity in IFC2x3.
class IFC_PARSE_API IfcStyleModel : public IfcRepresentation {
public:
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcRepresentation::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcRepresentation::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcRepresentation::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcStyleModel (IfcEntityInstanceData* e);
    IfcStyleModel (IfcRepresentationContext* v1_ContextOfItems, boost::optional< std::string > v2_RepresentationIdentifier, boost::optional< std::string > v3_RepresentationType, IfcTemplatedEntityList< IfcRepresentationItem >::ptr v4_Items);
    typedef IfcTemplatedEntityList< IfcStyleModel > list;
};
/// Definition from ISO/CD 10303-46:1992: The styled item is an assignment of style for presentation to a geometric representation item as it is used in a representation.
/// 
/// NOTE  Corresponding ISO 10303 name: styled_item. Please refer to ISO/IS 10303-46:1994 for the final definition of the formal standard.
/// 
/// The IfcStyledItem holds presentation style information for products, either explicitly for an IfcGeometricRepresentationItem being part of an IfcShapeRepresentation assigned to a product, or by assigning presentation information to IfcMaterial being assigned as other representation for a product.
/// 
/// If the IfcStyledItem is used within a reference from an IfcProductDefinitionShape then one Item shall be provided.
/// If the IfcStyledItem is used within a reference from an IfcMaterialDefinitionRepresentation then no Item shall be provided.
/// 
/// HISTORY  New entity in IFC2x2.
/// 
/// IFC2x2 Addendum 1 CHANGE  The entity IfcStyledItem has been made non abstract and the attribute Name added.
/// 
/// IFC2x3 CHANGE The attribute Item has been made optional, upward compatibility for file
/// based exchange is guaranteed.
/// 
/// IFC2x4 CHANGE The subtype IfcAnnotationOccurrence and its subtypes are deleted. Use IfcStyledItem for all instantiations. The data type of Styles has been changed to IfcStyleAssignmentSelect
/// 
/// Use Definition
/// 
/// Figure 293 illustrates use of IfcStyledItem for the two usage examples:
/// 
/// As a presentation for a geometric representation item
/// As a presentation for a material definition
/// 
/// NOTE  The new IfcStyleAssignmentSelect allows the direct assignment styles, such as IfcCurveStyle, IfcSurfaceStyle without using the intermediate IfcPresentationStyleAssignment
/// 
/// Figure 293 — Styled item
class IFC_PARSE_API IfcStyledItem : public IfcRepresentationItem {
public:
    /// Whether the optional attribute Item is defined for this IfcStyledItem
    bool hasItem() const;
    /// A geometric representation item to which the style is assigned.
    /// 
    /// IFC2x Edition 2 Addendum 2 CHANGE The attribute Item has been made optional. Upward compatibility for file based exchange is guaranteed.
    IfcRepresentationItem* Item() const;
    void setItem(IfcRepresentationItem* v);
    /// Representation styles which are assigned, either to an geometric representation item, or to a material definition.
    /// 
    /// IFC2x4 CHANGE  The data type has been changed to IfcStyleAssignmentSelect with upward compatibility 
    /// for file based exchange.
    /// 
    /// NOTE  Only the select item IfcPresentationStyle shall be used from IFC2x4 onwards, the IfcPresentationStyleAssignment has been deprecated.
    IfcEntityList::ptr Styles() const;
    void setStyles(IfcEntityList::ptr v);
    /// Whether the optional attribute Name is defined for this IfcStyledItem
    bool hasName() const;
    /// The word, or group of words, by which the styled item is referred to.
    std::string Name() const;
    void setName(std::string v);
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 2: return IfcUtil::Argument_STRING; } return IfcRepresentationItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcRepresentationItem; case 1: return Type::IfcStyleAssignmentSelect; case 2: return Type::IfcLabel; } return IfcRepresentationItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Item"; case 1: return "Styles"; case 2: return "Name"; } return IfcRepresentationItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcStyledItem (IfcEntityInstanceData* e);
    IfcStyledItem (IfcRepresentationItem* v1_Item, IfcEntityList::ptr v2_Styles, boost::optional< std::string > v3_Name);
    typedef IfcTemplatedEntityList< IfcStyledItem > list;
};
/// The IfcStyledRepresentation represents the concept of a styled presentation being a representation of a product or a product component, like material. within a representation context. This representation context does not need to be (but may be) a geometric representation context.
/// 
/// NOTE  Current usage of IfcStyledRepresentation is restricted to the assignment of presentation information to an material. The IfcStyledRepresentation includes only presentation styles (IfcCurveStyle, FillAreaStyle, IfcSurfaceStyle) that define how a material should be presented within a particular (eventually view and scale dependent) representation context. All instances of IfcStyledRepresentation are referenced by IfcMaterialDefinitionRepresentation, and assigned to IfcMaterial by IfcMaterialDefinitionRepresentation.RepresentedMaterial.
/// 
/// A styled representation has to include one or several styled items with the associated style information (curve, symbol, text, fill area, or surface styles). It shall not contain the geometric representation items that are styled.
/// 
/// HISTORY  New entity in IFC2x2.
class IFC_PARSE_API IfcStyledRepresentation : public IfcStyleModel {
public:
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcStyleModel::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcStyleModel::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcStyleModel::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcStyledRepresentation (IfcEntityInstanceData* e);
    IfcStyledRepresentation (IfcRepresentationContext* v1_ContextOfItems, boost::optional< std::string > v2_RepresentationIdentifier, boost::optional< std::string > v3_RepresentationType, IfcTemplatedEntityList< IfcRepresentationItem >::ptr v4_Items);
    typedef IfcTemplatedEntityList< IfcStyledRepresentation > list;
};
/// Definition from IAI: Describes required or provided reinforcement area of surface members.
/// 
/// NOTE  Member design parameters like concrete cover, effective depth, orientation of meshes or rebars (two, optionally three directions) etc. are not specified in IfcStructuralLoadResource schema.  They shall be specified at the level of structural members.
/// 
/// HISTORY: New entity in IFC 2x4.
class IFC_PARSE_API IfcSurfaceReinforcementArea : public IfcStructuralLoadOrResult {
public:
    /// Whether the optional attribute SurfaceReinforcement1 is defined for this IfcSurfaceReinforcementArea
    bool hasSurfaceReinforcement1() const;
    /// Reinforcement at the face of the member which is located at the side of the positive local z direction of the surface member.  Specified as area per length, e.g. square metre per metre (hence length measure, e.g. metre).  The reinforcement area may be specified for two or three directions of reinforcement bars.
    std::vector< double > /*[2:3]*/ SurfaceReinforcement1() const;
    void setSurfaceReinforcement1(std::vector< double > /*[2:3]*/ v);
    /// Whether the optional attribute SurfaceReinforcement2 is defined for this IfcSurfaceReinforcementArea
    bool hasSurfaceReinforcement2() const;
    /// Reinforcement at the face of the member which is located at the side of the negative local z direction of the surface member.  Specified as area per length, e.g. square metre per metre (hence length measure, e.g. metre).  The reinforcement area may be specified for two or three directions of reinforcement bars.
    std::vector< double > /*[2:3]*/ SurfaceReinforcement2() const;
    void setSurfaceReinforcement2(std::vector< double > /*[2:3]*/ v);
    /// Whether the optional attribute ShearReinforcement is defined for this IfcSurfaceReinforcementArea
    bool hasShearReinforcement() const;
    /// Shear reinforcement.  Specified as area per area, e.g. square metre per square metre (hence ratio measure, i.e. unitless).
    double ShearReinforcement() const;
    void setShearReinforcement(double v);
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 1: return IfcUtil::Argument_AGGREGATE_OF_DOUBLE; case 2: return IfcUtil::Argument_AGGREGATE_OF_DOUBLE; case 3: return IfcUtil::Argument_DOUBLE; } return IfcStructuralLoadOrResult::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 1: return Type::IfcLengthMeasure; case 2: return Type::IfcLengthMeasure; case 3: return Type::IfcRatioMeasure; } return IfcStructuralLoadOrResult::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 1: return "SurfaceReinforcement1"; case 2: return "SurfaceReinforcement2"; case 3: return "ShearReinforcement"; } return IfcStructuralLoadOrResult::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcSurfaceReinforcementArea (IfcEntityInstanceData* e);
    IfcSurfaceReinforcementArea (boost::optional< std::string > v1_Name, boost::optional< std::vector< double > /*[2:3]*/ > v2_SurfaceReinforcement1, boost::optional< std::vector< double > /*[2:3]*/ > v3_SurfaceReinforcement2, boost::optional< double > v4_ShearReinforcement);
    typedef IfcTemplatedEntityList< IfcSurfaceReinforcementArea > list;
};
/// IfcSurfaceStyle is an assignment of one or many surface style elements to a surface, defined by subtypes of IfcSurface, IfcFaceBasedSurfaceModel, IfcShellBasedSurfaceModel, or by subtypes of IfcSolidModel. The positive direction of the surface normal relates to the positive side. In case of solids the outside of the solid is to be taken as positive side. 
/// 
/// NOTE: The surface style is often referred to as material definition in rendering applications.
/// 
/// NOTE Corresponding ISO 10303 entity: surface_style_usage and surface_side_style. Please refer to ISO/IS 10303-46:1994 for the final definition of the formal standard. The surface style definition in regard to support of rendering has been greatly expanded beyond the scope of ISO/IS 10303-46.
/// 
/// HISTORY New Entity in IFC 2.x.
class IFC_PARSE_API IfcSurfaceStyle : public IfcPresentationStyle {
public:
    /// An indication of which side of the surface to apply the style.
    IfcSurfaceSide::IfcSurfaceSide Side() const;
    void setSide(IfcSurfaceSide::IfcSurfaceSide v);
    /// A collection of different surface styles.
    IfcEntityList::ptr Styles() const;
    void setStyles(IfcEntityList::ptr v);
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 1: return IfcUtil::Argument_ENUMERATION; case 2: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } return IfcPresentationStyle::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 1: return Type::IfcSurfaceSide; case 2: return Type::IfcSurfaceStyleElementSelect; } return IfcPresentationStyle::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 1: return "Side"; case 2: return "Styles"; } return IfcPresentationStyle::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcSurfaceStyle (IfcEntityInstanceData* e);
    IfcSurfaceStyle (boost::optional< std::string > v1_Name, IfcSurfaceSide::IfcSurfaceSide v2_Side, IfcEntityList::ptr v3_Styles);
    typedef IfcTemplatedEntityList< IfcSurfaceStyle > list;
};
/// IfcSurfaceStyleLighting is a container class for properties for calculation of physically exact illuminance related to a particular surface style.
/// 
/// Figure 294 shows the reflection and transmission components from an incident ray. The sum of the components for reflection and transmission is a value of 1.0 denoting that the incident ray is completely decomposed into reflection and transmission components. Each value of reflection and transmission is therefore within the range 0.0 to 1.0. 
/// 
/// Figure 294 — Surface style lighting
/// 
/// All these factors can be measured physically and are ratios for the red, green and blue part of the light. These properties are defined in the model as Type IfcColorRGB with a factor for each colour. 
/// 
/// EXAMPLE  A green glass transmits only green light, so its transmission factor is 0.0 for red, between 0.0 and 1.0 for green and 0.0 for blue. A green surface reflects only green light, so the reflectance factor is 0.0 for red, between 0.0 and 1.0 for green and 0.0 for blue.
/// 
/// HISTORY  New entity in IFC 2x2.
class IFC_PARSE_API IfcSurfaceStyleLighting : public IfcPresentationItem {
public:
    /// The degree of diffusion of the transmitted light. In the case of completely transparent materials there is no diffusion. The greater the diffusing power, the smaller the direct component of the transmitted light, up to the point where only diffuse light is produced.A value of 1 means totally diffuse for that colour part of the light.
    /// The factor can be measured physically and has three ratios for the red, green and blue part of the light.
    IfcColourRgb* DiffuseTransmissionColour() const;
    void setDiffuseTransmissionColour(IfcColourRgb* v);
    /// The degree of diffusion of the reflected light. In the case of specular surfaces there is no diffusion. The greater the diffusing power of the reflecting surface, the smaller the specular component of the reflected light, up to the point where only diffuse light is produced. A value of 1 means totally diffuse for that colour part of the light. 
    /// The factor can be measured physically and has three ratios for the red, green and blue part of the light.
    IfcColourRgb* DiffuseReflectionColour() const;
    void setDiffuseReflectionColour(IfcColourRgb* v);
    /// Describes how the light falling on a body is totally or partially transmitted. 
    /// The factor can be measured physically and has three ratios for the red, green and blue part of the light.
    IfcColourRgb* TransmissionColour() const;
    void setTransmissionColour(IfcColourRgb* v);
    /// A coefficient that determines the extent that the light falling onto a surface is fully or partially reflected. 
    /// The factor can be measured physically and has three ratios for the red, green and blue part of the light.
    IfcColourRgb* ReflectanceColour() const;
    void setReflectanceColour(IfcColourRgb* v);
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_ENTITY_INSTANCE; case 2: return IfcUtil::Argument_ENTITY_INSTANCE; case 3: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcPresentationItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcColourRgb; case 1: return Type::IfcColourRgb; case 2: return Type::IfcColourRgb; case 3: return Type::IfcColourRgb; } return IfcPresentationItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "DiffuseTransmissionColour"; case 1: return "DiffuseReflectionColour"; case 2: return "TransmissionColour"; case 3: return "ReflectanceColour"; } return IfcPresentationItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcSurfaceStyleLighting (IfcEntityInstanceData* e);
    IfcSurfaceStyleLighting (IfcColourRgb* v1_DiffuseTransmissionColour, IfcColourRgb* v2_DiffuseReflectionColour, IfcColourRgb* v3_TransmissionColour, IfcColourRgb* v4_ReflectanceColour);
    typedef IfcTemplatedEntityList< IfcSurfaceStyleLighting > list;
};
/// IfcSurfaceStyleRefraction extends the surface style lighting, or the surface style rendering definition for properties for calculation of physically exact illuminance by adding seldomly used properties. Currently this includes the refraction index (by which the light ray refracts when passing through a prism) and the dispersion factor (or Abbe constant) which takes into account the wavelength dependency of the refraction.
/// 
/// NOTE: If such refraction properties are used, the IfcSurfaceStyle should include within its set of Styles (depending on whether rendering or lighting is used) an instance of IfcSurfaceStyleLighting and IfcSurfaceStyleRefraction, or an instance of IfcSurfaceStyleRendering and IfcSurfaceStyleRefraction.
/// 
/// HISTORY: New entity in IFC 2x2.
class IFC_PARSE_API IfcSurfaceStyleRefraction : public IfcPresentationItem {
public:
    /// Whether the optional attribute RefractionIndex is defined for this IfcSurfaceStyleRefraction
    bool hasRefractionIndex() const;
    /// The index of refraction for all wave lengths of light. The refraction index is the ratio between the speed of light in a vacuum and the speed of light in the medium. E.g. glass has a refraction index of 1.5, whereas water has an index of 1.33
    double RefractionIndex() const;
    void setRefractionIndex(double v);
    /// Whether the optional attribute DispersionFactor is defined for this IfcSurfaceStyleRefraction
    bool hasDispersionFactor() const;
    /// The Abbe constant given as a fixed ratio between the refractive indices of the material at different wavelengths. A low Abbe number means a high dispersive power. In general this translates to a greater angular spread of the emergent spectrum.
    double DispersionFactor() const;
    void setDispersionFactor(double v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_DOUBLE; case 1: return IfcUtil::Argument_DOUBLE; } return IfcPresentationItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcReal; case 1: return Type::IfcReal; } return IfcPresentationItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "RefractionIndex"; case 1: return "DispersionFactor"; } return IfcPresentationItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcSurfaceStyleRefraction (IfcEntityInstanceData* e);
    IfcSurfaceStyleRefraction (boost::optional< double > v1_RefractionIndex, boost::optional< double > v2_DispersionFactor);
    typedef IfcTemplatedEntityList< IfcSurfaceStyleRefraction > list;
};
/// Definition from ISO/CD 10303-46:1992: The surface style rendering allows the realistic visualization of surfaces referring to rendering techniques based on the laws of physics and mathematics. 
/// 
/// The entity IfcSurfaceStyleShading allows for colour information used for shading, whereas subtypes provide data for more sophisticated rendering techniques. The surface colour is used for colouring or simple shading of the assigned surfaces. 
/// 
/// NOTE Corresponding ISO 10303 entity: surface_style_rendering. Please refer to ISO/IS 10303-46:1994 for the final definition of the formal standard. No rendering method is defined for each surface style (such as constant, colour, dot or normal shading), therefore the attribute rendering_method has been omitted.
/// 
/// HISTORY: New entity in IFC 2x.
class IFC_PARSE_API IfcSurfaceStyleShading : public IfcPresentationItem {
public:
    /// The colour used to render the surface. The surface colour for visualisation is defined by specifying the intensity of red, green and blue.
    IfcColourRgb* SurfaceColour() const;
    void setSurfaceColour(IfcColourRgb* v);
    /// Whether the optional attribute Transparency is defined for this IfcSurfaceStyleShading
    bool hasTransparency() const;
    double Transparency() const;
    void setTransparency(double v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_DOUBLE; } return IfcPresentationItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcColourRgb; case 1: return Type::IfcNormalisedRatioMeasure; } return IfcPresentationItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "SurfaceColour"; case 1: return "Transparency"; } return IfcPresentationItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcSurfaceStyleShading (IfcEntityInstanceData* e);
    IfcSurfaceStyleShading (IfcColourRgb* v1_SurfaceColour, boost::optional< double > v2_Transparency);
    typedef IfcTemplatedEntityList< IfcSurfaceStyleShading > list;
};
/// The entity IfcSurfaceStyleWithTextures allows to include image textures in surface styles. These image textures can be applied repeating across the surface or mapped with a particular scale upon the surface.
/// 
/// The entity IfcSurfaceStyleWithTextures is part of the surface style table for presentation information assigned to surfaces for shading, rendering and lighting with textures. The mapping of the texture onto the surface or the solid is determined by the texture coordinates, in absense of an IfcTextureCoordinate assigned to each surface texture, a default mapping of the texture to the geometric face or surface applies.
/// 
/// Surface textures included in the IfcSurfaceStyleWithTextures are two dimensional map formats. They define 2D images that contain an array of colour values describing the texture. Depending on the number of IfcSurfaceTextures being included in the list of Textures the IfcSurfaceStyleWithTextures either describes a single texture, or a multi texture.
/// 
/// single texture: a single surface texture is applied to the styled geometric item (entirely or partly) with optional repetition and texture transformation
/// multi texture: two or more surface textures are applied to the styled geometric item (entirely or partly) with optional repetition, texture transformation or texture coordinate mapping being specific for each texture.
/// 
/// Informal proposition
/// 
/// Only one instance of IfcSurfaceStyleWithTextures shall be referenced by an IfcStyledItem and be assigned to an IfcGeometricRepresentationItem
/// 
/// NOTE  The definitions of texturing within this standard have been developed in dependence on the texture component of X3D. See ISO/IEC 19775-1.2:2008 X3D Architecture and base components Edition 2, Part 1, 18 Texturing component for the definitions in the international standard.
/// 
/// HISTORY  New entity in IFC2x2.
/// 
/// IFC2x3 CHANGE  inverse attribute HasTextureCoordinates deleted.
class IFC_PARSE_API IfcSurfaceStyleWithTextures : public IfcPresentationItem {
public:
    /// The textures applied to the surface. In case of more than one surface texture is included, the IfcSurfaceStyleWithTexture defines a multi texture.
    IfcTemplatedEntityList< IfcSurfaceTexture >::ptr Textures() const;
    void setTextures(IfcTemplatedEntityList< IfcSurfaceTexture >::ptr v);
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } return IfcPresentationItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcSurfaceTexture; } return IfcPresentationItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Textures"; } return IfcPresentationItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcSurfaceStyleWithTextures (IfcEntityInstanceData* e);
    IfcSurfaceStyleWithTextures (IfcTemplatedEntityList< IfcSurfaceTexture >::ptr v1_Textures);
    typedef IfcTemplatedEntityList< IfcSurfaceStyleWithTextures > list;
};
/// An IfcSurfaceTexture provides a 2-dimensional
/// image-based texture map. It can either be given by referencing an
/// external image file through an URL reference
/// (IfcImageTexture), including the image file as a blob
/// (long binary) into the data set (IfcBlobTexture), or by
/// explicitly including an array of pixels
/// (IfcPixelTexture).
/// The following definitions from ISO/IEC 19775-1 X3D Architecture
/// and base components (X3D Specification)
/// apply:
/// 
/// Texture: An image
/// used in a texture map to create visual appearance effects when
/// applied to geometry nodes.
/// Texture map: A
/// texture plus the general parameters necessary for mapping the
/// texture to geometry.
/// 
/// Texture are defined by 2D images that contain an array of colour
/// values describing the texture. The texture values are interpreted
/// differently depending on the number of components in the texture
/// and the specifics of the image format. In general, texture may be
/// described using one of the following forms:
/// 
/// Intensity textures (one-component)
/// Intensity plus alpha opacity textures (two-component)
/// Full RGB textures (three-component)
/// Full RGB plus alpha opacity textures (four-component)
/// 
/// NOTE  Image formats specify an alpha opacity, not transparency (where alpha = 1 - transparency).
/// 
/// Figure 295 illustrates the texture coordinate system.
/// 
/// Figure 295 — Surface texture coordinates
/// 
/// The following definitions from ISO/IEC 19775-1 X3D Architecture and base components (X3D Specification) on texture coordinates apply:
/// 
/// Texture maps are defined in a 2D coordinate system (s, t) that ranges from [0.0, 1.0] in both directions. The bottom edge of the image corresponds to the S-axis of the texture map, and left edge of the image corresponds to the T-axis of the texture map. The lower-left pixel of the image corresponds to s=0, t=0, and the top-right pixel of the image corresponds to s=1, t=1. Texture maps may be viewed as two dimensional colour functions that, given an (s, t) coordinate, return a colour value colour(s, t).
/// 
/// If multiple surface textures are included in the
/// IfcSurfaceStyleWithTextures applying them to a geometric
/// item, a mode and optional parameters can be included that blending
/// operations.
/// The RepeatS and RepeatT Boolean flags control
/// whether the texture map is repeated outside the [0.0, 1.0] texture
/// coordinate range, when applied to a geometric surface, or clamped
/// to lie within the [0.0, 1.0] range. The TextureTransform
/// applies a 2D non-uniform transformation to the texture before it is
/// applied to a geometric surface.
/// The following definitions from ISO/IEC 19775-1 X3D Architecture
/// and base components (X3D Specification)
/// apply:
/// 
/// These parameters
/// support changes to the size, orientation, and position of textures
/// on shapes. Note that these operations appear reversed when viewed
/// on the surface of geometry. For example, a scale value of (2
/// 2) will scale the texture coordinates and have the net effect of
/// shrinking the texture size by a factor of 2 (texture coordinates
/// are twice as large and thus cause the texture to repeat). A
/// translation of (0.5 0.0) translates the texture coordinates +.5
/// units along the S-axis and has the net effect of translating the
/// texture −0.5 along the S-axis on the geometry's surface. A
/// rotation of π/2 of the texture coordinates results in a
/// −π/2 rotation of the texture on the geometry.
/// The center
/// field specifies a translation offset in texture coordinate space
/// about which the rotation and scale fields are
/// applied. The scale field specifies a scaling factor in S and
/// T of the texture coordinates about the center point.
/// scale values shall be in the range (−∞,∞).
/// The rotation field specifies a rotation in radians of the
/// texture coordinates about the center point after the scale
/// has been applied. A positive rotation value makes the texture
/// coordinates rotate counterclockwise about the centre, thereby
/// rotating the appearance of the texture itself clockwise. The
/// translation field specifies a translation of the texture
/// coordinates.
/// The following conventions
/// apply:
/// 
/// center =
/// TextureTransform.LocalOrigin;
/// rotation = TextureTransform.Axis1
/// scale S = TextureTransform.Scale
/// scale T = TextureTransform.Scale2
/// 
/// NOTE  The definitions of texturing within this standard have been developed in dependence on the texture component of X3D. See ISO/IEC 19775-1.2:2008 X3D Architecture and base components Edition 2, Part 1, 18 Texturing component for the definitions in the international standard.
/// 
/// HISTORY  New entity in IFC 2x2.
/// 
/// IFC2x4 CHANGE  Attribute TextureType replaces by Mode, attributes Parameter and MapsTo aded, new inverse attribute UsedInStyle.
class IFC_PARSE_API IfcSurfaceTexture : public IfcPresentationItem {
public:
    /// The RepeatS field specifies how the texture wraps in the S direction. If RepeatS is TRUE (the default), the texture map is repeated outside the [0.0, 1.0] texture coordinate range in the S direction so that it fills the shape. If RepeatS is FALSE, the texture coordinates are clamped in the S direction to lie within the [0.0, 1.0] range.
    bool RepeatS() const;
    void setRepeatS(bool v);
    /// The RepeatT field specifies how the texture wraps in the T direction. If RepeatT is TRUE (the default), the texture map is repeated outside the [0.0, 1.0] texture coordinate range in the T direction so that it fills the shape. If RepeatT is FALSE, the texture coordinates are clamped in the T direction to lie within the [0.0, 1.0] range.
    bool RepeatT() const;
    void setRepeatT(bool v);
    /// Whether the optional attribute Mode is defined for this IfcSurfaceTexture
    bool hasMode() const;
    /// The Mode attribute is provided to control the appearance of a multi textures. The mode then controls the type of blending operation. The mode includes a MODULATE for a lit appearance, a REPLACE for a unlit appearance, and variations of the two.
    /// 
    /// NOTE  The applicable values for the Mode attribute are determined by view definitions or implementer agreements. It is recommended to use the modes described in ISO/IES 19775-1.2:2008 X3D Architecture and base components Edition 2, Part 1. See 18.4.3 MultiTexture for recommended values.
    /// 
    /// IFC2x4 CHANGE  New attribute replacing previous TextureType.
    std::string Mode() const;
    void setMode(std::string v);
    /// Whether the optional attribute TextureTransform is defined for this IfcSurfaceTexture
    bool hasTextureTransform() const;
    /// The TextureTransform defines a 2D transformation that is applied to the texture coordinates. It affects the way texture coordinates are applied to the surfaces of geometric representation itesm. The 2D transformation supports changes to the size, orientation, and position of textures on shapes. 
    /// 
    /// Mirroring is not allowed to be used in the IfcCarteesianTransformationOperator
    IfcCartesianTransformationOperator2D* TextureTransform() const;
    void setTextureTransform(IfcCartesianTransformationOperator2D* v);
    /// Whether the optional attribute Parameter is defined for this IfcSurfaceTexture
    bool hasParameter() const;
    /// The Parameter attribute is provided to control the appearance of a multi textures. The applicable parameters depend on the value of the Mode attribute.
    /// 
    /// NOTE  The applicable values for the list of Parameter attributes are determined by view definitions or implementer agreements. It is recommended to use the source and the function fields described in ISO/IES 19775-1.2:2008 X3D Architecture and base components Edition 2, Part 1. See 18.4.3 MultiTexture for recommended values.
    /// By convention, Parameter[1] shall then hold the source value, Parameter[2] the function value, Parameter[3] the base RGB color for select operations, and Parameter[4] the alpha value for select operations.
    /// 
    /// IFC2x4 CHANGE  New attribute added at the end of the attribute list.
    std::vector< std::string > /*[1:?]*/ Parameter() const;
    void setParameter(std::vector< std::string > /*[1:?]*/ v);
    virtual unsigned int getArgumentCount() const { return 5; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_BOOL; case 1: return IfcUtil::Argument_BOOL; case 2: return IfcUtil::Argument_STRING; case 3: return IfcUtil::Argument_ENTITY_INSTANCE; case 4: return IfcUtil::Argument_AGGREGATE_OF_STRING; } return IfcPresentationItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcBoolean; case 1: return Type::IfcBoolean; case 2: return Type::IfcIdentifier; case 3: return Type::IfcCartesianTransformationOperator2D; case 4: return Type::IfcIdentifier; } return IfcPresentationItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "RepeatS"; case 1: return "RepeatT"; case 2: return "Mode"; case 3: return "TextureTransform"; case 4: return "Parameter"; } return IfcPresentationItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcTextureCoordinate >::ptr IsMappedBy() const; // INVERSE IfcTextureCoordinate::Maps
    IfcTemplatedEntityList< IfcSurfaceStyleWithTextures >::ptr UsedInStyles() const; // INVERSE IfcSurfaceStyleWithTextures::Textures
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcSurfaceTexture (IfcEntityInstanceData* e);
    IfcSurfaceTexture (bool v1_RepeatS, bool v2_RepeatT, boost::optional< std::string > v3_Mode, IfcCartesianTransformationOperator2D* v4_TextureTransform, boost::optional< std::vector< std::string > /*[1:?]*/ > v5_Parameter);
    typedef IfcTemplatedEntityList< IfcSurfaceTexture > list;
};
/// An IfcTable is a data structure for the provision of information in the form of rows and columns. Each instance may have IfcTableColumn instances that define the name, description and units for each column. The rows of information are stored as a list of IfcTableRow objects. 
/// 
/// Limitation: For backwards compatibility, the rows of an IfcTable object are constrained to have the same number of cells. The first Row of the table provides the number of cells. All other rows are forced to include the same number of cells. This is enforced by the WR2. 
/// 
/// Figure 335 illustrates table use.
/// 
/// Figure 335 — Table use
/// 
/// Figure 336 depicts how tables were structured prior to IFC2x4.
/// 
/// Figure 336 — Table use alternative
/// 
/// HISTORY  New entity in IFC R1.5.
/// 
/// IFC2x4 CHANGE  Columns attribute added.
class IFC_PARSE_API IfcTable : public IfcUtil::IfcBaseEntity {
public:
    /// Whether the optional attribute Name is defined for this IfcTable
    bool hasName() const;
    /// A unique name which is intended to describe the usage of the Table.
    std::string Name() const;
    void setName(std::string v);
    /// Whether the optional attribute Rows is defined for this IfcTable
    bool hasRows() const;
    /// Reference to information content of rows.
    IfcTemplatedEntityList< IfcTableRow >::ptr Rows() const;
    void setRows(IfcTemplatedEntityList< IfcTableRow >::ptr v);
    /// Whether the optional attribute Columns is defined for this IfcTable
    bool hasColumns() const;
    /// The column information associated with this table.
    IfcTemplatedEntityList< IfcTableColumn >::ptr Columns() const;
    void setColumns(IfcTemplatedEntityList< IfcTableColumn >::ptr v);
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_STRING; case 1: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 2: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcLabel; case 1: return Type::IfcTableRow; case 2: return Type::IfcTableColumn; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Name"; case 1: return "Rows"; case 2: return "Columns"; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcTable (IfcEntityInstanceData* e);
    IfcTable (boost::optional< std::string > v1_Name, boost::optional< IfcTemplatedEntityList< IfcTableRow >::ptr > v2_Rows, boost::optional< IfcTemplatedEntityList< IfcTableColumn >::ptr > v3_Columns);
    typedef IfcTemplatedEntityList< IfcTable > list;
};
/// An IfcTableColumn is a data structure that captures column information for use in an IfcTable. Each instance defines the name, description, identifier, and units of measure that are applicable to the columnar data associated with the IfcTableRow objects. 
/// 
/// The use of IfcTableColumn supercedes the IsHeading flag associated with IfcTableRow. 
/// 
/// HISTORY  New entity in IFC2x4.
class IFC_PARSE_API IfcTableColumn : public IfcUtil::IfcBaseEntity {
public:
    /// Whether the optional attribute Identifier is defined for this IfcTableColumn
    bool hasIdentifier() const;
    /// Table column identifier.
    std::string Identifier() const;
    void setIdentifier(std::string v);
    /// Whether the optional attribute Name is defined for this IfcTableColumn
    bool hasName() const;
    /// The table column display name.
    std::string Name() const;
    void setName(std::string v);
    /// Whether the optional attribute Description is defined for this IfcTableColumn
    bool hasDescription() const;
    /// Descriptive text for the table column.
    std::string Description() const;
    void setDescription(std::string v);
    /// Whether the optional attribute Unit is defined for this IfcTableColumn
    bool hasUnit() const;
    /// The unit of measure to be used for this column's data.
    IfcUnit* Unit() const;
    void setUnit(IfcUnit* v);
    /// Whether the optional attribute ReferencePath is defined for this IfcTableColumn
    bool hasReferencePath() const;
    IfcReference* ReferencePath() const;
    void setReferencePath(IfcReference* v);
    virtual unsigned int getArgumentCount() const { return 5; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_STRING; case 1: return IfcUtil::Argument_STRING; case 2: return IfcUtil::Argument_STRING; case 3: return IfcUtil::Argument_ENTITY_INSTANCE; case 4: return IfcUtil::Argument_ENTITY_INSTANCE; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcIdentifier; case 1: return Type::IfcLabel; case 2: return Type::IfcText; case 3: return Type::IfcUnit; case 4: return Type::IfcReference; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Identifier"; case 1: return "Name"; case 2: return "Description"; case 3: return "Unit"; case 4: return "ReferencePath"; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcTableColumn (IfcEntityInstanceData* e);
    IfcTableColumn (boost::optional< std::string > v1_Identifier, boost::optional< std::string > v2_Name, boost::optional< std::string > v3_Description, IfcUnit* v4_Unit, IfcReference* v5_ReferencePath);
    typedef IfcTemplatedEntityList< IfcTableColumn > list;
};
/// IfcTableRow contains data for a single row within an IfcTable. 
/// 
/// Limitation: For backward compatibility, all IfcTableRow objects referenced by an IfcTable shall have the same number of Row Cells. The actual number of Cells shall be taken from the number of cells of the first IfcTableRow for that table. The number of Cells is calculated by the derived attribute NumberOfCellsInRow in the associated IfcTable. 
/// 
/// Figure 337 illustrates table row use.
/// 
/// Figure 337 — Table row use
/// 
/// Figure 338 depicts how table rows were structured prior to IFC2x4 with the use of the IsHeading flag. Note that the use of the IfcTableColumn constructs should be used instead of the IsHeading flag (which remains for backward compatibility only): 
/// 
/// Figure 338 — Table row use alternative
/// 
/// HISTORY  New entity in IFC R1.5.
class IFC_PARSE_API IfcTableRow : public IfcUtil::IfcBaseEntity {
public:
    /// Whether the optional attribute RowCells is defined for this IfcTableRow
    bool hasRowCells() const;
    /// The data value of the table cell..
    IfcEntityList::ptr RowCells() const;
    void setRowCells(IfcEntityList::ptr v);
    /// Whether the optional attribute IsHeading is defined for this IfcTableRow
    bool hasIsHeading() const;
    /// Flag which identifies if the row is a heading row or a row which contains row values. NOTE - If the row is a heading, the flag takes the value = TRUE.
    bool IsHeading() const;
    void setIsHeading(bool v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_BOOL; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcValue; case 1: return Type::IfcBoolean; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "RowCells"; case 1: return "IsHeading"; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcTableRow (IfcEntityInstanceData* e);
    IfcTableRow (boost::optional< IfcEntityList::ptr > v1_RowCells, boost::optional< bool > v2_IsHeading);
    typedef IfcTemplatedEntityList< IfcTableRow > list;
};
/// IfcTaskTime captures the time-related information about a task including the different types (actual or scheduled) of starting and ending times.
/// 
/// HISTORY: New entity in IFC2x4, adapted from IfcScheduleTimeControl.  Differently to IfcScheduleTimeControl it is also possible to differentiate duration time measures between the two possible types; (1) work time and (2) elapsed time.
/// 
/// Use definitions
/// All given values should be provided by the application; the IFC schema does not deal with dependencies between task time values. There is also no consistency check through where rules that guarantee a meaningful population of time values. Thus, an application is responsible to provide reasonable values and, if an application receives task times, has to make consistency checks by their own.
/// 
/// IfcTaskTime furthermore provides a generic mechanism to differentiate between user given time values and time values derived from user given time values and other constraints such as work calendars and assigned resources.
class IFC_PARSE_API IfcTaskTime : public IfcSchedulingTime {
public:
    /// Whether the optional attribute DurationType is defined for this IfcTaskTime
    bool hasDurationType() const;
    /// Enables to specify the type of duration values for ScheduleDuration,        ActualDuration and RemainingTime. The duration type is either
    ///   work time or elapsed time.
    IfcTaskDurationEnum::IfcTaskDurationEnum DurationType() const;
    void setDurationType(IfcTaskDurationEnum::IfcTaskDurationEnum v);
    /// Whether the optional attribute ScheduleDuration is defined for this IfcTaskTime
    bool hasScheduleDuration() const;
    /// The amount of time which is scheduled for completion of a
    ///   task.
    ///   The value might be measured or somehow calculated, which is defined by
    ///   ScheduleDataOrigin. 
    ///   The value is either given as elapsed time or work time, which is defined by
    ///   DurationType.
    /// 
    /// NOTE: Scheduled Duration may be calculated as the
    ///   time from scheduled start date to scheduled finish date.
    std::string ScheduleDuration() const;
    void setScheduleDuration(std::string v);
    /// Whether the optional attribute ScheduleStart is defined for this IfcTaskTime
    bool hasScheduleStart() const;
    /// The date on which a task is scheduled to be started. 
    ///   The value might be measured or somehow calculated, which is defined by
    ///   ScheduleDataOrigin.
    /// 
    /// NOTE: The scheduled start date must be greater than
    ///   or equal to the earliest start date.
    std::string ScheduleStart() const;
    void setScheduleStart(std::string v);
    /// Whether the optional attribute ScheduleFinish is defined for this IfcTaskTime
    bool hasScheduleFinish() const;
    /// The date on which a task is scheduled to be finished.
    ///   The value might be measured or somehow calculated, which is defined by
    ///   ScheduleDataOrigin.
    /// 
    /// NOTE: The scheduled finish date must be greater than
    ///   or equal to the earliest finish date.
    std::string ScheduleFinish() const;
    void setScheduleFinish(std::string v);
    /// Whether the optional attribute EarlyStart is defined for this IfcTaskTime
    bool hasEarlyStart() const;
    /// The earliest date on which a task can be started. It is a calculated value.
    std::string EarlyStart() const;
    void setEarlyStart(std::string v);
    /// Whether the optional attribute EarlyFinish is defined for this IfcTaskTime
    bool hasEarlyFinish() const;
    /// The earliest date on which a task can be finished. It is a calculated value.
    std::string EarlyFinish() const;
    void setEarlyFinish(std::string v);
    /// Whether the optional attribute LateStart is defined for this IfcTaskTime
    bool hasLateStart() const;
    /// The latest date on which a task can be started. It is a calculated value.
    std::string LateStart() const;
    void setLateStart(std::string v);
    /// Whether the optional attribute LateFinish is defined for this IfcTaskTime
    bool hasLateFinish() const;
    /// The latest date on which a task can be finished. It is a calculated value.
    std::string LateFinish() const;
    void setLateFinish(std::string v);
    /// Whether the optional attribute FreeFloat is defined for this IfcTaskTime
    bool hasFreeFloat() const;
    /// The amount of time during which the start or finish of a
    ///   task may be varied without any effect on the overall
    ///   programme of work. It is a calculated elapsed time value.
    std::string FreeFloat() const;
    void setFreeFloat(std::string v);
    /// Whether the optional attribute TotalFloat is defined for this IfcTaskTime
    bool hasTotalFloat() const;
    /// The difference between the duration available to carry out
    ///   a task and the scheduled duration of the task. It is a calculated 
    ///   elapsed time value.
    /// 
    /// NOTE: Total Float time may be calculated as being
    ///   the difference between the scheduled duration of a task and
    ///   the available duration from earliest start to latest
    ///   finish. Float time may be either positive, zero or
    ///   negative. Where it is zero or negative, the task becomes
    ///   critical.
    std::string TotalFloat() const;
    void setTotalFloat(std::string v);
    /// Whether the optional attribute IsCritical is defined for this IfcTaskTime
    bool hasIsCritical() const;
    /// A flag which identifies whether a scheduled task is a
    ///   critical item within the programme.
    /// 
    /// NOTE: A task becomes critical when the float time
    ///   becomes zero or negative.
    bool IsCritical() const;
    void setIsCritical(bool v);
    /// Whether the optional attribute StatusTime is defined for this IfcTaskTime
    bool hasStatusTime() const;
    /// The date or time at which the status of the tasks within
    ///   the schedule is analyzed.
    std::string StatusTime() const;
    void setStatusTime(std::string v);
    /// Whether the optional attribute ActualDuration is defined for this IfcTaskTime
    bool hasActualDuration() const;
    /// The actual duration of the task. It is a measured value.
    ///   The value is either given as elapsed time or work time, which is defined by
    ///   DurationType.
    std::string ActualDuration() const;
    void setActualDuration(std::string v);
    /// Whether the optional attribute ActualStart is defined for this IfcTaskTime
    bool hasActualStart() const;
    /// The date on which a task is actually started. It is a measured value.
    /// 
    /// NOTE: The scheduled start date must be greater than
    ///   or equal to the earliest start date. No constraint is
    ///   applied to the actual start date with respect to the
    ///   scheduled start date since a task may be started earlier
    ///   than had originally been scheduled if circumstances allow.
    std::string ActualStart() const;
    void setActualStart(std::string v);
    /// Whether the optional attribute ActualFinish is defined for this IfcTaskTime
    bool hasActualFinish() const;
    /// The date on which a task is actually finished.
    std::string ActualFinish() const;
    void setActualFinish(std::string v);
    /// Whether the optional attribute RemainingTime is defined for this IfcTaskTime
    bool hasRemainingTime() const;
    /// The amount of time remaining to complete a task. It is a predicted value.
    ///   The value is either given as elapsed time or work time, which is defined by
    ///   DurationType.
    /// 
    /// NOTE: The time remaining in which to complete a task
    ///   may be determined both for tasks which have not yet started
    ///   and those which have. Remaining time for a task not yet
    ///   started has the same value as the scheduled duration. For a
    ///   task already started, remaining time is calculated as the
    ///   difference between the scheduled finish and the point of
    ///   analysis.
    std::string RemainingTime() const;
    void setRemainingTime(std::string v);
    /// Whether the optional attribute Completion is defined for this IfcTaskTime
    bool hasCompletion() const;
    /// The extent of completion expressed as a ratio or percentage.
    ///   It is a measured value.
    double Completion() const;
    void setCompletion(double v);
    virtual unsigned int getArgumentCount() const { return 20; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 3: return IfcUtil::Argument_ENUMERATION; case 4: return IfcUtil::Argument_STRING; case 5: return IfcUtil::Argument_STRING; case 6: return IfcUtil::Argument_STRING; case 7: return IfcUtil::Argument_STRING; case 8: return IfcUtil::Argument_STRING; case 9: return IfcUtil::Argument_STRING; case 10: return IfcUtil::Argument_STRING; case 11: return IfcUtil::Argument_STRING; case 12: return IfcUtil::Argument_STRING; case 13: return IfcUtil::Argument_BOOL; case 14: return IfcUtil::Argument_STRING; case 15: return IfcUtil::Argument_STRING; case 16: return IfcUtil::Argument_STRING; case 17: return IfcUtil::Argument_STRING; case 18: return IfcUtil::Argument_STRING; case 19: return IfcUtil::Argument_DOUBLE; } return IfcSchedulingTime::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 3: return Type::IfcTaskDurationEnum; case 4: return Type::IfcDuration; case 5: return Type::IfcDateTime; case 6: return Type::IfcDateTime; case 7: return Type::IfcDateTime; case 8: return Type::IfcDateTime; case 9: return Type::IfcDateTime; case 10: return Type::IfcDateTime; case 11: return Type::IfcDuration; case 12: return Type::IfcDuration; case 13: return Type::IfcBoolean; case 14: return Type::IfcDateTime; case 15: return Type::IfcDuration; case 16: return Type::IfcDateTime; case 17: return Type::IfcDateTime; case 18: return Type::IfcDuration; case 19: return Type::IfcPositiveRatioMeasure; } return IfcSchedulingTime::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 3: return "DurationType"; case 4: return "ScheduleDuration"; case 5: return "ScheduleStart"; case 6: return "ScheduleFinish"; case 7: return "EarlyStart"; case 8: return "EarlyFinish"; case 9: return "LateStart"; case 10: return "LateFinish"; case 11: return "FreeFloat"; case 12: return "TotalFloat"; case 13: return "IsCritical"; case 14: return "StatusTime"; case 15: return "ActualDuration"; case 16: return "ActualStart"; case 17: return "ActualFinish"; case 18: return "RemainingTime"; case 19: return "Completion"; } return IfcSchedulingTime::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcTaskTime (IfcEntityInstanceData* e);
    IfcTaskTime (boost::optional< std::string > v1_Name, boost::optional< IfcDataOriginEnum::IfcDataOriginEnum > v2_DataOrigin, boost::optional< std::string > v3_UserDefinedDataOrigin, boost::optional< IfcTaskDurationEnum::IfcTaskDurationEnum > v4_DurationType, boost::optional< std::string > v5_ScheduleDuration, boost::optional< std::string > v6_ScheduleStart, boost::optional< std::string > v7_ScheduleFinish, boost::optional< std::string > v8_EarlyStart, boost::optional< std::string > v9_EarlyFinish, boost::optional< std::string > v10_LateStart, boost::optional< std::string > v11_LateFinish, boost::optional< std::string > v12_FreeFloat, boost::optional< std::string > v13_TotalFloat, boost::optional< bool > v14_IsCritical, boost::optional< std::string > v15_StatusTime, boost::optional< std::string > v16_ActualDuration, boost::optional< std::string > v17_ActualStart, boost::optional< std::string > v18_ActualFinish, boost::optional< std::string > v19_RemainingTime, boost::optional< double > v20_Completion);
    typedef IfcTemplatedEntityList< IfcTaskTime > list;
};
/// IfcTaskTimeRecurring is a recurring instance of IfcTaskTime for handling regularly scheduled or repetitive tasks.
/// 
/// HISTORY: New entity in IFC2x4.
class IFC_PARSE_API IfcTaskTimeRecurring : public IfcTaskTime {
public:
    IfcRecurrencePattern* Recurrence() const;
    void setRecurrence(IfcRecurrencePattern* v);
    virtual unsigned int getArgumentCount() const { return 21; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 20: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcTaskTime::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 20: return Type::IfcRecurrencePattern; } return IfcTaskTime::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 20: return "Recurrence"; } return IfcTaskTime::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcTaskTimeRecurring (IfcEntityInstanceData* e);
    IfcTaskTimeRecurring (boost::optional< std::string > v1_Name, boost::optional< IfcDataOriginEnum::IfcDataOriginEnum > v2_DataOrigin, boost::optional< std::string > v3_UserDefinedDataOrigin, boost::optional< IfcTaskDurationEnum::IfcTaskDurationEnum > v4_DurationType, boost::optional< std::string > v5_ScheduleDuration, boost::optional< std::string > v6_ScheduleStart, boost::optional< std::string > v7_ScheduleFinish, boost::optional< std::string > v8_EarlyStart, boost::optional< std::string > v9_EarlyFinish, boost::optional< std::string > v10_LateStart, boost::optional< std::string > v11_LateFinish, boost::optional< std::string > v12_FreeFloat, boost::optional< std::string > v13_TotalFloat, boost::optional< bool > v14_IsCritical, boost::optional< std::string > v15_StatusTime, boost::optional< std::string > v16_ActualDuration, boost::optional< std::string > v17_ActualStart, boost::optional< std::string > v18_ActualFinish, boost::optional< std::string > v19_RemainingTime, boost::optional< double > v20_Completion, IfcRecurrencePattern* v21_Recurrence);
    typedef IfcTemplatedEntityList< IfcTaskTimeRecurring > list;
};
/// Definition: Address to which telephone, electronic mail and other forms of telecommunications should be addressed.
/// 
/// HISTORY New entity in IFC Release 2x.
/// 
/// IFC 2x4 change:  Added attribute MessagingIDs.
/// Type of attribute WWWHomePageURL compatibly changed from IfcLabel to IfcURIReference.
class IFC_PARSE_API IfcTelecomAddress : public IfcAddress {
public:
    /// Whether the optional attribute TelephoneNumbers is defined for this IfcTelecomAddress
    bool hasTelephoneNumbers() const;
    /// The list of telephone numbers at which telephone messages may be received.
    std::vector< std::string > /*[1:?]*/ TelephoneNumbers() const;
    void setTelephoneNumbers(std::vector< std::string > /*[1:?]*/ v);
    /// Whether the optional attribute FacsimileNumbers is defined for this IfcTelecomAddress
    bool hasFacsimileNumbers() const;
    /// The list of fax numbers at which fax messages may be received.
    std::vector< std::string > /*[1:?]*/ FacsimileNumbers() const;
    void setFacsimileNumbers(std::vector< std::string > /*[1:?]*/ v);
    /// Whether the optional attribute PagerNumber is defined for this IfcTelecomAddress
    bool hasPagerNumber() const;
    /// The pager number at which paging messages may be received.
    std::string PagerNumber() const;
    void setPagerNumber(std::string v);
    /// Whether the optional attribute ElectronicMailAddresses is defined for this IfcTelecomAddress
    bool hasElectronicMailAddresses() const;
    /// The list of Email addresses at which Email messages may be received.
    std::vector< std::string > /*[1:?]*/ ElectronicMailAddresses() const;
    void setElectronicMailAddresses(std::vector< std::string > /*[1:?]*/ v);
    /// Whether the optional attribute WWWHomePageURL is defined for this IfcTelecomAddress
    bool hasWWWHomePageURL() const;
    /// The world wide web address at which the preliminary page of information for the person or organization can be located.
    /// NOTE: Information on the world wide web for a person or organization may be separated 
    /// into a number of pages and across a number of host sites, all of which may be linked together. It is assumed that 
    /// all such information may be referenced from a single page that is termed the home page for that person or organization.
    std::string WWWHomePageURL() const;
    void setWWWHomePageURL(std::string v);
    /// Whether the optional attribute MessagingIDs is defined for this IfcTelecomAddress
    bool hasMessagingIDs() const;
    /// IDs or addresses for any other means of telecommunication, for example instant messaging, voice-over-IP, or file transfer protocols. The communication protocol is indicated by the URI value with scheme designations such as irc:, sip:, or ftp:.
    std::vector< std::string > /*[1:?]*/ MessagingIDs() const;
    void setMessagingIDs(std::vector< std::string > /*[1:?]*/ v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 3: return IfcUtil::Argument_AGGREGATE_OF_STRING; case 4: return IfcUtil::Argument_AGGREGATE_OF_STRING; case 5: return IfcUtil::Argument_STRING; case 6: return IfcUtil::Argument_AGGREGATE_OF_STRING; case 7: return IfcUtil::Argument_STRING; case 8: return IfcUtil::Argument_AGGREGATE_OF_STRING; } return IfcAddress::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 3: return Type::IfcLabel; case 4: return Type::IfcLabel; case 5: return Type::IfcLabel; case 6: return Type::IfcLabel; case 7: return Type::IfcURIReference; case 8: return Type::IfcURIReference; } return IfcAddress::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 3: return "TelephoneNumbers"; case 4: return "FacsimileNumbers"; case 5: return "PagerNumber"; case 6: return "ElectronicMailAddresses"; case 7: return "WWWHomePageURL"; case 8: return "MessagingIDs"; } return IfcAddress::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcTelecomAddress (IfcEntityInstanceData* e);
    IfcTelecomAddress (boost::optional< IfcAddressTypeEnum::IfcAddressTypeEnum > v1_Purpose, boost::optional< std::string > v2_Description, boost::optional< std::string > v3_UserDefinedPurpose, boost::optional< std::vector< std::string > /*[1:?]*/ > v4_TelephoneNumbers, boost::optional< std::vector< std::string > /*[1:?]*/ > v5_FacsimileNumbers, boost::optional< std::string > v6_PagerNumber, boost::optional< std::vector< std::string > /*[1:?]*/ > v7_ElectronicMailAddresses, boost::optional< std::string > v8_WWWHomePageURL, boost::optional< std::vector< std::string > /*[1:?]*/ > v9_MessagingIDs);
    typedef IfcTemplatedEntityList< IfcTelecomAddress > list;
};
/// Definition from ISO/CD 10303-46:1992: The text style is a presentation style for annotation text.
/// 
/// The IfcTextStyle provides the text style table for presentation information assigned to text literals. The style is defined by color, text font characteristics, and text box characteristics. The definitions are based upon:
/// 
/// definitions from ISO/IS 10303-46:1994 for (old) vector based and monospace text.
///   definitions from Cascading Style Sheets, level 1, W3C Recommendation 17 Dec 1996, revised 11 Jan 1999, CSS1, for all true type text. The use of the CSS1 definitions is the preferred way to represent text styles.
/// 
/// An IfcTextStyle, when representing (old) vector based and monospace text, is instantiated with:
/// 
/// TextCharacterAppearance:: IfcTextStyleForDefinedFont (with BackgroundColour = NIL)
///   TextStyle:: IfcTextStyleWithBoxCharacteristics
///   TextFontStyle:: IfcDraughtingPreDefinedTextFont or IfcExternallyDefinedTextFont
/// 
/// An IfcTextStyle, when representing (new) true type text, based on CSS1 definitions, is instantiated with:
/// 
/// TextCharacterAppearance:: IfcTextStyleForDefinedFont
///   TextStyle:: IfcTextStyleTextModel
///   TextFontStyle:: IfcTextStyleFontModel
/// 
/// An IfcTextStyle can be assigned to IfcTextLiteral via the IfcPresentationStyleAssignment through an intermediate IfcAnnotationTextOccurrence.
/// 
/// NOTE  Corresponding ISO 10303 name: text_style. Please refer to ISO/IS 10303-46:1994 for the final definition of the formal standard. In order to avoid ANDOR subtype relationships, the IfcTextBlockStyleSelect has been introduced that allows the combination of a text style as having box characteristic, and/or having spacing, or having none of those additional properties.
/// 
/// NOTE  Corresponding CSS1 definitions are: Font properties (font-family, font-style, font-variant, font-weight, font-size), Color and background properties (color, background-color) and Text properties (word-spacing, letter-spacing, text-decoration, text-transform, text-align, text-indent, line-height).
/// 
/// HISTORY  New entity in IFC2x2.
/// 
/// IFC2x3 CHANGE  The IfcTextStyle has been changed by adding TextFontStyle and different data types for TextStyle and IfcCharacterStyleSelect.
class IFC_PARSE_API IfcTextStyle : public IfcPresentationStyle {
public:
    /// Whether the optional attribute TextCharacterAppearance is defined for this IfcTextStyle
    bool hasTextCharacterAppearance() const;
    /// A character style to be used for presented text.
    IfcTextStyleForDefinedFont* TextCharacterAppearance() const;
    void setTextCharacterAppearance(IfcTextStyleForDefinedFont* v);
    /// Whether the optional attribute TextStyle is defined for this IfcTextStyle
    bool hasTextStyle() const;
    /// The style applied to the text block for its visual appearance.
    /// It defines the text block characteristics, either for vector based or monospace text fonts (see select item IfcTextStyleWithBoxCharacteristics), or for true type text fonts (see select item IfcTextStyleTextModel.
    /// 
    /// IFC2x Edition 3 CHANGE  The attribute TextBlockStyle has been changed from SET[1:?] to a non-aggregated optional, it has been renamed from TextStyles.
    IfcTextStyleTextModel* TextStyle() const;
    void setTextStyle(IfcTextStyleTextModel* v);
    /// The style applied to the text font for its visual appearance.
    /// It defines the font family, font style, weight and size.
    /// 
    /// IFC2x Edition 2 Addendum 2 CHANGE The attribute TextFontStyle is a new attribute attached to IfcTextStyle.
    IfcTextFontSelect* TextFontStyle() const;
    void setTextFontStyle(IfcTextFontSelect* v);
    /// Whether the optional attribute ModelOrDraughting is defined for this IfcTextStyle
    bool hasModelOrDraughting() const;
    bool ModelOrDraughting() const;
    void setModelOrDraughting(bool v);
    virtual unsigned int getArgumentCount() const { return 5; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 1: return IfcUtil::Argument_ENTITY_INSTANCE; case 2: return IfcUtil::Argument_ENTITY_INSTANCE; case 3: return IfcUtil::Argument_ENTITY_INSTANCE; case 4: return IfcUtil::Argument_BOOL; } return IfcPresentationStyle::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 1: return Type::IfcTextStyleForDefinedFont; case 2: return Type::IfcTextStyleTextModel; case 3: return Type::IfcTextFontSelect; case 4: return Type::IfcBoolean; } return IfcPresentationStyle::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 1: return "TextCharacterAppearance"; case 2: return "TextStyle"; case 3: return "TextFontStyle"; case 4: return "ModelOrDraughting"; } return IfcPresentationStyle::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcTextStyle (IfcEntityInstanceData* e);
    IfcTextStyle (boost::optional< std::string > v1_Name, IfcTextStyleForDefinedFont* v2_TextCharacterAppearance, IfcTextStyleTextModel* v3_TextStyle, IfcTextFontSelect* v4_TextFontStyle, boost::optional< bool > v5_ModelOrDraughting);
    typedef IfcTemplatedEntityList< IfcTextStyle > list;
};
/// Definition from ISO/CD 10303-46:1992: A text style for defined font is a character glyph style for pre-defined or externally defined text fonts.
/// 
/// Definition from CSS1 (W3C Recommendation): These properties describe the color (often called foreground color) and background of an element (i.e. the surface onto which the content is rendered). One can set a background color.
/// 
/// NOTE  The CSS1 definition allows also for a background image. This has not been incorporated into IFC.
/// 
/// The IfcTextStyleForDefinedFont combines the text font color with an optional background color, that fills the text box, defined by the planar extent given to the text literal.
/// 
/// NOTE  Corresponding ISO 10303 name: text_style_for_defined_font. Please refer to ISO/IS
/// 10303-46:1994, p.122 for the final definition of the formal standard. The attribute BackgroundColour
/// has been added.
/// 
/// NOTE  Corresponding CSS1 definitions are Color and background properties (color, background-color).
/// 
/// HISTORY  New entity in IFC2x3.
/// 
/// IFC2x3 CHANGE  The IfcTextStyleForDefinedFont has been added and replaces IfcColour at the IfcCharacterStyleSelect.
class IFC_PARSE_API IfcTextStyleForDefinedFont : public IfcPresentationItem {
public:
    /// This property describes the text color of an element (often referred to as the foreground color).
    IfcColour* Colour() const;
    void setColour(IfcColour* v);
    /// Whether the optional attribute BackgroundColour is defined for this IfcTextStyleForDefinedFont
    bool hasBackgroundColour() const;
    /// This property sets the background color of an element.
    IfcColour* BackgroundColour() const;
    void setBackgroundColour(IfcColour* v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcPresentationItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcColour; case 1: return Type::IfcColour; } return IfcPresentationItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Colour"; case 1: return "BackgroundColour"; } return IfcPresentationItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcTextStyleForDefinedFont (IfcEntityInstanceData* e);
    IfcTextStyleForDefinedFont (IfcColour* v1_Colour, IfcColour* v2_BackgroundColour);
    typedef IfcTemplatedEntityList< IfcTextStyleForDefinedFont > list;
};
/// Definition from CSS1 (W3C Recommendation): The properties defined in the text model affect the visual presentation of characters, spaces, words, and paragraphs.
/// 
/// The IfcTextStyleTextModel combines all text style properties, that affect the presentation of a text literal within a given extent. It includes the spacing between characters and words, the horizontal and vertical alignment of the text within the planar box of the extent, decorations (like underline), transformations of the literal (like uppercase), and the height of each text line within a multi-line text block.
/// 
/// NOTE  Corresponding CSS1 definitions are Text properties (word-spacing, letter-spacing, text-decoration, vertical-align, text-transform, text-align, text-indent, line-height).
/// 
/// HISTORY  New entity in IFC2x3.
class IFC_PARSE_API IfcTextStyleTextModel : public IfcPresentationItem {
public:
    /// Whether the optional attribute TextIndent is defined for this IfcTextStyleTextModel
    bool hasTextIndent() const;
    /// The property specifies the indentation that appears before the first formatted line.
    ///   NOTE  It has been introduced for later compliance to full CSS1 support.
    IfcSizeSelect* TextIndent() const;
    void setTextIndent(IfcSizeSelect* v);
    /// Whether the optional attribute TextAlign is defined for this IfcTextStyleTextModel
    bool hasTextAlign() const;
    /// This property describes how text is aligned horizontally within the element. The actual justification algorithm used is dependent on the rendering algorithm.
    std::string TextAlign() const;
    void setTextAlign(std::string v);
    /// Whether the optional attribute TextDecoration is defined for this IfcTextStyleTextModel
    bool hasTextDecoration() const;
    /// This property describes decorations that are added to the text of an element.
    std::string TextDecoration() const;
    void setTextDecoration(std::string v);
    /// Whether the optional attribute LetterSpacing is defined for this IfcTextStyleTextModel
    bool hasLetterSpacing() const;
    /// The length unit indicates an addition to the default space between characters. Values can be negative, but there may be implementation-specific limits. The user agent is free to select the exact spacing algorithm. The letter spacing may also be influenced by justification (which is a value of the 'align' property).
    ///   NOTE  The following values are allowed, IfcDescriptiveMeasure with value='normal', or IfcLengthMeasure, the length unit is globally defined at IfcUnitAssignment.
    IfcSizeSelect* LetterSpacing() const;
    void setLetterSpacing(IfcSizeSelect* v);
    /// Whether the optional attribute WordSpacing is defined for this IfcTextStyleTextModel
    bool hasWordSpacing() const;
    /// The length unit indicates an addition to the default space between words. Values can be negative, but there may be implementation-specific limits. The user agent is free to select the exact spacing algorithm. The word spacing may also be influenced by justification (which is a value of the 'text-align' property).
    ///   NOTE  It has been introduced for later compliance to full CSS1 support.
    IfcSizeSelect* WordSpacing() const;
    void setWordSpacing(IfcSizeSelect* v);
    /// Whether the optional attribute TextTransform is defined for this IfcTextStyleTextModel
    bool hasTextTransform() const;
    /// This property describes how text characters may transform to upper case, lower case, or capitalized case, independent of the character case used in the text literal.
    ///   NOTE  It has been introduced for later compliance to full CSS1 support.
    std::string TextTransform() const;
    void setTextTransform(std::string v);
    /// Whether the optional attribute LineHeight is defined for this IfcTextStyleTextModel
    bool hasLineHeight() const;
    /// The property sets the distance between two adjacent lines' baselines.
    /// When a ratio value is specified, the line height is given by the font size of the current element multiplied with the numerical value. A value of 'normal' sets the line height to a reasonable value for the element's font. It is suggested that user agents set the 'normal' value to be a ratio number in the range of 1.0 to 1.2.
    ///   NOTE  The following values are allowed: IfcDescriptiveMeasure with value='normal', or 
    /// IfcLengthMeasure, with non-negative values, the length unit is globally defined at IfcUnitAssignment, or IfcRatioMeasure.
    IfcSizeSelect* LineHeight() const;
    void setLineHeight(IfcSizeSelect* v);
    virtual unsigned int getArgumentCount() const { return 7; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_STRING; case 2: return IfcUtil::Argument_STRING; case 3: return IfcUtil::Argument_ENTITY_INSTANCE; case 4: return IfcUtil::Argument_ENTITY_INSTANCE; case 5: return IfcUtil::Argument_STRING; case 6: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcPresentationItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcSizeSelect; case 1: return Type::IfcTextAlignment; case 2: return Type::IfcTextDecoration; case 3: return Type::IfcSizeSelect; case 4: return Type::IfcSizeSelect; case 5: return Type::IfcTextTransformation; case 6: return Type::IfcSizeSelect; } return IfcPresentationItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "TextIndent"; case 1: return "TextAlign"; case 2: return "TextDecoration"; case 3: return "LetterSpacing"; case 4: return "WordSpacing"; case 5: return "TextTransform"; case 6: return "LineHeight"; } return IfcPresentationItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcTextStyleTextModel (IfcEntityInstanceData* e);
    IfcTextStyleTextModel (IfcSizeSelect* v1_TextIndent, boost::optional< std::string > v2_TextAlign, boost::optional< std::string > v3_TextDecoration, IfcSizeSelect* v4_LetterSpacing, IfcSizeSelect* v5_WordSpacing, boost::optional< std::string > v6_TextTransform, IfcSizeSelect* v7_LineHeight);
    typedef IfcTemplatedEntityList< IfcTextStyleTextModel > list;
};
/// The IfcTextureCoordinate a an abstract supertype of the different kinds to apply texture coordinates to geometries. For vertex based geometries an explicit assignment of 2D texture vertices to the 3D geometry points is supported by the subtype IfcTextureMap, in addition there can be a procedural description of how texture coordinates shall be applied to geometric items. If no IfcTextureCoordinate is provided for the IfcSurfaceTexture, the default mapping shall be used.
/// 
/// See relevant subtypes of IfcGeometricRepresentationItem for default texture mapping description.
/// 
/// NOTE  The definitions of texturing within this standard have been developed in dependence on the texture component of X3D. See ISO/IEC 19775-1.2:2008 X3D Architecture and base components Edition 2, Part 1, 18 Texturing component for the definitions in the international standard.
/// 
/// HISTORY  New entity in IFC2x2.
/// 
/// IFC2x3 CHANGE  The attribute Texture is deleted.
/// 
/// IFC2x4 CHANGE  The inverse attribute AnnotatedSurface is deleted, and the inverse AppliesTextures is added.
class IFC_PARSE_API IfcTextureCoordinate : public IfcPresentationItem {
public:
    IfcTemplatedEntityList< IfcSurfaceTexture >::ptr Maps() const;
    void setMaps(IfcTemplatedEntityList< IfcSurfaceTexture >::ptr v);
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } return IfcPresentationItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcSurfaceTexture; } return IfcPresentationItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Maps"; } return IfcPresentationItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcTextureCoordinate (IfcEntityInstanceData* e);
    IfcTextureCoordinate (IfcTemplatedEntityList< IfcSurfaceTexture >::ptr v1_Maps);
    typedef IfcTemplatedEntityList< IfcTextureCoordinate > list;
};
/// The IfcTextureCoordinateGenerator describes a procedurally defined mapping function with input parameter to map 2D texture coordinates to 3D geometry vertices. The allowable Mode values and input Parameter need to be agreed upon in view definitions and implementer agreements.
/// 
/// It is recommended to use the texture coordinate generation modes as defined in X3D.
/// 
/// The following definitions from ISO/IEC 19775-1 X3D Architecture and base components (X3D Specification) apply:
/// 
/// The TextureCoordinateGenerator supports the automatic generation of texture coordinates for geometric shapes.
/// The mode field describes the algorithm used to compute texture coordinates.
/// 
/// SPHERE,
/// CAMERASPACENORMAL,
/// CAMERASPACEPOSITION,
/// CAMERASPACEREFLECTIONVECTOR,
/// SPHERE-LOCAL,
/// COORD,
/// COORD-EYE,
/// NOISE,
/// NOISE-EYE,
/// SPHERE-REFLECT,
/// SPHERE-REFLECT-LOCAL
/// 
/// NOTE  The definitions of texturing within this standard have been developed in dependence on the texture component of X3D. See ISO/IEC 19775-1.2:2008 X3D Architecture and base components Edition 2, Part 1, 18 Texturing component for the definitions in the international standard.
/// 
/// HISTORY New entity in IFC2x2.
/// 
/// IFC2x2 Addendum 2 CHANGE  The attribute Texturehas been deleted.
class IFC_PARSE_API IfcTextureCoordinateGenerator : public IfcTextureCoordinate {
public:
    /// The Mode attribute describes the algorithm used to compute texture coordinates.
    /// 
    /// NOTE  The applicable values for the Mode attribute are determined by view definitions or implementer agreements. It is recommended to use the modes described in ISO/IES 19775-1.2:2008 X3D Architecture and base components Edition 2, Part 1. See 18.4.8 TextureCoordinateGenerator for recommended values.
    std::string Mode() const;
    void setMode(std::string v);
    /// Whether the optional attribute Parameter is defined for this IfcTextureCoordinateGenerator
    bool hasParameter() const;
    /// The parameters used as arguments by the function as specified by Mode.
    /// 
    /// IFC2x4 CHANGE  Made optional data type restricted to REAL.
    std::vector< double > /*[1:?]*/ Parameter() const;
    void setParameter(std::vector< double > /*[1:?]*/ v);
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 1: return IfcUtil::Argument_STRING; case 2: return IfcUtil::Argument_AGGREGATE_OF_DOUBLE; } return IfcTextureCoordinate::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 1: return Type::IfcLabel; case 2: return Type::IfcReal; } return IfcTextureCoordinate::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 1: return "Mode"; case 2: return "Parameter"; } return IfcTextureCoordinate::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcTextureCoordinateGenerator (IfcEntityInstanceData* e);
    IfcTextureCoordinateGenerator (IfcTemplatedEntityList< IfcSurfaceTexture >::ptr v1_Maps, std::string v2_Mode, boost::optional< std::vector< double > /*[1:?]*/ > v3_Parameter);
    typedef IfcTemplatedEntityList< IfcTextureCoordinateGenerator > list;
};
/// An IfcTextureMap provides the mapping of the
/// 2-dimensional texture coordinates to the surface onto which it is
/// mapped. It is used for mapping the texture to surfaces of vertex
/// based geometry models, such as
/// 
/// IfcFacetedBrep
/// IfcFacetedBrepWithVoids
/// IfcFaceBasedSurfaceModel
/// IfcShellBasedSurfaceModel
/// 
/// The IfcTextureMap has a list of TextureVertex,
/// that corresponds to the points of the face bound of the vertex
/// based geometry item. The corresponding pair of lists is:
/// 
/// the list of Polygon of type IfcCartesianPoint,
/// and
/// the list of Vertices of type
/// IfcTextureVertex.
/// 
/// Each IfcTextureVertex (given as S, T coordinates of the
/// 2-dimension texture coordinate system) corresponds to the geometric
/// coordinates of the IfcCartesianPoint (given as 3-dimension
/// X, Y, and Z coordinates within the object coordinate system of the
/// geometric item).
/// The following definitions from ISO/IEC 19775-1 X3D Architecture
/// and base components (X3D Specification)
/// apply:
/// 
/// The TextureCoordinate node is a geometry property node that
/// specifies a set of 2D texture coordinates used by vertex-based
/// geometry nodes to map textures to vertices.
/// 
/// NOTE  In contrary to the
/// X3D vertext based geometry, for example IndexedFaceSet and
/// ElevationGrid, the vertext based geometry in IFC may include inner
/// loops. The areas of inner loops have to be cut-out from the texture
/// applied to the outer loop.
/// 
/// Figure 301 illustrates applying a texture map to a vertex based geometry.
/// 
/// Figure 301 — Texture map
/// 
/// HISTORY  New entity in IFC2x2.
/// 
/// IFC2x3 CHANGE  The attribute Texture is deleted, and the attribute TextureMaps is added.
/// 
/// IFC2x4 CHANGE  The attribute TextureMap is replaced by Vertices, and the attribute AppliedTo is added.
/// 
/// Informal propositions:
/// 
/// The FaceBound referenced in AppliedTo shall be used by the vertex based geometry, to which this texture map is assigned to by through the IfcStyledItem.
class IFC_PARSE_API IfcTextureMap : public IfcTextureCoordinate {
public:
    /// List of texture coordinate vertices that are applied to the corresponding points of the polyloop defining a face bound.
    /// 
    /// NOTE  The corresponding face bound may be an inner loop.
    IfcTemplatedEntityList< IfcTextureVertex >::ptr Vertices() const;
    void setVertices(IfcTemplatedEntityList< IfcTextureVertex >::ptr v);
    IfcFace* MappedTo() const;
    void setMappedTo(IfcFace* v);
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 1: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 2: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcTextureCoordinate::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 1: return Type::IfcTextureVertex; case 2: return Type::IfcFace; } return IfcTextureCoordinate::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 1: return "Vertices"; case 2: return "MappedTo"; } return IfcTextureCoordinate::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcTextureMap (IfcEntityInstanceData* e);
    IfcTextureMap (IfcTemplatedEntityList< IfcSurfaceTexture >::ptr v1_Maps, IfcTemplatedEntityList< IfcTextureVertex >::ptr v2_Vertices, IfcFace* v3_MappedTo);
    typedef IfcTemplatedEntityList< IfcTextureMap > list;
};
/// An IfcTextureVertex is a list of 2 (S, T) texture coordinates. 
/// 
/// The following additional definitions from ISO 19775 apply:
/// 
/// Each vertex-based geometry node uses a set of 2D texture
/// coordinates that map textures to vertices. Texture map values (
/// ImageTexture, PixelTexture) range from [0.0, 1.0] along the S-axis and
/// T-axis. However, texture coordinate values may be in the range
/// (-∞,∞). Texture coordinates identify a location
/// (and thus a
/// colour value) in the texture map. The horizontal coordinate S is
/// specified first, followed by the vertical coordinate T. If the texture
/// map is repeated in a given direction (S-axis or T-axis), a texture
/// coordinate C (s or t) is mapped into a texture map that has N pixels in
/// the given direction as follows: 
/// 
/// Texture map location = (C - floor(C)) × N			 
/// 
/// If the texture map is not
/// repeated, the texture coordinates are
/// clamped to the 0.0 to 1.0 range as follows: 
/// 
/// Texture map location = N,     if C > 1.0,                     = 0.0,   if C < 0.0,                     = C × N, if 0.0 ≤ C ≤ 1.0.
/// 
/// Texture coordinates may be transformed (scaled, rotated, translated) by supplying a TextureTransform as a component of the texture's definition. 
/// 
/// HISTORY: New entity in IFC 2x2.
class IFC_PARSE_API IfcTextureVertex : public IfcPresentationItem {
public:
    /// The first coordinate[1] is the S, the second coordinate[2] is the T parameter value.
    std::vector< double > /*[2:2]*/ Coordinates() const;
    void setCoordinates(std::vector< double > /*[2:2]*/ v);
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_AGGREGATE_OF_DOUBLE; } return IfcPresentationItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcParameterValue; } return IfcPresentationItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Coordinates"; } return IfcPresentationItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcTextureVertex (IfcEntityInstanceData* e);
    IfcTextureVertex (std::vector< double > /*[2:2]*/ v1_Coordinates);
    typedef IfcTemplatedEntityList< IfcTextureVertex > list;
};

class IFC_PARSE_API IfcTextureVertexList : public IfcPresentationItem {
public:
    std::vector< std::vector< double > > TexCoordsList() const;
    void setTexCoordsList(std::vector< std::vector< double > > v);
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_AGGREGATE_OF_AGGREGATE_OF_DOUBLE; } return IfcPresentationItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcParameterValue; } return IfcPresentationItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "TexCoordsList"; } return IfcPresentationItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcTextureVertexList (IfcEntityInstanceData* e);
    IfcTextureVertexList (std::vector< std::vector< double > > v1_TexCoordsList);
    typedef IfcTemplatedEntityList< IfcTextureVertexList > list;
};
/// IfcTimePeriod defines a time period given by a start and end time. Both time definitions consider the time zone and allow for the daylight savings offset.
/// 
/// HISTORY: New entity in IFC R2x4.
/// 
/// Use definitions
/// A time period is defined by a start and an end time, which is defined by IfcTime. The given time period should be within reasonable values (for example, the start time must be before the end time). It is furthermore expected that both time definitions use the same time zone and, if given, the same daylight saving offset.
class IFC_PARSE_API IfcTimePeriod : public IfcUtil::IfcBaseEntity {
public:
    /// Start time of the time period.
    std::string StartTime() const;
    void setStartTime(std::string v);
    /// End time of the time period.
    std::string EndTime() const;
    void setEndTime(std::string v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_STRING; case 1: return IfcUtil::Argument_STRING; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcTime; case 1: return Type::IfcTime; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "StartTime"; case 1: return "EndTime"; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcTimePeriod (IfcEntityInstanceData* e);
    IfcTimePeriod (std::string v1_StartTime, std::string v2_EndTime);
    typedef IfcTemplatedEntityList< IfcTimePeriod > list;
};
/// A time series is a set of a time-stamped data entries. It allows a natural association of data collected over intervals of time. Time series can be regular or irregular. In regular time series data arrive predictably at predefined intervals.  In irregular time series  some or all time stamps do not follow a repetitive pattern and unpredictable bursts of data may arrive at unspecified points in time.
/// 
/// The modeling of buildings and their performance involves data that are generated and recorded over a period of time.  Such data cover a large spectrum, from weather data to schedules of all kinds to status measurements to reporting to everything else that has a time related aspect. Their correct placement in time is essential for their proper understanding and use, and the IfcTimeSeries subtypes provide the appropriate data structures to accommodate these types of data.
/// 
/// HISTORY: New entity in IFC 2x2.
class IFC_PARSE_API IfcTimeSeries : public IfcUtil::IfcBaseEntity {
public:
    /// An unique name for the time series.
    std::string Name() const;
    void setName(std::string v);
    /// Whether the optional attribute Description is defined for this IfcTimeSeries
    bool hasDescription() const;
    /// A text description of the data that the series represents.
    std::string Description() const;
    void setDescription(std::string v);
    /// The start time of a time series.
    std::string StartTime() const;
    void setStartTime(std::string v);
    /// The end time of a time series.
    std::string EndTime() const;
    void setEndTime(std::string v);
    /// The time series data type.
    IfcTimeSeriesDataTypeEnum::IfcTimeSeriesDataTypeEnum TimeSeriesDataType() const;
    void setTimeSeriesDataType(IfcTimeSeriesDataTypeEnum::IfcTimeSeriesDataTypeEnum v);
    /// The orgin of a time series data.
    IfcDataOriginEnum::IfcDataOriginEnum DataOrigin() const;
    void setDataOrigin(IfcDataOriginEnum::IfcDataOriginEnum v);
    /// Whether the optional attribute UserDefinedDataOrigin is defined for this IfcTimeSeries
    bool hasUserDefinedDataOrigin() const;
    /// Value of the data origin if DataOrigin attribute is USERDEFINED.
    std::string UserDefinedDataOrigin() const;
    void setUserDefinedDataOrigin(std::string v);
    /// Whether the optional attribute Unit is defined for this IfcTimeSeries
    bool hasUnit() const;
    /// The unit to be assigned to all values within the time series. Note that mixing units is not allowed. If the value is not given, the global unit for the type of IfcValue, as defined at IfcProject.UnitsInContext is used.
    IfcUnit* Unit() const;
    void setUnit(IfcUnit* v);
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_STRING; case 1: return IfcUtil::Argument_STRING; case 2: return IfcUtil::Argument_STRING; case 3: return IfcUtil::Argument_STRING; case 4: return IfcUtil::Argument_ENUMERATION; case 5: return IfcUtil::Argument_ENUMERATION; case 6: return IfcUtil::Argument_STRING; case 7: return IfcUtil::Argument_ENTITY_INSTANCE; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcLabel; case 1: return Type::IfcText; case 2: return Type::IfcDateTime; case 3: return Type::IfcDateTime; case 4: return Type::IfcTimeSeriesDataTypeEnum; case 5: return Type::IfcDataOriginEnum; case 6: return Type::IfcLabel; case 7: return Type::IfcUnit; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Name"; case 1: return "Description"; case 2: return "StartTime"; case 3: return "EndTime"; case 4: return "TimeSeriesDataType"; case 5: return "DataOrigin"; case 6: return "UserDefinedDataOrigin"; case 7: return "Unit"; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcExternalReferenceRelationship >::ptr HasExternalReference() const; // INVERSE IfcExternalReferenceRelationship::RelatedResourceObjects
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcTimeSeries (IfcEntityInstanceData* e);
    IfcTimeSeries (std::string v1_Name, boost::optional< std::string > v2_Description, std::string v3_StartTime, std::string v4_EndTime, IfcTimeSeriesDataTypeEnum::IfcTimeSeriesDataTypeEnum v5_TimeSeriesDataType, IfcDataOriginEnum::IfcDataOriginEnum v6_DataOrigin, boost::optional< std::string > v7_UserDefinedDataOrigin, IfcUnit* v8_Unit);
    typedef IfcTemplatedEntityList< IfcTimeSeries > list;
};
/// A time series value is a list of values that comprise the time series. At least one value must be supplied. Applications are expected to normalize values by applying the following three rules:
/// 
/// All time (universal, local, daylight savings, and solar) is normalized against the ISO 8601 standard GMT/UTC (Universal Coordinated Time).
/// Any rollover is handled by the application providing the data.  Rollover occurs, for example, when the measurement device resets itself while measuring and the recording data do not include the data measured before the reset.
/// The normalized data refer to the preceding time unit.  The time series example shown in Figure 241 below contains four time points: Time "a" indicates the beginning of the time series and the associated datum has no relevance.  Data at time points "b," "c" and "d" are associated with values 1, 2 and 3, respectively.
/// 
/// Figure 241 — Time series value 
/// 
/// HISTORY  New entity in IFC2x2.
class IFC_PARSE_API IfcTimeSeriesValue : public IfcUtil::IfcBaseEntity {
public:
    /// A list of time-series values. At least one value is required.
    IfcEntityList::ptr ListValues() const;
    void setListValues(IfcEntityList::ptr v);
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcValue; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "ListValues"; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcTimeSeriesValue (IfcEntityInstanceData* e);
    IfcTimeSeriesValue (IfcEntityList::ptr v1_ListValues);
    typedef IfcTemplatedEntityList< IfcTimeSeriesValue > list;
};
/// Definition from ISO/CD 10303-42:1992: The topological representation item is the supertype for all the topological representation items in the geometry resource. 
/// 
/// NOTE  Corresponding ISO 10303 entity: topological_representation_item. Please refer to ISO/IS 10303-42:1994, p.129 for the final definition of the formal standard.
/// 
/// HISTORY: New entity in IFC Release 1.5
class IFC_PARSE_API IfcTopologicalRepresentationItem : public IfcRepresentationItem {
public:
    virtual unsigned int getArgumentCount() const { return 0; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcRepresentationItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcRepresentationItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcRepresentationItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcTopologicalRepresentationItem (IfcEntityInstanceData* e);
    IfcTopologicalRepresentationItem ();
    typedef IfcTemplatedEntityList< IfcTopologicalRepresentationItem > list;
};
/// IfcTopologyRepresentation
/// represents the concept of a particular topological representation of a
/// product or a product component within a representation context. This
/// representation context does not need to be (but may be) a geometric
/// representation context. Several representation types for shape
/// representation are included as predefined types: 
/// 
/// Vertex
///   topological vertex
/// representation (with or without assigned geometry)
/// 
/// Edge
///   topological edge
/// representation (with or without assigned geometry)
/// 
/// Path
///   topological path
/// representation (with or without assigned geometry)
/// 
/// Face
///   topological face
/// representation (with or without assigned geometry)
/// 
/// Shell
///   topological shell
/// representation (with or without assigned geometry)
/// 
/// Undefined
///   no constraints imposed
/// 
/// The representation type is
/// given as a string value at the inherited attribute 'RepresentationType'.
/// 
/// HISTORY: New entity in IFC 2x2.
class IFC_PARSE_API IfcTopologyRepresentation : public IfcShapeModel {
public:
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcShapeModel::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcShapeModel::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcShapeModel::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcTopologyRepresentation (IfcEntityInstanceData* e);
    IfcTopologyRepresentation (IfcRepresentationContext* v1_ContextOfItems, boost::optional< std::string > v2_RepresentationIdentifier, boost::optional< std::string > v3_RepresentationType, IfcTemplatedEntityList< IfcRepresentationItem >::ptr v4_Items);
    typedef IfcTemplatedEntityList< IfcTopologyRepresentation > list;
};
/// IfcUnitAssignment indicates a set of units which may be assigned. Within an IfcUnitAssigment each unit definition shall be unique; that is, there shall be no redundant unit definitions for the same unit type such as length unit or area unit. For currencies, there shall be only a single IfcMonetaryUnit within an IfcUnitAssignment.
/// 
/// NOTE  A project (IfcProject) has a unit assignment which establishes a set of units which will be used globally within the project, if not otherwise defined. Other objects may have local unit assignments if there is a requirement for them to make use of units which do not fall within the project unit assignment.
/// 
/// HISTORY  New entity in IFC Release 1.5.1.
class IFC_PARSE_API IfcUnitAssignment : public IfcUtil::IfcBaseEntity {
public:
    /// Units to be included within a unit assignment.
    IfcEntityList::ptr Units() const;
    void setUnits(IfcEntityList::ptr v);
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcUnit; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Units"; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcUnitAssignment (IfcEntityInstanceData* e);
    IfcUnitAssignment (IfcEntityList::ptr v1_Units);
    typedef IfcTemplatedEntityList< IfcUnitAssignment > list;
};
/// Definition from ISO/CD 10303-42:1992: A vertex is the topological construct corresponding to a point. It has dimensionality 0 and extent 0. The domain of a vertex, if present, is a point in m dimensional real space RM; this is represented by the vertex point subtype. 
/// 
/// NOTE  Corresponding ISO 10303 entity: vertex. Please refer to ISO/IS 10303-42:1994, p. 129 for the final definition of the formal standard.
/// 
/// HISTORY  New Entity in IFC Release 2.0
/// 
/// Informal proposition:
/// 
/// The vertex has dimensionality 0. This is a fundamental property of the vertex.
/// The extent of a vertex is defined to be zero.
class IFC_PARSE_API IfcVertex : public IfcTopologicalRepresentationItem {
public:
    virtual unsigned int getArgumentCount() const { return 0; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcTopologicalRepresentationItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcTopologicalRepresentationItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcTopologicalRepresentationItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcVertex (IfcEntityInstanceData* e);
    IfcVertex ();
    typedef IfcTemplatedEntityList< IfcVertex > list;
};
/// Definition from ISO/CD 10303-42:1992: A vertex point is a vertex which has its geometry defined as a point.  
/// 
/// NOTE  Corresponding ISO 10303 entity: vertex_point. Please refer to ISO/IS 10303-42:1994, p. 130 for the final definition of the formal standard. Due to the general IFC model specification rule not to use multiple inheritance, the subtype relationship to geometric_representation_item is not included.
/// 
/// HISTORY  New Entity in IFC2x.
/// 
/// Informal proposition: 
/// 
/// The domain of the vertex is formally defined to be the domain of its vertex point.
class IFC_PARSE_API IfcVertexPoint : public IfcVertex {
public:
    /// The geometric point, which defines the position in geometric space of the vertex.
    IfcPoint* VertexGeometry() const;
    void setVertexGeometry(IfcPoint* v);
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcVertex::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcPoint; } return IfcVertex::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "VertexGeometry"; } return IfcVertex::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcVertexPoint (IfcEntityInstanceData* e);
    IfcVertexPoint (IfcPoint* v1_VertexGeometry);
    typedef IfcTemplatedEntityList< IfcVertexPoint > list;
};
/// IfcVirtualGridIntersection defines the derived location of the intersection between two grid axes. Offset values may be given to set an offset distance to the grid axis for the calculation of the virtual grid intersection.
/// 
/// The two intersecting axes (IntersectingAxes) define the intersection point, which exact location (in terms of the Cartesian point representing the intersection) has to be calculated from the geometric representation of the two participating curves.
/// 
/// NOTE The IfcGrid local placement, that can be provided relative to the local placement of another spatial structure element, has to be taken into account for calculating the absolute placement of the IfcVirtualGridIntersection. Where rules and informal rules ensure, that the IntersectingAxes belong to the same IfcGrid
/// 
/// Offset values may be given (OffsetDistances). If given, the position within the list of OffsetDistances
/// corresponds with the position within the list of IntersectingAxes. Therefore:
/// 
/// OffsetDistances[1] sets the offset to IntersectingAxes[1],
/// OffsetDistances[2] sets the offset to IntersectingAxes[2], and
/// OffsetDistances[3] sets the offset to the virtual intersection in direction of the orientation of the cross product
/// of IntersectingAxes[1] and the orthogonal complement of the IntersectingAxes[1] (which is the positive or negative
/// direction of the z axis of the design grid position).
/// 
/// HISTORY  New entity in IFC Release 1.5. The entity name was changed from IfcConstraintRelIntersection in IFC Release 2x.
/// 
/// Informal Propositions:
/// 
/// Both, IntersectingAxes[1] and
/// IntersectingAxes[2] shall be two IfcGridAxis
/// defined by the same IfcGrid.
/// IntersectingAxes[1] and IntersectingAxes[2]
/// shall not be part of the same row of grid axes, i.e. both shall
/// not be within the same set of IfcGrid.UAxes or
/// IfcGrid.VAxes of the corresponding IfcGrid.
/// 
/// Geometry use definitions:
/// The following figures explain the usage of the OffsetDistances and IntersectingAxes attributes.
/// 
/// Figure 246 illustrates two offset distances given where the virtual intersection is defined in the xy plane of the grid axis placement.
/// 
/// Figure 246 — Virtual grid intersection with two offsets
/// 
/// Figure 247 illustrates three offset distances given where the virtual intersection is defined by an offset (in direction of the
/// z-axis of the design grid placement) to the virtual intersection in the xy plane of the grid axis placement.
/// 
/// Figure 247 — Virtual grid intersection with three offsets
/// 
/// The distance of the offset curve (OffsetDistances[n])
/// is measured from the basis curve. The distance may be positive,
/// negative or zero. A positive value of distance defines an offset
/// in the direction which is normal to the curve in the sense of an
/// anti-clockwise rotation through 90 degrees from the tangent
/// vector T at the given point. (This is in the direction of
/// orthogonal complement(T).) This can be reverted by the
/// SameSense attribute at IfcGridAxis which may switch
/// the sense of the AxisCurve.
/// Illustration
/// 
/// Figure 248 illustrates an example of a negative offset where the figure shows the side of the offset.
/// 
/// IntersectingAxes[1].AxisCurve is an
/// IfcTrimmedCurve with an IfcCircle as
/// BasisCurve and SenseAgreement = TRUE.
/// IntersectingAxes[1].SameSense = TRUE.
/// OffsetDistances[1] is a negative length measure
/// 
/// Figure 248 — Virtual grid intersection negative offset
class IFC_PARSE_API IfcVirtualGridIntersection : public IfcUtil::IfcBaseEntity {
public:
    /// Two grid axes which intersects at exactly one intersection (see also informal proposition at IfcGrid). If attribute OffsetDistances is omitted, the intersection defines the placement or ref direction of a grid placement directly. If OffsetDistances are given, the intersection is defined by the offset curves to the grid axes.
    IfcTemplatedEntityList< IfcGridAxis >::ptr IntersectingAxes() const;
    void setIntersectingAxes(IfcTemplatedEntityList< IfcGridAxis >::ptr v);
    /// Offset distances to the grid axes. If given, it defines virtual offset curves to the grid axes. The intersection of the offset curves specify the virtual grid intersection.
    std::vector< double > /*[2:3]*/ OffsetDistances() const;
    void setOffsetDistances(std::vector< double > /*[2:3]*/ v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_AGGREGATE_OF_DOUBLE; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcGridAxis; case 1: return Type::IfcLengthMeasure; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "IntersectingAxes"; case 1: return "OffsetDistances"; } (void)i; throw IfcParse::IfcAttributeOutOfRangeException("Argument index out of range"); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcVirtualGridIntersection (IfcEntityInstanceData* e);
    IfcVirtualGridIntersection (IfcTemplatedEntityList< IfcGridAxis >::ptr v1_IntersectingAxes, std::vector< double > /*[2:3]*/ v2_OffsetDistances);
    typedef IfcTemplatedEntityList< IfcVirtualGridIntersection > list;
};
/// IfcWorkTime defines time periods that are used by IfcWorkCalendar for either describing working times or non-working exception times. Besides start and finish dates, a set of time periods can be given by various types of recurrence patterns.
/// 
/// HISTORY: New entity in IFC2x4.
/// 
/// Use definitions
/// A work time should have a meaningful name that describes the time periods (for example, working week, holiday name). Non-recurring time periods should have a start date (IfcWorkTime.Start) and a finish date (IfcWorkTime.Finish). In that case it is assumed that the time period begins at 0:00 on the start date and ends at 24:00 on the finish date.
/// 
/// The start and finish date is optional if a recurrence pattern is given (IfcWorkTime.RecurrencePattern).  They then restrict never-ending recurrence patterns.
class IFC_PARSE_API IfcWorkTime : public IfcSchedulingTime {
public:
    /// Whether the optional attribute RecurrencePattern is defined for this IfcWorkTime
    bool hasRecurrencePattern() const;
    /// Recurrence pattern that defines a time period, which, if given, is
    ///   valid within the time period defined by
    ///   IfcWorkTime.Start and IfcWorkTime.Finish.
    IfcRecurrencePattern* RecurrencePattern() const;
    void setRecurrencePattern(IfcRecurrencePattern* v);
    /// Whether the optional attribute Start is defined for this IfcWorkTime
    bool hasStart() const;
    /// Start date of the work time (0:00), that might be further
    ///   restricted by a recurrence pattern.
    std::string Start() const;
    void setStart(std::string v);
    /// Whether the optional attribute Finish is defined for this IfcWorkTime
    bool hasFinish() const;
    /// End date of the work time (24:00), that might be further
    ///   restricted by a recurrence pattern.
    std::string Finish() const;
    void setFinish(std::string v);
    virtual unsigned int getArgumentCount() const { return 6; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 3: return IfcUtil::Argument_ENTITY_INSTANCE; case 4: return IfcUtil::Argument_STRING; case 5: return IfcUtil::Argument_STRING; } return IfcSchedulingTime::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 3: return Type::IfcRecurrencePattern; case 4: return Type::IfcDate; case 5: return Type::IfcDate; } return IfcSchedulingTime::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 3: return "RecurrencePattern"; case 4: return "Start"; case 5: return "Finish"; } return IfcSchedulingTime::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcWorkTime (IfcEntityInstanceData* e);
    IfcWorkTime (boost::optional< std::string > v1_Name, boost::optional< IfcDataOriginEnum::IfcDataOriginEnum > v2_DataOrigin, boost::optional< std::string > v3_UserDefinedDataOrigin, IfcRecurrencePattern* v4_RecurrencePattern, boost::optional< std::string > v5_Start, boost::optional< std::string > v6_Finish);
    typedef IfcTemplatedEntityList< IfcWorkTime > list;
};
/// An IfcApprovalRelationship associates approvals (one
/// relating approval and one or more related approvals), each having different status or level as the approval process or the approved
/// objects evolve.
/// 
/// HISTORY: New entity in Release IFC2x2.
/// 
/// IFC2x4 CHANGE  Subtyped from IfcResourceLevelRelationship, order of attributes changed.
class IFC_PARSE_API IfcApprovalRelationship : public IfcResourceLevelRelationship {
public:
    /// The approval that other approval is related to.
    IfcApproval* RelatingApproval() const;
    void setRelatingApproval(IfcApproval* v);
    /// The approvals that are related to another (relating) approval.IFC2x Edition 4 CHANGE The cardinality of this attribute has been changed to SET.
    IfcTemplatedEntityList< IfcApproval >::ptr RelatedApprovals() const;
    void setRelatedApprovals(IfcTemplatedEntityList< IfcApproval >::ptr v);
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 2: return IfcUtil::Argument_ENTITY_INSTANCE; case 3: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } return IfcResourceLevelRelationship::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 2: return Type::IfcApproval; case 3: return Type::IfcApproval; } return IfcResourceLevelRelationship::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 2: return "RelatingApproval"; case 3: return "RelatedApprovals"; } return IfcResourceLevelRelationship::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcApprovalRelationship (IfcEntityInstanceData* e);
    IfcApprovalRelationship (boost::optional< std::string > v1_Name, boost::optional< std::string > v2_Description, IfcApproval* v3_RelatingApproval, IfcTemplatedEntityList< IfcApproval >::ptr v4_RelatedApprovals);
    typedef IfcTemplatedEntityList< IfcApprovalRelationship > list;
};
/// The closed profile IfcArbitraryClosedProfileDef defines an arbitrary two-dimensional profile for the use within the swept surface geometry, the swept area solid or a sectioned spine. It is given by an outer boundary from which the surface or solid can be constructed. 
/// 
/// HISTORY: New entity in IFC 1.5. Entity has been renamed from IfcArbitraryProfileDef in IFC Release 2x.
/// 
/// Informal proposition: 
/// 
/// The OuterCurve has to be a closed curve.
///   The OuterCurve shall not intersect.
/// 
/// Figure 307 illustrates the arbitrary closed profile definition. The OuterCurve is defined in the underlying coordinate system. The underlying coordinate system is defined by the swept surface or swept area solid that uses the profile definition. It is the xy plane of either:
/// 
/// IfcSweptSurface.Position
///   IfcSweptAreaSolid.Position
/// 
/// or in case of sectioned spines the xy plane of each list member of IfcSectionedSpine.CrossSectionPositions. The OuterCurve
/// attribute defines a two dimensional closed bounded curve.
/// 
/// Figure 307 — Arbitrary closed profile
class IFC_PARSE_API IfcArbitraryClosedProfileDef : public IfcProfileDef {
public:
    /// Bounded curve, defining the outer boundaries of the arbitrary profile.
    IfcCurve* OuterCurve() const;
    void setOuterCurve(IfcCurve* v);
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 2: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcProfileDef::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 2: return Type::IfcCurve; } return IfcProfileDef::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 2: return "OuterCurve"; } return IfcProfileDef::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcArbitraryClosedProfileDef (IfcEntityInstanceData* e);
    IfcArbitraryClosedProfileDef (IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< std::string > v2_ProfileName, IfcCurve* v3_OuterCurve);
    typedef IfcTemplatedEntityList< IfcArbitraryClosedProfileDef > list;
};
/// The open profile IfcArbitraryOpenProfileDef defines an arbitrary two-dimensional open profile for the use within the swept surface geometry. It is given by an open boundary from with the surface can be constructed. 
/// 
/// HISTORY  New entity in IFC2x.
/// 
/// Informal proposition:
/// 
/// The Curve has to be an open curve.
/// 
/// Figure 308 illustrates the arbitrary open profile definition. The Curve is defined in the underlying coordinate system. The underlying coordinate system is defined by the swept surface that uses the profile definition. It is the xy plane of: 
/// 
/// IfcSweptSurface.Position
/// 
/// The Curve attribute defines a two dimensional open bounded curve.
/// 
/// Figure 308 — Arbitrary open profile
class IFC_PARSE_API IfcArbitraryOpenProfileDef : public IfcProfileDef {
public:
    /// Open bounded curve defining the profile.
    IfcBoundedCurve* Curve() const;
    void setCurve(IfcBoundedCurve* v);
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 2: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcProfileDef::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 2: return Type::IfcBoundedCurve; } return IfcProfileDef::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 2: return "Curve"; } return IfcProfileDef::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcArbitraryOpenProfileDef (IfcEntityInstanceData* e);
    IfcArbitraryOpenProfileDef (IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< std::string > v2_ProfileName, IfcBoundedCurve* v3_Curve);
    typedef IfcTemplatedEntityList< IfcArbitraryOpenProfileDef > list;
};
/// The IfcArbitraryProfileDefWithVoids defines an arbitrary closed two-dimensional profile with holes defined for the use for the swept area solid or a sectioned spine. It is given by an outer boundary and inner boundaries from with the solid the can be constructed.
/// 
/// HISTORY  New entity in IFC2x.
/// 
/// Informal propositions:
/// 
/// The outer curve and all inner curves shall be closed curves.
///   The outer curve shall enclose all inner curves.
///   No inner curve shall intersect with the outer curve or any other inner curve.
///   No inner curve may enclose another inner curve.
/// 
/// Figure 309 illustrates the arbitrary closed profile definition with voids. The OuterCurve, defined at the supertype IfcArbitraryClosedProfileDef
/// and the inner curves are defined in the same underlying coordinate system. The common underlying coordinate system is defined by the swept area solid that uses the profile definition. It is the xy plane of:
/// 
/// IfcSweptAreaSolid.Position
/// 
/// or in case of sectioned spines the xy plane of each list member of IfcSectionedSpine.CrossSectionPositions.  The OuterCurve attribute defines a two dimensional closed bounded curve, the InnerCurves define a set of two dimensional closed bounded curves.
/// 
/// Figure 309 — Arbitrary profile with voids
class IFC_PARSE_API IfcArbitraryProfileDefWithVoids : public IfcArbitraryClosedProfileDef {
public:
    /// Set of bounded curves, defining the inner boundaries of the arbitrary profile.
    IfcTemplatedEntityList< IfcCurve >::ptr InnerCurves() const;
    void setInnerCurves(IfcTemplatedEntityList< IfcCurve >::ptr v);
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 3: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } return IfcArbitraryClosedProfileDef::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 3: return Type::IfcCurve; } return IfcArbitraryClosedProfileDef::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 3: return "InnerCurves"; } return IfcArbitraryClosedProfileDef::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcArbitraryProfileDefWithVoids (IfcEntityInstanceData* e);
    IfcArbitraryProfileDefWithVoids (IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< std::string > v2_ProfileName, IfcCurve* v3_OuterCurve, IfcTemplatedEntityList< IfcCurve >::ptr v4_InnerCurves);
    typedef IfcTemplatedEntityList< IfcArbitraryProfileDefWithVoids > list;
};
/// An IfcBlobTexture provides a 2-dimensional distribution of the lighting parameters of a surface onto which it is mapped. The texture itself is given as a single binary blob, representing the content of a pixel format file. The file format of the pixel file is given by the RasterFormat attribute and allowable formats are guided by where rule SupportedRasterFormat.
/// 
/// NOTE  Toolbox specific implementations of the binary datatype may restrict the maximum length of the binary blob to capture the raster file content.
/// 
/// For interpretation of the texture nodes see IfcImageTexture definition.
/// 
/// HISTORY  New class in IFC2x3.
/// 
/// IFC2x4 CHANGE  Data type of RasterCode has been corrected to BINARY.
class IFC_PARSE_API IfcBlobTexture : public IfcSurfaceTexture {
public:
    /// The format of the RasterCode often using a compression.
    std::string RasterFormat() const;
    void setRasterFormat(std::string v);
    /// Blob, given as a single binary, to capture the texture within one popular file (compression) format. The file format is provided by the RasterFormat attribute.
    boost::dynamic_bitset<> RasterCode() const;
    void setRasterCode(boost::dynamic_bitset<> v);
    virtual unsigned int getArgumentCount() const { return 7; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 5: return IfcUtil::Argument_STRING; case 6: return IfcUtil::Argument_BINARY; } return IfcSurfaceTexture::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 5: return Type::IfcIdentifier; case 6: return Type::IfcBinary; } return IfcSurfaceTexture::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 5: return "RasterFormat"; case 6: return "RasterCode"; } return IfcSurfaceTexture::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcBlobTexture (IfcEntityInstanceData* e);
    IfcBlobTexture (bool v1_RepeatS, bool v2_RepeatT, boost::optional< std::string > v3_Mode, IfcCartesianTransformationOperator2D* v4_TextureTransform, boost::optional< std::vector< std::string > /*[1:?]*/ > v5_Parameter, std::string v6_RasterFormat, boost::dynamic_bitset<> v7_RasterCode);
    typedef IfcTemplatedEntityList< IfcBlobTexture > list;
};
/// The profile IfcCenterLineProfileDef defines an arbitrary two-dimensional open, not self intersecting profile for the use within the swept solid geometry. It is given by an area defined by applying a constant thickness to a centerline, generating an area from which the solid can be constructed.
/// 
/// Among else, IfcCenterLineProfileDef is used to model cold-formed
/// steel or aluminium sections (Sigma, Zeta, Omega, and similar sections
/// which are not covered by subtypes of IfcParameterizedProfileDef).
/// However, since IfcCenterLineProfileDef does not provide shape parameters
/// except for the thickness, there is generally a need to further specify the
/// profile definition by means of
/// 
/// the name,
///   external reference to a document or library,
///   profile properties,
/// 
/// or a combination of them.  See IfcProfileDef for guidance on external references for profiles.
/// 
/// HISTORY  New entity in IFC2x3.
/// 
/// Informal proposition: 
/// 
/// The Curve has to be an open curve.
///   The Curve has to be a non-intersecting curve.
/// 
/// Figure 311 illustrates the center line profile definition. The Curve is defined in the underlying coordinate system. The underlying coordinate system is defined by the swept surface that uses the profile  definition. It is the xy plane of: 
/// 
/// IfcSweptSurface.Position
/// 
/// The Curve attribute defines a two dimensional open bounded curve. The Thickness attribute defines a constant thickness along the curve.
/// 
/// Figure 311 — Centerline profile
class IFC_PARSE_API IfcCenterLineProfileDef : public IfcArbitraryOpenProfileDef {
public:
    /// Constant thickness applied along the center line.
    double Thickness() const;
    void setThickness(double v);
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 3: return IfcUtil::Argument_DOUBLE; } return IfcArbitraryOpenProfileDef::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 3: return Type::IfcPositiveLengthMeasure; } return IfcArbitraryOpenProfileDef::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 3: return "Thickness"; } return IfcArbitraryOpenProfileDef::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCenterLineProfileDef (IfcEntityInstanceData* e);
    IfcCenterLineProfileDef (IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< std::string > v2_ProfileName, IfcBoundedCurve* v3_Curve, double v4_Thickness);
    typedef IfcTemplatedEntityList< IfcCenterLineProfileDef > list;
};
/// An IfcClassification is used for the arrangement of objects into a class or category according to a common purpose or their possession of common
/// characteristics. A classification in the sense of IfcClassification is taxonomy, or taxonomic scheme, arranged in a hierarchical structure. A category of objects relates to other categories in a generalization-specialization relationship. Therefore the classification items in an
/// classification are organized in a tree structure.
/// 
/// HISTORY New class in IFC Release 1.5. Modified in IFC 2x.
/// 
/// IFC 2x4 CHANGE Attribute Edition made optional. Attributes: PublicationLocation, Description and ReferenceTokens added. Inverse attribute HasClassificationReferences added.
/// 
/// Classification use definitions
/// IfcClassification identifies the classification system or source from which a classification notation is derived. Each classification reference or classification item, belonging to a single classification system, shall reference a single instance of IfcClassification. Therefore, each particular classification system or source used should have only one IfcClassification instance. However, because multiple classification is allowed, there may be many IfcClassification objects used, each identifying a different classification system or source.
/// 
/// A classification system declared may be either formally published (such as Omniclass, Uniclass, Masterformat, or DIN) or it may be a locally defined method of classifiying information.  There are two methods to define a classification system within an IFC dataset:
/// 
/// Including the classification system structure within the dataset: Here a hierarchical tree of IfcClassificationItem's is included that defines the classification system including the relationship between the classification items. An IfcClassificationNotation is used to classify an object.
/// Referencing the classification system by a classification key or id: Here the IfcClassificationReference is used to assign a classification id or key to each classified object.
class IFC_PARSE_API IfcClassification : public IfcExternalInformation {
public:
    /// Whether the optional attribute Source is defined for this IfcClassification
    bool hasSource() const;
    /// Source (or publisher) for this classification.
    /// 
    /// NOTE that the source of the classification means the person or organization that was the original author or the person or organization currently acting as the publisher.
    std::string Source() const;
    void setSource(std::string v);
    /// Whether the optional attribute Edition is defined for this IfcClassification
    bool hasEdition() const;
    /// The edition or version of the classification system from which the classification notation is derived.
    /// 
    /// NOTE the version labeling system is specific to the classification system. 
    /// 
    /// IFC2x4 CHANGE The attribute has been changed to be optional.
    std::string Edition() const;
    void setEdition(std::string v);
    /// Whether the optional attribute EditionDate is defined for this IfcClassification
    bool hasEditionDate() const;
    /// The date on which the edition of the classification used became valid.
    /// 
    /// NOTE The indication of edition may be sufficient to identify the classification source uniquely but the edition date is provided as an optional attribute to enable more precise identification where required.
    /// 
    /// IFC2x4 CHANGE The data type has been changed to IfcDate, the date string according to ISO8601.
    std::string EditionDate() const;
    void setEditionDate(std::string v);
    /// The name or label by which the classification used is normally known.
    /// 
    /// NOTE Examples of names include CI/SfB, Masterformat, BSAB, Uniclass, STABU, DIN276, DIN277 etc.
    std::string Name() const;
    void setName(std::string v);
    /// Whether the optional attribute Description is defined for this IfcClassification
    bool hasDescription() const;
    /// Additional description provided for the classification.
    /// 
    /// IFC2x4 CHANGE  New attribute added at the end of the attribute list.
    std::string Description() const;
    void setDescription(std::string v);
    /// Whether the optional attribute Location is defined for this IfcClassification
    bool hasLocation() const;
    /// Resource identifier or locator, provided as URI, URN or URL, of the classification.  
    /// 
    /// IFC2x4 CHANGE  New attribute added at the end of the attribute list.
    std::string Location() const;
    void setLocation(std::string v);
    /// Whether the optional attribute ReferenceTokens is defined for this IfcClassification
    bool hasReferenceTokens() const;
    /// The delimiter tokens that are used to mark the boundaries of individual facets (substrings) in a classification reference.
    /// 
    /// This typically applies then the IfcClassification is used in
    /// conjuction with IfcClassificationReference's. If only one ReferenceToken is provided, it applies to all boundaries of individual facets, if more than one ReferenceToken are provided, the first token applies to the first boundary, the second token to the second boundary, and the nth token to the nth and any additional boundary. 
    /// 
    /// NOTE  Tokens are typically recommended within the classification itself and each token will have a particular role.
    /// 
    /// EXAMPLE 1  To indicate that the facet delimiter used for DIN277-2 reference key "2.1" ("Office rooms") is ".", a single ReferenceToken ['.'] is provided. To indicate that the facet delimiter used for Omniclass Table 13 (space by function) reference key "13-15 11 34 11" ("Office") are "-" and " ", two ReferenceToken's ['-', ' '] are provided. 
    /// 
    /// EXAMPLE 2  The use of ReferenceTokens can also be extended to include masks. The use need to be agreed in view definitions or implementer agreements that stipulates a "mask syntax" that should be used.  
    /// 
    /// IFC2x4 CHANGE  New attribute added at the end of the attribute list.
    std::vector< std::string > /*[1:?]*/ ReferenceTokens() const;
    void setReferenceTokens(std::vector< std::string > /*[1:?]*/ v);
    virtual unsigned int getArgumentCount() const { return 7; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_STRING; case 1: return IfcUtil::Argument_STRING; case 2: return IfcUtil::Argument_STRING; case 3: return IfcUtil::Argument_STRING; case 4: return IfcUtil::Argument_STRING; case 5: return IfcUtil::Argument_STRING; case 6: return IfcUtil::Argument_AGGREGATE_OF_STRING; } return IfcExternalInformation::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcLabel; case 1: return Type::IfcLabel; case 2: return Type::IfcDate; case 3: return Type::IfcLabel; case 4: return Type::IfcText; case 5: return Type::IfcURIReference; case 6: return Type::IfcIdentifier; } return IfcExternalInformation::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Source"; case 1: return "Edition"; case 2: return "EditionDate"; case 3: return "Name"; case 4: return "Description"; case 5: return "Location"; case 6: return "ReferenceTokens"; } return IfcExternalInformation::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcRelAssociatesClassification >::ptr ClassificationForObjects() const; // INVERSE IfcRelAssociatesClassification::RelatingClassification
    IfcTemplatedEntityList< IfcClassificationReference >::ptr HasReferences() const; // INVERSE IfcClassificationReference::ReferencedSource
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcClassification (IfcEntityInstanceData* e);
    IfcClassification (boost::optional< std::string > v1_Source, boost::optional< std::string > v2_Edition, boost::optional< std::string > v3_EditionDate, std::string v4_Name, boost::optional< std::string > v5_Description, boost::optional< std::string > v6_Location, boost::optional< std::vector< std::string > /*[1:?]*/ > v7_ReferenceTokens);
    typedef IfcTemplatedEntityList< IfcClassification > list;
};
/// An IfcClassificationReference is a reference into a classification system or source (see IfcClassification) for a specific classification key (or notation).
/// 
/// The inherited attributes have the following meaning:
/// 
/// Identification: holds the key provided for a specific references to classification items (or tables).
/// Name: allows for a human interpretable designation of a classification notation.
/// Location: optionally holds a direct URI link into the classification system (or source) to hyperlink the classification key.
/// 
/// The IfcClassificationReference can either be assigned directly to the IfcClassification, such as if no classification hierarchy has to be included, or it references the parent classification notation, if the fully classification hierarchy is included in the data set. The attribute ReferencedSource then holds the following information (choice by IfcClassificationReferenceSelect):
/// 
/// being of type IfcClassification: direct reference to the classification system (with meta information provided), used for highest level of classification notations, or if the classification notation hierarchy is not relevant,
/// being of type IfcClassificationReference: reference to the parent classification notation within the classification hierarchy.
/// 
/// HISTORY New entity in IFC 2x.
/// 
/// IFC2x4 CHANGE The attribute Description and inverse attribute HasReferences are added.  The attribute Identification has been renamed from ItemReference.
/// 
/// Use definitions
/// The IfcClassificationReference can be used to only assign classification keys to objects, or to hold a fully classification hierarchy. The first is refered to as "lightweight classification", and the second as "full classification"
/// 
/// The IfcClassificationReference can be used as a form of 'lightweight' classification through the 'Identification' attribute inherited from the abstract IfcExternalReference class. In this case, the 'Identification' could take (for instance) the Uniclass notation "L6814" which, if the classification was well understood by all parties and was known to be taken from a particular classification source, would be sufficient. The Name attribute could be the title "Tanking". This would remove the need for the overhead of the more complete classification structure of the model.
class IFC_PARSE_API IfcClassificationReference : public IfcExternalReference {
public:
    /// Whether the optional attribute ReferencedSource is defined for this IfcClassificationReference
    bool hasReferencedSource() const;
    /// The classification system or source that is referenced.
    IfcClassificationReferenceSelect* ReferencedSource() const;
    void setReferencedSource(IfcClassificationReferenceSelect* v);
    /// Whether the optional attribute Description is defined for this IfcClassificationReference
    bool hasDescription() const;
    /// Description of the classification reference for informational purposes.
    /// 
    /// IFC2x4 CHANGE  New attribute added at the end of the attribute list.
    std::string Description() const;
    void setDescription(std::string v);
    /// Whether the optional attribute Sort is defined for this IfcClassificationReference
    bool hasSort() const;
    std::string Sort() const;
    void setSort(std::string v);
    virtual unsigned int getArgumentCount() const { return 6; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 3: return IfcUtil::Argument_ENTITY_INSTANCE; case 4: return IfcUtil::Argument_STRING; case 5: return IfcUtil::Argument_STRING; } return IfcExternalReference::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 3: return Type::IfcClassificationReferenceSelect; case 4: return Type::IfcText; case 5: return Type::IfcIdentifier; } return IfcExternalReference::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 3: return "ReferencedSource"; case 4: return "Description"; case 5: return "Sort"; } return IfcExternalReference::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcRelAssociatesClassification >::ptr ClassificationRefForObjects() const; // INVERSE IfcRelAssociatesClassification::RelatingClassification
    IfcTemplatedEntityList< IfcClassificationReference >::ptr HasReferences() const; // INVERSE IfcClassificationReference::ReferencedSource
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcClassificationReference (IfcEntityInstanceData* e);
    IfcClassificationReference (boost::optional< std::string > v1_Location, boost::optional< std::string > v2_Identification, boost::optional< std::string > v3_Name, IfcClassificationReferenceSelect* v4_ReferencedSource, boost::optional< std::string > v5_Description, boost::optional< std::string > v6_Sort);
    typedef IfcTemplatedEntityList< IfcClassificationReference > list;
};

class IFC_PARSE_API IfcColourRgbList : public IfcPresentationItem {
public:
    std::vector< std::vector< double > > ColourList() const;
    void setColourList(std::vector< std::vector< double > > v);
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_AGGREGATE_OF_AGGREGATE_OF_DOUBLE; } return IfcPresentationItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcNormalisedRatioMeasure; } return IfcPresentationItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "ColourList"; } return IfcPresentationItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcColourRgbList (IfcEntityInstanceData* e);
    IfcColourRgbList (std::vector< std::vector< double > > v1_ColourList);
    typedef IfcTemplatedEntityList< IfcColourRgbList > list;
};
/// Definition from ISO/CD 10303-46:1992: The colour specification entity contains a direct colour definition. Colour component values refer directly to a specific colour space.
/// 
/// NOTE  Corresponding ISO 10303 name: colour_specification. It has been made into an abstract entity in IFC. Please refer to ISO/IS 10303-46:1994, p. 138 for the final definition of the formal standard.
/// 
/// HISTORY  New entity in IFC2x2.
class IFC_PARSE_API IfcColourSpecification : public IfcPresentationItem {
public:
    /// Whether the optional attribute Name is defined for this IfcColourSpecification
    bool hasName() const;
    /// Optional name given to a particular colour specification in addition to the colour components (like the RGB values).
    /// 
    /// NOTE  Examples are the names of a industry colour classification, such as RAL.
    /// IFC2x Edition 3 CHANGE  Attribute added.
    std::string Name() const;
    void setName(std::string v);
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_STRING; } return IfcPresentationItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcLabel; } return IfcPresentationItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Name"; } return IfcPresentationItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcColourSpecification (IfcEntityInstanceData* e);
    IfcColourSpecification (boost::optional< std::string > v1_Name);
    typedef IfcTemplatedEntityList< IfcColourSpecification > list;
};
/// The IfcCompositeProfileDef
/// defines the profile by composition of other profiles. The composition
/// is given by a set of at least two other profile definitions. Any
/// profile definition (except for another composite profile) can be used
/// to construct the composite. 
/// 
/// HISTORY  New entity in IFC2x.
/// 
/// Figure 314 illustrates the composite profile definition. The IfcCompositeProfileDef does not define an own position coordinate system, it is directly defined in the underlying coordinate system. The underlying coordinate system is defined by the swept surface or swept area solid that uses the profile definition. It is the xy plane of either:
/// 
/// IfcSweptSurface.Position
///   IfcSweptAreaSolid.Position
/// 
/// Or in case of sectioned spines it is the xy plane of each list member of IfcSectionedSpine.CrossSectionPositions. The IfcCompositeProfileDef is defined using other profile definitions. Those other profile definitions are directly inserted into the underlying coordinate system.
/// 
/// In case of parameterized profile definitions, the Position attribute of those standard profiles is used to place the profiles relatively to each other.
///   In case of arbitrary profile definitions, each Cartesian coordinate is given directly within the underlying coordinate system.
/// 
/// NOTE  The black coordinate axes show the underlying coordinate system of the swept surface or swept area solid.
/// 
/// Figure 314
/// 
/// Twin profiles special case
/// 
/// If twin profiles are modeled by profile composition, the base profile should
/// only be specified once. It is then included into the composite profile directly
/// and additionally indirectly via IfcMirroredProfileDef. For example, a
/// double angle made of two L100x10 with 10mm air gap between them, i.e. a
/// _| |_ shape, can be modeled as
/// 
/// single_L : IfcLShapeProfileDef := IfcLShapeProfileDef(AREA, 'L100X100X10',
///     IfcAxis2Placement2D(IfcCartesianPoint(((.100+.010)/2., .0)), ?),
///     .100, .100, .010, .012, ?, 0., ?, ?);
///  
/// double_L : IfcCompositeProfileDef := IfcCompositeProfileDef(AREA, 'double angle',
///     (single_L, IfcMirroredProfileDef(AREA, ?, single_L, ?)), 'twin profile');
class IFC_PARSE_API IfcCompositeProfileDef : public IfcProfileDef {
public:
    /// The profiles which are used to define the composite profile.
    IfcTemplatedEntityList< IfcProfileDef >::ptr Profiles() const;
    void setProfiles(IfcTemplatedEntityList< IfcProfileDef >::ptr v);
    /// Whether the optional attribute Label is defined for this IfcCompositeProfileDef
    bool hasLabel() const;
    /// The name by which the composition may be referred to. The actual meaning of the name has to be defined in the context of applications.
    std::string Label() const;
    void setLabel(std::string v);
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 2: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 3: return IfcUtil::Argument_STRING; } return IfcProfileDef::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 2: return Type::IfcProfileDef; case 3: return Type::IfcLabel; } return IfcProfileDef::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 2: return "Profiles"; case 3: return "Label"; } return IfcProfileDef::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCompositeProfileDef (IfcEntityInstanceData* e);
    IfcCompositeProfileDef (IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< std::string > v2_ProfileName, IfcTemplatedEntityList< IfcProfileDef >::ptr v3_Profiles, boost::optional< std::string > v4_Label);
    typedef IfcTemplatedEntityList< IfcCompositeProfileDef > list;
};
/// Definition from ISO/CD 10303-42:1992: A connected_face_set is a set of faces such that the domain of faces together with their bounding edges and vertices is connected.  
/// 
/// NOTE  Corresponding ISO 10303 entity: connected_face_set, the subtype closed_shell is included as IfcClosedShell and the subtype open_shell is included as IfcOpenShell. Please refer to ISO/IS 10303-42:1994, p. 144 for the final definition of the formal standard.
/// 
/// HISTORY  New class in IFC Release 1.0
/// 
/// Informal proposition: 
/// 
/// The union of the domains of the faces and their bounding loops shall be arcwise connected.
class IFC_PARSE_API IfcConnectedFaceSet : public IfcTopologicalRepresentationItem {
public:
    /// The set of faces arcwise connected along common edges or vertices.
    IfcTemplatedEntityList< IfcFace >::ptr CfsFaces() const;
    void setCfsFaces(IfcTemplatedEntityList< IfcFace >::ptr v);
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } return IfcTopologicalRepresentationItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcFace; } return IfcTopologicalRepresentationItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "CfsFaces"; } return IfcTopologicalRepresentationItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcConnectedFaceSet (IfcEntityInstanceData* e);
    IfcConnectedFaceSet (IfcTemplatedEntityList< IfcFace >::ptr v1_CfsFaces);
    typedef IfcTemplatedEntityList< IfcConnectedFaceSet > list;
};
/// IfcConnectionCurveGeometry is used to describe the geometric constraints that facilitate the physical connection of two objects at a curve or at an edge with curve geometry associated. It is envisioned as a control that applies to the element connection relationships. 
/// 
/// EXAMPLE  The connection relationship between two walls has a geometric constraint which describes the end caps (or cut-off of the wall ends) by a CurveOnRelatingElement for the first wall and a CurveOnRelatedElement for the second wall. The exact usage of the IfcConnectionCurveGeometry is further defined in the geometry use sections of the elements that use it.
/// 
/// The available geometry for the connection constraint may be further restricted to only allow straight segments by applying IfcPolyline
/// only. Such an usage constraint is provided at the object definition of the IfcElement subtype, utilizing the element connection by referring to the subtype of IfcRelConnects with the associated IfcConnectionCurveGeometry.
/// 
/// HISTORY  New entity in IFC Release 1.5, has been renamed from IfcLineConnectionGeometry in IFC Release 2x.
/// 
/// IFC2x Edition 3 CHANGE  The provision of topology with associated geometry, IfcEdgeCurve, is enabled by using the IfcCurveOrEdgeCurve.
/// 
/// Geometry use definitions
/// The IfcCurve (or the IfcEdgeCurve with an associated IfcCurve) at the CurveOnRelatingElement attribute defines the curve where the basic geometry items of the connected elements connects. The curve geometry and coordinates are provided within the local coordinate system of the RelatingElement, as specified at the IfcRelConnects Subtype that utilizes the IfcConnectionCurveGeometry. Optionally, the same curve geometry and coordinates can also be provided within the local coordinate system of the RelatedElement by using the CurveOnRelatedElement attribute.
class IFC_PARSE_API IfcConnectionCurveGeometry : public IfcConnectionGeometry {
public:
    /// The bounded curve at which the connected objects are aligned at the relating element, given in the LCS of the relating element.
    IfcCurveOrEdgeCurve* CurveOnRelatingElement() const;
    void setCurveOnRelatingElement(IfcCurveOrEdgeCurve* v);
    /// Whether the optional attribute CurveOnRelatedElement is defined for this IfcConnectionCurveGeometry
    bool hasCurveOnRelatedElement() const;
    /// The bounded curve at which the connected objects are aligned at the related element, given in the LCS of the related element. If the information is omitted, then the origin of the related element is used.
    IfcCurveOrEdgeCurve* CurveOnRelatedElement() const;
    void setCurveOnRelatedElement(IfcCurveOrEdgeCurve* v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcConnectionGeometry::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcCurveOrEdgeCurve; case 1: return Type::IfcCurveOrEdgeCurve; } return IfcConnectionGeometry::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "CurveOnRelatingElement"; case 1: return "CurveOnRelatedElement"; } return IfcConnectionGeometry::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcConnectionCurveGeometry (IfcEntityInstanceData* e);
    IfcConnectionCurveGeometry (IfcCurveOrEdgeCurve* v1_CurveOnRelatingElement, IfcCurveOrEdgeCurve* v2_CurveOnRelatedElement);
    typedef IfcTemplatedEntityList< IfcConnectionCurveGeometry > list;
};
/// IfcConnectionPointEccentricity is used to describe the geometric constraints that facilitate the physical connection of two objects at a point or vertex point with associated point coordinates. There is a physical distance, or eccentricity, etween the connection points of both object. The eccentricity can be either given by:
/// 
/// providing the PointOnRelatingElement and the PointOnRelatedElement, where bothÿpoint coordinates are not identical within a common parent coordinate system (latestly within the world coordinate system),
/// providing the PointOnRelatingElement and the three distance measures, EccentricityInX, EccentricityInY, and EccentricityInZ (or only EccentricityInX, and EccentricityInY if the
/// underlying coordinate system is two-dimensional), or
/// providing both.
/// 
/// NOTEÿ If both, PointOnRelatedElement, and EccentricityInX, EccentricityInY, (EccentricityInZ) are provided, the values should be consistent. In case of any non-consistency, the calculated distance between PointOnRelatingElement and PointOnRelatedElement takes precedence.
/// 
/// The explicit values for EccentricityInX, EccentricityInY, and EccentricityInZ are always
/// measured in the following direction and coordinate system (defining when the value is positive or negative):
/// 
/// from the PointOnRelatedElement to PointOnRelatingElement within the coordinate system of the RelatingElement.
/// in addition: when used to specify connections in structural analysis models, the IfcStructuralMember is to be used as the RelatingElement of the relationship object utilizing IfcConnectionPointEccentricity, and the IfcStructuralConnection is the RelatedElement.
/// 
/// HISTORYÿ New entity in IFC 2x Edition 3.
/// 
/// Geometry use definitions
/// The IfcPoint (or the IfcVertexPoint with an associated IfcPoint) at the PointOnRelatingElement attribute defines the point where the basic geometry items of the connected elements connects. The point coordinates are provided within the local coordinate system of the RelatingElement, as specified at the IfcRelConnects subtype that utilizes the IfcConnectionPointGeometry. Optionally, the same point coordinates can also be provided within the local coordinate system of the RelatedElement by using the PointOnRelatedElement attribute, otherwise the distance to the point at the RelatedElement has to be given by the three eccentricity values.
class IFC_PARSE_API IfcConnectionPointEccentricity : public IfcConnectionPointGeometry {
public:
    /// Whether the optional attribute EccentricityInX is defined for this IfcConnectionPointEccentricity
    bool hasEccentricityInX() const;
    /// Distance in x direction between the two points (or vertex points) engaged in the point connection.
    double EccentricityInX() const;
    void setEccentricityInX(double v);
    /// Whether the optional attribute EccentricityInY is defined for this IfcConnectionPointEccentricity
    bool hasEccentricityInY() const;
    /// Distance in y direction between the two points (or vertex points) engaged in the point connection.
    double EccentricityInY() const;
    void setEccentricityInY(double v);
    /// Whether the optional attribute EccentricityInZ is defined for this IfcConnectionPointEccentricity
    bool hasEccentricityInZ() const;
    /// Distance in z direction between the two points (or vertex points) engaged in the point connection.
    double EccentricityInZ() const;
    void setEccentricityInZ(double v);
    virtual unsigned int getArgumentCount() const { return 5; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 2: return IfcUtil::Argument_DOUBLE; case 3: return IfcUtil::Argument_DOUBLE; case 4: return IfcUtil::Argument_DOUBLE; } return IfcConnectionPointGeometry::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 2: return Type::IfcLengthMeasure; case 3: return Type::IfcLengthMeasure; case 4: return Type::IfcLengthMeasure; } return IfcConnectionPointGeometry::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 2: return "EccentricityInX"; case 3: return "EccentricityInY"; case 4: return "EccentricityInZ"; } return IfcConnectionPointGeometry::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcConnectionPointEccentricity (IfcEntityInstanceData* e);
    IfcConnectionPointEccentricity (IfcPointOrVertexPoint* v1_PointOnRelatingElement, IfcPointOrVertexPoint* v2_PointOnRelatedElement, boost::optional< double > v3_EccentricityInX, boost::optional< double > v4_EccentricityInY, boost::optional< double > v5_EccentricityInZ);
    typedef IfcTemplatedEntityList< IfcConnectionPointEccentricity > list;
};
/// Definition from ISO/CD 10303-41:1992: A context dependent unit is a unit which is not related to the SI system.
/// 
/// NOTE The number of parts in an assembly is a physical quantity measured in units that may be called "parts" but which cannot be related to an SI unit.
/// 
/// NOTE Corresponding ISO 10303 name: context_dependent_unit, please refer to ISO/IS 10303-41 for the final definition of the formal standard.
/// 
/// HISTORY New entity in IFC Release 1.5.1.
class IFC_PARSE_API IfcContextDependentUnit : public IfcNamedUnit {
public:
    /// The word, or group of words, by which the context dependent unit is referred to.
    std::string Name() const;
    void setName(std::string v);
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 2: return IfcUtil::Argument_STRING; } return IfcNamedUnit::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 2: return Type::IfcLabel; } return IfcNamedUnit::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 2: return "Name"; } return IfcNamedUnit::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcExternalReferenceRelationship >::ptr HasExternalReference() const; // INVERSE IfcExternalReferenceRelationship::RelatedResourceObjects
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcContextDependentUnit (IfcEntityInstanceData* e);
    IfcContextDependentUnit (IfcDimensionalExponents* v1_Dimensions, IfcUnitEnum::IfcUnitEnum v2_UnitType, std::string v3_Name);
    typedef IfcTemplatedEntityList< IfcContextDependentUnit > list;
};
/// Definition from ISO/CD 10303-41:1992: A conversion based unit is a unit that is defined based on a measure with unit.
/// 
/// NOTE Corresponding ISO 10303 name: conversion_based_unit, please refer to ISO/IS 10303-41 for the final definition of the formal standard.
/// 
/// HISTORY New entity in IFC Release 1.5.1.
/// 
/// IFC 2x3 change: standard names of typical units added.
/// 
/// IFC 2x4 change: further names added: square inch, square foot, square mile, square yard, cubic inch, cubic foot, cubic yard, fluid ounce UK/US, ton UK/US, degree.
/// 
/// Example: An inch is a converted unit. It is from the Imperial system, its name is "inch" and it can be related to the si unit, millimetre, through a measure with unit whose value is 25.4 millimetre. A foot is also a converted unit. It is from the Imperial system, its name is "foot" and it can be related to an IfcSIUnit, millimetre, either directly or through the unit called "inch". Note that several US customary units differ from Imperial units (nonmetric English units) of the same name.
/// 
/// To identify some commonly used conversion based units, the standard designations (case insensitive) for the Name attribute include the following:
/// 
/// Name	Description
///   'inch'		Length measure equal to 25.4 mm
///   'foot'		Length measure equal to 304.8 mm
///   'yard'		Length measure equal to 914 mm
///   'mile'		Length measure equal to 1609 m
///   'square inch'	Area measure equal to 0.0006452 square meters
///   'square foot'	Area measure equal to 0.09290 square meters
///   'square yard'	Area measure equal to 0.83612736 square meters
///   'acre'		Area measure equal to 4046.86 square meters
///   'square mile'	Area measure equal to 2 588 881 square meters
///   'cubic inch'	Volume measure equal to 0.00001639 cubic meters
///   'cubic foot'	Volume measure equal to 0.02832 cubic meters
///   'cubic yard'	Volume measure equal to 0.7636 cubic meters
///   'litre'		Volume measure equal to 0.001 cubic meters
///   'fluid ounce UK'	Volume measure equal to 0.0000284130625 cubic meters
///   'fluid ounce US'	Volume measure equal to 0.00002957353 cubic meters
///   'pint UK'		Volume measure equal to 0.000568 cubic meters
///   'pint US'		Volume measure equal to 0.000473 cubic meters
///   'gallon UK'	Volume measure equal to 0.004546 cubic meters
///   'gallon US'	Volume measure equal to 0.003785 cubic meters
///   'degree'		Angle measure equal to π/180 rad
///   'ounce'		Mass measure equal to 28.35 g
///   'pound'		Mass measure equal to 0.454 kg
///   'ton UK'		Mass measure equal to 1016.0469088 kg, also known as long ton, gross ton, shipper's ton
///   'ton US'		Mass measure equal to 907.18474 kg, also known as short ton, net ton
///   'lbf'		Force measure equal to 4.4482216153 N, pound-force
///   'kip'		Force measure equal to 4448.2216153 N, kilopound-force
///   'psi'		Pressure measure equal to 6894.7572932 Pa, pound-force per square inch
///   'ksi'		Pressure measure equal to 6894757.2932 Pa, kilopound-force per square inch
///   'minute'		Time measure equal to 60 s
///   'hour'		Time measure equal to 3600 s
///   'day'		Time measure equal to 86400 s
///   'btu'		Energy measure equal to 1055.056 J, British Thermal Unit
class IFC_PARSE_API IfcConversionBasedUnit : public IfcNamedUnit {
public:
    /// The word, or group of words, by which the conversion based unit is referred to.
    std::string Name() const;
    void setName(std::string v);
    /// The physical quantity from which the converted unit is derived.
    IfcMeasureWithUnit* ConversionFactor() const;
    void setConversionFactor(IfcMeasureWithUnit* v);
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 2: return IfcUtil::Argument_STRING; case 3: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcNamedUnit::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 2: return Type::IfcLabel; case 3: return Type::IfcMeasureWithUnit; } return IfcNamedUnit::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 2: return "Name"; case 3: return "ConversionFactor"; } return IfcNamedUnit::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcExternalReferenceRelationship >::ptr HasExternalReference() const; // INVERSE IfcExternalReferenceRelationship::RelatedResourceObjects
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcConversionBasedUnit (IfcEntityInstanceData* e);
    IfcConversionBasedUnit (IfcDimensionalExponents* v1_Dimensions, IfcUnitEnum::IfcUnitEnum v2_UnitType, std::string v3_Name, IfcMeasureWithUnit* v4_ConversionFactor);
    typedef IfcTemplatedEntityList< IfcConversionBasedUnit > list;
};
/// IfcConversionBasedUnitWithOffset is a unit which is converted from another unit by applying a conversion factor and an offset.
/// 
/// HISTORY New entity in IFC 2x4.
/// 
/// Example: The temperature unit Fahrenheit is based on the temperature unit Kelvin as follows:
/// 
/// f = k · 1.8 – 459.67
/// 
/// wherein k is an absolute temperature expressed in Kelvin and f is the same temperature in Fahrenheit.  The following entity instances provide Fahrenheit as a unit:
/// 
/// IfcConversionBasedUnitWithOffset(
///     IfcDimensionalExponents(0, 0, 0, 0, 1, 0, 0),
///     THERMODYNAMICTEMPERATUREUNIT,
///     'Fahrenheit',
///     IfcMeasureWithUnit(
///         IfcThermodynamicTemperatureMeasure(1.8),
///         IfcSiUnit(THERMODYNAMICTEMPERATUREUNIT, ?, KELVIN)),
///     -459.67);
class IFC_PARSE_API IfcConversionBasedUnitWithOffset : public IfcConversionBasedUnit {
public:
    /// A positive or negative offset to add after the inherited ConversionFactor was applied.
    double ConversionOffset() const;
    void setConversionOffset(double v);
    virtual unsigned int getArgumentCount() const { return 5; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 4: return IfcUtil::Argument_DOUBLE; } return IfcConversionBasedUnit::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 4: return Type::IfcReal; } return IfcConversionBasedUnit::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 4: return "ConversionOffset"; } return IfcConversionBasedUnit::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcConversionBasedUnitWithOffset (IfcEntityInstanceData* e);
    IfcConversionBasedUnitWithOffset (IfcDimensionalExponents* v1_Dimensions, IfcUnitEnum::IfcUnitEnum v2_UnitType, std::string v3_Name, IfcMeasureWithUnit* v4_ConversionFactor, double v5_ConversionOffset);
    typedef IfcTemplatedEntityList< IfcConversionBasedUnitWithOffset > list;
};
/// IfcCurrencyRelationship defines the rate of exchange
/// that applies between two designated currencies at a particular time
/// and as published by a particular source.
/// 
/// HISTORY  New Entity in IFC2x2.
/// 
/// IFC2x4 CHANGE  Subtyped from IfcResourceLevelRelationship, attribute order changed.
/// 
/// Use definitions
/// An IfcCurrencyRelationship is used where there may be a need to reference an IfcCostValue in one currency to an IfcCostValue in another currency. It takes account of fact that currency exchange rates may vary by requiring the recording the date and time of the currency exchange rate used and the source that publishes the rate. There may be many sources and there are different strategies for currency conversion (spot rate, forward buying of currency at a fixed rate).
/// The source for the currency exchange is defined as an instance of IfcLibraryInformation that includes a name and a URL.
class IFC_PARSE_API IfcCurrencyRelationship : public IfcResourceLevelRelationship {
public:
    /// The monetary unit from which an exchange is derived. For instance, in the case of a conversion from GBP to USD, the relating monetary unit is GBP.
    IfcMonetaryUnit* RelatingMonetaryUnit() const;
    void setRelatingMonetaryUnit(IfcMonetaryUnit* v);
    /// The monetary unit to which an exchange results. For instance, in the case of a conversion from GBP to USD, the related monetary unit is USD.
    IfcMonetaryUnit* RelatedMonetaryUnit() const;
    void setRelatedMonetaryUnit(IfcMonetaryUnit* v);
    /// The currently agreed ratio of the amount of a related monetary unit that is equivalent to a unit amount of the relating monetary unit in a currency relationship. For instance, in the case of a conversion from GBP to USD, the value of the exchange rate may be 1.486 (USD) : 1 (GBP).
    double ExchangeRate() const;
    void setExchangeRate(double v);
    /// Whether the optional attribute RateDateTime is defined for this IfcCurrencyRelationship
    bool hasRateDateTime() const;
    /// The date and time at which an exchange rate applies.
    /// 
    /// IFC2x4 CHANGE Type changed from IfcDateTimeSelect. Attribute made optional.
    std::string RateDateTime() const;
    void setRateDateTime(std::string v);
    /// Whether the optional attribute RateSource is defined for this IfcCurrencyRelationship
    bool hasRateSource() const;
    /// The source from which an exchange rate is obtained.
    IfcLibraryInformation* RateSource() const;
    void setRateSource(IfcLibraryInformation* v);
    virtual unsigned int getArgumentCount() const { return 7; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 2: return IfcUtil::Argument_ENTITY_INSTANCE; case 3: return IfcUtil::Argument_ENTITY_INSTANCE; case 4: return IfcUtil::Argument_DOUBLE; case 5: return IfcUtil::Argument_STRING; case 6: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcResourceLevelRelationship::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 2: return Type::IfcMonetaryUnit; case 3: return Type::IfcMonetaryUnit; case 4: return Type::IfcPositiveRatioMeasure; case 5: return Type::IfcDateTime; case 6: return Type::IfcLibraryInformation; } return IfcResourceLevelRelationship::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 2: return "RelatingMonetaryUnit"; case 3: return "RelatedMonetaryUnit"; case 4: return "ExchangeRate"; case 5: return "RateDateTime"; case 6: return "RateSource"; } return IfcResourceLevelRelationship::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCurrencyRelationship (IfcEntityInstanceData* e);
    IfcCurrencyRelationship (boost::optional< std::string > v1_Name, boost::optional< std::string > v2_Description, IfcMonetaryUnit* v3_RelatingMonetaryUnit, IfcMonetaryUnit* v4_RelatedMonetaryUnit, double v5_ExchangeRate, boost::optional< std::string > v6_RateDateTime, IfcLibraryInformation* v7_RateSource);
    typedef IfcTemplatedEntityList< IfcCurrencyRelationship > list;
};
/// Definition from ISO/CD 10303-46:1992: A curve style specifies the visual appearance of curves.
/// 
/// An IfcCurveStyle provides the style table for presentation information assigned to geometric curves. The style is defined by a color, a font and a width. The IfcCurveStyle defines curve patterns as model patterns, that is, the distance between visible and invisible segments of curve patterns are given in model space dimensions (that have to be scaled using the target plot scale).
/// 
/// Styles are intended to be shared by multiple IfcStyledItem's, assigning the style to occurrences of (subtypes of) IfcGeometricRepresentationItem's. Measures given to a font pattern or a curve width are given in global drawing length units.
/// 
/// NOTE  global units are defined at the single IfcProject instance, given by UnitsInContext:IfcUnitAssignment, the same units are used for the geometric representation items and for the style definitions.
/// 
/// The measure values for font pattern and curve width apply to the model space with a target plot scale provided for the correct appearance in the default plot scale.. For different scale and projection dependent curve styles a different instance of IfcCurveStyle needs to be used by IfcPresentationStyleAssignment for different IfcGeometricRepresentationSubContext dependent representations.
/// 
/// NOTE  the target plot scale is given by IfcGeometricRepresentationSubContext.TargetScale.
/// 
/// An IfcCurveStyle can be assigned to IfcGeometricRepresentationItem's via the IfcPresentationStyleAssignment through an intermediate IfcStyledItem or IfcAnnotationCurveOccurrence.
/// 
/// NOTE  Corresponding ISO 10303 name: curve_style. Please refer to ISO/IS 10303-46:1994 for the final definition of the formal standard.
/// 
/// HISTORY  New entity in IFC2x2.
class IFC_PARSE_API IfcCurveStyle : public IfcPresentationStyle {
public:
    /// Whether the optional attribute CurveFont is defined for this IfcCurveStyle
    bool hasCurveFont() const;
    /// A curve style font which is used to present a curve. It can either be a predefined curve font, or an explicitly defined curve font. Both may be scaled. If not given, then the curve font should be taken from the layer assignment with style, if that is not given either, then the default curve font applies.
    IfcCurveFontOrScaledCurveFontSelect* CurveFont() const;
    void setCurveFont(IfcCurveFontOrScaledCurveFontSelect* v);
    /// Whether the optional attribute CurveWidth is defined for this IfcCurveStyle
    bool hasCurveWidth() const;
    /// A positive length measure in units of the presentation area for the width of a presented curve. If not given, then the style should be taken from the layer assignment with style, if that is not given either, then the default style applies.
    IfcSizeSelect* CurveWidth() const;
    void setCurveWidth(IfcSizeSelect* v);
    /// Whether the optional attribute CurveColour is defined for this IfcCurveStyle
    bool hasCurveColour() const;
    /// The colour of the visible part of the curve. If not given, then the colour should be taken from the layer assignment with style, if that is not given either, then the default colour applies.
    IfcColour* CurveColour() const;
    void setCurveColour(IfcColour* v);
    /// Whether the optional attribute ModelOrDraughting is defined for this IfcCurveStyle
    bool hasModelOrDraughting() const;
    bool ModelOrDraughting() const;
    void setModelOrDraughting(bool v);
    virtual unsigned int getArgumentCount() const { return 5; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 1: return IfcUtil::Argument_ENTITY_INSTANCE; case 2: return IfcUtil::Argument_ENTITY_INSTANCE; case 3: return IfcUtil::Argument_ENTITY_INSTANCE; case 4: return IfcUtil::Argument_BOOL; } return IfcPresentationStyle::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 1: return Type::IfcCurveFontOrScaledCurveFontSelect; case 2: return Type::IfcSizeSelect; case 3: return Type::IfcColour; case 4: return Type::IfcBoolean; } return IfcPresentationStyle::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 1: return "CurveFont"; case 2: return "CurveWidth"; case 3: return "CurveColour"; case 4: return "ModelOrDraughting"; } return IfcPresentationStyle::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCurveStyle (IfcEntityInstanceData* e);
    IfcCurveStyle (boost::optional< std::string > v1_Name, IfcCurveFontOrScaledCurveFontSelect* v2_CurveFont, IfcSizeSelect* v3_CurveWidth, IfcColour* v4_CurveColour, boost::optional< bool > v5_ModelOrDraughting);
    typedef IfcTemplatedEntityList< IfcCurveStyle > list;
};
/// Definition from ISO/CD 10303-46:1992: A curve style font combines several curve style font pattern entities into a more complex pattern. The resulting pattern is repeated along the curve. 
/// 
/// NOTE: Corresponding ISO 10303 name: curve_style_font. Please refer to ISO/IS 10303-46:1994 for the final definition of the formal standard.
/// 
/// HISTORY: New entity in IFC2x2.
class IFC_PARSE_API IfcCurveStyleFont : public IfcPresentationItem {
public:
    /// Whether the optional attribute Name is defined for this IfcCurveStyleFont
    bool hasName() const;
    /// Name that may be assigned with the curve font.
    std::string Name() const;
    void setName(std::string v);
    /// A list of curve font pattern entities, that contains the simple patterns used for drawing curves. The patterns are applied in the order they occur in the list.
    IfcTemplatedEntityList< IfcCurveStyleFontPattern >::ptr PatternList() const;
    void setPatternList(IfcTemplatedEntityList< IfcCurveStyleFontPattern >::ptr v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_STRING; case 1: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } return IfcPresentationItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcLabel; case 1: return Type::IfcCurveStyleFontPattern; } return IfcPresentationItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Name"; case 1: return "PatternList"; } return IfcPresentationItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCurveStyleFont (IfcEntityInstanceData* e);
    IfcCurveStyleFont (boost::optional< std::string > v1_Name, IfcTemplatedEntityList< IfcCurveStyleFontPattern >::ptr v2_PatternList);
    typedef IfcTemplatedEntityList< IfcCurveStyleFont > list;
};
/// Definition from ISO/CD 10303-46:1992: A curve style font and scaling is a curve style font and a scalar factor for that font, so that a given curve style font may be applied at various scales.
/// 
/// The IfcCurveStyleFontAndScaling allows for the reuse of the same curve style definition in several sizes. The definition of the CurveFontScale is the scaling of a base curve style pattern to be used as a new or derived curve style pattern.
/// 
/// NOTE  The CurveFontScale should not be mixed up with the target plot scale.
/// 
/// An example for IfcCurveStyleFontAndScaling is the sizing of a basic curve style dash pattern 'dash' (visible 0.01m, invisible 0.005m) into 'dash large' with CurveFontScale = 2 (resulting in visible 0.02m, invisible 0.01m), and into 'dash small' with CurveFontScale = 0.5 (resulting in visible 0.005m, invisible 0.0025m).
/// 
/// NOTE  Corresponding ISO 10303 name: curve_style_font_and_scaling. Please refer to ISO/IS 10303-46:1994 for the final definition of the formal standard.
/// 
/// HISTORY  New entity in IFC2x2.
class IFC_PARSE_API IfcCurveStyleFontAndScaling : public IfcPresentationItem {
public:
    /// Whether the optional attribute Name is defined for this IfcCurveStyleFontAndScaling
    bool hasName() const;
    /// Name that may be assigned with the scaling of a curve font.
    std::string Name() const;
    void setName(std::string v);
    /// The curve font to be scaled.
    IfcCurveStyleFontSelect* CurveFont() const;
    void setCurveFont(IfcCurveStyleFontSelect* v);
    /// The scale factor.
    double CurveFontScaling() const;
    void setCurveFontScaling(double v);
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_STRING; case 1: return IfcUtil::Argument_ENTITY_INSTANCE; case 2: return IfcUtil::Argument_DOUBLE; } return IfcPresentationItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcLabel; case 1: return Type::IfcCurveStyleFontSelect; case 2: return Type::IfcPositiveRatioMeasure; } return IfcPresentationItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Name"; case 1: return "CurveFont"; case 2: return "CurveFontScaling"; } return IfcPresentationItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCurveStyleFontAndScaling (IfcEntityInstanceData* e);
    IfcCurveStyleFontAndScaling (boost::optional< std::string > v1_Name, IfcCurveStyleFontSelect* v2_CurveFont, double v3_CurveFontScaling);
    typedef IfcTemplatedEntityList< IfcCurveStyleFontAndScaling > list;
};
/// Definition from ISO/CD 10303-46:1992: A curve style font pattern is a pair of visible and invisible curve segment length measures in presentation area units. 
/// 
/// NOTE Corresponding ISO 10303 name: curve_style_font_pattern. Please refer to ISO/IS 10303-46:1994 for the final definition of the formal standard.
/// 
/// HISTORY New entity in IFC2x2.
class IFC_PARSE_API IfcCurveStyleFontPattern : public IfcPresentationItem {
public:
    /// The length of the visible segment in the pattern definition.
    /// 
    /// NOTE  For a visible segment representing a point, the value 0. should be assigned.
    /// 
    /// IFC2x Edition 3 CHANGE  The datatype has been changed to IfcLengthMeasure with upward compatibility for file-based exchange.
    double VisibleSegmentLength() const;
    void setVisibleSegmentLength(double v);
    /// The length of the invisible segment in the pattern definition.
    double InvisibleSegmentLength() const;
    void setInvisibleSegmentLength(double v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_DOUBLE; case 1: return IfcUtil::Argument_DOUBLE; } return IfcPresentationItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcLengthMeasure; case 1: return Type::IfcPositiveLengthMeasure; } return IfcPresentationItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "VisibleSegmentLength"; case 1: return "InvisibleSegmentLength"; } return IfcPresentationItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCurveStyleFontPattern (IfcEntityInstanceData* e);
    IfcCurveStyleFontPattern (double v1_VisibleSegmentLength, double v2_InvisibleSegmentLength);
    typedef IfcTemplatedEntityList< IfcCurveStyleFontPattern > list;
};
/// IfcDerivedProfileDef defines the profile by transformation from the parent profile. The transformation is given by a two dimensional transformation operator. Transformation includes translation, rotation, mirror and scaling. The latter can be uniform or non uniform. The derived profiles may be used to define swept surfaces, swept area solids or sectioned spines.
/// 
/// The transformation effects the position, rotation, mirroring or scale of the profile at the underlying coordinate system, i.e. the coordinate system defined by the swept surface or swept area solid that uses the profile definition. It is the xy plane of either: 
/// 
/// IfcSweptSurface.Position
///   IfcSweptAreaSolid.Position
/// 
/// or in case of sectioned spines the xy plane of each list member of IfcSectionedSpine.CrossSectionPositions. The position and potential rotation of the ParentProfile within the underlying coordinate system is taken into consideration before applying the Cartesian transformation operator.
/// 
/// Note, if only mirroring is required, IfcMirroredProfileDef should be used instead.
/// 
/// HISTORY: New entity in IFC Release 2x.
/// 
/// Figure 316 illustrates examples of derived profiles.
/// 
/// Parameter
/// The IfcDerivedProfileDef
/// is defined using the IfcCartesianTransformationOperator2D
/// (CTO), which is applied to the parent profile definition. 
/// 
/// Example
/// The example shows an uniform scaling and a transformation
/// of an IfcRectangleProfileDef
/// to match the lower-left cardinal point. The attributes of the CTO are:
/// 
/// Axis1 = NIL (defaults to 1.,0.)
///   Axis2 = NIL (defaults to 0.,1.)
///   LocalOrigin = IfcCartesianPoint(,)
///   Scale = 2.
/// 
/// Note: The ParentProfile has a Position
/// = IfcCartesianPoint(,) already.
/// 
/// Parameter
/// The IfcDerivedProfileDef is defined using
/// non uniform transformationsby applying the IfcCartesianTransformationOperator2DnonUniform
/// as a subtype of the 2D CTO.
/// 
/// Example
/// The example shows a non-uniform scaling and a translation of an IfcRectangleProfileDef
/// to match the lower-left cardinal point. The attributes of the CTO are:
/// 
/// Axis1 = NIL (defaults to 1.,0.)
///   Axis2 = NIL (defaults to 0.,1.)
///   LocalOrigin = IfcCartesianPoint(0.,<1/2 YDim)
///   Scale  = 1.
///   Scale2 = 2.
/// 
/// Note: The ParentProfile has a Position
/// = IfcCartesianPoint(,) already.
/// 
/// Parameter
/// The IfcDerivedProfileDef
/// is defined using mirroring by applying the IfcCartesianTransformationOperator2D
/// (CTO) to the parent profile.
/// 
/// Example
/// The example shows a mirroring of an IfcLShapeProfileDef
/// to match the centre cardinal point. The attributes of the CTO are:
/// 
/// Axis1 = (-1.,0.)
///   Axis2 = NIL (defaults to 0.,1.)
///   LocalOrigin = IfcCartesianPoint(0.,0.)
///   Scale = NIL (defaults to 1.)
/// 
/// Note: The ParentProfile has a Position = IfcCartesianPoint(0.,0.).
/// 
/// This example is for illustration only.
/// If the transformation results only in mirroring like shown in the example, then
/// IfcMirroredProfileDef should be used instead of IfcDerivedProfileDef.
/// 
/// Note: The following color map applies:
/// 
/// black coordinate axes show the
///   underlying coordinate system of the swept surface, swept area solid, or
///   sectioned spine
/// 
/// red coordinate axes
///   show the position coordinate system of the parent profile
/// 
/// brown coordinate axes
///   show the position coordinate system of the derived profile
/// 
/// Figure 316 — Derived profile
class IFC_PARSE_API IfcDerivedProfileDef : public IfcProfileDef {
public:
    /// The parent profile provides the origin of the transformation.
    IfcProfileDef* ParentProfile() const;
    void setParentProfile(IfcProfileDef* v);
    /// Transformation operator applied to the parent profile.
    IfcCartesianTransformationOperator2D* Operator() const;
    void setOperator(IfcCartesianTransformationOperator2D* v);
    /// Whether the optional attribute Label is defined for this IfcDerivedProfileDef
    bool hasLabel() const;
    /// The name by which the transformation may be referred to. The actual meaning of the name has to be defined in the context of applications.
    std::string Label() const;
    void setLabel(std::string v);
    virtual unsigned int getArgumentCount() const { return 5; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 2: return IfcUtil::Argument_ENTITY_INSTANCE; case 3: return IfcUtil::Argument_ENTITY_INSTANCE; case 4: return IfcUtil::Argument_STRING; } return IfcProfileDef::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 2: return Type::IfcProfileDef; case 3: return Type::IfcCartesianTransformationOperator2D; case 4: return Type::IfcLabel; } return IfcProfileDef::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 2: return "ParentProfile"; case 3: return "Operator"; case 4: return "Label"; } return IfcProfileDef::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcDerivedProfileDef (IfcEntityInstanceData* e);
    IfcDerivedProfileDef (IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< std::string > v2_ProfileName, IfcProfileDef* v3_ParentProfile, IfcCartesianTransformationOperator2D* v4_Operator, boost::optional< std::string > v5_Label);
    typedef IfcTemplatedEntityList< IfcDerivedProfileDef > list;
};
/// IfcDocumentInformation captures "metadata" of an external document. The actual content of the document is not defined in IFC; instead, it can be found following the reference given to IfcDocumentReference. 
/// 
/// HISTORY: New entity in IFC 2x.
class IFC_PARSE_API IfcDocumentInformation : public IfcExternalInformation {
public:
    std::string Identification() const;
    void setIdentification(std::string v);
    /// File name or document name assigned by owner.
    std::string Name() const;
    void setName(std::string v);
    /// Whether the optional attribute Description is defined for this IfcDocumentInformation
    bool hasDescription() const;
    /// Description of document and its content.
    std::string Description() const;
    void setDescription(std::string v);
    /// Whether the optional attribute Location is defined for this IfcDocumentInformation
    bool hasLocation() const;
    /// Resource identifier or locator, provided as URI, URN or URL, of the document information for online references.
    /// 
    /// IFC2x4 CHANGE  New attribute added at end of attribute list.
    std::string Location() const;
    void setLocation(std::string v);
    /// Whether the optional attribute Purpose is defined for this IfcDocumentInformation
    bool hasPurpose() const;
    /// Purpose for this document.
    std::string Purpose() const;
    void setPurpose(std::string v);
    /// Whether the optional attribute IntendedUse is defined for this IfcDocumentInformation
    bool hasIntendedUse() const;
    /// Intended use for this document.
    std::string IntendedUse() const;
    void setIntendedUse(std::string v);
    /// Whether the optional attribute Scope is defined for this IfcDocumentInformation
    bool hasScope() const;
    /// Scope for this document.
    std::string Scope() const;
    void setScope(std::string v);
    /// Whether the optional attribute Revision is defined for this IfcDocumentInformation
    bool hasRevision() const;
    /// Document revision designation.
    std::string Revision() const;
    void setRevision(std::string v);
    /// Whether the optional attribute DocumentOwner is defined for this IfcDocumentInformation
    bool hasDocumentOwner() const;
    /// Information about the person and/or organization acknowledged as the 'owner' of this document. In some contexts, the document owner determines who has access to or editing right to the document.
    IfcActorSelect* DocumentOwner() const;
    void setDocumentOwner(IfcActorSelect* v);
    /// Whether the optional attribute Editors is defined for this IfcDocumentInformation
    bool hasEditors() const;
    /// The persons and/or organizations who have created this document or contributed to it.
    IfcEntityList::ptr Editors() const;
    void setEditors(IfcEntityList::ptr v);
    /// Whether the optional attribute CreationTime is defined for this IfcDocumentInformation
    bool hasCreationTime() const;
    /// Date and time stamp when the document was originally created.
    /// 
    /// IFC2x4 CHANGE The data type has been changed to IfcDateTime, the date time string according to ISO8601.
    std::string CreationTime() const;
    void setCreationTime(std::string v);
    /// Whether the optional attribute LastRevisionTime is defined for this IfcDocumentInformation
    bool hasLastRevisionTime() const;
    /// Date and time stamp when this document version was created.
    /// 
    /// IFC2x4 CHANGE The data type has been changed to IfcDateTime, the date time string according to ISO8601.
    std::string LastRevisionTime() const;
    void setLastRevisionTime(std::string v);
    /// Whether the optional attribute ElectronicFormat is defined for this IfcDocumentInformation
    bool hasElectronicFormat() const;
    /// Describes the electronic format of the document being referenced, providing the file extension and the manner in which the content is provided.
    std::string ElectronicFormat() const;
    void setElectronicFormat(std::string v);
    /// Whether the optional attribute ValidFrom is defined for this IfcDocumentInformation
    bool hasValidFrom() const;
    /// Date when the document becomes valid.
    /// 
    /// IFC2x4 CHANGE The data type has been changed to IfcDate, the date string according to ISO8601.
    std::string ValidFrom() const;
    void setValidFrom(std::string v);
    /// Whether the optional attribute ValidUntil is defined for this IfcDocumentInformation
    bool hasValidUntil() const;
    /// Date until which the document remains valid.
    /// 
    /// IFC2x4 CHANGE The data type has been changed to IfcDate, the date string according to ISO8601.
    std::string ValidUntil() const;
    void setValidUntil(std::string v);
    /// Whether the optional attribute Confidentiality is defined for this IfcDocumentInformation
    bool hasConfidentiality() const;
    /// The level of confidentiality of the document.
    IfcDocumentConfidentialityEnum::IfcDocumentConfidentialityEnum Confidentiality() const;
    void setConfidentiality(IfcDocumentConfidentialityEnum::IfcDocumentConfidentialityEnum v);
    /// Whether the optional attribute Status is defined for this IfcDocumentInformation
    bool hasStatus() const;
    /// The current status of the document. Examples of status values that might be used for a document information status include:
    /// - DRAFT
    /// - FINAL DRAFT
    /// - FINAL
    /// - REVISION
    IfcDocumentStatusEnum::IfcDocumentStatusEnum Status() const;
    void setStatus(IfcDocumentStatusEnum::IfcDocumentStatusEnum v);
    virtual unsigned int getArgumentCount() const { return 17; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_STRING; case 1: return IfcUtil::Argument_STRING; case 2: return IfcUtil::Argument_STRING; case 3: return IfcUtil::Argument_STRING; case 4: return IfcUtil::Argument_STRING; case 5: return IfcUtil::Argument_STRING; case 6: return IfcUtil::Argument_STRING; case 7: return IfcUtil::Argument_STRING; case 8: return IfcUtil::Argument_ENTITY_INSTANCE; case 9: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 10: return IfcUtil::Argument_STRING; case 11: return IfcUtil::Argument_STRING; case 12: return IfcUtil::Argument_STRING; case 13: return IfcUtil::Argument_STRING; case 14: return IfcUtil::Argument_STRING; case 15: return IfcUtil::Argument_ENUMERATION; case 16: return IfcUtil::Argument_ENUMERATION; } return IfcExternalInformation::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcIdentifier; case 1: return Type::IfcLabel; case 2: return Type::IfcText; case 3: return Type::IfcURIReference; case 4: return Type::IfcText; case 5: return Type::IfcText; case 6: return Type::IfcText; case 7: return Type::IfcLabel; case 8: return Type::IfcActorSelect; case 9: return Type::IfcActorSelect; case 10: return Type::IfcDateTime; case 11: return Type::IfcDateTime; case 12: return Type::IfcIdentifier; case 13: return Type::IfcDate; case 14: return Type::IfcDate; case 15: return Type::IfcDocumentConfidentialityEnum; case 16: return Type::IfcDocumentStatusEnum; } return IfcExternalInformation::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Identification"; case 1: return "Name"; case 2: return "Description"; case 3: return "Location"; case 4: return "Purpose"; case 5: return "IntendedUse"; case 6: return "Scope"; case 7: return "Revision"; case 8: return "DocumentOwner"; case 9: return "Editors"; case 10: return "CreationTime"; case 11: return "LastRevisionTime"; case 12: return "ElectronicFormat"; case 13: return "ValidFrom"; case 14: return "ValidUntil"; case 15: return "Confidentiality"; case 16: return "Status"; } return IfcExternalInformation::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcRelAssociatesDocument >::ptr DocumentInfoForObjects() const; // INVERSE IfcRelAssociatesDocument::RelatingDocument
    IfcTemplatedEntityList< IfcDocumentReference >::ptr HasDocumentReferences() const; // INVERSE IfcDocumentReference::ReferencedDocument
    IfcTemplatedEntityList< IfcDocumentInformationRelationship >::ptr IsPointedTo() const; // INVERSE IfcDocumentInformationRelationship::RelatedDocuments
    IfcTemplatedEntityList< IfcDocumentInformationRelationship >::ptr IsPointer() const; // INVERSE IfcDocumentInformationRelationship::RelatingDocument
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcDocumentInformation (IfcEntityInstanceData* e);
    IfcDocumentInformation (std::string v1_Identification, std::string v2_Name, boost::optional< std::string > v3_Description, boost::optional< std::string > v4_Location, boost::optional< std::string > v5_Purpose, boost::optional< std::string > v6_IntendedUse, boost::optional< std::string > v7_Scope, boost::optional< std::string > v8_Revision, IfcActorSelect* v9_DocumentOwner, boost::optional< IfcEntityList::ptr > v10_Editors, boost::optional< std::string > v11_CreationTime, boost::optional< std::string > v12_LastRevisionTime, boost::optional< std::string > v13_ElectronicFormat, boost::optional< std::string > v14_ValidFrom, boost::optional< std::string > v15_ValidUntil, boost::optional< IfcDocumentConfidentialityEnum::IfcDocumentConfidentialityEnum > v16_Confidentiality, boost::optional< IfcDocumentStatusEnum::IfcDocumentStatusEnum > v17_Status);
    typedef IfcTemplatedEntityList< IfcDocumentInformation > list;
};
/// An IfcDocumentInformationRelationship is a relationship class that enables a document to have the ability to reference other documents.
/// 
/// HISTORY  New entity in Release IFC2x.
/// 
/// IFC2x4 CHANGE  Subtyped from IfcResourceLevelRelationship, order of attributes changed.
/// 
/// Use definitions
/// This class can be used to describe relationships in which one document may reference one or more other sub documents or where a document is used as a replacement for another document (but where both the original and the replacing document need to be retained).
class IFC_PARSE_API IfcDocumentInformationRelationship : public IfcResourceLevelRelationship {
public:
    /// The document that acts as the parent, referencing or original document in a relationship.
    IfcDocumentInformation* RelatingDocument() const;
    void setRelatingDocument(IfcDocumentInformation* v);
    /// The document that acts as the child, referenced or replacing document in a relationship.
    IfcTemplatedEntityList< IfcDocumentInformation >::ptr RelatedDocuments() const;
    void setRelatedDocuments(IfcTemplatedEntityList< IfcDocumentInformation >::ptr v);
    /// Whether the optional attribute RelationshipType is defined for this IfcDocumentInformationRelationship
    bool hasRelationshipType() const;
    /// Describes the type of relationship between documents. This could be sub-document, replacement etc. The interpretation has to be established in an application context.
    std::string RelationshipType() const;
    void setRelationshipType(std::string v);
    virtual unsigned int getArgumentCount() const { return 5; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 2: return IfcUtil::Argument_ENTITY_INSTANCE; case 3: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 4: return IfcUtil::Argument_STRING; } return IfcResourceLevelRelationship::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 2: return Type::IfcDocumentInformation; case 3: return Type::IfcDocumentInformation; case 4: return Type::IfcLabel; } return IfcResourceLevelRelationship::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 2: return "RelatingDocument"; case 3: return "RelatedDocuments"; case 4: return "RelationshipType"; } return IfcResourceLevelRelationship::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcDocumentInformationRelationship (IfcEntityInstanceData* e);
    IfcDocumentInformationRelationship (boost::optional< std::string > v1_Name, boost::optional< std::string > v2_Description, IfcDocumentInformation* v3_RelatingDocument, IfcTemplatedEntityList< IfcDocumentInformation >::ptr v4_RelatedDocuments, boost::optional< std::string > v5_RelationshipType);
    typedef IfcTemplatedEntityList< IfcDocumentInformationRelationship > list;
};
/// An IfcDocumentReference is a reference 
/// to the location of a document. The reference is given by a system 
/// interpretable Location attribute (a URL string) where the document can be found, and an optional inherited
///   internal reference Identification, which refers to a system
///   interpretable position within the document. The optional inherited
/// Name attribute is meant to have meaning for human readers. Optional 
/// document metadata can also be captured through reference to 
/// IfcDocumentInformation.
/// 
/// HISTORY: New Entity in IFC Release 2.0.
///   Modified in IFC 2x.
class IFC_PARSE_API IfcDocumentReference : public IfcExternalReference {
public:
    /// Whether the optional attribute Description is defined for this IfcDocumentReference
    bool hasDescription() const;
    /// Description of the document reference for informational purposes.
    /// 
    /// IFC2x4 CHANGE  New attribute added at the end of the attribute list.
    std::string Description() const;
    void setDescription(std::string v);
    /// Whether the optional attribute ReferencedDocument is defined for this IfcDocumentReference
    bool hasReferencedDocument() const;
    /// The document that is referenced.
    IfcDocumentInformation* ReferencedDocument() const;
    void setReferencedDocument(IfcDocumentInformation* v);
    virtual unsigned int getArgumentCount() const { return 5; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 3: return IfcUtil::Argument_STRING; case 4: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcExternalReference::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 3: return Type::IfcText; case 4: return Type::IfcDocumentInformation; } return IfcExternalReference::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 3: return "Description"; case 4: return "ReferencedDocument"; } return IfcExternalReference::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcRelAssociatesDocument >::ptr DocumentRefForObjects() const; // INVERSE IfcRelAssociatesDocument::RelatingDocument
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcDocumentReference (IfcEntityInstanceData* e);
    IfcDocumentReference (boost::optional< std::string > v1_Location, boost::optional< std::string > v2_Identification, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcDocumentInformation* v5_ReferencedDocument);
    typedef IfcTemplatedEntityList< IfcDocumentReference > list;
};
/// Definition from ISO/CD 10303-42:1992: An edge is the
/// topological construct corresponding to the connection of two
/// vertices. More abstractly, it may stand for a logical
/// relationship between two vertices. The domain of an edge, if
/// present, is a finite, non-self-intersecting open curve in
/// RM, that is, a connected 1-dimensional
/// manifold. The bounds of an edge are two vertices, which need not
/// be distinct. The edge is oriented by choosing its traversal
/// direction to run from the first to the second vertex. If the two
/// vertices are the same, the edge is a self loop. The domain of the
/// edge does not include its bounds, and 0 ≤ Ξ ≤ ∞.
/// Associated with an edge may be a geometric curve to locate the
/// edge in a coordinate space; this is represented by the edge curve
/// (IfcEdgeCurve) subtype. The curve shall be finite and
/// non-self-intersecting within the domain of the edge. An edge is a
/// graph, so its multiplicity M and graph genus Ge
/// may be determined by the graph traversal algorithm. Since
/// M = E = 1, the Euler equation (1) reduces in the
/// case to
/// 
/// where V = 1 or 2, and Ge = 1 or 0.
/// Specifically, the topological edge defining data shall
/// satisfy:
/// 
/// - an edge has two vertices
/// 
/// - the vertices need not be distinct
/// 
/// - Equation (2) shall hold.
/// 
/// The geometry between the two
/// vertices defaults to a straight line if no curve geometry is
/// assigned using the subtype IfcEdgeCurve. The
/// IfcEdge can therefore be used to exchange straight edges
/// without an associated geometry provided by IfcLine or
/// IfcPolyline thought IfcEdgeCurve.EdgeGeometry.
/// 
/// Figure 333 illustrates an example where the bounds of the IfcEdge are given by the EdgeStart and EdgeEnd; this also determines the direction of the edge. The location within a coordinate space is determined by the IfcVertexPoint type for EdgeStart and EdgeEnd. Since no edge geometry is assigned, it defaults to a straight line agreeing to the direction sense.
/// 
/// Figure 333 — Edge representation
/// 
/// NOTE  Corresponding ISO 10303 entity: edge. Please refer to ISO/IS 10303-42:1994, p. 130 for the final definition of the formal standard.
/// 
/// HISTORY  New Entity in IFC Release 2.0
/// 
/// Informal propositions:
/// 
/// The edge has dimensionality 1.
/// The extend of an edge shall be finite and nonzero.
class IFC_PARSE_API IfcEdge : public IfcTopologicalRepresentationItem {
public:
    /// Start point (vertex) of the edge.
    IfcVertex* EdgeStart() const;
    void setEdgeStart(IfcVertex* v);
    /// End point (vertex) of the edge. The same vertex can be used for both EdgeStart and EdgeEnd.
    IfcVertex* EdgeEnd() const;
    void setEdgeEnd(IfcVertex* v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcTopologicalRepresentationItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcVertex; case 1: return Type::IfcVertex; } return IfcTopologicalRepresentationItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "EdgeStart"; case 1: return "EdgeEnd"; } return IfcTopologicalRepresentationItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcEdge (IfcEntityInstanceData* e);
    IfcEdge (IfcVertex* v1_EdgeStart, IfcVertex* v2_EdgeEnd);
    typedef IfcTemplatedEntityList< IfcEdge > list;
};
/// Definition from ISO/CD 10303-42:1992: An edge curve is
/// a special subtype of edge which has its geometry fully defined.
/// The geometry is defined by associating the edge with a curve
/// which may be unbounded. As the topological and geometric
/// directions may be opposed, an indicator (same sense) is used to
/// identify whether the edge and curve directions agree or are
/// opposed. The Boolean value indicates whether the curve direction
/// agrees with (TRUE) or is in the opposite direction (FALSE) to the
/// edge direction. Any geometry associated with the vertices of the
/// edge shall be consistent with the edge geometry. Multiple edges
/// can reference the same curve.
/// 
/// Figure 334 illustrates an example where the edge geometry is given by an unbounded curve, here IfcCircle. The bounds are provided by the EdgeStart and EdgeEnd, the topological direction of the IfcEdgeCurve opposes the direction of the IfcCircle by SameSense = FALSE.
/// 
/// Figure 334 — Edge curve
/// 
/// NOTE  Corresponding ISO 10303 entity: edge_curve. Please refer to ISO/IS 10303-42:1994, p. 132
/// for the final definition of the formal standard. Due to the general IFC model specification rule not to use multiple inheritance, the subtype relationship to geometric_representation_item is not included.
/// 
/// <blockquote class="history"
/// HISTORY  New Entity in IFC2x.
/// 
/// Informal propositions:
/// 
/// The domain of the edge curve is formally defined to be the
/// domain of its edge geometry as trimmed by the vertices. This
/// domain does not include the vertices.
/// An edge curve has non-zero finite extent.
/// An edge curve is a manifold.
/// An edge curve is arcwise connected.
/// The edge start is not a part of the edge domain.
/// The edge end is not a part of the edge domain.
/// Vertex geometry shall be consistent with edge geometry.
class IFC_PARSE_API IfcEdgeCurve : public IfcEdge {
public:
    /// The curve which defines the shape and spatial location of the edge. This curve may be unbounded and is implicitly trimmed by the vertices of the edge; this defines the edge domain. Multiple edges can reference the same curve.
    IfcCurve* EdgeGeometry() const;
    void setEdgeGeometry(IfcCurve* v);
    /// This logical flag indicates whether (TRUE), or not (FALSE) the senses of the edge and the curve defining the edge geometry are the same. The sense of an edge is from the edge start vertex to the edge end vertex; the sense of a curve is in the direction of increasing parameter.
    bool SameSense() const;
    void setSameSense(bool v);
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 2: return IfcUtil::Argument_ENTITY_INSTANCE; case 3: return IfcUtil::Argument_BOOL; } return IfcEdge::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 2: return Type::IfcCurve; case 3: return Type::IfcBoolean; } return IfcEdge::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 2: return "EdgeGeometry"; case 3: return "SameSense"; } return IfcEdge::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcEdgeCurve (IfcEntityInstanceData* e);
    IfcEdgeCurve (IfcVertex* v1_EdgeStart, IfcVertex* v2_EdgeEnd, IfcCurve* v3_EdgeGeometry, bool v4_SameSense);
    typedef IfcTemplatedEntityList< IfcEdgeCurve > list;
};
/// IfcEventTime captures the time-related information about an event
///   including the different types of event dates (i.e. actual,
///   scheduled, early, and late).
/// 
/// HISTORY: New entity in IFC2x4.
///   Use definitions
/// 
/// All given values should be provided by the application,
///   i.e. the IFC schema does not deal with dependencies between
///   process time values. At this stage there is also no
///   consistency check through where rules that guarantee a
///   meaningful population of date values. Thus, an application
///   is responsible to provide reasonable values and, if an
///   application receives event dates, has to make consistency
///   checks by their own.
/// 
/// IfcEventTime furthermore provides a generic
///   mechanism to differentiate between user given time values
///   and time values derived from user given time values and
///   other constraints such as work calendars and assigned
///   resources (derived from the process graph). The data origin flag 
///   is provided as a single attribute applying to all date time related attributes 
///   of IfcEventTime.
class IFC_PARSE_API IfcEventTime : public IfcSchedulingTime {
public:
    /// Whether the optional attribute ActualDate is defined for this IfcEventTime
    bool hasActualDate() const;
    /// The date on which an event actually occurs. It is a measured value.
    std::string ActualDate() const;
    void setActualDate(std::string v);
    /// Whether the optional attribute EarlyDate is defined for this IfcEventTime
    bool hasEarlyDate() const;
    /// The earliest date on which an event can occur. It is a calculated value.
    std::string EarlyDate() const;
    void setEarlyDate(std::string v);
    /// Whether the optional attribute LateDate is defined for this IfcEventTime
    bool hasLateDate() const;
    /// The latest date on which an event can occur. It is a calculated value.
    std::string LateDate() const;
    void setLateDate(std::string v);
    /// Whether the optional attribute ScheduleDate is defined for this IfcEventTime
    bool hasScheduleDate() const;
    /// The date on which an event is scheduled to occur. 
    ///   The value might be measured or somehow calculated, which is defined by
    ///   ScheduleDataOrigin.
    std::string ScheduleDate() const;
    void setScheduleDate(std::string v);
    virtual unsigned int getArgumentCount() const { return 7; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 3: return IfcUtil::Argument_STRING; case 4: return IfcUtil::Argument_STRING; case 5: return IfcUtil::Argument_STRING; case 6: return IfcUtil::Argument_STRING; } return IfcSchedulingTime::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 3: return Type::IfcDateTime; case 4: return Type::IfcDateTime; case 5: return Type::IfcDateTime; case 6: return Type::IfcDateTime; } return IfcSchedulingTime::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 3: return "ActualDate"; case 4: return "EarlyDate"; case 5: return "LateDate"; case 6: return "ScheduleDate"; } return IfcSchedulingTime::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcEventTime (IfcEntityInstanceData* e);
    IfcEventTime (boost::optional< std::string > v1_Name, boost::optional< IfcDataOriginEnum::IfcDataOriginEnum > v2_DataOrigin, boost::optional< std::string > v3_UserDefinedDataOrigin, boost::optional< std::string > v4_ActualDate, boost::optional< std::string > v5_EarlyDate, boost::optional< std::string > v6_LateDate, boost::optional< std::string > v7_ScheduleDate);
    typedef IfcTemplatedEntityList< IfcEventTime > list;
};

class IFC_PARSE_API IfcExtendedProperties : public IfcPropertyAbstraction {
public:
    /// Whether the optional attribute Name is defined for this IfcExtendedProperties
    bool hasName() const;
    std::string Name() const;
    void setName(std::string v);
    /// Whether the optional attribute Description is defined for this IfcExtendedProperties
    bool hasDescription() const;
    std::string Description() const;
    void setDescription(std::string v);
    IfcTemplatedEntityList< IfcProperty >::ptr Properties() const;
    void setProperties(IfcTemplatedEntityList< IfcProperty >::ptr v);
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_STRING; case 1: return IfcUtil::Argument_STRING; case 2: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } return IfcPropertyAbstraction::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcIdentifier; case 1: return Type::IfcText; case 2: return Type::IfcProperty; } return IfcPropertyAbstraction::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Name"; case 1: return "Description"; case 2: return "Properties"; } return IfcPropertyAbstraction::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcExtendedProperties (IfcEntityInstanceData* e);
    IfcExtendedProperties (boost::optional< std::string > v1_Name, boost::optional< std::string > v2_Description, IfcTemplatedEntityList< IfcProperty >::ptr v3_Properties);
    typedef IfcTemplatedEntityList< IfcExtendedProperties > list;
};
/// IfcExternalReferenceRelationship is a relationship entity that enables objects from the
/// IfcResourceObjectSelect to have the ability to be tagged by external references.
/// 
/// NOTE This relationship is used to assign classification, library or document information to entities that
/// do not inherit from IfcRoot. It has a similar functionality as the subtypes of IfcRelAssociates.
/// 
/// HISTORY New Entity in IFC 2x4
class IFC_PARSE_API IfcExternalReferenceRelationship : public IfcResourceLevelRelationship {
public:
    /// An external reference that can be used to tag an object within the range of IfcResourceObjectSelect.
    /// 
    /// NOTE  External references can be a library reference (for example a dictionary or a catalogue reference), a classification reference, or a documentation reference.
    IfcExternalReference* RelatingReference() const;
    void setRelatingReference(IfcExternalReference* v);
    /// Objects within the list of IfcResourceObjectSelect that can be tagged by an external reference to a dictionary, library, catalogue, classification or documentation.
    IfcEntityList::ptr RelatedResourceObjects() const;
    void setRelatedResourceObjects(IfcEntityList::ptr v);
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 2: return IfcUtil::Argument_ENTITY_INSTANCE; case 3: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } return IfcResourceLevelRelationship::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 2: return Type::IfcExternalReference; case 3: return Type::IfcResourceObjectSelect; } return IfcResourceLevelRelationship::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 2: return "RelatingReference"; case 3: return "RelatedResourceObjects"; } return IfcResourceLevelRelationship::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcExternalReferenceRelationship (IfcEntityInstanceData* e);
    IfcExternalReferenceRelationship (boost::optional< std::string > v1_Name, boost::optional< std::string > v2_Description, IfcExternalReference* v3_RelatingReference, IfcEntityList::ptr v4_RelatedResourceObjects);
    typedef IfcTemplatedEntityList< IfcExternalReferenceRelationship > list;
};
/// Definition from ISO/CD 10303-42:1992: A face is a topological
///   entity of dimensionality 2 corresponding to the intuitive notion of a piece of
///   surface bounded by loops. Its domain, if present, is an oriented, connected,
///   finite 2-manifold in Rm. A face domain shall not have handles
///   but it may have holes, each hole bounded by a loop. The domain of the
///   underlying geometry of the face, if present, does not contain its bounds, and 0
///   < Ξ < ∞. 
///   A face is represented by its bounding loops, which are defined as face
///   bounds. A face has a topological normal n and the tangent to a loop is t. For a
///   loop bounding a face with defined geometry, the cross product n x t points
///   toward the interior of the face. That is, each loop runs counter-clockwise
///   around the face when viewed from above, if we consider the normal n to point
///   up. With each loop is associated a BOOLEAN flag to signify whether the loop
///   direction is oriented with respect to the face normal (TRUE) or should be
///   reversed (FALSE).  
///   A face shall have at least one bound, and the loops shall not intersect.
///   One loop is optionally distinguished as the outer loop of the face. If so, it
///   establishes a preferred way of embedding the face domain in the plane, in which
///   the other bounding loops of the face are inside the outer bound. Because the
///   face domain is arcwise connected, no inner loop will contain any other loop.
///   This is true regardless of which embedding in the plane is chosen.  
///   The edges and vertices referenced by the loops of a face form a graph,
///   of which the individual loops are the connected components. The Euler equation
///   (1) for this graph becomes: 
/// 
/// where Gli is the graph genus of the
///   i th loop. 
/// 
/// NOTE  Corresponding ISO 10303 entity: face. No subtypes of face have been incorporated
///   into this IFC Release. Please refer to ISO/IS 10303-42:1994, p. 140 for the
///   final definition of the formal standard. The WR1 has not been incorporated,
///   since it is always satisfied, due to the fact that only poly loops exist for
///   face bounds.
/// 
/// HISTORY  New class in IFC Release 1.0
/// 
/// Informal propositions: 
/// 
/// No edge shall be referenced by the face more than twice.  
///   Distinct face bounds of the face shall have no common vertices. 
///   If geometry is present, distinct loops of the same face shall not
///   intersect.  
///   The face shall satisfy the Euler Equation: (number of vertices) -
///   (number of edges) - (number of loops) + (sum of genus for loops) = 0.
class IFC_PARSE_API IfcFace : public IfcTopologicalRepresentationItem {
public:
    /// Boundaries of the face.
    IfcTemplatedEntityList< IfcFaceBound >::ptr Bounds() const;
    void setBounds(IfcTemplatedEntityList< IfcFaceBound >::ptr v);
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } return IfcTopologicalRepresentationItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcFaceBound; } return IfcTopologicalRepresentationItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Bounds"; } return IfcTopologicalRepresentationItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcTextureMap >::ptr HasTextureMaps() const; // INVERSE IfcTextureMap::MappedTo
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcFace (IfcEntityInstanceData* e);
    IfcFace (IfcTemplatedEntityList< IfcFaceBound >::ptr v1_Bounds);
    typedef IfcTemplatedEntityList< IfcFace > list;
};
/// Definition from ISO/CD 10303-42:1992: A face bound is a loop which is intended to be used for bounding a face.  
/// 
/// NOTE  Corresponding ISO 10303 entity: face_bound. Please refer to ISO/IS 10303-42:1994, p. 139 for the final definition of the formal standard.
/// 
/// HISTORY  New class in IFC Release 1.0
class IFC_PARSE_API IfcFaceBound : public IfcTopologicalRepresentationItem {
public:
    /// The loop which will be used as a face boundary.
    IfcLoop* Bound() const;
    void setBound(IfcLoop* v);
    /// This indicated whether (TRUE) or not (FALSE) the loop has the same sense when used to bound the face as when first defined. If sense is FALSE the senses of all its component oriented edges are implicitly reversed when used in the face.
    bool Orientation() const;
    void setOrientation(bool v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_BOOL; } return IfcTopologicalRepresentationItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcLoop; case 1: return Type::IfcBoolean; } return IfcTopologicalRepresentationItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Bound"; case 1: return "Orientation"; } return IfcTopologicalRepresentationItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcFaceBound (IfcEntityInstanceData* e);
    IfcFaceBound (IfcLoop* v1_Bound, bool v2_Orientation);
    typedef IfcTemplatedEntityList< IfcFaceBound > list;
};
/// Definition from ISO/CD 10303-42:1992: A face outer bound is a special subtype of face bound which carries the additional semantics of defining an outer boundary on the face. No more than one boundary of a face shall be of this type.  
/// 
/// NOTE Corresponding ISO 10303 entity: face_outer_bound. Please refer to ISO/IS 10303-42:1994, p. 139 for the final definition of the formal standard.
/// 
/// HISTORY New class in IFC Release 1.0
class IFC_PARSE_API IfcFaceOuterBound : public IfcFaceBound {
public:
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcFaceBound::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcFaceBound::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcFaceBound::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcFaceOuterBound (IfcEntityInstanceData* e);
    IfcFaceOuterBound (IfcLoop* v1_Bound, bool v2_Orientation);
    typedef IfcTemplatedEntityList< IfcFaceOuterBound > list;
};
/// Definition from ISO/CD 10303-42:1992: A face surface
///   (IfcFaceSurface) is a subtype of face in which the geometry is defined by an
///   associated surface. The portion of the surface used by the face shall be
///   embeddable in the plane as an open disk, possibly with holes. However, the
///   union of the face with the edges and vertices of its bounding loops need not be
///   embeddable in the plane. It may, for example, cover an entire sphere or torus.
///   As both a face and a geometric surface have defined normal directions, a
///   BOOLEAN flag (the orientation attribute) is used to indicate whether the
///   surface normal agrees with (TRUE) or is opposed to (FALSE) the face normal
///   direction. The geometry associated with any component of the loops of the face
///   shall be consistent with the surface geometry, in the sense that the domains of
///   all the vertex points and edge curves are contained in the face geometry
///   surface. A surface may be referenced by more than one face surface. 
/// 
/// NOTE  Corresponding ISO 10303 entity:
///   face_surface. Please refer to ISO/IS 10303-42:1994, p. 204 for the final
///   definition of the formal standard. Due to the general IFC model specification
///   rule not to use multiple inheritance, the subtype relationship to
///   geometric_representation_item is not included.
/// 
/// HISTORY  New class in IFC2x
/// 
/// Informal propositions: 
/// 
/// The domain of the face surface is formally defined to be the domain
///   of its face geometry as trimmed by the loops, this domain does not include the
///   bounding loops. 
///   A face surface has non zero finite extent. 
///   A face surface is a manifold. 
///   A face surface is arcwise connected. 
///   A face surface has surface genus 0.
///   The loops are not part of the face domain.
///   Loop geometry shall be consistent with face geometry. This implies
///   that any edge - curves or vertex points used in defining the loops bounding the
///   face surface shall lie on the face geometry.
///   The loops of the face shall not intersect.
class IFC_PARSE_API IfcFaceSurface : public IfcFace {
public:
    /// The surface which defines the internal shape of the face. This surface may be unbounded. The domain of the face is defined by this surface and the bounding loops in the inherited attribute SELF\FaceBounds.
    IfcSurface* FaceSurface() const;
    void setFaceSurface(IfcSurface* v);
    /// This flag indicates whether the sense of the surface normal agrees with (TRUE), or opposes (FALSE), the sense of the topological normal to the face.
    bool SameSense() const;
    void setSameSense(bool v);
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 1: return IfcUtil::Argument_ENTITY_INSTANCE; case 2: return IfcUtil::Argument_BOOL; } return IfcFace::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 1: return Type::IfcSurface; case 2: return Type::IfcBoolean; } return IfcFace::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 1: return "FaceSurface"; case 2: return "SameSense"; } return IfcFace::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcFaceSurface (IfcEntityInstanceData* e);
    IfcFaceSurface (IfcTemplatedEntityList< IfcFaceBound >::ptr v1_Bounds, IfcSurface* v2_FaceSurface, bool v3_SameSense);
    typedef IfcTemplatedEntityList< IfcFaceSurface > list;
};
/// Definition from IAI: Defines forces at which a support or connection fails.
/// 
/// Applicability:
/// 
/// Point supports and connections.
/// 
/// HISTORY: New entity in IFC 2x2.
class IFC_PARSE_API IfcFailureConnectionCondition : public IfcStructuralConnectionCondition {
public:
    /// Whether the optional attribute TensionFailureX is defined for this IfcFailureConnectionCondition
    bool hasTensionFailureX() const;
    /// Tension force in x-direction leading to failure of the connection.
    double TensionFailureX() const;
    void setTensionFailureX(double v);
    /// Whether the optional attribute TensionFailureY is defined for this IfcFailureConnectionCondition
    bool hasTensionFailureY() const;
    /// Tension force in y-direction leading to failure of the connection.
    double TensionFailureY() const;
    void setTensionFailureY(double v);
    /// Whether the optional attribute TensionFailureZ is defined for this IfcFailureConnectionCondition
    bool hasTensionFailureZ() const;
    /// Tension force in z-direction leading to failure of the connection.
    double TensionFailureZ() const;
    void setTensionFailureZ(double v);
    /// Whether the optional attribute CompressionFailureX is defined for this IfcFailureConnectionCondition
    bool hasCompressionFailureX() const;
    /// Compression force in x-direction leading to failure of the connection.
    double CompressionFailureX() const;
    void setCompressionFailureX(double v);
    /// Whether the optional attribute CompressionFailureY is defined for this IfcFailureConnectionCondition
    bool hasCompressionFailureY() const;
    /// Compression force in y-direction leading to failure of the connection.
    double CompressionFailureY() const;
    void setCompressionFailureY(double v);
    /// Whether the optional attribute CompressionFailureZ is defined for this IfcFailureConnectionCondition
    bool hasCompressionFailureZ() const;
    /// Compression force in z-direction leading to failure of the connection.
    double CompressionFailureZ() const;
    void setCompressionFailureZ(double v);
    virtual unsigned int getArgumentCount() const { return 7; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 1: return IfcUtil::Argument_DOUBLE; case 2: return IfcUtil::Argument_DOUBLE; case 3: return IfcUtil::Argument_DOUBLE; case 4: return IfcUtil::Argument_DOUBLE; case 5: return IfcUtil::Argument_DOUBLE; case 6: return IfcUtil::Argument_DOUBLE; } return IfcStructuralConnectionCondition::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 1: return Type::IfcForceMeasure; case 2: return Type::IfcForceMeasure; case 3: return Type::IfcForceMeasure; case 4: return Type::IfcForceMeasure; case 5: return Type::IfcForceMeasure; case 6: return Type::IfcForceMeasure; } return IfcStructuralConnectionCondition::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 1: return "TensionFailureX"; case 2: return "TensionFailureY"; case 3: return "TensionFailureZ"; case 4: return "CompressionFailureX"; case 5: return "CompressionFailureY"; case 6: return "CompressionFailureZ"; } return IfcStructuralConnectionCondition::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcFailureConnectionCondition (IfcEntityInstanceData* e);
    IfcFailureConnectionCondition (boost::optional< std::string > v1_Name, boost::optional< double > v2_TensionFailureX, boost::optional< double > v3_TensionFailureY, boost::optional< double > v4_TensionFailureZ, boost::optional< double > v5_CompressionFailureX, boost::optional< double > v6_CompressionFailureY, boost::optional< double > v7_CompressionFailureZ);
    typedef IfcTemplatedEntityList< IfcFailureConnectionCondition > list;
};
/// Definition from ISO/CD 10303-46:1992: The style for filling visible curve segments, annotation fill areas or surfaces with tiles or hatches.
/// 
/// An IfcFillAreaStyle provides the style table for presentation information assigned to annotation fill areas or surfaces for hatching and tiling. The IfcFillAreaStyle defines hatches as model hatches, that is, the distance between hatch lines, or the curve patterns of hatch lines are given in model space dimensions (that have to be scaled using the target plot scale). The IfcFillAreaStyle allows for the following combinations of defining the style of hatching and tiling:
/// 
/// Solid fill for areas and surfaces by only assigning IfcColour to the set of FillStyles. It then provides the background colour for the filled area or surface.
/// 
/// NOTE  Color information of surfaces for rendering is assigned by using IfcSurfaceStyle, not by using IfcFillAreaStyle.
/// 
/// Vector based hatching for areas and surfaces based on a single row of hatch lines by assigning a single instance of IfcFillAreaStyleHatching to the set of FillStyles.  If an instance of IfcColour is assigned in addition to the set of FillStyles, it provides the background colour for the hatching.  Vector based hatching for areas and surfaces based on two (potentially crossing) rows of hatch lines by assigning two instances of IfcFillAreaStyleHatching to the set of FillStyles. 
/// 
/// If an instance of IfcColour is assigned in addition to the set of FillStyles, it provides the background colour for the hatching. 
/// 
/// NOTE  Assigning more then two instances of IfcFillAreaStyleHatching to define three or more rows of hatch lines is not encouraged.
/// 
/// Tiling for areas and surfaces by assigning a single instance of IfcFillAreaStyleTiles to the set of FillStyles.  If an instance of IfcColour is assigned in addition to the set of FillStyles, it provides the background colour for the tiling. 
/// 
/// IFC2x3 NOTE  The use of IfcFillAreaStyleTiles is discouraged., as its definition might change is future releases.
/// 
/// Externally defined hatch style by assigning a single instance of IfcExternallyDefinedHatchStyle to the set of FillStyles. 
///   If an instance of IfcColour is assigned in addition to the set of FillStyles, it provides the background colour for the hatching.
/// 
/// Measures given to a hatch or tile pattern are given in global drawing length units.
/// 
/// NOTE  Global units are defined at the single IfcProject instance, given by UnitsInContext:IfcUnitAssignment, the same units are used for the geometric representation items and for the style definitions.
/// 
/// The measure values for hatch or tile pattern apply to the model space with a target plot scale provided for the correct appearance in the default plot scale. For different scale and projection dependent fill area styles a different instance of IfcFillAreaStyle needs to be used by IfcPresentationStyleAssignment for different IfcGeometricRepresentationSubContext dependent representations.
/// 
/// NOTE  the target plot scale is given by IfcGeometricRepresentationSubContext.TargetScale.
/// 
/// An IfcFillAreaStyle can be assigned to IfcFillArea via the IfcPresentationStyleAssignment through an intermediate IfcStyledItem or subtype IfcAnnotationFillAreaOccurrence.
/// 
/// NOTE  Corresponding ISO 10303 name: fill_area_style. Please refer to ISO/IS 10303-46:1994 for the final definition of the formal standard.
/// 
/// HISTORY  New entity in IFC2x2.
class IFC_PARSE_API IfcFillAreaStyle : public IfcPresentationStyle {
public:
    /// The set of fill area styles to use in presenting visible curve segments, annotation fill areas or surfaces.
    IfcEntityList::ptr FillStyles() const;
    void setFillStyles(IfcEntityList::ptr v);
    /// Whether the optional attribute ModelorDraughting is defined for this IfcFillAreaStyle
    bool hasModelorDraughting() const;
    bool ModelorDraughting() const;
    void setModelorDraughting(bool v);
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 1: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 2: return IfcUtil::Argument_BOOL; } return IfcPresentationStyle::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 1: return Type::IfcFillStyleSelect; case 2: return Type::IfcBoolean; } return IfcPresentationStyle::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 1: return "FillStyles"; case 2: return "ModelorDraughting"; } return IfcPresentationStyle::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcFillAreaStyle (IfcEntityInstanceData* e);
    IfcFillAreaStyle (boost::optional< std::string > v1_Name, IfcEntityList::ptr v2_FillStyles, boost::optional< bool > v3_ModelorDraughting);
    typedef IfcTemplatedEntityList< IfcFillAreaStyle > list;
};
/// Definition from ISO/CD 10303-42:1992: A geometric
/// representation context is a representation context in which the
/// geometric representation items are geometrically founded. A
/// geometric representation context is a distinct coordinate space,
/// spatially unrelated to other coordinate spaces.
/// 
/// IfcGeometricRepresentationContext defines the context that
/// applies to several shape representations of products within a
/// project. It defines the type of the context in which the shape
/// representation is defined, and the numeric precision applicable
/// to the geometric representation items defined in this context. In
/// addition it can be used to offset the project coordinate system
/// from a global point of origin, using the
/// WorldCoordinateSystem attribute.
/// 
/// As shown in Figure 329, the TrueNorth attribute should be provided if the y axis of the WorldCoordinateSystem does not point to the global northing. Direction of the true north, or geographic northing direction, relative to the underlying project coordinate
/// system as established by the attribute WorldCoordinateSystem. It is given by a 2 dimensional direction within the xy-plane of the project coordinate system. If not resent, it defaults to [0.,1.] - i.e. the positive Y axis of the project coordinate system equals the geographic northing direction. The direction is provided within project coordinate system and identifies the true north direction (see
/// figure).
/// 
/// Figure 329 — Geometric representation context true north
/// 
/// NOTE ÿThe inherited attribute
/// ContextType shall have one of the following recognized
/// values: 'Sketch', 'Outline', 'Design', 'Detail',
/// 'Model', 'Plan',
/// 'NotDefined'.
/// 
/// The use of one instance of
/// IfcGeometricRepresentationContext to represent the model
/// (3D) view is mandatory, the use of a second instance of
/// IfcGeometricRepresentationContext to represent the plan
/// (2D) view is optional (but needs to be given, if there are scale
/// dependent plan views), the additional scale or view dependent
/// contexts need to be handled by using the subtype
/// IfcGeometricRepresentationSubContext pointing to the model
/// view (or the plan view) as the ParentContext.
/// 
/// Figure 330 illustrates use of representation contexts defined at IfcProject for 3D model and 2D plan context, including sub
/// context definitions for different target scales.
/// 
/// Figure 330 — Geometric representation context use
/// 
/// NOTE  The definition of this class relates to the ISO 10303 entity geometric_representation_context. Please refer to ISO/IS 10303-42:1994 for the final definition of the formal standard.
/// 
/// HISTORY ÿNew Entity in IFC Release 2.0
/// 
/// IFC2x3 CHANGE ÿApplicable values for ContextType are only 'Model',ÿ 'Plan', andÿ'NotDefined'. All other sub contexts are now handled by the new subtype in IFC2x Edition 2 IfcGeometricRepresentationSubContext. Upward compatibility for file based exchange is guaranteed.
class IFC_PARSE_API IfcGeometricRepresentationContext : public IfcRepresentationContext {
public:
    /// The integer dimension count of the coordinate space modeled in a geometric representation context.
    int CoordinateSpaceDimension() const;
    void setCoordinateSpaceDimension(int v);
    /// Whether the optional attribute Precision is defined for this IfcGeometricRepresentationContext
    bool hasPrecision() const;
    /// Value of the model precision for geometric models. It is a double value (REAL), typically in 1E-5 to 1E-8 range, that indicates the tolerance under which two given points are still assumed to be identical. The value can be used e.g. to sets the maximum distance from an edge curve to the underlying face surface in brep models.
    double Precision() const;
    void setPrecision(double v);
    /// Establishment of the engineering coordinate system (often referred to as the world coordinate system in CAD) for all representation contexts used by the project. 
    /// 
    /// Note  it can be used to provide better numeric stability if the placement of the building(s) is far away from the origin. In most cases however it would be set to origin: (0.,0.,0.) and directions x(1.,0.,0.), y(0.,1.,0.), z(0.,0.,1.).
    IfcAxis2Placement* WorldCoordinateSystem() const;
    void setWorldCoordinateSystem(IfcAxis2Placement* v);
    /// Whether the optional attribute TrueNorth is defined for this IfcGeometricRepresentationContext
    bool hasTrueNorth() const;
    /// Direction of the true north, or geographic northing direction, relative to the underlying project coordinate system. It is given by a 2 dimensional direction within the xy-plane of the project coordinate system. If not resent, it defaults to 0. 1. - i.e. the positive Y axis of the project coordinate system equals the geographic northing direction.
    IfcDirection* TrueNorth() const;
    void setTrueNorth(IfcDirection* v);
    virtual unsigned int getArgumentCount() const { return 6; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 2: return IfcUtil::Argument_INT; case 3: return IfcUtil::Argument_DOUBLE; case 4: return IfcUtil::Argument_ENTITY_INSTANCE; case 5: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcRepresentationContext::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 2: return Type::IfcDimensionCount; case 3: return Type::IfcReal; case 4: return Type::IfcAxis2Placement; case 5: return Type::IfcDirection; } return IfcRepresentationContext::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 2: return "CoordinateSpaceDimension"; case 3: return "Precision"; case 4: return "WorldCoordinateSystem"; case 5: return "TrueNorth"; } return IfcRepresentationContext::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcGeometricRepresentationSubContext >::ptr HasSubContexts() const; // INVERSE IfcGeometricRepresentationSubContext::ParentContext
    IfcTemplatedEntityList< IfcCoordinateOperation >::ptr HasCoordinateOperation() const; // INVERSE IfcCoordinateOperation::SourceCRS
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcGeometricRepresentationContext (IfcEntityInstanceData* e);
    IfcGeometricRepresentationContext (boost::optional< std::string > v1_ContextIdentifier, boost::optional< std::string > v2_ContextType, int v3_CoordinateSpaceDimension, boost::optional< double > v4_Precision, IfcAxis2Placement* v5_WorldCoordinateSystem, IfcDirection* v6_TrueNorth);
    typedef IfcTemplatedEntityList< IfcGeometricRepresentationContext > list;
};
/// Definition from ISO/CD 10303-43:1992: An geometric representation item is a representation item that has the additional meaning of having geometric position or orientation or both. This meaning is present by virtue of:  
/// 
/// being a Cartesian point or a direction  
///   referencing directly a Cartesian point or direction  
///   referencing indirectly a Cartesian point or direction  
/// 
/// An indirect reference to a Cartesian point or direction means that a given geometric item references the Cartesian point or direction through one or more intervening geometry or topology items.  
/// 
/// EXAMPLE: Consider a circle. It gains its geometric position and orientation by virtue of a reference to axis2_placement (IfcAxis2Placement) that is turn references a cartesian_point (IfcCartesianPoint) and several directions (IfcDirection). 
/// 
/// EXAMPLE: Consider a manifold brep. A manifold_solid_brep (IfcManifoldSolidBrep) is a geometric_representation_item (IfcGeometricRepresentationItem) that through several layers of topological_representation_item's (IfcTopologicalRepresentationItem) references poly loops (IfcPolyLoop). Through additional intervening entities poly loops reference cartesian_point's (IfcCartesianPoint).
/// 
/// The derivation of the dimensionality of the IfcGeometricRepresentationItem is different to ISO 10303; there is a specific derived attribute at each class that defines the dimensionality, whereas ISO 10303 does it for the representation_context and requires all geometric_representation_item's to have the same dimensionality therein.  
/// 
/// The definition of swept area solids as geometric representation items is different to ISO 10303; it is based on a set of predefined profiles (or cross sections), that is, a set of parameterized geometric primitives widely supported in the industry. Those profiles are used to create volumes through extrusion, revolution and cross section based sweep operations.
/// 
/// NOTE: Corresponding ISO 10303 entity: geometric_representation_item. Please refer to ISO/IS 10303-42:1994, p. 22 for the final definition of the formal standard. The following changes have been made: It does not inherit from ISO/IS 10303-43:1994 entity representation_item. The derived attribute Dim is demoted to the appropriate subtypes. The WR1 has not been incorporated. Not all subtypes that are in ISO/IS 10303-42:1994 have been added to the current IFC Release.
/// 
/// HISTORY: New entity in IFC Release 1.5
class IFC_PARSE_API IfcGeometricRepresentationItem : public IfcRepresentationItem {
public:
    virtual unsigned int getArgumentCount() const { return 0; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcRepresentationItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcRepresentationItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcRepresentationItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcGeometricRepresentationItem (IfcEntityInstanceData* e);
    IfcGeometricRepresentationItem ();
    typedef IfcTemplatedEntityList< IfcGeometricRepresentationItem > list;
};
/// IfcGeometricRepresentationSubContext defines the context that applies to several shape representations of a product being a sub context, sharing the WorldCoordinateSystem, CoordinateSpaceDimension, Precision and TrueNorth attributes with the parent IfcGeometricRepresentationContext.
/// 
/// The IfcGeometricRepresentationSubContext is used to define semantically distinguished representation types for different information content, dependent on the representation view and the target scale. It can be used to control the level of detail of the shape representation that is most applicable to this geometric representation context. addition the sub context is used to control the later appearance of the IfcShapeRepresentation within a plot view.
/// 
/// NOTE  If the IfcShapeRepresentation using this sub context has IfcStyledItem's assigned to the Items, the presentation style information (e.g. IfcCurveStyle, IfcTextStyle) associated with the IfcStyledItem is given in target plot dimensions. For example, a line thickness (IfcCurveStyle.CurveWidth) is given by a thickness measure relating to the thickness for a plot within the (range of) target scale.
/// 
/// Each IfcProduct can then have several instances of subtypes of IfcRepresentation, each being assigned to a different geometric representation context (IfcGeometricRepresentationContext or IfcGeometricRepresentationSubContext). The application can then choose the most appropriate representation for showing the geometric shape of the product, depending on the target view and scale.
/// 
/// NOTE  The provision of a model view (IfcGeometricRepresentationContext.ContextType = 'Model') is mandatory. Instances of IfcGeometricRepresentationSubContext relate to it as its ParentContext.
/// 
/// EXAMPLE  Instances of IfcGeometricRepresentationSubContext can be used to handle the multi-view blocks or macros, which are used in CAD programs to store several scale and/or view dependent geometric representations of the same object.
/// 
/// HISTORY  New entity in Release IFC 2x2.
class IFC_PARSE_API IfcGeometricRepresentationSubContext : public IfcGeometricRepresentationContext {
public:
    /// Parent context from which the sub context derives its world coordinate system, precision, space coordinate dimension and true north.
    IfcGeometricRepresentationContext* ParentContext() const;
    void setParentContext(IfcGeometricRepresentationContext* v);
    /// Whether the optional attribute TargetScale is defined for this IfcGeometricRepresentationSubContext
    bool hasTargetScale() const;
    /// The target plot scale of the representation 
    /// to which this representation context applies.
    ///   Scale indicates the target plot scale for
    /// the representation sub context, all annotation styles are given in plot
    /// dimensions according to this target plot scale.
    /// If multiple instances of IfcGeometricRepresentationSubContext
    /// are given having the same TargetView value, the target plot scale 
    /// applies up to the next smaller scale, or up to unlimited small scale.
    /// 
    /// Note: Scale 1:100 (given as 0.01 within TargetScale)
    /// is bigger then 1:200 (given as 0.005 within TargetScale).
    double TargetScale() const;
    void setTargetScale(double v);
    /// Target view of the representation to which this representation context applies.
    IfcGeometricProjectionEnum::IfcGeometricProjectionEnum TargetView() const;
    void setTargetView(IfcGeometricProjectionEnum::IfcGeometricProjectionEnum v);
    /// Whether the optional attribute UserDefinedTargetView is defined for this IfcGeometricRepresentationSubContext
    bool hasUserDefinedTargetView() const;
    /// User defined target view, this attribute value shall be given, if the TargetView attribute is set to USERDEFINED.
    std::string UserDefinedTargetView() const;
    void setUserDefinedTargetView(std::string v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 2: return IfcUtil::Argument_DERIVED; case 3: return IfcUtil::Argument_DERIVED; case 4: return IfcUtil::Argument_DERIVED; case 5: return IfcUtil::Argument_DERIVED; case 6: return IfcUtil::Argument_ENTITY_INSTANCE; case 7: return IfcUtil::Argument_DOUBLE; case 8: return IfcUtil::Argument_ENUMERATION; case 9: return IfcUtil::Argument_STRING; } return IfcGeometricRepresentationContext::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 6: return Type::IfcGeometricRepresentationContext; case 7: return Type::IfcPositiveRatioMeasure; case 8: return Type::IfcGeometricProjectionEnum; case 9: return Type::IfcLabel; } return IfcGeometricRepresentationContext::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 6: return "ParentContext"; case 7: return "TargetScale"; case 8: return "TargetView"; case 9: return "UserDefinedTargetView"; } return IfcGeometricRepresentationContext::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcGeometricRepresentationSubContext (IfcEntityInstanceData* e);
    IfcGeometricRepresentationSubContext (boost::optional< std::string > v1_ContextIdentifier, boost::optional< std::string > v2_ContextType, IfcGeometricRepresentationContext* v7_ParentContext, boost::optional< double > v8_TargetScale, IfcGeometricProjectionEnum::IfcGeometricProjectionEnum v9_TargetView, boost::optional< std::string > v10_UserDefinedTargetView);
    typedef IfcTemplatedEntityList< IfcGeometricRepresentationSubContext > list;
};
/// Definition from ISO/CD 10303-42:1992: This entity is intended for the transfer of models when a topological structure is not available. 
/// 
/// The IfcGeometricSet is used for the exchange of shape representations consisting of (2D or 3D) points, curves, and/or surfaces, which do not have a topological structure (such as connected face sets or shells) and are not solid models (such as swept solids, CSG or Brep) 
/// 
/// NOTE: Corresponding ISO 10303-42 entity: geometric_set. The derived attribute Dim has been added at this level and was therefore demoted from the geometric_representation_item. Please refer to ISO/IS 10303-42:1994, p. 190 for the final definition of the formal standard.
/// 
/// HISTORY: New entity in IFC Release 2x.
class IFC_PARSE_API IfcGeometricSet : public IfcGeometricRepresentationItem {
public:
    /// The geometric elements which make up the geometric set, these may be points, curves or surfaces; but are required to be of the same coordinate space dimensionality.
    IfcEntityList::ptr Elements() const;
    void setElements(IfcEntityList::ptr v);
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } return IfcGeometricRepresentationItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcGeometricSetSelect; } return IfcGeometricRepresentationItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Elements"; } return IfcGeometricRepresentationItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcGeometricSet (IfcEntityInstanceData* e);
    IfcGeometricSet (IfcEntityList::ptr v1_Elements);
    typedef IfcTemplatedEntityList< IfcGeometricSet > list;
};
/// IfcGridPlacement provides a specialization of IfcObjectPlacement in which
/// the placement and axis direction of the object coordinate system is defined by a reference to the design grid as defined in IfcGrid.
/// The location of the object coordinate system is given by the attribute PlacementLocation. It is defined as an
/// IfcVirtualGridIntersection, that is, an intersection between two grid axes with optional offsets.
/// The axis direction of the x-axis of the object coordinate
/// system is given either:
/// 
/// PlacementRefDirection = NIL: by the tangent of the first grid axis (PlacementLocation.IntersectingAxes[1]) at the virtual intersection (maybe using the offset curve, if PlacementLocation.OffsetDistances is given);
/// PlacementRefDirection = IfcDirection: by the explicitly provided direction information;
/// PlacementRefDirection = IfcVirtualGridIntersection: by the tangent between the virtual grid intersection of PlacementLocation and the virtual grid intersection of PlacementRefDirection. Offsets as potentially provided in the IfcVirtualGridIntersection's of PlacementLocation and PlacementRefDirection have to be taken into account.
/// 
/// The direction of the y-axis of the IfcGridPlacement is the orthogonal complement to the x-axis. The plane defined by the x and y axis shall be co-planar to the xy plane of the local placement of the IfcGrid.ÿ 
/// The direction of the z-axis is the orientation of the cross product of the x-axis and the y-axis, i.e. the z-axis of the IfcGridPlacement shall be co-linear to the z-axis of the local placement of the IfcGrid.
/// 
/// NOTE The IfcGrid local placement, that can be provided relative to the local placement of another spatial structure element, has to be taken into account for calculating the absolute placement of the virtual grid intersection.
/// 
/// NOTE The PlacementLocation.OffsetDistances[3] and the PlacementRefDirection.OffsetDistances[3] shall either not be assigned or should have the same z offset value.
/// 
/// HISTORY ÿNew entity in IFC Release 1.5. The entity name was changed from IfcConstrainedPlacement in IFC Release 2x.
/// 
/// IFC2x4 CHANGE Attribute data type of PlacementRefDirection has been changed to IfcGridPlacementDirectionSelect.
/// 
/// Geometry use definitions
/// The following examples show the usage of placement location and direction for an IfcGridPlacement.
/// 
/// Figure 243 illustrates the case where PlacementRefDirection is not given - the object coordinate system is defined by:
/// 
/// its location: given by the virtual grid intersection of PlacementLocation
/// its x-axis direction: given by the tangent of the first intersecting axis in the offset location of the virtual grid intersection
/// 
/// Figure 243 — Grid placement
/// 
/// Figure 244 illustrates the case where PlacementRefDirection is given as an IfcDirection- the object coordinate system is defined by:
/// 
/// its location: given by the virtual grid intersection of PlacementLocation
/// its x-axis direction: given by the DirectionRatios of the IfcDirection, only the ratios for x and y are taken into account,
/// 
/// Figure 244 — Grid placement with direction
/// 
/// Figure 245 illustrates the case where PlacementRefDirection is given as an IfcVirtualGridIntersection- the object coordinate system is defined by:
/// 
/// its location: given by the virtual grid intersection of PlacementLocation
/// its x-axis direction: given by the tangent of the line between the virtual grid intersection of the PlacementLocation and the virtual grid intersection of the PlacementRefDirection.
/// 
/// Figure 245 — Grid placement with intersection
class IFC_PARSE_API IfcGridPlacement : public IfcObjectPlacement {
public:
    /// Placement of the object coordinate system defined by the intersection of two grid axes.
    IfcVirtualGridIntersection* PlacementLocation() const;
    void setPlacementLocation(IfcVirtualGridIntersection* v);
    /// Whether the optional attribute PlacementRefDirection is defined for this IfcGridPlacement
    bool hasPlacementRefDirection() const;
    /// Reference to either an explicit direction, or a second grid axis intersection, which defines the orientation of the grid placement.
    /// 
    /// IFC2x4 CHANGE  The select of an explict direction has been added.
    IfcGridPlacementDirectionSelect* PlacementRefDirection() const;
    void setPlacementRefDirection(IfcGridPlacementDirectionSelect* v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcObjectPlacement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcVirtualGridIntersection; case 1: return Type::IfcGridPlacementDirectionSelect; } return IfcObjectPlacement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "PlacementLocation"; case 1: return "PlacementRefDirection"; } return IfcObjectPlacement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcGridPlacement (IfcEntityInstanceData* e);
    IfcGridPlacement (IfcVirtualGridIntersection* v1_PlacementLocation, IfcGridPlacementDirectionSelect* v2_PlacementRefDirection);
    typedef IfcTemplatedEntityList< IfcGridPlacement > list;
};
/// Definition from ISO/CD 10303-42:1992: A half space solid is defined by the half space which is the regular subset of the domain which lies on one side of an unbounded surface. The side of the surface which is in the half space is determined by the surface normal and the agreement flag. If the agreement flag is TRUE, then the subset is the one the normal points away from. If the agreement flag is FALSE, then the subset is the one the normal points into. For a valid half space solid the surface shall divide the domain into exactly two subsets. Also, within the domain the surface shall be manifold and all surface normals shall point into the same subset.  
/// 
/// NOTE A half space is not a subtype of solid model (IfcSolidModel), half space solids are only useful as operands in Boolean expressions.
/// 
/// NOTE Corresponding STEP entity: half_space_solid. Please refer to ISO/IS 10303-42:1994, p. 185 for the final definition of the formal standard. The derived attribute Dim has been added at this level and was therefore demoted from the geometric_representation_item.
/// 
/// HISTORY New class in IFC Release 1.5
/// 
/// Informal propositions: 
/// 
/// The base surface shall divide the domain into exactly two subsets. If the half space solid is of subtype boxed half space (IfcBoxedHalfSpace), the domain in question is that of the attribute enclosure. In all other cases the domain is all of space and the base surface shall be unbounded.  The base surface shall be an unbounded surface (subtype of IfcElementarySurface). 
/// 
/// Figure 258 illustrates the definition of the IfcHalfSpaceSolid within a given coordinate system. The base surface is given by an unbounded plane, the red boundary is shown for visualization purposes only. 
/// 
/// Figure 258 — Half space solid geometry
class IFC_PARSE_API IfcHalfSpaceSolid : public IfcGeometricRepresentationItem {
public:
    /// Surface defining side of half space.
    IfcSurface* BaseSurface() const;
    void setBaseSurface(IfcSurface* v);
    /// The agreement flag is TRUE if the normal to the BaseSurface points away from the material of the IfcHalfSpaceSolid. Otherwise it is FALSE.
    bool AgreementFlag() const;
    void setAgreementFlag(bool v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_BOOL; } return IfcGeometricRepresentationItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcSurface; case 1: return Type::IfcBoolean; } return IfcGeometricRepresentationItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "BaseSurface"; case 1: return "AgreementFlag"; } return IfcGeometricRepresentationItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcHalfSpaceSolid (IfcEntityInstanceData* e);
    IfcHalfSpaceSolid (IfcSurface* v1_BaseSurface, bool v2_AgreementFlag);
    typedef IfcTemplatedEntityList< IfcHalfSpaceSolid > list;
};
/// An IfcImageTexture provides a 2-dimensional texture that can be applied to a surface of an geometric item and that provides lighting parameters of a surface onto which it is mapped. The texture is provided as an image file at an external location for which an URL is provided.
/// 
/// The following definitions from ISO/IEC 19775-1 X3D Architecture and base components (X3D Specification) apply:
/// 
/// The ImageTexture node defines a texture map by specifying an image file and general parameters for mapping to geometry. 
/// The texture is read from the URL specified by the url field. When the url field contains no [resolvable] values, texturing is disabled. Browsers shall support the JPEG and PNG (see ISO/IEC 15948) image file formats.
/// Texture nodes that require support for the PNG image format shall interpret the PNG pixel formats in the following way:
/// 
/// Greyscale pixels without alpha or simple transparency are treated as intensity textures.
/// >Greyscale pixels with alpha or simple transparency are treated as intensity plus alpha textures.
/// RGB pixels without alpha channel or simple transparency are treated as full RGB textures.
/// RGB pixels with alpha channel or simple transparency are treated as full RGB plus alpha textures.
/// 
/// If the image specifies colours as indexed-colour (that is, palettes or colourmaps), the following semantics should be used (note that `greyscale' refers to a palette entry with equal red, green, and blue values):
/// 
/// If all the colours in the palette are greyscale and there is no transparency chunk, it is treated as an intensity texture.
/// If all the colours in the palette are greyscale and there is a transparency chunk, it is treated as an intensity plus opacity texture.
/// >If any colour in the palette is not grey and there is no transparency chunk, it is treated as a full RGB texture.
/// If any colour in the palette is not grey and there is a transparency chunk, it is treated as a full RGB plus alpha texture.
/// 
/// Texture nodes that require support for JPEG files shall interpret JPEG files as follows:
/// 
/// Greyscale files (number of components equals 1) are treated as intensity textures.
/// YCbCr files are treated as full RGB textures.
/// No other JPEG file types are required. It is recommended that other JPEG files are treated as a full RGB textures.
/// 
/// Texture nodes that recommend support for GIF files shall follow the applicable semantics described above for the PNG format.
/// 
/// The Uniform Resource Locator (URL) is a form of an URI and specified in RFC1738 by IETF. It supports resources located on a particular server being accessed by a particular protocol (usually http), and resources located at a local machine.
/// 
/// NOTE  Exchange files following the ifcZIP convention may include a sub directory structure for image resources to be stored together with the product data set.
/// 
/// NOTE  The definitions of texturing within this standard have been developed in dependence on the texture component of X3D. See ISO/IEC 19775-1.2:2008 X3D Architecture and base components Edition 2, Part 1, 18 Texturing component for the definitions in the international standard.
/// 
/// HISTORY  New entity in Release IFC2x2.
class IFC_PARSE_API IfcImageTexture : public IfcSurfaceTexture {
public:
    /// Location, provided as an URI, at which the image texture is electronically published.
    std::string URLReference() const;
    void setURLReference(std::string v);
    virtual unsigned int getArgumentCount() const { return 6; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 5: return IfcUtil::Argument_STRING; } return IfcSurfaceTexture::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 5: return Type::IfcURIReference; } return IfcSurfaceTexture::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 5: return "URLReference"; } return IfcSurfaceTexture::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcImageTexture (IfcEntityInstanceData* e);
    IfcImageTexture (bool v1_RepeatS, bool v2_RepeatT, boost::optional< std::string > v3_Mode, IfcCartesianTransformationOperator2D* v4_TextureTransform, boost::optional< std::vector< std::string > /*[1:?]*/ > v5_Parameter, std::string v6_URLReference);
    typedef IfcTemplatedEntityList< IfcImageTexture > list;
};

class IFC_PARSE_API IfcIndexedColourMap : public IfcPresentationItem {
public:
    IfcTessellatedFaceSet* MappedTo() const;
    void setMappedTo(IfcTessellatedFaceSet* v);
    /// Whether the optional attribute Opacity is defined for this IfcIndexedColourMap
    bool hasOpacity() const;
    double Opacity() const;
    void setOpacity(double v);
    IfcColourRgbList* Colours() const;
    void setColours(IfcColourRgbList* v);
    std::vector< int > /*[1:?]*/ ColourIndex() const;
    void setColourIndex(std::vector< int > /*[1:?]*/ v);
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_DOUBLE; case 2: return IfcUtil::Argument_ENTITY_INSTANCE; case 3: return IfcUtil::Argument_AGGREGATE_OF_INT; } return IfcPresentationItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcTessellatedFaceSet; case 1: return Type::IfcNormalisedRatioMeasure; case 2: return Type::IfcColourRgbList; case 3: return Type::IfcPositiveInteger; } return IfcPresentationItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "MappedTo"; case 1: return "Opacity"; case 2: return "Colours"; case 3: return "ColourIndex"; } return IfcPresentationItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcIndexedColourMap (IfcEntityInstanceData* e);
    IfcIndexedColourMap (IfcTessellatedFaceSet* v1_MappedTo, boost::optional< double > v2_Opacity, IfcColourRgbList* v3_Colours, std::vector< int > /*[1:?]*/ v4_ColourIndex);
    typedef IfcTemplatedEntityList< IfcIndexedColourMap > list;
};

class IFC_PARSE_API IfcIndexedTextureMap : public IfcTextureCoordinate {
public:
    IfcTessellatedFaceSet* MappedTo() const;
    void setMappedTo(IfcTessellatedFaceSet* v);
    IfcTextureVertexList* TexCoords() const;
    void setTexCoords(IfcTextureVertexList* v);
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 1: return IfcUtil::Argument_ENTITY_INSTANCE; case 2: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcTextureCoordinate::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 1: return Type::IfcTessellatedFaceSet; case 2: return Type::IfcTextureVertexList; } return IfcTextureCoordinate::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 1: return "MappedTo"; case 2: return "TexCoords"; } return IfcTextureCoordinate::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcIndexedTextureMap (IfcEntityInstanceData* e);
    IfcIndexedTextureMap (IfcTemplatedEntityList< IfcSurfaceTexture >::ptr v1_Maps, IfcTessellatedFaceSet* v2_MappedTo, IfcTextureVertexList* v3_TexCoords);
    typedef IfcTemplatedEntityList< IfcIndexedTextureMap > list;
};

class IFC_PARSE_API IfcIndexedTriangleTextureMap : public IfcIndexedTextureMap {
public:
    /// Whether the optional attribute TexCoordIndex is defined for this IfcIndexedTriangleTextureMap
    bool hasTexCoordIndex() const;
    std::vector< std::vector< int > > TexCoordIndex() const;
    void setTexCoordIndex(std::vector< std::vector< int > > v);
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 3: return IfcUtil::Argument_AGGREGATE_OF_AGGREGATE_OF_INT; } return IfcIndexedTextureMap::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 3: return Type::IfcPositiveInteger; } return IfcIndexedTextureMap::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 3: return "TexCoordIndex"; } return IfcIndexedTextureMap::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcIndexedTriangleTextureMap (IfcEntityInstanceData* e);
    IfcIndexedTriangleTextureMap (IfcTemplatedEntityList< IfcSurfaceTexture >::ptr v1_Maps, IfcTessellatedFaceSet* v2_MappedTo, IfcTextureVertexList* v3_TexCoords, boost::optional< std::vector< std::vector< int > > > v4_TexCoordIndex);
    typedef IfcTemplatedEntityList< IfcIndexedTriangleTextureMap > list;
};
/// In an irregular time series, unpredictable bursts of data arrive at unspecified points in time, or most time stamps cannot be characterized by a repeating pattern.
/// 
/// EXAMPLE: A circulating pump cycles on and off at unpredictable times as dictated by the demands on the piping system; the amount of light in a classroom varies depending on when the lights are manually switched on and off and and how many lamps are controlled by each switch.
/// 
/// HISTORY: New entity in IFC 2x2.
class IFC_PARSE_API IfcIrregularTimeSeries : public IfcTimeSeries {
public:
    /// The collection of time series values.
    IfcTemplatedEntityList< IfcIrregularTimeSeriesValue >::ptr Values() const;
    void setValues(IfcTemplatedEntityList< IfcIrregularTimeSeriesValue >::ptr v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } return IfcTimeSeries::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcIrregularTimeSeriesValue; } return IfcTimeSeries::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "Values"; } return IfcTimeSeries::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcIrregularTimeSeries (IfcEntityInstanceData* e);
    IfcIrregularTimeSeries (std::string v1_Name, boost::optional< std::string > v2_Description, std::string v3_StartTime, std::string v4_EndTime, IfcTimeSeriesDataTypeEnum::IfcTimeSeriesDataTypeEnum v5_TimeSeriesDataType, IfcDataOriginEnum::IfcDataOriginEnum v6_DataOrigin, boost::optional< std::string > v7_UserDefinedDataOrigin, IfcUnit* v8_Unit, IfcTemplatedEntityList< IfcIrregularTimeSeriesValue >::ptr v9_Values);
    typedef IfcTemplatedEntityList< IfcIrregularTimeSeries > list;
};
/// IfcLagTime describes the time parameters that may exist within a sequence relationship between two processes.
/// 
/// HISTORY: New entity in IFC Release 2x4.
/// 
/// Use Definitions
/// 
/// An IfcLagTime provides information about the
///   time lag that exists between the predecessor and successor
///   process in a sequence. The assertion of the time lag is
///   optional for a sequence but for work schedules that
///   specifically deal with processes occurring at particular
///   times, it should be asserted.
/// 
/// A lag time has a duration type. This allows the
///   identification of whether elapsed time or work time is
///   being measured (where work time is the estimate of the time
///   required to complete the process and elapsed time being the
///   amount of time actually allocated to the process)
/// 
/// The form of measurement of the duration can be captured.
///   Allowed values for this are MEASURED, PREDICTED or
///   SIMULATED. The selection of this value depends on the use
///   of the schedule. A NOTDEFINED value is also allowed.
/// 
/// The value of the time lag may be selected as being either a
///   percentage ratio or an actual time measure. If selected as
///   a ratio, the percentage should apply to the duration of the
///   predecessor process (relating process) such that e.g. a
///   value of 0.5 (50%) would indicate that the successor task
///   should start when the predecessor task is 50% complete (if
///   a START-START sequence type is used) or should wait for 50%
///   of the duration of the predecessor process to have elapsed
///   after the finish of the predecessor process in case of a
///   FINISH-START sequence type.
/// 
/// The time unit for the task duration may also be set and
///   this may be set to any allowed unit of time measure.
class IFC_PARSE_API IfcLagTime : public IfcSchedulingTime {
public:
    /// Value of the time lag selected as being either a ratio or a
    ///   time measure.
    IfcTimeOrRatioSelect* LagValue() const;
    void setLagValue(IfcTimeOrRatioSelect* v);
    /// The allowed types of task duration that specify the lag time
    ///   measurement (work time or elapsed time).
    IfcTaskDurationEnum::IfcTaskDurationEnum DurationType() const;
    void setDurationType(IfcTaskDurationEnum::IfcTaskDurationEnum v);
    virtual unsigned int getArgumentCount() const { return 5; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 3: return IfcUtil::Argument_ENTITY_INSTANCE; case 4: return IfcUtil::Argument_ENUMERATION; } return IfcSchedulingTime::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 3: return Type::IfcTimeOrRatioSelect; case 4: return Type::IfcTaskDurationEnum; } return IfcSchedulingTime::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 3: return "LagValue"; case 4: return "DurationType"; } return IfcSchedulingTime::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcLagTime (IfcEntityInstanceData* e);
    IfcLagTime (boost::optional< std::string > v1_Name, boost::optional< IfcDataOriginEnum::IfcDataOriginEnum > v2_DataOrigin, boost::optional< std::string > v3_UserDefinedDataOrigin, IfcTimeOrRatioSelect* v4_LagValue, IfcTaskDurationEnum::IfcTaskDurationEnum v5_DurationType);
    typedef IfcTemplatedEntityList< IfcLagTime > list;
};
/// Definition from ISO/CD 10303-46:1992: The light source entity is determined by the reflectance specified in the surface style rendering. Lighting is applied on a surface by surface basis: no interactions between surfaces such as shadows or reflections are defined. 
/// 
/// NOTE: Corresponding STEP entity: light_source. Please refer to ISO/IS 10303-46:1994, p. 31 for the final definition of the formal standard. 
/// 
/// NOTE: In addition to the attributes as defined in ISO10303-46 the following additional properties from ISO/IEC 14772-1:1997 (VRML) are added: ambientIntensity and Intensity. The attribute Name has been added as well (as it is not inherited via representation_item).
/// 
/// HISTORY: This is a new Entity in IFC 2x, renamed and enhanced in IFC2x2.
class IFC_PARSE_API IfcLightSource : public IfcGeometricRepresentationItem {
public:
    /// Whether the optional attribute Name is defined for this IfcLightSource
    bool hasName() const;
    /// The name given to the light source in presentation.
    std::string Name() const;
    void setName(std::string v);
    /// Definition from ISO/CD 10303-46:1992: Based on the current lighting model, the colour of the light to be used for shading.
    /// Definition from VRML97 - ISO/IEC 14772-1:1997: The color field specifies the spectral color properties of both the direct and ambient light emission as an RGB value.
    IfcColourRgb* LightColour() const;
    void setLightColour(IfcColourRgb* v);
    /// Whether the optional attribute AmbientIntensity is defined for this IfcLightSource
    bool hasAmbientIntensity() const;
    /// Definition from VRML97 - ISO/IEC 14772-1:1997: The ambientIntensity specifies the intensity of the ambient emission from the light. Light intensity may range from 0.0 (no light emission) to 1.0 (full intensity).
    double AmbientIntensity() const;
    void setAmbientIntensity(double v);
    /// Whether the optional attribute Intensity is defined for this IfcLightSource
    bool hasIntensity() const;
    /// Definition from VRML97 - ISO/IEC 14772-1:1997: The intensity field specifies the brightness of the direct emission from the ligth. Light intensity may range from 0.0 (no light emission) to 1.0 (full intensity).
    double Intensity() const;
    void setIntensity(double v);
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_STRING; case 1: return IfcUtil::Argument_ENTITY_INSTANCE; case 2: return IfcUtil::Argument_DOUBLE; case 3: return IfcUtil::Argument_DOUBLE; } return IfcGeometricRepresentationItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcLabel; case 1: return Type::IfcColourRgb; case 2: return Type::IfcNormalisedRatioMeasure; case 3: return Type::IfcNormalisedRatioMeasure; } return IfcGeometricRepresentationItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Name"; case 1: return "LightColour"; case 2: return "AmbientIntensity"; case 3: return "Intensity"; } return IfcGeometricRepresentationItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcLightSource (IfcEntityInstanceData* e);
    IfcLightSource (boost::optional< std::string > v1_Name, IfcColourRgb* v2_LightColour, boost::optional< double > v3_AmbientIntensity, boost::optional< double > v4_Intensity);
    typedef IfcTemplatedEntityList< IfcLightSource > list;
};
/// Definition from ISO/CD 10303-46:1992: The light source ambient entity is a subtype of light source. It lights a surface independent of the surface's orientation and position. 
/// 
/// NOTE: Corresponding ISO 10303 entity: light_source_ambient. Please refer to ISO/IS 10303-46:1994, p. 31 for the final definition of the formal standard.
/// 
/// NOTE: In addition to the attributes as defined in ISO 10303-46 the additional property from ISO/IEC 14772-1:1997 (VRML) AmbientIntensity is inherited from the supertype.
/// 
/// HISTORY: This is a new entity in IFC 2x, renamed and enhanced in IFC2x2.
class IFC_PARSE_API IfcLightSourceAmbient : public IfcLightSource {
public:
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcLightSource::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcLightSource::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcLightSource::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcLightSourceAmbient (IfcEntityInstanceData* e);
    IfcLightSourceAmbient (boost::optional< std::string > v1_Name, IfcColourRgb* v2_LightColour, boost::optional< double > v3_AmbientIntensity, boost::optional< double > v4_Intensity);
    typedef IfcTemplatedEntityList< IfcLightSourceAmbient > list;
};
/// Definition from ISO/CD 10303-46:1992: The light source directional is a subtype of light source. This entity has a light source direction. With a conceptual origin at infinity, all the rays of the light are parallel to this direction. This kind of light source lights a surface based on the surface's orientation, but not position. 
/// 
/// Definition from ISO/IEC 14772-1:1997: The directional light node defines a directional light source that illuminates along rays parallel to a given 3-dimensional vector. Directional light nodes do not attenuate with distance. Directional light nodes are specified in the local coordinate system and are affected by ancestor transformations. 
/// 
/// NOTE: Corresponding ISO 10303 entity: light_source_directional. Please refer to ISO/IS 10303-46:1994, p. 32 for the final definition of the formal standard.
/// 
/// NOTE: In addition to the attributes as defined in ISO 10303-46 the additional property from ISO/IEC 14772-1:1997 (VRML) AmbientIntensity and Intensity are inherited from the supertype.
/// 
/// HISTORY: This is a new entity in IFC 2x, renamed and enhanced in IFC2x2.
class IFC_PARSE_API IfcLightSourceDirectional : public IfcLightSource {
public:
    /// Definition from ISO/CD 10303-46:1992: This direction is the direction of the light source.
    /// Definition from VRML97 - ISO/IEC 14772-1:1997: The direction field specifies the direction vector of the illumination emanating from the light source in the local coordinate system. Light is emitted along parallel rays from an infinite distance away.
    IfcDirection* Orientation() const;
    void setOrientation(IfcDirection* v);
    virtual unsigned int getArgumentCount() const { return 5; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 4: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcLightSource::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 4: return Type::IfcDirection; } return IfcLightSource::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 4: return "Orientation"; } return IfcLightSource::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcLightSourceDirectional (IfcEntityInstanceData* e);
    IfcLightSourceDirectional (boost::optional< std::string > v1_Name, IfcColourRgb* v2_LightColour, boost::optional< double > v3_AmbientIntensity, boost::optional< double > v4_Intensity, IfcDirection* v5_Orientation);
    typedef IfcTemplatedEntityList< IfcLightSourceDirectional > list;
};
/// IfcLightSourceGoniometric defines a light source for which exact lighting data is available. It specifies the type of a light emitter, defines the position and orientation of a light distribution curve and the data concerning lamp and photometric information. 
/// 
/// Figure 303 shows an example of a light emitter having two light sources (of type IfcLightSourceGoniometric). 
/// 
/// Figure 303 — Light source goniometric
/// 
/// HISTORY: New entity in IFC2x2.
class IFC_PARSE_API IfcLightSourceGoniometric : public IfcLightSource {
public:
    /// The position of the light source. It is used to orientate the light distribution curves.
    IfcAxis2Placement3D* Position() const;
    void setPosition(IfcAxis2Placement3D* v);
    /// Whether the optional attribute ColourAppearance is defined for this IfcLightSourceGoniometric
    bool hasColourAppearance() const;
    /// Artificial light sources are classified in terms of their color appearance. To the human eye they all appear to be white; the difference can only be detected by direct comparison. Visual performance is not directly affected by differences in color appearance.
    IfcColourRgb* ColourAppearance() const;
    void setColourAppearance(IfcColourRgb* v);
    /// The color temperature of any source of radiation is defined as the temperature (in Kelvin) of a black-body or Planckian radiator whose radiation has the same chromaticity as the source of radiation. Often the values are only approximate color temperatures as the black-body radiator cannot emit radiation of every chromaticity value. The color temperatures of the commonest artificial light sources range from less than 3000K (warm white) to 4000K (intermediate) and over 5000K (daylight).
    double ColourTemperature() const;
    void setColourTemperature(double v);
    /// Luminous flux is a photometric measure of radiant flux, i.e. the volume of light emitted from a light source. Luminous flux is measured either for the interior as a whole or for a part of the interior (partial luminous flux for a solid angle). All other photometric parameters are derivatives of luminous flux. Luminous flux is measured in lumens (lm). The luminous flux is given as a nominal value for each lamp.
    double LuminousFlux() const;
    void setLuminousFlux(double v);
    /// Identifies the types of light emitter from which the type required may be set.
    IfcLightEmissionSourceEnum::IfcLightEmissionSourceEnum LightEmissionSource() const;
    void setLightEmissionSource(IfcLightEmissionSourceEnum::IfcLightEmissionSourceEnum v);
    /// The data source from which light distribution data is obtained.
    IfcLightDistributionDataSourceSelect* LightDistributionDataSource() const;
    void setLightDistributionDataSource(IfcLightDistributionDataSourceSelect* v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 4: return IfcUtil::Argument_ENTITY_INSTANCE; case 5: return IfcUtil::Argument_ENTITY_INSTANCE; case 6: return IfcUtil::Argument_DOUBLE; case 7: return IfcUtil::Argument_DOUBLE; case 8: return IfcUtil::Argument_ENUMERATION; case 9: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcLightSource::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 4: return Type::IfcAxis2Placement3D; case 5: return Type::IfcColourRgb; case 6: return Type::IfcThermodynamicTemperatureMeasure; case 7: return Type::IfcLuminousFluxMeasure; case 8: return Type::IfcLightEmissionSourceEnum; case 9: return Type::IfcLightDistributionDataSourceSelect; } return IfcLightSource::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 4: return "Position"; case 5: return "ColourAppearance"; case 6: return "ColourTemperature"; case 7: return "LuminousFlux"; case 8: return "LightEmissionSource"; case 9: return "LightDistributionDataSource"; } return IfcLightSource::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcLightSourceGoniometric (IfcEntityInstanceData* e);
    IfcLightSourceGoniometric (boost::optional< std::string > v1_Name, IfcColourRgb* v2_LightColour, boost::optional< double > v3_AmbientIntensity, boost::optional< double > v4_Intensity, IfcAxis2Placement3D* v5_Position, IfcColourRgb* v6_ColourAppearance, double v7_ColourTemperature, double v8_LuminousFlux, IfcLightEmissionSourceEnum::IfcLightEmissionSourceEnum v9_LightEmissionSource, IfcLightDistributionDataSourceSelect* v10_LightDistributionDataSource);
    typedef IfcTemplatedEntityList< IfcLightSourceGoniometric > list;
};
/// Definition from ISO/CD 10303-46:1992: The light source positional entity is a subtype of light source. This entity has a light source position and attenuation coefficients. A positional light source affects a surface based on the surface's orientation and position. 
/// 
/// Definition from ISO/IEC 14772-1:1997: The Point light node specifies a point light source at a 3D location in the local coordinate system. A point light source emits light equally in all directions; that is, it is omnidirectional. Point light nodes are specified in the local coordinate system and are affected by ancestor transformations.  
/// 
/// Point light node's illumination falls off with distance as specified by three attenuation coefficients. The attenuation factor is  
/// 
/// 1/max(attenuation[0] + attenuation[1] × r + attenuation[2] × r 2 , 1), 
/// 
/// where r is the distance from the light to the surface being illuminated. The default is no attenuation. An attenuation value of (0, 0, 0) is identical to (1, 0, 0). Attenuation values shall be greater than or equal to zero.  
/// 
/// NOTE: Corresponding ISO 10303 entity: light_source_positional. Please refer to ISO/IS 10303-46:1994, p. 32 for the final definition of the formal standard.
/// 
/// NOTE: In addition to the attributes as defined in ISO10303-46 the additional property from ISO/IEC 14772-1:1997 (VRML) Radius and QuadricAttenuation are added to this subtype and the AmbientIntensity and Intensity are inherited from the supertype.
/// 
/// HISTORY: This is a new entity in IFC 2x, renamed and enhanced in IFC2x2.
class IFC_PARSE_API IfcLightSourcePositional : public IfcLightSource {
public:
    /// Definition from ISO/CD 10303-46:1992: The Cartesian point indicates the position of the light source.
    /// Definition from VRML97 - ISO/IEC 14772-1:1997: A Point light node illuminates geometry within radius of its location.
    IfcCartesianPoint* Position() const;
    void setPosition(IfcCartesianPoint* v);
    /// Definition from IAI: The maximum distance from the light source for a surface still to be illuminated.
    /// Definition from VRML97 - ISO/IEC 14772-1:1997: A Point light node illuminates geometry within radius of its location.
    double Radius() const;
    void setRadius(double v);
    /// Definition from ISO/CD 10303-46:1992: This real indicates the value of the attenuation in the lighting equation that is constant.
    double ConstantAttenuation() const;
    void setConstantAttenuation(double v);
    /// Definition from ISO/CD 10303-46:1992: This real indicates the value of the attenuation in the lighting equation that proportional to the distance from the light source.
    double DistanceAttenuation() const;
    void setDistanceAttenuation(double v);
    /// Definition from the IAI: This real indicates the value of the attenuation in the lighting equation that proportional to the square value of the distance from the light source.
    double QuadricAttenuation() const;
    void setQuadricAttenuation(double v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 4: return IfcUtil::Argument_ENTITY_INSTANCE; case 5: return IfcUtil::Argument_DOUBLE; case 6: return IfcUtil::Argument_DOUBLE; case 7: return IfcUtil::Argument_DOUBLE; case 8: return IfcUtil::Argument_DOUBLE; } return IfcLightSource::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 4: return Type::IfcCartesianPoint; case 5: return Type::IfcPositiveLengthMeasure; case 6: return Type::IfcReal; case 7: return Type::IfcReal; case 8: return Type::IfcReal; } return IfcLightSource::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 4: return "Position"; case 5: return "Radius"; case 6: return "ConstantAttenuation"; case 7: return "DistanceAttenuation"; case 8: return "QuadricAttenuation"; } return IfcLightSource::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcLightSourcePositional (IfcEntityInstanceData* e);
    IfcLightSourcePositional (boost::optional< std::string > v1_Name, IfcColourRgb* v2_LightColour, boost::optional< double > v3_AmbientIntensity, boost::optional< double > v4_Intensity, IfcCartesianPoint* v5_Position, double v6_Radius, double v7_ConstantAttenuation, double v8_DistanceAttenuation, double v9_QuadricAttenuation);
    typedef IfcTemplatedEntityList< IfcLightSourcePositional > list;
};
/// Definition from ISO/CD 10303-46:1992: The light source spot entity is a subtype of light source. Spot light source entities have a light source colour, position, direction, attenuation coefficients, concentration exponent, and spread angle. If a point lies outside the cone of influence of a light source of this type as determined by the light source position, direction and spread angle its colour is not affected by that light source. 
/// 
/// NOTE  The IfcLightSourceSpot adds the BeamWidthAngle which defines the inner cone in which the light source emits light at uniform full intensity. The light source's emission intensity drops off from the inner solid angle (BeamWidthAngle) to the outer solid angle (SpreadAngle).
/// 
/// Definition from ISO/IEC 14772-1:1997: The Spot light node defines a light source that emits light from a specific point along a specific direction vector and constrained within a solid angle. Spot lights may illuminate geometry nodes that respond to light sources and intersect the solid angle defined by the Spot light. Spot light nodes are specified in the local coordinate system and are affected by ancestors' transformations. 
/// 
/// Figure 304 (from VRML97) shows the definition of spot light. 
/// 
/// Figure 304 — Light source spot
/// 
/// NOTE  Corresponding ISO 10303 entity: light_source_spot. Please refer to ISO/IS 10303-46:1994, p. 33 for the final definition of the formal standard.
/// 
/// NOTE  In addition to the attributes as defined in ISO10303-46 the additional property from ISO/IEC 14772-1:1997 (VRML) Radius, BeamWidth, and QuadricAttenuation are added to this subtype and the AmbientIntensity and Intensity are inherited from the supertype.
/// 
/// HISTORY  This is a new entity in IFC 2x, renamed and enhanced in IFC2x2.
class IFC_PARSE_API IfcLightSourceSpot : public IfcLightSourcePositional {
public:
    /// Definition from ISO/CD 10303-46:1992: This is the direction of the axis of the cone of the light source specified in the coordinate space of the representation being projected..
    /// Definition from VRML97 - ISO/IEC 14772-1:1997: The direction field specifies the direction vector of the light's central axis defined in the local coordinate system.
    IfcDirection* Orientation() const;
    void setOrientation(IfcDirection* v);
    /// Whether the optional attribute ConcentrationExponent is defined for this IfcLightSourceSpot
    bool hasConcentrationExponent() const;
    /// Definition from ISO/CD 10303-46:1992: This real is the exponent on the cosine of the angle between the line that starts at the position of the spot light source and is in the direction of the orientation of the spot light source and a line that starts at the position of the spot light source and goes through a point on the surface being shaded.
    /// NOTE: This attribute does not exists in ISO/IEC 14772-1:1997.
    double ConcentrationExponent() const;
    void setConcentrationExponent(double v);
    /// Definition from ISO/CD 10303-46:1992: This planar angle measure is the angle between the line that starts at the position of the spot light source and is in the direction of the spot light source and any line on the boundary of the cone of influence.
    /// Definition from VRML97 - ISO/IEC 14772-1:1997: The cutOffAngle (name of spread angle in VRML) field specifies the outer bound of the solid angle. The light source does not emit light outside of this solid angle.
    double SpreadAngle() const;
    void setSpreadAngle(double v);
    /// Definition from VRML97 - ISO/IEC 14772-1:1997: The beamWidth field specifies an inner solid angle in which the light source emits light at uniform full intensity. The light source's emission intensity drops off from the inner solid angle (beamWidthAngle) to the outer solid angle (spreadAngle).
    double BeamWidthAngle() const;
    void setBeamWidthAngle(double v);
    virtual unsigned int getArgumentCount() const { return 13; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENTITY_INSTANCE; case 10: return IfcUtil::Argument_DOUBLE; case 11: return IfcUtil::Argument_DOUBLE; case 12: return IfcUtil::Argument_DOUBLE; } return IfcLightSourcePositional::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcDirection; case 10: return Type::IfcReal; case 11: return Type::IfcPositivePlaneAngleMeasure; case 12: return Type::IfcPositivePlaneAngleMeasure; } return IfcLightSourcePositional::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "Orientation"; case 10: return "ConcentrationExponent"; case 11: return "SpreadAngle"; case 12: return "BeamWidthAngle"; } return IfcLightSourcePositional::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcLightSourceSpot (IfcEntityInstanceData* e);
    IfcLightSourceSpot (boost::optional< std::string > v1_Name, IfcColourRgb* v2_LightColour, boost::optional< double > v3_AmbientIntensity, boost::optional< double > v4_Intensity, IfcCartesianPoint* v5_Position, double v6_Radius, double v7_ConstantAttenuation, double v8_DistanceAttenuation, double v9_QuadricAttenuation, IfcDirection* v10_Orientation, boost::optional< double > v11_ConcentrationExponent, double v12_SpreadAngle, double v13_BeamWidthAngle);
    typedef IfcTemplatedEntityList< IfcLightSourceSpot > list;
};
/// IfcLocalPlacement defines the relative placement of a product in relation to the
/// placement of another product or the absolute placement of a product within the geometric representation context of the project. 
/// IfcLocalPlacement allows that an IfcProduct can be placed by this IfcLocalPlacement (through
/// the attributeObjectPlacement) within the local coordinate system of the object placement of another IfcProduct,
/// which is referenced by the PlacementRelTo. Rules to prevent cyclic relative placements have to be introduced on the
/// application level.
/// If the PlacementRelTo is not given, then
/// the IfcProduct is placed absolutely within the
/// world coordinate system.
/// 
/// HISTORY: New entity in IFC Release 1.0.
/// 
/// Geometry use definitions
/// The following conventions shall apply as default relative positions if the relative placement is used. The conventions are given for all five direct subtypes of IfcProduct, the IfcSpatialStructureElement, IfcElement, IfcAnnotation, IfcGrid, IfcPort. More detailed placement information is given at the level of subtypes of those five types mentioned.
/// 
/// For the subtypes of IfcSpatialStructureElement the following conventions apply
/// 
/// IfcSite shall be placed absolutely within the world coordinate system established by the geometric
/// representation context of the IfcProject 
///   IfcBuilding shall be placed relative to the local placement of IfcSite 
///   IfcBuildingStorey shall be placed relative to the local placement of IfcBuilding 
/// 
/// For IfcGrid and IfcAnnotation the convention applies that it shall be placed relative
/// 
/// to the local placement of its container (IfcSite, IfcBuilding, IfcBuildingStorey)
/// 
/// it should be the same container element that is referenced by the IfcRelContainedInSpatialStructure
/// containment relationship,
/// 
/// For IfcPort the convention applies that it shall be placed relative
/// 
/// to the local placement of the element it belongs to (IfcElement)
/// 
/// it should be the same element that is referenced by the IfcRelConnectsPortToElement connection
/// relationship,
/// 
/// For IfcElement the convention applies that it shall be placed relative:
/// 
/// to the local placement of its container (IfcSite, IfcBuilding, IfcBuildingStorey)
/// 
/// it should be the same container element that is referenced by the IfcRelContainedInSpatialStructure
/// containment relationship,
/// 
/// to the local placement of the IfcElement to which it is tied by an element composition relationship
/// 
/// for features that are located relative to the main component (such as openings), as expressed by IfcRelVoidsElement and IfcRelProjectsElement,
///   for elements that fill an opening (such as doors or windows), as expressed byIfcRelFillsElement,
///   for coverings that cover the element, as expressed byIfcRelCoversBldgElements,
///   for sub components that are aggregated to the main component, as expressed by  IIfcRelAggregates and IfcRelNests)
/// 
/// If the PlacementRelTo relationship is not given, then it defaults to an absolute placement within the world
/// coordinate system established by the referenced geometric representation context within the project.
class IFC_PARSE_API IfcLocalPlacement : public IfcObjectPlacement {
public:
    /// Whether the optional attribute PlacementRelTo is defined for this IfcLocalPlacement
    bool hasPlacementRelTo() const;
    /// Reference to Object that provides the relative placement by its local coordinate system. If it is omitted, then the local placement is given to the WCS, established by the geometric representation context.
    IfcObjectPlacement* PlacementRelTo() const;
    void setPlacementRelTo(IfcObjectPlacement* v);
    /// Geometric placement that defines the transformation from the related coordinate system into the relating. The placement can be either 2D or 3D, depending on the dimension count of the coordinate system.
    IfcAxis2Placement* RelativePlacement() const;
    void setRelativePlacement(IfcAxis2Placement* v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcObjectPlacement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcObjectPlacement; case 1: return Type::IfcAxis2Placement; } return IfcObjectPlacement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "PlacementRelTo"; case 1: return "RelativePlacement"; } return IfcObjectPlacement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcLocalPlacement (IfcEntityInstanceData* e);
    IfcLocalPlacement (IfcObjectPlacement* v1_PlacementRelTo, IfcAxis2Placement* v2_RelativePlacement);
    typedef IfcTemplatedEntityList< IfcLocalPlacement > list;
};
/// Definition from ISO/CD 10303-42:1992: A loop is a topological
///   entity constructed from a single vertex, or by stringing together connected
///   (oriented) edges, or linear segments beginning and ending at the same vertex.
///   It is typically used to bound a face lying on a surface. A loop has
///   dimensionality of 0 or 1. The domain of a 0-dimensional loop is a single point.
///   The domain of a 1-dimensional loop is a connected, oriented curve, but need not
///   to be manifold. As the loop is a circle, the location of its beginning/ending
///   point is arbitrary. The domain of the loop includes its bounds, an 0 ≤ Ξ
///   < ∞.  
///   A loop is represented by a single vertex, or by an ordered collection of
///   oriented edges, or by an ordered collection of points. A loop is a graph, so
///   M and the graph genus Gl may be determined by the
///   graph traversal algorithm. Since M = 1, the Euler equation (1) reduces
///   in this case to  
/// 
/// where V and El are the number of unique
///   vertices and oriented edges in the loop and Gl is the genus
///   of the loop.  
///   NOTE  Corresponding ISO 10303 entity: loop, the following subtypes have been incorporated into IFC: poly_loop as IfcPolyLoop, vertex_loop as IfcVertexLoop, edge_loop as IfcEdgeLoop. Please refer to ISO/IS 10303-42:1994, p. 136 for the final definition of the formal standard. 
/// 
/// HISTORY  New Entity in IFC2x. 
///   Informal propositions: 
/// 
/// A loop has a finite extent. 
///   A loop describes a closed (topological) curve with coincident start
///   and end vertices.
class IFC_PARSE_API IfcLoop : public IfcTopologicalRepresentationItem {
public:
    virtual unsigned int getArgumentCount() const { return 0; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcTopologicalRepresentationItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcTopologicalRepresentationItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcTopologicalRepresentationItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcLoop (IfcEntityInstanceData* e);
    IfcLoop ();
    typedef IfcTemplatedEntityList< IfcLoop > list;
};
/// Definition from ISO/CD 10303-43:1992: A mapped item is the use of an existing representation (the mapping source - mapped representation) as a representation item in a second representation. 
/// 
/// NOTE: A mapped item is a subtype of representation item. It enables a representation to be used as a representation item in one or more other representations. The mapped item allows for the definition of a representation using other representations. 
/// 
/// The IfcMappedItem is the inserted instance of a source definition (to be compared with a
/// block / shared cell / macro definition). The instance is inserted by applying a Cartesian transformation operator as the MappingTarget.
/// 
/// EXAMPLE  An IfcMappedItem can reuse other mapped items (ako nested blocks), doing so the IfcRepresentationMap is based on an IfcShapeRepresentation including one or more IfcMappedItem's.
/// 
/// NOTE   Corresponding ISO 10303 entity: mapped_item. Please refer to ISO/IS
/// 10303-43:1994, for the final definition of the formal standard. The definition of mapping_target (MappingTarget) has been restricted to be of the type cartesian_transformation_operator
/// (IfcCartesianTransformationOperator).
/// 
/// HISTORY  New entity in IFC Release 2x.
/// 
/// Informal Propositions
/// 
/// A mapped item shall not be self-defining by participating in the definition of the representation being mapped.
///   The dimensionality of the mapping source and the mapping target has to be the same, if the mapping source is a geometric representation item.
class IFC_PARSE_API IfcMappedItem : public IfcRepresentationItem {
public:
    /// A representation map that is the source of the mapped item. It can be seen as a block (or cell or marco) definition.
    IfcRepresentationMap* MappingSource() const;
    void setMappingSource(IfcRepresentationMap* v);
    /// A representation item that is the target onto which the mapping source is mapped. It is constraint to be a Cartesian transformation operator.
    IfcCartesianTransformationOperator* MappingTarget() const;
    void setMappingTarget(IfcCartesianTransformationOperator* v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcRepresentationItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcRepresentationMap; case 1: return Type::IfcCartesianTransformationOperator; } return IfcRepresentationItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "MappingSource"; case 1: return "MappingTarget"; } return IfcRepresentationItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcMappedItem (IfcEntityInstanceData* e);
    IfcMappedItem (IfcRepresentationMap* v1_MappingSource, IfcCartesianTransformationOperator* v2_MappingTarget);
    typedef IfcTemplatedEntityList< IfcMappedItem > list;
};
/// IfcMaterial is a homogeneous or inhomogeneous
/// substance that can be used to form elements (physical products or
/// their components).
/// IfcMaterial is the basic entity for material
/// designation and definition; this includes identification by name
/// and classification (via reference to an external classification),
/// as well as association of material properties (isotropic or
/// anisotropic) defined by (subtypes of)
/// IfcMaterialProperties. An instance of IfcMaterial
/// may be associated to an element or element type using the
/// IfcRelAssociatesMaterial relationship. The assignment
/// might either be direct as a single material information, or
/// via
/// 
/// a material layer set
/// a material profile set
/// a material constituent set
/// 
/// An IfcMaterial may also have presentation information
/// associated. Such presentation information is provided by
/// IfcMaterialDefinitionRepresentation, associating line
/// styles, hatching definitions or surface coloring/rendering
/// information to a material.
/// 
/// HISTORYÿNew entity in IFC2x4
/// 
/// IFC2x4 CHANGEÿ The attributes Description and Category have been added.
class IFC_PARSE_API IfcMaterial : public IfcMaterialDefinition {
public:
    /// Name of the material. 
    /// 
    /// EXAMPLE A view definition may require Material.Name to uniquely specify e.g. concrete or steel grade, in which case the attribute Material.Category could take the value 'Concrete' or 'Steel'. 
    /// 
    /// NOTE Material grade may have diffenrent meaning in different view definitions, e.g. strength grade for structural design and analysis, or visible appearance grade in architectural application. Also, more elaborate material grade definition may be associated as classification via inverse attribute HasExternalReferences.
    std::string Name() const;
    void setName(std::string v);
    /// Whether the optional attribute Description is defined for this IfcMaterial
    bool hasDescription() const;
    /// Definition of the material in more descriptive terms than given by attributes Name or Category.
    /// 
    /// IFC2x4 CHANGE  The attribute has been added at the end of attribute list.
    std::string Description() const;
    void setDescription(std::string v);
    /// Whether the optional attribute Category is defined for this IfcMaterial
    bool hasCategory() const;
    /// Definition of the category (group or type) of material, in more general terms than given by attribute Name.  
    /// 
    /// EXAMPLE A view definition may require each Material.Name to be unique, e.g. for each concrete or steel grade used in a project, in which case Material.Category could take the values 'Concrete' or 'Steel'.
    /// 
    /// IFC2x4 CHANGE  The attribute has been added at the end of attribute list.
    std::string Category() const;
    void setCategory(std::string v);
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_STRING; case 1: return IfcUtil::Argument_STRING; case 2: return IfcUtil::Argument_STRING; } return IfcMaterialDefinition::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcLabel; case 1: return Type::IfcText; case 2: return Type::IfcLabel; } return IfcMaterialDefinition::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Name"; case 1: return "Description"; case 2: return "Category"; } return IfcMaterialDefinition::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcMaterialDefinitionRepresentation >::ptr HasRepresentation() const; // INVERSE IfcMaterialDefinitionRepresentation::RepresentedMaterial
    IfcTemplatedEntityList< IfcMaterialRelationship >::ptr IsRelatedWith() const; // INVERSE IfcMaterialRelationship::RelatedMaterials
    IfcTemplatedEntityList< IfcMaterialRelationship >::ptr RelatesTo() const; // INVERSE IfcMaterialRelationship::RelatingMaterial
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcMaterial (IfcEntityInstanceData* e);
    IfcMaterial (std::string v1_Name, boost::optional< std::string > v2_Description, boost::optional< std::string > v3_Category);
    typedef IfcTemplatedEntityList< IfcMaterial > list;
};
/// IfcMaterialConstituent is a single and identifiable part of an element which is constructed of a number of part (one or more) each having an individual material. The association of the material constituent to the part is provided by a keyword as value of the Name attribute.
/// 
/// NOTE See the "Material Use Definition" at the individual element to which an IfcMaterialConstituentSet may apply for a required or recommended definition of such keywords as value for IfcMaterialConstituent.Name.
/// 
/// HISTORYÿNew Entity in IFC2x4
class IFC_PARSE_API IfcMaterialConstituent : public IfcMaterialDefinition {
public:
    /// Whether the optional attribute Name is defined for this IfcMaterialConstituent
    bool hasName() const;
    /// The name by which the material constituent is known.
    std::string Name() const;
    void setName(std::string v);
    /// Whether the optional attribute Description is defined for this IfcMaterialConstituent
    bool hasDescription() const;
    /// Definition of the material constituent in descriptive terms.
    std::string Description() const;
    void setDescription(std::string v);
    /// Reference to the material from which the constituent is constructed.
    IfcMaterial* Material() const;
    void setMaterial(IfcMaterial* v);
    /// Whether the optional attribute Fraction is defined for this IfcMaterialConstituent
    bool hasFraction() const;
    /// Optional provision of a fraction of the total amount (volume or weight) that applies to the IfcMaterialConstituentSet that is contributed by this IfcMaterialConstituent.
    double Fraction() const;
    void setFraction(double v);
    /// Whether the optional attribute Category is defined for this IfcMaterialConstituent
    bool hasCategory() const;
    /// Category of the material constituent, e.g. the role it has in the constituent set it belongs to.
    std::string Category() const;
    void setCategory(std::string v);
    virtual unsigned int getArgumentCount() const { return 5; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_STRING; case 1: return IfcUtil::Argument_STRING; case 2: return IfcUtil::Argument_ENTITY_INSTANCE; case 3: return IfcUtil::Argument_DOUBLE; case 4: return IfcUtil::Argument_STRING; } return IfcMaterialDefinition::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcLabel; case 1: return Type::IfcText; case 2: return Type::IfcMaterial; case 3: return Type::IfcNormalisedRatioMeasure; case 4: return Type::IfcLabel; } return IfcMaterialDefinition::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Name"; case 1: return "Description"; case 2: return "Material"; case 3: return "Fraction"; case 4: return "Category"; } return IfcMaterialDefinition::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcMaterialConstituentSet >::ptr ToMaterialConstituentSet() const; // INVERSE IfcMaterialConstituentSet::MaterialConstituents
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcMaterialConstituent (IfcEntityInstanceData* e);
    IfcMaterialConstituent (boost::optional< std::string > v1_Name, boost::optional< std::string > v2_Description, IfcMaterial* v3_Material, boost::optional< double > v4_Fraction, boost::optional< std::string > v5_Category);
    typedef IfcTemplatedEntityList< IfcMaterialConstituent > list;
};
/// IfcMaterialConstituentSet is a collection of individual material constituents, each assigning a material to a part of an element. The parts are only identified by a keyword (as opposed to an IfcMaterialLayerSet or IfcMaterialProfileSet where each part has an individual shape parameter (layer thickness or layer profile).
/// 
/// EXAMPLE The different materials of a window
/// construction shall be provided for the window lining and the
/// window glazing. An IfcMaterialConstituentSet is assigned
/// to the window with two IfcMaterialConstituent's, one with
/// the Name = 'Lining', one with the Name =
/// 'Glazing'.
/// NOTE See the "Material Use Definition" at the individual
/// element to which an IfcMaterialConstituentSet may apply
/// for a required or recommended definition of such
/// keywords.
/// 
/// HISTORYÿNew Entity in IFC2x4.
class IFC_PARSE_API IfcMaterialConstituentSet : public IfcMaterialDefinition {
public:
    /// Whether the optional attribute Name is defined for this IfcMaterialConstituentSet
    bool hasName() const;
    /// The name by which the constituent set is known.
    std::string Name() const;
    void setName(std::string v);
    /// Whether the optional attribute Description is defined for this IfcMaterialConstituentSet
    bool hasDescription() const;
    /// Definition of the material constituent set in descriptive terms.
    std::string Description() const;
    void setDescription(std::string v);
    /// Whether the optional attribute MaterialConstituents is defined for this IfcMaterialConstituentSet
    bool hasMaterialConstituents() const;
    /// Identification of the constituents from which the material constituent set is composed.
    IfcTemplatedEntityList< IfcMaterialConstituent >::ptr MaterialConstituents() const;
    void setMaterialConstituents(IfcTemplatedEntityList< IfcMaterialConstituent >::ptr v);
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_STRING; case 1: return IfcUtil::Argument_STRING; case 2: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } return IfcMaterialDefinition::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcLabel; case 1: return Type::IfcText; case 2: return Type::IfcMaterialConstituent; } return IfcMaterialDefinition::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Name"; case 1: return "Description"; case 2: return "MaterialConstituents"; } return IfcMaterialDefinition::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcMaterialConstituentSet (IfcEntityInstanceData* e);
    IfcMaterialConstituentSet (boost::optional< std::string > v1_Name, boost::optional< std::string > v2_Description, boost::optional< IfcTemplatedEntityList< IfcMaterialConstituent >::ptr > v3_MaterialConstituents);
    typedef IfcTemplatedEntityList< IfcMaterialConstituentSet > list;
};
/// IfcMaterialDefinitionRepresentation defines presentation information relating to IfcMaterial. It allows for multiple presentations of the same material for different geometric representation contexts.
/// 
/// NOTE  The IfcMaterialDefinitionRepresentation is currently only used
/// to define presentation information to material used at element
/// occurrences, defined as subtypes of IfcElement, or at
/// element types, defined as subtypes of IfcElementType. The
/// IfcMaterial is assigned to the subtype of
/// IfcElement, or IfcElementType using the
/// IfcRelAssociatesMaterial relationship (eventually via
/// other material related entities IfcMaterialLayerSetUsage,
/// IfcMaterialLayerSet, IfcMaterialLayer, or
/// IfcMaterialProfileSetUsage, IfcMaterialProfileSet,
/// IfcMaterialProfile).
/// 
/// The IfcMaterialDefinitionRepresentation can apply
/// 
/// different presentation styles for different representation contexts, for example, a different style for sketch view, model view or plan view, or for different target scales,
/// for each representation context is can apply curve style, fill area style (hatching), symbol, text and surface style.
/// 
/// HISTORY  New entity in IFC2x3.
/// 
/// IFC2x3 CHANGE  The entity IfcMaterialDefinitionRepresentation has been added. Upward compatibility for file based exchange is guaranteed.
/// 
/// IFC2x4 CHANGE  The assignment of curve, surface and other styles to an IfcStyledItem has been simplified by IfcStyleAssignmentSelect. The use of intermediate IfcPresentationStyleAssignment is deprecated.
/// 
/// Use definition
/// 
/// As shown in Figure 331, the presentation assignment can be specific to a representation context by adding one and more IfcStyledRepresentation's. Each of them includes a single IfcStyledItem with exactly zero or one style for either curve, fill area, surface, text or symbol style that is applicable.
/// 
/// Figure 331 — Material definition representation
class IFC_PARSE_API IfcMaterialDefinitionRepresentation : public IfcProductRepresentation {
public:
    /// Reference to the material to which the representation applies.
    IfcMaterial* RepresentedMaterial() const;
    void setRepresentedMaterial(IfcMaterial* v);
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 3: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcProductRepresentation::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 3: return Type::IfcMaterial; } return IfcProductRepresentation::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 3: return "RepresentedMaterial"; } return IfcProductRepresentation::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcMaterialDefinitionRepresentation (IfcEntityInstanceData* e);
    IfcMaterialDefinitionRepresentation (boost::optional< std::string > v1_Name, boost::optional< std::string > v2_Description, IfcTemplatedEntityList< IfcRepresentation >::ptr v3_Representations, IfcMaterial* v4_RepresentedMaterial);
    typedef IfcTemplatedEntityList< IfcMaterialDefinitionRepresentation > list;
};
/// IfcMaterialLayerSetUsage determines the usage of
/// IfcMaterialLayerSet in terms of its location and
/// orientation relative to the associated element geometry. The
/// location of material layer set shall be compatible with the
/// building element geometry (that is, material layers shall fit inside
/// the element geometry). The rules to ensure the compatibility
/// depend on the type of the building element.
/// 
/// EXAMPLE ÿFor a cavity brick wall with shape
/// representation SweptSolid, the
/// IfcMaterialLayerSet.TotalThickness shall be equal to the
/// wall thickness. Also the OffsetFromReferenceLine shall
/// match the exact positions between the two shape representations
/// of IfcWallStandardCase, i.e. the
/// IfcShapeRepresentation's with
/// RepresentationIdentifier="Axis" and
/// RepresentationIdentifier="Body".
/// 
/// NOTE ÿRefer to the implementation guide and agreements for
/// more information on matching between building element geometry
/// and material layer set usage.
/// 
/// The IfcMaterialLayerSetUsage is always assigned to an
/// individual occurrence object only (i.e. to relevant subtypes of
/// IfcElement). The IfcMaterialLayerSet, referenced by
/// ForLayerSet can however be shared among several occurrence
/// objects. If the element type is available (i.e. the relevant
/// subtype of IfcElementType, then the
/// IfcMaterialLayerSet can be assigned to the type object.
/// The assignment between aÿsubtype of IfcElement and the
/// IfcMaterialLayerSetUsage is handled by
/// IfcRelAssociatesMaterial.
/// 
/// Use definition
/// The IfcMaterialLayerSetUsage is primarily intended to
/// be associated with planar building elements having a constant
/// thickness. With further agreements on the interpretation of
/// LayerSetDirection, the usage can be extended also to other
/// cases, e.g. to curved building elements, provided that the
/// material layer thicknesses are constant.
/// Generally, an element may be layered in any of its primary
/// directions, denoted by its x, y or z axis. The geometry use
/// definitions at eachÿspecific types of building element will
/// determine the applicableÿLayerSetDirection.
/// 
/// The following examples illustrate how the IfcMaterialLayerSetUsage attributes (LayerSetDirection, DirectionSense, OffsetFromReferenceLine) can
/// be used in different cases. The normative material use definitions are documented at each element (how these shall be used).
/// 
/// Figure 286 shows an example of the use of IfcMaterialLayerSetUsage aligned to the axis of a wall.
/// 
/// EXAMPLE  For a standard wall with extruded
/// geometric representation (vertical extrusion), the layer set
/// direction will be perpendicular to extrusion direction,
/// andÿcan be derived from the direction of the wall
/// axis. With the DirectionSense(positive in
/// this example) the individual IfcMaterialLayers are
/// assigned consecutively right-to-left or left-to-right. For a
/// curved wall, "direction denoting the wall thickness" can be
/// derived from the direction of the wall axis, and it will remain
/// perpendicular to the wall path. The
/// DirectionSenseÿapplies as well.
/// 
/// NOTE  According to the IfcWallStandardCase material use
/// definition the LayerSetDirection for
/// IfcWallStandardCase is always AXIS2 (i.e. along the
/// y-axis), as shown in this example.
/// 
/// Figure 286 — Material layer set usage for wall
/// 
/// Figure 287 shows an example of the use of IfcMaterialLayerSetUsage aligned to a slab.
/// 
/// EXAMPLE ÿFor a slab with perpendicular
/// extruded geometric representation, the LayerSetDirection
/// will coincide with the extrusion direction (in positive or
/// negative sense). In this example, the material layer set base is
/// the extruded profile and consistent with the
/// IfcExtrudedAreaSolid.Position,ÿwith the
/// DirectionSensebeing positive, the
/// individual IfcMaterialLayers are built up from the base
/// towards positive z direction in this case.
/// 
/// NOTE ÿAccording to the IfcSlabStandardCase
/// material use definition the LayerSetDirection for
/// IfcSlabStandardCase is always AXIS3 (i.e. along the
/// z-axis).
/// 
/// Figure 287 — Material layer set usage for slab
/// 
/// Figure 288 shows an example of the use of IfcMaterialLayerSetUsage aligned to a roof slab with non-perpendicular extrusion.
/// 
/// EXAMPLE ÿFor a slab with non-perpendicular
/// extruded geometric representation, the guidelines above apply as
/// well. The material layer thickness and the
/// OffsetFromReferenceLine is always measured
/// perpendicularly, even if the extrusion direction is not
/// perpendicular. Therefore the total material layer thickness is
/// not equal to the extrusion depth of the
/// geometry.
/// 
/// Figure 288 — Material layer set usage for roof slab
class IFC_PARSE_API IfcMaterialLayerSetUsage : public IfcMaterialUsageDefinition {
public:
    /// The IfcMaterialLayerSet set to which the usage is applied.
    IfcMaterialLayerSet* ForLayerSet() const;
    void setForLayerSet(IfcMaterialLayerSet* v);
    /// Orientation of the material layer set relative to element reference geometry. The meaning of the value of this attribute shall be specified in the geometry use section for each element. For extruded shape representation, direction can be given along the extrusion path (e.g. for slabs) or perpendicular to it (e.g. for walls).
    /// 
    /// NOTE  the LayerSetDirection for IfcWallStandardCase shall be AXIS2 (i.e. the y-axis) and for IfcSlabStandardCase and IfcPlateStandardCase it shall be AXIS3 (i.e. the z-axis).
    /// 
    /// Whether the material layers of the set being used shall 'grow' into the positive or negative direction of the given axis, shall be deifned by DirectionSense attribute.
    IfcLayerSetDirectionEnum::IfcLayerSetDirectionEnum LayerSetDirection() const;
    void setLayerSetDirection(IfcLayerSetDirectionEnum::IfcLayerSetDirectionEnum v);
    /// Denotion whether the material layer set is oriented in positive or negative sense along the specified axis (defined by LayerSetDirection). "Positive" means that the consecutive layers (the IfcMaterialLayer instances in the list of  IfcMaterialLayerSet.MaterialLayers) are placed face-by-face in the direction of the positive axis as established by LayerSetDirection: for AXIS2 it would be in +y, for AXIS3 it would be +z. "Negative" means that the layers are placed face-by-face in the direction of the negative LayerSetDirection. In both cases,  starting at the material layer set base line.
    /// NOTE  the material layer set base line (MlsBase) is located by OffsetFromReferenceLine, and may be on the positive or negative side of the element reference line (or plane); positive or negative for MlsBase placement does not depend on the DirectionSense attribute, but on the relevant element axis.
    IfcDirectionSenseEnum::IfcDirectionSenseEnum DirectionSense() const;
    void setDirectionSense(IfcDirectionSenseEnum::IfcDirectionSenseEnum v);
    /// Offset of the material layer set base line (MlsBase) from reference geometry (line or plane) of element. The offset can be positive or negative, unless restricted for a particular building element type in its use definition or by implementer agreement. A positive value means, that the MlsBase is placed on the positive side of the reference line or plane, on the axis established by LayerSetDirection (in case of AXIS2 into the direction of +y, or in case of AXIS2 into the direction of +z). A negative value means that the MlsBase is placed on the negative side, as established by LayerSetDirection (in case of AXIS2 into the direction of -y). NOTE  the positive or negative sign in the offset only affects the MlsBase placement, it does not have any effect on the application of DirectionSense for orientation of the material layers; also DirectionSense does not change the MlsBase placement.
    double OffsetFromReferenceLine() const;
    void setOffsetFromReferenceLine(double v);
    /// Whether the optional attribute ReferenceExtent is defined for this IfcMaterialLayerSetUsage
    bool hasReferenceExtent() const;
    /// EPM-HTML>
    /// Extent of the extrusion of the elements body shape representation to which the IfcMaterialLayerSetUsage applies. It is used as the reference value for the upper OffsetValues[2] provided by the IfcMaterialLayerSetWithOffsets subtype for included material layers.
    /// 
    /// IFC2x4 CHANGE  New attribute added to the end of attribute list.
    /// 
    /// NOTE 1  The attribute ReferenceExtent shall be asserted, if an IfcMaterialLayerSetWithOffsets is included in the ForLayerSet.MaterialLayers list of maerial layers.
    /// 
    /// NOTE 2  The ReferenceExtent for IfcWallStandardCase is the reference height starting at z=0 being the XY plane of the object coordinate system.
    double ReferenceExtent() const;
    void setReferenceExtent(double v);
    virtual unsigned int getArgumentCount() const { return 5; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_ENUMERATION; case 2: return IfcUtil::Argument_ENUMERATION; case 3: return IfcUtil::Argument_DOUBLE; case 4: return IfcUtil::Argument_DOUBLE; } return IfcMaterialUsageDefinition::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcMaterialLayerSet; case 1: return Type::IfcLayerSetDirectionEnum; case 2: return Type::IfcDirectionSenseEnum; case 3: return Type::IfcLengthMeasure; case 4: return Type::IfcPositiveLengthMeasure; } return IfcMaterialUsageDefinition::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "ForLayerSet"; case 1: return "LayerSetDirection"; case 2: return "DirectionSense"; case 3: return "OffsetFromReferenceLine"; case 4: return "ReferenceExtent"; } return IfcMaterialUsageDefinition::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcMaterialLayerSetUsage (IfcEntityInstanceData* e);
    IfcMaterialLayerSetUsage (IfcMaterialLayerSet* v1_ForLayerSet, IfcLayerSetDirectionEnum::IfcLayerSetDirectionEnum v2_LayerSetDirection, IfcDirectionSenseEnum::IfcDirectionSenseEnum v3_DirectionSense, double v4_OffsetFromReferenceLine, boost::optional< double > v5_ReferenceExtent);
    typedef IfcTemplatedEntityList< IfcMaterialLayerSetUsage > list;
};
/// IfcMaterialProfileSetUsage determines the usage of IfcMaterialProfileSet in terms of its location relative to the associated element geometry. The location of a material profile set shall be compatible with the building element geometry (that is, material profiles shall fit inside the element geometry). The rules to ensure the compatibility depend on the type of the building element. For building elements with shape representations which are based on extruded solids, this is accomplished by referring to the identical profile definition in the shape model as in the material profile set.
/// 
/// NOTE ÿ Refer to the implementation guide and agreements for more information on matching between building element geometry and material profile set usage.
/// NOTE ÿ The referenced IfcMaterialProfileSet may represent a single material
/// profile, or a composite profile with two or more material profiles.
/// 
/// HISTORYÿNew Entity in IFC2x4.
class IFC_PARSE_API IfcMaterialProfileSetUsage : public IfcMaterialUsageDefinition {
public:
    /// The IfcMaterialProfileSet set to which the usage is applied.
    IfcMaterialProfileSet* ForProfileSet() const;
    void setForProfileSet(IfcMaterialProfileSet* v);
    /// Whether the optional attribute CardinalPoint is defined for this IfcMaterialProfileSetUsage
    bool hasCardinalPoint() const;
    /// Index reference to a significant point in the section profile. Describes how the section is aligned relative to the (longitudinal) axis of the member it is associated with. This parametric specification of profile alignment can be provided redundantly to the explicit alignment defined by ForProfileSet.MaterialProfiles[*].Profile.
    int CardinalPoint() const;
    void setCardinalPoint(int v);
    /// Whether the optional attribute ReferenceExtent is defined for this IfcMaterialProfileSetUsage
    bool hasReferenceExtent() const;
    /// EPM-HTML>
    /// Extent of the extrusion of the elements body shape representation to which the IfcMaterialProfileSetUsage applies. It is used as the reference value for the upper OffsetValues[2] provided by the IfcMaterialProfileSetWithOffsets subtype for included material profiles.
    /// 
    /// NOTE 1  The attribute ReferenceExtent shall be asserted, if an IfcMaterialProfileSetWithOffsets is included in the ForProfileSet.MaterialProfiles list of maerial layers.
    /// 
    /// NOTE 2  The ReferenceExtent for IfcBeamStandardCase, IfcColumnStandardCase, and IfcMemberStandardCase is the reference length starting at z=0 being the XY plane of the object coordinate system.
    double ReferenceExtent() const;
    void setReferenceExtent(double v);
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_INT; case 2: return IfcUtil::Argument_DOUBLE; } return IfcMaterialUsageDefinition::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcMaterialProfileSet; case 1: return Type::IfcCardinalPointReference; case 2: return Type::IfcPositiveLengthMeasure; } return IfcMaterialUsageDefinition::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "ForProfileSet"; case 1: return "CardinalPoint"; case 2: return "ReferenceExtent"; } return IfcMaterialUsageDefinition::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcMaterialProfileSetUsage (IfcEntityInstanceData* e);
    IfcMaterialProfileSetUsage (IfcMaterialProfileSet* v1_ForProfileSet, boost::optional< int > v2_CardinalPoint, boost::optional< double > v3_ReferenceExtent);
    typedef IfcTemplatedEntityList< IfcMaterialProfileSetUsage > list;
};
/// IfcMaterialProfileSetUsageTapering specifies dual material profile sets in association with tapered prismatic (beam- or column-like) elements.
/// 
/// HISTORYÿ New entity in IFC 2x4
/// 
/// Usage with tapered building elements
/// The inherited attribute ForProfileSet specifies the
/// profile and material at the start of the member,
/// ForProfileEndSet at its end. Start and end correspond to
/// the extrusion direction in the shape model of the shape
/// representation of the element or element type.
/// Both material profile sets should refer to the same material,
/// that is, only differ with respect to their profiles.
/// 
/// Usage with structural analysis curve members
/// IfcMaterialProfileSetUsageTapering may be used with the
/// structural analysis idealization
/// (IfcStructuralCurveMember) of uniform members as well as
/// of tapered members.
/// In case of uniform members, ForProfileSet and
/// ForProfileEndSet refer to the same material profile set.
/// In case of tapered members, ForProfileSet specifies the
/// profile and material at the start of the member,
/// ForProfileEndSet at its end. Start and end correspond to
/// the edge direction in the topological representation of the curve
/// member.
class IFC_PARSE_API IfcMaterialProfileSetUsageTapering : public IfcMaterialProfileSetUsage {
public:
    /// The second IfcMaterialProfileSet set to which the usage is applied.
    IfcMaterialProfileSet* ForProfileEndSet() const;
    void setForProfileEndSet(IfcMaterialProfileSet* v);
    /// Whether the optional attribute CardinalEndPoint is defined for this IfcMaterialProfileSetUsageTapering
    bool hasCardinalEndPoint() const;
    /// Index reference to a significant point in the second section profile. Describes how this section is aligned relative to the axis of the member it is associated with. This parametric specification of profile alignment can be provided redundantly to the explicit alignment defined by ForProfileSet.MaterialProfiles[*].Profile.
    int CardinalEndPoint() const;
    void setCardinalEndPoint(int v);
    virtual unsigned int getArgumentCount() const { return 5; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 3: return IfcUtil::Argument_ENTITY_INSTANCE; case 4: return IfcUtil::Argument_INT; } return IfcMaterialProfileSetUsage::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 3: return Type::IfcMaterialProfileSet; case 4: return Type::IfcCardinalPointReference; } return IfcMaterialProfileSetUsage::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 3: return "ForProfileEndSet"; case 4: return "CardinalEndPoint"; } return IfcMaterialProfileSetUsage::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcMaterialProfileSetUsageTapering (IfcEntityInstanceData* e);
    IfcMaterialProfileSetUsageTapering (IfcMaterialProfileSet* v1_ForProfileSet, boost::optional< int > v2_CardinalPoint, boost::optional< double > v3_ReferenceExtent, IfcMaterialProfileSet* v4_ForProfileEndSet, boost::optional< int > v5_CardinalEndPoint);
    typedef IfcTemplatedEntityList< IfcMaterialProfileSetUsageTapering > list;
};
/// IfcMaterialProperties is defined as an abstract
/// supertype for entities that apply material properties to material
/// definitions. A set of material properties that are assigned to an
/// individual material definiton may be identified by a Name
/// and a Description.
/// 
/// NOTE  The set of material properties can be assigned
/// to an individual IfcMaterial, a set or composite of
/// materials (IfcMaterialConstituent,
/// IfcMaterialConstituentSet), or set or individual material
/// layer (IfcMaterialLayer, IfcMaterialLayerSet), or
/// a set or individual material profile (IfcMaterialProfile,
/// IfcMaterialProfileSet)
/// 
/// The applicable set of material properties is defined at the
/// subtype IfcExtendedMaterialProperties. It includes
/// material properties defined in this IFC specification and those
/// defined as user-defined extended material properties.
/// 
/// HISTORY  New Entity in IFC 2x.
/// 
/// IFC2x4 CHANGE  The subtypes that represented a fixed list of statically defined material properties, IfcMechanicalMaterialProperties, IfcThermalMaterialProperties, IfcHygroscopicMaterialProperties, IfcGeneralMaterialProperties, IfcOpticalMaterialProperties, IfcWaterProperties, IfcFuelProperties, IfcProductsOfCombustionProperties have been deleted, use the generic IfcExtendedMaterialProperties instead.
class IFC_PARSE_API IfcMaterialProperties : public IfcExtendedProperties {
public:
    /// Reference to the material definition to which the set of properties is assigned.
    /// 
    /// IFC2x4 CHANGE  The datatype has been changed to supertype IfcMaterialDefinition.
    IfcMaterialDefinition* Material() const;
    void setMaterial(IfcMaterialDefinition* v);
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 3: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcExtendedProperties::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 3: return Type::IfcMaterialDefinition; } return IfcExtendedProperties::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 3: return "Material"; } return IfcExtendedProperties::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcMaterialProperties (IfcEntityInstanceData* e);
    IfcMaterialProperties (boost::optional< std::string > v1_Name, boost::optional< std::string > v2_Description, IfcTemplatedEntityList< IfcProperty >::ptr v3_Properties, IfcMaterialDefinition* v4_Material);
    typedef IfcTemplatedEntityList< IfcMaterialProperties > list;
};
/// IfcMaterialRelationship  defines a relationship between part and whole in material definitions (as in composite materials). The parts, expressed by the set of RelatedMaterials, are material constituents of which a single material aggregate is composed.
/// 
/// HISTORYÿNew Entity in IFC2x4
class IFC_PARSE_API IfcMaterialRelationship : public IfcResourceLevelRelationship {
public:
    /// Reference to the relating material (the composite).
    IfcMaterial* RelatingMaterial() const;
    void setRelatingMaterial(IfcMaterial* v);
    /// Reference to related materials (as constituents of composite material).
    IfcTemplatedEntityList< IfcMaterial >::ptr RelatedMaterials() const;
    void setRelatedMaterials(IfcTemplatedEntityList< IfcMaterial >::ptr v);
    /// Whether the optional attribute Expression is defined for this IfcMaterialRelationship
    bool hasExpression() const;
    /// The amount of related material in the whole (composite material or material set). Expressed as proportion (percentage) of weight or volume, or as any other appropriate value.
    std::string Expression() const;
    void setExpression(std::string v);
    virtual unsigned int getArgumentCount() const { return 5; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 2: return IfcUtil::Argument_ENTITY_INSTANCE; case 3: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 4: return IfcUtil::Argument_STRING; } return IfcResourceLevelRelationship::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 2: return Type::IfcMaterial; case 3: return Type::IfcMaterial; case 4: return Type::IfcLabel; } return IfcResourceLevelRelationship::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 2: return "RelatingMaterial"; case 3: return "RelatedMaterials"; case 4: return "Expression"; } return IfcResourceLevelRelationship::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcMaterialRelationship (IfcEntityInstanceData* e);
    IfcMaterialRelationship (boost::optional< std::string > v1_Name, boost::optional< std::string > v2_Description, IfcMaterial* v3_RelatingMaterial, IfcTemplatedEntityList< IfcMaterial >::ptr v4_RelatedMaterials, boost::optional< std::string > v5_Expression);
    typedef IfcTemplatedEntityList< IfcMaterialRelationship > list;
};
/// The IfcMirroredProfileDef defines the profile by mirroring the parent profile about the y axis of the parent profile coordinate system. That is, left and right of the parent profile are swapped.
/// 
/// Notes:
/// 
/// IfcMirroredProfileDef is primarily useful together with
/// IfcCShapeProfileDef, IfcLShapeProfileDef,
/// IfcUShapeProfileDef, or IfcZShapeProfileDef as
/// parent profile but can be used with other parent profile types as well.
/// 
/// Mirroring of an IfcParameterizedProfileDef is performed after
/// translation and rotation according to its Position attribute.
/// For example, if the parent profile's Position offsets it by half
/// of its width to the right, then the mirrored profile will be offset by
/// half of its width to the left.
/// 
/// Mirroring about the x axis, i.e. swapping top and bottom, can be
/// achieved by mirroring about the y axis coupled with 180 degree rotation
/// about the z axis.
/// In general, rotation happens in a containing object such as
/// IfcSweptAreaSolid, i.e. after mirroring by IfcMirroredProfileDef
/// was performed.
/// If the parent profile is an IfcParameterizedProfileDef, rotation
/// can alternatively happen already in the parent profile by means of its
/// Position attribute, i.e. before mirroring by IfcMirroredProfileDef
/// was performed.
/// 
/// HISTORY  New entity in IFC2x4.
class IFC_PARSE_API IfcMirroredProfileDef : public IfcDerivedProfileDef {
public:
    virtual unsigned int getArgumentCount() const { return 5; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcDerivedProfileDef::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcDerivedProfileDef::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcDerivedProfileDef::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcMirroredProfileDef (IfcEntityInstanceData* e);
    IfcMirroredProfileDef (IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< std::string > v2_ProfileName, IfcProfileDef* v3_ParentProfile, boost::optional< std::string > v5_Label);
    typedef IfcTemplatedEntityList< IfcMirroredProfileDef > list;
};
/// An IfcObjectDefinition is the generalization of any
/// semantically treated thing or process, either being a type or an
/// occurrences. Object defintions can be named, using the inherited
/// Name attribute, which should be a user recognizable label
/// for the object occurrance. Further explanations to the object can
/// be given using the inherited Description attribute. A
/// context is a specific kind of object definition as it provides the
/// project or library context in which object types and object
/// occurrences are defined.
/// Objects are independent pieces of information that might contain
/// or reference other pieces of information. There are four essential
/// kinds of relationships in which object definitons (by their
/// instantiable subtypes) can be involved:
/// 
/// Assignment of other objects - an assignment relationship
/// (IfcRelAssigns) that refers to other types of objects and
/// creates a bi-directional association. The semantic of the
/// assignment is established at the level of the subtypes of the
/// general IfcRelAssigns relationship. There is no dependency
/// implied a priori by the assignment.
/// Association to external resources - an association
/// relationship (IfcRelAssociates) that refers to external
/// sources of information (most notably a classification or document)
/// and creates a uni-directional association. There is no dependency
/// implied by the association.
/// Aggregation of other objects - an aggregation
/// relationship (IfcRelAggregates) that establishes an
/// unordered, spatial whole/part relation and creates a bi-directional
/// relation. There is an implied dependency established.
/// Nesting of other objects - a nesting relationship
/// (IfcRelNests) that establishes an ordered, non-spatial
/// whole/part relation and creates a bi-directional relation. There is
/// an implied dependency established.
/// Declaration within a context - a relationship
/// (IfcRelDeclares) of the uppermost object definition within
/// the object definition tree (e.g. the summary object within an
/// object nesting tree) to the context (a project or project library).
/// It applies the units, representation context and other context
/// information to this object definition and all dependent ones.
/// 
/// EXCEPTION  The link
/// between the uppermost object in the spatial structure tree, that is
/// IfcSite or ifcBuilding, and the context provided
/// by IfcProject is created using the
/// IfcRelAggregates relationship. See IfcProject for
/// more information.
/// 
/// HISTORY New abstract entity in IFC2x3.
/// 
/// IFC2x4 CHANGE The new subtype IfcContext and the relationship to context HasContext has been added . The decomposition relationship is split into ordered nesting (Nests, IsNestedBy) and un-ordered aggregating (Decomposes, IsDecomposedBy).
class IFC_PARSE_API IfcObjectDefinition : public IfcRoot {
public:
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcRoot::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcRoot::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcRoot::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcRelAssigns >::ptr HasAssignments() const; // INVERSE IfcRelAssigns::RelatedObjects
    IfcTemplatedEntityList< IfcRelNests >::ptr Nests() const; // INVERSE IfcRelNests::RelatedObjects
    IfcTemplatedEntityList< IfcRelNests >::ptr IsNestedBy() const; // INVERSE IfcRelNests::RelatingObject
    IfcTemplatedEntityList< IfcRelDeclares >::ptr HasContext() const; // INVERSE IfcRelDeclares::RelatedDefinitions
    IfcTemplatedEntityList< IfcRelAggregates >::ptr IsDecomposedBy() const; // INVERSE IfcRelAggregates::RelatingObject
    IfcTemplatedEntityList< IfcRelAggregates >::ptr Decomposes() const; // INVERSE IfcRelAggregates::RelatedObjects
    IfcTemplatedEntityList< IfcRelAssociates >::ptr HasAssociations() const; // INVERSE IfcRelAssociates::RelatedObjects
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcObjectDefinition (IfcEntityInstanceData* e);
    IfcObjectDefinition (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description);
    typedef IfcTemplatedEntityList< IfcObjectDefinition > list;
};
/// Definition from ISO/CD 10303-42:1992: An open shell is a shell of
///   the dimensionality 2. Its domain, if present, is a finite, connected, oriented,
///   2-manifold with boundary, but is not a closed surface. It can be thought of as
///   a closed shell with one or more holes punched in it. The domain of an open
///   shell satisfies 0
///   < Ξ < 1. An open shell is
///   functionally more general than a face because its domain can have handles. 
///   The shell is defined by a collection of faces, which may be oriented
///   faces. The sense of each face, after taking account of the orientation, shall
///   agree with the shell normal as defined below. The orientation can be supplied
///   directly as a BOOLEAN attribute of an oriented face, or be defaulted to TRUE if
///   the shell member is a face without the orientation attribute. 
///   The following combinatorial restrictions on open shells and geometrical
///   restrictions on their domains are designed, together with the informal
///   propositions, to ensure that any domain associated with an open shell is an
///   orientable manifold. 
/// 
/// Each face reference shall be unique.  
///   An open shell shall have at least one face.  
///   A given face may exist in more than one open shell. 
/// 
/// The boundary of an open shell consists of the edges that are referenced
///   only once by the face - bounds (loops) of its faces, together with all of their
///   vertices. The domain of an open shell, if present, contains all edges and
///   vertices of its faces. 
/// 
/// NOTE  Note that this is slightly different from the
///   definition of a face domain, which includes none of its bounds. For example, a
///   face domain may exclude an isolated point or line segment. An open shell domain
///   may not. (See the algorithm for computing below.) 
///   In the current IFC Release only poly loops
///   (IfcPolyLoop) are defined for bounds of face bound
///   (IfcFaceBound.Bound). This will allow for faceted B-rep only. For
///   further specification, including the Euler formulas to be satisfied, please
///   refer to ISO 10303-42:1994. 
/// 
/// NOTE  Corresponding ISO 10303 entity:
///   open_shell, please refer to ISO/IS 10303-42:1994, p.148 for the final
///   definition of the formal standard.
/// 
/// HISTORY  New class in IFC2x.
/// 
/// Informal propositions: 
/// 
/// Every edge shall be referenced exactly twice by the face bounds of
///   the face.  
///   Each oriented edge shall be unique.  
///   No edge shall be referenced by more than two faces.  
///   Distinct faces of the shell do not intersect, but may share edges or
///   vertices.  
///   Distinct edges do not intersect but may share vertices.  
///   Each face reference shall be unique.  
///   The loops of the shell shall not be a mixture of poly loop and other
///   loop types. Note: this is given, since only poly loop is defined as face bound
///   definition.  
///   The closed shell shall be an oriented arcwise connected 2-manifold.
/// 
/// The Euler equation shall be satisfied. Note: Please refer to ISO/IS
///   10303-42:1994, p.148 for the equation.
class IFC_PARSE_API IfcOpenShell : public IfcConnectedFaceSet {
public:
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcConnectedFaceSet::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcConnectedFaceSet::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcConnectedFaceSet::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcOpenShell (IfcEntityInstanceData* e);
    IfcOpenShell (IfcTemplatedEntityList< IfcFace >::ptr v1_CfsFaces);
    typedef IfcTemplatedEntityList< IfcOpenShell > list;
};
/// Definition: establishes an association between one relating organization and one or more related organizations.
/// 
/// NOTE Corresponds to the following entity in ISO-10303-41: organization_relationship.
/// 
/// HISTORY New entity in IFC Release 2x.
/// IFC 2x4 change: attribute Name made optional.
class IFC_PARSE_API IfcOrganizationRelationship : public IfcResourceLevelRelationship {
public:
    /// Organization which is the relating part of the relationship between organizations.
    IfcOrganization* RelatingOrganization() const;
    void setRelatingOrganization(IfcOrganization* v);
    /// The other, possibly dependent, organizations which are the related parts of the relationship between organizations.
    IfcTemplatedEntityList< IfcOrganization >::ptr RelatedOrganizations() const;
    void setRelatedOrganizations(IfcTemplatedEntityList< IfcOrganization >::ptr v);
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 2: return IfcUtil::Argument_ENTITY_INSTANCE; case 3: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } return IfcResourceLevelRelationship::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 2: return Type::IfcOrganization; case 3: return Type::IfcOrganization; } return IfcResourceLevelRelationship::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 2: return "RelatingOrganization"; case 3: return "RelatedOrganizations"; } return IfcResourceLevelRelationship::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcOrganizationRelationship (IfcEntityInstanceData* e);
    IfcOrganizationRelationship (boost::optional< std::string > v1_Name, boost::optional< std::string > v2_Description, IfcOrganization* v3_RelatingOrganization, IfcTemplatedEntityList< IfcOrganization >::ptr v4_RelatedOrganizations);
    typedef IfcTemplatedEntityList< IfcOrganizationRelationship > list;
};
/// Definition from ISO/CD 10303-42:1992: An oriented edge is an edge constructed from another edge and contains a BOOLEAN direction flag to indicate whether or not the orientation of the constructed edge agrees with the orientation of the original edge. Except for perhaps orientation, the oriented edge is equivalent to the original edge.  
/// 
/// NOTE  A common practice is solid modelling systems is to have an entity that represents the "use" or "traversal" of an edge. This "use" entity explicitly represents the requirement in a manifold solid that each edge must be traversed exactly twice, once in each direction. The "use" functionality is provided by the edge subtype oriented edge.
/// 
/// NOTE  Corresponding ISO 10303 entity: oriented_edge. Please refer to ISO/IS 10303-42:1994, p. 133 for the final definition of the formal standard.
/// 
/// HISTORY  New Entity in IFC Release 2.0.
class IFC_PARSE_API IfcOrientedEdge : public IfcEdge {
public:
    /// Edge entity used to construct this oriented edge.
    IfcEdge* EdgeElement() const;
    void setEdgeElement(IfcEdge* v);
    /// BOOLEAN, If TRUE the topological orientation as used coincides with the orientation from start vertex to end vertex of the edge element. If FALSE otherwise.
    bool Orientation() const;
    void setOrientation(bool v);
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_DERIVED; case 1: return IfcUtil::Argument_DERIVED; case 2: return IfcUtil::Argument_ENTITY_INSTANCE; case 3: return IfcUtil::Argument_BOOL; } return IfcEdge::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 2: return Type::IfcEdge; case 3: return Type::IfcBoolean; } return IfcEdge::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 2: return "EdgeElement"; case 3: return "Orientation"; } return IfcEdge::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcOrientedEdge (IfcEntityInstanceData* e);
    IfcOrientedEdge (IfcEdge* v3_EdgeElement, bool v4_Orientation);
    typedef IfcTemplatedEntityList< IfcOrientedEdge > list;
};
/// The parameterized profile definition
/// defines a 2D position coordinate system to which the parameters of the
/// different profiles relate to. All profiles are defined centric to the
/// origin of the position coordinate system, or more specific, the origin
/// [0.,0.] shall be in the center of the bounding box of the profile.
/// 
/// The Position attribute of IfcParameterizedProfileDef
/// is used to position the profile within the XY plane of the underlying
/// coordinate system of the swept surface geometry, the swept area
/// solid or the sectioned spine. It can be used to position the profile at
/// any point which becomes the origin [0.,0.,0.] of the extruded
/// or rotated surface or solid.
/// 
/// The Position attribute should not be used if the transformation
/// can be specified in a containing object instead.  In particular, this
/// applies if the IfcParameterizedProfileDef is referenced as
/// SweptArea in subtypes of IfcSweptAreaSolid or as
/// CrossSections in IfcSectionedSpine.
/// 
/// Several subtypes of IfcParameterizedProfileDef provide
/// shape parameters which are optional. Sending systems should always
/// provide values for these parameters if possible. If these parameters
/// are left unspecified, receiving systems may retrieve values for them
/// by external reference (if a reference to an external document or library
/// is given; see guidance at IfcProfileDef), or estimate them, or
/// simply assume zero values.
/// 
/// HISTORY  New entity in IFC2x2.
/// 
/// IFC2x Platform CHANGE  The IfcParameterizedProfileDef
/// is introduced as an intermediate new abstract entity that unifies the
/// definition and usage of the position coordinate system for all
/// parameterized profiles. The Position attribute has been removed at all
/// subtypes (like IfcRectangleProfileDef, IfcCircleProfileDef,
/// etc.).
/// 
/// IFC2x3 CHANGE  All profile origins are now in the center
/// of the bounding box.
/// 
/// IFC2x4 CHANGE  Position attribute made optional (default: identity transformation).
/// Several radius parameters in subtypes have been changed from optional IfcPositiveLengthMeasure (assumed default: 0.) to optional IfcNonNegativeLengthMeasure (default: unspecified).  This change allows to explicitly specify zero radius.  Sending systems shall export 0. values if parameters are known to be 0.
/// Subtypes IfcCraneRailAShapeProfileDef and IfcCraneRailFShapeProfileDef deleted.  Rail profiles shall be modeled as IfcArbitraryClosedProfileDef or as IfcAsymmetricIShapeProfileDef together with appropriate external reference.
class IFC_PARSE_API IfcParameterizedProfileDef : public IfcProfileDef {
public:
    /// Whether the optional attribute Position is defined for this IfcParameterizedProfileDef
    bool hasPosition() const;
    /// Position coordinate system of the parameterized profile definition. If unspecified, no translation and no rotation is applied.
    IfcAxis2Placement2D* Position() const;
    void setPosition(IfcAxis2Placement2D* v);
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 2: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcProfileDef::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 2: return Type::IfcAxis2Placement2D; } return IfcProfileDef::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 2: return "Position"; } return IfcProfileDef::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcParameterizedProfileDef (IfcEntityInstanceData* e);
    IfcParameterizedProfileDef (IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< std::string > v2_ProfileName, IfcAxis2Placement2D* v3_Position);
    typedef IfcTemplatedEntityList< IfcParameterizedProfileDef > list;
};
/// Definition from ISO/CD 10303-42:1992: A path is a topological entity consisting of an ordered collection of oriented edges, such that the edge start vertex of each edge coincides with the edge end of its predecessor. The path is ordered from the edge start of the first oriented edge to the edge end of the last edge. The BOOLEAN value sense in the oriented edge indicates whether the edge direction agrees with the direction of the path (TRUE) or is the opposite direction (FALSE).  
/// 
/// An individual edge can only be referenced once by an individual path. An edge can be referenced by multiple paths. An edge can exist independently of a path.  
/// 
/// NOTE  Corresponding ISO 10303 entity: path. Please refer to ISO/IS 10303-42:1994, p. 133 for the final definition of the formal standard.
/// 
/// HISTORY  New Entity in IFC Release 2.0
/// 
/// Informal proposition:
/// 
/// A path has dimensionality 1.
/// A path is arcwise connected.
/// The edges of the path do not intersect except at common vertices.
/// A path has a finite, non-zero extent.
class IFC_PARSE_API IfcPath : public IfcTopologicalRepresentationItem {
public:
    /// The list of oriented edges which are concatenated together to form this path.
    IfcTemplatedEntityList< IfcOrientedEdge >::ptr EdgeList() const;
    void setEdgeList(IfcTemplatedEntityList< IfcOrientedEdge >::ptr v);
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } return IfcTopologicalRepresentationItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcOrientedEdge; } return IfcTopologicalRepresentationItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "EdgeList"; } return IfcTopologicalRepresentationItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPath (IfcEntityInstanceData* e);
    IfcPath (IfcTemplatedEntityList< IfcOrientedEdge >::ptr v1_EdgeList);
    typedef IfcTemplatedEntityList< IfcPath > list;
};
/// The complex physical quantity, IfcPhysicalComplexQuantity, is an entity that holds a set of single quantity measure value (as defined at the subtypes of IfcPhysicalSimpleQuantity), that all apply to a given component or aspect of the element. 
/// 
/// EXAMPLE: A layered element, like a wall, may have several material layers, each having individual quantities, like footprint area, side area and volume. An instance of IfcPhysicalComplexQuantity would group these individual quantities (given by a subtype of IfcPhysicalSimpleQuantity) and name them according to the material layer name by using the Name attribute. The Discrimination attribute would then be 'layer'.
/// 
/// A section "Quantity Use Definition" at individual entities as subtypes of IfcBuildingElement gives guidance to the usage of the Name and Discrimination attribute to characterize the complex quantities.
/// 
/// HISTORY  New entity in IFC2x2 Addendum 1.
/// 
/// IFC2x2 ADDENDUM 1 CHANGE  The entity IfcPhysicalComplexQuantity has been added. Upward compatibility for file based exchange is guaranteed.
class IFC_PARSE_API IfcPhysicalComplexQuantity : public IfcPhysicalQuantity {
public:
    /// Set of physical quantities that are grouped by this complex physical quantity according to a given discrimination.
    IfcTemplatedEntityList< IfcPhysicalQuantity >::ptr HasQuantities() const;
    void setHasQuantities(IfcTemplatedEntityList< IfcPhysicalQuantity >::ptr v);
    /// Identification of the discrimination by which this physical complex property is distinguished. Examples of discriminations are 'layer', 'steel bar diameter', etc.
    std::string Discrimination() const;
    void setDiscrimination(std::string v);
    /// Whether the optional attribute Quality is defined for this IfcPhysicalComplexQuantity
    bool hasQuality() const;
    /// Additional indication of a quality of the quantities that are grouped under this physical complex quantity.
    std::string Quality() const;
    void setQuality(std::string v);
    /// Whether the optional attribute Usage is defined for this IfcPhysicalComplexQuantity
    bool hasUsage() const;
    /// Additional indication of a usage type of the quantities that are grouped under this physical complex quantity.
    std::string Usage() const;
    void setUsage(std::string v);
    virtual unsigned int getArgumentCount() const { return 6; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 2: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 3: return IfcUtil::Argument_STRING; case 4: return IfcUtil::Argument_STRING; case 5: return IfcUtil::Argument_STRING; } return IfcPhysicalQuantity::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 2: return Type::IfcPhysicalQuantity; case 3: return Type::IfcLabel; case 4: return Type::IfcLabel; case 5: return Type::IfcLabel; } return IfcPhysicalQuantity::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 2: return "HasQuantities"; case 3: return "Discrimination"; case 4: return "Quality"; case 5: return "Usage"; } return IfcPhysicalQuantity::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPhysicalComplexQuantity (IfcEntityInstanceData* e);
    IfcPhysicalComplexQuantity (std::string v1_Name, boost::optional< std::string > v2_Description, IfcTemplatedEntityList< IfcPhysicalQuantity >::ptr v3_HasQuantities, std::string v4_Discrimination, boost::optional< std::string > v5_Quality, boost::optional< std::string > v6_Usage);
    typedef IfcTemplatedEntityList< IfcPhysicalComplexQuantity > list;
};
/// An IfcPixelTexture provides a 2D image-based texture map as an explicit array of pixel values (list of Pixel binary attributes). In contrary to the IfcImageTexture the IfcPixelTexture holds a 2 dimensional list of pixel color
/// (and opacity) directly, instead of referencing to an URL.
/// 
/// The following definitions from ISO/IEC 19775-1 X3D Architecture and base components (X3D Specification) apply:
/// 
/// The PixelTexture node defines a 2D image-based texture map as an explicit array of pixel values (image field) and parameters controlling tiling repetition of the texture onto geometry.
/// Texture maps are defined in a 2D coordinate system (s, t) that ranges from 0.0 to 1.0 in both directions. The bottom edge of the pixel image corresponds to the S-axis of the texture map, and left edge of the pixel image corresponds to the T-axis of the texture map. The lower-left pixel of the pixel image corresponds to s=0.0, t=0.0, and the top-right pixel of the image corresponds to s = 1.0, t = 1.0.
/// The Image field specifies a single uncompressed 2-dimensional pixel image. Image fields contain three integers representing the width, height and number of components in the image, followed by width×height hexadecimal values representing the pixels in the image. Pixel values are limited to 256 levels of intensity (that is, 0x00-0xFF hexadecimal).
/// 
/// A one-component image specifies one-byte hexadecimal value representing the intensity of the image. For example, 0xFF is full intensity in hexadecimal (255 in decimal), 0x00 is no intensity (0 in decimal).
/// A two-component image specifies the intensity in the first
/// (high) byte and the alpha opacity in the second (low) byte.
/// Pixels in a three-component image specify the red component in the first (high) byte, followed by the green and blue components (for example, 0xFF0000 is red, 0x00FF00 is green, 0x0000FF is blue).
/// Four-component images specify the alpha opacity byte after red/green/blue (e.g., 0x0000FF80 is semi-transparent blue). A value of 00 is completely transparent, FF is completely opaque, 80 is semi-transparent.
/// 
/// Note that alpha equals (1.0 -transparency), if alpha and transparency each range from 0.0 to 1.0.
/// 
/// HISTORY: New class in IFC2x2.
class IFC_PARSE_API IfcPixelTexture : public IfcSurfaceTexture {
public:
    /// The number of pixels in width (S) direction.
    int Width() const;
    void setWidth(int v);
    /// The number of pixels in height (T) direction.
    int Height() const;
    void setHeight(int v);
    /// Indication whether the pixel values contain a 1, 2, 3, or 4 colour component.
    int ColourComponents() const;
    void setColourComponents(int v);
    /// Flat list of hexadecimal values, each describing one pixel by 1, 2, 3, or 4 components.
    /// 
    /// IFC2x Edition 3 CHANGE  The data type has been changed from STRING to BINARY.
    std::vector< boost::dynamic_bitset<> > /*[1:?]*/ Pixel() const;
    void setPixel(std::vector< boost::dynamic_bitset<> > /*[1:?]*/ v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 5: return IfcUtil::Argument_INT; case 6: return IfcUtil::Argument_INT; case 7: return IfcUtil::Argument_INT; case 8: return IfcUtil::Argument_AGGREGATE_OF_BINARY; } return IfcSurfaceTexture::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 5: return Type::IfcInteger; case 6: return Type::IfcInteger; case 7: return Type::IfcInteger; case 8: return Type::IfcBinary; } return IfcSurfaceTexture::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 5: return "Width"; case 6: return "Height"; case 7: return "ColourComponents"; case 8: return "Pixel"; } return IfcSurfaceTexture::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPixelTexture (IfcEntityInstanceData* e);
    IfcPixelTexture (bool v1_RepeatS, bool v2_RepeatT, boost::optional< std::string > v3_Mode, IfcCartesianTransformationOperator2D* v4_TextureTransform, boost::optional< std::vector< std::string > /*[1:?]*/ > v5_Parameter, int v6_Width, int v7_Height, int v8_ColourComponents, std::vector< boost::dynamic_bitset<> > /*[1:?]*/ v9_Pixel);
    typedef IfcTemplatedEntityList< IfcPixelTexture > list;
};
/// Definition from ISO/CD 10303-42:1992: A placement entity defines the local environment for the definition of a geometry item. It locates the item to be defined and, in the case of the axis placement subtypes, gives its orientation. 
/// 
/// Additional definition from ISO/WD SC4/WG12/N071 Part42.2 geometry_schema: A placement locates a geometric item with respect to the coordinate system of its geometric context. 
/// 
/// IfcPlacement is an abstract supertype not to be directly instantiated, whereas the ISO 10303-42 entity placement can be instantiated to define a placement without orientation. The derived attribute Dim has been added, see also note at IfcGeometricRepresentationItem.  
/// 
/// NOTE: Corresponding ISO 10303 entity: placement. Please refer to ISO/IS 10303-42:1994, p. 27 for the final definition of the formal standard.
/// 
/// HISTORY: New entity in IFC Release 1.0
class IFC_PARSE_API IfcPlacement : public IfcGeometricRepresentationItem {
public:
    /// The geometric position of a reference point, such as the center of a circle, of the item to be located.
    IfcCartesianPoint* Location() const;
    void setLocation(IfcCartesianPoint* v);
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcGeometricRepresentationItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcCartesianPoint; } return IfcGeometricRepresentationItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Location"; } return IfcGeometricRepresentationItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPlacement (IfcEntityInstanceData* e);
    IfcPlacement (IfcCartesianPoint* v1_Location);
    typedef IfcTemplatedEntityList< IfcPlacement > list;
};
/// The planar extent defines the extent along the two axes of the two-dimensional coordinate system, independently of its position.
/// 
/// NOTE  Corresponding ISO 10303 name: planar_extent. Please refer to ISO/IS 10303-46:1994, p. 141 for the final definition of the formal standard.
/// 
/// HISTORY  New entity in IFC2x2.
class IFC_PARSE_API IfcPlanarExtent : public IfcGeometricRepresentationItem {
public:
    /// The extent in the direction of the x-axis.
    double SizeInX() const;
    void setSizeInX(double v);
    /// The extent in the direction of the y-axis.
    double SizeInY() const;
    void setSizeInY(double v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_DOUBLE; case 1: return IfcUtil::Argument_DOUBLE; } return IfcGeometricRepresentationItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcLengthMeasure; case 1: return Type::IfcLengthMeasure; } return IfcGeometricRepresentationItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "SizeInX"; case 1: return "SizeInY"; } return IfcGeometricRepresentationItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPlanarExtent (IfcEntityInstanceData* e);
    IfcPlanarExtent (double v1_SizeInX, double v2_SizeInY);
    typedef IfcTemplatedEntityList< IfcPlanarExtent > list;
};
/// Definition from ISO/CD 10303-42:1992: A point is a location in some real Cartesian coordinate space Rm, for m = 1, 2 or 3.  
/// 
/// NOTE: Corresponding ISO 10303 entity: point. Only the subtypes cartesian_point, point_on_curve, point_on_surface have been incorporated in the current release of IFC. Please refer to ISO/IS 10303-42:1994, p. 22 for the final definition of the formal standard.
/// 
/// HISTORY: New entity in IFC Release 1.5
class IFC_PARSE_API IfcPoint : public IfcGeometricRepresentationItem {
public:
    virtual unsigned int getArgumentCount() const { return 0; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcGeometricRepresentationItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcGeometricRepresentationItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcGeometricRepresentationItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPoint (IfcEntityInstanceData* e);
    IfcPoint ();
    typedef IfcTemplatedEntityList< IfcPoint > list;
};
/// Definition from ISO/CD 10303-42:1992: A point on curve is a point which lies on a curve. The point is determined by evaluating the curve at a specific parameter value. The coordinate space dimensionality of the point is that of the basis curve. 
/// 
/// NOTE: Corresponding STEP entity: point_on_curve. Please refer to ISO/IS 10303-42:1994, p. 23 for the final definition of the formal standard.
/// 
/// HISTORY: New entity in Release IFC2x Edition 2.
/// 
/// Informal Propositions: 
/// 
/// The value of the point parameter shall not be outside the parametric range of the curve.
class IFC_PARSE_API IfcPointOnCurve : public IfcPoint {
public:
    /// The curve to which point parameter relates.
    IfcCurve* BasisCurve() const;
    void setBasisCurve(IfcCurve* v);
    /// The parameter value of the point location.
    double PointParameter() const;
    void setPointParameter(double v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_DOUBLE; } return IfcPoint::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcCurve; case 1: return Type::IfcParameterValue; } return IfcPoint::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "BasisCurve"; case 1: return "PointParameter"; } return IfcPoint::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPointOnCurve (IfcEntityInstanceData* e);
    IfcPointOnCurve (IfcCurve* v1_BasisCurve, double v2_PointParameter);
    typedef IfcTemplatedEntityList< IfcPointOnCurve > list;
};
/// Definition from ISO/CD 10303-42:1992: A point on surface is a point which lies on a parametric surface. The point is determined by evaluating the surface at a particular pair of parameter values. 
/// 
/// NOTE: Corresponding ISO 10303 entity: point_on_surface. Please refer to ISO/IS 10303-42:1994, p. 24 for the final definition of the formal standard.  
/// 
/// HISTORY: New entity in Release IFC2x Edition 2.
/// 
/// Informal Propositions: 
/// 
/// The parametric values specified for u and v shall not be outside the parametric range of the basis surface.
class IFC_PARSE_API IfcPointOnSurface : public IfcPoint {
public:
    /// The surface to which the parameter values relate.
    IfcSurface* BasisSurface() const;
    void setBasisSurface(IfcSurface* v);
    /// The first parameter value of the point location.
    double PointParameterU() const;
    void setPointParameterU(double v);
    /// The second parameter value of the point location.
    double PointParameterV() const;
    void setPointParameterV(double v);
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_DOUBLE; case 2: return IfcUtil::Argument_DOUBLE; } return IfcPoint::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcSurface; case 1: return Type::IfcParameterValue; case 2: return Type::IfcParameterValue; } return IfcPoint::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "BasisSurface"; case 1: return "PointParameterU"; case 2: return "PointParameterV"; } return IfcPoint::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPointOnSurface (IfcEntityInstanceData* e);
    IfcPointOnSurface (IfcSurface* v1_BasisSurface, double v2_PointParameterU, double v3_PointParameterV);
    typedef IfcTemplatedEntityList< IfcPointOnSurface > list;
};
/// Definition from ISO/CD 10303-42:1992: A
/// poly loop is a loop with straight edges bounding a planar region in
/// space. A poly loop is a loop of genus 1 where the loop is represented
/// by an ordered coplanar collection of points forming the vertices of the
/// loop. The loop is composed of straight line segments joining a point in
/// the collection to the succeeding point in the collection. The closing
/// segment is from the last to the first point in the collection. 
/// The direction of the loop is in the direction of the line
/// segments. 
/// 
/// NOTE  This entity exists primarily to facilitate the efficient communication of faceted B-rep models.
/// 
/// A poly loop shall conform to the following topological
/// constraints:
/// 
/// - the loop has the genus of one.
///   - the following equation shall be satisfied
/// 
/// The IfcPolyLoop
/// is always closed and the last segment is from the last IfcCartesianPoint
/// in the list of Polygon's to the first IfcCartesianPoint.
/// Therefore the first point shall not be repeated at the end of the list,
/// neither by referencing the same instance, nor by using an additional
/// instance of IfcCartesianPoint having the
/// coordinates as the first point.
/// 
/// NOTE  Corresponding ISO 10303 entity: poly_loop. Please refer to ISO/IS
/// 10303-42:1994, p. 138 for the final definition of the formal standard.
/// Due to the general IFC model specification rule not to use multiple
/// inheritance, the subtype relationship to geometric_representation_item
/// is not included. The derived attribute Dim has been
/// added at this level.
/// 
/// HISTORY   New class in IFC Release 1.0
/// 
/// Informal propositions: 
/// 
/// All the points in the polygon defining the poly loop shall be coplanar.
///   The first and the last Polygon shall be different by value.
class IFC_PARSE_API IfcPolyLoop : public IfcLoop {
public:
    /// List of points defining the loop. There are no repeated points in the list.
    IfcTemplatedEntityList< IfcCartesianPoint >::ptr Polygon() const;
    void setPolygon(IfcTemplatedEntityList< IfcCartesianPoint >::ptr v);
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } return IfcLoop::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcCartesianPoint; } return IfcLoop::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Polygon"; } return IfcLoop::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPolyLoop (IfcEntityInstanceData* e);
    IfcPolyLoop (IfcTemplatedEntityList< IfcCartesianPoint >::ptr v1_Polygon);
    typedef IfcTemplatedEntityList< IfcPolyLoop > list;
};
/// The polygonal bounded
/// half space is a special subtype of a half space solid, where the
/// material of the half space used in Boolean expressions is bounded by a
/// polygonal boundary. The base
/// surface of the half space is positioned by its normal relativeto the
/// object coordinate system
/// (as defined at the supertype IfcHalfSpaceSolid), and
/// its polygonal (with or without arc segments) boundary is defined in the
/// XY plane of the position
/// coordinate system established by the Position
/// attribute, the subtraction body is extruded perpendicular to the XY
/// plane of the position coordinate system, that is, into the direction of the
/// positive Z axis defined by the Position attribute.
/// The boundary is defined by a 2 dimensional polyline (or 2 dimensional composite curve,
/// consisting of straight segments and circular arc segments)
/// within the
/// XY plane of the position coordinate system. The side of the surface
/// which is in the half space is determined by the surface normal and the
/// agreement flag. If the agreement flag is TRUE, then the subset is the
/// one the normal points away from. If the agreement flag is FALSE, then
/// the subset is the one the normal points into. 
/// 
/// NOTE  A polygonal bounded half space is not a subtype of IfcSolidModel, half space solids are only useful as operands in Boolean expressions.
/// 
/// HISTORY  New class in IFC Release 2x.
/// 
/// Informal propositions:
/// 
/// The IfcPolyline or the IfcCompositeCurve
/// providing the PolygonalBoundary
/// shall be closed.
///   If the PolygonalBoundary
/// is given by an IfcCompositeCurve, it shall only
/// have IfcCompositeCurveSegment's of type IfcPolyline,
/// or IfcTrimmedCurve (having a BasisCurve
/// of type IfcLine, or IfcCircle)
/// 
/// Figure 259 illustrates a polygonal bounded half space.
/// 
/// Black coordinates indicate the object coordinate system (usually provided by IfcLocalPlacement).
/// Green coordinates indicate the position coordinate system; the PolygonalBoundary is given within this coordinate system. It is provided by IfcPolygonalBoundedHalfSpace.Position. This coordinate system is relative to the object coordinate system. The extrusion direction of the subtraction body is the positive Z axis.
/// Red coordinates indicate the normal of the plane. It is provided by the BaseSurface (IfcSurface.Position). This normal is also relative to the object coordinate system.
/// 
/// Figure 259 — Polygonal half space geometry
/// 
/// Purpose
/// The polygonal bounded half space is used to limit the volume of the
/// half space in Boolean difference expressions. Only the part that is
/// defined by a theoretical intersection between the half space solid and
/// an extruded area solid, defined by extruding the polygonal boundary, is
/// used for Boolean expressions.
///   Parameter
/// The PolygonalBoundary defines the 2D polyline which
/// bounds the effectiveness of the half space in Boolean expressions. The BaseSurface
/// is defined by a plane, and the normal of the plane together with the AgreementFlag
/// defines the side of the material of the half space.
class IFC_PARSE_API IfcPolygonalBoundedHalfSpace : public IfcHalfSpaceSolid {
public:
    /// Definition of the position coordinate system for the bounding polyline and the base surface.
    IfcAxis2Placement3D* Position() const;
    void setPosition(IfcAxis2Placement3D* v);
    /// Two-dimensional polyline bounded curve, defined in the xy plane of the position coordinate system.
    /// 
    /// IFC2x Edition 3 CHANGE  The attribute type has been changed from IfcPolyline to its supertype IfcBoundedCurve with upward compatibility for file based exchange.
    IfcBoundedCurve* PolygonalBoundary() const;
    void setPolygonalBoundary(IfcBoundedCurve* v);
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 2: return IfcUtil::Argument_ENTITY_INSTANCE; case 3: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcHalfSpaceSolid::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 2: return Type::IfcAxis2Placement3D; case 3: return Type::IfcBoundedCurve; } return IfcHalfSpaceSolid::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 2: return "Position"; case 3: return "PolygonalBoundary"; } return IfcHalfSpaceSolid::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPolygonalBoundedHalfSpace (IfcEntityInstanceData* e);
    IfcPolygonalBoundedHalfSpace (IfcSurface* v1_BaseSurface, bool v2_AgreementFlag, IfcAxis2Placement3D* v3_Position, IfcBoundedCurve* v4_PolygonalBoundary);
    typedef IfcTemplatedEntityList< IfcPolygonalBoundedHalfSpace > list;
};
/// A pre defined item is a qualified name given to a style or font which is determined within the data exchange specification by convention on using the Name attribute value (in contrary to externally defined items, which are agreed by an external source).
/// 
/// NOTE  The convention on using the Name value is defined at the subtypes of IfcPreDefinedItem and is part of the specification.
/// 
/// NOTE  Corresponding ISO 10303 name: pre_defined_item. Please refer to ISO/IS 10303-41:1994, page 137 for the final definition of the formal standard.
/// 
/// HISTORY  New entity in IFC2x2.
class IFC_PARSE_API IfcPreDefinedItem : public IfcPresentationItem {
public:
    /// The string by which the pre defined item is identified. Allowable values for the string are declared at the level of subtypes.
    std::string Name() const;
    void setName(std::string v);
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_STRING; } return IfcPresentationItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcLabel; } return IfcPresentationItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Name"; } return IfcPresentationItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPreDefinedItem (IfcEntityInstanceData* e);
    IfcPreDefinedItem (std::string v1_Name);
    typedef IfcTemplatedEntityList< IfcPreDefinedItem > list;
};

class IFC_PARSE_API IfcPreDefinedProperties : public IfcPropertyAbstraction {
public:
    virtual unsigned int getArgumentCount() const { return 0; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcPropertyAbstraction::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcPropertyAbstraction::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcPropertyAbstraction::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPreDefinedProperties (IfcEntityInstanceData* e);
    IfcPreDefinedProperties ();
    typedef IfcTemplatedEntityList< IfcPreDefinedProperties > list;
};
/// The pre defined text font determines those qualified names which can be used for fonts that are in scope of the current data exchange specification (in contrary to externally defined text fonts). There are two choices:
/// 
/// IfcDraughtingPreDefinedTextFont for definitions from ISO/IS 10303-46:1994 for (old) vector based and monospace text.
/// 
/// IfcTextStyleFontModel for definitions from Cascading Style Sheets, level 1, W3C Recommendation 17 Dec 1996, revised 11 Jan 1999, CSS1, for all true type text. The use of the CSS1 definitions is the preferred way to represent text fonts.
/// 
/// NOTE  Corresponding ISO 10303 name: pre_defined_text_font. Please refer to ISO/IS 10303-46:1994, p. 138 for the final definition of the formal standard.
/// 
/// HISTORY  New entity in IFC2x2.
/// 
/// IFC2x3 CHANGE  The IfcTextStyleFontModel has been added as new subtype.
class IFC_PARSE_API IfcPreDefinedTextFont : public IfcPreDefinedItem {
public:
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcPreDefinedItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcPreDefinedItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcPreDefinedItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPreDefinedTextFont (IfcEntityInstanceData* e);
    IfcPreDefinedTextFont (std::string v1_Name);
    typedef IfcTemplatedEntityList< IfcPreDefinedTextFont > list;
};
/// The IfcProductDefinitionShape defines all shape relevant information about an IfcProduct. It allows for multiple geometric shape representations of the same product. The shape relevant information includes:
/// 
/// the shape representation including geometric representation items (for 3D solids, 2D annotations, etc.) and:
/// 
/// associated presentation information (line color, line type, surface rendering properties)
/// assignment to presentation layers (CAD layers for visibility control)
/// 
/// or the topological representation items for connectivity systems (vertex, edge, face representations) that may include geometric representation items (vertex points, edge curves, face surfaces)
/// 
/// NOTE  The definition of this entity relates to the ISO 10303 entity product_definition_shape. Please refer to ISO/IS 10303-41:1994 for the final definition of the formal standard.
/// 
/// HISTORY  New Entity in IFC Release 1.5
class IFC_PARSE_API IfcProductDefinitionShape : public IfcProductRepresentation {
public:
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcProductRepresentation::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcProductRepresentation::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcProductRepresentation::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcProduct >::ptr ShapeOfProduct() const; // INVERSE IfcProduct::Representation
    IfcTemplatedEntityList< IfcShapeAspect >::ptr HasShapeAspects() const; // INVERSE IfcShapeAspect::PartOfProductDefinitionShape
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcProductDefinitionShape (IfcEntityInstanceData* e);
    IfcProductDefinitionShape (boost::optional< std::string > v1_Name, boost::optional< std::string > v2_Description, IfcTemplatedEntityList< IfcRepresentation >::ptr v3_Representations);
    typedef IfcTemplatedEntityList< IfcProductDefinitionShape > list;
};
/// This is a collection of properties applicable to section profile definitions.
/// 
/// The following sets of extended profile property definitions are part of this IFC release:
/// 
/// mechanical properties for all classes of profiles
/// properties for precast concrete double-T sections
/// properties for precast concrete hollow core sections
/// 
/// HISTORY  New entity in IFC2x2.
/// 
/// IFC2x4 CHANGE  Entity made non-abstract.  Subtypes IfcGeneralProfileProperties, IfcStructuralProfileProperties, and IfcStructuralSteelProfileProperties deleted. Attribute ProfileName deleted, use ProfileDefinition.ProfileName instead. Attribute ProfileDefinition made mandatory. Attributes Name, Description, and HasProperties added.
class IFC_PARSE_API IfcProfileProperties : public IfcExtendedProperties {
public:
    /// Profile definition which is qualified by these properties.
    IfcProfileDef* ProfileDefinition() const;
    void setProfileDefinition(IfcProfileDef* v);
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 3: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcExtendedProperties::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 3: return Type::IfcProfileDef; } return IfcExtendedProperties::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 3: return "ProfileDefinition"; } return IfcExtendedProperties::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcProfileProperties (IfcEntityInstanceData* e);
    IfcProfileProperties (boost::optional< std::string > v1_Name, boost::optional< std::string > v2_Description, IfcTemplatedEntityList< IfcProperty >::ptr v3_Properties, IfcProfileDef* v4_ProfileDefinition);
    typedef IfcTemplatedEntityList< IfcProfileProperties > list;
};
/// IfcProperty is an abstract generalization for all types of properties that can be associated with IFC objects through the property set mechanism. 
/// 
/// HISTORY  New entity in IFC Release 1.0.
class IFC_PARSE_API IfcProperty : public IfcPropertyAbstraction {
public:
    /// Name for this property. This label is the significant name string that defines the semantic meaning for the property.
    std::string Name() const;
    void setName(std::string v);
    /// Whether the optional attribute Description is defined for this IfcProperty
    bool hasDescription() const;
    /// Informative text to explain the property.
    std::string Description() const;
    void setDescription(std::string v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_STRING; case 1: return IfcUtil::Argument_STRING; } return IfcPropertyAbstraction::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcIdentifier; case 1: return Type::IfcText; } return IfcPropertyAbstraction::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Name"; case 1: return "Description"; } return IfcPropertyAbstraction::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcPropertySet >::ptr PartOfPset() const; // INVERSE IfcPropertySet::HasProperties
    IfcTemplatedEntityList< IfcPropertyDependencyRelationship >::ptr PropertyForDependance() const; // INVERSE IfcPropertyDependencyRelationship::DependingProperty
    IfcTemplatedEntityList< IfcPropertyDependencyRelationship >::ptr PropertyDependsOn() const; // INVERSE IfcPropertyDependencyRelationship::DependantProperty
    IfcTemplatedEntityList< IfcComplexProperty >::ptr PartOfComplex() const; // INVERSE IfcComplexProperty::HasProperties
    IfcTemplatedEntityList< IfcResourceConstraintRelationship >::ptr HasConstraints() const; // INVERSE IfcResourceConstraintRelationship::RelatedResourceObjects
    IfcTemplatedEntityList< IfcResourceApprovalRelationship >::ptr HasApprovals() const; // INVERSE IfcResourceApprovalRelationship::RelatedResourceObjects
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcProperty (IfcEntityInstanceData* e);
    IfcProperty (std::string v1_Name, boost::optional< std::string > v2_Description);
    typedef IfcTemplatedEntityList< IfcProperty > list;
};
/// IfcPropertyDefinition defines the generalization of
/// all characteristics (i.e. a grouping of individual properties),
/// that may be assigned to objects. Currently, subtypes of
/// IfcPropertyDefinition include property set occurrences,
/// property set templates, and property templates.
/// 
/// Property set template -
/// IfcPropertySetTemplate, a collection of property templates
/// that determine the definition of properties used within a project
/// context.
/// Property template -
/// IfcPropertyTemplate, a single template that determines the
/// definition of a particular property used in the same project
/// context. The template may determine the name, description, data
/// type, the unit, or a standard expression for each property that is
/// based on that template.
/// Property set occurrence -
/// IfcPropertySet, a set of individual properties (that may
/// or may not be determined by a property template) holding individual
/// values, measure types and units, and are associated to an object
/// occurrence or object type.
/// 
/// NOTE 1  The subtype hierarchy of IfcPropertyDefinition also includes statically defined property sets as IfcPreDefinedPropertySet. Those are rarely used collections of fixed attributes combined in an entity definition. The IfcPreDefinedPropertySet can not be determined by an IfcPropertySetTemplate.
/// 
/// NOTE 2  Individual properties, (subtypes of IfcProperty), are currently not included in the subtype hierarchy of IfcPropertyDefinition. This anomaly is due to upward compatibility reasons with earlier releases of this
/// standard.
/// 
/// HISTORY  New Entity in IFC2.0
/// 
/// Relationship use definition
/// Property definitions define information that is shared among
/// multiple instances of objects, either object occurrences or object
/// types. IfcPropertyDefinition's (by their instantiable
/// subtypes) can participated within the following relationships:
/// 
/// Assignment to a project context - an
/// HasContext relationship to IfcRelDeclares that
/// establishes the project context in which this property definition
/// is declared. This relationship is predominately applicable to
/// subtypes of IfcPropertyTemplateDefinition.
/// Association to external resources - an
/// HasAssociation relationship to IfcRelAssociates
/// that refers to external sources of information (most notably a
/// classification or document) and creates a uni-directional
/// association. There is no dependency implied by the
/// association.
/// 
/// Subtypes are included in more specific relationships, see
/// IfcPropertySetDefinition and
/// IfcPropertyTemplateDefinition for details.
class IFC_PARSE_API IfcPropertyDefinition : public IfcRoot {
public:
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcRoot::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcRoot::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcRoot::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcRelDeclares >::ptr HasContext() const; // INVERSE IfcRelDeclares::RelatedDefinitions
    IfcTemplatedEntityList< IfcRelAssociates >::ptr HasAssociations() const; // INVERSE IfcRelAssociates::RelatedObjects
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPropertyDefinition (IfcEntityInstanceData* e);
    IfcPropertyDefinition (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description);
    typedef IfcTemplatedEntityList< IfcPropertyDefinition > list;
};
/// An IfcPropertyDependencyRelationship describes an identified dependency between the value of one property and that of another.
/// 
/// HISTORY  New entity in IFC2x2
/// 
/// IFC2x4 CHANGE  Made subtype of IfcResourceLevelRelationship (attribute order changed).
/// 
/// Use Definition
/// Whilst the IfcPropertyDependencyRelationship may be used to describe the dependency, and it may do so in terms of the expression of how the dependency operates, it is not possible through the current IFC model for the value of the related property to be actually derived from the value of the relating property. The determination of value according to the dependency is required to be performed by an application that can then use the Expression attribute to flag the form of the dependency.
class IFC_PARSE_API IfcPropertyDependencyRelationship : public IfcResourceLevelRelationship {
public:
    /// The property on which the relationship depends.
    IfcProperty* DependingProperty() const;
    void setDependingProperty(IfcProperty* v);
    /// The dependant property.
    IfcProperty* DependantProperty() const;
    void setDependantProperty(IfcProperty* v);
    /// Whether the optional attribute Expression is defined for this IfcPropertyDependencyRelationship
    bool hasExpression() const;
    /// Expression that further describes the nature of the dependency relation.
    std::string Expression() const;
    void setExpression(std::string v);
    virtual unsigned int getArgumentCount() const { return 5; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 2: return IfcUtil::Argument_ENTITY_INSTANCE; case 3: return IfcUtil::Argument_ENTITY_INSTANCE; case 4: return IfcUtil::Argument_STRING; } return IfcResourceLevelRelationship::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 2: return Type::IfcProperty; case 3: return Type::IfcProperty; case 4: return Type::IfcText; } return IfcResourceLevelRelationship::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 2: return "DependingProperty"; case 3: return "DependantProperty"; case 4: return "Expression"; } return IfcResourceLevelRelationship::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPropertyDependencyRelationship (IfcEntityInstanceData* e);
    IfcPropertyDependencyRelationship (boost::optional< std::string > v1_Name, boost::optional< std::string > v2_Description, IfcProperty* v3_DependingProperty, IfcProperty* v4_DependantProperty, boost::optional< std::string > v5_Expression);
    typedef IfcTemplatedEntityList< IfcPropertyDependencyRelationship > list;
};
/// IfcPropertySetDefinition is a generalization of all
/// individual property sets that can be assigned to an object or type
/// object. The property set definition can be either:
/// 
/// Dynamically extendable property sets -
/// IfcPropertySet, a set of properties for which the IFC
/// model only provides a kind of "meta model", to be further declared
/// by agreement. This means no entity definition of the properties
/// exists within the IFC model. The declaration is done by assigning a
/// significant string value to the Name attribute of the
/// entity as defined in the entity IfcPropertySet and at each
/// subtype of IfcProperty, referenced by the property set.
/// Dynamically defined property sets may have an underlying template
/// provided by IfcPropertySetTemplate.
/// Statically defined property sets -
/// IfcPreDefinedPropertySet, a property set entity that
/// exists within the IFC specification. The semantic meaning of each
/// statically defined property set is declared by its entity type and
/// the meaning of the properties is defined by the name and data type
/// of the explicit attribute representing it.
/// 
/// HISTORY  New Entity in IFC Release 2x
/// 
/// IFC2x4 CHANGE  The subtype IfcPreDefinedPropertySet has been added.
/// 
/// Relationship use definition
/// Property set definitions define information that is shared among
/// multiple instances of objects, either object occurrences or object
/// types. IfcPropertySetDefinition's (by their instantiable
/// subtypes) can participated within the following relationships:
/// 
/// Assignment to object types - an
/// DefinesType direct relationship to IfcTypeObject
/// that applies the property set, with all included properties, to the
/// object type. Those properties apply to all object occurrences
/// having the same object type.
/// Assignment to object occurrences - an
/// DefinesOccurrence relationship to
/// IfcRelDefinesByProperties that applies the property set,
/// with all included properties, to the object occurrence.
/// 
/// NOTE  Properties assigned to object occurrences may override properties assigned to the object type. See IfcRelDefinesByType for further information.
class IFC_PARSE_API IfcPropertySetDefinition : public IfcPropertyDefinition {
public:
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcPropertyDefinition::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcPropertyDefinition::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcPropertyDefinition::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcTypeObject >::ptr DefinesType() const; // INVERSE IfcTypeObject::HasPropertySets
    IfcTemplatedEntityList< IfcRelDefinesByTemplate >::ptr IsDefinedBy() const; // INVERSE IfcRelDefinesByTemplate::RelatedPropertySets
    IfcTemplatedEntityList< IfcRelDefinesByProperties >::ptr DefinesOccurrence() const; // INVERSE IfcRelDefinesByProperties::RelatingPropertyDefinition
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPropertySetDefinition (IfcEntityInstanceData* e);
    IfcPropertySetDefinition (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description);
    typedef IfcTemplatedEntityList< IfcPropertySetDefinition > list;
};
/// IfcPropertyTemplateDefinition is a generalization of
/// all property and property set templates. Templates define the
/// collection, types, names, applicable measure types and units of
/// individual properties used in a project. The property template
/// definition can be either:
/// 
/// Property set template -
/// IfcPropertySetTemplate, a collection of property templates
/// that determine the definition of properties used within a project
/// context.
/// Property template -
/// IfcPropertyTemplate, a single template that determines the
/// definition of a particular property used in the same project
/// context. The template may determine the name, description, data
/// type, the unit, or a standard expression for each property that is
/// based on that template.
/// 
/// The subtypes of IfcPropertyTemplateDefinition are
/// declared within a project context. The uppermost template
/// definition (e.g. the IfcPropertySetTemplate including
/// several IfcPropertyTemplate's) should be related to the
/// context, either IfcProject, or IfcProjectLibrary,
/// using the inherited HasContext inverse attribute.
/// 
/// HISTORY  New Entity in IFC2x4.
class IFC_PARSE_API IfcPropertyTemplateDefinition : public IfcPropertyDefinition {
public:
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcPropertyDefinition::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcPropertyDefinition::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcPropertyDefinition::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPropertyTemplateDefinition (IfcEntityInstanceData* e);
    IfcPropertyTemplateDefinition (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description);
    typedef IfcTemplatedEntityList< IfcPropertyTemplateDefinition > list;
};

class IFC_PARSE_API IfcQuantitySet : public IfcPropertySetDefinition {
public:
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcPropertySetDefinition::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcPropertySetDefinition::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcPropertySetDefinition::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcQuantitySet (IfcEntityInstanceData* e);
    IfcQuantitySet (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description);
    typedef IfcTemplatedEntityList< IfcQuantitySet > list;
};
/// IfcRectangleProfileDef defines a rectangle as the profile definition used by the swept surface geometry or the swept area solid. It is given by its X extent and its Y extent, and placed within the 2D position coordinate system, established by the Position attribute. It is placed centric within the position coordinate system. 
/// 
/// HISTORY: New class in IFC 1.5. The use definition has changed in IFC Release 2x.
/// 
/// Figure 323 illustrates parameters of the rectangle profile definition.
/// 
/// Position
/// 
/// The parameterized profile defines its own position coordinate system.
/// The underlying
/// coordinate system is defined by the swept surface or swept area solid
/// that uses the profile definition. It is the xy plane of either: 
/// 
/// IfcSweptSurface.Position
///   IfcSweptAreaSolid.Position
/// 
/// or in case of sectioned spines the xy plane of each list member of IfcSectionedSpine.CrossSectionPositions.
/// 
/// By using offsets of the position location, the parameterized profile
/// can be positioned centric (using x,y offsets = 0.), or at any position
/// relative to the profile. Explicit coordinate offsets are used to define
/// cardinal points (for example, upper-left bound).
///   Parameter
/// 
/// The IfcRectangleProfileDef
/// is defined within the position
/// coordinate system, where the XDim
/// defines the length measure
/// for the length of the rectangle (half along the positive x-axis) and
/// the YDim
/// defines the length measure for the width of the
/// rectangle (half along the positive y-axis).
/// 
/// Figure 323 — Rectangle profile
class IFC_PARSE_API IfcRectangleProfileDef : public IfcParameterizedProfileDef {
public:
    /// The extent of the rectangle in the direction of the x-axis.
    double XDim() const;
    void setXDim(double v);
    /// The extent of the rectangle in the direction of the y-axis.
    double YDim() const;
    void setYDim(double v);
    virtual unsigned int getArgumentCount() const { return 5; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 3: return IfcUtil::Argument_DOUBLE; case 4: return IfcUtil::Argument_DOUBLE; } return IfcParameterizedProfileDef::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 3: return Type::IfcPositiveLengthMeasure; case 4: return Type::IfcPositiveLengthMeasure; } return IfcParameterizedProfileDef::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 3: return "XDim"; case 4: return "YDim"; } return IfcParameterizedProfileDef::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRectangleProfileDef (IfcEntityInstanceData* e);
    IfcRectangleProfileDef (IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< std::string > v2_ProfileName, IfcAxis2Placement2D* v3_Position, double v4_XDim, double v5_YDim);
    typedef IfcTemplatedEntityList< IfcRectangleProfileDef > list;
};
/// In a regular time series, the data arrives predictably at predefined intervals. In a regular time series there is no need to store multiple time stamps and the algorithms for analyzing the time series are therefore significantly simpler.  Using the start time provided in the supertype, the time step is used to identify the frequency of the occurrences of the list of values.
/// 
/// EXAMPLE: A smoke detector samples the concentration of particulates in a space at a fixed rate (for example, every six seconds); a control system measures the outside air temperature every hour.
/// 
/// HISTORY: New entity in IFC 2x2.
class IFC_PARSE_API IfcRegularTimeSeries : public IfcTimeSeries {
public:
    /// A duration of time intervals between values.
    double TimeStep() const;
    void setTimeStep(double v);
    /// The collection of time series values.
    IfcTemplatedEntityList< IfcTimeSeriesValue >::ptr Values() const;
    void setValues(IfcTemplatedEntityList< IfcTimeSeriesValue >::ptr v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_DOUBLE; case 9: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } return IfcTimeSeries::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcTimeMeasure; case 9: return Type::IfcTimeSeriesValue; } return IfcTimeSeries::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "TimeStep"; case 9: return "Values"; } return IfcTimeSeries::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRegularTimeSeries (IfcEntityInstanceData* e);
    IfcRegularTimeSeries (std::string v1_Name, boost::optional< std::string > v2_Description, std::string v3_StartTime, std::string v4_EndTime, IfcTimeSeriesDataTypeEnum::IfcTimeSeriesDataTypeEnum v5_TimeSeriesDataType, IfcDataOriginEnum::IfcDataOriginEnum v6_DataOrigin, boost::optional< std::string > v7_UserDefinedDataOrigin, IfcUnit* v8_Unit, double v9_TimeStep, IfcTemplatedEntityList< IfcTimeSeriesValue >::ptr v10_Values);
    typedef IfcTemplatedEntityList< IfcRegularTimeSeries > list;
};
/// IfcReinforcementProperties defines the set of properties for a specific combination of reinforcement bar steel grade, bar type and effective depth. 
/// 
/// HISTORY  New entity in IFC2x2.
/// 
/// The total cross section area for the specific steel grade is always provided. Additionally also general reinforcing bar configurations as a count of bars may be provided as defined in attribute BarCount. In this case the nominal bar diameter should be identical for all given bars as defined in attribute NominalBarDiameter.
class IFC_PARSE_API IfcReinforcementBarProperties : public IfcPreDefinedProperties {
public:
    /// The total effective cross-section area of the reinforcement of a specific steel grade.
    double TotalCrossSectionArea() const;
    void setTotalCrossSectionArea(double v);
    /// The nominal steel grade defined according to local standards.
    std::string SteelGrade() const;
    void setSteelGrade(std::string v);
    /// Whether the optional attribute BarSurface is defined for this IfcReinforcementBarProperties
    bool hasBarSurface() const;
    /// Indicator for whether the bar surface is plain or textured.
    IfcReinforcingBarSurfaceEnum::IfcReinforcingBarSurfaceEnum BarSurface() const;
    void setBarSurface(IfcReinforcingBarSurfaceEnum::IfcReinforcingBarSurfaceEnum v);
    /// Whether the optional attribute EffectiveDepth is defined for this IfcReinforcementBarProperties
    bool hasEffectiveDepth() const;
    /// The effective depth, i.e. the distance of the specific reinforcement cross section area or reinforcement configuration in a row, counted from a common specific reference point. Usually the reference point is the upper surface (for beams and slabs) or a similar projection in a plane (for columns).
    double EffectiveDepth() const;
    void setEffectiveDepth(double v);
    /// Whether the optional attribute NominalBarDiameter is defined for this IfcReinforcementBarProperties
    bool hasNominalBarDiameter() const;
    /// The nominal diameter defining the cross-section size of the reinforcing bar. The bar diameter should be identical for all bars included in the specific reinforcement configuration.
    double NominalBarDiameter() const;
    void setNominalBarDiameter(double v);
    /// Whether the optional attribute BarCount is defined for this IfcReinforcementBarProperties
    bool hasBarCount() const;
    /// The number of bars with identical nominal diameter and steel grade included in the specific reinforcement configuration.
    double BarCount() const;
    void setBarCount(double v);
    virtual unsigned int getArgumentCount() const { return 6; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_DOUBLE; case 1: return IfcUtil::Argument_STRING; case 2: return IfcUtil::Argument_ENUMERATION; case 3: return IfcUtil::Argument_DOUBLE; case 4: return IfcUtil::Argument_DOUBLE; case 5: return IfcUtil::Argument_DOUBLE; } return IfcPreDefinedProperties::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcAreaMeasure; case 1: return Type::IfcLabel; case 2: return Type::IfcReinforcingBarSurfaceEnum; case 3: return Type::IfcLengthMeasure; case 4: return Type::IfcPositiveLengthMeasure; case 5: return Type::IfcCountMeasure; } return IfcPreDefinedProperties::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "TotalCrossSectionArea"; case 1: return "SteelGrade"; case 2: return "BarSurface"; case 3: return "EffectiveDepth"; case 4: return "NominalBarDiameter"; case 5: return "BarCount"; } return IfcPreDefinedProperties::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcReinforcementBarProperties (IfcEntityInstanceData* e);
    IfcReinforcementBarProperties (double v1_TotalCrossSectionArea, std::string v2_SteelGrade, boost::optional< IfcReinforcingBarSurfaceEnum::IfcReinforcingBarSurfaceEnum > v3_BarSurface, boost::optional< double > v4_EffectiveDepth, boost::optional< double > v5_NominalBarDiameter, boost::optional< double > v6_BarCount);
    typedef IfcTemplatedEntityList< IfcReinforcementBarProperties > list;
};
/// IfcRelationship is the abstract generalization of all objectified relationships in IFC. Objectified relationships are the preferred way to handle relationships among objects. This allows to keep relationship specific properties directly at the relationship and opens the possibility to later handle relationship specific behavior.  
/// 
/// There are two different types of relationships, 1-to-1 relationships and 1-to-many relationship. used within the subtypes of IfcRelationship. The following convention applies to all subtypes: 
/// 
/// The two sides of the objectified relationship are named - Relating+ and - Related+ 
/// In case of the 1-to-many relationship, the related side of the relationship shall be an aggregate SET 1:N 
/// 
/// HISTORY: New entity in IFC Release 1.0.
class IFC_PARSE_API IfcRelationship : public IfcRoot {
public:
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcRoot::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcRoot::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcRoot::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRelationship (IfcEntityInstanceData* e);
    IfcRelationship (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description);
    typedef IfcTemplatedEntityList< IfcRelationship > list;
};
/// An IfcResourceApprovalRelationship is used for
/// associating an approval to resource objects. A single approval
/// might be given to one or many items via IfcResourceObjectSelect.
/// 
/// HISTORY  New
/// Entity in IFC Release 2x4
class IFC_PARSE_API IfcResourceApprovalRelationship : public IfcResourceLevelRelationship {
public:
    /// Resource objects that are approved.
    IfcEntityList::ptr RelatedResourceObjects() const;
    void setRelatedResourceObjects(IfcEntityList::ptr v);
    /// The approval for the resource objects selected.
    IfcApproval* RelatingApproval() const;
    void setRelatingApproval(IfcApproval* v);
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 2: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 3: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcResourceLevelRelationship::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 2: return Type::IfcResourceObjectSelect; case 3: return Type::IfcApproval; } return IfcResourceLevelRelationship::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 2: return "RelatedResourceObjects"; case 3: return "RelatingApproval"; } return IfcResourceLevelRelationship::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcResourceApprovalRelationship (IfcEntityInstanceData* e);
    IfcResourceApprovalRelationship (boost::optional< std::string > v1_Name, boost::optional< std::string > v2_Description, IfcEntityList::ptr v3_RelatedResourceObjects, IfcApproval* v4_RelatingApproval);
    typedef IfcTemplatedEntityList< IfcResourceApprovalRelationship > list;
};
/// An IfcResourceConstraintRelationship is a relationship
/// entity that enables a constraint to be related to one or more
/// resource level objects.
/// 
/// HISTORY  New Entity in Release IFC2x2.
/// 
/// IFC2x4 CHANGE  Renamed from IfcPropertyConstraintRelationship and extended to apply to all resource level entities.  Subtyped from IfcResourceLevelRelationship.
/// 
/// Use definition
/// 
/// An IfcResourceConstraintRelationship allows for the
/// specification of a constraint to be applied to many entity types.
/// An important case is to apply constraints to properties. The
/// constraints applied therefore enable a property to carry values
/// identifying requirements as well as those identifying the
/// fulfilment of those requirements.
/// 
/// Figure 238 shows how a constraint may be applied to a property within a property set. For simplicity, only the mandatory attributes are shown as asserted. It shows how a property 'ThingWeight' which has a nominal value of 19.5 kg has two constraints that are logically aggregated by an AND connection. One of the constraints has a benchmark of 'GREATERTHANOREQUALTO' whilst the second has a benchmark of 'LESSTHANOREQUALTO'. This means that the constraint must lie between these two bounding values. The relating constraint is instantiated as an objective named as 'Weight Constraint' and qualified as a SPECIFICATION constraint. The two related constraints are both specified as metrics since they can have specific values.
/// 
/// Figure 238 — Resource constraint relationship
class IFC_PARSE_API IfcResourceConstraintRelationship : public IfcResourceLevelRelationship {
public:
    /// The constraint that is to be related.
    IfcConstraint* RelatingConstraint() const;
    void setRelatingConstraint(IfcConstraint* v);
    /// The properties to which a constraint is to be related.
    IfcEntityList::ptr RelatedResourceObjects() const;
    void setRelatedResourceObjects(IfcEntityList::ptr v);
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 2: return IfcUtil::Argument_ENTITY_INSTANCE; case 3: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } return IfcResourceLevelRelationship::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 2: return Type::IfcConstraint; case 3: return Type::IfcResourceObjectSelect; } return IfcResourceLevelRelationship::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 2: return "RelatingConstraint"; case 3: return "RelatedResourceObjects"; } return IfcResourceLevelRelationship::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcResourceConstraintRelationship (IfcEntityInstanceData* e);
    IfcResourceConstraintRelationship (boost::optional< std::string > v1_Name, boost::optional< std::string > v2_Description, IfcConstraint* v3_RelatingConstraint, IfcEntityList::ptr v4_RelatedResourceObjects);
    typedef IfcTemplatedEntityList< IfcResourceConstraintRelationship > list;
};
/// IfcResourceTime captures the time-related information about a construction resource.
///   HISTORY: New entity in IFC2x4.
class IFC_PARSE_API IfcResourceTime : public IfcSchedulingTime {
public:
    /// Whether the optional attribute ScheduleWork is defined for this IfcResourceTime
    bool hasScheduleWork() const;
    /// Indicates the total work (e.g. person-hours) allocated to the task on behalf of the resource. 
    /// Note: this is not necessarily the same as the task duration (IfcTaskTime.ScheduleDuration); it may vary according to the resource usage ratio and other resources assigned to the task.
    std::string ScheduleWork() const;
    void setScheduleWork(std::string v);
    /// Whether the optional attribute ScheduleUsage is defined for this IfcResourceTime
    bool hasScheduleUsage() const;
    /// Indicates the amount of the resource used concurrently. For example, 100% means 1 worker, 300% means 3 workers, 50% means half of 1 worker's time for scenarios where multitasking is feasible. If not provided, then the usage ratio is considered to be 100%.
    double ScheduleUsage() const;
    void setScheduleUsage(double v);
    /// Whether the optional attribute ScheduleStart is defined for this IfcResourceTime
    bool hasScheduleStart() const;
    /// Indicates the time when the resource is scheduled to start working.
    std::string ScheduleStart() const;
    void setScheduleStart(std::string v);
    /// Whether the optional attribute ScheduleFinish is defined for this IfcResourceTime
    bool hasScheduleFinish() const;
    /// Indicates the time when the resource is scheduled to finish working.
    std::string ScheduleFinish() const;
    void setScheduleFinish(std::string v);
    /// Whether the optional attribute ScheduleContour is defined for this IfcResourceTime
    bool hasScheduleContour() const;
    /// Indicates how a resource should be leveled over time by adjusting the resource usage according to a specified curve.  Standard values include: 'Flat', 'BackLoaded', 'FrontLoaded', 'DoublePeak', 'EarlyPeak', 'LatePeak', 'Bell', and 'Turtle'.  Custom values may specify a custom name or formula.
    std::string ScheduleContour() const;
    void setScheduleContour(std::string v);
    /// Whether the optional attribute LevelingDelay is defined for this IfcResourceTime
    bool hasLevelingDelay() const;
    /// Indicates a delay in the ScheduleStart caused by leveling.
    std::string LevelingDelay() const;
    void setLevelingDelay(std::string v);
    /// Whether the optional attribute IsOverAllocated is defined for this IfcResourceTime
    bool hasIsOverAllocated() const;
    /// Indicates that the resource is scheduled in excess of its capacity.
    bool IsOverAllocated() const;
    void setIsOverAllocated(bool v);
    /// Whether the optional attribute StatusTime is defined for this IfcResourceTime
    bool hasStatusTime() const;
    /// Indicates the date and time for which status values are applicable; particularly completion, actual, and remaining values.  If values are time-phased (the referencing IfcConstructionResource has associated time series values for attributes), then the status values may be determined from such time-phased data as of the StatusTime.
    std::string StatusTime() const;
    void setStatusTime(std::string v);
    /// Whether the optional attribute ActualWork is defined for this IfcResourceTime
    bool hasActualWork() const;
    /// Indicates the actual work performed by the resource as of the StatusTime.
    std::string ActualWork() const;
    void setActualWork(std::string v);
    /// Whether the optional attribute ActualUsage is defined for this IfcResourceTime
    bool hasActualUsage() const;
    /// Indicates the actual amount of the resource used concurrently.
    double ActualUsage() const;
    void setActualUsage(double v);
    /// Whether the optional attribute ActualStart is defined for this IfcResourceTime
    bool hasActualStart() const;
    /// Indicates the time when the resource actually started working.
    std::string ActualStart() const;
    void setActualStart(std::string v);
    /// Whether the optional attribute ActualFinish is defined for this IfcResourceTime
    bool hasActualFinish() const;
    /// Indicates the time when the resource actually finished working.
    std::string ActualFinish() const;
    void setActualFinish(std::string v);
    /// Whether the optional attribute RemainingWork is defined for this IfcResourceTime
    bool hasRemainingWork() const;
    /// Indicates the work remaining to be completed by the resource.
    std::string RemainingWork() const;
    void setRemainingWork(std::string v);
    /// Whether the optional attribute RemainingUsage is defined for this IfcResourceTime
    bool hasRemainingUsage() const;
    double RemainingUsage() const;
    void setRemainingUsage(double v);
    /// Whether the optional attribute Completion is defined for this IfcResourceTime
    bool hasCompletion() const;
    /// Indicates the percent completion of this resource.  If the resource is assigned to a task, then indicates completion of the task on behalf of the resource; if the resource is partitioned into sub-allocations, then indicates overall completion of sub-allocations.
    double Completion() const;
    void setCompletion(double v);
    virtual unsigned int getArgumentCount() const { return 18; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 3: return IfcUtil::Argument_STRING; case 4: return IfcUtil::Argument_DOUBLE; case 5: return IfcUtil::Argument_STRING; case 6: return IfcUtil::Argument_STRING; case 7: return IfcUtil::Argument_STRING; case 8: return IfcUtil::Argument_STRING; case 9: return IfcUtil::Argument_BOOL; case 10: return IfcUtil::Argument_STRING; case 11: return IfcUtil::Argument_STRING; case 12: return IfcUtil::Argument_DOUBLE; case 13: return IfcUtil::Argument_STRING; case 14: return IfcUtil::Argument_STRING; case 15: return IfcUtil::Argument_STRING; case 16: return IfcUtil::Argument_DOUBLE; case 17: return IfcUtil::Argument_DOUBLE; } return IfcSchedulingTime::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 3: return Type::IfcDuration; case 4: return Type::IfcPositiveRatioMeasure; case 5: return Type::IfcDateTime; case 6: return Type::IfcDateTime; case 7: return Type::IfcLabel; case 8: return Type::IfcDuration; case 9: return Type::IfcBoolean; case 10: return Type::IfcDateTime; case 11: return Type::IfcDuration; case 12: return Type::IfcPositiveRatioMeasure; case 13: return Type::IfcDateTime; case 14: return Type::IfcDateTime; case 15: return Type::IfcDuration; case 16: return Type::IfcPositiveRatioMeasure; case 17: return Type::IfcPositiveRatioMeasure; } return IfcSchedulingTime::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 3: return "ScheduleWork"; case 4: return "ScheduleUsage"; case 5: return "ScheduleStart"; case 6: return "ScheduleFinish"; case 7: return "ScheduleContour"; case 8: return "LevelingDelay"; case 9: return "IsOverAllocated"; case 10: return "StatusTime"; case 11: return "ActualWork"; case 12: return "ActualUsage"; case 13: return "ActualStart"; case 14: return "ActualFinish"; case 15: return "RemainingWork"; case 16: return "RemainingUsage"; case 17: return "Completion"; } return IfcSchedulingTime::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcResourceTime (IfcEntityInstanceData* e);
    IfcResourceTime (boost::optional< std::string > v1_Name, boost::optional< IfcDataOriginEnum::IfcDataOriginEnum > v2_DataOrigin, boost::optional< std::string > v3_UserDefinedDataOrigin, boost::optional< std::string > v4_ScheduleWork, boost::optional< double > v5_ScheduleUsage, boost::optional< std::string > v6_ScheduleStart, boost::optional< std::string > v7_ScheduleFinish, boost::optional< std::string > v8_ScheduleContour, boost::optional< std::string > v9_LevelingDelay, boost::optional< bool > v10_IsOverAllocated, boost::optional< std::string > v11_StatusTime, boost::optional< std::string > v12_ActualWork, boost::optional< double > v13_ActualUsage, boost::optional< std::string > v14_ActualStart, boost::optional< std::string > v15_ActualFinish, boost::optional< std::string > v16_RemainingWork, boost::optional< double > v17_RemainingUsage, boost::optional< double > v18_Completion);
    typedef IfcTemplatedEntityList< IfcResourceTime > list;
};
/// IfcRoundedRectangleProfileDef defines a rectangle with equally rounded corners as the profile definition used by the swept surface geometry or the swept area solid. It is given by the X extent, the Y extent, and the radius for the rounded corners, and placed within the 2D position coordinate system, established by the Position attribute. It is placed centric within the position coordinate system, that is, in the center of the bounding box.
/// 
/// HISTORY  New class in IFC2x.
/// 
/// IFC2x PLATFORM CHANGE  The IfcRoundedRectangleProfileDef is now subtyped from IfcRectangleProfileDef. The XDim and YDim attributes have been removed (now inherited from supertype).
/// 
/// Figure 324 illustrates parameters of the rounded rectangle profile definition.
/// 
/// Position
/// 
/// The parameterized profile defines its own position coordinate system.
/// The underlying
/// coordinate system is defined by the swept surface or swept area solid
/// that uses the profile definition. It is the xy plane of either: 
/// 
/// IfcSweptSurface.Position
///   IfcSweptAreaSolid.Position
/// 
/// or in case of sectioned spines the xy plane of each list member of IfcSectionedSpine.CrossSectionPositions.
/// 
/// By using offsets of the position location, the parameterized profile
/// can be positioned centric (using x,y offsets = 0.), or at any position
/// relative to the profile. Explicit coordinate offsets are used to define
/// cardinal points (e.g. upper-left bound).
///   Parameter
/// 
/// The IfcRoundedRectangleProfileDef
/// is defined within the
/// position coordinate system, where the XDim
/// defines the measure
/// for the length of the rectangle (half along the positive x-axis), the YDim
/// defines the length measure for the width of the rectangle (half along
/// the positive y-axis) and the RoundingRadius
/// defines the radius
/// of curvature in all four corners of the rectangle.
/// 
/// Figure 324 — Rounded rectangle profile
class IFC_PARSE_API IfcRoundedRectangleProfileDef : public IfcRectangleProfileDef {
public:
    /// Radius of the circular arcs by which all four corners of the rectangle are equally rounded.
    double RoundingRadius() const;
    void setRoundingRadius(double v);
    virtual unsigned int getArgumentCount() const { return 6; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 5: return IfcUtil::Argument_DOUBLE; } return IfcRectangleProfileDef::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 5: return Type::IfcPositiveLengthMeasure; } return IfcRectangleProfileDef::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 5: return "RoundingRadius"; } return IfcRectangleProfileDef::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRoundedRectangleProfileDef (IfcEntityInstanceData* e);
    IfcRoundedRectangleProfileDef (IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< std::string > v2_ProfileName, IfcAxis2Placement2D* v3_Position, double v4_XDim, double v5_YDim, double v6_RoundingRadius);
    typedef IfcTemplatedEntityList< IfcRoundedRectangleProfileDef > list;
};
/// IfcSectionProperties defines the cross section properties for a single longitudinal piece of a cross section.  It is a special-purpose helper class for IfcSectionReinforcementProperties.
/// 
/// HISTORY  New entity in IFC2x2.
/// 
/// The section piece may be either uniform or tapered. In the latter case an end profile should also be provided. The start and end profiles are assumed to be of the same profile type. Generally only rectangular or circular cross section profiles are assumed to be used.
class IFC_PARSE_API IfcSectionProperties : public IfcPreDefinedProperties {
public:
    /// An indicator whether a specific piece of a cross section is uniform or tapered in longitudinal direction.
    IfcSectionTypeEnum::IfcSectionTypeEnum SectionType() const;
    void setSectionType(IfcSectionTypeEnum::IfcSectionTypeEnum v);
    /// The cross section profile at the start point of the longitudinal section.
    IfcProfileDef* StartProfile() const;
    void setStartProfile(IfcProfileDef* v);
    /// Whether the optional attribute EndProfile is defined for this IfcSectionProperties
    bool hasEndProfile() const;
    /// The cross section profile at the end point of the longitudinal section.
    IfcProfileDef* EndProfile() const;
    void setEndProfile(IfcProfileDef* v);
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENUMERATION; case 1: return IfcUtil::Argument_ENTITY_INSTANCE; case 2: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcPreDefinedProperties::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcSectionTypeEnum; case 1: return Type::IfcProfileDef; case 2: return Type::IfcProfileDef; } return IfcPreDefinedProperties::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "SectionType"; case 1: return "StartProfile"; case 2: return "EndProfile"; } return IfcPreDefinedProperties::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcSectionProperties (IfcEntityInstanceData* e);
    IfcSectionProperties (IfcSectionTypeEnum::IfcSectionTypeEnum v1_SectionType, IfcProfileDef* v2_StartProfile, IfcProfileDef* v3_EndProfile);
    typedef IfcTemplatedEntityList< IfcSectionProperties > list;
};
/// IfcSectionReinforcementProperties defines the cross section properties of reinforcement for a single longitudinal piece of a cross section with a specific reinforcement usage type.  
/// 
/// HISTORY  New entity in IFC2x2.
/// 
/// Several sets of cross section reinforcement properties represented by instances of IfcReinforcementProperties may be attached to the section reinforcement properties
/// (IfcReinforcementDefinitionProperties of IfcStructuralElementsDomain schema),
/// one for each combination of steel grades and reinforcement bar types and sizes.
class IFC_PARSE_API IfcSectionReinforcementProperties : public IfcPreDefinedProperties {
public:
    /// The start position in longitudinal direction for the section reinforcement properties.
    double LongitudinalStartPosition() const;
    void setLongitudinalStartPosition(double v);
    /// The end position in longitudinal direction for the section reinforcement properties.
    double LongitudinalEndPosition() const;
    void setLongitudinalEndPosition(double v);
    /// Whether the optional attribute TransversePosition is defined for this IfcSectionReinforcementProperties
    bool hasTransversePosition() const;
    /// The position for the section reinforcement properties in transverse direction.
    double TransversePosition() const;
    void setTransversePosition(double v);
    /// The role, purpose or usage of the reinforcement, i.e. the kind of loads and stresses it is intended to carry, defined for the section reinforcement properties.
    IfcReinforcingBarRoleEnum::IfcReinforcingBarRoleEnum ReinforcementRole() const;
    void setReinforcementRole(IfcReinforcingBarRoleEnum::IfcReinforcingBarRoleEnum v);
    /// Definition of the cross section profile and longitudinal section type.
    IfcSectionProperties* SectionDefinition() const;
    void setSectionDefinition(IfcSectionProperties* v);
    /// The set of reinforcment properties attached to a section reinforcement properties definition.
    IfcTemplatedEntityList< IfcReinforcementBarProperties >::ptr CrossSectionReinforcementDefinitions() const;
    void setCrossSectionReinforcementDefinitions(IfcTemplatedEntityList< IfcReinforcementBarProperties >::ptr v);
    virtual unsigned int getArgumentCount() const { return 6; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_DOUBLE; case 1: return IfcUtil::Argument_DOUBLE; case 2: return IfcUtil::Argument_DOUBLE; case 3: return IfcUtil::Argument_ENUMERATION; case 4: return IfcUtil::Argument_ENTITY_INSTANCE; case 5: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } return IfcPreDefinedProperties::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcLengthMeasure; case 1: return Type::IfcLengthMeasure; case 2: return Type::IfcLengthMeasure; case 3: return Type::IfcReinforcingBarRoleEnum; case 4: return Type::IfcSectionProperties; case 5: return Type::IfcReinforcementBarProperties; } return IfcPreDefinedProperties::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "LongitudinalStartPosition"; case 1: return "LongitudinalEndPosition"; case 2: return "TransversePosition"; case 3: return "ReinforcementRole"; case 4: return "SectionDefinition"; case 5: return "CrossSectionReinforcementDefinitions"; } return IfcPreDefinedProperties::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcSectionReinforcementProperties (IfcEntityInstanceData* e);
    IfcSectionReinforcementProperties (double v1_LongitudinalStartPosition, double v2_LongitudinalEndPosition, boost::optional< double > v3_TransversePosition, IfcReinforcingBarRoleEnum::IfcReinforcingBarRoleEnum v4_ReinforcementRole, IfcSectionProperties* v5_SectionDefinition, IfcTemplatedEntityList< IfcReinforcementBarProperties >::ptr v6_CrossSectionReinforcementDefinitions);
    typedef IfcTemplatedEntityList< IfcSectionReinforcementProperties > list;
};
/// Definition from ISO 10303-42:1999: A sectioned
/// spine is a representation of the shape of a three dimensional
/// object composed of a spine curve and a number of planar cross
/// sections. The shape is defined between the first element of cross
/// sections and the last element of this set.
/// 
/// NOTE A sectioned spine may be used to represent a surface or a
/// solid but the interpolation of the shape between the
/// cross-sections is not defined. For the representation of a solid
/// all cross-sections are closed curves.
/// 
/// A sectioned spine
/// (IfcSectionedSpine) is a representation of the shape of a
/// three dimensional object composed by a number of planar cross
/// sections, and a spine curve. The shape is defined between the
/// first element of cross sections and the last element of the cross
/// sections. A sectioned spine may be used to represent a surface or
/// a solid but the interpolation of the shape between the cross
/// sections is not defined.
/// For the representation of a solid all cross sections are
/// areas. For representation of a surface all cross sections are
/// curves. The cross sections are defined as profiles, whereas the
/// consecutive profiles may be derived by a transformation of the
/// start profile or the previous consecutive profile.
/// The spine curve shall be of type IfcCompositeCurve,
/// each of its segments (IfcCompositeCurveSegment) shall
/// correspond to the part between exactly two consecutive
/// cross-sections.
/// 
/// NOTE: Corresponding ISO 10303 entity: sectioned spine. Please refer to ISO/DIS 10303-42-ed2:1999, p. 282 for the definition of the formal standard. The cross sections are defined in IFC as IfcProfileDef. The position coordinate systems are added.
/// 
/// HISTORY New entity in IFC Release 2x.
/// 
/// Figure 268 illustrates an example of an IfcSectionedSpine.
/// 
/// The SpineCurve is given by an IfcCompositeCurve with two Segments. The Segments[1] has a ParentCurve of type IfcPolyline and a Transition = CONTSAMEGRADIENT. The Segments[2] has a ParentCurve of type
/// IfcTrimmedCurve and a Transition = DISCONTINUOUS.
/// Each CrossSectionPosition lies at a start or end point of the Segments.
/// Each CrossSections are inserted by the CrossSectionPositions. The first two cross sections are of
/// type IfcRectangleProfileDef, the third is of type IfcDerivedProfileDef.
/// 
/// Figure 268 — Sectioned spine geometry
/// 
/// Figure 269 illustrates the final result of the IfcSectionedSpine. The body (shown transparently) is not fully defined by the
/// exchange definition.
/// 
/// Figure 269 — Sectioned spine result
/// 
/// Informal propositions
/// 
/// none of the cross sections, after being placed by the cross section positions, shall intersect
/// none of the cross sections, after being placed by the cross section positions, shall lie in the same plane
/// the local origin of each cross section position shall lie at the beginning or end of a composite curve segment.
class IFC_PARSE_API IfcSectionedSpine : public IfcGeometricRepresentationItem {
public:
    /// A single composite curve, that defines the spine curve. Each of the composite curve segments correspond to the part between two cross-sections.
    IfcCompositeCurve* SpineCurve() const;
    void setSpineCurve(IfcCompositeCurve* v);
    /// A list of at least two cross sections, each defined within the xy plane of the position coordinate system of the cross section. The position coordinate system is given by the corresponding list CrossSectionPositions.
    IfcTemplatedEntityList< IfcProfileDef >::ptr CrossSections() const;
    void setCrossSections(IfcTemplatedEntityList< IfcProfileDef >::ptr v);
    /// Position coordinate systems for the cross sections that form the sectioned spine. The profiles defining the cross sections are positioned within the xy plane of the corresponding position coordinate system.
    IfcTemplatedEntityList< IfcAxis2Placement3D >::ptr CrossSectionPositions() const;
    void setCrossSectionPositions(IfcTemplatedEntityList< IfcAxis2Placement3D >::ptr v);
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 2: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } return IfcGeometricRepresentationItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcCompositeCurve; case 1: return Type::IfcProfileDef; case 2: return Type::IfcAxis2Placement3D; } return IfcGeometricRepresentationItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "SpineCurve"; case 1: return "CrossSections"; case 2: return "CrossSectionPositions"; } return IfcGeometricRepresentationItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcSectionedSpine (IfcEntityInstanceData* e);
    IfcSectionedSpine (IfcCompositeCurve* v1_SpineCurve, IfcTemplatedEntityList< IfcProfileDef >::ptr v2_CrossSections, IfcTemplatedEntityList< IfcAxis2Placement3D >::ptr v3_CrossSectionPositions);
    typedef IfcTemplatedEntityList< IfcSectionedSpine > list;
};
/// Definition from ISO/CD 10303-42:1992: A shell based surface model is described by a set of open or closed shells of dimensionality 2. The shells shall not intersect except at edges and vertices. In particular, distinct faces may not intersect. A complete face of one shell may be shared with another shell. Coincident portions of shells shall both reference the same faces, edges and vertices defining the coincident region. There shall be at least one shell. 
/// 
/// A shell may exist independently of a surface model. 
/// 
/// NOTE Corresponding ISO 10303-42 entity: shell_based_surface_model. Please refer to ISO/IS 10303-42:1994, p. 187 for the final definition of the formal standard.
/// 
/// HISTORY: New entity in IFC Release 2x.
/// 
/// Informal propositions 
/// 
/// The dimensionality of the shell based surface model is 2.  
/// The shells shall not overlap or intersect except at common faces, edges or vertices.
class IFC_PARSE_API IfcShellBasedSurfaceModel : public IfcGeometricRepresentationItem {
public:
    IfcEntityList::ptr SbsmBoundary() const;
    void setSbsmBoundary(IfcEntityList::ptr v);
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } return IfcGeometricRepresentationItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcShell; } return IfcGeometricRepresentationItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "SbsmBoundary"; } return IfcGeometricRepresentationItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcShellBasedSurfaceModel (IfcEntityInstanceData* e);
    IfcShellBasedSurfaceModel (IfcEntityList::ptr v1_SbsmBoundary);
    typedef IfcTemplatedEntityList< IfcShellBasedSurfaceModel > list;
};
/// IfcSimpleProperty is a generalization of a single property object. The various subtypes of IfcSimpleProperty establish different ways in which a property value can be set. 
/// 
/// HISTORY  New Entity in IFC Release 1.0, definition changed in IFC Release 2x.
class IFC_PARSE_API IfcSimpleProperty : public IfcProperty {
public:
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcProperty::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcProperty::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcProperty::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcSimpleProperty (IfcEntityInstanceData* e);
    IfcSimpleProperty (std::string v1_Name, boost::optional< std::string > v2_Description);
    typedef IfcTemplatedEntityList< IfcSimpleProperty > list;
};
/// Definition from IAI: Describes slippage in support conditions or connection conditions.  Slippage means that a relative displacement may occur in a support or connection before support or connection reactions are awoken.
/// 
/// Applicability:
/// 
/// Point supports and connections,
///   curve supports and connections,
///   surface supports and connections.
/// 
/// HISTORY: New entity in IFC 2x2.
class IFC_PARSE_API IfcSlippageConnectionCondition : public IfcStructuralConnectionCondition {
public:
    /// Whether the optional attribute SlippageX is defined for this IfcSlippageConnectionCondition
    bool hasSlippageX() const;
    /// Slippage in x-direction of the coordinate system defined by the instance which uses this resource object.
    double SlippageX() const;
    void setSlippageX(double v);
    /// Whether the optional attribute SlippageY is defined for this IfcSlippageConnectionCondition
    bool hasSlippageY() const;
    /// Slippage in y-direction of the coordinate system defined by the instance which uses this resource object.
    double SlippageY() const;
    void setSlippageY(double v);
    /// Whether the optional attribute SlippageZ is defined for this IfcSlippageConnectionCondition
    bool hasSlippageZ() const;
    /// Slippage in z-direction of the coordinate system defined by the instance which uses this resource object.
    double SlippageZ() const;
    void setSlippageZ(double v);
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 1: return IfcUtil::Argument_DOUBLE; case 2: return IfcUtil::Argument_DOUBLE; case 3: return IfcUtil::Argument_DOUBLE; } return IfcStructuralConnectionCondition::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 1: return Type::IfcLengthMeasure; case 2: return Type::IfcLengthMeasure; case 3: return Type::IfcLengthMeasure; } return IfcStructuralConnectionCondition::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 1: return "SlippageX"; case 2: return "SlippageY"; case 3: return "SlippageZ"; } return IfcStructuralConnectionCondition::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcSlippageConnectionCondition (IfcEntityInstanceData* e);
    IfcSlippageConnectionCondition (boost::optional< std::string > v1_Name, boost::optional< double > v2_SlippageX, boost::optional< double > v3_SlippageY, boost::optional< double > v4_SlippageZ);
    typedef IfcTemplatedEntityList< IfcSlippageConnectionCondition > list;
};
/// Definition from ISO/CD 10303-42:1992: A solid model is a complete representation of the nominal shape of a product such that all points in the interior are connected. Any point can be classified as being inside, outside, or on the boundary of a solid. There are several different types of solid model representations. 
/// 
/// NOTE: Corresponding ISO 10303-42 entity: solid_model, only three subtypes have been incorporated into the current IFC Release - subset of manifold_solid_brep (IfcManifoldSolidBrep, constraint to faceted B-rep), swept_area_solid (IfcSweptAreaSolid), the swept_disk_solid (IfcSweptDiskSolid) and subset of csg_solid (IfcCsgSolid). The derived attribute Dim has been added at this level and was therefore demoted from the geometric_representation_item. Please refer to ISO/IS 10303-42:1994, p. 170 for the final definition of the formal standard.
/// 
/// HISTORY: New entity in IFC Release 1.5
class IFC_PARSE_API IfcSolidModel : public IfcGeometricRepresentationItem {
public:
    virtual unsigned int getArgumentCount() const { return 0; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcGeometricRepresentationItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcGeometricRepresentationItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcGeometricRepresentationItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcSolidModel (IfcEntityInstanceData* e);
    IfcSolidModel ();
    typedef IfcTemplatedEntityList< IfcSolidModel > list;
};
/// Definition from IAI: An instance of the entity
///   IfcStructuralLoadLinearForce shall be used to define actions on curves.
/// 
/// HISTORY: New entity in Release IFC2x
///   edition 2.
class IFC_PARSE_API IfcStructuralLoadLinearForce : public IfcStructuralLoadStatic {
public:
    /// Whether the optional attribute LinearForceX is defined for this IfcStructuralLoadLinearForce
    bool hasLinearForceX() const;
    /// Linear force value in x-direction.
    double LinearForceX() const;
    void setLinearForceX(double v);
    /// Whether the optional attribute LinearForceY is defined for this IfcStructuralLoadLinearForce
    bool hasLinearForceY() const;
    /// Linear force value in y-direction.
    double LinearForceY() const;
    void setLinearForceY(double v);
    /// Whether the optional attribute LinearForceZ is defined for this IfcStructuralLoadLinearForce
    bool hasLinearForceZ() const;
    /// Linear force value in z-direction.
    double LinearForceZ() const;
    void setLinearForceZ(double v);
    /// Whether the optional attribute LinearMomentX is defined for this IfcStructuralLoadLinearForce
    bool hasLinearMomentX() const;
    /// Linear moment about the x-axis.
    double LinearMomentX() const;
    void setLinearMomentX(double v);
    /// Whether the optional attribute LinearMomentY is defined for this IfcStructuralLoadLinearForce
    bool hasLinearMomentY() const;
    /// Linear moment about the y-axis.
    double LinearMomentY() const;
    void setLinearMomentY(double v);
    /// Whether the optional attribute LinearMomentZ is defined for this IfcStructuralLoadLinearForce
    bool hasLinearMomentZ() const;
    /// Linear moment about the z-axis.
    double LinearMomentZ() const;
    void setLinearMomentZ(double v);
    virtual unsigned int getArgumentCount() const { return 7; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 1: return IfcUtil::Argument_DOUBLE; case 2: return IfcUtil::Argument_DOUBLE; case 3: return IfcUtil::Argument_DOUBLE; case 4: return IfcUtil::Argument_DOUBLE; case 5: return IfcUtil::Argument_DOUBLE; case 6: return IfcUtil::Argument_DOUBLE; } return IfcStructuralLoadStatic::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 1: return Type::IfcLinearForceMeasure; case 2: return Type::IfcLinearForceMeasure; case 3: return Type::IfcLinearForceMeasure; case 4: return Type::IfcLinearMomentMeasure; case 5: return Type::IfcLinearMomentMeasure; case 6: return Type::IfcLinearMomentMeasure; } return IfcStructuralLoadStatic::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 1: return "LinearForceX"; case 2: return "LinearForceY"; case 3: return "LinearForceZ"; case 4: return "LinearMomentX"; case 5: return "LinearMomentY"; case 6: return "LinearMomentZ"; } return IfcStructuralLoadStatic::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcStructuralLoadLinearForce (IfcEntityInstanceData* e);
    IfcStructuralLoadLinearForce (boost::optional< std::string > v1_Name, boost::optional< double > v2_LinearForceX, boost::optional< double > v3_LinearForceY, boost::optional< double > v4_LinearForceZ, boost::optional< double > v5_LinearMomentX, boost::optional< double > v6_LinearMomentY, boost::optional< double > v7_LinearMomentZ);
    typedef IfcTemplatedEntityList< IfcStructuralLoadLinearForce > list;
};
/// Definition from IAI: An instance of the entity
///   IfcStructuralLoadPlanarForce shall be used to define actions on faces.
/// 
/// HISTORY: New entity in Release IFC2x
///   edition 2.
class IFC_PARSE_API IfcStructuralLoadPlanarForce : public IfcStructuralLoadStatic {
public:
    /// Whether the optional attribute PlanarForceX is defined for this IfcStructuralLoadPlanarForce
    bool hasPlanarForceX() const;
    /// Planar force value in x-direction.
    double PlanarForceX() const;
    void setPlanarForceX(double v);
    /// Whether the optional attribute PlanarForceY is defined for this IfcStructuralLoadPlanarForce
    bool hasPlanarForceY() const;
    /// Planar force value in y-direction.
    double PlanarForceY() const;
    void setPlanarForceY(double v);
    /// Whether the optional attribute PlanarForceZ is defined for this IfcStructuralLoadPlanarForce
    bool hasPlanarForceZ() const;
    /// Planar force value in z-direction.
    double PlanarForceZ() const;
    void setPlanarForceZ(double v);
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 1: return IfcUtil::Argument_DOUBLE; case 2: return IfcUtil::Argument_DOUBLE; case 3: return IfcUtil::Argument_DOUBLE; } return IfcStructuralLoadStatic::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 1: return Type::IfcPlanarForceMeasure; case 2: return Type::IfcPlanarForceMeasure; case 3: return Type::IfcPlanarForceMeasure; } return IfcStructuralLoadStatic::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 1: return "PlanarForceX"; case 2: return "PlanarForceY"; case 3: return "PlanarForceZ"; } return IfcStructuralLoadStatic::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcStructuralLoadPlanarForce (IfcEntityInstanceData* e);
    IfcStructuralLoadPlanarForce (boost::optional< std::string > v1_Name, boost::optional< double > v2_PlanarForceX, boost::optional< double > v3_PlanarForceY, boost::optional< double > v4_PlanarForceZ);
    typedef IfcTemplatedEntityList< IfcStructuralLoadPlanarForce > list;
};
/// Definition from IAI: Instances of the entity
///   IfcStructuralLoadSingleDisplacement shall be used to define displacements.
/// 
/// HISTORY: New entity in Release IFC2x
///   edition 2.
class IFC_PARSE_API IfcStructuralLoadSingleDisplacement : public IfcStructuralLoadStatic {
public:
    /// Whether the optional attribute DisplacementX is defined for this IfcStructuralLoadSingleDisplacement
    bool hasDisplacementX() const;
    /// Displacement in x-direction.
    double DisplacementX() const;
    void setDisplacementX(double v);
    /// Whether the optional attribute DisplacementY is defined for this IfcStructuralLoadSingleDisplacement
    bool hasDisplacementY() const;
    /// Displacement in y-direction.
    double DisplacementY() const;
    void setDisplacementY(double v);
    /// Whether the optional attribute DisplacementZ is defined for this IfcStructuralLoadSingleDisplacement
    bool hasDisplacementZ() const;
    /// Displacement in z-direction.
    double DisplacementZ() const;
    void setDisplacementZ(double v);
    /// Whether the optional attribute RotationalDisplacementRX is defined for this IfcStructuralLoadSingleDisplacement
    bool hasRotationalDisplacementRX() const;
    /// Rotation about the x-axis.
    double RotationalDisplacementRX() const;
    void setRotationalDisplacementRX(double v);
    /// Whether the optional attribute RotationalDisplacementRY is defined for this IfcStructuralLoadSingleDisplacement
    bool hasRotationalDisplacementRY() const;
    /// Rotation about the y-axis.
    double RotationalDisplacementRY() const;
    void setRotationalDisplacementRY(double v);
    /// Whether the optional attribute RotationalDisplacementRZ is defined for this IfcStructuralLoadSingleDisplacement
    bool hasRotationalDisplacementRZ() const;
    /// Rotation about the z-axis.
    double RotationalDisplacementRZ() const;
    void setRotationalDisplacementRZ(double v);
    virtual unsigned int getArgumentCount() const { return 7; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 1: return IfcUtil::Argument_DOUBLE; case 2: return IfcUtil::Argument_DOUBLE; case 3: return IfcUtil::Argument_DOUBLE; case 4: return IfcUtil::Argument_DOUBLE; case 5: return IfcUtil::Argument_DOUBLE; case 6: return IfcUtil::Argument_DOUBLE; } return IfcStructuralLoadStatic::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 1: return Type::IfcLengthMeasure; case 2: return Type::IfcLengthMeasure; case 3: return Type::IfcLengthMeasure; case 4: return Type::IfcPlaneAngleMeasure; case 5: return Type::IfcPlaneAngleMeasure; case 6: return Type::IfcPlaneAngleMeasure; } return IfcStructuralLoadStatic::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 1: return "DisplacementX"; case 2: return "DisplacementY"; case 3: return "DisplacementZ"; case 4: return "RotationalDisplacementRX"; case 5: return "RotationalDisplacementRY"; case 6: return "RotationalDisplacementRZ"; } return IfcStructuralLoadStatic::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcStructuralLoadSingleDisplacement (IfcEntityInstanceData* e);
    IfcStructuralLoadSingleDisplacement (boost::optional< std::string > v1_Name, boost::optional< double > v2_DisplacementX, boost::optional< double > v3_DisplacementY, boost::optional< double > v4_DisplacementZ, boost::optional< double > v5_RotationalDisplacementRX, boost::optional< double > v6_RotationalDisplacementRY, boost::optional< double > v7_RotationalDisplacementRZ);
    typedef IfcTemplatedEntityList< IfcStructuralLoadSingleDisplacement > list;
};
/// Definition from IAI: Defines a displacement with warping.
/// 
/// HISTORY: New entity in IFC 2x2.
class IFC_PARSE_API IfcStructuralLoadSingleDisplacementDistortion : public IfcStructuralLoadSingleDisplacement {
public:
    /// Whether the optional attribute Distortion is defined for this IfcStructuralLoadSingleDisplacementDistortion
    bool hasDistortion() const;
    /// The distortion curvature (warping, i.e. a cross-sectional deplanation) given to the displacement load.
    double Distortion() const;
    void setDistortion(double v);
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 7: return IfcUtil::Argument_DOUBLE; } return IfcStructuralLoadSingleDisplacement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 7: return Type::IfcCurvatureMeasure; } return IfcStructuralLoadSingleDisplacement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 7: return "Distortion"; } return IfcStructuralLoadSingleDisplacement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcStructuralLoadSingleDisplacementDistortion (IfcEntityInstanceData* e);
    IfcStructuralLoadSingleDisplacementDistortion (boost::optional< std::string > v1_Name, boost::optional< double > v2_DisplacementX, boost::optional< double > v3_DisplacementY, boost::optional< double > v4_DisplacementZ, boost::optional< double > v5_RotationalDisplacementRX, boost::optional< double > v6_RotationalDisplacementRY, boost::optional< double > v7_RotationalDisplacementRZ, boost::optional< double > v8_Distortion);
    typedef IfcTemplatedEntityList< IfcStructuralLoadSingleDisplacementDistortion > list;
};
/// Definition from IAI: Instances of the entity
///   IfcStructuralLoadSingleForce shall be used to define the forces and
///   moments of an action operating on a single point. 
/// 
/// HISTORY: New entity in Release IFC2x
///   edition 2.
class IFC_PARSE_API IfcStructuralLoadSingleForce : public IfcStructuralLoadStatic {
public:
    /// Whether the optional attribute ForceX is defined for this IfcStructuralLoadSingleForce
    bool hasForceX() const;
    /// Force value in x-direction.
    double ForceX() const;
    void setForceX(double v);
    /// Whether the optional attribute ForceY is defined for this IfcStructuralLoadSingleForce
    bool hasForceY() const;
    /// Force value in y-direction.
    double ForceY() const;
    void setForceY(double v);
    /// Whether the optional attribute ForceZ is defined for this IfcStructuralLoadSingleForce
    bool hasForceZ() const;
    /// Force value in z-direction.
    double ForceZ() const;
    void setForceZ(double v);
    /// Whether the optional attribute MomentX is defined for this IfcStructuralLoadSingleForce
    bool hasMomentX() const;
    /// Moment about the x-axis.
    double MomentX() const;
    void setMomentX(double v);
    /// Whether the optional attribute MomentY is defined for this IfcStructuralLoadSingleForce
    bool hasMomentY() const;
    /// Moment about the y-axis.
    double MomentY() const;
    void setMomentY(double v);
    /// Whether the optional attribute MomentZ is defined for this IfcStructuralLoadSingleForce
    bool hasMomentZ() const;
    /// Moment about the z-axis.
    double MomentZ() const;
    void setMomentZ(double v);
    virtual unsigned int getArgumentCount() const { return 7; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 1: return IfcUtil::Argument_DOUBLE; case 2: return IfcUtil::Argument_DOUBLE; case 3: return IfcUtil::Argument_DOUBLE; case 4: return IfcUtil::Argument_DOUBLE; case 5: return IfcUtil::Argument_DOUBLE; case 6: return IfcUtil::Argument_DOUBLE; } return IfcStructuralLoadStatic::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 1: return Type::IfcForceMeasure; case 2: return Type::IfcForceMeasure; case 3: return Type::IfcForceMeasure; case 4: return Type::IfcTorqueMeasure; case 5: return Type::IfcTorqueMeasure; case 6: return Type::IfcTorqueMeasure; } return IfcStructuralLoadStatic::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 1: return "ForceX"; case 2: return "ForceY"; case 3: return "ForceZ"; case 4: return "MomentX"; case 5: return "MomentY"; case 6: return "MomentZ"; } return IfcStructuralLoadStatic::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcStructuralLoadSingleForce (IfcEntityInstanceData* e);
    IfcStructuralLoadSingleForce (boost::optional< std::string > v1_Name, boost::optional< double > v2_ForceX, boost::optional< double > v3_ForceY, boost::optional< double > v4_ForceZ, boost::optional< double > v5_MomentX, boost::optional< double > v6_MomentY, boost::optional< double > v7_MomentZ);
    typedef IfcTemplatedEntityList< IfcStructuralLoadSingleForce > list;
};
/// Definition from IAI: Instances of the entity
///   IfcStructuralLoadSingleForceWarping, as a subtype of
///   IfcStructuralLoadSingleForce, shall be used to define an action operation
///   on a single point. In addition to forces and moments defined by its supertype a
///   warping moment can be defined.  
/// 
/// HISTORY: New entity in Release IFC2x
///   edition 2.
class IFC_PARSE_API IfcStructuralLoadSingleForceWarping : public IfcStructuralLoadSingleForce {
public:
    /// Whether the optional attribute WarpingMoment is defined for this IfcStructuralLoadSingleForceWarping
    bool hasWarpingMoment() const;
    /// The warping moment at the point load.
    double WarpingMoment() const;
    void setWarpingMoment(double v);
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 7: return IfcUtil::Argument_DOUBLE; } return IfcStructuralLoadSingleForce::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 7: return Type::IfcWarpingMomentMeasure; } return IfcStructuralLoadSingleForce::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 7: return "WarpingMoment"; } return IfcStructuralLoadSingleForce::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcStructuralLoadSingleForceWarping (IfcEntityInstanceData* e);
    IfcStructuralLoadSingleForceWarping (boost::optional< std::string > v1_Name, boost::optional< double > v2_ForceX, boost::optional< double > v3_ForceY, boost::optional< double > v4_ForceZ, boost::optional< double > v5_MomentX, boost::optional< double > v6_MomentY, boost::optional< double > v7_MomentZ, boost::optional< double > v8_WarpingMoment);
    typedef IfcTemplatedEntityList< IfcStructuralLoadSingleForceWarping > list;
};
/// Definition from ISO/DIS 10303-42:1999(E): A subedge is an edge whose domain is a connected portion of the domain of an existing edge. The topological constraints on a subedge are the same as those on an edge. 
/// 
/// Informal propositions: 
/// 
/// The domain of the subedge is formally defined to be the domain of the parent edge, as trimmed by the subedge start vertex and subedge end vertex. 
/// The start vertex and end vertex shall be within the union of the domains of the vertices of the parent edge and the domain of the parent edge. 
/// 
/// NOTE  Corresponding ISO 10303 entity: subedge. Please refer to ISO/DIS 10303-42:1999(E), p. 194 for the final definition of the formal standard.
/// 
/// HISTORY  New entity in IFC2x2.
class IFC_PARSE_API IfcSubedge : public IfcEdge {
public:
    /// The Edge, or Subedge, which contains the Subedge.
    IfcEdge* ParentEdge() const;
    void setParentEdge(IfcEdge* v);
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 2: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcEdge::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 2: return Type::IfcEdge; } return IfcEdge::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 2: return "ParentEdge"; } return IfcEdge::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcSubedge (IfcEntityInstanceData* e);
    IfcSubedge (IfcVertex* v1_EdgeStart, IfcVertex* v2_EdgeEnd, IfcEdge* v3_ParentEdge);
    typedef IfcTemplatedEntityList< IfcSubedge > list;
};
/// Definition from ISO/CD 10303-42:1992: A surface can be envisioned as a set of connected points in 3-dimensional space which is always locally 2-dimensional, but need not be a manifold.  
/// 
/// NOTE Corresponding ISO 10303 entity: surface, the following subtypes have been incorporated into IFC - elementary_surface (as IfcElementarySurface), swept_surface (as IfcSweptSurface) and bounded_surface (as IfcBoundedSurface). Please refer to ISO/IS 10303-42:1994, p. 68 for the final definition of the formal standard. 
/// 
/// HISTORY New class in IFC Release 1.5
/// 
/// Informal proposition: 
/// 
/// A surface has non zero area. 
/// A surface is arcwise connected.
class IFC_PARSE_API IfcSurface : public IfcGeometricRepresentationItem {
public:
    virtual unsigned int getArgumentCount() const { return 0; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcGeometricRepresentationItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcGeometricRepresentationItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcGeometricRepresentationItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcSurface (IfcEntityInstanceData* e);
    IfcSurface ();
    typedef IfcTemplatedEntityList< IfcSurface > list;
};
/// IfcSurfaceStyleRendering holds the properties for visualization related to a particular surface side style.  
/// 
/// It allows rendering properties to be defined by: 
/// 
/// a transparency component (Transparency attribute) 
///   a colour component (SurfaceColour attribute inherited from IfcSurfaceStyleShading) 
///   a reflectance component, given either by 
/// 
/// applying reflectance factors to the surface colour: 
/// 
/// diffuse component (SurfaceColour * DiffuseFactor)				  
///   transmission component (SurfaceColour * TransmissionFactor) 
///   diffuse transmission component (SurfaceColour * DiffuseTransmissionFactor) 
///   reflection component (SurfaceColour * ReflectionFactor) 
///   specular component (SurfaceColour * SpecularFactor attribute together with SpecularHighlight) 
/// 
/// explicitly defining such factors as colours (DiffuseColour, TransmissionColour, DiffuseTransmissionColour, ReflectionColour and SpecularColour) 
/// 
/// a displacement component, currently only given by a texture map with the TextureType = bump 
///   a coverage component, currently only given by the alpha component of the texture map (2 or 4 component colour texture) 
/// 
/// NOTE: The inherited attribute SurfaceColour is treated as the ambient colour and specifies how much ambient light from light sources this surface shall reflect. Ambient light is omnidirectional and depends only on the number of light sources, not their positions with respect to the surface.
/// 
/// NOTE: If the reflectance method, as given by the IfcReflectanceMethodEnum is "GLASS", the transmission factor controls the level of transparency in the glass, In this case the transparency factor is interpreted as transmission factor.
/// 
/// NOTE: Both Transparency and TransmissionColour (or factor) are included, the following definitions apply:
/// 
/// Transparency is the ratio of the transmitted flux in a solid angle of 2 * PI sr (one hemisphere). It is a simple colour filtration that does not account for refraction. 
///   Transmission factor of a material is the ratio of transmitted flux in a given solid angle to the transmitted flux of a completely diffuse material with 100% transmission in the same solid angle. It is the portion of light that goes through the material and may be refracted. 
/// 
/// NOTE: IFC 2x2 adds additional capability for presentation of physically accurate illuminance on surfaces. VRML type rendering and rendering based on ISO 10303-46 continues to be supported by a subset of the information. For reflectance equations and further information about the surface style properties and its processing, see:
/// 
/// ISO/IEC 14772-1: 1997: The Virtual Reality Modeling Language 
/// 
/// NOTE: The definition of IfcSurfaceStyleRenderingProperties includes the definitions as found in ISO 10303-46:1994, in particular of:
/// 
/// surface_style_rendering_with_properties
///   surface_style_rendering_ambient
///   surface_style_rendering_ambient_diffuse
///   surface_style_rendering_ambient_diffuse_specular
///   surface_style_transparent
/// 
/// In addition to the attributes as defined in ISO 10303-46, (ambient_reflectance, diffuse_reflectance, specular_reflectance, specular_exponent, and specular_colour), the current IFC definition adds other colours, reflectance factors and specular roughness.
/// 
/// HISTORY: New Entity in IFC 2x.
class IFC_PARSE_API IfcSurfaceStyleRendering : public IfcSurfaceStyleShading {
public:
    /// Whether the optional attribute DiffuseColour is defined for this IfcSurfaceStyleRendering
    bool hasDiffuseColour() const;
    /// The diffuse part of the reflectance equation can be given as either a colour or a scalar factor.
    /// The diffuse colour field reflects all light sources depending on the angle of the surface with respect to the light source. The more directly the surface faces the light, the more diffuse light reflects.
    /// The diffuse factor field specifies how much diffuse light from light sources this surface shall reflect. Diffuse light depends on the angle of the surface with respect to the light source. The more directly the surface faces the light, the more diffuse light reflects. The diffuse colour is then defined by surface colour * diffuse factor.
    IfcColourOrFactor* DiffuseColour() const;
    void setDiffuseColour(IfcColourOrFactor* v);
    /// Whether the optional attribute TransmissionColour is defined for this IfcSurfaceStyleRendering
    bool hasTransmissionColour() const;
    /// The transmissive part of the reflectance equation can be given as either a colour or a scalar factor. It only applies to materials which Transparency field is greater than zero.
    /// The transmissive colour field specifies the colour that passes through a transparant material (like the colour that shines through a glass).
    /// The transmissive factor defines the transmissive part, the transmissive colour is then defined by surface colour * transmissive factor.
    IfcColourOrFactor* TransmissionColour() const;
    void setTransmissionColour(IfcColourOrFactor* v);
    /// Whether the optional attribute DiffuseTransmissionColour is defined for this IfcSurfaceStyleRendering
    bool hasDiffuseTransmissionColour() const;
    /// The diffuse transmission part of the reflectance equation can be given as either a colour or a scalar factor. It only applies to materials whose Transparency field is greater than zero.
    /// The diffuse transmission colour specifies how much diffuse light is reflected at the opposite side of the material surface.
    /// The diffuse transmission factor field specifies how much diffuse light from light sources this surface shall reflect on the opposite side of the material surface. The diffuse transmissive colour is then defined by surface colour * diffuse transmissive factor.
    IfcColourOrFactor* DiffuseTransmissionColour() const;
    void setDiffuseTransmissionColour(IfcColourOrFactor* v);
    /// Whether the optional attribute ReflectionColour is defined for this IfcSurfaceStyleRendering
    bool hasReflectionColour() const;
    /// The reflection (or mirror) part of the reflectance equation can be given as either a colour or a scalar factor. Applies to "glass" and "mirror" reflection models.
    /// The reflection colour specifies the contribution made by light from the mirror direction, i.e. light being reflected from the surface.
    /// The reflection factor specifies the amount of contribution made by light from the mirror direction. The reflection colour is then defined by surface colour * reflection factor.
    IfcColourOrFactor* ReflectionColour() const;
    void setReflectionColour(IfcColourOrFactor* v);
    /// Whether the optional attribute SpecularColour is defined for this IfcSurfaceStyleRendering
    bool hasSpecularColour() const;
    /// The specular part of the reflectance equation can be given as either a colour or a scalar factor.
    /// The specular colour determine the specular highlights (e.g., the shiny spots on an apple). When the angle from the light to the surface is close to the angle from the surface to the viewer, the specular colour is added to the diffuse and ambient colour calculations.
    /// The specular factor defines the specular part, the specular colour is then defined by surface colour * specular factor.
    IfcColourOrFactor* SpecularColour() const;
    void setSpecularColour(IfcColourOrFactor* v);
    /// Whether the optional attribute SpecularHighlight is defined for this IfcSurfaceStyleRendering
    bool hasSpecularHighlight() const;
    /// The exponent or roughness part of the specular reflectance.
    IfcSpecularHighlightSelect* SpecularHighlight() const;
    void setSpecularHighlight(IfcSpecularHighlightSelect* v);
    /// Identifies the predefined types of reflectance method from which the method required may be set.
    IfcReflectanceMethodEnum::IfcReflectanceMethodEnum ReflectanceMethod() const;
    void setReflectanceMethod(IfcReflectanceMethodEnum::IfcReflectanceMethodEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 2: return IfcUtil::Argument_ENTITY_INSTANCE; case 3: return IfcUtil::Argument_ENTITY_INSTANCE; case 4: return IfcUtil::Argument_ENTITY_INSTANCE; case 5: return IfcUtil::Argument_ENTITY_INSTANCE; case 6: return IfcUtil::Argument_ENTITY_INSTANCE; case 7: return IfcUtil::Argument_ENTITY_INSTANCE; case 8: return IfcUtil::Argument_ENUMERATION; } return IfcSurfaceStyleShading::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 2: return Type::IfcColourOrFactor; case 3: return Type::IfcColourOrFactor; case 4: return Type::IfcColourOrFactor; case 5: return Type::IfcColourOrFactor; case 6: return Type::IfcColourOrFactor; case 7: return Type::IfcSpecularHighlightSelect; case 8: return Type::IfcReflectanceMethodEnum; } return IfcSurfaceStyleShading::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 2: return "DiffuseColour"; case 3: return "TransmissionColour"; case 4: return "DiffuseTransmissionColour"; case 5: return "ReflectionColour"; case 6: return "SpecularColour"; case 7: return "SpecularHighlight"; case 8: return "ReflectanceMethod"; } return IfcSurfaceStyleShading::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcSurfaceStyleRendering (IfcEntityInstanceData* e);
    IfcSurfaceStyleRendering (IfcColourRgb* v1_SurfaceColour, boost::optional< double > v2_Transparency, IfcColourOrFactor* v3_DiffuseColour, IfcColourOrFactor* v4_TransmissionColour, IfcColourOrFactor* v5_DiffuseTransmissionColour, IfcColourOrFactor* v6_ReflectionColour, IfcColourOrFactor* v7_SpecularColour, IfcSpecularHighlightSelect* v8_SpecularHighlight, IfcReflectanceMethodEnum::IfcReflectanceMethodEnum v9_ReflectanceMethod);
    typedef IfcTemplatedEntityList< IfcSurfaceStyleRendering > list;
};
/// Definition from ISO/CD 10303-42:1992: The swept area
///   solid entity collects the entities which are defined
///   procedurally by sweeping action on planar bounded surfaces.
///   The position is space of the swept solid will be dependent
///   upon the position of the swept area. The swept area will be
///   a face of the resulting swept area solid, except for the
///   case of a revolved area solid with angle equal to 2π
///   (or 360 degrees).
/// 
/// The swept area is defined by a
///   cross section (also referred to as profile), which is given
///   as a closed two-dimensional boundary on an implicit plane.
///   The swept area is defined in the xy plane of the position
///   coordinate system, which is given for the swept area solid.
/// 
/// NOTE Corresponding ISO 10303-42 entity: swept_area_solid, The data type of SweptArea is modified and given by a profile definition (IfcProfileDef). A position coordinate system is defined by the Position attribute has been added. Please refer to ISO/IS 10303-42:1994, p. 183 for the final definition of the formal standard.
/// 
/// HISTORY New entity in IFC Release 1.5, the capabilities have been enhanced in IFC Release 2x.
class IFC_PARSE_API IfcSweptAreaSolid : public IfcSolidModel {
public:
    /// The surface defining the area to be swept. It is given as a profile definition within the xy plane of the position coordinate system.
    IfcProfileDef* SweptArea() const;
    void setSweptArea(IfcProfileDef* v);
    /// Whether the optional attribute Position is defined for this IfcSweptAreaSolid
    bool hasPosition() const;
    /// Position coordinate system for the swept area, provided by a profile definition within the XY plane of the Position.
    IfcAxis2Placement3D* Position() const;
    void setPosition(IfcAxis2Placement3D* v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcSolidModel::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcProfileDef; case 1: return Type::IfcAxis2Placement3D; } return IfcSolidModel::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "SweptArea"; case 1: return "Position"; } return IfcSolidModel::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcSweptAreaSolid (IfcEntityInstanceData* e);
    IfcSweptAreaSolid (IfcProfileDef* v1_SweptArea, IfcAxis2Placement3D* v2_Position);
    typedef IfcTemplatedEntityList< IfcSweptAreaSolid > list;
};
/// Definition from ISO 10303-42:2002: A swept
/// disk solid is the solid produced by sweeping a circular disk
/// along a three dimensional curve. During the sweeping operation
/// the normal to the plane of the circular disk is in the direction
/// of the tangent to the directrix curve and the center of the disk
/// lies on the directrix. The circular disk may, optionally, have a
/// central hole, in this case the resulting solid has a through
/// hole, or, an internal void when the directrix forms a close
/// curve.
/// The StartParam and
/// EndParam parameter are optional, if not provided they
/// default to the start and end of the Directrix. Only if the
/// Directrix is given by a bounded or by a closed curve, it
/// is permissible to omit the values of StartParam and
/// EndParam.
/// If the transitions between consecutive segments of the
/// Directrix are not tangent continuous, the resulting solid
/// is created by a miter at half angle between the two segments.
/// Informal proposition restricts the permissible angle between two
/// non-tangent continuous segments.
/// 
/// Figure 272 illustrates an example.
/// 
/// Directrix given as IfcCompositeCurve being
/// tangent continuous between its segments
/// Directrix being a bounded and open curve
/// No StartParam and EndParam are provided, start
/// and end default to start and end of the bounded curve of the
/// Directrix
/// 
/// NOTE  Although the example shows a Directrix as a composite curve on a planar reference surface, the definition of IfcSweptDiskSolid is not restricted to be based on planer curves. However view definitions or implementer agreements may provide restrictions.
/// 
/// Figure 272 — Swept disk solid geometry
/// 
/// NOTE  Corresponding ISO 10303-42 entity: swept_disk_solid. Please refer to ISO/FDIS 10303-42:2002, p. 282 for the definition of the formal standard.
/// 
/// HISTORY  New entity in IFC Release 2x2.
/// 
/// IFC2x4 CHANGE  The attribute StartParam and EndParam have been made optional.
/// 
/// Informal proposition
/// 
/// If the Directrix curve definition is not tangent
/// continuous, the transition between the segments has to be within
/// an acceptable limit of tangent discontinuity. Very sharp edges
/// may result in nearly impossible miter. Implementer agreements may
/// define acceptable limits for tangent discontinuity.
/// The segments of the Directrix shall be long enough to
/// apply the Radius. In case of an arc segment forming part
/// of the Directrix ,its radius shall be greater then the
/// disk Radius
/// The Directrix shall not be based on an intersecting
/// curve.
class IFC_PARSE_API IfcSweptDiskSolid : public IfcSolidModel {
public:
    /// The curve used to define the sweeping operation. The solid is generated by sweeping a circular disk along the Directrix.
    IfcCurve* Directrix() const;
    void setDirectrix(IfcCurve* v);
    /// The Radius of the circular disk to be swept along the directrix. Denotes the outer radius, if an InnerRadius is applied.
    double Radius() const;
    void setRadius(double v);
    /// Whether the optional attribute InnerRadius is defined for this IfcSweptDiskSolid
    bool hasInnerRadius() const;
    /// This attribute is optional, if present it defines the radius of a circular hole in the centre of the disk.
    double InnerRadius() const;
    void setInnerRadius(double v);
    /// Whether the optional attribute StartParam is defined for this IfcSweptDiskSolid
    bool hasStartParam() const;
    /// The parameter value on the Directrix at which the sweeping operation commences. If no value is provided the start of the sweeping operation is at the start of the Directrix..
    /// 
    /// IFC2x4 CHANGE  The attribute has been changed to OPTIONAL with upward compatibility for file-based exchange.
    double StartParam() const;
    void setStartParam(double v);
    /// Whether the optional attribute EndParam is defined for this IfcSweptDiskSolid
    bool hasEndParam() const;
    /// The parameter value on the Directrix at which the sweeping operation ends. If no value is provided the end of the sweeping operation is at the end of the Directrix..
    /// 
    /// IFC2x4 CHANGE  The attribute has been changed to OPTIONAL with upward compatibility for file-based exchange.
    double EndParam() const;
    void setEndParam(double v);
    virtual unsigned int getArgumentCount() const { return 5; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_DOUBLE; case 2: return IfcUtil::Argument_DOUBLE; case 3: return IfcUtil::Argument_DOUBLE; case 4: return IfcUtil::Argument_DOUBLE; } return IfcSolidModel::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcCurve; case 1: return Type::IfcPositiveLengthMeasure; case 2: return Type::IfcPositiveLengthMeasure; case 3: return Type::IfcParameterValue; case 4: return Type::IfcParameterValue; } return IfcSolidModel::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Directrix"; case 1: return "Radius"; case 2: return "InnerRadius"; case 3: return "StartParam"; case 4: return "EndParam"; } return IfcSolidModel::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcSweptDiskSolid (IfcEntityInstanceData* e);
    IfcSweptDiskSolid (IfcCurve* v1_Directrix, double v2_Radius, boost::optional< double > v3_InnerRadius, boost::optional< double > v4_StartParam, boost::optional< double > v5_EndParam);
    typedef IfcTemplatedEntityList< IfcSweptDiskSolid > list;
};
/// The IfcSweptDiskSolidPolygonal is a IfcSweptDiskSolid where the Directrix is restricted to be provided by an IfcPolyline only. An optional FilletRadius attribute can be asserted, it is then applied as a fillet to all transitions between the segments of the IfcPolyline.
/// 
/// HISTORY New entity in IFC2x4.
/// 
/// Informal proposition
/// 
/// The FilletRadius, if provided, has to be smaller then
/// or equal to the length of the start and end segment of the
/// IfcPolyline, and smaller then or equal to one half of the
/// lenght of the shortest inner segment.
class IFC_PARSE_API IfcSweptDiskSolidPolygonal : public IfcSweptDiskSolid {
public:
    /// Whether the optional attribute FilletRadius is defined for this IfcSweptDiskSolidPolygonal
    bool hasFilletRadius() const;
    /// The fillet that is equally applied to all transitions between the segments of the IfcPolyline, providing the geometric representation for the Directrix. If omited, no fillet is applied to the segments.
    double FilletRadius() const;
    void setFilletRadius(double v);
    virtual unsigned int getArgumentCount() const { return 6; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 5: return IfcUtil::Argument_DOUBLE; } return IfcSweptDiskSolid::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 5: return Type::IfcPositiveLengthMeasure; } return IfcSweptDiskSolid::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 5: return "FilletRadius"; } return IfcSweptDiskSolid::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcSweptDiskSolidPolygonal (IfcEntityInstanceData* e);
    IfcSweptDiskSolidPolygonal (IfcCurve* v1_Directrix, double v2_Radius, boost::optional< double > v3_InnerRadius, boost::optional< double > v4_StartParam, boost::optional< double > v5_EndParam, boost::optional< double > v6_FilletRadius);
    typedef IfcTemplatedEntityList< IfcSweptDiskSolidPolygonal > list;
};
/// Definition from ISO/CD 10303-42:1992: A swept surface is one that is constructed by sweeping a curve along another curve.  
/// 
/// NOTE: Corresponding ISO 10303 entity: swept_surface. Please refer to ISO/IS 10303-42:1994, p.76 for the final definition of the formal standard.
/// 
/// HISTORY: New entity in IFC Release 2x.
class IFC_PARSE_API IfcSweptSurface : public IfcSurface {
public:
    /// The curve to be swept in defining the surface. The curve is defined as a profile within the position coordinate system.
    IfcProfileDef* SweptCurve() const;
    void setSweptCurve(IfcProfileDef* v);
    /// Whether the optional attribute Position is defined for this IfcSweptSurface
    bool hasPosition() const;
    /// Position coordinate system for the placement of the profile within the xy plane of the axis placement.
    IfcAxis2Placement3D* Position() const;
    void setPosition(IfcAxis2Placement3D* v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcSurface::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcProfileDef; case 1: return Type::IfcAxis2Placement3D; } return IfcSurface::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "SweptCurve"; case 1: return "Position"; } return IfcSurface::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcSweptSurface (IfcEntityInstanceData* e);
    IfcSweptSurface (IfcProfileDef* v1_SweptCurve, IfcAxis2Placement3D* v2_Position);
    typedef IfcTemplatedEntityList< IfcSweptSurface > list;
};
/// IfcTShapeProfileDef defines
/// a section profile that provides the defining parameters of a T-shaped
/// section to be used by the swept area solid. Its parameters and
/// orientation relative to the position coordinate system are according to
/// the following illustration. The centre of the position coordinate
/// system is in the profile's centre of the bounding box.
/// 
/// HISTORY  New entity in IFC2x2.
/// 
/// IFC2x3 CHANGE  All profile origins are now in the center of the bounding box.
/// 
/// IFC2x4 CHANGE  Type of FilletRadius, FlangeEdgeRadius, and WebEdgeRadius relaxed to allow for zero radius. Trailing attribute CentreOfGravityInY deleted, use respective property in IfcExtendedProfileProperties instead.
/// 
/// Figure 326 illustrates parameters of the T-shape profile definition.
/// 
/// Position 
/// The parameterized profile defines its own position coordinate system.
/// The underlying
/// coordinate system is defined by the swept area solid
/// that uses the profile definition. It is the xy plane of:
/// 
/// IfcSweptAreaSolid.Position
/// 
/// by using offsets of the position location, the parameterized profile
/// can be positioned centric (using x,y offsets = 0.), or at any position
/// relative to the profile.
/// 
/// Figure 326 — T-shape profile
class IFC_PARSE_API IfcTShapeProfileDef : public IfcParameterizedProfileDef {
public:
    /// Web lengths, see illustration above (= h).
    double Depth() const;
    void setDepth(double v);
    /// Flange lengths, see illustration above (= b).
    double FlangeWidth() const;
    void setFlangeWidth(double v);
    /// Constant wall thickness of web (= ts).
    double WebThickness() const;
    void setWebThickness(double v);
    /// Constant wall thickness of flange (= tg).
    double FlangeThickness() const;
    void setFlangeThickness(double v);
    /// Whether the optional attribute FilletRadius is defined for this IfcTShapeProfileDef
    bool hasFilletRadius() const;
    /// Fillet radius according the above illustration (= r1).
    double FilletRadius() const;
    void setFilletRadius(double v);
    /// Whether the optional attribute FlangeEdgeRadius is defined for this IfcTShapeProfileDef
    bool hasFlangeEdgeRadius() const;
    /// Edge radius according the above illustration (= r2).
    double FlangeEdgeRadius() const;
    void setFlangeEdgeRadius(double v);
    /// Whether the optional attribute WebEdgeRadius is defined for this IfcTShapeProfileDef
    bool hasWebEdgeRadius() const;
    /// Edge radius according the above illustration (= r3).
    double WebEdgeRadius() const;
    void setWebEdgeRadius(double v);
    /// Whether the optional attribute WebSlope is defined for this IfcTShapeProfileDef
    bool hasWebSlope() const;
    /// Slope of flange of the profile.
    double WebSlope() const;
    void setWebSlope(double v);
    /// Whether the optional attribute FlangeSlope is defined for this IfcTShapeProfileDef
    bool hasFlangeSlope() const;
    /// Slope of web of the profile.
    double FlangeSlope() const;
    void setFlangeSlope(double v);
    virtual unsigned int getArgumentCount() const { return 12; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 3: return IfcUtil::Argument_DOUBLE; case 4: return IfcUtil::Argument_DOUBLE; case 5: return IfcUtil::Argument_DOUBLE; case 6: return IfcUtil::Argument_DOUBLE; case 7: return IfcUtil::Argument_DOUBLE; case 8: return IfcUtil::Argument_DOUBLE; case 9: return IfcUtil::Argument_DOUBLE; case 10: return IfcUtil::Argument_DOUBLE; case 11: return IfcUtil::Argument_DOUBLE; } return IfcParameterizedProfileDef::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 3: return Type::IfcPositiveLengthMeasure; case 4: return Type::IfcPositiveLengthMeasure; case 5: return Type::IfcPositiveLengthMeasure; case 6: return Type::IfcPositiveLengthMeasure; case 7: return Type::IfcNonNegativeLengthMeasure; case 8: return Type::IfcNonNegativeLengthMeasure; case 9: return Type::IfcNonNegativeLengthMeasure; case 10: return Type::IfcPlaneAngleMeasure; case 11: return Type::IfcPlaneAngleMeasure; } return IfcParameterizedProfileDef::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 3: return "Depth"; case 4: return "FlangeWidth"; case 5: return "WebThickness"; case 6: return "FlangeThickness"; case 7: return "FilletRadius"; case 8: return "FlangeEdgeRadius"; case 9: return "WebEdgeRadius"; case 10: return "WebSlope"; case 11: return "FlangeSlope"; } return IfcParameterizedProfileDef::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcTShapeProfileDef (IfcEntityInstanceData* e);
    IfcTShapeProfileDef (IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< std::string > v2_ProfileName, IfcAxis2Placement2D* v3_Position, double v4_Depth, double v5_FlangeWidth, double v6_WebThickness, double v7_FlangeThickness, boost::optional< double > v8_FilletRadius, boost::optional< double > v9_FlangeEdgeRadius, boost::optional< double > v10_WebEdgeRadius, boost::optional< double > v11_WebSlope, boost::optional< double > v12_FlangeSlope);
    typedef IfcTemplatedEntityList< IfcTShapeProfileDef > list;
};

class IFC_PARSE_API IfcTessellatedItem : public IfcGeometricRepresentationItem {
public:
    virtual unsigned int getArgumentCount() const { return 0; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcGeometricRepresentationItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcGeometricRepresentationItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcGeometricRepresentationItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcTessellatedItem (IfcEntityInstanceData* e);
    IfcTessellatedItem ();
    typedef IfcTemplatedEntityList< IfcTessellatedItem > list;
};
/// The text literal is a geometric representation item which describes a text string using a string literal and additional position and path information.
/// 
/// NOTE  The IfcTextLiteral is an entity that had been adopted from ISO 10303, Industrial automation systems and integration—Product data representation and exchange.
/// 
/// NOTE  Corresponding ISO 10303 name: text_literal. Please refer to ISO/IS 10303-46:1994 for the
/// final definition of the formal standard. The attributes font and alignment have been removed as those should be handled by the text style.
/// 
/// HISTORY  New entity in IFC2x2.
/// 
/// IFC2x3 CHANGE  The IfcTextLiteral has been changed by removing Font and Alignment.
class IFC_PARSE_API IfcTextLiteral : public IfcGeometricRepresentationItem {
public:
    /// The text literal to be presented.
    std::string Literal() const;
    void setLiteral(std::string v);
    /// An IfcAxis2Placement that determines the placement and orientation of the presented string.
    /// When used with a text style based on IfcTextStyleWithBoxCharacteristics then the y-axis is taken as the reference direction for the box rotation angle and the box slant angle.
    IfcAxis2Placement* Placement() const;
    void setPlacement(IfcAxis2Placement* v);
    /// The writing direction of the text literal.
    IfcTextPath::IfcTextPath Path() const;
    void setPath(IfcTextPath::IfcTextPath v);
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_STRING; case 1: return IfcUtil::Argument_ENTITY_INSTANCE; case 2: return IfcUtil::Argument_ENUMERATION; } return IfcGeometricRepresentationItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcPresentableText; case 1: return Type::IfcAxis2Placement; case 2: return Type::IfcTextPath; } return IfcGeometricRepresentationItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Literal"; case 1: return "Placement"; case 2: return "Path"; } return IfcGeometricRepresentationItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcTextLiteral (IfcEntityInstanceData* e);
    IfcTextLiteral (std::string v1_Literal, IfcAxis2Placement* v2_Placement, IfcTextPath::IfcTextPath v3_Path);
    typedef IfcTemplatedEntityList< IfcTextLiteral > list;
};
/// The text literal with extent is a text literal with the additional explicit information of the planar extent (or surrounding text box). An alignment attribute defines, how the text box is aligned to the placement and how it may expand.
/// 
/// NOTE  The IfcTextLiteralWithExtent is an entity that had been adopted from ISO 10303, Industrial automation systems and integration—Product data representation and exchange, Part 46: Integrated generic resources: Visual presentation. 
/// 
/// NOTE  Corresponding ISO 10303 name: text_literal_with_extent. Please refer to ISO/IS 10303-46:1994 for the final definition of the formal standard.
/// 
/// HISTORY  New entity in IFC2x2.
/// 
/// IFC2x3 CHANGE  The IfcTextLiteralWithExtent has been changed by adding BoxAlignment.
class IFC_PARSE_API IfcTextLiteralWithExtent : public IfcTextLiteral {
public:
    /// The extent in the x and y direction of the text literal.
    IfcPlanarExtent* Extent() const;
    void setExtent(IfcPlanarExtent* v);
    /// The alignment of the text literal relative to its position.
    std::string BoxAlignment() const;
    void setBoxAlignment(std::string v);
    virtual unsigned int getArgumentCount() const { return 5; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 3: return IfcUtil::Argument_ENTITY_INSTANCE; case 4: return IfcUtil::Argument_STRING; } return IfcTextLiteral::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 3: return Type::IfcPlanarExtent; case 4: return Type::IfcBoxAlignment; } return IfcTextLiteral::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 3: return "Extent"; case 4: return "BoxAlignment"; } return IfcTextLiteral::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcTextLiteralWithExtent (IfcEntityInstanceData* e);
    IfcTextLiteralWithExtent (std::string v1_Literal, IfcAxis2Placement* v2_Placement, IfcTextPath::IfcTextPath v3_Path, IfcPlanarExtent* v4_Extent, std::string v5_BoxAlignment);
    typedef IfcTemplatedEntityList< IfcTextLiteralWithExtent > list;
};
/// Definition from CSS1 (W3C Recommendation): Setting font properties will be among the most common uses of style sheets. Unfortunately, there exists no well-defined and universally accepted taxonomy for classifying fonts, and terms that apply to one font family may not be appropriate for others. For example, 'italic' is commonly used to label slanted text, but slanted text may also be labeled as being Oblique, Slanted, Incline, Cursive or Kursiv. Therefore it is not a simple problem to map typical font selection properties to a specific font.
/// 
/// Font matching
/// Because there is no accepted, universal taxonomy of font properties, matching of properties to font faces must be done carefully. The properties are matched in a well-defined order to ensure that the results of this matching process are as consistent as possible across user agents (assuming that the same library of font faces is presented to each of them).
/// 
/// The user agent makes (or
/// accesses) a database of relevant CSS1
/// properties of all the fonts of which the UA is aware. The UA may be
/// aware of a font because it has been installed locally or it has been
/// previously downloaded over the web. If there are two fonts with
/// exactly the same properties, one of them is ignored. 
///   At a given element and for
/// each character in that element, the UA
/// assembles the font-properties applicable to that element. Using the
/// complete set of properties, the UA uses the 'font-family' property to
/// choose a tentative font family. The remaining properties are tested
/// against the family according to the matching criteria described with
/// each property. If there are matches for all the remaining properties,
/// then that is the matching font face for the given element. 
///   If there is no matching font
/// face within the 'font-family' being
/// processed by step 2, and if there is a next alternative 'font-family'
/// in the font set, then repeat step 2 with the next alternative
/// 'font-family'. 
///   If there is a matching font
/// face, but it doesn't contain a glyph
/// for the current character, and if there is a next alternative
/// 'font-family' in the font sets, then repeat step 2 with the next
/// alternative 'font-family'.  
///   If there is no font within
/// the family selected in 2, then use a
/// UA-dependent default 'font-family' and repeat step 2, using the best
/// match that can be obtained within the default font. 
/// 
/// (The above algorithm can be
/// optimized to avoid having to revisit
/// the CSS1 properties for each character.)
/// 
/// The per-property matching rules
/// from (2) above are as follows:
/// 
/// 'font-style' is tried first.
/// 'italic'
/// will be satisfied if there is either a face in the UA's font database
/// labeled with the CSS keyword 'italic' (preferred) or 'oblique'.
/// Otherwise the values must be matched exactly or font-style will fail. 
///   'font-variant' is tried
/// next. 'normal'
/// matches a font not labeled as 'small-caps'; 'small-caps' matches (1) a
/// font labeled as 'small-caps', (2) a font in which the small caps are
/// synthesized, or (3) a font where all lowercase letters are replaced by
/// upper case letters. A small-caps font may be synthesized by
/// electronically scaling uppercase letters from a normal font. 
///   'font-weight' is matched next, it will never fail. (See 'font-weight' below.) 
///   'font-size' must be matched within a
/// UA-dependent margin of tolerance. (Typically, sizes for scalable fonts
/// are rounded to the nearest whole pixel, while the tolerance for
/// bitmapped fonts could be as large as 20%.) Further computations, are
/// based on the 'font-size' value that is used, not the one that is specified.
/// 
/// The inherited Name attribute is used to define the font name, particularly in cases, where no (list of) font families are provided. 
/// 
/// NOTE  Corresponding CSS1 definitions are Font properties ('font-family', 'font-style', 'font-variant',  'font-weight').
/// 
/// HISTORY  New entity in IFC2x3.
class IFC_PARSE_API IfcTextStyleFontModel : public IfcPreDefinedTextFont {
public:
    /// The value is a prioritized list of font family names and/or generic family names. The first list entry has the highest priority, if this font fails, the next list item shall be used. The last list item should (if possible) be a generic family.
    std::vector< std::string > /*[1:?]*/ FontFamily() const;
    void setFontFamily(std::vector< std::string > /*[1:?]*/ v);
    /// Whether the optional attribute FontStyle is defined for this IfcTextStyleFontModel
    bool hasFontStyle() const;
    /// The font style property selects between normal (sometimes referred to as "roman" or "upright"), italic and oblique faces within a font family.
    std::string FontStyle() const;
    void setFontStyle(std::string v);
    /// Whether the optional attribute FontVariant is defined for this IfcTextStyleFontModel
    bool hasFontVariant() const;
    /// The font variant property selects between normal and small-caps.
    ///   NOTE  It has been introduced for later compliance to full CSS1 support.
    std::string FontVariant() const;
    void setFontVariant(std::string v);
    /// Whether the optional attribute FontWeight is defined for this IfcTextStyleFontModel
    bool hasFontWeight() const;
    /// The font weight property selects the weight of the font.
    ///   NOTE  Values other then 'normal' and 'bold' have been introduced for later compliance to full CSS1 support.
    std::string FontWeight() const;
    void setFontWeight(std::string v);
    /// The font size provides the size or height of the text font.
    ///   NOTE  The following values are allowed, <IfcLengthMeasure, with positive values, the length unit is globally defined at IfcUnitAssignment.
    IfcSizeSelect* FontSize() const;
    void setFontSize(IfcSizeSelect* v);
    virtual unsigned int getArgumentCount() const { return 6; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 1: return IfcUtil::Argument_AGGREGATE_OF_STRING; case 2: return IfcUtil::Argument_STRING; case 3: return IfcUtil::Argument_STRING; case 4: return IfcUtil::Argument_STRING; case 5: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcPreDefinedTextFont::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 1: return Type::IfcTextFontName; case 2: return Type::IfcFontStyle; case 3: return Type::IfcFontVariant; case 4: return Type::IfcFontWeight; case 5: return Type::IfcSizeSelect; } return IfcPreDefinedTextFont::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 1: return "FontFamily"; case 2: return "FontStyle"; case 3: return "FontVariant"; case 4: return "FontWeight"; case 5: return "FontSize"; } return IfcPreDefinedTextFont::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcTextStyleFontModel (IfcEntityInstanceData* e);
    IfcTextStyleFontModel (std::string v1_Name, std::vector< std::string > /*[1:?]*/ v2_FontFamily, boost::optional< std::string > v3_FontStyle, boost::optional< std::string > v4_FontVariant, boost::optional< std::string > v5_FontWeight, IfcSizeSelect* v6_FontSize);
    typedef IfcTemplatedEntityList< IfcTextStyleFontModel > list;
};
/// IfcTrapeziumProfileDef defines a trapezium as the profile definition used by the swept surface geometry or the swept area solid. It is given by its Top X and Bottom X extent and its Y extent as well as by the offset of the Top X extend, and placed within the 2D position coordinate system, established by the Position attribute. It is placed centric within the position coordinate system, that is, in the center of the bounding box. 
/// 
/// HISTORY  New class in IFC 1.5. The use definition has changed in IFC2x.
/// 
/// Figure 325 illustrates parameters of the trapezium profile definition.
/// 
/// Position
/// 
/// The parameterized profile defines its own position coordinate system.
/// The underlying
/// coordinate system is defined by the swept surface or swept area solid
/// that uses the profile definition. It is the xy plane of either:
/// 
/// IfcSweptSurface.Position
///   IfcSweptAreaSolid.Position
/// 
/// or in case of sectioned spines the xy plane of each list member of IfcSectionedSpine.CrossSectionPositions.
/// 
/// By using offsets of the position location, the parameterized profile
/// can be positioned centric (using x,y offsets = 0.), or at any position
/// relative to the profile. Explicit coordinate offsets are used to define
/// cardinal points (e.g. upper-left bound).
///   Parameter
/// 
/// The IfcTrapeziumProfileDef
/// is defined within the position
/// coordinate system, where the BottomDim
/// defines the length
/// measure for the bottom line (half along the positive x-axis) and the YDim
/// defines the length measure for the parallel distance of bottom and top
/// line (half along the positive y-axis). The top line starts with a
/// distance of TopXOffset
/// from [-BottomLine/2,YDim] (which can be
/// negative, zero, or positive) and has a length of TopXDim
/// along
/// the positive x-axis.
/// 
/// Figure 325 — Trapezium profile
class IFC_PARSE_API IfcTrapeziumProfileDef : public IfcParameterizedProfileDef {
public:
    /// The extent of the bottom line measured along the implicit x-axis.
    double BottomXDim() const;
    void setBottomXDim(double v);
    /// The extent of the top line measured along the implicit x-axis.
    double TopXDim() const;
    void setTopXDim(double v);
    /// The extent of the distance between the parallel bottom and top lines measured along the implicit y-axis.
    double YDim() const;
    void setYDim(double v);
    /// Offset from the beginning of the top line to the bottom line, measured along the implicit x-axis.
    double TopXOffset() const;
    void setTopXOffset(double v);
    virtual unsigned int getArgumentCount() const { return 7; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 3: return IfcUtil::Argument_DOUBLE; case 4: return IfcUtil::Argument_DOUBLE; case 5: return IfcUtil::Argument_DOUBLE; case 6: return IfcUtil::Argument_DOUBLE; } return IfcParameterizedProfileDef::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 3: return Type::IfcPositiveLengthMeasure; case 4: return Type::IfcPositiveLengthMeasure; case 5: return Type::IfcPositiveLengthMeasure; case 6: return Type::IfcLengthMeasure; } return IfcParameterizedProfileDef::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 3: return "BottomXDim"; case 4: return "TopXDim"; case 5: return "YDim"; case 6: return "TopXOffset"; } return IfcParameterizedProfileDef::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcTrapeziumProfileDef (IfcEntityInstanceData* e);
    IfcTrapeziumProfileDef (IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< std::string > v2_ProfileName, IfcAxis2Placement2D* v3_Position, double v4_BottomXDim, double v5_TopXDim, double v6_YDim, double v7_TopXOffset);
    typedef IfcTemplatedEntityList< IfcTrapeziumProfileDef > list;
};
/// The object type defines the
/// specific information about a type, being common to all
/// occurrences of this type. It refers to the specific level of the
/// well recognized generic - specific - occurrance modeling
/// paradigm. The IfcTypeObject gets assigned to the
/// individual object instances (the occurrences) via the
/// IfcRelDefinesByType relationship.
/// NOTE The terms 'Type' and 'Style' are often
/// used interchangeably.
/// The object type is represented by a set of property set
/// definitions. The attached property sets describe the available
/// alpha-numeric information about the object type. and are used to
/// define all common properties that apply to all object occurrences
/// of that type.
/// NOTE If a property having having the same name
/// is used within the IfcPropertySet assigned to an
/// IfcTypeObject (and subtypes) and to an occurrence of that
/// type, then the occurrence property overrides the type property.
/// See IfcRelDefinesByType for an explanatory
/// figure.
/// Object types may be exchanged without being already assigned
/// to objects. An object type may have an indication of the library
/// (or catalogue) from which its definition originates. This
/// association is handled by the inherited HasAssociations
/// relationship pointing to IfcRelAssociatesLibrary.
/// 
/// HISTORY New entity in IFC Release 2x
/// 
/// IFC2x3 CHANGE The IfcTypeObject is now subtyped from the new supertype IfcObjectDefinition, and the attribute HasPropertySets has been changed from a LIST into a SET.
/// 
/// IFC2x4 CHANGE (1) The entity IfcTypeObject shall not be instantiated from IFC2x4 onwards. It will be changed into an ABSTRACT supertype in future releases of IFC. (2) The inverse attribute Types has been renamed from ObjectTypeOf.
class IFC_PARSE_API IfcTypeObject : public IfcObjectDefinition {
public:
    /// Whether the optional attribute ApplicableOccurrence is defined for this IfcTypeObject
    bool hasApplicableOccurrence() const;
    /// The attribute optionally defines the data type of the occurrence object, to which the assigned type object can relate. If not present, no instruction is given to which occurrence object the type object is applicable. The following conventions are used:
    /// 
    /// The IFC entity name of the applicable occurrence using the IFC naming convention, CamelCase with IFC prefix
    ///   It can be optionally followed by the predefined type after the separator "/" (forward slash), using Uupper case
    ///   If one type object is applicable to many occurrence objects, then those occurrence object names should be separate by comma "," forming a comma separated string.
    /// 
    /// EXAMPLE  Refering to a furniture as applicable occurrence entity would be expressed as 'IfcFurnishingElement', refering to a brace as applicable entity would be expressed as 'IfcMember/BRACE', refering to a wall and wall standard case would be expressed as 'IfcWall, IfcWallStandardCase'.
    std::string ApplicableOccurrence() const;
    void setApplicableOccurrence(std::string v);
    /// Whether the optional attribute HasPropertySets is defined for this IfcTypeObject
    bool hasHasPropertySets() const;
    /// Set list of unique property sets, that are associated with the object type and are common to all object occurrences referring to this object type.
    /// 
    /// IFC2x3 CHANGE  The attribute aggregate type has been changed from LIST to SET.
    IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr HasPropertySets() const;
    void setHasPropertySets(IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr v);
    virtual unsigned int getArgumentCount() const { return 6; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 4: return IfcUtil::Argument_STRING; case 5: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } return IfcObjectDefinition::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 4: return Type::IfcIdentifier; case 5: return Type::IfcPropertySetDefinition; } return IfcObjectDefinition::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 4: return "ApplicableOccurrence"; case 5: return "HasPropertySets"; } return IfcObjectDefinition::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcRelDefinesByType >::ptr Types() const; // INVERSE IfcRelDefinesByType::RelatingType
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcTypeObject (IfcEntityInstanceData* e);
    IfcTypeObject (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets);
    typedef IfcTemplatedEntityList< IfcTypeObject > list;
};
/// IfcTypeProcess defines a
/// specific (or type) definition of a process or activity without
/// being assigned to a schedule or a time.ÿIt is used to define a
/// process or activity specification, that is, the specific process or
/// activity information that is common to all occurrences that are
/// defined for that process or activity type.
/// 
/// An IfcTypeProcess may have a list of property set
/// attached. Values of these properties are common to all
/// occurrences of that process or activity type. The type occurrence
/// relationship is realized using the objectified relationship
/// IfcRelDefinesByType.
/// 
/// Subtypes of IfcTypeProcess may be exchanged without
/// being already assigned to subtypes of IfcProcess.
/// 
/// HISTORY New entity in IFC2x4.
/// 
/// Property set use definition
/// An IfcTypeProcess may have a list of property sets
/// attached, accessible by the attribute
/// SELF\IfcTypeObject.HasPropertySets. Currently there are no
/// predefined property sets defined as part of the IFC
/// specification.
/// NOTE: For property sets, a property within an
/// occurrence property set that is assigned at the process
/// occurrence, overrides the same property assigned to the process
/// type.
class IFC_PARSE_API IfcTypeProcess : public IfcTypeObject {
public:
    /// Whether the optional attribute Identification is defined for this IfcTypeProcess
    bool hasIdentification() const;
    /// An identifying designation given to a process type.
    std::string Identification() const;
    void setIdentification(std::string v);
    /// Whether the optional attribute LongDescription is defined for this IfcTypeProcess
    bool hasLongDescription() const;
    /// An long description, or text, describing the activity in detail.
    /// 
    /// NOTE The inherited SELF\IfcRoot.Description attribute is used as the short description.
    std::string LongDescription() const;
    void setLongDescription(std::string v);
    /// Whether the optional attribute ProcessType is defined for this IfcTypeProcess
    bool hasProcessType() const;
    /// The type denotes a particular type that indicates the process further. The use has to be established at the level of instantiable subtypes. In particular it holds the user defined type, if the enumeration of the attribute 'PredefinedType' is set to USERDEFINED.
    std::string ProcessType() const;
    void setProcessType(std::string v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 6: return IfcUtil::Argument_STRING; case 7: return IfcUtil::Argument_STRING; case 8: return IfcUtil::Argument_STRING; } return IfcTypeObject::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 6: return Type::IfcIdentifier; case 7: return Type::IfcText; case 8: return Type::IfcLabel; } return IfcTypeObject::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 6: return "Identification"; case 7: return "LongDescription"; case 8: return "ProcessType"; } return IfcTypeObject::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcRelAssignsToProcess >::ptr OperatesOn() const; // INVERSE IfcRelAssignsToProcess::RelatingProcess
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcTypeProcess (IfcEntityInstanceData* e);
    IfcTypeProcess (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< std::string > v7_Identification, boost::optional< std::string > v8_LongDescription, boost::optional< std::string > v9_ProcessType);
    typedef IfcTemplatedEntityList< IfcTypeProcess > list;
};
/// IfcTypeProduct defines a type
/// definition of a product without being already inserted into a
/// project structure (without having a placement), and not being
/// included into the geometric representation context of the
/// project.ÿIt is used to define a product specification, that is, the
/// specific product information that is common to all occurrences
/// of that product type.
/// 
/// An IfcTypeProduct may have a list of property set
/// attached and an optional set of product representations. Values
/// of these properties and the representation maps are common to all
/// occurrencesÿof that product type.ÿThe type occurrence
/// relationship is realized using the objectified relationship
/// IfcRelDefinesByType.
/// 
/// NOTE 1ÿ The product representations are
/// defined as representation maps, which gets assigned by a product
/// instance through the representation item(s) being an
/// IfcShapeRepresentation and having Items of
/// typeÿIfcMappedItem.
/// NOTE 2 ÿThe representations at the occurrence
/// level (represented by subtypes of IfcProduct) can override
/// the specific representations at the type level, ÿ
/// 
/// for geometric representations: a Cartesian
/// transformation operator can be applied at the occurrence level,
/// andÿ
/// for property sets: A property within an occurrence
/// property set, assigned at the product occurrence, overrides the
/// same property assigned to the product type.
/// 
/// An IfcTypeProduct may be exchanged without being
/// already assigned to subtypes of IfcProduct.
/// 
/// HISTORY New entity in IFC Release 2x.
/// 
/// IFC2x4 CHANGE The entity IfcTypeProduct shall not be instantiated from IFC2x4 onwards. It will be changed into an ABSTRACT supertype in future releases of IFC.
/// 
/// Geometry use definition
/// The RepresentationMaps define the type product shape
/// and multiple geometric representations can be assigned. If a
/// product occurrence is assigned to the type by using the
/// IfcRelDefinesByType relationship, then these occurrences
/// have to reference the representation maps. The reference is
/// created by one or multiple IfcShapeRepresentation's having
/// an IfcMappedItem as Items, that places the
/// IfcRepresentationMap of the type product into the spatial
/// contexts, i.e. by using an Cartesian transformation operator to
/// transform the IfcRepresentationMap into the object
/// coordinate system of the product occurrence.
/// 
/// Figure 10 illustrates an example of referencing a representation map by
/// the shape representation of a product occurrence. Here the
/// Cartesian transformation operator only uses translation, but no
/// rotation, mirroring, or scaling.
/// 
/// Figure 10 — Product type geometry with single placement
/// 
/// Figure 11 illustrates an example of referencing a representation
/// multiple times map by the shape representation of a product
/// occurrence. Here the Cartesian transformation operator only uses
/// translation, but no rotation, mirroring, or scaling. The
/// different translation values determine the pattern of the
/// multiple placement.
/// 
/// Figure 11 — Product type geometry with multiple placement
class IFC_PARSE_API IfcTypeProduct : public IfcTypeObject {
public:
    /// Whether the optional attribute RepresentationMaps is defined for this IfcTypeProduct
    bool hasRepresentationMaps() const;
    /// List of unique representation maps. Each representation map describes a block definition of the shape of the product style. By providing more than one representation map, a multi-view block definition can be given.
    IfcTemplatedEntityList< IfcRepresentationMap >::ptr RepresentationMaps() const;
    void setRepresentationMaps(IfcTemplatedEntityList< IfcRepresentationMap >::ptr v);
    /// Whether the optional attribute Tag is defined for this IfcTypeProduct
    bool hasTag() const;
    /// The tag (or label) identifier at the particular type of a product, e.g. the article number (like the EAN). It is the identifier at the specific level.
    std::string Tag() const;
    void setTag(std::string v);
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 6: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 7: return IfcUtil::Argument_STRING; } return IfcTypeObject::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 6: return Type::IfcRepresentationMap; case 7: return Type::IfcLabel; } return IfcTypeObject::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 6: return "RepresentationMaps"; case 7: return "Tag"; } return IfcTypeObject::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcRelAssignsToProduct >::ptr ReferencedBy() const; // INVERSE IfcRelAssignsToProduct::RelatingProduct
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcTypeProduct (IfcEntityInstanceData* e);
    IfcTypeProduct (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag);
    typedef IfcTemplatedEntityList< IfcTypeProduct > list;
};
/// IfcTypeResource defines a specific (or type) definition of a resource.ÿIt is used to define a resource specification (the specific resource, that is common to all occurrences that are defined for that resource) and could act as a resource template.
/// 
/// An IfcTypeResource may have a list of property sets attached. Values of these properties are common to all occurrences of that resource type. The type occurrence relationship is realized using the objectified relationship IfcRelDefinesByType.
/// 
/// Subtypes of IfcTypeResource may be exchanged without being already assigned to subtypes of IfcResource.
/// 
/// HISTORY New entity in IFC2x4.
/// 
/// Property set use definition
/// An IfcTypeResource may have a list of property sets attached, accessible by the attribute SELF\IfcTypeObject.HasPropertySets. Currently there are no predefined property sets defined as part of the IFC specification.
/// 
/// NOTE: For property sets, a property within an occurrence property set that is assigned at the resource occurrence, overrides the same property assigned to the resource type.
class IFC_PARSE_API IfcTypeResource : public IfcTypeObject {
public:
    /// Whether the optional attribute Identification is defined for this IfcTypeResource
    bool hasIdentification() const;
    /// An identifying designation given to a resource type.
    std::string Identification() const;
    void setIdentification(std::string v);
    /// Whether the optional attribute LongDescription is defined for this IfcTypeResource
    bool hasLongDescription() const;
    /// An long description, or text, describing the resource in detail.
    /// 
    /// NOTE The inherited SELF\IfcRoot.Description attribute is used as the short description.
    std::string LongDescription() const;
    void setLongDescription(std::string v);
    /// Whether the optional attribute ResourceType is defined for this IfcTypeResource
    bool hasResourceType() const;
    /// The type denotes a particular type that indicates the resource further. The use has to be established at the level of instantiable subtypes. In particular it holds the user defined type, if the enumeration of the attribute 'PredefinedType' is set to USERDEFINED.
    std::string ResourceType() const;
    void setResourceType(std::string v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 6: return IfcUtil::Argument_STRING; case 7: return IfcUtil::Argument_STRING; case 8: return IfcUtil::Argument_STRING; } return IfcTypeObject::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 6: return Type::IfcIdentifier; case 7: return Type::IfcText; case 8: return Type::IfcLabel; } return IfcTypeObject::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 6: return "Identification"; case 7: return "LongDescription"; case 8: return "ResourceType"; } return IfcTypeObject::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcRelAssignsToResource >::ptr ResourceOf() const; // INVERSE IfcRelAssignsToResource::RelatingResource
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcTypeResource (IfcEntityInstanceData* e);
    IfcTypeResource (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< std::string > v7_Identification, boost::optional< std::string > v8_LongDescription, boost::optional< std::string > v9_ResourceType);
    typedef IfcTemplatedEntityList< IfcTypeResource > list;
};
/// IfcUShapeProfileDef defines
/// a section profile that provides the defining parameters of a U-shape
/// (channel) section to be used by the swept area solid. Its parameters
/// and orientation relative to the position coordinate system are
/// according to the following illustration. The centre of the position
/// coordinate system is in the profile's centre of the bounding box.
/// 
/// HISTORY  New entity in IFC2x2.
/// 
/// IFC2x3 CHANGE  All profile origins are now in the center of the bounding box.
/// 
/// IFC2x4 CHANGE  Type of FilletRadius and EdgeRadius relaxed to allow for zero radius.
/// Trailing attribute CentreOfGravityInX deleted, use respective property in IfcExtendedProfileProperties instead.
/// 
/// Figure 327 illustrates parameters of the U-shape profile definition.
/// 
/// Position 
/// The parameterized profile defines its own position coordinate system.
/// The underlying coordinate system is defined by the swept area solid
/// that uses the profile definition. It is the xy plane of:
/// 
/// IfcSweptAreaSolid.Position
/// 
/// By using offsets of the position location, the parameterized profile
/// can be positioned centric (using x,y offsets = 0.), or at any position
/// relative to the profile.
/// 
/// Figure 327 — U-shape profile
class IFC_PARSE_API IfcUShapeProfileDef : public IfcParameterizedProfileDef {
public:
    /// Web lengths, see illustration above (= h).
    double Depth() const;
    void setDepth(double v);
    /// Flange lengths, see illustration above (= b).
    double FlangeWidth() const;
    void setFlangeWidth(double v);
    /// Constant wall thickness of web (= ts).
    double WebThickness() const;
    void setWebThickness(double v);
    /// Constant wall thickness of flange (= tg).
    double FlangeThickness() const;
    void setFlangeThickness(double v);
    /// Whether the optional attribute FilletRadius is defined for this IfcUShapeProfileDef
    bool hasFilletRadius() const;
    /// Fillet radius according the above illustration (= r1).
    double FilletRadius() const;
    void setFilletRadius(double v);
    /// Whether the optional attribute EdgeRadius is defined for this IfcUShapeProfileDef
    bool hasEdgeRadius() const;
    /// Edge radius according the above illustration (= r2).
    double EdgeRadius() const;
    void setEdgeRadius(double v);
    /// Whether the optional attribute FlangeSlope is defined for this IfcUShapeProfileDef
    bool hasFlangeSlope() const;
    /// Slope of flange of the profile.
    double FlangeSlope() const;
    void setFlangeSlope(double v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 3: return IfcUtil::Argument_DOUBLE; case 4: return IfcUtil::Argument_DOUBLE; case 5: return IfcUtil::Argument_DOUBLE; case 6: return IfcUtil::Argument_DOUBLE; case 7: return IfcUtil::Argument_DOUBLE; case 8: return IfcUtil::Argument_DOUBLE; case 9: return IfcUtil::Argument_DOUBLE; } return IfcParameterizedProfileDef::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 3: return Type::IfcPositiveLengthMeasure; case 4: return Type::IfcPositiveLengthMeasure; case 5: return Type::IfcPositiveLengthMeasure; case 6: return Type::IfcPositiveLengthMeasure; case 7: return Type::IfcNonNegativeLengthMeasure; case 8: return Type::IfcNonNegativeLengthMeasure; case 9: return Type::IfcPlaneAngleMeasure; } return IfcParameterizedProfileDef::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 3: return "Depth"; case 4: return "FlangeWidth"; case 5: return "WebThickness"; case 6: return "FlangeThickness"; case 7: return "FilletRadius"; case 8: return "EdgeRadius"; case 9: return "FlangeSlope"; } return IfcParameterizedProfileDef::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcUShapeProfileDef (IfcEntityInstanceData* e);
    IfcUShapeProfileDef (IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< std::string > v2_ProfileName, IfcAxis2Placement2D* v3_Position, double v4_Depth, double v5_FlangeWidth, double v6_WebThickness, double v7_FlangeThickness, boost::optional< double > v8_FilletRadius, boost::optional< double > v9_EdgeRadius, boost::optional< double > v10_FlangeSlope);
    typedef IfcTemplatedEntityList< IfcUShapeProfileDef > list;
};
/// Definition from ISO/CD 10303-42:1992: The vector is defined in terms of the direction and magnitude of the vector. The value of the magnitude attribute defines the magnitude of the vector. 
/// 
/// NOTE: The magnitude of the vector can not be reliable calculated from the components of the Orientation attribute. This form of representation was selected to reduce problems with numerical instability. For example a vector of magnitude 2.0 mm and equally inclined to the coordinate axes could be represented with Orientation attribute of (1.0,1.0,1.0).
/// 
/// NOTE: Corresponding ISO 10303 entity: vector. Please refer to ISO/IS 10303-42:1994, p.27 for the final definition of the formal standard. The derived attribute Dim has been added (see also note at IfcGeometricRepresentationItem).
/// 
/// HISTORY: New entity in IFC Release 1.0
class IFC_PARSE_API IfcVector : public IfcGeometricRepresentationItem {
public:
    /// The direction of the vector.
    IfcDirection* Orientation() const;
    void setOrientation(IfcDirection* v);
    /// The magnitude of the vector. All vectors of Magnitude 0.0 are regarded as equal in value regardless of the orientation attribute.
    double Magnitude() const;
    void setMagnitude(double v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_DOUBLE; } return IfcGeometricRepresentationItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcDirection; case 1: return Type::IfcLengthMeasure; } return IfcGeometricRepresentationItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Orientation"; case 1: return "Magnitude"; } return IfcGeometricRepresentationItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcVector (IfcEntityInstanceData* e);
    IfcVector (IfcDirection* v1_Orientation, double v2_Magnitude);
    typedef IfcTemplatedEntityList< IfcVector > list;
};
/// Definition from ISO/CD 10303-42:1992: A vertex_loop is a loop of
///   zero genus consisting of a single vertex. A vertex can exist independently of a
///   vertex loop. The topological data shall satisfy the following constraint:  
/// 
/// Informal propositions: 
/// 
/// A vertex loop has zero extent and dimensionality. 
///   The vertex loop has genus 0. 
/// 
/// NOTE  Corresponding ISO 10303 entity: vertex_loop. Please refer to ISO/IS 10303-42:1994, p. 121 for the final definition of the formal standard.
/// 
/// HISTORY  New Entity in IFC2x2.
class IFC_PARSE_API IfcVertexLoop : public IfcLoop {
public:
    /// The vertex which defines the entire loop.
    IfcVertex* LoopVertex() const;
    void setLoopVertex(IfcVertex* v);
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcLoop::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcVertex; } return IfcLoop::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "LoopVertex"; } return IfcLoop::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcVertexLoop (IfcEntityInstanceData* e);
    IfcVertexLoop (IfcVertex* v1_LoopVertex);
    typedef IfcTemplatedEntityList< IfcVertexLoop > list;
};
/// Definition: The window style defines a particular style of windows, which may be included into the spatial context of the building model through instances of IfcWindow. A window style defines the overall parameter of the window style and refers to the particular parameter of the lining and one (or several) panels through IfcWindowLiningProperties and IfcWindowPanelProperties.
/// 
/// The window entity (IfcWindow) defines a particular occurrence of a window inserted in the spatial context of a project. The actual parameter of the window and/or its shape is defined at the IfcWindowStyle, to which the IfcWindow related by the inverse relationship IsDefinedBy pointing to IfcRelDefinesByType. The IfcWindowStyle also defines the particular attributes for the lining (IfcWindowLiningProperties) and panels (IfcWindowPanelProperties).
/// 
/// HISTORY New entity in IFC Release 2x.
/// 
/// IFC2x4 CHANGE The entity has been deprecated and shall not be used. The new entity IfcWindowType shall be used instead.
/// 
/// Geometry use definitions
/// The IfcWindowStyle defines the baseline geometry, or the representation map, for all occurrences of the window style,
/// given by the IfcWindow, pointing to this style. The representation of the window style may be given by the agreed set
/// of minimal parameters, defined for the window lining and the window panel(s), or it may be given by a geometric representation
/// used by the IfcRepresentationMap. The attribute ParameterTakesPrecedence decides, whether the set of
/// parameters can be used to exactly represent the shape of the window style (TRUE), or whether the attached IfcRepresentationMap holds the exact representation (FALSE).
/// 
/// The IfcWindowStyleOperationTypeEnum defines the general layout of the window style. Depending on the enumerator, the
/// appropriate instances of IfcWindowLiningProperties and IfcWindowPanelProperties are attached in the list of
/// HasPropertySets. See geometry use definitions there.
class IFC_PARSE_API IfcWindowStyle : public IfcTypeProduct {
public:
    /// Type defining the basic construction and material type of the window.
    IfcWindowStyleConstructionEnum::IfcWindowStyleConstructionEnum ConstructionType() const;
    void setConstructionType(IfcWindowStyleConstructionEnum::IfcWindowStyleConstructionEnum v);
    /// Type defining the general layout and operation of the window style.
    IfcWindowStyleOperationEnum::IfcWindowStyleOperationEnum OperationType() const;
    void setOperationType(IfcWindowStyleOperationEnum::IfcWindowStyleOperationEnum v);
    /// The Boolean value reflects, whether the parameter given in the attached lining and panel properties exactly define the geometry (TRUE), or whether the attached style shape take precedence (FALSE). In the last case the parameter have only informative value.
    bool ParameterTakesPrecedence() const;
    void setParameterTakesPrecedence(bool v);
    /// The Boolean indicates, whether the attached ShapeStyle can be sized (using scale factor of transformation), or not (FALSE). If not, the ShapeStyle should be inserted by the IfcWindow (using IfcMappedItem) with the scale factor = 1.
    bool Sizeable() const;
    void setSizeable(bool v);
    virtual unsigned int getArgumentCount() const { return 12; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; case 9: return IfcUtil::Argument_ENUMERATION; case 10: return IfcUtil::Argument_BOOL; case 11: return IfcUtil::Argument_BOOL; } return IfcTypeProduct::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcWindowStyleConstructionEnum; case 9: return Type::IfcWindowStyleOperationEnum; case 10: return Type::IfcBoolean; case 11: return Type::IfcBoolean; } return IfcTypeProduct::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "ConstructionType"; case 9: return "OperationType"; case 10: return "ParameterTakesPrecedence"; case 11: return "Sizeable"; } return IfcTypeProduct::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcWindowStyle (IfcEntityInstanceData* e);
    IfcWindowStyle (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, IfcWindowStyleConstructionEnum::IfcWindowStyleConstructionEnum v9_ConstructionType, IfcWindowStyleOperationEnum::IfcWindowStyleOperationEnum v10_OperationType, bool v11_ParameterTakesPrecedence, bool v12_Sizeable);
    typedef IfcTemplatedEntityList< IfcWindowStyle > list;
};
/// IfcZShapeProfileDef defines
/// a section profile that provides the defining parameters of a Z-shape
/// section to be used by the swept area solid. Its parameters and
/// orientation relative to the position coordinate system are according to
/// the following illustration. The centre of the position coordinate
/// system is in the profile's centre of the bounding box.
/// 
/// HISTORY  New entity in IFC2x2.
/// 
/// IFC2x Edition 4 CHANGE  Type of FilletRadius and EdgeRadius relaxed to allow for zero radius.
/// 
/// Figure 328 illustrates parameters of the Z-shape profile definition.
/// 
/// Position
/// The parameterized profile defines its own position coordinate system.
/// The underlying coordinate system is defined by the swept area solid
/// that uses the profile definition. It is the xy plane of:
/// 
/// IfcSweptAreaSolid.Position
/// 
/// By using offsets of the position location, the parameterized profile
/// can be positioned centric (using x,y offsets = 0.), or at any position
/// relative to the profile.
/// 
/// Figure 328 — Z-shape profile
class IFC_PARSE_API IfcZShapeProfileDef : public IfcParameterizedProfileDef {
public:
    /// Web length, see illustration above (= h).
    double Depth() const;
    void setDepth(double v);
    /// Flange length, see illustration above (= b).
    double FlangeWidth() const;
    void setFlangeWidth(double v);
    /// Constant wall thickness of web, see illustration above (= ts).
    double WebThickness() const;
    void setWebThickness(double v);
    /// Constant wall thickness of flange, see illustration above (= tg).
    double FlangeThickness() const;
    void setFlangeThickness(double v);
    /// Whether the optional attribute FilletRadius is defined for this IfcZShapeProfileDef
    bool hasFilletRadius() const;
    /// Fillet radius according the above illustration (= r1).
    double FilletRadius() const;
    void setFilletRadius(double v);
    /// Whether the optional attribute EdgeRadius is defined for this IfcZShapeProfileDef
    bool hasEdgeRadius() const;
    /// Edge radius according the above illustration (= r2).
    double EdgeRadius() const;
    void setEdgeRadius(double v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 3: return IfcUtil::Argument_DOUBLE; case 4: return IfcUtil::Argument_DOUBLE; case 5: return IfcUtil::Argument_DOUBLE; case 6: return IfcUtil::Argument_DOUBLE; case 7: return IfcUtil::Argument_DOUBLE; case 8: return IfcUtil::Argument_DOUBLE; } return IfcParameterizedProfileDef::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 3: return Type::IfcPositiveLengthMeasure; case 4: return Type::IfcPositiveLengthMeasure; case 5: return Type::IfcPositiveLengthMeasure; case 6: return Type::IfcPositiveLengthMeasure; case 7: return Type::IfcNonNegativeLengthMeasure; case 8: return Type::IfcNonNegativeLengthMeasure; } return IfcParameterizedProfileDef::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 3: return "Depth"; case 4: return "FlangeWidth"; case 5: return "WebThickness"; case 6: return "FlangeThickness"; case 7: return "FilletRadius"; case 8: return "EdgeRadius"; } return IfcParameterizedProfileDef::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcZShapeProfileDef (IfcEntityInstanceData* e);
    IfcZShapeProfileDef (IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< std::string > v2_ProfileName, IfcAxis2Placement2D* v3_Position, double v4_Depth, double v5_FlangeWidth, double v6_WebThickness, double v7_FlangeThickness, boost::optional< double > v8_FilletRadius, boost::optional< double > v9_EdgeRadius);
    typedef IfcTemplatedEntityList< IfcZShapeProfileDef > list;
};
/// An advanced face is a specialization of a face surface that has to meet requirements on using particular topological and geometric representation items for the definition of the faces, edges and vertices.
/// 
/// An IfcAdvancedFace is restricted to:
/// 
/// have a face surface geometry of type IfcElementarySurface, IfcSweptSurface or IfcBSplineSurface
/// have at least on IfcFaceOuterBound as the bound of the face
/// have all faces to be bound by IfcEdgeLoop or IfcVertexLoop
/// have all edges to have an edge curve geometry have the edge curve geometry restricted to IfcLine, IfcConic, IfcPolyline, or IfcBSplineCurve
/// 
/// NOTE  Corresponding ISO 10303 entity: advanced_face. Please refer to ISO/IS 10303-511:1999 for
/// the final definition of the formal standard.
/// 
/// HISTORY  New entity in IFC2x4
class IFC_PARSE_API IfcAdvancedFace : public IfcFaceSurface {
public:
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcFaceSurface::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcFaceSurface::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcFaceSurface::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcAdvancedFace (IfcEntityInstanceData* e);
    IfcAdvancedFace (IfcTemplatedEntityList< IfcFaceBound >::ptr v1_Bounds, IfcSurface* v2_FaceSurface, bool v3_SameSense);
    typedef IfcTemplatedEntityList< IfcAdvancedFace > list;
};
/// Definition from ISO/CD 10303-46:1992: An annotation fill area is a set of curves that may be filled with hatching, colour or tiling. The annotation fill are is described by boundaries which consist of non-intersecting, non-self-intersecting closed curves. These curves form the boundary of planar areas to be filled according to the style for the annotation fill area.
/// 
/// NOTE: A curve that is not surrounded by any other curve is a border between an unfilled area on the outside and a filled area on the inside. Another curve may surround an unfilled area if it is surrounded by another curve whose inside is a filled area.
/// 
/// Figure 300 (from ISO 10303-46) illustrates annotation fill area.
/// 
/// Figure 300 — Annotation fill area
/// 
/// NOTE  Corresponding ISO 10303 name: annotation_fill_area. Please refer to ISO/IS 10303-46:1994 for the final definition of the formal standard.
/// 
/// The IfcAnnotationFillArea defines an area by a definite OuterBoundary, that might include InnerBoundaries. The areas defined by the InnerBoundaries are excluded from applying the fill area style.
/// 
/// Informal Proposition:
/// 
/// Any curve that describes an inner boundary shall not intersect with, nor include, another curve defining an inner boundary.
///   The curve defining the outer boundary shall not intersect with any curve defining an inner boundary, nor shall it be surrounded by a curve defining an inner boundary.
/// 
/// HISTORY  New entity in IFC2x2.
/// 
/// IFC2x3 CHANGE  The two attributes OuterBoundary and InnerBoundaries are added and replace the previous single boundary.
class IFC_PARSE_API IfcAnnotationFillArea : public IfcGeometricRepresentationItem {
public:
    /// A closed curve that defines the outer boundary of the fill area. The areas defined by the outer boundary (minus potentially defined inner boundaries) is filled by the fill area style.
    /// 
    /// IFC2x Edition 3 CHANGE  The two new attributes OuterBoundary and InnerBoundaries replace the old single attribute Boundaries.
    IfcCurve* OuterBoundary() const;
    void setOuterBoundary(IfcCurve* v);
    /// Whether the optional attribute InnerBoundaries is defined for this IfcAnnotationFillArea
    bool hasInnerBoundaries() const;
    /// A set of inner curves that define the inner boundaries of the fill area. The areas defined by the inner boundaries are excluded from applying the fill area style.
    /// 
    /// IFC2x Edition 3 CHANGE  The two new attributes OuterBoundary and InnerBoundaries replace the old single attribute Boundaries.
    IfcTemplatedEntityList< IfcCurve >::ptr InnerBoundaries() const;
    void setInnerBoundaries(IfcTemplatedEntityList< IfcCurve >::ptr v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } return IfcGeometricRepresentationItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcCurve; case 1: return Type::IfcCurve; } return IfcGeometricRepresentationItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "OuterBoundary"; case 1: return "InnerBoundaries"; } return IfcGeometricRepresentationItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcAnnotationFillArea (IfcEntityInstanceData* e);
    IfcAnnotationFillArea (IfcCurve* v1_OuterBoundary, boost::optional< IfcTemplatedEntityList< IfcCurve >::ptr > v2_InnerBoundaries);
    typedef IfcTemplatedEntityList< IfcAnnotationFillArea > list;
};
/// IfcAsymmetricIShapeProfileDef
/// defines a section profile that provides the defining parameters of a
/// singly symmetric I-shaped section. Its parameters and orientation relative to the
/// position coordinate system are according to the following illustration.
/// The centre of the position coordinate system is in the profile's centre
/// of the bounding box.
/// 
/// The inherited attributes are redefined as:
/// 
/// OverallWidth -- BottomFlangeWidth
///   FlangeThickness -- BottomFlangeThickness
///   FilletRadius -- BottomFlangeFilletRadius
/// 
/// The overall width of the profile is implicitly given by the maximum of
/// the bottom flange width and the top flange width.
/// 
/// IfcAsymmetricIShapeProfileDef can also be used to model rail profiles
/// if the application scenario does not require a full explicit shape model of the
/// rail profile. Alternatively, IfcArbitraryClosedProfileDef can be
/// used to provide the exact shape of rail profiles. Either way, a reference
/// to an external document or library should be provided to further define the
/// profile as described at IfcProfileDef.
/// 
/// HISTORY  New entity in Release IFC2x Edition 2.
/// 
/// IFC2x3 CHANGE  All profile origins are now in the center of the bounding box. The attribute CentreOfGravityInY has been made OPTIONAL.
/// 
/// IFC2x4 CHANGE  Bottom flange is not necessarily wider than top flange. TopFlangeThickness changed from OPTIONAL to mandatory. Type of TopFlangeFilletRadius relaxed to allow for zero radius. Trailing attribute CentreOfGravityInY deleted, use respective property in IfcExtendedProfileProperties instead.
/// 
/// Figure 310 illustrates parameters of the asymmetric I-shaped section definition. The parameterized profile defines its own position coordinate system. The underlying coordinate system is defined by the swept area solid that uses the profile definition. It is the xy plane of:
/// 
/// IfcSweptAreaSolid.Position
/// 
/// By using offsets of the position location, the parameterized profile can be positioned centric (using x,y offsets = 0.), or at any position
/// relative to the profile. The parameterized profile is defined by a set of parameter attributes.  In the illustrated example, the 'CentreOfGravityInY' property in IfcExtendedProfileProperties, if provided, is negative.
/// 
/// Figure 310 — Assymetric I-shape profile
class IFC_PARSE_API IfcAsymmetricIShapeProfileDef : public IfcParameterizedProfileDef {
public:
    double BottomFlangeWidth() const;
    void setBottomFlangeWidth(double v);
    double OverallDepth() const;
    void setOverallDepth(double v);
    double WebThickness() const;
    void setWebThickness(double v);
    double BottomFlangeThickness() const;
    void setBottomFlangeThickness(double v);
    /// Whether the optional attribute BottomFlangeFilletRadius is defined for this IfcAsymmetricIShapeProfileDef
    bool hasBottomFlangeFilletRadius() const;
    double BottomFlangeFilletRadius() const;
    void setBottomFlangeFilletRadius(double v);
    /// Extent of the top flange, defined parallel to the x axis of the position coordinate system.
    double TopFlangeWidth() const;
    void setTopFlangeWidth(double v);
    /// Whether the optional attribute TopFlangeThickness is defined for this IfcAsymmetricIShapeProfileDef
    bool hasTopFlangeThickness() const;
    /// Flange thickness of the top flange of the I-shape.
    double TopFlangeThickness() const;
    void setTopFlangeThickness(double v);
    /// Whether the optional attribute TopFlangeFilletRadius is defined for this IfcAsymmetricIShapeProfileDef
    bool hasTopFlangeFilletRadius() const;
    /// The fillet between the web and the top flange of the I-shape.
    double TopFlangeFilletRadius() const;
    void setTopFlangeFilletRadius(double v);
    /// Whether the optional attribute BottomFlangeEdgeRadius is defined for this IfcAsymmetricIShapeProfileDef
    bool hasBottomFlangeEdgeRadius() const;
    double BottomFlangeEdgeRadius() const;
    void setBottomFlangeEdgeRadius(double v);
    /// Whether the optional attribute BottomFlangeSlope is defined for this IfcAsymmetricIShapeProfileDef
    bool hasBottomFlangeSlope() const;
    double BottomFlangeSlope() const;
    void setBottomFlangeSlope(double v);
    /// Whether the optional attribute TopFlangeEdgeRadius is defined for this IfcAsymmetricIShapeProfileDef
    bool hasTopFlangeEdgeRadius() const;
    double TopFlangeEdgeRadius() const;
    void setTopFlangeEdgeRadius(double v);
    /// Whether the optional attribute TopFlangeSlope is defined for this IfcAsymmetricIShapeProfileDef
    bool hasTopFlangeSlope() const;
    double TopFlangeSlope() const;
    void setTopFlangeSlope(double v);
    virtual unsigned int getArgumentCount() const { return 15; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 3: return IfcUtil::Argument_DOUBLE; case 4: return IfcUtil::Argument_DOUBLE; case 5: return IfcUtil::Argument_DOUBLE; case 6: return IfcUtil::Argument_DOUBLE; case 7: return IfcUtil::Argument_DOUBLE; case 8: return IfcUtil::Argument_DOUBLE; case 9: return IfcUtil::Argument_DOUBLE; case 10: return IfcUtil::Argument_DOUBLE; case 11: return IfcUtil::Argument_DOUBLE; case 12: return IfcUtil::Argument_DOUBLE; case 13: return IfcUtil::Argument_DOUBLE; case 14: return IfcUtil::Argument_DOUBLE; } return IfcParameterizedProfileDef::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 3: return Type::IfcPositiveLengthMeasure; case 4: return Type::IfcPositiveLengthMeasure; case 5: return Type::IfcPositiveLengthMeasure; case 6: return Type::IfcPositiveLengthMeasure; case 7: return Type::IfcNonNegativeLengthMeasure; case 8: return Type::IfcPositiveLengthMeasure; case 9: return Type::IfcPositiveLengthMeasure; case 10: return Type::IfcNonNegativeLengthMeasure; case 11: return Type::IfcNonNegativeLengthMeasure; case 12: return Type::IfcPlaneAngleMeasure; case 13: return Type::IfcNonNegativeLengthMeasure; case 14: return Type::IfcPlaneAngleMeasure; } return IfcParameterizedProfileDef::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 3: return "BottomFlangeWidth"; case 4: return "OverallDepth"; case 5: return "WebThickness"; case 6: return "BottomFlangeThickness"; case 7: return "BottomFlangeFilletRadius"; case 8: return "TopFlangeWidth"; case 9: return "TopFlangeThickness"; case 10: return "TopFlangeFilletRadius"; case 11: return "BottomFlangeEdgeRadius"; case 12: return "BottomFlangeSlope"; case 13: return "TopFlangeEdgeRadius"; case 14: return "TopFlangeSlope"; } return IfcParameterizedProfileDef::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcAsymmetricIShapeProfileDef (IfcEntityInstanceData* e);
    IfcAsymmetricIShapeProfileDef (IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< std::string > v2_ProfileName, IfcAxis2Placement2D* v3_Position, double v4_BottomFlangeWidth, double v5_OverallDepth, double v6_WebThickness, double v7_BottomFlangeThickness, boost::optional< double > v8_BottomFlangeFilletRadius, double v9_TopFlangeWidth, boost::optional< double > v10_TopFlangeThickness, boost::optional< double > v11_TopFlangeFilletRadius, boost::optional< double > v12_BottomFlangeEdgeRadius, boost::optional< double > v13_BottomFlangeSlope, boost::optional< double > v14_TopFlangeEdgeRadius, boost::optional< double > v15_TopFlangeSlope);
    typedef IfcTemplatedEntityList< IfcAsymmetricIShapeProfileDef > list;
};
/// Definition from ISO/CD 10303-42:1992: The direction and location in three dimensional space of a single axis. An axis1_placement is defined in terms of a locating point (inherited from placement supertype) and an axis direction: this is either the direction of axis or defaults to (0.0,0.0,1.0). The actual direction for the axis placement is given by the derived attribute z (Z).  
/// 
/// NOTE  Corresponding ISO 10303 name: axis1_placement, please refer to ISO/IS 10303-42:1994, p. 28 for the final definition of the formal standard.
/// 
/// HISTORY  New entity in IFC Release 1.5
/// 
/// Figure 274 illustrates the definition of the IfcAxis1Placement within the three-dimensional coordinate system.
/// 
/// Figure 274 — Axis1 placement
class IFC_PARSE_API IfcAxis1Placement : public IfcPlacement {
public:
    /// Whether the optional attribute Axis is defined for this IfcAxis1Placement
    bool hasAxis() const;
    /// The direction of the local Z axis.
    IfcDirection* Axis() const;
    void setAxis(IfcDirection* v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 1: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcPlacement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 1: return Type::IfcDirection; } return IfcPlacement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 1: return "Axis"; } return IfcPlacement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcAxis1Placement (IfcEntityInstanceData* e);
    IfcAxis1Placement (IfcCartesianPoint* v1_Location, IfcDirection* v2_Axis);
    typedef IfcTemplatedEntityList< IfcAxis1Placement > list;
};
/// Definition from ISO/CD 10303-42:1992: The location and orientation in two dimensional space of two mutually perpendicular axes. An axis2_placement_2d is defined in terms of a point, (inherited from the placement supertype), and an axis. It can be used to locate and originate an object in two dimensional space and to define a placement coordinate system. The class includes a point which forms the origin of the placement coordinate system. A direction vector is required to complete the definition of the placement coordinate system. The reference direction defines the placement X axis direction, the placement Y axis is derived from this.  
/// 
/// If the RefDirection attribute is not given, the placement defaults to P[1] (x-axis) as [1.,0.] and P[2] (y-axis) as [0.,1.].  
/// 
/// NOTE  Corresponding ISO 10303 name: axis2_placement_2d, please refer to ISO/IS 10303-42:1994, p. 28 for the final definition of the formal standard.
/// 
/// HISTORY  New entity in IFC Release 1.5.
/// 
/// Figure 275 illustrates the definition of the IfcAxis2Placement2D within the two-dimensional coordinate system. 
/// 
/// Figure 275 — Axis2 placement 2D
class IFC_PARSE_API IfcAxis2Placement2D : public IfcPlacement {
public:
    /// Whether the optional attribute RefDirection is defined for this IfcAxis2Placement2D
    bool hasRefDirection() const;
    /// The direction used to determine the direction of the local X axis. If a value is omited that it defaults to [1.0, 0.0.].
    IfcDirection* RefDirection() const;
    void setRefDirection(IfcDirection* v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 1: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcPlacement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 1: return Type::IfcDirection; } return IfcPlacement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 1: return "RefDirection"; } return IfcPlacement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcAxis2Placement2D (IfcEntityInstanceData* e);
    IfcAxis2Placement2D (IfcCartesianPoint* v1_Location, IfcDirection* v2_RefDirection);
    typedef IfcTemplatedEntityList< IfcAxis2Placement2D > list;
};
/// Definition from ISO/CD 10303-42:1992: The location and orientation in three dimensional space of three mutually perpendicular axes. An axis2_placement_3D is defined in terms of a point (inherited from placement supertype) and two (ideally orthogonal) axes. It can be used to locate and originate an object in three dimensional space and to define a placement coordinate system. The entity includes a point which forms the origin of the placement coordinate system. Two direction vectors are required to complete the definition of the placement coordinate system. The axis is the placement Z axis direction and the ref_direction is an approximation to the placement X axis direction.
/// 
/// If the attribute values for Axis and RefDirection
/// are not given, the placement defaults to P[1] (x-axis) as [1.,0.,0.],
/// P[2] (y-axis) as [0.,1.,0.] and P[3] (z-axis) as [0.,0.,1.].
/// 
/// NOTE  Corresponding ISO 10303 name: axis2_placement_3d, please refer to ISO/IS 10303-42:1994 for the final definition of the formal standard. The WR5 is added to ensure that either both attributes Axis and RefDirection are given, or both are omitted.
/// 
/// HISTORY  New entity in IFC Release 1.5.
/// 
/// Figure 276 illustrates the definition of the IfcAxis2Placement3D within the three-dimensional coordinate system.
/// 
/// Figure 276 — Axis2 placement 3D
class IFC_PARSE_API IfcAxis2Placement3D : public IfcPlacement {
public:
    /// Whether the optional attribute Axis is defined for this IfcAxis2Placement3D
    bool hasAxis() const;
    /// The exact direction of the local Z Axis.
    IfcDirection* Axis() const;
    void setAxis(IfcDirection* v);
    /// Whether the optional attribute RefDirection is defined for this IfcAxis2Placement3D
    bool hasRefDirection() const;
    /// The direction used to determine the direction of the local X Axis. If necessary an adjustment is made to maintain orthogonality to the Axis direction. If Axis and/or RefDirection is omitted, these directions are taken from the geometric coordinate system.
    IfcDirection* RefDirection() const;
    void setRefDirection(IfcDirection* v);
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 1: return IfcUtil::Argument_ENTITY_INSTANCE; case 2: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcPlacement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 1: return Type::IfcDirection; case 2: return Type::IfcDirection; } return IfcPlacement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 1: return "Axis"; case 2: return "RefDirection"; } return IfcPlacement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcAxis2Placement3D (IfcEntityInstanceData* e);
    IfcAxis2Placement3D (IfcCartesianPoint* v1_Location, IfcDirection* v2_Axis, IfcDirection* v3_RefDirection);
    typedef IfcTemplatedEntityList< IfcAxis2Placement3D > list;
};
/// Definition from ISO/CD 10303-42:1992: A Boolean result
/// is the result of a regularized operation on two solids to create
/// a new solid. Valid operations are regularized union, regularized
/// intersection, and regularized difference. For purpose of Boolean
/// operations, a solid is considered to be a regularized set of
/// points. The final Boolean result depends upon the operation and
/// the two operands. In the case of the difference operator the
/// order of the operands is also significant. The operator can be
/// either union, intersection or difference. The effect of these
/// operators is described below:
/// 
/// Union on two solids is the new solid that is the
/// regularization of the set of all points that are in either the
/// first operand or the second operand or in both.
/// Intersection on two solids is the new solid that is the
/// regularization of the set of all points that are in both the
/// first operand and the second operand.
/// The result of the difference operation on two solids is the
/// regularization of the set of all points which are in the first
/// operand, but not in the second operand.
/// 
/// NOTE For example if the first operand is a block and the second operand is a solid cylinder of suitable dimensions and location, the boolean result produced with the difference operator would be a block with a circular hole.
/// 
/// NOTE Corresponding ISO 10303-42 entity: boolean_result. The derived attribute Dim has been added at this level and was therefore demoted from the geometric_representation_item. Please refer to ISO/IS 10303-42:1994, p.175 for the final definition of the formal standard.
/// 
/// HISTORY: New class in IFC Release 1.5.1.
class IFC_PARSE_API IfcBooleanResult : public IfcGeometricRepresentationItem {
public:
    /// The Boolean operator used in the operation to create the result.
    IfcBooleanOperator::IfcBooleanOperator Operator() const;
    void setOperator(IfcBooleanOperator::IfcBooleanOperator v);
    /// The first operand to be operated upon by the Boolean operation.
    IfcBooleanOperand* FirstOperand() const;
    void setFirstOperand(IfcBooleanOperand* v);
    /// The second operand specified for the operation.
    IfcBooleanOperand* SecondOperand() const;
    void setSecondOperand(IfcBooleanOperand* v);
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENUMERATION; case 1: return IfcUtil::Argument_ENTITY_INSTANCE; case 2: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcGeometricRepresentationItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcBooleanOperator; case 1: return Type::IfcBooleanOperand; case 2: return Type::IfcBooleanOperand; } return IfcGeometricRepresentationItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Operator"; case 1: return "FirstOperand"; case 2: return "SecondOperand"; } return IfcGeometricRepresentationItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcBooleanResult (IfcEntityInstanceData* e);
    IfcBooleanResult (IfcBooleanOperator::IfcBooleanOperator v1_Operator, IfcBooleanOperand* v2_FirstOperand, IfcBooleanOperand* v3_SecondOperand);
    typedef IfcTemplatedEntityList< IfcBooleanResult > list;
};
/// Definition from ISO/CD 10303-42:1992: A bounded surface is a surface of finite area with identifiable boundaries.
/// 
/// NOTE Corresponding ISO 10303 name: bounded_surface. Please refer to ISO/IS 10303-42:1994, p.78 for the final definition of the formal standard.
/// 
/// HISTORY New entity in IFC Release 2x
/// 
/// IFC2x4 CHANGE Entity made abstract.
/// 
/// Informal propositions:
/// 
/// A bounded surface has finite non-zero surface area.
/// A bounded surface has boundary curves.
class IFC_PARSE_API IfcBoundedSurface : public IfcSurface {
public:
    virtual unsigned int getArgumentCount() const { return 0; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcSurface::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcSurface::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcSurface::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcBoundedSurface (IfcEntityInstanceData* e);
    IfcBoundedSurface ();
    typedef IfcTemplatedEntityList< IfcBoundedSurface > list;
};
/// Definition from ISO/CD 10303-42:1992: A box domain
///   is an orthogonal box parallel to the axes of the geometric
///   coordinate system which may be used to limit the domain of
///   a half space solid. A box domain is specified by the
///   coordinates of the bottom left corner, and the lengths of
///   the sides measured in the directions of the coordinate
///   axes.
/// 
/// Every semantic object having a
///   physical extent might have a minimum default representation
///   of a bounding box. The bounding box is therefore also used
///   as minimal geometric representation for any geometrically
///   represented object. Therefore the IfcBoundingBox is
///   subtyped from IfcGeometricRepresentationItem.
/// 
/// NOTE Corresponding ISO 10303-42 entity: box_domain, please refer to ISO/IS 10303-42:1994, p. 186 for the final definition of the formal standard. In IFC the bounding box can also be used outside of the context of an IfcBoxedHalfSpace.
/// 
/// HISTORY New entity in IFC Release 1.0.
/// 
/// As shown in Figure 252, the IfcBoundingBox is defined with its own location which can be used to place the IfcBoundingBox relative to the geometric coordinate system. The IfcBoundingBox is defined by the lower left corner (Corner) and the upper right corner (XDim, YDim, ZDim measured within the parent co-ordinate system).
/// 
/// Figure 252 — Bounding box
class IFC_PARSE_API IfcBoundingBox : public IfcGeometricRepresentationItem {
public:
    /// Location of the bottom left corner (having the minimum values).
    IfcCartesianPoint* Corner() const;
    void setCorner(IfcCartesianPoint* v);
    /// Length attribute (measured along the edge parallel to the X Axis)
    double XDim() const;
    void setXDim(double v);
    /// Width attribute (measured along the edge parallel to the Y Axis)
    double YDim() const;
    void setYDim(double v);
    /// Height attribute (measured along the edge parallel to the Z Axis).
    double ZDim() const;
    void setZDim(double v);
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_DOUBLE; case 2: return IfcUtil::Argument_DOUBLE; case 3: return IfcUtil::Argument_DOUBLE; } return IfcGeometricRepresentationItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcCartesianPoint; case 1: return Type::IfcPositiveLengthMeasure; case 2: return Type::IfcPositiveLengthMeasure; case 3: return Type::IfcPositiveLengthMeasure; } return IfcGeometricRepresentationItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Corner"; case 1: return "XDim"; case 2: return "YDim"; case 3: return "ZDim"; } return IfcGeometricRepresentationItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcBoundingBox (IfcEntityInstanceData* e);
    IfcBoundingBox (IfcCartesianPoint* v1_Corner, double v2_XDim, double v3_YDim, double v4_ZDim);
    typedef IfcTemplatedEntityList< IfcBoundingBox > list;
};
/// Definition from ISO/CD 10303-42:1992: This entity is a subtype of the half space solid which is trimmed by a surrounding rectangular box. The box has its edges parallel to the coordinate axes of the geometric coordinate system.
/// 
/// NOTE  The purpose of the box is to facilitate CSG computations by producing a solid of finite size.
/// 
/// The IfcBoxedHalfSpace is
/// used (as its supertype IfcHalfSpaceSolid) only within
/// Boolean operations. It divides the domain into exactly two
/// subsets, where the domain in question is that of the attribute
/// Enclosure.
/// The purpose of the attribute Enclosure is to provide a
/// search box for the other operand in the Boolean operation. It
/// shall be sufficiently large to fully enclose the resulting solid
/// after the Boolean operation with the half space. It however does
/// not alter the final result. The result of the Boolean operation
/// would be the same, as if executed by the supertype
/// IfcHalfSpaceSolid. See Figure 253 below.
/// 
/// Figure 253 — Boxed half space operands
/// 
/// NOTE Corresponding ISO 10303-42 entity: boxed_half_space, please refer to ISO/IS 10303-42:1994, p. 185 for the final definition of the formal standard. The IFC class IfcBoundingBox is used for the definition of the enclosure, providing the same definition as box_domain.
/// 
/// HISTORY  New entity in IFC Release 1.5.1, improved documentation available in IFC Release 2x.
/// 
/// IFC2x4 CHANGE  Usage correct, position coordinate system for Enclosure is the object coordinate system.
/// 
/// The IfcBoundingBox (relating to ISO 10303-42:1994 box_domain) that provides the enclosure is given for the convenience of the receiving application to enable the use of size box comparison for efficiency (for example, to check first whether size boxes intersect, if not no calculations has to be done to check whether the solids of the entities intersect).
/// 
/// The Enclosure therefore helps to prevent dealing with infinite-size related issues. The enclosure box is positioned within the object coordinate system, established by the ObjectPlacement of the element represented (for example, by IfcLocalPlacement).  Figure 254 shows the Enclosure box being sufficiently large to fully enclose the Boolean result.
/// 
/// Figure 254 — Boxed half space geometry
class IFC_PARSE_API IfcBoxedHalfSpace : public IfcHalfSpaceSolid {
public:
    /// The box which bounds the resulting solid of the Boolean operation involving the half space solid for computational purposes only.
    IfcBoundingBox* Enclosure() const;
    void setEnclosure(IfcBoundingBox* v);
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 2: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcHalfSpaceSolid::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 2: return Type::IfcBoundingBox; } return IfcHalfSpaceSolid::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 2: return "Enclosure"; } return IfcHalfSpaceSolid::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcBoxedHalfSpace (IfcEntityInstanceData* e);
    IfcBoxedHalfSpace (IfcSurface* v1_BaseSurface, bool v2_AgreementFlag, IfcBoundingBox* v3_Enclosure);
    typedef IfcTemplatedEntityList< IfcBoxedHalfSpace > list;
};
/// IfcCShapeProfileDef defines
/// a section profile that provides the defining parameters of a C-shaped
/// section to be used by the swept area solid. This section is typically
/// produced by cold forming steel. Its parameters and orientation relative
/// to the position coordinate system are according to the following
/// illustration. The centre of the position coordinate system is in the
/// profile's centre of the bounding box.
/// 
/// HISTORY  New entity in IFC2x2.
/// 
/// IFC2x3 CHANGE  All profile origins are now in the center of the bounding box.
/// 
/// IFC2x4 CHANGE  Type of InternalFilletRadius relaxed to allow for zero radius.
/// Trailing attribute CentreOfGravityInX deleted, use respective property in IfcExtendedProfileProperties instead.
/// 
/// Figure 315 illustrates parameters of the C-shape profile definition. The parameterized profile defines its own position coordinate system. The underlying coordinate system is defined by the swept area solid that uses the profile definition. It is the xy plane of:
/// 
/// IfcSweptAreaSolid.Position
/// 
/// By using offsets of the position location, the parameterized profile can be positioned centric (using x,y offsets = 0.), or at any position relative to the profile. The parameterized profile is defined by a set of parameter attributes. In the illustrated example, the 'CentreOfGravityInX' property in IfcExtendedProfileProperties, if provided, is negative.
/// 
/// Figure 315 — C-shape profile
class IFC_PARSE_API IfcCShapeProfileDef : public IfcParameterizedProfileDef {
public:
    /// Profile depth, see illustration above (= h).
    double Depth() const;
    void setDepth(double v);
    /// Profile width, see illustration above (= b).
    double Width() const;
    void setWidth(double v);
    /// Constant wall thickness of profile (= ts).
    double WallThickness() const;
    void setWallThickness(double v);
    /// Lengths of girth, see illustration above (= c).
    double Girth() const;
    void setGirth(double v);
    /// Whether the optional attribute InternalFilletRadius is defined for this IfcCShapeProfileDef
    bool hasInternalFilletRadius() const;
    /// Internal fillet radius according the above illustration (= r1).
    double InternalFilletRadius() const;
    void setInternalFilletRadius(double v);
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 3: return IfcUtil::Argument_DOUBLE; case 4: return IfcUtil::Argument_DOUBLE; case 5: return IfcUtil::Argument_DOUBLE; case 6: return IfcUtil::Argument_DOUBLE; case 7: return IfcUtil::Argument_DOUBLE; } return IfcParameterizedProfileDef::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 3: return Type::IfcPositiveLengthMeasure; case 4: return Type::IfcPositiveLengthMeasure; case 5: return Type::IfcPositiveLengthMeasure; case 6: return Type::IfcPositiveLengthMeasure; case 7: return Type::IfcNonNegativeLengthMeasure; } return IfcParameterizedProfileDef::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 3: return "Depth"; case 4: return "Width"; case 5: return "WallThickness"; case 6: return "Girth"; case 7: return "InternalFilletRadius"; } return IfcParameterizedProfileDef::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCShapeProfileDef (IfcEntityInstanceData* e);
    IfcCShapeProfileDef (IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< std::string > v2_ProfileName, IfcAxis2Placement2D* v3_Position, double v4_Depth, double v5_Width, double v6_WallThickness, double v7_Girth, boost::optional< double > v8_InternalFilletRadius);
    typedef IfcTemplatedEntityList< IfcCShapeProfileDef > list;
};
/// Definition from ISO/CD 10303-42:1992: A point defined by its coordinates in a two or three dimensional rectangular Cartesian coordinate system, or in a two dimensional parameter space. The entity is defined in a two or three dimensional space.  
/// 
/// The derived attribute Dim has been added (see also note at IfcGeometricRepresentationItem). The WR1 was added to constrain the usage of IfcCartesianPoint in the context of IFC geometry. For the purpose of defining geometry in IFC only two and three dimensional Cartesian points are used.  
/// 
/// NOTE: Corresponding STEP entity: cartesian_point, please refer to ISO/IS 10303-42:1994, p. 23 for the final definition of the formal standard.
/// 
/// HISTORY: New entity in IFC Release 1.0
class IFC_PARSE_API IfcCartesianPoint : public IfcPoint {
public:
    /// The first, second, and third coordinate of the point location. If placed in a two or three dimensional rectangular Cartesian coordinate system, Coordinates[1] is the X coordinate, Coordinates[2] is the Y coordinate, and Coordinates[3] is the Z coordinate.
    std::vector< double > /*[1:3]*/ Coordinates() const;
    void setCoordinates(std::vector< double > /*[1:3]*/ v);
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_AGGREGATE_OF_DOUBLE; } return IfcPoint::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcLengthMeasure; } return IfcPoint::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Coordinates"; } return IfcPoint::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCartesianPoint (IfcEntityInstanceData* e);
    IfcCartesianPoint (std::vector< double > /*[1:3]*/ v1_Coordinates);
    typedef IfcTemplatedEntityList< IfcCartesianPoint > list;
};

class IFC_PARSE_API IfcCartesianPointList : public IfcGeometricRepresentationItem {
public:
    virtual unsigned int getArgumentCount() const { return 0; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcGeometricRepresentationItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcGeometricRepresentationItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcGeometricRepresentationItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCartesianPointList (IfcEntityInstanceData* e);
    IfcCartesianPointList ();
    typedef IfcTemplatedEntityList< IfcCartesianPointList > list;
};

class IFC_PARSE_API IfcCartesianPointList2D : public IfcCartesianPointList {
public:
    std::vector< std::vector< double > > CoordList() const;
    void setCoordList(std::vector< std::vector< double > > v);
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_AGGREGATE_OF_AGGREGATE_OF_DOUBLE; } return IfcCartesianPointList::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcLengthMeasure; } return IfcCartesianPointList::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "CoordList"; } return IfcCartesianPointList::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCartesianPointList2D (IfcEntityInstanceData* e);
    IfcCartesianPointList2D (std::vector< std::vector< double > > v1_CoordList);
    typedef IfcTemplatedEntityList< IfcCartesianPointList2D > list;
};

class IFC_PARSE_API IfcCartesianPointList3D : public IfcCartesianPointList {
public:
    std::vector< std::vector< double > > CoordList() const;
    void setCoordList(std::vector< std::vector< double > > v);
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_AGGREGATE_OF_AGGREGATE_OF_DOUBLE; } return IfcCartesianPointList::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcLengthMeasure; } return IfcCartesianPointList::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "CoordList"; } return IfcCartesianPointList::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCartesianPointList3D (IfcEntityInstanceData* e);
    IfcCartesianPointList3D (std::vector< std::vector< double > > v1_CoordList);
    typedef IfcTemplatedEntityList< IfcCartesianPointList3D > list;
};
/// Definition from ISO/CD 10303-42:1992: A Cartesian transformation operator defines a geometric transformation composed of translation, rotation, mirroring and uniform scaling. The list of normalized vectors u defines the columns of an orthogonal matrix T. These vectors are computed, by the base axis function, from the direction attributes axis1, axis2 and, in Cartesian transformation operator 3d, axis3. If |T|= -1, the transformation includes mirroring. The local origin point A, the scale value S and the matrix T together define a transformation.  
/// 
/// The transformation for a point with position vector P is defined by 
/// 
/// P -> A + STP  
///   The transformation for a direction d is defined by  
/// 
/// d -> Td  
///   The transformation for a vector with orientation d and magnitude k is
///   defined by 
/// 
/// d -> Td, and  
///   k -> Sk  
///   For those entities whose attributes include an axis2 placement, the
///   transformation is applied, after the derivation, to the derived attributes p
///   defining the placement coordinate directions. For a transformed surface, the
///   direction of the surface normal at any point is obtained by transforming the
///   normal, at the corresponding point, to the original surface. For geometric
///   entities with attributes (such as the radius of a circle) which have the
///   dimensionality of length, the values will be multiplied by S.  
///   For curves on surface the p curve.reference to curve will be unaffected
///   by any transformation. The Cartesian transformation operator shall only be
///   applied to geometry defined in a consistent system of units with the same units
///   on each axis. With all optional attributes omitted, the transformation defaults
///   to the identity transformation. The Cartesian transformation operator shall
///   only be instantiated as one of its subtypes.  
/// 
/// NOTE: Corresponding ISO 10303 entity: cartesian_transformation_operator, please refer to ISO/IS 10303-42:1994, p. 32 for the final definition of the formal standard.
/// 
/// HISTORY: New entity in IFC Release 2x.
class IFC_PARSE_API IfcCartesianTransformationOperator : public IfcGeometricRepresentationItem {
public:
    /// Whether the optional attribute Axis1 is defined for this IfcCartesianTransformationOperator
    bool hasAxis1() const;
    /// The direction used to determine U[1], the derived X axis direction.
    IfcDirection* Axis1() const;
    void setAxis1(IfcDirection* v);
    /// Whether the optional attribute Axis2 is defined for this IfcCartesianTransformationOperator
    bool hasAxis2() const;
    /// The direction used to determine U[2], the derived Y axis direction.
    IfcDirection* Axis2() const;
    void setAxis2(IfcDirection* v);
    /// The required translation, specified as a cartesian point. The actual translation included in the transformation is from the geometric origin to the local origin.
    IfcCartesianPoint* LocalOrigin() const;
    void setLocalOrigin(IfcCartesianPoint* v);
    /// Whether the optional attribute Scale is defined for this IfcCartesianTransformationOperator
    bool hasScale() const;
    /// The scaling value specified for the transformation.
    double Scale() const;
    void setScale(double v);
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_ENTITY_INSTANCE; case 2: return IfcUtil::Argument_ENTITY_INSTANCE; case 3: return IfcUtil::Argument_DOUBLE; } return IfcGeometricRepresentationItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcDirection; case 1: return Type::IfcDirection; case 2: return Type::IfcCartesianPoint; case 3: return Type::IfcReal; } return IfcGeometricRepresentationItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Axis1"; case 1: return "Axis2"; case 2: return "LocalOrigin"; case 3: return "Scale"; } return IfcGeometricRepresentationItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCartesianTransformationOperator (IfcEntityInstanceData* e);
    IfcCartesianTransformationOperator (IfcDirection* v1_Axis1, IfcDirection* v2_Axis2, IfcCartesianPoint* v3_LocalOrigin, boost::optional< double > v4_Scale);
    typedef IfcTemplatedEntityList< IfcCartesianTransformationOperator > list;
};
/// Definition from ISO/CD 10303-42:1992: A Cartesian transformation operator 2d defines a geometric transformation in two-dimensional space composed of translation, rotation, mirroring and uniform scaling. The list of normalized vectors u defines the columns of an orthogonal matrix T. These vectors are computed from the direction attributes axis1 and axis2 by the base axis function. If |T|= -1, the transformation includes mirroring.  
/// 
/// NOTE: Corresponding ISO 10303 entity : cartesian_transformation_operator_2d, please refer to ISO/IS 10303-42:1994, p. 36 for the final definition of the formal standard.
/// 
/// HISTORY: New entity in IFC Release 2x.
class IFC_PARSE_API IfcCartesianTransformationOperator2D : public IfcCartesianTransformationOperator {
public:
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcCartesianTransformationOperator::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcCartesianTransformationOperator::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcCartesianTransformationOperator::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCartesianTransformationOperator2D (IfcEntityInstanceData* e);
    IfcCartesianTransformationOperator2D (IfcDirection* v1_Axis1, IfcDirection* v2_Axis2, IfcCartesianPoint* v3_LocalOrigin, boost::optional< double > v4_Scale);
    typedef IfcTemplatedEntityList< IfcCartesianTransformationOperator2D > list;
};
/// A Cartesian transformation operator 2d non uniform defines a geometric transformation in two-dimensional space composed of translation, rotation, mirroring and non uniform scaling. Non uniform scaling is given by two different scaling factors: 
/// 
/// SELF\IfcCartesianTransformationOperator.Scale: the x axis scale factor 
/// Scale2: the y axis scale factor 
/// 
/// If the Scale factor (at supertype IfcCartesianTransformationOperator) is omitted, it defaults to 1.0. If the Scale2 factor is omitted, it defaults to the value of Scale (the x axis scale factor). 
/// 
/// NOTE: The scale factor (Scl) defined at the supertype IfcCartesianTransformationOperator is used to express the calculated Scale factor (normally x axis scale factor).
/// 
/// HISTORY: New entity in IFC Release 2x.
class IFC_PARSE_API IfcCartesianTransformationOperator2DnonUniform : public IfcCartesianTransformationOperator2D {
public:
    /// Whether the optional attribute Scale2 is defined for this IfcCartesianTransformationOperator2DnonUniform
    bool hasScale2() const;
    /// The scaling value specified for the transformation along the axis 2. This is normally the y scale factor.
    double Scale2() const;
    void setScale2(double v);
    virtual unsigned int getArgumentCount() const { return 5; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 4: return IfcUtil::Argument_DOUBLE; } return IfcCartesianTransformationOperator2D::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 4: return Type::IfcReal; } return IfcCartesianTransformationOperator2D::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 4: return "Scale2"; } return IfcCartesianTransformationOperator2D::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCartesianTransformationOperator2DnonUniform (IfcEntityInstanceData* e);
    IfcCartesianTransformationOperator2DnonUniform (IfcDirection* v1_Axis1, IfcDirection* v2_Axis2, IfcCartesianPoint* v3_LocalOrigin, boost::optional< double > v4_Scale, boost::optional< double > v5_Scale2);
    typedef IfcTemplatedEntityList< IfcCartesianTransformationOperator2DnonUniform > list;
};
/// Definition from ISO/CD 10303-42:1992: A Cartesian transformation operator 3d defines a geometric transformation in three-dimensional space composed of translation, rotation, mirroring and uniform scaling. The list of normalized vectors u defines the columns of an orthogonal matrix T. These vectors are computed from the direction attributes axis1, axis2 and axis3 by the base axis function. If |T|= -1, the transformation includes mirroring.  
/// 
/// NOTE: Corresponding ISO 10303 entity: cartesian_transformation_operator_3d, please refer to ISO/IS 10303-42:1994, p. 33 for the final definition of the formal standard.
/// 
/// HISTORY: New entity in IFC Release 2x.
class IFC_PARSE_API IfcCartesianTransformationOperator3D : public IfcCartesianTransformationOperator {
public:
    /// Whether the optional attribute Axis3 is defined for this IfcCartesianTransformationOperator3D
    bool hasAxis3() const;
    /// The exact direction of U[3], the derived Z axis direction.
    IfcDirection* Axis3() const;
    void setAxis3(IfcDirection* v);
    virtual unsigned int getArgumentCount() const { return 5; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 4: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcCartesianTransformationOperator::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 4: return Type::IfcDirection; } return IfcCartesianTransformationOperator::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 4: return "Axis3"; } return IfcCartesianTransformationOperator::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCartesianTransformationOperator3D (IfcEntityInstanceData* e);
    IfcCartesianTransformationOperator3D (IfcDirection* v1_Axis1, IfcDirection* v2_Axis2, IfcCartesianPoint* v3_LocalOrigin, boost::optional< double > v4_Scale, IfcDirection* v5_Axis3);
    typedef IfcTemplatedEntityList< IfcCartesianTransformationOperator3D > list;
};
/// A Cartesian transformation operator 3d non uniform defines a geometric transformation in three-dimensional space composed of translation, rotation, mirroring and non uniform scaling. Non uniform scaling is given by three different scaling factors:
/// 
/// SELF\IfcCartesianTransformationOperator.Scale: the x axis scale factor
/// Scale2: the y axis scale factor
/// Scale3: the z axis scale factor
/// 
/// If the Scale factor (at supertype IfcCartesianTransformationOperator) is omitted, it defaults to 1.0. If the Scale2 or the Scale3 factor is omitted, it defaults to the value of Scale (the x axis scale factor). 
/// 
/// NOTE: The scale factor (Scl) defined at the supertype IfcCartesianTransformationOperator is used to express the calculated Scale factor (normally x axis scale factor).
/// 
/// HISTORY: New entity in IFC Release 2x.
class IFC_PARSE_API IfcCartesianTransformationOperator3DnonUniform : public IfcCartesianTransformationOperator3D {
public:
    /// Whether the optional attribute Scale2 is defined for this IfcCartesianTransformationOperator3DnonUniform
    bool hasScale2() const;
    /// The scaling value specified for the transformation along the axis 2. This is normally the y scale factor.
    double Scale2() const;
    void setScale2(double v);
    /// Whether the optional attribute Scale3 is defined for this IfcCartesianTransformationOperator3DnonUniform
    bool hasScale3() const;
    /// The scaling value specified for the transformation along the axis 3. This is normally the z scale factor.
    double Scale3() const;
    void setScale3(double v);
    virtual unsigned int getArgumentCount() const { return 7; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 5: return IfcUtil::Argument_DOUBLE; case 6: return IfcUtil::Argument_DOUBLE; } return IfcCartesianTransformationOperator3D::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 5: return Type::IfcReal; case 6: return Type::IfcReal; } return IfcCartesianTransformationOperator3D::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 5: return "Scale2"; case 6: return "Scale3"; } return IfcCartesianTransformationOperator3D::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCartesianTransformationOperator3DnonUniform (IfcEntityInstanceData* e);
    IfcCartesianTransformationOperator3DnonUniform (IfcDirection* v1_Axis1, IfcDirection* v2_Axis2, IfcCartesianPoint* v3_LocalOrigin, boost::optional< double > v4_Scale, IfcDirection* v5_Axis3, boost::optional< double > v6_Scale2, boost::optional< double > v7_Scale3);
    typedef IfcTemplatedEntityList< IfcCartesianTransformationOperator3DnonUniform > list;
};
/// IfcCircleProfileDef defines a circle as the profile definition used by the swept surface geometry or by the swept area solid. It is given by its Radius attribute and placed within the 2D position coordinate system, established by the Position attribute. 
/// 
/// HISTORY  New class in IFC 1.5.
/// 
/// Figure 313 illustrates parameters for the circle profile definition. The parameterized profile defines its own position coordinate system. The underlying coordinate system is defined by the swept surface or swept area solid that uses the profile definition. It is the xy plane of either: 
/// 
/// IfcSweptSurface.Position
///   IfcSweptAreaSolid.Position
/// 
/// Or in case of sectioned spines, it is the xy plane of each list member of IfcSectionedSpine.CrossSectionPositions. By using offsets of the position location, the parameterized profile can be positioned centric (using x,y offsets = 0.), or at any position relative to the profile. Explicit coordinate offsets are used to define cardinal points (e.g. upper-left bound). The Position attribute defines the 2D position coordinate system of the circle. The Radius attribute defines the radius of the circle.
/// 
/// Figure 313 — Circle profile
class IFC_PARSE_API IfcCircleProfileDef : public IfcParameterizedProfileDef {
public:
    /// The radius of the circle.
    double Radius() const;
    void setRadius(double v);
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 3: return IfcUtil::Argument_DOUBLE; } return IfcParameterizedProfileDef::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 3: return Type::IfcPositiveLengthMeasure; } return IfcParameterizedProfileDef::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 3: return "Radius"; } return IfcParameterizedProfileDef::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCircleProfileDef (IfcEntityInstanceData* e);
    IfcCircleProfileDef (IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< std::string > v2_ProfileName, IfcAxis2Placement2D* v3_Position, double v4_Radius);
    typedef IfcTemplatedEntityList< IfcCircleProfileDef > list;
};
/// Definition from ISO/CD 10303-42:1992: A closed shell is a shell
///   of the dimensionality 2 which typically serves as a bound for a region in R3. A
///   closed shell has no boundary, and has non-zero finite extent. If the shell has
///   a domain with coordinate space R3, it divides that space into two connected
///   regions, one finite and the other infinite. In this case, the topological
///   normal of the shell is defined as being directed from the finite to the
///   infinite region.  
///   The shell is represented by a collection of faces. The domain of the
///   shell, if present, contains all those faces, together with their bounds.
///   Associated with each face in the shell is a logical value which indicates
///   whether the face normal agrees with (TRUE) or is opposed to (FALSE) the shell
///   normal. The logical value can be applied directly as a BOOLEAN attribute of an
///   oriented face, or be defaulted to TRUE if the shell boundary attribute member
///   is a face without the orientation attribute.  
///   The combinatorial restrictions on closed shells and geometrical
///   restrictions on their domains are designed to ensure that any domain associated
///   with a closed shell is a closed, orientable manifold. The domain of a closed
///   shell, if present, is a connected, closed, oriented 2-manifold. It is always
///   topologically equivalent to an H-fold torus for some H
///   ³ 0. The number H is referred to as the
///   surface genus of the shell. If a shell of genus H has a domain within
///   coordinate space R3, then the finite region of space inside
///   it is topologically equivalent to a solid ball with H tunnels drilled
///   through it. 
///   The Euler equation (7) applies with B=0, because in this case
///   there are no holes. As in the case of open shells, the surface genus H
///   may not be known a priori, but shall be an integer ³ 0. Thus a necessary, but not sufficient, condition
///   for a well-formed closed shell is the following: 
/// 
/// In the current IFC Release only poly loops
///   (IfcPolyLoop) are defined for bounds of face bound
///   (IfcFaceBound). This will allow for faceted B-rep only. 
/// 
/// NOTE: Corresponding ISO 10303 entity: closed_shell, please refer to ISO/IS 10303-42:1994, p.149 for the final definition of the formal standard.
/// 
/// HISTORY  New class in IFC Release 1.0
/// 
/// Informal propositions: 
/// 
/// Every edge shall be referenced exactly twice by the loops of the face.  
///   Each oriented edge shall be unique.  
///   No edge shall be referenced by more than two faces.  
///   Distinct faces of the shell do not intersect, but may share edges or vertices.  
///   Distinct edges do not intersect but may share vertices.  
///   Each face reference shall be unique.  
///   The loops of the shell shall not be a mixture of poly loop and other loop types. Note: this is given, since only poly loop is defined as face bound definition. 
///   The closed shell shall be an oriented arcwise connected 2-manifold. 
///   The Euler equation shall be satisfied. Note: Please refer to ISO/IS
///   10303-42:1994, p.149 for the equation.
class IFC_PARSE_API IfcClosedShell : public IfcConnectedFaceSet {
public:
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcConnectedFaceSet::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcConnectedFaceSet::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcConnectedFaceSet::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcClosedShell (IfcEntityInstanceData* e);
    IfcClosedShell (IfcTemplatedEntityList< IfcFace >::ptr v1_CfsFaces);
    typedef IfcTemplatedEntityList< IfcClosedShell > list;
};
/// Definition from ISO/CD 10303-46:1992: A colour rgb as a subtype of colour specifications is defined by three colour component values for red, green, and blue in the RGB colour model.
/// 
/// NOTE  In contrary to the usual value range of colour components being integer from 0...255, the definition from ISO10303-46 defines the colour components as real from 0.0 ... 1.0. Applications need to execute this conversion before populating the colour RGB values.
/// 
/// NOTE  Corresponding STEP name: colour_rgb. The name attribute has been omitted, the data type for the reg, green and blue parts is IfcNormalizedRatioMeasure, that already includes the range restrictions for the values. Please
/// refer to ISO/IS 10303-46:1994, p. 138 for the final definition of the formal standard.
/// 
/// HISTORY  New entity in IFC2x2.
class IFC_PARSE_API IfcColourRgb : public IfcColourSpecification {
public:
    /// The intensity of the red colour component.
    /// 
    /// NOTE  The colour component value is given within the range of 0..1, and not within the range of 0..255 as otherwise usual.
    double Red() const;
    void setRed(double v);
    /// The intensity of the green colour component.
    /// 
    /// NOTE  The colour component value is given within the range of 0..1, and not within the range of 0..255 as otherwise usual.
    double Green() const;
    void setGreen(double v);
    /// The intensity of the blue colour component.
    /// 
    /// NOTE  The colour component value is given within the range of 0..1, and not within the range of 0..255 as otherwise usual.
    double Blue() const;
    void setBlue(double v);
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 1: return IfcUtil::Argument_DOUBLE; case 2: return IfcUtil::Argument_DOUBLE; case 3: return IfcUtil::Argument_DOUBLE; } return IfcColourSpecification::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 1: return Type::IfcNormalisedRatioMeasure; case 2: return Type::IfcNormalisedRatioMeasure; case 3: return Type::IfcNormalisedRatioMeasure; } return IfcColourSpecification::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 1: return "Red"; case 2: return "Green"; case 3: return "Blue"; } return IfcColourSpecification::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcColourRgb (IfcEntityInstanceData* e);
    IfcColourRgb (boost::optional< std::string > v1_Name, double v2_Red, double v3_Green, double v4_Blue);
    typedef IfcTemplatedEntityList< IfcColourRgb > list;
};
/// IfcComplexProperty is used to define complex properties to be handled completely within a property set. The included set of properties may be a mixed or consistent collection of IfcProperty subtypes. This enables the definition of a set of properties to be included as a single 'property' entry in an IfcPropertySet. The definition of such an IfcComplexProperty can be reused in many different IfcPropertySet's.
/// 
/// NOTE  Since an IfcComplexProperty may contain other complex properties, sets of properties can be nested. This nesting may be restricted by view definitions and implementer agreements.
/// 
/// HISTORY New Entity in IFC Release 2.0, capabilities enhanced in IFC Release 2x.
class IFC_PARSE_API IfcComplexProperty : public IfcProperty {
public:
    /// Usage description of the IfcComplexProperty within the property set which references the IfcComplexProperty.
    ///   NOTE: Consider a complex property for glazing properties. The Name attribute of the IfcComplexProperty could be Pset_GlazingProperties, and the UsageName attribute could be OuterGlazingPane.
    std::string UsageName() const;
    void setUsageName(std::string v);
    /// Set of properties that can be used within this complex property (may include other complex properties).
    IfcTemplatedEntityList< IfcProperty >::ptr HasProperties() const;
    void setHasProperties(IfcTemplatedEntityList< IfcProperty >::ptr v);
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 2: return IfcUtil::Argument_STRING; case 3: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } return IfcProperty::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 2: return Type::IfcIdentifier; case 3: return Type::IfcProperty; } return IfcProperty::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 2: return "UsageName"; case 3: return "HasProperties"; } return IfcProperty::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcComplexProperty (IfcEntityInstanceData* e);
    IfcComplexProperty (std::string v1_Name, boost::optional< std::string > v2_Description, std::string v3_UsageName, IfcTemplatedEntityList< IfcProperty >::ptr v4_HasProperties);
    typedef IfcTemplatedEntityList< IfcComplexProperty > list;
};
/// Definition from ISO/CD 10303-42:1992: A composite curve segment is a bounded curve together with transition information which is used to construct a composite curve (IfcCompositeCurve).
/// 
/// The derived attribute Dim has been added (see also note at IfcGeometricRepresentationItem). The IfcCompositeCurveSegment is a subtype of IfcGeometricRepresentationItem (whereas in ISO 10303-42 composite_curve_segment is not a subtype of geometric_representation_item, the proposed 2nd edition of ISO 10303-42 however proposes the subtype relationship).
/// 
/// NOTE Corresponding ISO 10303 entity: composite_curve_segment. Please refer to ISO/IS 10303-42:1994, p.57 for the final definition of the formal standard.
/// 
/// HISTORY New class in IFC Release 1.0
class IFC_PARSE_API IfcCompositeCurveSegment : public IfcGeometricRepresentationItem {
public:
    /// The state of transition (i.e., geometric continuity from the last point of this segment to the first point of the next segment) in a composite curve.
    IfcTransitionCode::IfcTransitionCode Transition() const;
    void setTransition(IfcTransitionCode::IfcTransitionCode v);
    /// An indicator of whether or not the sense of the segment agrees with, or opposes, that of the parent curve. If SameSense is false, the point with highest parameter value is taken as the first point of the segment.
    /// 
    /// NOTE  If the datatype of ParentCurve is IfcTrimmedCurve, the value of SameSense overrides the value of IfcTrimmedCurve.SenseAgreement
    bool SameSense() const;
    void setSameSense(bool v);
    /// The bounded curve which defines the geometry of the segment.
    IfcCurve* ParentCurve() const;
    void setParentCurve(IfcCurve* v);
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENUMERATION; case 1: return IfcUtil::Argument_BOOL; case 2: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcGeometricRepresentationItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcTransitionCode; case 1: return Type::IfcBoolean; case 2: return Type::IfcCurve; } return IfcGeometricRepresentationItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Transition"; case 1: return "SameSense"; case 2: return "ParentCurve"; } return IfcGeometricRepresentationItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcCompositeCurve >::ptr UsingCurves() const; // INVERSE IfcCompositeCurve::Segments
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCompositeCurveSegment (IfcEntityInstanceData* e);
    IfcCompositeCurveSegment (IfcTransitionCode::IfcTransitionCode v1_Transition, bool v2_SameSense, IfcCurve* v3_ParentCurve);
    typedef IfcTemplatedEntityList< IfcCompositeCurveSegment > list;
};
/// IfcConstructionResourceType is an abstract generalization of the different resource types used in construction projects, mainly labor, material, equipment and product resource types, plus subcontracted resource types and aggregations such as a crew resource type. 
/// 
/// A resource type represents a model of "use of something" and does not necessarily correspond to a specific type of object such as a person or vehicle, but represents possible usages of such objects such as general labor or an equipment fleet.  A resource type can either represent usage in general (consumption attributes defined but no task type assignment) or a task-specific resource type (production attributes defined and having an IfcTask assignment).
/// 
/// A construction resource type captures common productivities and cost rates for applying resources to particular task types.
/// 
/// HISTORY: New entity in IFC2x4.
/// 
/// Composition use definition
/// Resource types may be decomposed into nested resource types indicating productivities when applying the resource to specific task types using the IfcRelNests relationship where IfcRelNests.RelatingObject refers to the general resource type and IfcRelNests.RelatedObjects refers to one or more task-specific productivities.  For example, an IfcLaborResourceType may be defined for "Carpenter" which may have a nested IfcLaborResourceType for "Carpenter - Wall Framing" and another nested IfcLaborResourceType for "Carpenter - Drywall", each of which may have productivities based according to specific task types (IfcTaskType). 
/// 
/// Assignment use definition
/// Resource types may be assigned to process types (IfcTypeProcess subtypes) using the IfcRelAssignsToProcess relationship as shown in Figure 193.  Such relationship indicates that the resource type applies to the process type for the use indicated (e.g. IfcTaskType.PredefinedType).  Such relationship enables a scenario of placing an IfcProduct of a particular IfcTypeProduct, querying for a set of IfcTypeProcess process types for constructing such product (e.g. IfcTaskTypeEnum.CONSTRUCTION), querying each IfcTypeProcess for a set of IfcTypeResource resource types for carrying out the process, and finally choosing an IfcTypeProcess and IfcTypeResource combination resulting in the shortest time for instantiated IfcTask occurrence(s) and/or lowest-cost for instantiated IfcConstructionResource occurrence(s).
/// 
/// Figure 193 — Construction resource type assignment
class IFC_PARSE_API IfcConstructionResourceType : public IfcTypeResource {
public:
    /// Whether the optional attribute BaseCosts is defined for this IfcConstructionResourceType
    bool hasBaseCosts() const;
    IfcTemplatedEntityList< IfcAppliedValue >::ptr BaseCosts() const;
    void setBaseCosts(IfcTemplatedEntityList< IfcAppliedValue >::ptr v);
    /// Whether the optional attribute BaseQuantity is defined for this IfcConstructionResourceType
    bool hasBaseQuantity() const;
    IfcPhysicalQuantity* BaseQuantity() const;
    void setBaseQuantity(IfcPhysicalQuantity* v);
    virtual unsigned int getArgumentCount() const { return 11; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 10: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcTypeResource::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcAppliedValue; case 10: return Type::IfcPhysicalQuantity; } return IfcTypeResource::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "BaseCosts"; case 10: return "BaseQuantity"; } return IfcTypeResource::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcConstructionResourceType (IfcEntityInstanceData* e);
    IfcConstructionResourceType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< std::string > v7_Identification, boost::optional< std::string > v8_LongDescription, boost::optional< std::string > v9_ResourceType, boost::optional< IfcTemplatedEntityList< IfcAppliedValue >::ptr > v10_BaseCosts, IfcPhysicalQuantity* v11_BaseQuantity);
    typedef IfcTemplatedEntityList< IfcConstructionResourceType > list;
};
/// IfcContext is the generalization of a project context in which objects, type objects, property sets, and properties are defined. The IfcProject as subtype of IfcContext provides the context for all information on a construction project, it may include one or several IfcProjectLibrary as subtype of IfcContext to register the included libraries for the project.
/// 
/// Context definitions can be named, using the inherited Name attribute, which should be a user recognizable key or number for the context. The LongName can add a full name. Further explanations to the context can be given using the inherited Description attribute.
/// 
/// HISTORY  New abstract entity in IFC2x4.
/// 
/// Relationship use definition
/// Contexts are declared by the relationship object that refers to the corresponding object:
/// 
/// Project library to project: IfcProjectLibrary is assigned to IfcProject (both subtypes of using
/// IfcContext) by using IfcRelDeclares
/// 
/// More specific relationships are introduced at the level of subtypes.
class IFC_PARSE_API IfcContext : public IfcObjectDefinition {
public:
    /// Whether the optional attribute ObjectType is defined for this IfcContext
    bool hasObjectType() const;
    /// The type denotes a particular type that indicates the object further. The use has to be established at the level of instantiable subtypes.
    std::string ObjectType() const;
    void setObjectType(std::string v);
    /// Whether the optional attribute LongName is defined for this IfcContext
    bool hasLongName() const;
    /// Long name for the context as used for reference purposes.
    std::string LongName() const;
    void setLongName(std::string v);
    /// Whether the optional attribute Phase is defined for this IfcContext
    bool hasPhase() const;
    /// Current project phase, or life-cycle phase of this project. Applicable values have to be agreed upon by view definitions or implementer agreements.
    std::string Phase() const;
    void setPhase(std::string v);
    /// Whether the optional attribute RepresentationContexts is defined for this IfcContext
    bool hasRepresentationContexts() const;
    /// Context of the representations used within the context. When the context is a project and it includes shape representations for its components, one or several geometric representation contexts need to be included that define e.g. the world coordinate system, the coordinate space dimensions, and/or the precision factor.
    /// 
    /// IFC2x4 CHANGE  The attribute has been changed to be optional. Change made with upward compatibility for file based exchange.
    IfcTemplatedEntityList< IfcRepresentationContext >::ptr RepresentationContexts() const;
    void setRepresentationContexts(IfcTemplatedEntityList< IfcRepresentationContext >::ptr v);
    /// Whether the optional attribute UnitsInContext is defined for this IfcContext
    bool hasUnitsInContext() const;
    /// Units globally assigned to measure types used within the context.
    /// 
    /// IFC2x4 CHANGE  The attribute has been changed to be optional. Change made with upward compatibility for file based exchange.
    IfcUnitAssignment* UnitsInContext() const;
    void setUnitsInContext(IfcUnitAssignment* v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 4: return IfcUtil::Argument_STRING; case 5: return IfcUtil::Argument_STRING; case 6: return IfcUtil::Argument_STRING; case 7: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 8: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcObjectDefinition::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 4: return Type::IfcLabel; case 5: return Type::IfcLabel; case 6: return Type::IfcLabel; case 7: return Type::IfcRepresentationContext; case 8: return Type::IfcUnitAssignment; } return IfcObjectDefinition::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 4: return "ObjectType"; case 5: return "LongName"; case 6: return "Phase"; case 7: return "RepresentationContexts"; case 8: return "UnitsInContext"; } return IfcObjectDefinition::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcRelDefinesByProperties >::ptr IsDefinedBy() const; // INVERSE IfcRelDefinesByProperties::RelatedObjects
    IfcTemplatedEntityList< IfcRelDeclares >::ptr Declares() const; // INVERSE IfcRelDeclares::RelatingContext
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcContext (IfcEntityInstanceData* e);
    IfcContext (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, boost::optional< std::string > v6_LongName, boost::optional< std::string > v7_Phase, boost::optional< IfcTemplatedEntityList< IfcRepresentationContext >::ptr > v8_RepresentationContexts, IfcUnitAssignment* v9_UnitsInContext);
    typedef IfcTemplatedEntityList< IfcContext > list;
};
/// The resource type IfcCrewResourceType defines commonly shared information for occurrences of crew resources. The set of shared information may include:
/// 
/// common productivities
/// common cost rates
/// common properties within shared property sets
/// 
/// It is used to define a crew resource specification the specific resource information that is common to all occurrences of that resource). Resource types may be exchanged without being already assigned to occurrences.
/// Occurrences of the IfcCrewResourceType are represented by instances of IfcCrewResource.
/// 
/// HISTORY New entity in IFC2x4.
class IFC_PARSE_API IfcCrewResourceType : public IfcConstructionResourceType {
public:
    /// Defines types of crew resources.
    IfcCrewResourceTypeEnum::IfcCrewResourceTypeEnum PredefinedType() const;
    void setPredefinedType(IfcCrewResourceTypeEnum::IfcCrewResourceTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 12; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 11: return IfcUtil::Argument_ENUMERATION; } return IfcConstructionResourceType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 11: return Type::IfcCrewResourceTypeEnum; } return IfcConstructionResourceType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 11: return "PredefinedType"; } return IfcConstructionResourceType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCrewResourceType (IfcEntityInstanceData* e);
    IfcCrewResourceType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< std::string > v7_Identification, boost::optional< std::string > v8_LongDescription, boost::optional< std::string > v9_ResourceType, boost::optional< IfcTemplatedEntityList< IfcAppliedValue >::ptr > v10_BaseCosts, IfcPhysicalQuantity* v11_BaseQuantity, IfcCrewResourceTypeEnum::IfcCrewResourceTypeEnum v12_PredefinedType);
    typedef IfcTemplatedEntityList< IfcCrewResourceType > list;
};
/// IfcCsgPrimitive3D is an abstract supertype of all three dimensional primitives used as either tree root item, or as Boolean results within a CSG solid model. All 3D CSG primitives are defined within a three-dimensional placement coordinate system.
/// 
/// NOTEÿ No directly corresponding ISO 10303-42 entity, the select type primitive_3d covers the same individual 3D CSG primitives, the position attribute has been added to apply equally to all subtypes. Please refer to ISO/IS 10303-42:1994, p. 234 for the final definition of the formal standard.
/// 
/// HISTORYÿ New entity in IFC2x3.
class IFC_PARSE_API IfcCsgPrimitive3D : public IfcGeometricRepresentationItem {
public:
    /// The placement coordinate system to which the parameters of each individual CSG primitive apply.
    IfcAxis2Placement3D* Position() const;
    void setPosition(IfcAxis2Placement3D* v);
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcGeometricRepresentationItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcAxis2Placement3D; } return IfcGeometricRepresentationItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Position"; } return IfcGeometricRepresentationItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCsgPrimitive3D (IfcEntityInstanceData* e);
    IfcCsgPrimitive3D (IfcAxis2Placement3D* v1_Position);
    typedef IfcTemplatedEntityList< IfcCsgPrimitive3D > list;
};
/// Definition from ISO/CD 10303-42:1992: A solid
///   represented as a CSG model is defined by a collection of
///   so-called primitive solids, combined using regularized
///   Boolean operations. The allowed operations are
///   intersection, union, and difference. As a special case a
///   CSG solid can also consists of a single CSG primitive.
/// 
/// A CSG solid requires two kinds of information for its
///   complete definition: geometric and structural.
/// 
/// The geometric information is conveyed by solid models.
///   These typically primitive volumes such as cylinders, wedges
///   and extrusions, but can include general B-Rep models. Solid
///   models can also be half space solids.
/// 
/// The structural information is in a tree (strictly an
///   acyclic directed graph) of Boolean result and CSG solids,
///   which represent a &#8216;recipe&#8217; for building the
///   solid. The terminal nodes are the geometric primitives and
///   other solids. Every CSG solid has precisely one Boolean
///   result associated with it which is the root of the tree
///   that defines the solid. (There may be further Boolean
///   results within the tree as operands). The significance of a
///   CSG solid entity is that the solid defined by the
///   associated tree is thus identified as a significant object
///   itself, and in this way it is distinguished from other
///   Boolean result entities representing intermediate results
///   during the construction process.
/// 
/// Definition from IAI: The following primitive volumes
///   can be parts of the CSG tree: solid models, i.e. faceted
///   B-Rep (IfcFacetedBrep, IfcFacetedBrepWithVoids),
///   swept area solid (IfcExtrudedAreaSolid,
///   IfcRevolvedAreaSolid, IfcSurfaceCurveSweptAreaSolid),
///   swept disk solids (IfcSweptDiskSolid), half space
///   solids (IfcHalfSpaceSolid and subtypes), and CSG
///   primitives (subtypes of IfcCsgPrimitive3D).
/// 
/// NOTE Corresponding ISO 10303-42 entity: csg_solid, please refer to ISO/IS 10303-42:1994, p.174 for the final definition of the formal standard.
/// 
/// HISTORY New class in IFC Release 1.5.1
class IFC_PARSE_API IfcCsgSolid : public IfcSolidModel {
public:
    /// Boolean expression of primitives and regularized operators describing the solid. The root of the tree of Boolean expressions is given explicitly as an IfcBooleanResult entitiy or as a primitive (subtypes of IfcCsgPrimitive3D).
    IfcCsgSelect* TreeRootExpression() const;
    void setTreeRootExpression(IfcCsgSelect* v);
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcSolidModel::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcCsgSelect; } return IfcSolidModel::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "TreeRootExpression"; } return IfcSolidModel::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCsgSolid (IfcEntityInstanceData* e);
    IfcCsgSolid (IfcCsgSelect* v1_TreeRootExpression);
    typedef IfcTemplatedEntityList< IfcCsgSolid > list;
};
/// Definition from ISO/CD 10303-42:1992: A curve can be envisioned as the path of a point moving in its coordinate space.  
/// 
/// NOTE: Corresponding ISO 10303 entity: curve, only the following subtypes have been incorporated into IFC: line as IfcLine, conic as IfcConic, bounded_curve as IfcBoundedCurve. Please refer to ISO/IS 10303-42:1994, p.37 for the final definition of the formal standard. The derived attribute Dim has been added (see also note at IfcGeometricRepresentationItem).
/// 
/// HISTORY: New entity in IFC Release 1.0
/// 
/// Informal proposition: 
/// 
/// A curve shall be arcwise connected 
/// A curve shall have an arc length greater than zero.
class IFC_PARSE_API IfcCurve : public IfcGeometricRepresentationItem {
public:
    virtual unsigned int getArgumentCount() const { return 0; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcGeometricRepresentationItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcGeometricRepresentationItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcGeometricRepresentationItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCurve (IfcEntityInstanceData* e);
    IfcCurve ();
    typedef IfcTemplatedEntityList< IfcCurve > list;
};
/// Definition from ISO/CD 10303-42:1992: The curve bounded surface is a parametric surface with curved boundaries defined by one or more boundary curves. The bounded surface is defined to be the portion of the basis surface in the direction of N x T from any point on the boundary, where N is the surface normal and T the boundary curve tangent vector at this point. The region so defined shall be arcwise connected. 
/// 
/// The IfcCurveBoundedPlane is a specialized bounded surface class that deals only with bounding basis plane surfaces. The definition varies from STEP as outer and inner boundaries are separated attributes and refer to IfcCurve. The only basis surface that is allowed is of type IfcPlane, and the implicit_outer attribute has not been incorporated, since only unbounded surfaces are used as basis surface.
/// 
/// The BasisSurface is an IfcPlane that establishes the position coordinate system by SELF\IfcElementarySurface.Position. The OuterBoundary and the InnerBoundaries (if provided) shall lie on the surface of IfcPlane. Therefore the IfcCurve's establishing the outer and inner boundaries shall be:
/// 
/// either a 2D curve within the XY plane of the position coordinate sytem of IfcPlane or a 3D curve with all coordinates having a z value = 0.
/// 
/// NOTE Corresponding ISO 10303 entity curve_bounded_surface has been changed to meet the specific requirements of an easy representation of curve bounded planes.
/// 
/// HISTORY  New entity in IFC Release 1.5
/// 
/// IFC2x PLATFORM CHANGE: The data type of the attribute OuterBoundary and InnerBoundaries has been changed from Ifc2DCompositeCurve to its supertype IfcCurve with upward compatibility for file based exchange.
class IFC_PARSE_API IfcCurveBoundedPlane : public IfcBoundedSurface {
public:
    /// The surface to be bound.
    IfcPlane* BasisSurface() const;
    void setBasisSurface(IfcPlane* v);
    /// The outer boundary of the surface.
    IfcCurve* OuterBoundary() const;
    void setOuterBoundary(IfcCurve* v);
    /// An optional set of inner boundaries. They shall not intersect each other or the outer boundary.
    IfcTemplatedEntityList< IfcCurve >::ptr InnerBoundaries() const;
    void setInnerBoundaries(IfcTemplatedEntityList< IfcCurve >::ptr v);
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_ENTITY_INSTANCE; case 2: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } return IfcBoundedSurface::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcPlane; case 1: return Type::IfcCurve; case 2: return Type::IfcCurve; } return IfcBoundedSurface::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "BasisSurface"; case 1: return "OuterBoundary"; case 2: return "InnerBoundaries"; } return IfcBoundedSurface::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCurveBoundedPlane (IfcEntityInstanceData* e);
    IfcCurveBoundedPlane (IfcPlane* v1_BasisSurface, IfcCurve* v2_OuterBoundary, IfcTemplatedEntityList< IfcCurve >::ptr v3_InnerBoundaries);
    typedef IfcTemplatedEntityList< IfcCurveBoundedPlane > list;
};
/// Definition from ISO/CD 10303-42:1992 The curve bounded surface is a parametric surface with curved boundaries defined by one or more boundary curves. One of the boundary curves may be the outer boundary; any number of inner boundaries is permissible. The region of the curve bounded surface in the basis surface is defined to be the portion of the basis surface in the direction of N x T from any point on the boundary, where N is the surface normal and T the boundary curve tangent vector at this point. The region so defined shall be arcwise connected.
/// 
/// The IfcCurveBoundedSurface is a parametric surface with boundaries defined by p-curves, that is, a curve which lies on the basis of a surface and is defined in the parameter space of that surface. The p-curve is a special type of a composite curve segment and shall only be used to bound a surface.
/// 
/// The outer boundary shall be either defined by:
/// 
/// an IfcOuterBoundaryCurve, a closed composite curve on surface for the definition of an outer boundary, then the attribute ImplicitOuter has to be set to FALSE, or
/// by the implicit boundary of the bounded surface, e.g. the u1, u2, v1, v2 of IfcRectangularTrimmedSurface< then the attribute ImplicitOuter has to be set to TRUE.
/// Note that some surfaces, like
/// IfcCylindricalSurface does not have identifiable implicit
/// boundaries.
/// 
/// NOTE Corresponding STEP entity: curve_bounded_surface. Please refer to ISO/IS 10303-42:1994, p.87 for the final definition of the formal standard.
/// 
/// HISTORY New entity in IFC2x4.
/// 
/// Informal Propositions
/// 
/// Each curve in the set of Boundaries shall be closed.
/// No two curves in the set of Boundaries shall intersect.
/// At most one of the boundary curves may enclose any other boundary curve. If an IfcOuterBoundaryCurve is designated, only that curve may enclose any other boundary curve.
class IFC_PARSE_API IfcCurveBoundedSurface : public IfcBoundedSurface {
public:
    /// The surface to be bounded.
    IfcSurface* BasisSurface() const;
    void setBasisSurface(IfcSurface* v);
    /// The outer boundary of the surface.
    IfcTemplatedEntityList< IfcBoundaryCurve >::ptr Boundaries() const;
    void setBoundaries(IfcTemplatedEntityList< IfcBoundaryCurve >::ptr v);
    bool ImplicitOuter() const;
    void setImplicitOuter(bool v);
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 2: return IfcUtil::Argument_BOOL; } return IfcBoundedSurface::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcSurface; case 1: return Type::IfcBoundaryCurve; case 2: return Type::IfcBoolean; } return IfcBoundedSurface::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "BasisSurface"; case 1: return "Boundaries"; case 2: return "ImplicitOuter"; } return IfcBoundedSurface::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCurveBoundedSurface (IfcEntityInstanceData* e);
    IfcCurveBoundedSurface (IfcSurface* v1_BasisSurface, IfcTemplatedEntityList< IfcBoundaryCurve >::ptr v2_Boundaries, bool v3_ImplicitOuter);
    typedef IfcTemplatedEntityList< IfcCurveBoundedSurface > list;
};
/// Definition from ISO/CD 10303-42:1992: This entity defines a general direction vector in two or three dimensional space. The actual magnitudes of the components have no effect upon the direction being defined, only the ratios X:Y:Z or X:Y are significant.  
/// 
/// NOTE: The components of this entity are not normalized. If a unit vector is required it should be normalized before use.
/// 
/// NOTE: Corresponding ISO 10303 entity: direction. Please refer to ISO/IS 10303-42:1994, p.26 for the final definition of the formal standard. The derived attribute Dim has been added (see also note at IfcGeometricRepresentationItem).
/// 
/// HISTORY: New entity in IFC Release 1.0
class IFC_PARSE_API IfcDirection : public IfcGeometricRepresentationItem {
public:
    /// The components in the direction of X axis (DirectionRatios[1]), of Y axis (DirectionRatios[2]), and of Z axis (DirectionRatios[3])
    std::vector< double > /*[2:3]*/ DirectionRatios() const;
    void setDirectionRatios(std::vector< double > /*[2:3]*/ v);
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_AGGREGATE_OF_DOUBLE; } return IfcGeometricRepresentationItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcReal; } return IfcGeometricRepresentationItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "DirectionRatios"; } return IfcGeometricRepresentationItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcDirection (IfcEntityInstanceData* e);
    IfcDirection (std::vector< double > /*[2:3]*/ v1_DirectionRatios);
    typedef IfcTemplatedEntityList< IfcDirection > list;
};
/// Definition: The door style, IfcDoorStyle, defines a particular style of doors, which may be included into the spatial context of the building model through instances of IfcDoor. A door style defines the overall parameter of the door style and refers to the particular parameter of the lining and one (or several) panels through the IfcDoorLiningProperties and the IfcDoorPanelProperties.
/// 
/// The door entity, IfcDoor, defines a particular occurrence of a door inserted in the spatial context of a
/// project. The actual parameter of the door and/or its shape is defined at the IfcDoorStyle, to which the IfcDoor
/// is related by the inverse relationship IsDefinedBy pointing to IfcRelDefinedByType. The IfcDoorStyle
/// also defines the particular attributes for the lining, IfcDoorLiningProperties, and panels, IfcDoorPanelProperties.
/// 
/// HISTORYÿNew entity in IFC Release 2x.
/// 
/// IFC2x4 CHANGE The entity is deprecated and shall not be used. The new entity
/// IfcDoorType shall be used instead.
/// 
/// Geometry use definitions
/// 
/// The IfcDoorStyle defines the baseline geometry, or the representation map, for all occurrences of the door style, given
/// by the IfcDoor, pointing to this style. The representation of the door style may be given by the agreed set of minimal
/// parameters, defined for the door lining and the door panel(s), or it may be given by a geometric representation used by the
/// IfcRepresentationMap. The attribute ParameterTakesPrecedence decides, whether the set of parameters can be used to exactly represent the shape of the door style (TRUE), or whether the attached IfcRepresentationMap
/// holds the exact representation (FALSE).
/// 
/// The IfcDoorStyleOperationTypeEnum defines the general layout of the door style. Depending on the enumerator, the
/// appropriate instances of IfcDoorLiningProperties and IfcDoorPanelProperties are attached in the list of
/// HasPropertySets. The IfcDoorStyleOperationTypeEnum mainly determines the hinge side (left hung, or right hung), the
/// operation (swinging, sliding, folding, etc.)ÿand the number of panels.
/// 
/// See geometry use definitions at IfcDoorStyleOperationTypeEnum for the correct usage of opening symbols for different operation types.
class IFC_PARSE_API IfcDoorStyle : public IfcTypeProduct {
public:
    /// Type defining the general layout and operation of the door style.
    IfcDoorStyleOperationEnum::IfcDoorStyleOperationEnum OperationType() const;
    void setOperationType(IfcDoorStyleOperationEnum::IfcDoorStyleOperationEnum v);
    /// Type defining the basic construction and material type of the door.
    IfcDoorStyleConstructionEnum::IfcDoorStyleConstructionEnum ConstructionType() const;
    void setConstructionType(IfcDoorStyleConstructionEnum::IfcDoorStyleConstructionEnum v);
    /// The Boolean value reflects, whether the parameter given in the attached lining and panel properties exactly define the geometry (TRUE), or whether the attached style shape take precedence (FALSE). In the last case the parameter have only informative value.
    bool ParameterTakesPrecedence() const;
    void setParameterTakesPrecedence(bool v);
    /// The Boolean indicates, whether the attached IfcMappedRepresentation (if given) can be sized (using scale factor of transformation), or not (FALSE). If not, the IfcMappedRepresentation should be IfcShapeRepresentation of the IfcDoor (using IfcMappedItem as the Item) with the scale factor = 1.
    bool Sizeable() const;
    void setSizeable(bool v);
    virtual unsigned int getArgumentCount() const { return 12; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; case 9: return IfcUtil::Argument_ENUMERATION; case 10: return IfcUtil::Argument_BOOL; case 11: return IfcUtil::Argument_BOOL; } return IfcTypeProduct::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcDoorStyleOperationEnum; case 9: return Type::IfcDoorStyleConstructionEnum; case 10: return Type::IfcBoolean; case 11: return Type::IfcBoolean; } return IfcTypeProduct::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "OperationType"; case 9: return "ConstructionType"; case 10: return "ParameterTakesPrecedence"; case 11: return "Sizeable"; } return IfcTypeProduct::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcDoorStyle (IfcEntityInstanceData* e);
    IfcDoorStyle (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, IfcDoorStyleOperationEnum::IfcDoorStyleOperationEnum v9_OperationType, IfcDoorStyleConstructionEnum::IfcDoorStyleConstructionEnum v10_ConstructionType, bool v11_ParameterTakesPrecedence, bool v12_Sizeable);
    typedef IfcTemplatedEntityList< IfcDoorStyle > list;
};
/// Definition from ISO/CD 10303-42:1992: An edge_loop is a loop with nonzero extent. It is a path in which the start and end vertices are the same. Its domain, if present, is a closed curve. An edge_loop may overlap itself.
/// 
/// Informal propositions: 
/// 
/// The genus of the IfcEdgeLoop shall be 1 or greater. 
/// The Euler formula shall be satisfied:(number of vertices) + genus - (number of edges) = 1; 
/// No edge may be referenced more than once by the same IfcEdgeLoop with the same sense. For this purpose, an edge which is not an oriented edge is considered to be referenced with the sense TRUE. 
/// 
/// NOTE  Corresponding ISO 10303 entity: edge_loop. Please refer to ISO/IS 10303-42:1994, p. 122 for the final definition of the formal standard.
/// 
/// HISTORY  New Entity in IFC2x2.
class IFC_PARSE_API IfcEdgeLoop : public IfcLoop {
public:
    /// A list of oriented edge entities which are concatenated together to form this path.
    IfcTemplatedEntityList< IfcOrientedEdge >::ptr EdgeList() const;
    void setEdgeList(IfcTemplatedEntityList< IfcOrientedEdge >::ptr v);
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } return IfcLoop::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcOrientedEdge; } return IfcLoop::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "EdgeList"; } return IfcLoop::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcEdgeLoop (IfcEntityInstanceData* e);
    IfcEdgeLoop (IfcTemplatedEntityList< IfcOrientedEdge >::ptr v1_EdgeList);
    typedef IfcTemplatedEntityList< IfcEdgeLoop > list;
};
/// Definition from IAI: An IfcElementQuantity
/// defines a set of derived measures of an element's physical
/// property. Elements could be spatial structure elements (like
/// buildings, storeys, or spaces) or building elements (like walls,
/// slabs, finishes). The IfcElementQuantity gets assigned to
/// the element by using the IfcRelDefinesByProperties
/// relationship.
/// The optional MethodOfMeasurement attribute defines the
/// code, e.g. from a standard method of measurement, which had been
/// used to calculate the element quantity.
/// 
/// NOTE The recognizable values for the name and the
/// method of measurement attributes have to be agreed upon in
/// further agreement documents, such as implementers agreements.
/// Some of these agreements might be limited to a certain region, to
/// which the method of measurement applies.
/// 
/// The name attribute, given at the individual Quantities
/// provides a recognizable semantic meaning of the element quantity.
/// Both information is needed to establish a precise meaning for the
/// measure value. An optional description may be assigned to each of
/// the Quantities. All quantities assigned by a single
/// instance of IfcElementQuantity are deemed to have been
/// generated according to the same method of measurement. However
/// several instances of IfcElementQuantity are assignable to
/// an element, thus allowing for an element having quantities
/// generated according to several methods of measurement.
/// 
/// EXAMPLE1 To exchange the net floor area of spaces in
/// the German region (as IfcSpace), the name might be
/// 'Netto-Grundfläche' (net floor area), and the method of
/// measurement might be accordingly 'DIN277-2' (German industry norm
/// no. 277 edition 2)
/// 
/// EXAMPLE2 The same instance of IfcSpace may have
/// a different area measure assigned in the German region according
/// to a housing regulation, the name would be 'Wohnfläche' and
/// the method of measurement would be '2.BV'. It would be attached
/// to the IfcSpace by a separate
/// IfcRelDefinesByProperties relationship.
/// 
/// The IfcElementQuantity can have the following subtypes
/// of IfcPhysicalQuantity within its SET of
/// Quantities, which count for the basis measure types
/// used:
/// 
/// count measure
/// weight measure
/// length measure
/// area measure
/// volume measure
/// time measure
/// 
/// HISTORY New entity in IFC Release
/// 2x. NOTE: It replaces the calcXxx attributes used in previous IFC
/// Releases.
/// IFC2x4 CHANGE Subtyped from new
/// intermediate IfcPreDefinedPropertySet
/// supertype.
/// 
/// Quantity Use Defintion
/// Base quantities are quantity definitions that are independent
/// of a particular method of measurement and therefore
/// internationally applicable. Base quantities are defined as gross
/// and net values and provided by measurement of the correct
/// geometric shape representation of the element. The IFC
/// specification includes a set of base quantity definition. See
/// each subtype of IfcElement for applicable base
/// quantities.
/// The following general agreements apply for each base quantity
/// set
/// 
/// IfcElementQuantity.Name = 'BaseQuantities'
/// IfcElementQuantity.MethodOfMeasurement = NIL
/// IfcElementQuantity.Quantities = SET of subtypes of
/// IfcPhysicalSimpleQuantity with values for the Name
/// attribute as published as part of the IFC specifciation.
class IFC_PARSE_API IfcElementQuantity : public IfcQuantitySet {
public:
    /// Whether the optional attribute MethodOfMeasurement is defined for this IfcElementQuantity
    bool hasMethodOfMeasurement() const;
    /// Name of the method of measurement used to calculate the element quantity. The method of measurement attribute has to be made recognizable by further agreements.
    /// 
    /// IFC2x2 Addendum 1 change: The attribute has been changed to be optional
    std::string MethodOfMeasurement() const;
    void setMethodOfMeasurement(std::string v);
    /// The individual quantities for the element, can be a set of length, area, volume, weight or count based quantities.
    IfcTemplatedEntityList< IfcPhysicalQuantity >::ptr Quantities() const;
    void setQuantities(IfcTemplatedEntityList< IfcPhysicalQuantity >::ptr v);
    virtual unsigned int getArgumentCount() const { return 6; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 4: return IfcUtil::Argument_STRING; case 5: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } return IfcQuantitySet::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 4: return Type::IfcLabel; case 5: return Type::IfcPhysicalQuantity; } return IfcQuantitySet::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 4: return "MethodOfMeasurement"; case 5: return "Quantities"; } return IfcQuantitySet::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcElementQuantity (IfcEntityInstanceData* e);
    IfcElementQuantity (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_MethodOfMeasurement, IfcTemplatedEntityList< IfcPhysicalQuantity >::ptr v6_Quantities);
    typedef IfcTemplatedEntityList< IfcElementQuantity > list;
};
/// Definition from IAI: The IfcElementType
///   defines a list of commonly shared property set definitions
///   of an element and an optional set of product
///   representations. It is used to define an element
///   specification (i.e. the specific product information, that
///   is common to all occurrences of that product type).
/// 
/// NOTE The product representations are defined as
///   representation maps (at the level of the supertype
///   IfcTypeProduct, which gets assigned by an element
///   instance through the
///   IfcShapeRepresentation.Item[1] being an
///   IfcMappedItem.
/// 
/// An element type is used to define the common properties of
///   a certain type or style of an element that may be applied
///   to instances of that element type to assign a specific
///   style. Element types (the instantiable subtypes) may be
///   exchanged without being already assigned to occurrences.
/// 
/// HISTORY New entity in
///   Release IFC2x Edition 2
class IFC_PARSE_API IfcElementType : public IfcTypeProduct {
public:
    /// Whether the optional attribute ElementType is defined for this IfcElementType
    bool hasElementType() const;
    /// The type denotes a particular type that indicates the object further. The use has to be established at the level of instantiable subtypes. In particular it holds the user defined type, if the enumeration of the attribute 'PredefinedType' is set to USERDEFINED.
    std::string ElementType() const;
    void setElementType(std::string v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_STRING; } return IfcTypeProduct::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcLabel; } return IfcTypeProduct::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "ElementType"; } return IfcTypeProduct::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcElementType (IfcEntityInstanceData* e);
    IfcElementType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType);
    typedef IfcTemplatedEntityList< IfcElementType > list;
};
/// Definition from ISO/CD 10303-42:1992: An elementary surface (IfcElementarySurface) is a simple analytic surface with defined parametric representation. 
/// 
/// NOTE Corresponding ISO 10303 entity: elementary_surface. Only the subtype plane is incorporated as IfcPlane. The derived attribute Dim has been added (see also note at IfcGeometricRepresentationItem). Please refer to ISO/IS 10303-42:1994, p. 69 for the final definition of the formal standard.
/// 
/// HISTORY New class in IFC Release 1.5
class IFC_PARSE_API IfcElementarySurface : public IfcSurface {
public:
    /// The position and orientation of the surface. This attribute is used in the definition of the parameterization of the surface.
    IfcAxis2Placement3D* Position() const;
    void setPosition(IfcAxis2Placement3D* v);
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcSurface::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcAxis2Placement3D; } return IfcSurface::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Position"; } return IfcSurface::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcElementarySurface (IfcEntityInstanceData* e);
    IfcElementarySurface (IfcAxis2Placement3D* v1_Position);
    typedef IfcTemplatedEntityList< IfcElementarySurface > list;
};
/// IfcEllipseProfileDef defines an ellipse as the profile definition used by the swept surface geometry
/// or the swept area solid. It is given by its semi axis attributes and placed within the 2D position coordinate system, established by the Position attribute. 
/// 
/// HISTORY  New entity in IFC2x
/// 
/// Figure 317 illustrates parameters for the ellipse profile definition. The parameterized profile defines its own position coordinate system.
/// The underlying coordinate system is defined by the swept surface or swept area solid that uses the profile definition. It is the xy plane of either: 
/// 
/// IfcSweptSurface.Position
///   IfcSweptAreaSolid.Position
/// 
/// Or in case of sectioned spines it is the xy plane of each list member of IfcSectionedSpine.CrossSectionPositions. By using offsets of the position location, the parameterized profile can be positioned centric (using x,y offsets = 0.), or at any position relative to the profile. Explicit coordinate offsets are used to define cardinal points (for example, upper-left bound). The location of the position coordinate system defines the center of the ellipse. The SemiAxis1 attribute defines the first radius of the ellipse in the direction of the X axis, the SemiAxis2 attribute defines the second radius of the ellipse in the direction of the Y axis.
/// 
/// NOTE  The semi axes of the ellipse are rectangular to each other by definition.
/// 
/// Figure 317 — Ellipse profile
class IFC_PARSE_API IfcEllipseProfileDef : public IfcParameterizedProfileDef {
public:
    /// The first radius of the ellipse. It is measured along the direction of Position.P[1].
    double SemiAxis1() const;
    void setSemiAxis1(double v);
    /// The second radius of the ellipse. It is measured along the direction of Position.P[2].
    double SemiAxis2() const;
    void setSemiAxis2(double v);
    virtual unsigned int getArgumentCount() const { return 5; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 3: return IfcUtil::Argument_DOUBLE; case 4: return IfcUtil::Argument_DOUBLE; } return IfcParameterizedProfileDef::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 3: return Type::IfcPositiveLengthMeasure; case 4: return Type::IfcPositiveLengthMeasure; } return IfcParameterizedProfileDef::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 3: return "SemiAxis1"; case 4: return "SemiAxis2"; } return IfcParameterizedProfileDef::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcEllipseProfileDef (IfcEntityInstanceData* e);
    IfcEllipseProfileDef (IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< std::string > v2_ProfileName, IfcAxis2Placement2D* v3_Position, double v4_SemiAxis1, double v5_SemiAxis2);
    typedef IfcTemplatedEntityList< IfcEllipseProfileDef > list;
};
/// An IfcEventType defines a particular type of event that may be specified.
/// 
/// HISTORY  New entity in IFC2x4
/// 
/// An IfcEventType provides for all forms of types of event that may be specified.
///   Usage of IfcEventType defines the parameters for one or more occurrences of IfcEvent. Parameters may be specified through property sets that may be enumerated in the IfcEventTypeEnum data type or through explicit attributes of IfcEvent. Event occurrences (IfcEvent entities) are linked to the event type through the IfcRelDefinesByType relationship.
class IFC_PARSE_API IfcEventType : public IfcTypeProcess {
public:
    /// Identifies the predefined types of an event from which 
    ///   the type required may be set.
    IfcEventTypeEnum::IfcEventTypeEnum PredefinedType() const;
    void setPredefinedType(IfcEventTypeEnum::IfcEventTypeEnum v);
    /// Identifies the predefined types of event trigger from which 
    ///   the type required may be set.
    IfcEventTriggerTypeEnum::IfcEventTriggerTypeEnum EventTriggerType() const;
    void setEventTriggerType(IfcEventTriggerTypeEnum::IfcEventTriggerTypeEnum v);
    /// Whether the optional attribute UserDefinedEventTriggerType is defined for this IfcEventType
    bool hasUserDefinedEventTriggerType() const;
    /// A user defined event trigger type, the value of which 
    ///   is asserted when the value of an event trigger type is 
    ///   declared as USERDEFINED.
    std::string UserDefinedEventTriggerType() const;
    void setUserDefinedEventTriggerType(std::string v);
    virtual unsigned int getArgumentCount() const { return 12; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; case 10: return IfcUtil::Argument_ENUMERATION; case 11: return IfcUtil::Argument_STRING; } return IfcTypeProcess::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcEventTypeEnum; case 10: return Type::IfcEventTriggerTypeEnum; case 11: return Type::IfcLabel; } return IfcTypeProcess::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; case 10: return "EventTriggerType"; case 11: return "UserDefinedEventTriggerType"; } return IfcTypeProcess::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcEventType (IfcEntityInstanceData* e);
    IfcEventType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< std::string > v7_Identification, boost::optional< std::string > v8_LongDescription, boost::optional< std::string > v9_ProcessType, IfcEventTypeEnum::IfcEventTypeEnum v10_PredefinedType, IfcEventTriggerTypeEnum::IfcEventTriggerTypeEnum v11_EventTriggerType, boost::optional< std::string > v12_UserDefinedEventTriggerType);
    typedef IfcTemplatedEntityList< IfcEventType > list;
};
/// The IfcExtrudedAreaSolid is defined by sweeping a cross
/// section provided by a profile definition. The direction of the
/// extrusion is given by the ExtrudedDirection attribute and
/// the length of the extrusion is given by the Depth
/// attribute. If the planar area has inner boundaries (holes
/// defined), then those holes shall be swept into holes of the solid.
/// The extruded direction can be any direction which is not
/// perpendicular to the z axis of the position coordinate system of
/// the profile.
/// The following definitions from ISO 10303-42 apply:
/// 
/// An extruded area
/// solid is a solid defined by sweeping a bounded planar surface. The
/// direction of translation is defined by a direction vector, and the
/// length of the translation is defined by a distance depth. The
/// planar area may have holes which will sweep into holes in the
/// solid.
/// 
/// The ExtrudedDirection is given within the position
/// coordinate system as defined by
/// IfcSweptAreaSolid.Position. Extrusions are not restricted
/// to be perpendicular to the extruded surface of the profile.
/// 
/// Figure 255 illustrates geometric parameters of the extruded area solid.  The extruded area solid defines the extrusion of a 2D area (given by a profile definition) by an direction and depth. The result is a
/// solid. The swept area is given by a profile definition. This profile is defined:
/// 
/// as a 2D bounded curve within the xy plane of the position coordinate system,
/// as a 2D bounded curve with holes within the xy plane of the position coordinate system,
/// or as a 2D primitive, defined within a 2D position coordinate system, that is placed relative to the xy plane of the position coordinate system
/// 
/// Figure 255 — Extruded area solid geometry
/// 
/// NOTE  Corresponding ISO 10303-42 entity: extruded_area_solid. Please refer to ISO/IS 10303-42:1994, p. 183 for the final definition of the formal standard. The data type of the inherited SweptArea attribute is different, i.e. of type IfcProfileDef. The Position attribute has been added to position the cross section used for the linear extrusion.
/// 
/// HISTORY  New entity in IFC Release 1.5, capabilities of this entity have been enhanced in IFC Release 2x.
/// 
/// Texture use definition
/// For side faces, textures are aligned facing upright continuously
/// along the sides with origin at the first point of an arbitrary
/// profile, and following the outer bound of the profile
/// counter-clockwise (as seen from above). For parameterized profiles,
/// the origin is defined at the +Y extent for rounded profiles (having
/// no sharp edge) and the first sharp edge counter-clockwise from the
/// +Y extent for all other profiles. Textures are stretched or
/// repeated on each side along the outer boundary of the profile
/// according to RepeatS. Textures are stretched or repeated
/// on each side along the extrusion axis according to
/// RepeatT.
/// For top and bottom caps, textures are aligned facing
/// front-to-back, with the origin at the minimum X and Y extent.
/// Textures are stretched or repeated on the top and bottom to the
/// extent of each face according to RepeatS and
/// RepeatT.
/// For profiles with voids, textures are aligned facing upright
/// along the inner side with origin at the first point of an arbitrary
/// profile, and following the inner bound of the profile clockwise (as
/// seen from above). For parameterized profiles, the origin of inner
/// sides is defined at the +Y extent for rounded profiles (having no
/// sharp edge such as hollow ellipses or rounded rectangles) and the
/// first sharp edge clockwise from the +Y extent for all other
/// profiles.
/// 
/// Figure 256 illustrates default texture mapping with a repeated texture (RepeatS=True and RepeatT=True). The image on the left shows the texture where the S axis points to the right and the T axis points up. The image on the right shows the texture applied to the geometry where the X axis points back to the right, the Y axis points back to the left, and the Z axis points up. For an IfcExtrudedAreaSolid having a profile of IfcIShapeProfileDef, the side texture coordinate origin is the first corner counter-clockwise from the +Y axis, which equals
/// (-0.5*IfcIShapeProfileDef.OverallWidth, +0.5*IfcIShapeProfileDef.OverallDepth), while the top (end cap)
/// texture coordinates start at (-0.5*IfcIShapeProfileDef.OverallWidth,
/// -0.5*IfcIShapeProfileDef.OverallDepth).
/// 
/// Figure 256 — Extruded area solid textures
class IFC_PARSE_API IfcExtrudedAreaSolid : public IfcSweptAreaSolid {
public:
    /// The direction in which the surface, provided by SweptArea is to be swept.
    IfcDirection* ExtrudedDirection() const;
    void setExtrudedDirection(IfcDirection* v);
    /// The distance the surface is to be swept along the ExtrudedDirection
    /// .
    double Depth() const;
    void setDepth(double v);
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 2: return IfcUtil::Argument_ENTITY_INSTANCE; case 3: return IfcUtil::Argument_DOUBLE; } return IfcSweptAreaSolid::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 2: return Type::IfcDirection; case 3: return Type::IfcPositiveLengthMeasure; } return IfcSweptAreaSolid::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 2: return "ExtrudedDirection"; case 3: return "Depth"; } return IfcSweptAreaSolid::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcExtrudedAreaSolid (IfcEntityInstanceData* e);
    IfcExtrudedAreaSolid (IfcProfileDef* v1_SweptArea, IfcAxis2Placement3D* v2_Position, IfcDirection* v3_ExtrudedDirection, double v4_Depth);
    typedef IfcTemplatedEntityList< IfcExtrudedAreaSolid > list;
};
/// IfcExtrudedAreaSolidTapered is defined by sweeping a cross
/// section along a linear spine. The cross section may change along
/// the sweep from the shape of the start cross section into the
/// shape of the end cross section. The resulting solid is bounded by
/// three or more faces: A start face, an end face (each defined by
/// start and end planes and sections), and one or more lateral
/// faces. Each lateral face is a ruled surface defined by a pair of
/// corresponding edges of the start and end section.
/// NOTE Given that the start and end section is
/// provided by a polygon, the corresponding vertices of the start
/// and end cross section are connected, forming a quadrilateral
/// polygon between each pair of corresponding vertices. The surface
/// defined by the bounding quadrilateral polygon is a ruled surface,
/// that could be approximated by triangulation.
/// The linear spine is defined by:
/// 
/// Start point:
/// SELF\IfcSweptAreaSolid.Position.Location
/// Direction:
/// SELF\IfcExtrudedAreaSolid.ExtrudedDirection
/// Distance: SELF\IfcExtrudedAreaSolid.Depth
/// 
/// The start cross section is defined by
/// SELF\IfcSweptAreaSolid.SweptArea:
/// 
/// A bounded planar surface lying in the XY plane of the
/// position coordinate system defined by
/// SELF\IfcSweptAreaSolid.Position.P[1] and
/// SELF\IfcSweptAreaSolid.Position.P[2]
/// The linear spine starts at the plane of the start cross
/// section. The spine is not necessarily perpendicular to the
/// plane.
/// 
/// The end cross section is defined by EndSweptArea:
/// 
/// A bounded planar surface lying in the XY plane of the
/// position coordinate system defined by translating the start
/// position coordinates provided by
/// SELF\IfcSweptAreaSolid.Position along the spine direction
/// by the spine distance. The plane of the end cross section is
/// coplanar to the plane of the start cross section.
/// 
/// The end cross section is topologically similar to the start
/// cross section (i.e. having the same number of vertices and
/// edges).
/// The end cross section can either be defined by the same
/// paramteric profile using different parameter values, or by a 2D
/// Cartesian transformation of the start profile within the end
/// cross section plane.
/// 
/// In case of two parameterized profiles the shape is constructed
/// as follows:
/// 
/// The end profile, defined by a cross section based on the same
/// profile paramterization as the start profile, is translated by
/// the spine distance along the spine direction.
/// It may be shifted within the XY plane of the end postion
/// coordinate system and may be twisted using the rotation
/// parameter.
/// The shift and rotation parameter are provided by the end
/// cross section being of type IfcParameterizedProfileDef,
/// where
/// 
/// Shift is
/// EndSweptArea\IfcParameterizedProfileDef.Position.Location
/// Rotation is
/// EndSweptArea\IfcParameterizedProfileDef.Position.RefDirection
/// 
/// Corresponding vertices of the start and end cross section are
/// connected. Lateral faces are constructed as ruled surfaces
/// between corresponding edges of start and end cross section.
/// 
/// In case of Cartesian transformation of the start cross section
/// the shape is constructed as follows:
/// 
/// The cross section curve, which starts as a curve in the XY
/// plane of the position coordinate system, is first scaled about
/// the origin by the scale parameter. It is then translated by the
/// spine distance along the spine direction. It maybe twisted by
/// using the rotation parameter.
/// The scale and rotation parameter are provided by the end
/// cross section being of type IfcDerivedProfileDef, where
/// 
/// Scale is
/// EndSweptArea\IfcDerivedProfileDef.Operator.Scale
/// Rotation is
/// EndSweptArea\IfcDerivedProfileDef.Operator.Axis1
/// 
/// Corresponding vertices of the start and end cross section are
/// connected. Lateral faces are constructed as ruled surfaces
/// between corresponding edges of start and end cross section.
/// 
/// HISTORY New entity in IFC2x4.
/// 
/// Informal propositions
/// 
/// Mirroring within IfcDerivedProfileDef.Operator shall
/// not be used
class IFC_PARSE_API IfcExtrudedAreaSolidTapered : public IfcExtrudedAreaSolid {
public:
    /// The surface defining the end of the swept area. It is given as a profile definition. The position coordinate system of the EndSwptArea is generated by translating the SELF\IfcSweptAreaSolid.Position along the SELF\IfcExtrudedAreaSolid.ExtrudedDirection by the distance of SELF\IfcExtrudedAreaSolid.Depth.
    IfcProfileDef* EndSweptArea() const;
    void setEndSweptArea(IfcProfileDef* v);
    virtual unsigned int getArgumentCount() const { return 5; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 4: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcExtrudedAreaSolid::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 4: return Type::IfcProfileDef; } return IfcExtrudedAreaSolid::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 4: return "EndSweptArea"; } return IfcExtrudedAreaSolid::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcExtrudedAreaSolidTapered (IfcEntityInstanceData* e);
    IfcExtrudedAreaSolidTapered (IfcProfileDef* v1_SweptArea, IfcAxis2Placement3D* v2_Position, IfcDirection* v3_ExtrudedDirection, double v4_Depth, IfcProfileDef* v5_EndSweptArea);
    typedef IfcTemplatedEntityList< IfcExtrudedAreaSolidTapered > list;
};
/// Definition from ISO/CD 10303-42:1992: A face based surface model is described by a set of connected face sets of dimensionality 2. The connected face sets shall not intersect except at edges and vertices, except that a face in one connected face set may overlap a face in another connected face set, provided the face boundaries are identical. There shall be at least one connected face set.  
/// 
/// A connected face set may exist independently of a surface model.
/// 
/// NOTE Corresponding STEP entity: face_based_surface_model. Please refer to ISO/IS 10303-42:1994, p. 188 for the final definition of the formal standard.
/// 
/// HISTORY: New entity in IFC Release 2x.
/// 
/// Informal propositions:
/// 
/// The connected face sets shall not overlap or intersect except at common faces, edges or vertices.
/// The fbsm faces have dimensionality 2.
class IFC_PARSE_API IfcFaceBasedSurfaceModel : public IfcGeometricRepresentationItem {
public:
    /// The set of connected face sets comprising the face based surface model.
    IfcTemplatedEntityList< IfcConnectedFaceSet >::ptr FbsmFaces() const;
    void setFbsmFaces(IfcTemplatedEntityList< IfcConnectedFaceSet >::ptr v);
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } return IfcGeometricRepresentationItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcConnectedFaceSet; } return IfcGeometricRepresentationItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "FbsmFaces"; } return IfcGeometricRepresentationItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcFaceBasedSurfaceModel (IfcEntityInstanceData* e);
    IfcFaceBasedSurfaceModel (IfcTemplatedEntityList< IfcConnectedFaceSet >::ptr v1_FbsmFaces);
    typedef IfcTemplatedEntityList< IfcFaceBasedSurfaceModel > list;
};
/// Definition from ISO/CD 10303-46:1992: The fill area style hatching defines a styled pattern of curves for hatching an annotation fill area or a surface.
/// 
/// The IfcFillAreaStyleHatching is used to define simple, vector-based hatching patterns, based on styled straight lines. The curve font, color and thickness is given by the HatchLineAppearance, the angle by the HatchLineAngle and the distance to the next hatch line by StartOfNextHatchLine, being either an offset distance or a vector.
/// 
/// NOTE  If the hatch pattern involves two (potentially crossing) rows of hatch lines, then two instances of IfcFillAreaStyleHatching should be assigned to the IfcFillAreaStyle. Both share the same (virtual) point of origin of the hatching that is used by the reference hatch line (or the PointOfReferenceHatchLine if there is an offset).
/// 
/// For better control of the hatching appearance, when using hatch lines with other fonts then continuous, the PatternStart allows to offset the start of the curve font pattern along the reference hatch line (if not given, the PatternStart is at zero distance from the virtual point of origin). If the reference hatch line does not go through the origin (of the virtual hatching coordinate system), it can be offset by using the PatternStart PointOfReferenceHatchLine.
/// 
/// NOTE  The coordinates of the PatternStart and the PointOfReferenceHatchLine are given relative to the assumed 0., 0. virtual point of origin at which the hatch pattern is later positioned by the FillStyleTarget point at IfcAnnotationFillAreaOccurrence. The measure values are given in global drawing length units and apply to the target plot scale for the scale depended representation subcontext.
/// 
/// NOTE  The use of PointOfReferenceHatchLine is deprecated.
/// 
/// Figure 292 illustrates hatch attributes.
/// 
/// Example 1
/// This example shows simple hatching given by using a curve font "continuous" at HatchLineAppearance.
/// 
/// The distance of hatch lines is given by a positive length measure. The
/// angle (here 45' if measures in degree) is provided by HatchLineAngle.
/// 
/// The PatternStart is
/// set to NIL ($) in this example.  Example 2
/// This shows hatching from example 1 with using a different curve font at HatchLineAppearance.
///   The distance of hatch lines is given by a positive
/// length measure, therefore the font pattern start is at a point at the
/// next hatch line given by a vector being perpendicular to the point of
/// origin at the reference hatch line.  The
/// PatternStart is set to NIL ($) in this example.
///   Example 3
/// This example uses hatching from example 2 with a vector to determine the pattern start of the next hatch lines. 
/// The pattern start is the beginning of the first visual curve font pattern segment at IfcCurveFont.CurveFont.  The PatternStart is set to NIL ($) in this example.
///   Example 4
/// This example uses hatching from example 3 where the pattern start is offset from the point of origin at the reference hatch line. That is, the first visible curve font pattern segment now does not start at the point of origin at the reference hatch line.
/// 
/// Example 5
/// This example uses hatching from example 4 where the hatch pattern is shifted against the underlying coordinate system. 
/// The point that is mapped to the insertion point of the IfcAnnotationFillAreaOccurrence now has an X and Y offset from the start of the reference hatch line. That is, the reference hatch line now does not go through the insertion point of the hatching.    
///   Example 6
/// This example shows use of IfcFillAreaStyleHatching attributes for two IfcFillAreaStyleHatching's within one IfcFillAreaStyle. Note that the PatternStart now displaces both the reference hatch line from the point of origin and the start of the curve pattern. This can be used in cases when more than one IfcFillAreaStyleHatching is used in an IfcFillAreaStyle in order to place rows of hatch lines with an offset from each other.
/// 
/// Figure 292 — Fill area style hatching
/// 
/// NOTE  Corresponding ISO 10303 name: fill_area_style_hatching. Please refer to ISO/IS 10303-46:1994, p. 108 for the final definition of the formal standard.
/// 
/// HISTORY  New entity in IFC2x2.
/// 
/// IFC2x3 CHANGE  The IfcFillAreaStyleHatching has been changed by making the attributes PatternStart and PointOfReferenceHatchLine OPTIONAL. The attribute StartOfNextHatchLine has changed to a SELECT with the additional choice of IfcPositiveLengthMeasure. Upward compatibility for file based exchange is guaranteed.
class IFC_PARSE_API IfcFillAreaStyleHatching : public IfcGeometricRepresentationItem {
public:
    /// The curve style of the hatching lines. Any curve style pattern shall start at the origin of each hatch line.
    IfcCurveStyle* HatchLineAppearance() const;
    void setHatchLineAppearance(IfcCurveStyle* v);
    /// A repetition factor that determines the distance between adjacent hatch lines.
    /// 
    /// IFC2x Edition 3 CHANGE  The attribute type of StartOfNextHatchLine has changed to a SELECT of IfcPositiveLengthMeasure (new) and IfcOneDirectionRepeatFactor.
    IfcHatchLineDistanceSelect* StartOfNextHatchLine() const;
    void setStartOfNextHatchLine(IfcHatchLineDistanceSelect* v);
    /// Whether the optional attribute PointOfReferenceHatchLine is defined for this IfcFillAreaStyleHatching
    bool hasPointOfReferenceHatchLine() const;
    /// A Cartesian point which defines the offset of the reference hatch line from the origin of the (virtual) hatching coordinate system. The origin is used for mapping the fill area style hatching onto an annotation fill area or surface. The reference hatch line would then appear with this offset from the fill style target point.
    /// If not given the reference hatch lines goes through the origin of the (virtual) hatching coordinate system.
    /// 
    /// IFC2x Edition 3 CHANGE  The usage of the attribute PointOfReferenceHatchLine has changed to not provide the Cartesian point which is the origin for mapping, but to provide an offset to the origin for the mapping. The attribute has been made OPTIONAL.
    IfcCartesianPoint* PointOfReferenceHatchLine() const;
    void setPointOfReferenceHatchLine(IfcCartesianPoint* v);
    /// Whether the optional attribute PatternStart is defined for this IfcFillAreaStyleHatching
    bool hasPatternStart() const;
    /// A distance along the reference hatch line which is the start point for the curve style font pattern of the reference hatch line.
    /// If not given, the start point of the curve style font pattern is at the (virtual) hatching coordinate system.
    /// 
    /// IFC2x Edition 2 Addendum 2 CHANGE The attribute PatternStart has been made OPTIONAL.
    IfcCartesianPoint* PatternStart() const;
    void setPatternStart(IfcCartesianPoint* v);
    /// A plane angle measure determining the direction of the parallel hatching lines.
    double HatchLineAngle() const;
    void setHatchLineAngle(double v);
    virtual unsigned int getArgumentCount() const { return 5; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_ENTITY_INSTANCE; case 2: return IfcUtil::Argument_ENTITY_INSTANCE; case 3: return IfcUtil::Argument_ENTITY_INSTANCE; case 4: return IfcUtil::Argument_DOUBLE; } return IfcGeometricRepresentationItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcCurveStyle; case 1: return Type::IfcHatchLineDistanceSelect; case 2: return Type::IfcCartesianPoint; case 3: return Type::IfcCartesianPoint; case 4: return Type::IfcPlaneAngleMeasure; } return IfcGeometricRepresentationItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "HatchLineAppearance"; case 1: return "StartOfNextHatchLine"; case 2: return "PointOfReferenceHatchLine"; case 3: return "PatternStart"; case 4: return "HatchLineAngle"; } return IfcGeometricRepresentationItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcFillAreaStyleHatching (IfcEntityInstanceData* e);
    IfcFillAreaStyleHatching (IfcCurveStyle* v1_HatchLineAppearance, IfcHatchLineDistanceSelect* v2_StartOfNextHatchLine, IfcCartesianPoint* v3_PointOfReferenceHatchLine, IfcCartesianPoint* v4_PatternStart, double v5_HatchLineAngle);
    typedef IfcTemplatedEntityList< IfcFillAreaStyleHatching > list;
};
/// Definition from ISO/CD 10303-46:1992: The fill area style tiles defines a two dimensional tile to be used for the filling of annotation fill areas or other closed regions. The content of a tile is defined by the tile set, and the placement of each tile determined by the filling pattern which indicates how to place tiles next to each other. Tiles or parts of tiles outside of the annotation fill area or closed region shall be clipped at the of the area or region. 
/// 
/// NOTE Corresponding ISO 10303 name: fill_area_style_tiles. Please refer to ISO/IS 10303-46:1994 for the final definition of the formal standard.
/// 
/// HISTORY New entity in IFC2x2.
class IFC_PARSE_API IfcFillAreaStyleTiles : public IfcGeometricRepresentationItem {
public:
    /// A two direction repeat factor defining the shape and relative positioning of the tiles.
    IfcTemplatedEntityList< IfcVector >::ptr TilingPattern() const;
    void setTilingPattern(IfcTemplatedEntityList< IfcVector >::ptr v);
    /// A set of constituents of the tile.
    IfcTemplatedEntityList< IfcStyledItem >::ptr Tiles() const;
    void setTiles(IfcTemplatedEntityList< IfcStyledItem >::ptr v);
    /// The scale factor applied to each tile as it is placed in the annotation fill area.
    double TilingScale() const;
    void setTilingScale(double v);
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 2: return IfcUtil::Argument_DOUBLE; } return IfcGeometricRepresentationItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcVector; case 1: return Type::IfcStyledItem; case 2: return Type::IfcPositiveRatioMeasure; } return IfcGeometricRepresentationItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "TilingPattern"; case 1: return "Tiles"; case 2: return "TilingScale"; } return IfcGeometricRepresentationItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcFillAreaStyleTiles (IfcEntityInstanceData* e);
    IfcFillAreaStyleTiles (IfcTemplatedEntityList< IfcVector >::ptr v1_TilingPattern, IfcTemplatedEntityList< IfcStyledItem >::ptr v2_Tiles, double v3_TilingScale);
    typedef IfcTemplatedEntityList< IfcFillAreaStyleTiles > list;
};
/// A fixed reference swept area solid is a type of swept area solid
/// which is the result of sweeping a surface along a
/// Directrix. The orientation of the curve during the
/// sweeping operation is controlled by the FixedReference
/// direction.
/// The SweptArea is required to be a curve bounded surface
/// lying in the plane z = 0 and this is swept along the
/// Directrix in such a way that the origin of the local
/// coordinate system used to define the SweptArea is on the
/// Directrix and the local X axis is in the direction of the
/// projection of FixedReference onto the normal plane to the
/// directrix at this point. The resulting solid has the property that
/// the cross section of the surface by the normal plane to the
/// Directrix at any point is a copy of the
/// SweptArea.
/// 
/// NOTE The swept face
/// is given by IfcProfileDef (or subtypes), the profile
/// definition is given within a 2D coordinate system, which is
/// inserted into the XY plane of the Position coordinate
/// system inherited from the supertype
/// IfcSweptAreaSolid.
/// 
/// The orientation of the SweptArea as it sweeps along the
/// Directrix is precisely defined by a
/// CartesianTransformationOperator3d with attributes:
/// 
/// LocalOrigin as point (0; 0; 0),
/// Axis1 as the FixedReference.
/// Axis3 as the direction of the tangent vector t
/// at the point of the Directrix with parameter
/// u.
/// 
/// The remaining attributes are defaulted to define a corresponding
/// transformation matrix T(u), which varies with the
/// Directrix parameter u.
/// 
/// NOTE The geometric shape of the
/// solid is not dependent upon the curve parameterization; the volume
/// depends upon the area swept and the length of the
/// Directrix.
/// 
/// The attributes of the Cartesian Transformation Operator (as
/// shown above) should apply to the Position coordinate
/// system, in which the profile is inserted. The Directrix
/// and the FixedReference are positioned within the 3D
/// Position coordinate system.
/// 
/// NOTE The entity is defined in analogy to the ISO 10303-42 entity: fixed_reference_swept_surface. Please refer to ISO/DIS 10303-42:2003(E) p. 103.
/// 
/// HISTORY New entity in IFC2x4.
/// 
/// Informal propositions:
/// 
/// The SweptArea shall lie in the plane z = 0.
/// The FixedReference shall not be parallel to a tangent
/// vector to the directrix at any point along this curve.
/// The Directrix curve shall be tangent continuous.
class IFC_PARSE_API IfcFixedReferenceSweptAreaSolid : public IfcSweptAreaSolid {
public:
    /// The curve used to define the sweeping operation. The solid is generated by sweeping the SELF\IfcSweptAreaSolid.SweptArea along the Directrix.
    IfcCurve* Directrix() const;
    void setDirectrix(IfcCurve* v);
    /// Whether the optional attribute StartParam is defined for this IfcFixedReferenceSweptAreaSolid
    bool hasStartParam() const;
    /// The parameter value on the Directrix at which the sweeping operation commences. If no value is provided the start of the sweeping operation is at the start of the Directrix.
    double StartParam() const;
    void setStartParam(double v);
    /// Whether the optional attribute EndParam is defined for this IfcFixedReferenceSweptAreaSolid
    bool hasEndParam() const;
    /// The parameter value on the Directrix at which the sweeping operation ends. If no value is provided the end of the sweeping operation is at the end of the Directrix.
    double EndParam() const;
    void setEndParam(double v);
    /// The direction providing the fixed axis1 (x-axis) direction for orienting the swept area during the sweeping operation along the Directrix.
    IfcDirection* FixedReference() const;
    void setFixedReference(IfcDirection* v);
    virtual unsigned int getArgumentCount() const { return 6; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 2: return IfcUtil::Argument_ENTITY_INSTANCE; case 3: return IfcUtil::Argument_DOUBLE; case 4: return IfcUtil::Argument_DOUBLE; case 5: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcSweptAreaSolid::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 2: return Type::IfcCurve; case 3: return Type::IfcParameterValue; case 4: return Type::IfcParameterValue; case 5: return Type::IfcDirection; } return IfcSweptAreaSolid::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 2: return "Directrix"; case 3: return "StartParam"; case 4: return "EndParam"; case 5: return "FixedReference"; } return IfcSweptAreaSolid::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcFixedReferenceSweptAreaSolid (IfcEntityInstanceData* e);
    IfcFixedReferenceSweptAreaSolid (IfcProfileDef* v1_SweptArea, IfcAxis2Placement3D* v2_Position, IfcCurve* v3_Directrix, boost::optional< double > v4_StartParam, boost::optional< double > v5_EndParam, IfcDirection* v6_FixedReference);
    typedef IfcTemplatedEntityList< IfcFixedReferenceSweptAreaSolid > list;
};
/// Definition from IAI: The
/// IfcFurnishingElementType defines a list of commonly shared
/// property set definitions of an element and an optional set of
/// product representations. It is used to define an element
/// specification (i.e. the specific product information, that is
/// common to all occurrences of that product type).
/// NOTEÿ The product representations are defined
/// as representation maps (at the level of the supertype
/// IfcTypeProduct, which gets assigned by an element
/// occurrence instance through the
/// IfcShapeRepresentation.Item[1] being an
/// IfcMappedItem.
/// A furnishing element type is used to define the common
/// properties of a certain type of a furnishing element that may be
/// applied to many instances of that feature type to assign a
/// specific style. Furnishing element types (or the instantiable
/// subtypes) may be exchanged without being already assigned to
/// occurrences.
/// The occurrences of the IfcFurnishingElementType are
/// represented by instances of IfcFurnishingElement (or its
/// subtypes).
/// HISTORYÿNew entity in
/// Release IFC2x Edition 2.
/// IFC2x3 CHANGE The entity has been
/// made non-abstract
/// IFC2x4 CHANGE The entity is marked
/// as deprecated for instantiation - will be made ABSTRACT after
/// IFC2x4.
class IFC_PARSE_API IfcFurnishingElementType : public IfcElementType {
public:
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcElementType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcElementType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcElementType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcFurnishingElementType (IfcEntityInstanceData* e);
    IfcFurnishingElementType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType);
    typedef IfcTemplatedEntityList< IfcFurnishingElementType > list;
};
/// The furnishing element type IfcFurnitureType defines commonly shared information for occurrences of furnitures.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// applicable assignment of process types 
/// 
/// It is used to define a furniture specification (i.e. the specific product information, that is common to all occurrences of that product type).  Furniture types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcFurnitureType are represented by instances of IfcFurniture. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcFurnishingElementType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_FurnitureTypeCommon 
/// 
/// The following property set definitions are applicable to this entity according to the PredefinedType attribute:  
/// Pset_FurnitureTypeChair (CHAIR) 
/// Pset_FurnitureTypeDesk (DESK) 
/// Pset_FurnitureTypeFileCabinet (FILECABINET) 
/// Pset_FurnitureTypeTable (TABLE) 
/// 
/// Material Use Definition 
/// The material of the IfcFurnitureType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Finish': The finish, typically at visible aspects of the furniture. 
/// 'Frame': The frame from which the object is constructed. 
/// 'Hardware': Finish hardware such as knobs or handles. 
/// 'Padding': Padding such as cushions. 
/// 'Panel': Panels such as glass. 
/// 
/// Composition Use Definition 
/// The IfcFurnitureType may be decomposed into components using IfcRelAggregates where RelatingObject refers to the enclosing IfcFurnitureType and RelatedObjects contains one or more components.  Components are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Composition use is defined for the following predefined types:
/// 
/// (All Types): May contain IfcSystemFurnitureElement components.  Modular furniture may be aggregated into components.
class IFC_PARSE_API IfcFurnitureType : public IfcFurnishingElementType {
public:
    /// A designation of where the assembly is intended to take place. A selection of alternatives s provided in an enumerated list.
    IfcAssemblyPlaceEnum::IfcAssemblyPlaceEnum AssemblyPlace() const;
    void setAssemblyPlace(IfcAssemblyPlaceEnum::IfcAssemblyPlaceEnum v);
    /// Whether the optional attribute PredefinedType is defined for this IfcFurnitureType
    bool hasPredefinedType() const;
    IfcFurnitureTypeEnum::IfcFurnitureTypeEnum PredefinedType() const;
    void setPredefinedType(IfcFurnitureTypeEnum::IfcFurnitureTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 11; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; case 10: return IfcUtil::Argument_ENUMERATION; } return IfcFurnishingElementType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcAssemblyPlaceEnum; case 10: return Type::IfcFurnitureTypeEnum; } return IfcFurnishingElementType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "AssemblyPlace"; case 10: return "PredefinedType"; } return IfcFurnishingElementType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcFurnitureType (IfcEntityInstanceData* e);
    IfcFurnitureType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcAssemblyPlaceEnum::IfcAssemblyPlaceEnum v10_AssemblyPlace, boost::optional< IfcFurnitureTypeEnum::IfcFurnitureTypeEnum > v11_PredefinedType);
    typedef IfcTemplatedEntityList< IfcFurnitureType > list;
};
/// Definition from IAI: An
///   IfcGeographicElementType is used to define an
///   element specification of a geographic element (i.e. the
///   specific product information, that is common to all
///   occurrences of that product type).ÿGeographic element types
///   include for different types of element that may be used to
///   represent information within a geographical landscape
///   external to a building. Within the world of geographic
///   information they are referred to generally as 'features'.ÿ
///   Geographic element types includes for many possibilities:
/// 
/// linear elements such as sections of a roadway
///   (including carriageway/pavement, verge, median, marker
///   line, kerb etc.), path, river, stream
/// 
/// connections and junctions including traffic
///   roundabouts, T junctions, 4 way junctions
/// 
/// point features such as street lighting, seating, bus
///   shelters, signage, trees
/// 
/// linear features such as layby's
/// 
/// area features such as ponds, lakes, woods and forests
/// 
/// The specification of the specific types are given by the
///   inherited attribute IfcElementType.ElementType given
///   as an IfcLabel.ÿ
/// 
/// NOTE ÿThis is due to the range of choices of
///   element type thyat are available and their expression in
///   different languages. It is not considered possible to
///   create a reasonably full list of types within an
///   enumeration. It is suggested that selection of the
///   relevant type be drawn from an available 'feature
///   catalog'.
/// 
/// HISTORYÿ New entity in
///   Release IFC2x Edition 4.
/// 
/// Feature Catalog Use Definition
/// 
/// Geographic element types are frequently identified in
///   feature catalogs that are produced for particular
///   purposes.ÿThe IfcGeographicElementType entity
///   enables the continued use of existing feature catalogs
///   through capture of their identity and attributes.
/// 
/// Information from feature catalogs might be captured in
///   various ways:
/// 
/// via property sets, some of which will be specifically
///   defined within the IFC property set catalog whilst others
///   will be created for local use; this is the form of capture
///   that is expected to be most widely used
/// 
/// through use of the IFC classification model whereby
///   features might be identified through a classification
///   notation and additional description; in which case, any
///   further attributes required would still need to be captured
///   in property sets.
class IFC_PARSE_API IfcGeographicElementType : public IfcElementType {
public:
    /// Predefined types to define the particular type of the geographic element. There may be property set definitions available for each predefined type.
    IfcGeographicElementTypeEnum::IfcGeographicElementTypeEnum PredefinedType() const;
    void setPredefinedType(IfcGeographicElementTypeEnum::IfcGeographicElementTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcElementType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcGeographicElementTypeEnum; } return IfcElementType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcElementType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcGeographicElementType (IfcEntityInstanceData* e);
    IfcGeographicElementType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcGeographicElementTypeEnum::IfcGeographicElementTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcGeographicElementType > list;
};
/// Definition from ISO/CD 10303-42:1992: A geometric curve set is a collection of two or three dimensional points and curves.
/// 
/// The IfcGeometricCurveSet is used for the exchange of shape representations consisting of (2D or 3D) points and curves only. 
/// 
/// NOTE: Corresponding ISO 10303-42 entity: geometric_set. Please refer to ISO/IS 10303-42:1994, p. 190 for the final definition of the formal standard.
/// 
/// HISTORY: New entity in IFC2x2.
class IFC_PARSE_API IfcGeometricCurveSet : public IfcGeometricSet {
public:
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcGeometricSet::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcGeometricSet::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcGeometricSet::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcGeometricCurveSet (IfcEntityInstanceData* e);
    IfcGeometricCurveSet (IfcEntityList::ptr v1_Elements);
    typedef IfcTemplatedEntityList< IfcGeometricCurveSet > list;
};
/// IfcIShapeProfileDef
/// defines a section profile that provides the defining parameters of a
/// symmetrical 'I' section to be used by the swept surface geometry or the
/// swept area solid. The I-shape profile has values for its overall depth,
/// width and its web and flange thickness. Additionally a fillet radius
/// may be given. It represents a I-section that is symmetrical about its
/// major and minor axes; and that has both top and bottom flanges being
/// equal and centred on the web.
/// 
/// IfcIShapeProfileDef can also be used to model I sections with
/// sloped or rounded flanges. The slope and radius cannot be expressed in
/// explicit attributes, but they may be retrieved by reference to an
/// external document or library.  See IfcProfileDef for guidance on
/// external references for profile definitions.
/// 
/// HISTORY  New entity in IFC2x.
/// 
/// IFC2x4 CHANGE  Type of FilletRadius relaxed to allow for zero radius.
/// 
/// Figure 318 illustrates parameters of the I-shape profile definition.
/// 
/// Position
/// 
/// The parameterized
/// profile defines its own position coordinate system.
/// The underlying
/// coordinate system is defined by the swept area solid
/// that uses the profile definition. It is the xy plane of: 
/// 
/// IfcSweptAreaSolid.Position
/// 
/// by using offsets of the position location, the parameterized profile
/// can be positioned centric (using x,y offsets = 0.), or at any position
/// relative to the profile. Explicit coordinate offsets are used to define
/// cardinal points (e.g. upper-left bound).
///   Parameter
/// 
/// The parameterized profile
/// is defined by a set of parameter attributes, see attribute definition
/// below.
/// 
/// Note:
/// The black coordinate axes show the
/// underlying coordinate system of the swept surface or swept area solid
/// 
/// Position
/// 
/// The profile is inserted into the underlying
/// coordinate system of the swept area solid by using the Position
/// attribute. In this example (cardinal point of lower left corner) the
/// attribute values of IfcAxis2Placement2D
/// are:
/// 
/// Location
/// = IfcCartesianPoint(,)
/// RefDirection = NIL (defaults to 1.,0.)
/// 
/// Parameter
/// If the FilletRadius
/// is given, it is equally applied to all four corners created by the web
/// and flanges.
/// 
/// Figure 318 — I-shape profile
class IFC_PARSE_API IfcIShapeProfileDef : public IfcParameterizedProfileDef {
public:
    /// Total extent of the width, defined parallel to the x axis of the position coordinate system.
    double OverallWidth() const;
    void setOverallWidth(double v);
    /// Total extent of the depth, defined parallel to the y axis of the position coordinate system.
    double OverallDepth() const;
    void setOverallDepth(double v);
    /// Thickness of the web of the I-shape. The web is centred on the x-axis and the y-axis of the position coordinate system.
    double WebThickness() const;
    void setWebThickness(double v);
    /// Flange thickness of the I-shape. Both, the upper and the lower flanges have the same thickness and they are centred on the y-axis of the position coordinate system.
    double FlangeThickness() const;
    void setFlangeThickness(double v);
    /// Whether the optional attribute FilletRadius is defined for this IfcIShapeProfileDef
    bool hasFilletRadius() const;
    /// The fillet between the web and the flange.
    double FilletRadius() const;
    void setFilletRadius(double v);
    /// Whether the optional attribute FlangeEdgeRadius is defined for this IfcIShapeProfileDef
    bool hasFlangeEdgeRadius() const;
    double FlangeEdgeRadius() const;
    void setFlangeEdgeRadius(double v);
    /// Whether the optional attribute FlangeSlope is defined for this IfcIShapeProfileDef
    bool hasFlangeSlope() const;
    double FlangeSlope() const;
    void setFlangeSlope(double v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 3: return IfcUtil::Argument_DOUBLE; case 4: return IfcUtil::Argument_DOUBLE; case 5: return IfcUtil::Argument_DOUBLE; case 6: return IfcUtil::Argument_DOUBLE; case 7: return IfcUtil::Argument_DOUBLE; case 8: return IfcUtil::Argument_DOUBLE; case 9: return IfcUtil::Argument_DOUBLE; } return IfcParameterizedProfileDef::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 3: return Type::IfcPositiveLengthMeasure; case 4: return Type::IfcPositiveLengthMeasure; case 5: return Type::IfcPositiveLengthMeasure; case 6: return Type::IfcPositiveLengthMeasure; case 7: return Type::IfcNonNegativeLengthMeasure; case 8: return Type::IfcNonNegativeLengthMeasure; case 9: return Type::IfcPlaneAngleMeasure; } return IfcParameterizedProfileDef::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 3: return "OverallWidth"; case 4: return "OverallDepth"; case 5: return "WebThickness"; case 6: return "FlangeThickness"; case 7: return "FilletRadius"; case 8: return "FlangeEdgeRadius"; case 9: return "FlangeSlope"; } return IfcParameterizedProfileDef::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcIShapeProfileDef (IfcEntityInstanceData* e);
    IfcIShapeProfileDef (IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< std::string > v2_ProfileName, IfcAxis2Placement2D* v3_Position, double v4_OverallWidth, double v5_OverallDepth, double v6_WebThickness, double v7_FlangeThickness, boost::optional< double > v8_FilletRadius, boost::optional< double > v9_FlangeEdgeRadius, boost::optional< double > v10_FlangeSlope);
    typedef IfcTemplatedEntityList< IfcIShapeProfileDef > list;
};

class IFC_PARSE_API IfcIndexedPolygonalFace : public IfcTessellatedItem {
public:
    std::vector< int > /*[3:?]*/ CoordIndex() const;
    void setCoordIndex(std::vector< int > /*[3:?]*/ v);
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_AGGREGATE_OF_INT; } return IfcTessellatedItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcPositiveInteger; } return IfcTessellatedItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "CoordIndex"; } return IfcTessellatedItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcPolygonalFaceSet >::ptr ToFaceSet() const; // INVERSE IfcPolygonalFaceSet::Faces
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcIndexedPolygonalFace (IfcEntityInstanceData* e);
    IfcIndexedPolygonalFace (std::vector< int > /*[3:?]*/ v1_CoordIndex);
    typedef IfcTemplatedEntityList< IfcIndexedPolygonalFace > list;
};

class IFC_PARSE_API IfcIndexedPolygonalFaceWithVoids : public IfcIndexedPolygonalFace {
public:
    std::vector< std::vector< int > > InnerCoordIndices() const;
    void setInnerCoordIndices(std::vector< std::vector< int > > v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 1: return IfcUtil::Argument_AGGREGATE_OF_AGGREGATE_OF_INT; } return IfcIndexedPolygonalFace::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 1: return Type::IfcPositiveInteger; } return IfcIndexedPolygonalFace::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 1: return "InnerCoordIndices"; } return IfcIndexedPolygonalFace::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcIndexedPolygonalFaceWithVoids (IfcEntityInstanceData* e);
    IfcIndexedPolygonalFaceWithVoids (std::vector< int > /*[3:?]*/ v1_CoordIndex, std::vector< std::vector< int > > v2_InnerCoordIndices);
    typedef IfcTemplatedEntityList< IfcIndexedPolygonalFaceWithVoids > list;
};
/// IfcLShapeProfileDef
/// defines a section profile that provides the defining parameters of an
/// L-shaped section (equilateral L profiles are also covered by this
/// entity) to be used by the swept area
/// solid. Its parameters and orientation relative to the position
/// coordinate system are according to the following illustration. The
/// shorter leg has the same direction as the positive Position.P[1]-axis, the longer
/// or equal leg the same as the positive Position.P[2]-axis. The centre of the
/// position coordinate system is in the profiles centre
/// of the bounding box.
/// 
/// HISTORY  New entity in IFC2x2.
/// 
/// IFC2x3 CHANGE  All profile origins are now in the center of the bounding box.
/// 
/// IFC2x4 CHANGE  Width changed from OPTIONAL to mandatory.  The previously informal rule that the longer leg is the Depth has been formalized.  Types of FilletRadius and EdgeRadius were relaxed to allow for zero values.  Trailing attributes CentreOfGravityInX and CentreOfGravityInY deleted, use respective properties in IfcExtendedProfileProperties instead.  WHERE rule which required Width <= Depth removed.
/// 
/// Figure 319 illustrates parameters of equal-sided and non-equal sided L-shaped section definitions.
/// 
/// Position 
/// The parameterized profile defines its own position coordinate system.
/// The underlying coordinate system is defined by the swept area solid
/// that uses the profile definition. It is the xy plane of:
/// 
/// IfcSweptAreaSolid.Position
/// 
/// by using offsets of the position location, the parameterized profile
/// can be positioned centric (using x,y offsets = 0.), or at any position
/// relative to the profile.
/// 
/// In the illustrated example, the 'CentreOfGravityInX' and 'CentreOfGravityInY' properties in IfcExtendedProfileProperties, if provided, are both negative.
/// 
/// Note:
/// The black coordinate axes show the
/// underlying coordinate system of the swept surface or swept area solid
/// 
/// Position 
/// The profile is inserted into the underlying
/// coordinate system of the swept area solid by using the Position
/// attribute. In this example (cardinal point of gravity) the
/// attribute values of IfcAxis2Placement2D
/// are:
/// 
/// Location = IfcCartesianPoint(
///               +|CentreOfGravityInX|,
///               +|CentreOfGravityInY|)
/// RefDirection = NIL (defaults to 1.,0.)
/// 
/// In the illustrated example, the x and y value of Position.Location, i.e. the measures |CentreOfGravityInX| and |CentreOfGravityInY| are both positive.  On the other hand, the properties named 'CentreOfGravityInX' and 'CentreOfGravityInY' in IfcExtendedProfileProperties, if provided, must both be set to 0 now because the centre of gravity of the resulting profile definition is located in the coordinate origin.
/// 
/// Figure 319 — L-shape profile
class IFC_PARSE_API IfcLShapeProfileDef : public IfcParameterizedProfileDef {
public:
    /// Leg length, see illustration above (= h). Same as the overall depth.
    double Depth() const;
    void setDepth(double v);
    /// Whether the optional attribute Width is defined for this IfcLShapeProfileDef
    bool hasWidth() const;
    /// Leg length, see illustration above (= b). Same as the overall width.
    double Width() const;
    void setWidth(double v);
    /// Constant wall thickness of profile, see illustration above (= ts).
    double Thickness() const;
    void setThickness(double v);
    /// Whether the optional attribute FilletRadius is defined for this IfcLShapeProfileDef
    bool hasFilletRadius() const;
    /// Fillet radius according the above illustration (= r1).
    double FilletRadius() const;
    void setFilletRadius(double v);
    /// Whether the optional attribute EdgeRadius is defined for this IfcLShapeProfileDef
    bool hasEdgeRadius() const;
    /// Edge radius according the above illustration (= r2).
    double EdgeRadius() const;
    void setEdgeRadius(double v);
    /// Whether the optional attribute LegSlope is defined for this IfcLShapeProfileDef
    bool hasLegSlope() const;
    /// Slope of the inner face of each leg of the profile.
    double LegSlope() const;
    void setLegSlope(double v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 3: return IfcUtil::Argument_DOUBLE; case 4: return IfcUtil::Argument_DOUBLE; case 5: return IfcUtil::Argument_DOUBLE; case 6: return IfcUtil::Argument_DOUBLE; case 7: return IfcUtil::Argument_DOUBLE; case 8: return IfcUtil::Argument_DOUBLE; } return IfcParameterizedProfileDef::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 3: return Type::IfcPositiveLengthMeasure; case 4: return Type::IfcPositiveLengthMeasure; case 5: return Type::IfcPositiveLengthMeasure; case 6: return Type::IfcNonNegativeLengthMeasure; case 7: return Type::IfcNonNegativeLengthMeasure; case 8: return Type::IfcPlaneAngleMeasure; } return IfcParameterizedProfileDef::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 3: return "Depth"; case 4: return "Width"; case 5: return "Thickness"; case 6: return "FilletRadius"; case 7: return "EdgeRadius"; case 8: return "LegSlope"; } return IfcParameterizedProfileDef::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcLShapeProfileDef (IfcEntityInstanceData* e);
    IfcLShapeProfileDef (IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< std::string > v2_ProfileName, IfcAxis2Placement2D* v3_Position, double v4_Depth, boost::optional< double > v5_Width, double v6_Thickness, boost::optional< double > v7_FilletRadius, boost::optional< double > v8_EdgeRadius, boost::optional< double > v9_LegSlope);
    typedef IfcTemplatedEntityList< IfcLShapeProfileDef > list;
};
/// The resource type IfcLaborResourceType defines commonly shared information for occurrences of labor resources. The set of shared information may include:
/// 
/// common productivities
/// common cost rates
/// common properties within shared property sets
/// 
/// It is used to define a labor resource specification (i.e. the specific resource information that is common to all occurrences of that resource). Resource types may be exchanged without being already assigned to occurrences.
/// 
/// Occurrences of the IfcLaborResourceType are represented by instances of IfcLaborResource.
/// 
/// HISTORY New entity in IFC2x4.
class IFC_PARSE_API IfcLaborResourceType : public IfcConstructionResourceType {
public:
    /// Defines types of labor resources.
    IfcLaborResourceTypeEnum::IfcLaborResourceTypeEnum PredefinedType() const;
    void setPredefinedType(IfcLaborResourceTypeEnum::IfcLaborResourceTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 12; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 11: return IfcUtil::Argument_ENUMERATION; } return IfcConstructionResourceType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 11: return Type::IfcLaborResourceTypeEnum; } return IfcConstructionResourceType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 11: return "PredefinedType"; } return IfcConstructionResourceType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcLaborResourceType (IfcEntityInstanceData* e);
    IfcLaborResourceType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< std::string > v7_Identification, boost::optional< std::string > v8_LongDescription, boost::optional< std::string > v9_ResourceType, boost::optional< IfcTemplatedEntityList< IfcAppliedValue >::ptr > v10_BaseCosts, IfcPhysicalQuantity* v11_BaseQuantity, IfcLaborResourceTypeEnum::IfcLaborResourceTypeEnum v12_PredefinedType);
    typedef IfcTemplatedEntityList< IfcLaborResourceType > list;
};
/// Definition from ISO/CD 10303-42:1992: A line is an unbounded curve with constant tangent direction. A line is defined by a point and a direction. The positive direction of the line is in the direction of the Dir vector. The line is parameterized as follows:
/// 
/// P = Pnt
///   V = Dir
///   λ(u) = P + uV
/// 
/// and the parametric range is:
/// 
/// ∞ < u < ∞
/// 
/// NOTE Corresponding ISO 10303 entity: line. Please refer to ISO/IS 10303-42:1994, p.37 for the final definition of the formal standard. The derived attribute Dim has been added at this level and was therefore demoted from the geometric_representation_item.
/// 
/// HISTORY New class in IFC Release 1.0
class IFC_PARSE_API IfcLine : public IfcCurve {
public:
    /// The location of the line.
    IfcCartesianPoint* Pnt() const;
    void setPnt(IfcCartesianPoint* v);
    /// The direction of the line, the magnitude and units of Dir affect the parameterization of the line.
    IfcVector* Dir() const;
    void setDir(IfcVector* v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcCurve::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcCartesianPoint; case 1: return Type::IfcVector; } return IfcCurve::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Pnt"; case 1: return "Dir"; } return IfcCurve::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcLine (IfcEntityInstanceData* e);
    IfcLine (IfcCartesianPoint* v1_Pnt, IfcVector* v2_Dir);
    typedef IfcTemplatedEntityList< IfcLine > list;
};
/// Definition from ISO/CD 10303-42:1992: A manifold solid
/// B-rep is a finite, arcwise connected volume bounded by one or
/// more surfaces, each of which is a connected, oriented, finite,
/// closed 2-manifold. There is no restriction on the genus of the
/// volume, nor on the number of voids within the volume.
/// The Boundary Representation (B-rep) of a manifold solid
/// utilizes a graph of edges and vertices embedded in a connected,
/// oriented, finite, closed two manifold surface. The embedded graph
/// divides the surface into arcwise connected areas known as faces.
/// The edges and vertices, therefore, form the boundaries of the
/// face and the domain of a face does not include its boundaries.
/// The embedded graph may be disconnected and may be a pseudo graph.
/// The graph is labeled; that is, each entity in the graph has a
/// unique identity. The geometric surface definition used to specify
/// the geometry of a face shall be 2-manifold embeddable in the
/// plane within the domain of the face. In other words, it shall be
/// connected, oriented, finite, non-self-intersecting, and of
/// surface genus 0.
/// Faces do not intersect except along their boundaries. Each
/// edge along the boundary of a face is shared by at most one other
/// face in the assemblage. The assemblage of edges in the B-rep do
/// not intersect except at their boundaries (i.e., vertices). The
/// geometry curve definition used to specify the geometry of an edge
/// shall be arcwise connected and shall not self intersect or
/// overlap within the domain of the edge. The geometry of an edge
/// shall be consistent with the geometry of the faces of which it
/// forms a partial bound. The geometry used to define a vertex shall
/// be consistent with the geometry of the faces and edges of which
/// it forms a partial bound.
/// A B-rep is represented by one or more closed shells which
/// shall be disjoint. One shell, the outer, shall completely enclose
/// all the other shells and no other shell may enclose a shell. The
/// facility to define a B-rep with one or more internal voids is
/// provided by a subtype. The following version of the Euler formula
/// shall be satisfied, where V, E, F, Ll and S are the
/// numbers of unique vertices, edges, faces, loop uses and shells in
/// the model and Gs is the sum of the genus of the
/// shells.
/// 
/// Instances of type IfcManifoldSolidBrep shall be of type
/// IfcFacetedBrep, using only IfcPolyLoop for the
/// bounds of IfcFaceBound, or of type IfcAdvancedBrep,
/// using only IfcAdvancedFace for the face geometry, and
/// IfcEdgeCurve for the edges.
/// 
/// NOTE: Corresponding ISO 10303-42 entity: manifold_solid_brep. Please refer to ISO/IS 10303-42:1994, p. 170 for the final definition of the formal standard. IfcManifoldSolidBrep is defined as ABSTRACT supertype to prevent it from direct instantiation.
/// 
/// HISTORY: New entity in IFC Release 1.0
/// 
/// Informal proposition:
/// 
/// The dimensionality of a manifold solid brep shall be 3.
/// The extent of the manifold solid brep shall be finite and
/// non-zero.
/// All elements of the manifold solid brep shall have defined
/// associated geometry.
/// The shell normals shall agree with the B-rep normal and point
/// away from the solid represented by the B-rep.
/// Each face shall be referenced only once by the shells of the
/// manifold solid brep.
/// The Euler equation shall be satisfied for the boundary
/// representation, where the genus term "shell term" us the sum of
/// the genus values for the shells of the brep.
class IFC_PARSE_API IfcManifoldSolidBrep : public IfcSolidModel {
public:
    /// A closed shell defining the exterior boundary of the solid. The shell normal shall point away from the interior of the solid.
    IfcClosedShell* Outer() const;
    void setOuter(IfcClosedShell* v);
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcSolidModel::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcClosedShell; } return IfcSolidModel::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Outer"; } return IfcSolidModel::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcManifoldSolidBrep (IfcEntityInstanceData* e);
    IfcManifoldSolidBrep (IfcClosedShell* v1_Outer);
    typedef IfcTemplatedEntityList< IfcManifoldSolidBrep > list;
};
/// An IfcObject is the
/// generalization of any semantically treated thing or process.
/// Objects are things as they appear - i.e. occurrences.
/// NOTE Examples of IfcObject include
/// physically tangible items, such as wall, beam or covering,
/// physically existing items, such as spaces, or conceptual items,
/// such as grids or virtual boundaries. It also stands for
/// processes, such as work tasks, for controls, such as cost items,
/// for actors, such as persons involved in the design process,
/// etc.
/// Objects can be named, using the inherited Name
/// attribute, which should be a user recognizable label for the
/// object occurrance. Further explanations to the object can be
/// given using the inherited Description attribute. The
/// ObjectType attribute is used:
/// 
/// to store the user defined value for all subtypes of
/// IfcObject, where a PredefinedType attribute is
/// given, and its value is set to USERDEFINED.
/// to provide a type information (could be seen as a very
/// lightweight classifier) of the subtype of IfcObject, if no
/// PredefinedType attribute is given. This is often the case,
/// if no comprehensive list of predefined types is available.
/// 
/// Objects are independent pieces of information that might
/// contain or reference other pieces of information. There are
/// several relationships in which objects can be involved:
/// 
/// Association to external/internal resource information
/// - an association relationship that refers to external/internal
/// sources of information. See supertype IfcObjectDefinition
/// for more information.
/// Assignment of other objects - an assignment
/// relationship that refers to other types of objects. See supertype
/// IfcObjectDefinition for more information.
/// Aggregation of other objects - an aggregation
/// relationship that establishes a whole/part relation. Objects can
/// either be a whole, or a part, or both. See supertype
/// IfcObjectDefinition for more information.
/// 
/// Assignment of a type : IsTypedBy - a definition
/// relationship IfcRelDefinesByType that uses a type
/// definition to define the common characteristics of this
/// occurrences, potentially including the common shape
/// representation and common properties of all object occurrences
/// assigned to this type. It is a specific - occurrence relationship
/// with implied dependencies (as the occurrence properties depend on
/// the properties of the type, but may override them).
/// 
/// NOTE See IfcRelDefinesByType for an
/// explanatory figure. Also see for how to override type properties
/// by occurrence properties
/// 
/// Assignment of a partial type : IsDeclaredBy,
/// Declares - a definition relationship
/// IfcRelDefinesByObject that uses a component of a type
/// definition (a part of a type, called the "declaring part") to
/// define a component of an occurence (part of occurrence, called
/// the "reflected part"). This is also refered to as a "deep copy".
/// The common characteristics of all parts in the occurrence are
/// defined by parts in the type. It is a specific - occurrence
/// relationship with implied dependencies (as the occurrence
/// properties depend on the properties of the type, but may override
/// them).
/// 
/// NOTE See IfcRelDefinesByObject for an
/// explanatory figure.
/// 
/// Assignment of property sets : IsDefinedBy - a
/// definition relationship IfcRelDefinesByProperties that
/// assignes property set definitions to the object occurrence.
/// 
/// HISTORY New Entity in IFC Release 1.0
/// 
/// IFC2x4 CHANGE The inverse relationships Declares, IsDeclaredBy, and IsTypedBy have been added, types are not longer included in the IsDefinesBy relationship. IfcProject has been promoted to be a subtype of IfcObjectDefinition -> IfcContext.
/// 
/// Informal Proposition
/// 
/// A partial type assignment, i.e. the inverse attribute
/// IsDeclaredBy, or Declares shall only be used, if
/// the object is part of a decomposition, i.e. if either
/// IsDecomposedBy, or Decomposes is exerted.
class IFC_PARSE_API IfcObject : public IfcObjectDefinition {
public:
    /// Whether the optional attribute ObjectType is defined for this IfcObject
    bool hasObjectType() const;
    /// The type denotes a particular type that indicates the object further. The use has to be established at the level of instantiable subtypes. In particular it holds the user defined type, if the enumeration of the attribute PredefinedType is set to USERDEFINED.
    std::string ObjectType() const;
    void setObjectType(std::string v);
    virtual unsigned int getArgumentCount() const { return 5; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 4: return IfcUtil::Argument_STRING; } return IfcObjectDefinition::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 4: return Type::IfcLabel; } return IfcObjectDefinition::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 4: return "ObjectType"; } return IfcObjectDefinition::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcRelDefinesByObject >::ptr IsDeclaredBy() const; // INVERSE IfcRelDefinesByObject::RelatedObjects
    IfcTemplatedEntityList< IfcRelDefinesByObject >::ptr Declares() const; // INVERSE IfcRelDefinesByObject::RelatingObject
    IfcTemplatedEntityList< IfcRelDefinesByType >::ptr IsTypedBy() const; // INVERSE IfcRelDefinesByType::RelatedObjects
    IfcTemplatedEntityList< IfcRelDefinesByProperties >::ptr IsDefinedBy() const; // INVERSE IfcRelDefinesByProperties::RelatedObjects
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcObject (IfcEntityInstanceData* e);
    IfcObject (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType);
    typedef IfcTemplatedEntityList< IfcObject > list;
};
/// Definition from ISO/CD 10303-42:1992: An offset curve 2d (IfcOffsetCurve2d) is a curve at a constant distance from a basis curve in two-dimensional space. This entity defines a simple plane-offset curve by offsetting by distance along the normal to basis curve in the plane of basis curve. The underlying curve shall have a well-defined tangent direction at every point. In the case of a composite curve, the transition code between each segment shall be cont same gradient or cont same gradient same curvature. 
/// 
/// NOTE: The offset curve 2d may differ in nature from the basis curve; the offset of a non self- intersecting curve can be self-intersecting. Care should be taken to ensure that the offset to a continuous curve does not become discontinuous.
/// 
/// The offset curve 2d takes its parameterization from the basis curve. The offset curve 2d is parameterized as  
/// 
/// where T is the unit tangent vector to the basis curve C(u) at parameter value u, and d is distance. The underlying curve shall be two-dimensional. 
/// 
/// NOTE Corresponding ISO 10303 entity: offset_curve_2d, Please refer to ISO/IS 10303-42:1994, p.65 for the final definition of the formal standard.
/// 
/// HISTORY New entity in IFC Release 2.x
class IFC_PARSE_API IfcOffsetCurve2D : public IfcCurve {
public:
    /// The curve that is being offset.
    IfcCurve* BasisCurve() const;
    void setBasisCurve(IfcCurve* v);
    /// The distance of the offset curve from the basis curve. distance may be positive, negative or zero. A positive value of distance defines an offset in the direction which is normal to the curve in the sense of an anti-clockwise rotation through 90 degrees from the tangent vector T at the given point. (This is in the direction of orthogonal complement(T).)
    double Distance() const;
    void setDistance(double v);
    /// An indication of whether the offset curve self-intersects; this is for information only.
    bool SelfIntersect() const;
    void setSelfIntersect(bool v);
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_DOUBLE; case 2: return IfcUtil::Argument_BOOL; } return IfcCurve::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcCurve; case 1: return Type::IfcLengthMeasure; case 2: return Type::IfcLogical; } return IfcCurve::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "BasisCurve"; case 1: return "Distance"; case 2: return "SelfIntersect"; } return IfcCurve::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcOffsetCurve2D (IfcEntityInstanceData* e);
    IfcOffsetCurve2D (IfcCurve* v1_BasisCurve, double v2_Distance, bool v3_SelfIntersect);
    typedef IfcTemplatedEntityList< IfcOffsetCurve2D > list;
};
/// Definition from ISO/CD 10303-42:1992: An offset curve 3d is a curve at a constant distance from a basis curve in three-dimensional space. The underlying curve shall have a well-defined tangent direction at every point. In the case of a composite curve the transition code between each segment shall be cont same gradient or cont same gradient same curvature. The offset curve at any point (parameter) on the basis curve is in the direction V x T where V is the fixed reference direction and T is the unit tangent to the basis curve. For the offset direction to be well defined, T shall not at any point of the curve be in the same, or opposite, direction as V. 
/// 
/// NOTE: The offset curve 3d may differ in nature from the basis curve; the offset of a non self- intersecting curve can be self-intersecting. Care should be taken to ensure that the offset to a continuous curve does not become discontinuous.
/// 
/// The offset curve 3d takes its parameterization from the basis curve. The offset curve 3d is parameterized as  
/// 
/// where T is the unit tangent vector to the basis curve C(u) at parameter value u, and d is distance. The underlying curve shall be three-dimensional.
/// 
/// NOTE Corresponding ISO 10303 entity: offset_curve_3d, Please refer to ISO/IS 10303-42:1994, p.66 for the final definition of the formal standard.
/// 
/// HISTORY New entity in IFC Release 2.x
/// 
/// Informal propositions: 
/// 
/// At no point on the curve shall ref direction be parallel, or opposite to, the direction of the tangent vector.
class IFC_PARSE_API IfcOffsetCurve3D : public IfcCurve {
public:
    /// The curve that is being offset.
    IfcCurve* BasisCurve() const;
    void setBasisCurve(IfcCurve* v);
    /// The distance of the offset curve from the basis curve. The distance may be positive, negative or zero.
    double Distance() const;
    void setDistance(double v);
    /// An indication of whether the offset curve self-intersects, this is for information only.
    bool SelfIntersect() const;
    void setSelfIntersect(bool v);
    /// The direction used to define the direction of the offset curve 3d from the basis curve.
    IfcDirection* RefDirection() const;
    void setRefDirection(IfcDirection* v);
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_DOUBLE; case 2: return IfcUtil::Argument_BOOL; case 3: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcCurve::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcCurve; case 1: return Type::IfcLengthMeasure; case 2: return Type::IfcLogical; case 3: return Type::IfcDirection; } return IfcCurve::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "BasisCurve"; case 1: return "Distance"; case 2: return "SelfIntersect"; case 3: return "RefDirection"; } return IfcCurve::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcOffsetCurve3D (IfcEntityInstanceData* e);
    IfcOffsetCurve3D (IfcCurve* v1_BasisCurve, double v2_Distance, bool v3_SelfIntersect, IfcDirection* v4_RefDirection);
    typedef IfcTemplatedEntityList< IfcOffsetCurve3D > list;
};
/// Definition from ISO/CD 10303-42:1992: A pcurve is a curve which lies on the basis of a surface and is defined in the parameter space of that surface. The basis curve is a curve defined in the two-dimensional parametric space of a reference basis surface. Although it is defined by a curve in two dimensional space, the variables involved are u and v, which occur in the parametric representation of the referenced surface, rather than the x, y, Cartesian coordinates.
/// 
/// The basis curve is only defined within the parametric range of the surface.
/// 
/// NOTE Corresponding ISO 10303 entity: pcurve. Please refer to ISO/IS 10303-42:1994, p.59 for the final definition of the formal standard. The definition of IfcPCurve derivates from pcurve. The following changes have been made: The BasisCurve replaces the definition of reference_to_curve since there is no requirement of having same dimensionality within the representation context.
/// 
/// HISTORY New class in IFC2x4.
class IFC_PARSE_API IfcPcurve : public IfcCurve {
public:
    IfcSurface* BasisSurface() const;
    void setBasisSurface(IfcSurface* v);
    IfcCurve* ReferenceCurve() const;
    void setReferenceCurve(IfcCurve* v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcCurve::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcSurface; case 1: return Type::IfcCurve; } return IfcCurve::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "BasisSurface"; case 1: return "ReferenceCurve"; } return IfcCurve::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPcurve (IfcEntityInstanceData* e);
    IfcPcurve (IfcSurface* v1_BasisSurface, IfcCurve* v2_ReferenceCurve);
    typedef IfcTemplatedEntityList< IfcPcurve > list;
};
/// Definition from ISO/CD 10303-46:1992: A planar box specifies an arbitrary rectangular box and its location in a two dimensional Cartesian coordinate system.
/// 
/// NOTE  Corresponding ISO 10303 name: planar_box. Please refer to
/// ISO/IS 10303-46:1994, p. 141 for the final definition of the formal standard.
/// 
/// HISTORY  New entity in IFC2x2.
class IFC_PARSE_API IfcPlanarBox : public IfcPlanarExtent {
public:
    /// The IfcAxis2Placement positions a local coordinate system for the definition of the rectangle. The origin of this local coordinate system serves as the lower left corner of the rectangular box.
    ///   NOTE  In case of a 3D placement by IfcAxisPlacement3D the IfcPlanarBox is defined within the xy plane of the definition coordinate system.
    IfcAxis2Placement* Placement() const;
    void setPlacement(IfcAxis2Placement* v);
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 2: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcPlanarExtent::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 2: return Type::IfcAxis2Placement; } return IfcPlanarExtent::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 2: return "Placement"; } return IfcPlanarExtent::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPlanarBox (IfcEntityInstanceData* e);
    IfcPlanarBox (double v1_SizeInX, double v2_SizeInY, IfcAxis2Placement* v3_Placement);
    typedef IfcTemplatedEntityList< IfcPlanarBox > list;
};
/// Definition from ISO/CD 10303-42:1992: A plane is an unbounded surface with a constant normal. A plane is defined by a point on the plane and the normal direction to the plane. The data is to be interpreted as follows:
/// 
/// C = Position.Location
/// x = Position.P[1]
/// y = Position.P[2]
/// z = Position.P[3] => normal to plane
/// 
/// and the surface is parameterized as:
/// 
/// where the parametric range is -∞ < u,v <
/// ∞. In the above parameterization the length unit for the
/// unit vectors x and y is derived from the context of
/// the plane.
/// 
/// The planar surface is an unbounded surface in the direction of x and y. Bounded planar surfaces are defined by using a subtype of IfcBoundedSurface with BasisSurface being a plane.
/// 
/// NOTE A rectangular bounded planar surface can
/// be defined by an IfcRectangularTrimmedSurface with
/// BasisSurface being the plane and U1 = left bound in
/// x, U2 = right bound in x, V1 = lower
/// bound in y, V2 = upper bound in y if viewed
/// into the direction of the negative normal. (assuming the
/// Usense and Vsense agree to the sense of the basis
/// surface).
/// The inherited attributes are interpreted as
/// 
/// SELF\IfcElementarySurface.Position defines the
/// location and orientation of the planar surface.
/// SELF\IfcElementarySurface.Position.Location defines a
/// point on the planar surface.
/// SELF\IfcElementarySurface.Position.P[3] defines the
/// normal of the planar surface.
/// 
/// NOTE Corresponding ISO 10303 entity: plane. Please refer to ISO/IS 10303-42:1994, p.69 for the final definition of the formal standard.
/// 
/// HISTORY New class in IFC Release 1.5
class IFC_PARSE_API IfcPlane : public IfcElementarySurface {
public:
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcElementarySurface::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcElementarySurface::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcElementarySurface::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPlane (IfcEntityInstanceData* e);
    IfcPlane (IfcAxis2Placement3D* v1_Position);
    typedef IfcTemplatedEntityList< IfcPlane > list;
};
/// The pre defined colour determines those qualified names which can be used to identify a colour that is in scope of the current data exchange specification (in contrary to colour specification which defines the colour directly by its colour components).
/// 
/// NOTE  Corresponding ISO 10303 name: pre_defined_colour. It has been made into an abstract entity in IFC. Please refer to ISO/IS 10303-46:1994, p. 141 for the final definition of the formal standard.
/// 
/// HISTORY  New entity in IFC2x2.
class IFC_PARSE_API IfcPreDefinedColour : public IfcPreDefinedItem {
public:
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcPreDefinedItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcPreDefinedItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcPreDefinedItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPreDefinedColour (IfcEntityInstanceData* e);
    IfcPreDefinedColour (std::string v1_Name);
    typedef IfcTemplatedEntityList< IfcPreDefinedColour > list;
};
/// Definition from ISO/CD 10303-46:1992: The predefined curve font type is an abstract supertype provided to define an application specific curve font. The name label shall be constrained in the application protocol to values that are given specific meaning for curve fonts in that application protocol.
/// 
/// NOTE: The IfcPreDefinedCurveFont is an abstract entity, subtypes of it provide the predefined curve font by agreement of the values of the inherited Name attribute. Currently the only subtype provided is IfcDraughtingPreDefinedCurveFont.
/// 
/// NOTE: Corresponding ISO 10303 name: pre_defined_curve_font. Please refer to ISO/IS 10303-46:1994, p. 103 for the final definition of the formal standard.
/// 
/// HISTORY: New entity in IFC2x2.
class IFC_PARSE_API IfcPreDefinedCurveFont : public IfcPreDefinedItem {
public:
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcPreDefinedItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcPreDefinedItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcPreDefinedItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPreDefinedCurveFont (IfcEntityInstanceData* e);
    IfcPreDefinedCurveFont (std::string v1_Name);
    typedef IfcTemplatedEntityList< IfcPreDefinedCurveFont > list;
};
/// IfcPreDefinedPropertySet
/// is a generalization of all statically defined property sets that
/// are assigned to an object or type object. The statically or
/// pre-defined property sets are entities with a fixed list of
/// attributes having particular defined data types.
/// 
/// IfcPreDefinedPropertySet's can be assigned to objects
/// and object types but do not have a defining property set
/// template.
/// 
/// HISTORY New Entity in IFC2x4
/// 
/// Relationship use definition
/// Property sets are related to other objects by using the
/// relationship object that refers to the corresponding object:
/// 
/// Occurrence Object: IfcRelDefinesByProperties
/// using the inverse attribute DefinesOccurrence.
/// Type Object: using a direct link by inverse attribute
/// DefinesType.
class IFC_PARSE_API IfcPreDefinedPropertySet : public IfcPropertySetDefinition {
public:
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcPropertySetDefinition::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcPropertySetDefinition::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcPropertySetDefinition::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPreDefinedPropertySet (IfcEntityInstanceData* e);
    IfcPreDefinedPropertySet (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description);
    typedef IfcTemplatedEntityList< IfcPreDefinedPropertySet > list;
};
/// An IfcProcedureType defines a particular type of procedure that may be specified.
/// 
/// HISTORY  New entity in IFC2x4
/// 
/// An IfcProcedureType provides for all forms of types of procedure that may be specified.
/// 
/// Usage of IfcProcedureType defines the parameters for
///   one or more occurrences of IfcProcedure. Parameters
///   may be specified through property sets that may be
///   enumerated in the IfcProcedureTypeEnum data type or
///   through explict attributes of IfcProcedure. Procedure occurrences
///   (IfcProcedure entities) are linked to the procedure type
///   through the IfcRelDefinesByType relationship.
class IFC_PARSE_API IfcProcedureType : public IfcTypeProcess {
public:
    /// Identifies the predefined types of a procedure from which 
    ///   the type required may be set.
    IfcProcedureTypeEnum::IfcProcedureTypeEnum PredefinedType() const;
    void setPredefinedType(IfcProcedureTypeEnum::IfcProcedureTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcTypeProcess::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcProcedureTypeEnum; } return IfcTypeProcess::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcTypeProcess::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcProcedureType (IfcEntityInstanceData* e);
    IfcProcedureType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< std::string > v7_Identification, boost::optional< std::string > v8_LongDescription, boost::optional< std::string > v9_ProcessType, IfcProcedureTypeEnum::IfcProcedureTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcProcedureType > list;
};
/// Definition from ISO9000: A process is a set of
/// activities that are interrelated or that interact with one
/// another. Processes use resources to transform inputs into
/// outputs. Processes are interconnected because the output from one
/// process becomes the input for another process. In effect,
/// processes are "glued" together by means of such input output
/// relationships.
/// 
/// IfcProcess is defined as
/// one individual activity or event, that is ordered in time, that
/// has sequence relationships with other processes, which transforms
/// input in output, and may connect to other other processes through
/// input output relationships. An IfcProcess can be an
/// activity (or task), or an event. It takes usually place in
/// building construction with the intent of designing, costing,
/// acquiring, constructing, or maintaining products or other and
/// similar tasks or procedures.
/// 
/// Figure 2 — Process relationships and the ICON process diagram.
/// 
/// HISTORY New entity in IFC Release 1.0.
/// 
/// IFC2x PLATFORM CHANGE The attribute Productivity has been removed.
/// 
/// IFC2x4 CHANGE The attribute Identification has been promoted from subtypes IfcTask and others.
/// 
/// Relationship use definition
/// Process information relates to other objects by establishing the following relationships:
/// 
/// Nesting of processes : IfcRelNests - A process can contain sub processes and thereby be nested.
/// Sequencing of processes : IfcRelSequence - Processes can be placed in sequence (including overlapping for parallel tasks), and have predecessors and successors.
/// Assigning process to schedules : IfcRelAssignsToControl - Activities such as tasks, and predominately summary tasks, are assigned to a work schedule.
/// Having a product assigned to the process as input :
/// IfcRelAssignsToProcess - Products can be assigned as input to a process, such as for construction process planning.
/// Having a product assigned to the process as output :
/// IfcRelAssignsToProduct - Products can be assigned as output to a process, such as for construction process planning.
/// Having a control assigned to the process as process control : IfcRelAssignsToProcess - Items that act as a
/// control onto the process can be assigned to a process, such as for cost management (a cost item assigned to a work task).
/// Having a resource assigned to the process as consumed by the process : IfcRelAssignsToProcess - Items that act
/// as a mechanism to a process, such as labor, material and equipment in cost calculations.
class IFC_PARSE_API IfcProcess : public IfcObject {
public:
    /// Whether the optional attribute Identification is defined for this IfcProcess
    bool hasIdentification() const;
    /// An identifying designation given to a process or activity.
    ///   It is the identifier at the occurrence level. 
    /// 
    /// IFC2x4 CHANGE  Attribute promoted from subtypes.
    std::string Identification() const;
    void setIdentification(std::string v);
    /// Whether the optional attribute LongDescription is defined for this IfcProcess
    bool hasLongDescription() const;
    /// An extended description or narrative that may be provided.
    /// 
    /// IFC2x4 CHANGE  New attribute.
    std::string LongDescription() const;
    void setLongDescription(std::string v);
    virtual unsigned int getArgumentCount() const { return 7; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 5: return IfcUtil::Argument_STRING; case 6: return IfcUtil::Argument_STRING; } return IfcObject::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 5: return Type::IfcIdentifier; case 6: return Type::IfcText; } return IfcObject::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 5: return "Identification"; case 6: return "LongDescription"; } return IfcObject::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcRelSequence >::ptr IsPredecessorTo() const; // INVERSE IfcRelSequence::RelatingProcess
    IfcTemplatedEntityList< IfcRelSequence >::ptr IsSuccessorFrom() const; // INVERSE IfcRelSequence::RelatedProcess
    IfcTemplatedEntityList< IfcRelAssignsToProcess >::ptr OperatesOn() const; // INVERSE IfcRelAssignsToProcess::RelatingProcess
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcProcess (IfcEntityInstanceData* e);
    IfcProcess (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, boost::optional< std::string > v6_Identification, boost::optional< std::string > v7_LongDescription);
    typedef IfcTemplatedEntityList< IfcProcess > list;
};
/// Any object that relates to a
/// geometric or spatial context. Subtypes of IfcProduct
/// usually hold a shape representation and a object placement within
/// the project structure.
/// This includes manufactured, supplied or created objects
/// (referred to as elements) for incorporation into an AEC/FM
/// project. This also includes objects that are created indirectly
/// by other products, as spaces are defined by bounding elements.
/// Products can be designated for permanent use or temporary use, an
/// example for the latter is formwork. Products are defined by their
/// properties and representations.
/// In addition to physical products (covered by the subtype
/// IfcElement) and spatial items (covered by the subtype
/// IfcSpatialElement) the IfcProduct also includes
/// non-physical items, that relate to a geometric or spatial
/// contexts, such as grid, port, annotation, structural actions,
/// etc.
/// The inherited ObjectType attribute can be used to
/// designate a particular type of the product instance. If subtypes
/// of IfcProduct have a PredefinedType defined, the
/// ObjectType is used to provide the user defined, particular
/// type of the product instance, if the PredefinedType is set
/// to USERDEFINED.
/// 
/// HISTORY New Entity in IFC Release 1.0
/// 
/// Relationship use definition
/// On a generic level products can be assigned to processes,
/// controls, resources, project by using the relationship objects
/// that refer to the corresponding object:
/// 
/// Having a control applied: assigned using
/// IfcRelAssignsToControl linking the IfcProduct to an
/// IfcControl
/// 
/// An example of this
/// relationship is the assignment of a performance history to a
/// distribution element.
/// 
/// Being assigned to a process: assigned using
/// IfcRelAssignsToProcess linking the IfcProduct to an
/// IfcProcess
/// 
/// An example of this
/// relationship is the assignment of products like wall, slab,
/// column to a contruction task for construction
/// planning.
/// 
/// Being assigned to a resource: assigned using
/// IfcRelAssignsToResource linking the IfcProduct to
/// an IfcResource
/// 
/// An example of this
/// relationship is the assignment of products to a construction
/// resource that consumes the product.
/// 
/// Type use definition
/// Any instance of IfcProduct defines a particular
/// occurrence of a product, the common type information, that
/// relates to many similar (or identical) occurrences of
/// IfcProduct, is handled by the IfcTypeProduct (and
/// its subtypes), assigned to one or many occurrences of
/// IfcProduct by using the objectified relationship
/// IfcRelDefinesByType. The IfcTypeProduct may
/// provide, in addition to common properties, also a common
/// geometric representation for all occurrences.
/// See IfcTypeProduct for how to use a
/// common geometric representation and IfcRelDefinesByType
/// for using and overriding common properties.
/// 
/// Representation use definition
/// An IfcProduct occurs at a specific location in space if
/// it has a geometric representation assigned. It can be placed
/// relatively to other products, but ultimately relative to the
/// world coordinate system defined for this project. The
/// ObjectPlacement attribute establishes the coordinate
/// system in which all points and directions used by the geometric
/// representation items under Representation are
/// founded. The placement can either be:
/// 
/// a relative placement: by IfcLocalPlacement with
/// PlacementRelTo pointing to a parent placement
/// an absolute placement: by IfcLocalPlacement
/// with PlacementRelTo being NIL
/// a placement relative to a grid: by
/// IfcGridPlacement
/// 
/// The Representation is provided by an
/// IfcProductDefinitionShape being either a geometric shape
/// representation, or a topology representation (with or without
/// underlying geometry of the topological items).
class IFC_PARSE_API IfcProduct : public IfcObject {
public:
    /// Whether the optional attribute ObjectPlacement is defined for this IfcProduct
    bool hasObjectPlacement() const;
    /// Placement of the product in space, the placement can either be absolute (relative to the world coordinate system), relative (relative to the object placement of another product), or constraint (e.g. relative to grid axes). It is determined by the various subtypes of IfcObjectPlacement, which includes the axis placement information to determine the  transformation for the object coordinate system.
    IfcObjectPlacement* ObjectPlacement() const;
    void setObjectPlacement(IfcObjectPlacement* v);
    /// Whether the optional attribute Representation is defined for this IfcProduct
    bool hasRepresentation() const;
    /// Reference to the representations of the product, being either a representation (IfcProductRepresentation) or as a special case a shape representations (IfcProductDefinitionShape). The product definition shape provides for multiple geometric representations of the shape property of the object within the same object coordinate system, defined by the object placement.
    IfcProductRepresentation* Representation() const;
    void setRepresentation(IfcProductRepresentation* v);
    virtual unsigned int getArgumentCount() const { return 7; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 5: return IfcUtil::Argument_ENTITY_INSTANCE; case 6: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcObject::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 5: return Type::IfcObjectPlacement; case 6: return Type::IfcProductRepresentation; } return IfcObject::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 5: return "ObjectPlacement"; case 6: return "Representation"; } return IfcObject::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcRelAssignsToProduct >::ptr ReferencedBy() const; // INVERSE IfcRelAssignsToProduct::RelatingProduct
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcProduct (IfcEntityInstanceData* e);
    IfcProduct (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation);
    typedef IfcTemplatedEntityList< IfcProduct > list;
};
/// IfcProject indicates the undertaking of some design, engineering, construction, or
/// maintenance activities leading towards a product. The project establishes the context for information to be exchanged or shared, and it may represent a construction project but does not have to.  The IfcProject's main purpose in an exchange structure is to provide the root instance and the context for all other information items included.
/// The context provided by the IfcProject includes:
/// 
/// the default units
/// the geometric representation context for exchange structures including shape representations
/// 
/// the world coordinate system
/// the coordinate space dimension
/// the precision used within the geometric representations, and
/// optionally the indication of the true north relative to the world coordinate system
/// 
/// HISTORY  New Entity in IFC Release 1.0
/// 
/// IFC2x4 CHANGE  The attributes RepresentationContexts and UnitsInContext are made optional and are promoted to supertype IfcContext.
/// 
/// Relationship use definition
/// The IfcProject is used to reference the root of the spatial structure of a building (that serves as the primary project breakdown and is required to be hierarchical). The spatial structure elements are linked together, and to the IfcProject, by using the objectified relationship IfcRelAggregates. The IfcProject references them by its inverse relationship:
/// 
/// IfcProject.Decomposes -- it shall be NIL, i.e. the
/// IfcProject shall not be decomposed into any parts.
/// IfcProject.IsDecomposedBy -- referencing
/// (IfcSite || IfcBuilding) by
/// IfcRelAggregates.RelatingObject. The IfcSite or
/// IfcBuilding referenced shall be the root of the spatial
/// structure.
/// 
/// The IfcProject is also the context for other information about the construction project such as a work plan. Non-product structures are assigned by their first level object to IfcProject using the IfcRelDeclares relationship.
/// 
/// The IfcProject provides the context for spatial elements and the associated products, and for work plans (or other non-product based) descriptions of the construction project. It is handled by two distinct relationship objects as shown in Figure 3.
/// NOTE   The spatial structure and the schedule structure can be decomposed. For example the IfcBuilding can be decomposed into IfcBuildingStorey's, and the IfcWorkPlan can be decomposed into IfcWorkSchedule's.
/// NOTE   The products and tasks can be decomposed further. For example the IfcCurtainWall can be decomposed into IfcMember and IfcPlate, the IfcTask can be decomposed into other IfcTask's.
/// NOTE   The products and tasks can have direct linking relationships. For example the IfcCurtainWall can be assigned to a IfcTask as an input or output for a construction schedule.
/// NOTE   The anomaly to use the composition structure through IfcRelAggregates for assigning the uppermost spatial container to IfcProject is due to upward compatibility reasons with earlier releases of this standard.
/// 
/// Figure 3 — Project spatial and work plan structure
/// 
/// As shown in Figure 4, the IfcProject provides the context for project libraries that in return provide a context to the library items assigned to it. Product types are an example for items that can be included in a project library.
/// 
/// Figure 4 — Project spatial structure, products and product type library
/// 
/// Informal propositions:
/// 
/// There shall only be one project within the exchange context. This is enforced by the global rule IfcSingleProjectInstance.
class IFC_PARSE_API IfcProject : public IfcContext {
public:
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcContext::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcContext::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcContext::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcProject (IfcEntityInstanceData* e);
    IfcProject (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, boost::optional< std::string > v6_LongName, boost::optional< std::string > v7_Phase, boost::optional< IfcTemplatedEntityList< IfcRepresentationContext >::ptr > v8_RepresentationContexts, IfcUnitAssignment* v9_UnitsInContext);
    typedef IfcTemplatedEntityList< IfcProject > list;
};
/// IfcProjectLibrary collects all library elements that are included within a referenced project data set.
/// 
/// Examples for project libraries include:
/// 
/// type libraries (also called style or family libraries): a collection of subtypes of IfcTypeObject
/// property definition libraries: a collections of IfcPropertySetTemplate or IfcPropertyTemplates
/// 
/// HISTORY New entity in IFC2x4.
/// 
/// Attribute use definition
/// 
/// SELF\IfcContext.RepresentationContext
/// Context of the representations used within the project library. When the project library includes shape representations for its library type objects, one or several geometric representation contexts need to be included that define the coordinate system, the coordinate space dimensions, and/or the precision factor.
/// 
/// SELF\IfcContext.UnitsInContext
/// Units locally assigned to measure types used within the context of this project library.
/// 
/// NOTE  It is generally discouraged to use a different length measure and plane angle measure in an included project library compared with the project itself. It may lead to unexpected results for the shape representation of items included in the project library.
/// 
/// Relationship use definition
/// 
/// Instances of IfcProjectLibrary are assigned to the project context using the IfcRelDeclares relationship and accessible through the inverse attribute HasContext. Individual object types and property (set) templates are assigned to the IfcProjectLibrary using the IfcRelDeclares relationship and are accessible through the inverse attribute Declares.
/// 
/// An IfcProjectLibrary may be decomposed into sub libraries using the relationship IfcRelNests. Sub libraries are accessed by the IfcProjectLibrary through the inverse attribute IsNestedBy.
class IFC_PARSE_API IfcProjectLibrary : public IfcContext {
public:
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcContext::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcContext::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcContext::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcProjectLibrary (IfcEntityInstanceData* e);
    IfcProjectLibrary (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, boost::optional< std::string > v6_LongName, boost::optional< std::string > v7_Phase, boost::optional< IfcTemplatedEntityList< IfcRepresentationContext >::ptr > v8_RepresentationContexts, IfcUnitAssignment* v9_UnitsInContext);
    typedef IfcTemplatedEntityList< IfcProjectLibrary > list;
};
/// A property with a bounded
///   value, IfcPropertyBoundedValue, defines a property
///   object which has a maximum of two (numeric or descriptive)
///   values assigned, the first value specifying the upper bound
///   and the second value specifying the lower bound. It defines
///   a property - value bound (min-max) combination for which
///   the property Name, an optional
///   Description,ÿthe optional UpperBoundValue
///   with measure type, the optional LowerBoundValue with
///   measure type, and the optional Unit is given.
/// 
/// A set point value can be provided in addition to the upper and lower bound values for operational value setting.
/// 
/// The unit is handled by the Unit attribute:
/// 
/// If the Unit attribute is not given, then the
///   unit is already implied by the type of
///   IfcMeasureValue or IfcDerivedMeasureValue.
///   The associated unit can be found at the
///   IfcUnitAssignment globally defined at the project
///   level (IfcProject.UnitsInContext).
/// 
/// If the Unit attribute is given, then the unit
///   assigned by the Unit attribute overrides the
///   globally assigned unit.
/// 
/// The IfcPropertyBoundedValue allows for the
///   specification of an interval for the value component of the
///   property description. If either the
///   LowerBoundValue or the UpperBoundValue is not
///   given, then it indicates an open bound (either a minimum
///   value or a maximum value). The interval is by definition
///   inclusive, that is, the value given for the
///   LowerBoundValue or the UpperBoundValue is
///   included in the interval.
/// 
/// NOTE  An IfcPropertyBoundedValue may be
///   exchanged with no values assigned yet. In this case the
///   LowerBoundValue and the UpperBoundValue are
///   set to NIL.
/// 
/// Examples of a property with bounded value are:
/// 
/// Name
/// 
/// UpperBoundValue
/// 
/// LowerBoundValue
/// 
/// SetPointValue
/// 
/// Type (through
///   IfcValue, WR1 ensures same type for both
///   values)
/// 
/// Unit
/// 
/// OverallHeight
/// 
/// 1930
/// 
/// 2300
/// 
/// IfcPositiveLengthMeasure
/// 
/// -
/// 
/// OverallWidth
/// 
/// 0.9
/// 
/// 1.25
/// 
/// IfcPositiveLengthMeasure
/// 
/// m
/// 
/// MaxHeight
/// 
/// 20.0
/// 
/// IfcPositiveLengthMeasure
/// 
/// -
/// 
/// MinWeight
/// 
/// 20
/// 
/// IfcMassMeasure
/// 
/// kg
/// 
/// HISTORY ÿNew entity in IFC Release 2x.
/// 
/// IFC2x2 CHANGE  The attribute type of the attribute UpperBoundValue and LowerBoundValue has been changed from mandatory to optional with upward compatibility for file based exchange.
/// 
/// IFC2x4 CHANGE  The attribute SetPointValue has been added.
/// 
/// Informal proposition:
/// 
/// If the measure type for the upper and lover bound value
///   is a numeric measure, then the following shall be true: 
///   UpperBoundValue > LowerBoundValue.
class IFC_PARSE_API IfcPropertyBoundedValue : public IfcSimpleProperty {
public:
    /// Whether the optional attribute UpperBoundValue is defined for this IfcPropertyBoundedValue
    bool hasUpperBoundValue() const;
    /// Upper bound value for the interval defining the property value. If the value is not given, it indicates an open bound (all values to be greater than or equal to LowerBoundValue).
    IfcValue* UpperBoundValue() const;
    void setUpperBoundValue(IfcValue* v);
    /// Whether the optional attribute LowerBoundValue is defined for this IfcPropertyBoundedValue
    bool hasLowerBoundValue() const;
    /// Lower bound value for the interval defining the property value. If the value is not given, it indicates an open bound (all values to be lower than or equal to UpperBoundValue).
    IfcValue* LowerBoundValue() const;
    void setLowerBoundValue(IfcValue* v);
    /// Whether the optional attribute Unit is defined for this IfcPropertyBoundedValue
    bool hasUnit() const;
    /// Unit for the upper and lower bound values, if not given, the default value for the measure type is used as defined by the global unit assignment at IfcProject.UnitInContext. The applicable unit is then selected by the underlying TYPE of the UpperBoundValue, LowerBoundValue, and SetPointValue)
    IfcUnit* Unit() const;
    void setUnit(IfcUnit* v);
    /// Whether the optional attribute SetPointValue is defined for this IfcPropertyBoundedValue
    bool hasSetPointValue() const;
    /// Set point value as typically used for operational value setting.
    /// 
    /// IFC2x4 CHANGE  The attribute has been added at the end of the attribute list.
    IfcValue* SetPointValue() const;
    void setSetPointValue(IfcValue* v);
    virtual unsigned int getArgumentCount() const { return 6; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 2: return IfcUtil::Argument_ENTITY_INSTANCE; case 3: return IfcUtil::Argument_ENTITY_INSTANCE; case 4: return IfcUtil::Argument_ENTITY_INSTANCE; case 5: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcSimpleProperty::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 2: return Type::IfcValue; case 3: return Type::IfcValue; case 4: return Type::IfcUnit; case 5: return Type::IfcValue; } return IfcSimpleProperty::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 2: return "UpperBoundValue"; case 3: return "LowerBoundValue"; case 4: return "Unit"; case 5: return "SetPointValue"; } return IfcSimpleProperty::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPropertyBoundedValue (IfcEntityInstanceData* e);
    IfcPropertyBoundedValue (std::string v1_Name, boost::optional< std::string > v2_Description, IfcValue* v3_UpperBoundValue, IfcValue* v4_LowerBoundValue, IfcUnit* v5_Unit, IfcValue* v6_SetPointValue);
    typedef IfcTemplatedEntityList< IfcPropertyBoundedValue > list;
};
/// A property with an enumerated
/// value, IfcPropertyEnumeratedValue, defines a property
/// object which has a value assigned that is chosen from an
/// enumeration. It defines a property - value combination for which
/// theÿproperty Name, an optional Description,ÿthe
/// optional EnumerationValues
/// with measure type and optionally an Unit is given.
/// 
/// NOTE  Multiple choices from the property enumeration are supported.
/// 
/// The unit is handled by the Unit attribute of the
/// IfcPropertyEnumeration:
/// 
/// If the Unit attribute is not given, then the unit is
/// already implied by the type of IfcMeasureValue or
/// IfcDerivedMeasureValue. The associated unit can be found
/// at the IfcUnitAssignment globally defined at the project
/// level (IfcProject.UnitsInContext).
/// If the Unit attribute is given, then the unit assigned
/// by the unit attribute overrides the globally assigned unit.
/// 
/// More precisely: The IfcPropertyEnumeratedValue defines
/// a property, which value is selected from a defined list of
/// enumerators. The enumerators are stored in a dynamic enumeration
/// of values including the type information from IfcValue
/// (see IfcPropertyEnumeration). This enables applications to
/// use an enumeration value as a property within a property set
/// (IfcPropertySet) including the allowed list of
/// values.ÿ
/// 
/// NOTE  An IfcPropertyEnumeratedValue may be exchanged with no values assigned yet. In this case the EnumerationValues are set to NIL.
/// 
/// Examples of a property with enumerated value are:
/// 
/// Nameÿ
/// Value (EnumerationValue)
/// Type (through
/// IfcValue)
/// ref.IfcPropertyEnumeration
/// (Name)ÿ
/// 
/// BladeAction
/// Opposed
/// IfcString
/// DamperBladeActionEnum
/// 
/// BladeAction
/// Parallel
/// IfcString
/// DamperBladeActionEnum
/// 
/// The IfcPropertyEnumeratedValue refers to an
/// IfcPropertyEnumeration, e.g. for the above:
/// 
/// Name
/// EnumerationValues
/// Type (through
/// IfcValue)
/// Unit
/// 
/// DamperBladeActionEnum
/// (Parallel, Opposed, Other, Unset)
/// IfcString
/// -
/// 
/// It is not mandatory to use an instance of
/// IfcPropertyEnumeration to hold the applicable values for
/// IfcPropertyEnumeratedValue, however this is the preferred
/// way. A single instance of IfcPropertyEnumeration can be
/// referenced by multiple instances of
/// IfcPropertyEnumeratedValue.
/// 
/// HISTORY ÿNew Entity in IFC Release 2.0, capabilities enhanced in IFC2x. The entity has
/// been renamed from IfcEnumeratedProperty in IFC2x.
/// 
/// IFC2x4 CHANGE Attribute EnumerationValues has been made OPTIONAL with upward
/// compatibility for file based exchange.
class IFC_PARSE_API IfcPropertyEnumeratedValue : public IfcSimpleProperty {
public:
    /// Whether the optional attribute EnumerationValues is defined for this IfcPropertyEnumeratedValue
    bool hasEnumerationValues() const;
    /// Enumeration values, which shall be listed in the referenced IfcPropertyEnumeration, if such a reference is provided.
    /// 
    /// IFC2x4 CHANGE  The attribute has been made optional with upward compatibility for file based exchange.
    IfcEntityList::ptr EnumerationValues() const;
    void setEnumerationValues(IfcEntityList::ptr v);
    /// Whether the optional attribute EnumerationReference is defined for this IfcPropertyEnumeratedValue
    bool hasEnumerationReference() const;
    /// Enumeration from which a enumeration value has been selected. The referenced enumeration also establishes the unit of the enumeration value.
    IfcPropertyEnumeration* EnumerationReference() const;
    void setEnumerationReference(IfcPropertyEnumeration* v);
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 2: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 3: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcSimpleProperty::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 2: return Type::IfcValue; case 3: return Type::IfcPropertyEnumeration; } return IfcSimpleProperty::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 2: return "EnumerationValues"; case 3: return "EnumerationReference"; } return IfcSimpleProperty::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPropertyEnumeratedValue (IfcEntityInstanceData* e);
    IfcPropertyEnumeratedValue (std::string v1_Name, boost::optional< std::string > v2_Description, boost::optional< IfcEntityList::ptr > v3_EnumerationValues, IfcPropertyEnumeration* v4_EnumerationReference);
    typedef IfcTemplatedEntityList< IfcPropertyEnumeratedValue > list;
};
/// An IfcPropertyListValue
///   defines a property that has several (numeric or
///   descriptive) values assigned, these values are given by an
///   ordered list.ÿIt defines a property - list value
///   combination for which the property Name, an optional
///   Description,ÿthe optional ListValues with measure
///   type and optionally an Unit is given.
/// 
/// An IfcPropertyListValue is a list of values. The
///   order in which values appear is significant. Each value in
///   the list is unique i.e. no duplicate values are allowed.
///   All list members shall be of the same type.
/// 
/// The unit applicable to all values is handled by the
///   Unit attribute:
/// 
/// If the Unit attribute is not given, then the
///   unit is already implied by the type of
///   IfcMeasureValue or IfcDerivedMeasureValue.
///   The associated unit can be found at the
///   IfcUnitAssignment globally defined at the project
///   level (IfcProject.UnitsInContext).
/// 
/// If the Unit attribute is given, then the unit
///   assigned by the Unit attribute overrides the
///   globally assigned unit.
/// 
/// Example of a property with list value is:
/// 
/// Name
/// 
/// ListValues
/// 
/// Type (through
///   IfcValue)
/// 
/// Unit
/// 
/// ApplicableSizes
/// 
/// 1200
/// 
/// IfcPositiveLengthMeasure
/// 
/// -
/// 
/// -
/// 
/// 1600
/// 
/// IfcPositiveLengthMeasure
/// 
/// -
/// 
/// -
/// 
/// 2400
/// 
/// IfcPositiveLengthMeasure
/// 
/// -
/// 
/// HISTORY  New Entity in Release IFC 2x Edition 2.
/// 
/// IFC2x4 CHANGE  Attribute ListValues has been made OPTIONAL with upward compatibility for file based exchange.
class IFC_PARSE_API IfcPropertyListValue : public IfcSimpleProperty {
public:
    /// Whether the optional attribute ListValues is defined for this IfcPropertyListValue
    bool hasListValues() const;
    /// List of property values.
    /// 
    /// IFC2x4 CHANGE  The attribute has been made optional with upward compatibility for file based exchange.
    IfcEntityList::ptr ListValues() const;
    void setListValues(IfcEntityList::ptr v);
    /// Whether the optional attribute Unit is defined for this IfcPropertyListValue
    bool hasUnit() const;
    /// Unit for the list values, if not given, the default value for the measure type (given by the TYPE of nominal value) is used as defined by the global unit assignment at IfcProject.
    IfcUnit* Unit() const;
    void setUnit(IfcUnit* v);
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 2: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 3: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcSimpleProperty::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 2: return Type::IfcValue; case 3: return Type::IfcUnit; } return IfcSimpleProperty::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 2: return "ListValues"; case 3: return "Unit"; } return IfcSimpleProperty::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPropertyListValue (IfcEntityInstanceData* e);
    IfcPropertyListValue (std::string v1_Name, boost::optional< std::string > v2_Description, boost::optional< IfcEntityList::ptr > v3_ListValues, IfcUnit* v4_Unit);
    typedef IfcTemplatedEntityList< IfcPropertyListValue > list;
};
/// IfcPropertyReferenceValue allows a property value to
///   be given by referencing other entities within the resource
///   definitions of IFC. Those other entities are regarded as
///   predefined complex properties and can be aggregated within
///   a property set (IfcPropertySet). The allowable
///   entities to be used as value references are given by the
///   IfcObjectReferenceSelect.
/// 
/// HISTORY  New entity in IFC
///   Release 1.5. Entity has been renamed from
///   IfcObjectReference in IFC Release 2x.
/// 
/// IFC2x4 CHANGE  Attribute
///   PropertyReference has been made OPTIONAL with upward
///   compatibility for file based exchange.
class IFC_PARSE_API IfcPropertyReferenceValue : public IfcSimpleProperty {
public:
    /// Whether the optional attribute UsageName is defined for this IfcPropertyReferenceValue
    bool hasUsageName() const;
    /// Description of the use of the referenced value within the property.
    std::string UsageName() const;
    void setUsageName(std::string v);
    /// Whether the optional attribute PropertyReference is defined for this IfcPropertyReferenceValue
    bool hasPropertyReference() const;
    /// Reference to another property entity through one of the select types in the IfcObjectReferenceSelect.
    /// 
    /// IFC2x4 CHANGE  The attribute has been made optional with upward compatibility for file based exchange.
    IfcObjectReferenceSelect* PropertyReference() const;
    void setPropertyReference(IfcObjectReferenceSelect* v);
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 2: return IfcUtil::Argument_STRING; case 3: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcSimpleProperty::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 2: return Type::IfcText; case 3: return Type::IfcObjectReferenceSelect; } return IfcSimpleProperty::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 2: return "UsageName"; case 3: return "PropertyReference"; } return IfcSimpleProperty::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPropertyReferenceValue (IfcEntityInstanceData* e);
    IfcPropertyReferenceValue (std::string v1_Name, boost::optional< std::string > v2_Description, boost::optional< std::string > v3_UsageName, IfcObjectReferenceSelect* v4_PropertyReference);
    typedef IfcTemplatedEntityList< IfcPropertyReferenceValue > list;
};
/// IfcPropertySet defines all dynamically extensible
/// properties. The property set is a container class that holds
/// properties within a property tree. These properties are interpreted
/// according to their name attribute.
/// The same IfcPropertySet can be assignd to multiple
/// object occurrences, it should then be assigned by a single instance
/// of IfcRelDefinedByProperties to a set of related objects.
/// Those property sets are referred to as shared property sets. It can
/// also be assigned to an object type.
/// The underlying structure, i.e. the required name, the applicable
/// object or object types to which the property set can be attached
/// and the individual properties that maybe included can be assigned
/// using the property set template.
/// 
/// NOTE  See IfcRelDefinesByType for how to override property sets assigned to an object type within the object occurrence.
/// 
/// HISTORY  New Entity in IFC Release 1.0
/// 
/// IFC2x4 CHANGE  All statically defined property set entities are no longer subtypes of
/// IfcPropertySet.
/// 
/// Relationship use definition
/// Property sets are related to other objects by using the
/// relationship object that refers to the corresponding object:
/// 
/// Occurrence Object: IfcRelDefinesByProperties
/// using the inverse attribute DefinesOccurrence.
/// Type Object: using a direct link by inverse attribute
/// DefinesType.
/// External reference: subtypes of
/// IfcRelAssociates are used to provide a link to a
/// classification system, or external library providing further
/// reference to the property set. Accessible by inverse attribute
/// HasAssociations.
/// Underlying template: IfcRelDefinesByTemplate
/// using the inverse attribute IsDefinedBy.
/// 
/// Attribute use definition
/// Instances of IfcPropertySet are used to assign named
/// sets of individual properties (complex or single properties). Each
/// individual property has a significant name string. Some property
/// sets are included in the IFC specification and have a
/// predefined set of properties indicated by assigning a significant
/// name. These property sets are listed under "property sets" main
/// menu item within this specification and from the object
/// documentation sheet for those object to which they are applicable.
/// The naming convention "Pset_Xxx" applies to all those property sets
/// that are defined as part of the IFC specification and it shall be
/// used as the value of the Name attribute.
/// In addition any user defined property set can be captured.
/// Property sets that are not declared as part of the IFC
/// specification shall have a Name value not including the
/// "Pset_" prefix.
class IFC_PARSE_API IfcPropertySet : public IfcPropertySetDefinition {
public:
    /// Contained set of properties. For property sets defined as part of the IFC Object model, the property objects within a property set are defined as part of the standard. If a property is not contained within the set of predefined properties, its value has not been set at this time.
    IfcTemplatedEntityList< IfcProperty >::ptr HasProperties() const;
    void setHasProperties(IfcTemplatedEntityList< IfcProperty >::ptr v);
    virtual unsigned int getArgumentCount() const { return 5; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 4: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } return IfcPropertySetDefinition::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 4: return Type::IfcProperty; } return IfcPropertySetDefinition::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 4: return "HasProperties"; } return IfcPropertySetDefinition::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPropertySet (IfcEntityInstanceData* e);
    IfcPropertySet (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcTemplatedEntityList< IfcProperty >::ptr v5_HasProperties);
    typedef IfcTemplatedEntityList< IfcPropertySet > list;
};
/// IfcPropertySetTemplate defines the template for all
/// dynamically extensible property sets represented by
/// IfcPropertySet. The property set template is a container
/// of property templates within a property tree. The individual
/// property templates are interpreted according to their Name
/// attribute and shall have no values assigned.
/// NOTE  By
/// convention an IfcPropertySetTemplate can also be used as a
/// template for an IfcElementQuantity, being a particular
/// type of a property set definition.
/// Property set templates can form part of a property library used
/// and declared within a project. Depending on the
/// TemplateType the IfcPropertySetTemplate defines a
/// template for:
/// 
/// "Pset_" - occurrences of IfcPropertySet
/// "QTO_" - occurrences of IfcElementQuantity
/// 
/// HISTORY New Entity in IFC2x4.
/// 
/// Relationship use definition
/// 
/// The inherited HasContext inverse relation to IfcRelDeclares is used to declare the IfcPropertySetTemplate within a project library. If included in an exchange data set it can then be traversed through the IfcProjectLibrary.
/// 
/// The Defines inverse relation to IfcRelDefinesByTemplate is provided to keep the definition relationship between the IfcPropertySetTemplate and the one to many IfcPropertySet's, for which it provides the template.
/// 
/// Between IfcProperty's within the HasProperties set of IfcPropertySet having the same Name attribute value as the IfcPropertyTemplate's within the HasPropertyTemplates set of IfcPropertySetTemplate an implicit definition relationship is established that assigns the template to the individual properties.
/// 
/// Figure 5 illustrates relationships used for property set templates.
/// 
/// Figure 5 — Property set template relationships
class IFC_PARSE_API IfcPropertySetTemplate : public IfcPropertyTemplateDefinition {
public:
    /// Whether the optional attribute TemplateType is defined for this IfcPropertySetTemplate
    bool hasTemplateType() const;
    /// Property set type defining whether the property set is applicable to a type (subtypes of IfcTypeObject), to an occurrence (subtypes of IfcObject), or as a special case to a performance history.
    /// The attribute ApplicableEntity may further refine the applicability to a single or multiple entity type(s).
    IfcPropertySetTemplateTypeEnum::IfcPropertySetTemplateTypeEnum TemplateType() const;
    void setTemplateType(IfcPropertySetTemplateTypeEnum::IfcPropertySetTemplateTypeEnum v);
    /// Whether the optional attribute ApplicableEntity is defined for this IfcPropertySetTemplate
    bool hasApplicableEntity() const;
    /// The attribute optionally defines the data type of the applicable type or occurrence object, to which the assigned property set template can relate. If not present, no instruction is given to which type or occurrence object the property set template is applicable. The following conventions are used:
    /// 
    /// The IFC entity name of the applicable entity using the IFC naming convention, CamelCase with IFC prefix
    ///   It can be optionally followed by the predefined type after the separator "/" (forward slash), using upper case
    ///   If a performance history object of a particular distribution object is attributes by the property set template, then the entity name (and potentially amended by the predefined type) is expanded by adding '[PerformanceHistory]'
    ///   If one property set template is applicable to many type and/or occurrence objects, then those object names should be separate by comma "," forming a comma separated string.
    /// 
    /// EXAMPLE  Refering to a boiler type as applicable entity would be expressed as 'IfcBoilerType', refering to a steam boiler type as applicable entity would be expressed as 'IfcBoilerType/STEAM', refering to a wall and wall standard case and a wall type would be expressed as 'IfcWall, IfcWallStandardCase, IfcWallType'.
    /// 
    /// An applicable IfcPerformanceHistory assigned to an occurrence or type object would be indicated by IfcBoilerType[PerformanceHistory], or respectively IfcBoilerType/STEAM[PerformanceHistory].
    std::string ApplicableEntity() const;
    void setApplicableEntity(std::string v);
    /// Set of IfcPropertyTemplate's that are defined within the scope of the IfcPropertySetTemplate.
    IfcTemplatedEntityList< IfcPropertyTemplate >::ptr HasPropertyTemplates() const;
    void setHasPropertyTemplates(IfcTemplatedEntityList< IfcPropertyTemplate >::ptr v);
    virtual unsigned int getArgumentCount() const { return 7; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 4: return IfcUtil::Argument_ENUMERATION; case 5: return IfcUtil::Argument_STRING; case 6: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } return IfcPropertyTemplateDefinition::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 4: return Type::IfcPropertySetTemplateTypeEnum; case 5: return Type::IfcIdentifier; case 6: return Type::IfcPropertyTemplate; } return IfcPropertyTemplateDefinition::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 4: return "TemplateType"; case 5: return "ApplicableEntity"; case 6: return "HasPropertyTemplates"; } return IfcPropertyTemplateDefinition::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcRelDefinesByTemplate >::ptr Defines() const; // INVERSE IfcRelDefinesByTemplate::RelatingTemplate
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPropertySetTemplate (IfcEntityInstanceData* e);
    IfcPropertySetTemplate (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< IfcPropertySetTemplateTypeEnum::IfcPropertySetTemplateTypeEnum > v5_TemplateType, boost::optional< std::string > v6_ApplicableEntity, IfcTemplatedEntityList< IfcPropertyTemplate >::ptr v7_HasPropertyTemplates);
    typedef IfcTemplatedEntityList< IfcPropertySetTemplate > list;
};
/// The property with a single value
/// IfcPropertySingleValue defines a property object which has
/// a single (numeric or descriptive) value assigned. It defines a
/// property - single value combination for which the property
/// Name, an optional Description,ÿand an optional
/// NominalValue with measure type is provided. In addition,
/// the default unit as specified within the project unit context can
/// be overriden by assigning an Unit.
/// The unit is handled by the Unit attribute:
/// 
/// If the Unit attribute is not given, then the unit is
/// already implied by the type of IfcMeasureValue or
/// IfcDerivedMeasureValue. The associated unit can be found
/// at the IfcUnitAssignment globally defined at the project
/// level (IfcProject.UnitsInContext).
/// If the Unit attribute is given, then the unit assigned
/// by the Unit attribute overrides the globally assigned
/// unit.
/// 
/// Examples of a property with single value are:
/// 
/// Name
/// NominalValue
/// Type (through IfcValue)
/// Unit
/// 
/// Description
/// Manufacturer "A" door
/// IfcLabel
/// -
/// 
/// PanelThickness
/// 0.12
/// IfcPositiveLengthMeasure
/// -
/// 
/// ThermalTransmittance
/// 2.6
/// IfcThermalTransmittanceMeasure
/// W/(m2K)
/// 
/// HISTORY ÿNew entity in IFC Release 1.0. The entity has been renamed from IfcSimpleProperty in IFC Release 2x.
/// 
/// IFC2x3 CHANGE ÿAttribute NominalValue has been made OPTIONAL with upward compatibility for file based exchange.
class IFC_PARSE_API IfcPropertySingleValue : public IfcSimpleProperty {
public:
    /// Whether the optional attribute NominalValue is defined for this IfcPropertySingleValue
    bool hasNominalValue() const;
    /// Value and measure type of this property. 
    /// 
    /// NOTE  By virtue of the defined data type, that is selected from the SELECT IfcValue, the appropriate unit can be found within the IfcUnitAssignment, defined for the project if no value for the unit attribute is given.
    /// 
    /// IFC2x3 CHANGE  The attribute has been made optional with upward compatibility for file based exchange.
    IfcValue* NominalValue() const;
    void setNominalValue(IfcValue* v);
    /// Whether the optional attribute Unit is defined for this IfcPropertySingleValue
    bool hasUnit() const;
    /// Unit for the nominal value, if not given, the default value for the measure type (given by the TYPE of nominal value) is used as defined by the global unit assignment at IfcProject.
    IfcUnit* Unit() const;
    void setUnit(IfcUnit* v);
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 2: return IfcUtil::Argument_ENTITY_INSTANCE; case 3: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcSimpleProperty::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 2: return Type::IfcValue; case 3: return Type::IfcUnit; } return IfcSimpleProperty::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 2: return "NominalValue"; case 3: return "Unit"; } return IfcSimpleProperty::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPropertySingleValue (IfcEntityInstanceData* e);
    IfcPropertySingleValue (std::string v1_Name, boost::optional< std::string > v2_Description, IfcValue* v3_NominalValue, IfcUnit* v4_Unit);
    typedef IfcTemplatedEntityList< IfcPropertySingleValue > list;
};
/// A property with a range value
///   (IfcPropertyTableValue) defines a property object
///   which has two lists of (numeric or descriptive) values
///   assigned, the values specifying a table with two columns.
///   The defining values provide the first column and establish
///   the scope for the defined values (the second column).
///   Interpolations are out of scope of the
///   IfcPropertyTableValue. An optional Expression
///   attribute may give the equation used for deriving the range
///   value, which is for information purposes only.
/// 
/// The IfcPropertyTableValue defines a defining/defined
///   property value combination for which the property name, the
///   table with defining and defined values with measure type
///   (and optional the units for defining and defined values)
///   are given.
/// 
/// The units are handled by the DefiningUnit and
///   DefinedUnit attributes:
/// 
/// If the DefiningUnit or DefinedUnit
///   attribute is not given, then the unit is already implied by
///   the type of IfcMeasureValue or
///   IfcDerivedMeasureValue. The associated unit can be
///   found at the IfcUnitAssignment globally defined at
///   the project level (IfcProject.UnitsInContext).
/// 
/// If the DefiningUnit or DefinedUnit
///   attribute is given, then the unit assigned by the unit
///   attribute overrides the globally assigned unit.
/// 
/// The IfcPropertyTableValue allows for the
///   specification of a table of defining/defined value pairs of
///   the property description. The optional 
///   attribute CurveInterpolation allows to determine the 
///   interval between two given values.
/// 
/// Examples of a property with range value are:
/// 
/// Name
/// 
/// DefiningValues
/// 
/// DefiningValue Type (through IfcValue)
/// 
/// DefinedValues
/// 
/// DefinedValue Type (through
///   IfcValue)
/// 
/// DefingUnit
/// 
/// DefinedUnit
/// 
/// SoundTransmissionLoss
/// 
/// 100
/// 
/// IfcFrequencyMeasure
/// 
/// 20
/// 
/// IfcNumericMeasure
/// 
/// -
/// 
/// dB
/// 
/// ÿ
/// 
/// 200
/// 
/// IfcFrequencyMeasure
/// 
/// 42
/// 
/// IfcNumericMeasure
/// 
/// ÿ
/// 
/// ÿ
/// 
/// ÿ
/// 
/// 400
/// 
/// IfcFrequencyMeasure
/// 
/// 46
/// 
/// IfcNumericMeasure
/// 
/// ÿ
/// 
/// ÿ
/// 
/// ÿ
/// 
/// 800
/// 
/// IfcFrequencyMeasure
/// 
/// 56
/// 
/// IfcNumericMeasure
/// 
/// ÿ
/// 
/// ÿ
/// 
/// ÿ
/// 
/// 1600
/// 
/// IfcFrequencyMeasure
/// 
/// 60
/// 
/// IfcNumericMeasure
/// 
/// ÿ
/// 
/// ÿ
/// 
/// ÿ
/// 
/// 3200
/// 
/// IfcFrequencyMeasure
/// 
/// 65
/// 
/// IfcNumericMeasure
/// 
/// ÿ
/// 
/// ÿ
/// 
/// HISTORY: New entity in IFC2x.
/// 
/// IFC2x4 CHANGE  Attributes DefiningValues and DefinedValues have been made OPTIONAL with upward compatibility for file based exchange. The attribute CurveInterpolation has been added..
/// 
/// Informal propositions:
/// 
/// The list of DefinedValues and the list of
///   DefiningValues are corresponding lists.
class IFC_PARSE_API IfcPropertyTableValue : public IfcSimpleProperty {
public:
    /// Whether the optional attribute DefiningValues is defined for this IfcPropertyTableValue
    bool hasDefiningValues() const;
    /// List of defining values, which determine the defined values. This list shall have unique values only.
    /// 
    /// IFC2x4 CHANGE  The attribute has been made optional with upward compatibility for file based exchange.
    IfcEntityList::ptr DefiningValues() const;
    void setDefiningValues(IfcEntityList::ptr v);
    /// Whether the optional attribute DefinedValues is defined for this IfcPropertyTableValue
    bool hasDefinedValues() const;
    /// Defined values which are applicable for the scope as defined by the defining values.
    /// 
    /// IFC2x4 CHANGE  The attribute has been made optional with upward compatibility for file based exchange.
    IfcEntityList::ptr DefinedValues() const;
    void setDefinedValues(IfcEntityList::ptr v);
    /// Whether the optional attribute Expression is defined for this IfcPropertyTableValue
    bool hasExpression() const;
    /// Expression for the derivation of defined values from the defining values, the expression is given for information only, i.e. no automatic processing can be expected from the expression.
    std::string Expression() const;
    void setExpression(std::string v);
    /// Whether the optional attribute DefiningUnit is defined for this IfcPropertyTableValue
    bool hasDefiningUnit() const;
    /// Unit for the defining values, if not given, the default value for the measure type (given by the TYPE of the defining values) is used as defined by the global unit assignment at IfcProject.
    IfcUnit* DefiningUnit() const;
    void setDefiningUnit(IfcUnit* v);
    /// Whether the optional attribute DefinedUnit is defined for this IfcPropertyTableValue
    bool hasDefinedUnit() const;
    /// Unit for the defined values, if not given, the default value for the measure type (given by the TYPE of the defined values) is used as defined by the global unit assignment at IfcProject.
    IfcUnit* DefinedUnit() const;
    void setDefinedUnit(IfcUnit* v);
    /// Whether the optional attribute CurveInterpolation is defined for this IfcPropertyTableValue
    bool hasCurveInterpolation() const;
    /// Interpolation of the curve between two defining and defined values that are provided. if not provided a linear interpolation is assumed.
    /// 
    /// IFC2x4 CHANGE  The attribute has been added at the end of the attribute list.
    IfcCurveInterpolationEnum::IfcCurveInterpolationEnum CurveInterpolation() const;
    void setCurveInterpolation(IfcCurveInterpolationEnum::IfcCurveInterpolationEnum v);
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 2: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 3: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 4: return IfcUtil::Argument_STRING; case 5: return IfcUtil::Argument_ENTITY_INSTANCE; case 6: return IfcUtil::Argument_ENTITY_INSTANCE; case 7: return IfcUtil::Argument_ENUMERATION; } return IfcSimpleProperty::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 2: return Type::IfcValue; case 3: return Type::IfcValue; case 4: return Type::IfcText; case 5: return Type::IfcUnit; case 6: return Type::IfcUnit; case 7: return Type::IfcCurveInterpolationEnum; } return IfcSimpleProperty::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 2: return "DefiningValues"; case 3: return "DefinedValues"; case 4: return "Expression"; case 5: return "DefiningUnit"; case 6: return "DefinedUnit"; case 7: return "CurveInterpolation"; } return IfcSimpleProperty::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPropertyTableValue (IfcEntityInstanceData* e);
    IfcPropertyTableValue (std::string v1_Name, boost::optional< std::string > v2_Description, boost::optional< IfcEntityList::ptr > v3_DefiningValues, boost::optional< IfcEntityList::ptr > v4_DefinedValues, boost::optional< std::string > v5_Expression, IfcUnit* v6_DefiningUnit, IfcUnit* v7_DefinedUnit, boost::optional< IfcCurveInterpolationEnum::IfcCurveInterpolationEnum > v8_CurveInterpolation);
    typedef IfcTemplatedEntityList< IfcPropertyTableValue > list;
};
/// The IfcPropertyTemplate is an abstract supertype
/// comprising the templates for all dynamically extensible properties,
/// either as an IfcComplexPropertyTemplate, or an
/// IfcSimplePropertyTemplate. These templates determine the
/// structure of:
/// 
/// in case of IfcComplexPropertyTemplate
/// 
/// an IfcComplexProperty
/// an IfcPhysicalComplexQuantity
/// 
/// in case of IfcSimplePropertyTemplate
/// 
/// a subtype of IfcSimpleProperty
/// a subtype of IfcPhysicalSimpleQuantity
/// 
/// The individual property templates are interpreted according to
/// their Name attribute and may have a predefined property
/// type, property unit, and property data type. A template however
/// shall not have measure values, or quantity values assigned. .
/// 
/// NOTE Property templates can form part of a property library used and attached as part of a project library. In general the IfcPropertySetTemplate, containing the subtypes of IfcPropertyTemplate would be directly linked to the IfcProjectLibrary.
/// 
/// HISTORY New Entity in IFC2x4.
class IFC_PARSE_API IfcPropertyTemplate : public IfcPropertyTemplateDefinition {
public:
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcPropertyTemplateDefinition::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcPropertyTemplateDefinition::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcPropertyTemplateDefinition::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcComplexPropertyTemplate >::ptr PartOfComplexTemplate() const; // INVERSE IfcComplexPropertyTemplate::HasPropertyTemplates
    IfcTemplatedEntityList< IfcPropertySetTemplate >::ptr PartOfPsetTemplate() const; // INVERSE IfcPropertySetTemplate::HasPropertyTemplates
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPropertyTemplate (IfcEntityInstanceData* e);
    IfcPropertyTemplate (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description);
    typedef IfcTemplatedEntityList< IfcPropertyTemplate > list;
};
/// IfcProxy is intended to be a kind of a container for wrapping objects which are defined by associated properties, which may or may not have a geometric representation and placement in space. A proxy may have a semantic meaning, defined by the Name attribute, and property definitions, attached through the property assignment relationship, which definition may be outside of the definitions given by the current release of IFC.
/// 
/// The ProxyType may give an indication to which high level semantic breakdown of object the semantic definition of the proxy relates to. the Tag attribute may be used to assign a human or system interpretable identifier (such as a serial number or bar code).
/// 
/// NOTE 1  Given that only a
/// limited number of semantic constructs can be formally defined within
/// IFC (and it will never be possible to define all), there has to be a
/// mechanism for capturing those constructs that are not (yet) defined by
/// IFC. 
/// 
/// NOTE 2  Product proxies are a
/// mechanism that allows to exchange data that is part of the project but
/// not necessarily part of the IFC model. Those proxies may have geometric
/// representations assigned.
/// 
/// HISTORY  New entity in IFC Release 1.5.
class IFC_PARSE_API IfcProxy : public IfcProduct {
public:
    /// High level (and only) semantic meaning attached to the IfcProxy, defining the basic construct type behind the Proxy, e.g. Product or Process.
    IfcObjectTypeEnum::IfcObjectTypeEnum ProxyType() const;
    void setProxyType(IfcObjectTypeEnum::IfcObjectTypeEnum v);
    /// Whether the optional attribute Tag is defined for this IfcProxy
    bool hasTag() const;
    /// The tag (or label) identifier at the particular instance of a product, e.g. the serial number, or the position number. It is the identifier at the occurrence level.
    std::string Tag() const;
    void setTag(std::string v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 7: return IfcUtil::Argument_ENUMERATION; case 8: return IfcUtil::Argument_STRING; } return IfcProduct::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 7: return Type::IfcObjectTypeEnum; case 8: return Type::IfcLabel; } return IfcProduct::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 7: return "ProxyType"; case 8: return "Tag"; } return IfcProduct::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcProxy (IfcEntityInstanceData* e);
    IfcProxy (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, IfcObjectTypeEnum::IfcObjectTypeEnum v8_ProxyType, boost::optional< std::string > v9_Tag);
    typedef IfcTemplatedEntityList< IfcProxy > list;
};
/// IfcRectangleHollowProfileDef defines a section profile that provides the defining parameters of a rectangular (or square) hollow section to be used by the swept surface geometry or the swept area solid. Its parameters and orientation relative to the position coordinate system are according to the following illustration. A square hollow section can be defined by equal values for h and b. The centre of the position coordinate system is in the profiles centre of the bounding box (for symmetric profiles identical with the centre of gravity). Normally, the longer sides are parallel to the y-axis, the shorter sides parallel to the x-axis.
/// 
/// HISTORY  New entity in IFC2x2.
/// 
/// IFC2x4 CHANGE  Types of InnerFilletRadius and OuterFilletRadius relaxed to allow for zero values.
/// 
/// Figure 322 illustrates parameters of a rectangular or square hollow profile definition.
/// 
/// Position
/// The parameterized profile defines its own position coordinate system.
/// The underlying coordinate system is defined by the swept area solid
/// that uses the profile definition. It is the xy plane of:
/// 
/// IfcSweptAreaSolid.Position
/// 
/// by using offsets of the position location, the parameterized profile
/// can be positioned centric (using x,y offsets = 0.), or at any position
/// relative to the profile.
/// 
/// Figure 322 — Rectangle hollow profile
class IFC_PARSE_API IfcRectangleHollowProfileDef : public IfcRectangleProfileDef {
public:
    /// Thickness of the material.
    double WallThickness() const;
    void setWallThickness(double v);
    /// Whether the optional attribute InnerFilletRadius is defined for this IfcRectangleHollowProfileDef
    bool hasInnerFilletRadius() const;
    /// Inner corner radius.
    double InnerFilletRadius() const;
    void setInnerFilletRadius(double v);
    /// Whether the optional attribute OuterFilletRadius is defined for this IfcRectangleHollowProfileDef
    bool hasOuterFilletRadius() const;
    /// Outer corner radius.
    double OuterFilletRadius() const;
    void setOuterFilletRadius(double v);
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 5: return IfcUtil::Argument_DOUBLE; case 6: return IfcUtil::Argument_DOUBLE; case 7: return IfcUtil::Argument_DOUBLE; } return IfcRectangleProfileDef::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 5: return Type::IfcPositiveLengthMeasure; case 6: return Type::IfcNonNegativeLengthMeasure; case 7: return Type::IfcNonNegativeLengthMeasure; } return IfcRectangleProfileDef::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 5: return "WallThickness"; case 6: return "InnerFilletRadius"; case 7: return "OuterFilletRadius"; } return IfcRectangleProfileDef::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRectangleHollowProfileDef (IfcEntityInstanceData* e);
    IfcRectangleHollowProfileDef (IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< std::string > v2_ProfileName, IfcAxis2Placement2D* v3_Position, double v4_XDim, double v5_YDim, double v6_WallThickness, boost::optional< double > v7_InnerFilletRadius, boost::optional< double > v8_OuterFilletRadius);
    typedef IfcTemplatedEntityList< IfcRectangleHollowProfileDef > list;
};
/// The IfcRectangularPyramid is a Construction Solid
/// Geometry (CSG) 3D primitive. It is a solid with a rectangular base and
/// a point called apex as the top. The tapers from the base to the
/// top. The axis from the center of the base to the apex is
/// perpendicular to the base. The inherited Position
/// attribute defines the IfcAxisPlacement3D and provides the
/// location and orientation of the pyramid:
/// 
/// SELF\IfcCsgPrimitive3D.Position: The location and
/// orientation of the axis system for the primitive. 
/// SELF\IfcCsgPrimitive3D.Position.Location: The center
/// of the circular area being the bottom face of the cone.
/// SELF\IfcCsgPrimitive3D.Position.Position[3]: The
/// z-axis of the inherited placement coordinate system provides the
/// center axis of the IfcRightCircularCone, and the apex is
/// at the Height value applied to the positive direction of
/// the z-axis. The BottomRadius defines the circular base at
/// the xy-plane of the placement coordinate system.
/// 
/// As shown in Figure 260, the pyramid is positioned within its own placement coordinate system. The origin is the center of the bottom rectangle, that lies in the XY plane. The apex lies on the positive z axis at [0, 0, Height].
/// 
/// Figure 260 — Rectangular pyramid geometry
/// 
/// NOTE  Corresponding ISO 10303 entity: right_circular_cone, the position attribute has been promoted to the immediate supertype IfcCsgPrimitive3D. No semi_angle attribute, and the radius defines the bottom radius, since only a non-truncated cone is in scope. Please refer to ISO/IS 10303-42:1994, p. 176 for the final definition of the formal standard.
/// 
/// HISTORY  New entity in IFC2x3
/// 
/// Texture use definition
/// 
/// On each triangular side face, textures are aligned facing upright. 
/// Textures are stretched or repeated to the extent of the base of each face according to RepeatS. 
/// Textures are stretched or repeated towards the top point according to Repeat T, 
/// where the top point has coordinates of (0.5,1.0) if RepeatT is False. 
/// 
/// On the bottom face, textures are aligned facing front-to-back.
/// 
/// Figure 261 illustrates default texture mapping with a clamped texture (RepeatS=False and RepeatT=False). The image on the left shows the texture where the S axis points to the right and the T axis points up. The image on the right shows the texture applied to the geometry where the X axis points back to the right, the Y axis
/// points back to the left, and the Z axis points up.
/// 
/// Side
/// Normal
/// Origin X
/// Origin Y
/// Origin Z
/// S Axis
/// T Axis
/// 
/// Left
/// -X
/// 0
/// +YLength
/// 0
/// -Y
/// (towards top point)
/// 
/// Right
/// +X
/// 0
/// +YLength
/// 0
/// +Y
/// (towards top point)
/// 
/// Front
/// +X
/// 0
/// 0
/// 0
/// +X
/// (towards top point)
/// 
/// Back
/// +Y
/// +XLength
/// +YLength
/// 0
/// -X
/// (towards top point)
/// 
/// Bottom
/// -Z
/// +XLength
/// 0
/// 0
/// -X
/// +Y
/// 
/// Figure 261 — Right circular cone textures
class IFC_PARSE_API IfcRectangularPyramid : public IfcCsgPrimitive3D {
public:
    /// The length of the base measured along the placement X axis. It is provided by the inherited axis placement through SELF\IfcCsgPrimitive3D.Position.P[1].
    double XLength() const;
    void setXLength(double v);
    /// The length of the base measured along the placement Y axis. It is provided by the inherited axis placement through SELF\IfcCsgPrimitive3D.Position.P[2].
    double YLength() const;
    void setYLength(double v);
    /// The height of the apex above the plane of the base, measured in the direction of the placement Z axis, the SELF\IfcCsgPrimitive3D.Position.P[2].
    double Height() const;
    void setHeight(double v);
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 1: return IfcUtil::Argument_DOUBLE; case 2: return IfcUtil::Argument_DOUBLE; case 3: return IfcUtil::Argument_DOUBLE; } return IfcCsgPrimitive3D::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 1: return Type::IfcPositiveLengthMeasure; case 2: return Type::IfcPositiveLengthMeasure; case 3: return Type::IfcPositiveLengthMeasure; } return IfcCsgPrimitive3D::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 1: return "XLength"; case 2: return "YLength"; case 3: return "Height"; } return IfcCsgPrimitive3D::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRectangularPyramid (IfcEntityInstanceData* e);
    IfcRectangularPyramid (IfcAxis2Placement3D* v1_Position, double v2_XLength, double v3_YLength, double v4_Height);
    typedef IfcTemplatedEntityList< IfcRectangularPyramid > list;
};
/// Definition from ISO/CD 10303-42:1992: The trimmed surface is a simple bounded surface in which the boundaries are the constant parametric lines u1 = u1, u2 = u2, v1 = v1 and v2 = v2. All these values shall be within the parametric range of the referenced surface. Cyclic properties of the parameter range are assumed.
/// 
/// NOTE 1 For example, 370 degrees is equivalent to 10 degrees, for those surfaces whose parametric form is defined using circular functions (sine and cosine).
/// 
/// The rectangular trimmed surface inherits its parameterization directly from the basis surface and has parameter ranges from 0 to |u2 - u1| and 0 to|v2-v1|.
/// 
/// NOTE 2 If the surface is closed in a given parametric direction, the values of u2 or v2 may require to be increased by the cyclic range.
/// 
/// NOTE Corresponding ISO 10303 name: rectangular_trimmed_surface. Please refer to ISO/IS 10303-42:1994, p.86 for the final definition of the formal standard.
/// 
/// HISTORY New class in IFC Release 2x.
/// 
/// Informal propositions: 
/// 
/// The domain of the trimmed surface shall be within the domain of the surface being trimmed.
class IFC_PARSE_API IfcRectangularTrimmedSurface : public IfcBoundedSurface {
public:
    /// Surface being trimmed.
    IfcSurface* BasisSurface() const;
    void setBasisSurface(IfcSurface* v);
    /// First u parametric value.
    double U1() const;
    void setU1(double v);
    /// First v parametric value.
    double V1() const;
    void setV1(double v);
    /// Second u parametric value.
    double U2() const;
    void setU2(double v);
    /// Second v parametric value.
    double V2() const;
    void setV2(double v);
    /// Flag to indicate whether the direction of the first parameter of the trimmed surface agrees with or opposes the sense of u in the basis surface.
    bool Usense() const;
    void setUsense(bool v);
    /// Flag to indicate whether the direction of the second parameter of the trimmed surface agrees with or opposes the sense of v in the basis surface.
    bool Vsense() const;
    void setVsense(bool v);
    virtual unsigned int getArgumentCount() const { return 7; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_DOUBLE; case 2: return IfcUtil::Argument_DOUBLE; case 3: return IfcUtil::Argument_DOUBLE; case 4: return IfcUtil::Argument_DOUBLE; case 5: return IfcUtil::Argument_BOOL; case 6: return IfcUtil::Argument_BOOL; } return IfcBoundedSurface::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcSurface; case 1: return Type::IfcParameterValue; case 2: return Type::IfcParameterValue; case 3: return Type::IfcParameterValue; case 4: return Type::IfcParameterValue; case 5: return Type::IfcBoolean; case 6: return Type::IfcBoolean; } return IfcBoundedSurface::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "BasisSurface"; case 1: return "U1"; case 2: return "V1"; case 3: return "U2"; case 4: return "V2"; case 5: return "Usense"; case 6: return "Vsense"; } return IfcBoundedSurface::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRectangularTrimmedSurface (IfcEntityInstanceData* e);
    IfcRectangularTrimmedSurface (IfcSurface* v1_BasisSurface, double v2_U1, double v3_V1, double v4_U2, double v5_V2, bool v6_Usense, bool v7_Vsense);
    typedef IfcTemplatedEntityList< IfcRectangularTrimmedSurface > list;
};
/// Definition from IAI: An
///   IfcReinforcementDefinitionProperties defines the cross section
///   properties of reinforcement included in reinforced concrete building elements.
///   The property set definition may be used both in conjunction with insitu and
///   precast structures.  
/// 
/// HISTORY New entity in IFC Release 2x2
/// IFC 2x4 change: Supertype changed from IfcPropertySetDefinition to IfcPreDefinedPropertySet
/// 
/// General usage: 
///   This subtype of IfcPropertySetDefinition is used to define the
///   reinforcement properties in early design stages, such as in requirement
///   definition or scheme design. In later design stages explicit instances of
///   subtypes of IfcReinforcingElement are used. The intended usage may be
///   indicated using the DefinitionType attribute value as a designator:
///   recommended values are 'Reinforcement area requirement' or 'Reinforcement
///   configuration requirement'. Other values may be used according to local
///   standards.  
///   Only one property set definition of this kind is used for each concrete
///   building element in each intended usage indicated by the DefinitionType
///   attribute value. This set then defines a list of cross section properties in a
///   discrete number of longitudinal sections as instances of
///   IfcSectionReinforcementProperties (one for each structural reinforcement
///   bar role), which in turn have a section cross section property defined as a
///   profile and a number of reinforcement properties, one for each steel grade /
///   bar type.
class IFC_PARSE_API IfcReinforcementDefinitionProperties : public IfcPreDefinedPropertySet {
public:
    /// Whether the optional attribute DefinitionType is defined for this IfcReinforcementDefinitionProperties
    bool hasDefinitionType() const;
    /// Descriptive type name applied to reinforcement definition properties.
    std::string DefinitionType() const;
    void setDefinitionType(std::string v);
    /// The list of section reinforcement properties attached to the reinforcement definition properties.
    IfcTemplatedEntityList< IfcSectionReinforcementProperties >::ptr ReinforcementSectionDefinitions() const;
    void setReinforcementSectionDefinitions(IfcTemplatedEntityList< IfcSectionReinforcementProperties >::ptr v);
    virtual unsigned int getArgumentCount() const { return 6; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 4: return IfcUtil::Argument_STRING; case 5: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } return IfcPreDefinedPropertySet::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 4: return Type::IfcLabel; case 5: return Type::IfcSectionReinforcementProperties; } return IfcPreDefinedPropertySet::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 4: return "DefinitionType"; case 5: return "ReinforcementSectionDefinitions"; } return IfcPreDefinedPropertySet::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcReinforcementDefinitionProperties (IfcEntityInstanceData* e);
    IfcReinforcementDefinitionProperties (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_DefinitionType, IfcTemplatedEntityList< IfcSectionReinforcementProperties >::ptr v6_ReinforcementSectionDefinitions);
    typedef IfcTemplatedEntityList< IfcReinforcementDefinitionProperties > list;
};
/// The assignment relationship, IfcRelAssigns, is a generalization of "link" relationships among instances of IfcObject and its various 1st level subtypes. A link denotes the specific association through which one object (the client) applies the services of other objects (the suppliers), or through which one object may navigate to other objects.
/// 
/// The client is denoted as the relating object and is established at the level of the specific, instantiable subtypes of IfcRelAssigns. The suppliers are denoted as the related objects and they are established by the RelatedObjects attribute. 
/// 
/// NOTE: The terms "client" and "supplier" are used in a general concept and do not imply any meaning for implementations of systems (like client-server).
/// 
/// EXAMPLE: A resource may receive information about its nature of representing real building products by establishing a link between IfcResource and IfcBuildingElement (subtype of IfcProduct) through the assignment relationship IfcRelAssignsToResource. The resource is then the client that applies the services of other objects (here building elements) to express the particular view of elements to be consumed as a resource in a process.
/// 
/// The assignment relationship establishs a bi-directional relationship among the participating objects and does not imply any dependency. The subtypes of IfcRelAssigns establishes the particular semantic meaning of the assignment relationship.
/// 
/// HISTORY: New entity in IFC Release 2x.
class IFC_PARSE_API IfcRelAssigns : public IfcRelationship {
public:
    /// Related objects, which are assigned to a single object. The type of the single (or relating) object is defined in the subtypes of IfcRelAssigns.
    IfcTemplatedEntityList< IfcObjectDefinition >::ptr RelatedObjects() const;
    void setRelatedObjects(IfcTemplatedEntityList< IfcObjectDefinition >::ptr v);
    /// Whether the optional attribute RelatedObjectsType is defined for this IfcRelAssigns
    bool hasRelatedObjectsType() const;
    /// Particular type of the assignment relationship. It can constrain the applicable object types, used within the role of RelatedObjects.
    /// IFC2x4 CHANGE  The attribute is deprecated and shall no longer be used. A NIL value should always be assigned.
    IfcObjectTypeEnum::IfcObjectTypeEnum RelatedObjectsType() const;
    void setRelatedObjectsType(IfcObjectTypeEnum::IfcObjectTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 6; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 4: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 5: return IfcUtil::Argument_ENUMERATION; } return IfcRelationship::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 4: return Type::IfcObjectDefinition; case 5: return Type::IfcObjectTypeEnum; } return IfcRelationship::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 4: return "RelatedObjects"; case 5: return "RelatedObjectsType"; } return IfcRelationship::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRelAssigns (IfcEntityInstanceData* e);
    IfcRelAssigns (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcTemplatedEntityList< IfcObjectDefinition >::ptr v5_RelatedObjects, boost::optional< IfcObjectTypeEnum::IfcObjectTypeEnum > v6_RelatedObjectsType);
    typedef IfcTemplatedEntityList< IfcRelAssigns > list;
};
/// The objectified relationship IfcRelAssignsToActor handles the assignment of objects (subtypes of IfcObject) to an actor (subtypes of IfcActor).
/// 
/// The IfcRelAssignsToActor objectified relationship defines a relationship between an IfcActor and one or many objects. A particular role of the actor played in that relationship can be associated. If specified, it takes priority over the role that may be directly assigned to the person or organization.
/// 
/// EXAMPLE: An occupant (as an actor) may rent a flat (as a collection of spaces or a zone). This would be an application of this generic relationship.
/// 
/// Reference to the objects (or single object) on which the actor acts upon in a certain role (if given) is specified in the inherited RelatedObjects attribute.  
/// 
/// HISTORY New Entity in IFC Release 2.0. Has been renamed from IfcRelActsUpon in IFC Release 2x.
class IFC_PARSE_API IfcRelAssignsToActor : public IfcRelAssigns {
public:
    /// Reference to the information about the actor. It comprises the information about the person or organization and its addresses.
    IfcActor* RelatingActor() const;
    void setRelatingActor(IfcActor* v);
    /// Whether the optional attribute ActingRole is defined for this IfcRelAssignsToActor
    bool hasActingRole() const;
    /// Role of the actor played within the context of the assignment to the object(s).
    IfcActorRole* ActingRole() const;
    void setActingRole(IfcActorRole* v);
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 6: return IfcUtil::Argument_ENTITY_INSTANCE; case 7: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcRelAssigns::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 6: return Type::IfcActor; case 7: return Type::IfcActorRole; } return IfcRelAssigns::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 6: return "RelatingActor"; case 7: return "ActingRole"; } return IfcRelAssigns::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRelAssignsToActor (IfcEntityInstanceData* e);
    IfcRelAssignsToActor (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcTemplatedEntityList< IfcObjectDefinition >::ptr v5_RelatedObjects, boost::optional< IfcObjectTypeEnum::IfcObjectTypeEnum > v6_RelatedObjectsType, IfcActor* v7_RelatingActor, IfcActorRole* v8_ActingRole);
    typedef IfcTemplatedEntityList< IfcRelAssignsToActor > list;
};
/// The objectified relationship IfcRelAssignsToControl handles the assignment of a control (represented by subtypes of IfcControl) to other objects (represented by subtypes of IfcObject, with the exception of controls).
/// 
/// EXAMPLEÿ The assignment of a performance history (as subtype of IfcControl) for a building service element (as subtype of IfcObject) is an application of this generic relationship.
/// 
/// HISTORYÿ New Entity in IFC Release 2.0. Has been renamed from IfcRelControls in IFC Release 2x.
class IFC_PARSE_API IfcRelAssignsToControl : public IfcRelAssigns {
public:
    /// Reference to the IfcControl that applies a control upon objects.
    IfcControl* RelatingControl() const;
    void setRelatingControl(IfcControl* v);
    virtual unsigned int getArgumentCount() const { return 7; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 6: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcRelAssigns::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 6: return Type::IfcControl; } return IfcRelAssigns::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 6: return "RelatingControl"; } return IfcRelAssigns::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRelAssignsToControl (IfcEntityInstanceData* e);
    IfcRelAssignsToControl (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcTemplatedEntityList< IfcObjectDefinition >::ptr v5_RelatedObjects, boost::optional< IfcObjectTypeEnum::IfcObjectTypeEnum > v6_RelatedObjectsType, IfcControl* v7_RelatingControl);
    typedef IfcTemplatedEntityList< IfcRelAssignsToControl > list;
};
/// The objectified relationship IfcRelAssignsToGroup handles the assignment of object definitions (individual object occurrences as subtypes of IfcObject, and object types as subtypes of IfcTypeObject) to a group (subtypes of IfcGroup).
/// 
/// The relationship handles the assignment of group members to the group object. It allows for grouping arbitrary objects within a group, including other groups. The grouping relationship can be applied in a recursive manner. The resulting group is of type IfcGroup.
/// 
/// NOTE Examples of groups include zones as a grouping of spaces, distribution systems as a grouping of building service components, or structural analysis models as a grouping of structural items.
/// 
/// The inherited attribute RelatedObjects gives the references to the objects, which are the elements within the group. The RelatingGroup is the group that comprises all elements. The same object or object type can be included in zero, one or many groups. Grouping relationships are not hierarchical.
/// 
/// Informal proposition:
/// 
/// The group assignment relationship shall be acyclic, that is, a group shall not participate in its own grouping relationship.
/// 
/// HISTORY New entity in IFC Release 1.0. It has been renamed from IfcRelGroups in IFC Release 2x.
class IFC_PARSE_API IfcRelAssignsToGroup : public IfcRelAssigns {
public:
    /// Reference to group that contains all assigned group members.
    IfcGroup* RelatingGroup() const;
    void setRelatingGroup(IfcGroup* v);
    virtual unsigned int getArgumentCount() const { return 7; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 6: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcRelAssigns::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 6: return Type::IfcGroup; } return IfcRelAssigns::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 6: return "RelatingGroup"; } return IfcRelAssigns::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRelAssignsToGroup (IfcEntityInstanceData* e);
    IfcRelAssignsToGroup (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcTemplatedEntityList< IfcObjectDefinition >::ptr v5_RelatedObjects, boost::optional< IfcObjectTypeEnum::IfcObjectTypeEnum > v6_RelatedObjectsType, IfcGroup* v7_RelatingGroup);
    typedef IfcTemplatedEntityList< IfcRelAssignsToGroup > list;
};
/// The objectified relationship IfcRelAssignsToGroupByFactor is a specialization of the general grouping mechanism. It allows to add a factor to define the ratio that applies to the assignment of object definitions (individual object occurrences as subtypes of IfcObject and object types as subtypes of IfcTypeObject) to a group (subtypes of IfcGroup).
/// 
/// The ratio can be used to define a percentage assignment.  For example, a Factor of 0.8 would indicate that the object is assigned by 80% to the group, or a Factor of 2.5 would indicate the object is assigned with a weight factor of 2.5 to the group. 
/// 
/// NOTE Examples of factored groups include the assignment of load cases in a load combination in structural analysis, or the assignment of spaces by percentage to different rental zones.
/// 
/// The same object or object type may be included with the same or different Factor values to many groups. Grouping relationships are not hierarchical.
/// 
/// HISTORY New entity in IFC2x4.
class IFC_PARSE_API IfcRelAssignsToGroupByFactor : public IfcRelAssignsToGroup {
public:
    /// Factor provided as a ratio measure that identifies the fraction or weighted factor that applies to the group assignment.
    double Factor() const;
    void setFactor(double v);
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 7: return IfcUtil::Argument_DOUBLE; } return IfcRelAssignsToGroup::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 7: return Type::IfcRatioMeasure; } return IfcRelAssignsToGroup::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 7: return "Factor"; } return IfcRelAssignsToGroup::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRelAssignsToGroupByFactor (IfcEntityInstanceData* e);
    IfcRelAssignsToGroupByFactor (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcTemplatedEntityList< IfcObjectDefinition >::ptr v5_RelatedObjects, boost::optional< IfcObjectTypeEnum::IfcObjectTypeEnum > v6_RelatedObjectsType, IfcGroup* v7_RelatingGroup, double v8_Factor);
    typedef IfcTemplatedEntityList< IfcRelAssignsToGroupByFactor > list;
};
/// The objectified relationship IfcRelAssignsToProcess handles the assignment of one or many objects to a process or activity. An object can be a product that is the item the process operates on. Processes and activities can operate on things other than products, and can operate in ways other than input and output.
/// 
/// EXAMPLE It may be common to define processes
/// during estimating or scheduling that describe design tasks
/// (resulting in documents), procurement tasks (resulting in
/// construction materials), planning tasks (resulting in processes),
/// etc. Furthermore, the ways in which process can operate on
/// something might include "installs", "finishes", "transports",
/// "removes", etc. The ways are described as operation
/// types.
/// The inherited attribute RelatedObjects gives the
/// references to the objects, or object type, which the process
/// operates on. The RelatingProcess is the process or process
/// type, that operates on the object. The operation types are
/// captured in the inherited attribute Name.
/// NOTE The agreement on valid and recognizable
/// values for the Name attribute is part of view definitions
/// and implementer agreements.
/// 
/// HISTORY New entity in IFC Release 1.5. Has been renamed from IfcRelProcessOperatesOn in IFC Release 2x.
/// 
/// IFC2x4 CHANGE The data type RelatingProcess has been extended to cover also IfcTypeProcess
class IFC_PARSE_API IfcRelAssignsToProcess : public IfcRelAssigns {
public:
    /// Reference to the process to which the objects are assigned to.
    /// 
    /// IFC2x4 CHANGE Datatype expanded to include IfcProcess and IfcTypeProcess.
    IfcProcessSelect* RelatingProcess() const;
    void setRelatingProcess(IfcProcessSelect* v);
    /// Whether the optional attribute QuantityInProcess is defined for this IfcRelAssignsToProcess
    bool hasQuantityInProcess() const;
    /// Quantity of the object specific for the operation by this process.
    IfcMeasureWithUnit* QuantityInProcess() const;
    void setQuantityInProcess(IfcMeasureWithUnit* v);
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 6: return IfcUtil::Argument_ENTITY_INSTANCE; case 7: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcRelAssigns::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 6: return Type::IfcProcessSelect; case 7: return Type::IfcMeasureWithUnit; } return IfcRelAssigns::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 6: return "RelatingProcess"; case 7: return "QuantityInProcess"; } return IfcRelAssigns::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRelAssignsToProcess (IfcEntityInstanceData* e);
    IfcRelAssignsToProcess (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcTemplatedEntityList< IfcObjectDefinition >::ptr v5_RelatedObjects, boost::optional< IfcObjectTypeEnum::IfcObjectTypeEnum > v6_RelatedObjectsType, IfcProcessSelect* v7_RelatingProcess, IfcMeasureWithUnit* v8_QuantityInProcess);
    typedef IfcTemplatedEntityList< IfcRelAssignsToProcess > list;
};
/// The objectified relationshipÿIfcRelAssignsToProduct handles the assignment of objects (subtypes of IfcObject) to a product (subtypes of IfcProduct). The Name attribute should be used to classify the usage of the IfcRelAssignsToProduct objectified relationship. The following Name values are proposed:
/// 
/// 'Context' : Assignment of a context specific representation, such as of structural members to a different context representation (with potentially different decomposition breakdown) such as of building elementsÿfor a specificÿcontext specific representation.ÿ
/// 'View' : Assignment of a product (via RelatingProduct) that is decomposed according to a discipline view, to another product (via RelatedObjects) that is decomposed according to a different discipline view. An example is the assignment of the architectural slab to a different decomposition of the pre manufactured sections of a slab (under a precast concrete discipline view).
/// 
/// HISTORY New Entity in IFC Release 2x
/// 
/// IFC2x3 CHANGE ÿThe reference of a product within a spatial structure is now handled by a new relationship object IfcRelReferencedInSpatialStructure. The IfcRelAssignsToProduct shall not be used to represent this relation from IFC2x3 onwards.
class IFC_PARSE_API IfcRelAssignsToProduct : public IfcRelAssigns {
public:
    /// Reference to the product or product type to which the objects are assigned to.
    /// 
    /// IFC2x4 CHANGE Datatype expanded to include IfcProduct and IfcTypeProduct.
    IfcProductSelect* RelatingProduct() const;
    void setRelatingProduct(IfcProductSelect* v);
    virtual unsigned int getArgumentCount() const { return 7; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 6: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcRelAssigns::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 6: return Type::IfcProductSelect; } return IfcRelAssigns::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 6: return "RelatingProduct"; } return IfcRelAssigns::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRelAssignsToProduct (IfcEntityInstanceData* e);
    IfcRelAssignsToProduct (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcTemplatedEntityList< IfcObjectDefinition >::ptr v5_RelatedObjects, boost::optional< IfcObjectTypeEnum::IfcObjectTypeEnum > v6_RelatedObjectsType, IfcProductSelect* v7_RelatingProduct);
    typedef IfcTemplatedEntityList< IfcRelAssignsToProduct > list;
};
/// The objectified relationship IfcRelAssignsToResource handles the assignment of objects
/// (as subtypes of IfcObject), acting as a resource usage or consumption, to a resource (as subtypes of IfcResource).
/// 
/// EXAMPLE The assignment of a resource usage to a construction resource is an application of this generic relationship. It could be an actor, as person or organization assigned to a labor resource, or a raw product assigned to a construction product or material resource).
/// 
/// HISTORY New Entity in IFC Release 2x.
class IFC_PARSE_API IfcRelAssignsToResource : public IfcRelAssigns {
public:
    /// Reference to the resource to which the objects are assigned to.
    /// 
    /// IFC2x4 CHANGE Datatype expanded to include IfcResource and IfcTypeResource.
    IfcResourceSelect* RelatingResource() const;
    void setRelatingResource(IfcResourceSelect* v);
    virtual unsigned int getArgumentCount() const { return 7; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 6: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcRelAssigns::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 6: return Type::IfcResourceSelect; } return IfcRelAssigns::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 6: return "RelatingResource"; } return IfcRelAssigns::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRelAssignsToResource (IfcEntityInstanceData* e);
    IfcRelAssignsToResource (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcTemplatedEntityList< IfcObjectDefinition >::ptr v5_RelatedObjects, boost::optional< IfcObjectTypeEnum::IfcObjectTypeEnum > v6_RelatedObjectsType, IfcResourceSelect* v7_RelatingResource);
    typedef IfcTemplatedEntityList< IfcRelAssignsToResource > list;
};
/// The association relationship
///   IfcRelAssociates refers to external sources of
///   information (most notably a classification, library or
///   document). There is no dependency implied by the
///   association.
/// 
/// EXAMPLE Further information may be given
///   to the tank equipment (as subtype of IfcProduct) in
///   terms of its classification and instruction documents, the
///   source of the additional information is held external to
///   the IFC project model.
/// 
/// Association relationships can be established to objects
///   (occurrences as subtypes of IfcObject) or to types 
///   (as subtypes of IfcTypeObject).
/// 
/// EXAMPLE 1  The classification information
///   for the storage tank equipment may be associated to the
///   IfcTankType (subtype of IfcTypeObject),
///   defining the specific information for all occurencies of
///   that tank in the project. Therefore the association of the
///   (e.g.) Uniclass notation 'L6814' may be associated by a
///   subtype of IfcRelAssociates to the type
///   information.
/// 
/// EXAMPLE 2  The classification information
///   for a particular space within a building may the associated
///   to the IfcSpace object (subtype of
///   IfcObject), defining a particular occurrence of
///   space. Therefore the association of the (e.g.) DIN notation
///   'HNF 1.5' may be associated by a subtype of
///   IfcRelAssociates to the object.
/// 
/// The association relationship establishs a uni-directional
///   association. The subtypes of IfcRelAssociates
///   establishes the particular semantic meaning of the
///   association relationship.
/// 
/// HISTORY New entity in IFC Release 2x.
/// 
/// IFC2x4 CHANGE Entity has been changed into an ABSTRACT supertype
class IFC_PARSE_API IfcRelAssociates : public IfcRelationship {
public:
    /// Set of object or property definitions to which the external references or information is associated. It includes object and type objects, property set templates, property templates and property sets and contexts.
    /// 
    /// IFC2x4 CHANGE  The attribute datatype has been changed from IfcRoot to IfcDefinitionSelect.
    IfcEntityList::ptr RelatedObjects() const;
    void setRelatedObjects(IfcEntityList::ptr v);
    virtual unsigned int getArgumentCount() const { return 5; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 4: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } return IfcRelationship::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 4: return Type::IfcDefinitionSelect; } return IfcRelationship::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 4: return "RelatedObjects"; } return IfcRelationship::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRelAssociates (IfcEntityInstanceData* e);
    IfcRelAssociates (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcEntityList::ptr v5_RelatedObjects);
    typedef IfcTemplatedEntityList< IfcRelAssociates > list;
};
/// The entity IfcRelAssociatesApproval is used to apply approval information defined by IfcApproval, in IfcApprovalResource schema, to subtypes of IfcRoot.
/// 
/// HISTORY: New entity in IFC2x2.
class IFC_PARSE_API IfcRelAssociatesApproval : public IfcRelAssociates {
public:
    /// Reference to approval that is being applied using this relationship.
    IfcApproval* RelatingApproval() const;
    void setRelatingApproval(IfcApproval* v);
    virtual unsigned int getArgumentCount() const { return 6; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 5: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcRelAssociates::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 5: return Type::IfcApproval; } return IfcRelAssociates::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 5: return "RelatingApproval"; } return IfcRelAssociates::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRelAssociatesApproval (IfcEntityInstanceData* e);
    IfcRelAssociatesApproval (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcEntityList::ptr v5_RelatedObjects, IfcApproval* v6_RelatingApproval);
    typedef IfcTemplatedEntityList< IfcRelAssociatesApproval > list;
};
/// The objectified relationship
/// IfcRelAssociatesClassification handles the assignment of a
/// classification item (items of the select
/// IfcClassificationSelect) to objects occurrences (subtypes of
/// IfcObject) or object types (subtypes of
/// IfcTypeObject).
/// The relationship is used to assign a classification item, or a
/// classification system itself to objects. Depending on the type of
/// the RelatingClassification it is either:
/// 
/// a reference to an classification item within an external
/// classification system, or
/// a reference to the classification system itself
/// 
/// NOTE  The reference to a classification item
/// includes a link to the classification system within which the item
/// is declared. It assigns the meaning of the classification item to
/// the object (ocurrence or type). The reference to the classification
/// system provides the information that the object (occurrence or
/// type) is governed by the classification system but no assignment of
/// a particular items has been done yet.
/// 
/// The inherited attribute RelatedObjects define the objects
/// or object types to which the classification is applied. The
/// attribute RelatingClassification is the reference to a
/// classification, applied to the object(s). A single
/// RelatingClassification can thereby be applied to one or
/// multiple objects.
/// 
/// HISTORY New entity in IFC Release 2x.
class IFC_PARSE_API IfcRelAssociatesClassification : public IfcRelAssociates {
public:
    /// Classification applied to the objects.
    IfcClassificationSelect* RelatingClassification() const;
    void setRelatingClassification(IfcClassificationSelect* v);
    virtual unsigned int getArgumentCount() const { return 6; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 5: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcRelAssociates::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 5: return Type::IfcClassificationSelect; } return IfcRelAssociates::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 5: return "RelatingClassification"; } return IfcRelAssociates::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRelAssociatesClassification (IfcEntityInstanceData* e);
    IfcRelAssociatesClassification (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcEntityList::ptr v5_RelatedObjects, IfcClassificationSelect* v6_RelatingClassification);
    typedef IfcTemplatedEntityList< IfcRelAssociatesClassification > list;
};
/// The entity IfcRelAssociatesConstraint is used to apply constraint information defined by IfcConstraint, in the IfcConstraintResource schema, to subtypes of IfcRoot.
/// 
/// HISTORY: New entity in IFC2x2.
class IFC_PARSE_API IfcRelAssociatesConstraint : public IfcRelAssociates {
public:
    /// Whether the optional attribute Intent is defined for this IfcRelAssociatesConstraint
    bool hasIntent() const;
    /// The intent of the constraint usage with regard to its related IfcConstraint and IfcObjects, IfcPropertyDefinitions or IfcRelationships. Typical values can be e.g. RATIONALE or EXPECTED PERFORMANCE.
    std::string Intent() const;
    void setIntent(std::string v);
    /// Reference to constraint that is being applied using this relationship.
    IfcConstraint* RelatingConstraint() const;
    void setRelatingConstraint(IfcConstraint* v);
    virtual unsigned int getArgumentCount() const { return 7; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 5: return IfcUtil::Argument_STRING; case 6: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcRelAssociates::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 5: return Type::IfcLabel; case 6: return Type::IfcConstraint; } return IfcRelAssociates::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 5: return "Intent"; case 6: return "RelatingConstraint"; } return IfcRelAssociates::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRelAssociatesConstraint (IfcEntityInstanceData* e);
    IfcRelAssociatesConstraint (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcEntityList::ptr v5_RelatedObjects, boost::optional< std::string > v6_Intent, IfcConstraint* v7_RelatingConstraint);
    typedef IfcTemplatedEntityList< IfcRelAssociatesConstraint > list;
};
/// The objectified relationship (IfcRelAssociatesDocument) handles the assignment of a document information (items of the select IfcDocumentSelect) to objects occurrences (subtypes of IfcObject) or object types (subtypes of IfcTypeObject).
/// 
/// The relationship is used to assign a document reference or a more detailed document information to objects. A single document reference can be applied to multiple objects.
/// 
/// The inherited attribute RelatedObjects define the objects to which the document association is applied. The attribute RelatingDocument is the reference to a document reference, applied to the object(s). 
/// 
/// HISTORY: New entity in IFC Release 2x.
class IFC_PARSE_API IfcRelAssociatesDocument : public IfcRelAssociates {
public:
    /// Document information or reference which is applied to the objects.
    IfcDocumentSelect* RelatingDocument() const;
    void setRelatingDocument(IfcDocumentSelect* v);
    virtual unsigned int getArgumentCount() const { return 6; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 5: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcRelAssociates::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 5: return Type::IfcDocumentSelect; } return IfcRelAssociates::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 5: return "RelatingDocument"; } return IfcRelAssociates::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRelAssociatesDocument (IfcEntityInstanceData* e);
    IfcRelAssociatesDocument (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcEntityList::ptr v5_RelatedObjects, IfcDocumentSelect* v6_RelatingDocument);
    typedef IfcTemplatedEntityList< IfcRelAssociatesDocument > list;
};
/// The objectified relationship (IfcRelAssociatesLibrary) handles the assignment of a library item (items of the select IfcLibrarySelect) to subtypes of IfcObjectDefinition or IfcPropertyDefinition. 
/// 
/// The relationship is used to assign a library reference or a more detailed link to a library information to objects, property sets or types. A single library reference can be applied to multiple items. 
/// 
/// The inherited attribute RelatedObjects define the items to which the library association is applied. The attribute RelatingLibrary is the reference to a library reference, applied to the item(s). 
/// 
/// HISTORY: New entity in IFC Release 2x.
class IFC_PARSE_API IfcRelAssociatesLibrary : public IfcRelAssociates {
public:
    /// Reference to a library, from which the definition of the property set is taken.
    IfcLibrarySelect* RelatingLibrary() const;
    void setRelatingLibrary(IfcLibrarySelect* v);
    virtual unsigned int getArgumentCount() const { return 6; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 5: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcRelAssociates::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 5: return Type::IfcLibrarySelect; } return IfcRelAssociates::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 5: return "RelatingLibrary"; } return IfcRelAssociates::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRelAssociatesLibrary (IfcEntityInstanceData* e);
    IfcRelAssociatesLibrary (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcEntityList::ptr v5_RelatedObjects, IfcLibrarySelect* v6_RelatingLibrary);
    typedef IfcTemplatedEntityList< IfcRelAssociatesLibrary > list;
};
/// Definition from IAI: Objectified relationship between a
/// material definition and elements or element types to which this
/// material definition applies.
/// The material definition can be:
/// 
/// assigned to an element occurrence as a specific usage of a
/// layer set or profile set
/// assigned to an element occurrence or element type as a layer
/// set, profile set, constituent set or a single material
/// 
/// Materials can be arranged by layers and applied to layered
/// elements. Typical elements are walls and slabs.
/// 
/// An IfcMaterialLayerSet, for layered elements with an
/// indication of the layering direction and individual layer
/// thicknesses
/// An IfcMaterialLayerSetUsage, i.e. a material layer set
/// with positioning information along the reference axis or surface
/// of the element.
/// NOTE As a material layer set usage is an
/// occurrence based information, that applies to each individual
/// element, it cannot be assigned to an element
/// type.
/// 
/// Material can be applied to profiles. Typical elements using
/// profile material are beam, column, member
/// 
/// An IfcMaterialProfileSet, i.e. a set of material
/// assigned to a set of profiles, with a single material assigned to
/// a single profile as the default.
/// An IfcMaterialProfileSetUsage, i.e. a material profile
/// set with positioning information relative to the element axis,
/// also refered to as cardinal point.
/// NOTE As a material profile set usage is an
/// occurrence based information, that applies to each individual
/// element, it cannot be assigned to an element
/// type.
/// 
/// Materials can be arranged by identified parts of a component
/// based element. Typical elements are dorrs/windows (with
/// components such as lining, framing and glazing), or distribution
/// elements.
/// 
/// An IfcMaterialConstituentSet, for component based
/// elements with an indication of the component by keyword to which
/// the material consituent applies.
/// NOTE See the material use definitions at each
/// applicable subtype of IfcElement or IfcElementType
/// for a provision of these keywords.
/// 
/// As a fallback, or in cases where only a single material
/// information is needed, material information can be directly
/// associated
/// 
/// A single IfcMaterial for any element where the
/// material use definition does not prohibits its direct
/// association
/// An IfcMaterialList, e.g. for composite elements,
/// without an information, how the different materials are arranged.
/// NOTE The use of
/// IfcMaterialList is deprecated in IFC2x4 onwards. Use
/// IfcMaterialConstituentSet
/// instead.
/// 
/// The IfcRelAssociatesMaterial relationship is a special
/// type of the IfcRelAssociates relationship. It can be
/// applied to subtypes of IfcElement and subtypes of
/// IfcElementType.
/// 
/// The IfcElement has an inverse relation to its material
/// definition by the HasAssociations attribute, inherited
/// from IfcObject.
/// The IfcElementType has an inverse relation to its
/// material definition by the HasAssociations attribute,
/// inherited from IfcPropertyDefinition.
/// 
/// If both, the element occurrence (by an instance of
/// IfcElement) and the element type (by an instance of
/// IfcElementType, connected through
/// IfcRelDefinesByType) have an associated material, then the
/// material associated to the element occurrence overrides the
/// material associated to the element type.
/// 
/// HISTORY New entity in IFC Release
/// 2.x.
/// 
/// Informal proposition
/// 
/// An IfcMaterialLayerSetUsage shall not be associated
/// with a subtype of IfcElementType, it should only be
/// associated with individual occurrences
/// An IfcMaterialProfileSetUsage shall not be associated
/// with a subtype of IfcElementType, it should only be
/// associated with individual occurrences
class IFC_PARSE_API IfcRelAssociatesMaterial : public IfcRelAssociates {
public:
    /// Material definition assigned to the elements or element types.
    IfcMaterialSelect* RelatingMaterial() const;
    void setRelatingMaterial(IfcMaterialSelect* v);
    virtual unsigned int getArgumentCount() const { return 6; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 5: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcRelAssociates::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 5: return Type::IfcMaterialSelect; } return IfcRelAssociates::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 5: return "RelatingMaterial"; } return IfcRelAssociates::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRelAssociatesMaterial (IfcEntityInstanceData* e);
    IfcRelAssociatesMaterial (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcEntityList::ptr v5_RelatedObjects, IfcMaterialSelect* v6_RelatingMaterial);
    typedef IfcTemplatedEntityList< IfcRelAssociatesMaterial > list;
};
/// IfcRelConnects is a connectivity relationship that connects objects under some criteria. As a general connectivity it does not imply constraints, however subtypes of the relationship define the applicable object types for the connectivity relationship and the semantics of the particular connectivity. 
/// 
/// HISTORY: New entity in IFC Release 2x.
class IFC_PARSE_API IfcRelConnects : public IfcRelationship {
public:
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcRelationship::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcRelationship::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcRelationship::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRelConnects (IfcEntityInstanceData* e);
    IfcRelConnects (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description);
    typedef IfcTemplatedEntityList< IfcRelConnects > list;
};
/// Definition from IAI: The
///   IfcRelConnectsElements objectified relationship
///   provides the generalization of the connectivity between
///   elements. It is a 1 to 1 relationship. The concept of two
///   elements being physically or logically connected is
///   described independently from the connecting elements. The
///   connectivity may be related to the shape representation of
///   the connected entities by providing a connection geometry.
/// 
/// In this case the geometrical constraints of the
///   connection are provided by the optional relationship to the
///   IfcConnectionGeometry. The connection geometry is
///   provided as a point, curve or surface within the local
///   placement coordinate systems of the connecting elements.
/// 
/// If the connection geometry is omitted then the
///   connection is provided as a logical connection. Under this
///   circumstance, the connection point, curve or surface has to
///   be recalculated by the receiving application.
/// 
/// HISTORY New entity in IFC
///   Release 1.0.
class IFC_PARSE_API IfcRelConnectsElements : public IfcRelConnects {
public:
    /// Whether the optional attribute ConnectionGeometry is defined for this IfcRelConnectsElements
    bool hasConnectionGeometry() const;
    /// The geometric shape representation of the connection geometry that is provided in the object coordinate system of the RelatingElement (mandatory) and in the object coordinate system of the RelatedElement (optionally).
    IfcConnectionGeometry* ConnectionGeometry() const;
    void setConnectionGeometry(IfcConnectionGeometry* v);
    /// Reference to a subtype of IfcElement that is connected by the connection relationship in the role of RelatingElement.
    IfcElement* RelatingElement() const;
    void setRelatingElement(IfcElement* v);
    /// Reference to a subtype of IfcElement that is connected by the connection relationship in the role of RelatedElement.
    IfcElement* RelatedElement() const;
    void setRelatedElement(IfcElement* v);
    virtual unsigned int getArgumentCount() const { return 7; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 4: return IfcUtil::Argument_ENTITY_INSTANCE; case 5: return IfcUtil::Argument_ENTITY_INSTANCE; case 6: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcRelConnects::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 4: return Type::IfcConnectionGeometry; case 5: return Type::IfcElement; case 6: return Type::IfcElement; } return IfcRelConnects::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 4: return "ConnectionGeometry"; case 5: return "RelatingElement"; case 6: return "RelatedElement"; } return IfcRelConnects::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRelConnectsElements (IfcEntityInstanceData* e);
    IfcRelConnectsElements (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcConnectionGeometry* v5_ConnectionGeometry, IfcElement* v6_RelatingElement, IfcElement* v7_RelatedElement);
    typedef IfcTemplatedEntityList< IfcRelConnectsElements > list;
};
/// The
/// IfcRelConnectsPathElements relationship provides the connectivity information between two elements, which have path information.
/// 
/// The objectified relationship provides the additional
/// information required to describe the connection between two path
/// based elements that might have single or multiple layers of
/// material. The connection type specifies where at the path based
/// element a connection is given (at the start, in the middle or at
/// the end).
/// 
/// The connection is described by a connection geometry, given
/// within the object coordinate systems of the
/// RelatingElement and of the RelatedElement. In case
/// of IfcWallStandardCase as the RelatingElement and
/// RelatedElement the connection geometry is provided by the
/// subtype IfcConnectionCurveGeometry. Both curves indicate
/// the so called "end cap", i.e. the curve that trims the wall outer
/// edges (being parallel along the wall axis) at the end.
/// HISTORY New entity in IFC Release 1.5.
/// 
/// Figure 115 shows the application of IfcRelConnectsPathElements with the ConnectionGeometry of type IfcConnectionCurveGeometry. The example shows the connection relationship between two instances of IfcWallStandardCase using the IfcRelConnectsPathElements relationship. The ConnectionCurveGeometry defines the CurveOnReleatingElement and CurveOnRelatedElement, both are of type IfcPolyline.
/// 
/// Figure 115 — Path connection geometry
/// 
/// Figure 116 illustrates using the IfcRelConnectsPathElements for a "T" type connection between two instances of IfcWallStandardCase.
/// Figure 117 illustrates using the IfcRelConnectsPathElements for a "L" type connection between two instances of IfcWallStandardCase.
/// NOTE  The two wall axes connect in each case.
/// 
/// ÿ
/// 
/// Figure 116 — Path connection T-Type
/// Figure 117 — Path connection L-Type
class IFC_PARSE_API IfcRelConnectsPathElements : public IfcRelConnectsElements {
public:
    /// Priorities for connection. It refers to the layers of the RelatingObject.
    std::vector< int > /*[0:?]*/ RelatingPriorities() const;
    void setRelatingPriorities(std::vector< int > /*[0:?]*/ v);
    /// Priorities for connection. It refers to the layers of the RelatedObject.
    std::vector< int > /*[0:?]*/ RelatedPriorities() const;
    void setRelatedPriorities(std::vector< int > /*[0:?]*/ v);
    /// Indication of the connection type in relation to the path of the RelatingObject.
    IfcConnectionTypeEnum::IfcConnectionTypeEnum RelatedConnectionType() const;
    void setRelatedConnectionType(IfcConnectionTypeEnum::IfcConnectionTypeEnum v);
    /// Indication of the connection type in relation to the path of the RelatingObject.
    IfcConnectionTypeEnum::IfcConnectionTypeEnum RelatingConnectionType() const;
    void setRelatingConnectionType(IfcConnectionTypeEnum::IfcConnectionTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 11; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 7: return IfcUtil::Argument_AGGREGATE_OF_INT; case 8: return IfcUtil::Argument_AGGREGATE_OF_INT; case 9: return IfcUtil::Argument_ENUMERATION; case 10: return IfcUtil::Argument_ENUMERATION; } return IfcRelConnectsElements::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 7: return Type::IfcInteger; case 8: return Type::IfcInteger; case 9: return Type::IfcConnectionTypeEnum; case 10: return Type::IfcConnectionTypeEnum; } return IfcRelConnectsElements::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 7: return "RelatingPriorities"; case 8: return "RelatedPriorities"; case 9: return "RelatedConnectionType"; case 10: return "RelatingConnectionType"; } return IfcRelConnectsElements::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRelConnectsPathElements (IfcEntityInstanceData* e);
    IfcRelConnectsPathElements (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcConnectionGeometry* v5_ConnectionGeometry, IfcElement* v6_RelatingElement, IfcElement* v7_RelatedElement, std::vector< int > /*[0:?]*/ v8_RelatingPriorities, std::vector< int > /*[0:?]*/ v9_RelatedPriorities, IfcConnectionTypeEnum::IfcConnectionTypeEnum v10_RelatedConnectionType, IfcConnectionTypeEnum::IfcConnectionTypeEnum v11_RelatingConnectionType);
    typedef IfcTemplatedEntityList< IfcRelConnectsPathElements > list;
};
/// The objectified relationship
/// IfcRelConnectsPortToElement defines the relationship that
/// is made between a port and the IfcElement, or
/// IfcElementType in which it is contained. It is a 1 to 1
/// relationship.
/// 
/// The
/// IfcRelConnectsPortToElement established a whole part
/// relationship between the element and its port. The port is used as
/// the means to connect to other ports in other elements. Since both,
/// the element-to-port, and the port-to-port relationships are 1:1
/// relationships, a topological system (or system path or ciruit) can
/// be defined.
/// 
/// Ports contained in different elements are connected to each
/// other using the IfcRelConnectsPorts relationship.
/// 
/// See relevant subtypes of
/// IfcDistributionElement for examples and port use
/// definition sections.
/// 
/// HISTORY  New
/// entity in Release IFC2x Edition 2.
/// IFC2x4 CHANGE  The
/// definition has been extended to include element types.
class IFC_PARSE_API IfcRelConnectsPortToElement : public IfcRelConnects {
public:
    /// Reference to an Port that is connected by the objectified relationship.
    IfcPort* RelatingPort() const;
    void setRelatingPort(IfcPort* v);
    /// Reference to an IfcElement, or IfcElementType that has ports assigned.
    /// 
    /// IFC2x4 CHANGE  Data type extended to IfcObjectDefinition to enable elements and element types for the port relationship.
    IfcDistributionElement* RelatedElement() const;
    void setRelatedElement(IfcDistributionElement* v);
    virtual unsigned int getArgumentCount() const { return 6; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 4: return IfcUtil::Argument_ENTITY_INSTANCE; case 5: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcRelConnects::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 4: return Type::IfcPort; case 5: return Type::IfcDistributionElement; } return IfcRelConnects::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 4: return "RelatingPort"; case 5: return "RelatedElement"; } return IfcRelConnects::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRelConnectsPortToElement (IfcEntityInstanceData* e);
    IfcRelConnectsPortToElement (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcPort* v5_RelatingPort, IfcDistributionElement* v6_RelatedElement);
    typedef IfcTemplatedEntityList< IfcRelConnectsPortToElement > list;
};
/// Definition from IAI: An IfcRelConnectsPorts
///   defines the relationship that is made between two ports at
///   their point of connection. It may include the connection
///   geometry between two ports.
/// 
/// IfcRelConnectsPorts is required for defining how
///   instances of IfcPort connect together. Each of the
///   port is being logically attached to the IfcElement
///   by using the IfcRelConnectsPortToElement
///   relationship.
/// 
/// HISTORY New entity in IFC
///   2.0, modified in IFC2x.
class IFC_PARSE_API IfcRelConnectsPorts : public IfcRelConnects {
public:
    /// Reference to the first port that is connected by the objectified relationship.
    IfcPort* RelatingPort() const;
    void setRelatingPort(IfcPort* v);
    /// Reference to the second port that is connected by the objectified relationship.
    IfcPort* RelatedPort() const;
    void setRelatedPort(IfcPort* v);
    /// Whether the optional attribute RealizingElement is defined for this IfcRelConnectsPorts
    bool hasRealizingElement() const;
    /// Defines the element that realizes a port connection relationship.
    IfcElement* RealizingElement() const;
    void setRealizingElement(IfcElement* v);
    virtual unsigned int getArgumentCount() const { return 7; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 4: return IfcUtil::Argument_ENTITY_INSTANCE; case 5: return IfcUtil::Argument_ENTITY_INSTANCE; case 6: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcRelConnects::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 4: return Type::IfcPort; case 5: return Type::IfcPort; case 6: return Type::IfcElement; } return IfcRelConnects::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 4: return "RelatingPort"; case 5: return "RelatedPort"; case 6: return "RealizingElement"; } return IfcRelConnects::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRelConnectsPorts (IfcEntityInstanceData* e);
    IfcRelConnectsPorts (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcPort* v5_RelatingPort, IfcPort* v6_RelatedPort, IfcElement* v7_RealizingElement);
    typedef IfcTemplatedEntityList< IfcRelConnectsPorts > list;
};
/// Definition from IAI: The IfcRelConnectsStructuralActivity relationship connects a structural activity (either an action or reaction) to a structural member, structural connection, or element.
/// 
/// HISTORY: New entity in IFC 2x2.
class IFC_PARSE_API IfcRelConnectsStructuralActivity : public IfcRelConnects {
public:
    /// Reference to a structural item or element to which the specified activity is applied.
    IfcStructuralActivityAssignmentSelect* RelatingElement() const;
    void setRelatingElement(IfcStructuralActivityAssignmentSelect* v);
    /// Reference to a structural activity which is acting upon the specified structural item or element.
    IfcStructuralActivity* RelatedStructuralActivity() const;
    void setRelatedStructuralActivity(IfcStructuralActivity* v);
    virtual unsigned int getArgumentCount() const { return 6; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 4: return IfcUtil::Argument_ENTITY_INSTANCE; case 5: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcRelConnects::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 4: return Type::IfcStructuralActivityAssignmentSelect; case 5: return Type::IfcStructuralActivity; } return IfcRelConnects::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 4: return "RelatingElement"; case 5: return "RelatedStructuralActivity"; } return IfcRelConnects::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRelConnectsStructuralActivity (IfcEntityInstanceData* e);
    IfcRelConnectsStructuralActivity (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcStructuralActivityAssignmentSelect* v5_RelatingElement, IfcStructuralActivity* v6_RelatedStructuralActivity);
    typedef IfcTemplatedEntityList< IfcRelConnectsStructuralActivity > list;
};
/// The entity IfcRelConnectsStructuralMember defines all needed properties describing the connection between structural members and structural connection objects (nodes or supports).
/// 
/// HISTORY  New entity in IFC2x2.
/// 
/// Use Definition
/// 
/// Point Connection
/// Instances of the entity IfcRelConnectsStructuralMember shall be used to describe a connection between an instance of IfcStructuralPointConnection and either an instance of IfcStructuralCurveMember or IfcStructuralSurfaceMember.  The RelatedStructuralConnection for point connections has to be of type IfcStructuralPointConnection.
/// 
/// Curve Connection
/// Instances of the entity IfcRelConnectsStructuralMember shall be used to describe a connection between an instance of IfcStructuralCurveConnection and an instance of either IfcStructuralCurveMember or IfcStructuralSurfaceMember.  The RelatedStructuralConnection for curve connections has to be of type IfcStructuralCurveConnection.
/// 
/// Surface Connection
/// Instances of the entity IfcRelConnectsStructuralMember shall be used to describe a connection between an instance of IfcStructuralSurfaceConnection and an instance of IfcStructuralSurfaceMember.  The RelatedStructuralConnection for curve connections has to be of type IfcStructuralSurfaceConnection.
/// 
/// Coordinate System for Applied Conditions
/// All values defined by AppliedCondition or AdditionalConditions are given within the coordinate system provided by ConditionCoordinateSystem, which is defined relative to the local coordinate system of the structural member.  If the ConditionCoordinateSystem is not defined, the local coordinate system of the structural member is used instead.
/// 
/// Supported Length
/// Optionally a supported length can be given, which specifies the length (or width) of the physical connection along a curve connection.
/// 
/// Figure 235 illustrates the appropriate definition of support lengths.
/// 
/// Figure 235 — Structural member support lengths
class IFC_PARSE_API IfcRelConnectsStructuralMember : public IfcRelConnects {
public:
    /// Reference to an instance of IfcStructuralMember (or its subclasses) which is connected to the specified structural connection.
    IfcStructuralMember* RelatingStructuralMember() const;
    void setRelatingStructuralMember(IfcStructuralMember* v);
    /// Reference to an instance of IfcStructuralConnection (or its subclasses) which is connected to the specified structural member.
    IfcStructuralConnection* RelatedStructuralConnection() const;
    void setRelatedStructuralConnection(IfcStructuralConnection* v);
    /// Whether the optional attribute AppliedCondition is defined for this IfcRelConnectsStructuralMember
    bool hasAppliedCondition() const;
    /// Conditions which define the connections properties.  Connection conditions are often called "release" but are not only used to define mechanisms like hinges but also rigid, elastic, and other conditions.
    IfcBoundaryCondition* AppliedCondition() const;
    void setAppliedCondition(IfcBoundaryCondition* v);
    /// Whether the optional attribute AdditionalConditions is defined for this IfcRelConnectsStructuralMember
    bool hasAdditionalConditions() const;
    /// Describes additional connection properties.
    IfcStructuralConnectionCondition* AdditionalConditions() const;
    void setAdditionalConditions(IfcStructuralConnectionCondition* v);
    /// Whether the optional attribute SupportedLength is defined for this IfcRelConnectsStructuralMember
    bool hasSupportedLength() const;
    /// Defines the 'supported length' of this structural connection. See Fig. for more detail.
    double SupportedLength() const;
    void setSupportedLength(double v);
    /// Whether the optional attribute ConditionCoordinateSystem is defined for this IfcRelConnectsStructuralMember
    bool hasConditionCoordinateSystem() const;
    /// Defines a coordinate system used for the description of the connection properties in ConnectionCondition relative to the local coordinate system of RelatingStructuralMember.  If left unspecified, the placement IfcAxis2Placement3D((x,y,z), ?, ?) is implied with x,y,z being the local member coordinates where the connection is made and the default axes directions being in parallel with the local axes of RelatingStructuralMember.
    IfcAxis2Placement3D* ConditionCoordinateSystem() const;
    void setConditionCoordinateSystem(IfcAxis2Placement3D* v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 4: return IfcUtil::Argument_ENTITY_INSTANCE; case 5: return IfcUtil::Argument_ENTITY_INSTANCE; case 6: return IfcUtil::Argument_ENTITY_INSTANCE; case 7: return IfcUtil::Argument_ENTITY_INSTANCE; case 8: return IfcUtil::Argument_DOUBLE; case 9: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcRelConnects::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 4: return Type::IfcStructuralMember; case 5: return Type::IfcStructuralConnection; case 6: return Type::IfcBoundaryCondition; case 7: return Type::IfcStructuralConnectionCondition; case 8: return Type::IfcLengthMeasure; case 9: return Type::IfcAxis2Placement3D; } return IfcRelConnects::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 4: return "RelatingStructuralMember"; case 5: return "RelatedStructuralConnection"; case 6: return "AppliedCondition"; case 7: return "AdditionalConditions"; case 8: return "SupportedLength"; case 9: return "ConditionCoordinateSystem"; } return IfcRelConnects::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRelConnectsStructuralMember (IfcEntityInstanceData* e);
    IfcRelConnectsStructuralMember (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcStructuralMember* v5_RelatingStructuralMember, IfcStructuralConnection* v6_RelatedStructuralConnection, IfcBoundaryCondition* v7_AppliedCondition, IfcStructuralConnectionCondition* v8_AdditionalConditions, boost::optional< double > v9_SupportedLength, IfcAxis2Placement3D* v10_ConditionCoordinateSystem);
    typedef IfcTemplatedEntityList< IfcRelConnectsStructuralMember > list;
};
/// Definition from IAI: The entity IfcRelConnectsWithEccentricity adds the definition of eccentricity to the connection between a structural member and a structural connection (representing either a node or support).
/// 
/// NOTE   Another eccentricity model is available independently of eccentric connection specification:  The section profile of a curve member may be inserted eccentrically with respect to the member's reference curve, see definitions at IfcStructuralCurveMember.  Whether one or the other or both eccentricity models may be used is subject to information requirements and local agreements.
/// 
/// HISTORY  New entity in IFC 2x3.
/// Use definitions changed in IFC 2x4 to always require two topology items.
/// 
/// Use Definition
/// 
/// Point Connection
/// ConnectionConstraint shall be of type IfcConnectionPointGeometry and shall refer to two instances of IfcVertexPoint.
/// 
/// Curve Connection
/// ConnectionConstraint shall be of type IfcConnectionCurveGeometry and shall refer to two instances of IfcEdge or subtypes.
/// 
/// Surface Connection
/// ConnectionConstraint shall be of type IfcConnectionSurfaceGeometry and shall refer to two instances of IfcFaceSurface.
class IFC_PARSE_API IfcRelConnectsWithEccentricity : public IfcRelConnectsStructuralMember {
public:
    /// The connection constraint explicitly states the eccentricity between a structural member and a structural connection by means of two topological objects (vertex and vertex, or edge and edge, or face and face).
    IfcConnectionGeometry* ConnectionConstraint() const;
    void setConnectionConstraint(IfcConnectionGeometry* v);
    virtual unsigned int getArgumentCount() const { return 11; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 10: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcRelConnectsStructuralMember::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 10: return Type::IfcConnectionGeometry; } return IfcRelConnectsStructuralMember::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 10: return "ConnectionConstraint"; } return IfcRelConnectsStructuralMember::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRelConnectsWithEccentricity (IfcEntityInstanceData* e);
    IfcRelConnectsWithEccentricity (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcStructuralMember* v5_RelatingStructuralMember, IfcStructuralConnection* v6_RelatedStructuralConnection, IfcBoundaryCondition* v7_AppliedCondition, IfcStructuralConnectionCondition* v8_AdditionalConditions, boost::optional< double > v9_SupportedLength, IfcAxis2Placement3D* v10_ConditionCoordinateSystem, IfcConnectionGeometry* v11_ConnectionConstraint);
    typedef IfcTemplatedEntityList< IfcRelConnectsWithEccentricity > list;
};
/// Definition from IAI:
///   IfcRelConnectsWithRealizingElements defines a
///   generic relationship that is made between two elements that
///   require the realization of that relationship by means of
///   further realizing elements.
/// 
/// An IfcRelConnectsWithRealizingElements is a
///   specialization of IfcRelConnectsElement where the
///   connecting operation has the additional attribute of (one
///   or many) realizing elements that may be used to realize or
///   further qualify the relationship. It is defined as a
///   ternary relationship.
/// 
/// EXAMPLE: It may be used to describe the
///   attachment of one element to another where the attachment
///   is realized by a 'fixing' element such as a bracket. It
///   may also be used to describe the mounting of one element
///   onto another such as the requirement for the mounting
///   major plant items onto builders work bases and/or
///   anti-vibration isolators.
/// 
/// HISTORY: New entity in
///   Release IFC2x Edition 2.
class IFC_PARSE_API IfcRelConnectsWithRealizingElements : public IfcRelConnectsElements {
public:
    /// Defines the elements that realize a connection relationship.
    IfcTemplatedEntityList< IfcElement >::ptr RealizingElements() const;
    void setRealizingElements(IfcTemplatedEntityList< IfcElement >::ptr v);
    /// Whether the optional attribute ConnectionType is defined for this IfcRelConnectsWithRealizingElements
    bool hasConnectionType() const;
    /// The type of the connection given for informal purposes, it may include labels, like 'joint', 'rigid joint', 'flexible joint', etc.
    std::string ConnectionType() const;
    void setConnectionType(std::string v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 7: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 8: return IfcUtil::Argument_STRING; } return IfcRelConnectsElements::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 7: return Type::IfcElement; case 8: return Type::IfcLabel; } return IfcRelConnectsElements::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 7: return "RealizingElements"; case 8: return "ConnectionType"; } return IfcRelConnectsElements::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRelConnectsWithRealizingElements (IfcEntityInstanceData* e);
    IfcRelConnectsWithRealizingElements (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcConnectionGeometry* v5_ConnectionGeometry, IfcElement* v6_RelatingElement, IfcElement* v7_RelatedElement, IfcTemplatedEntityList< IfcElement >::ptr v8_RealizingElements, boost::optional< std::string > v9_ConnectionType);
    typedef IfcTemplatedEntityList< IfcRelConnectsWithRealizingElements > list;
};
/// This objectified relationship,
///   IfcRelContainedInSpatialStructure, is used to assign
///   elements to a certain level of the spatial project
///   structure. Any element can only be assigned once to a
///   certain level of the spatial structure. The question, which
///   level is relevant for which type of element, can only be
///   answered within the context of a particular project and
///   might vary within the various regions.
/// 
/// EXAMPLE A multi-storey space is contained (or
///   belongs to) the building storey at which its ground level
///   is, but it is referenced by all the other building
///   storeys, in which it spans. A lift shaft might be
///   contained by the basement, but referenced by all storeys,
///   through which it spans.
/// 
/// The containment relationship of an element within a
///   spatial structure has to be a hierarchical relationship, an
///   element can only be contained within a single spatial
///   structure element. The reference relationship between an
///   element and the spatial structure may not be hierarchical,
///   i.e. an element can reference many spatial structure
///   elements.
/// 
/// NOTE The reference relationship is expressed by
///   IfcRelReferencedInSpatialStructure.
/// 
/// Predefined spatial structure elements to which elements can
///   be assigned are
/// 
/// site as IfcSite
/// 
/// building as IfcBuilding
/// 
/// storey as IfcBuildingStorey
/// 
/// space as IfcSpace
/// 
/// Occurrences of the same element type can be assigned to
///   different spatial structure elements depending on the
///   context of the occurrence.
/// 
/// EXAMPLE A wall might be normally assigned
///   to a storey, however the curtain wall might be assigned
///   to the building and the retaining wall in the terrain
///   might be assigned to the site.
/// 
/// HISTORY New entity in IFC
///   Release 2x.
/// 
/// IFC2x PLATFORM CHANGE: The
///   data type of the attribute RelatedElements has been
///   changed from IfcElement to its supertype
///   IfcProduct with upward compatibility for file based
///   exchange.
/// 
/// Containment Use Definition
///   Figure 39 shows the use of IfcRelContainedInSpatialStructure to assign a stair and two walls to two different levels within the spatial structure.
/// 
/// ÿ
/// 
/// Figure 39 — Relationship for spatial structure containment
class IFC_PARSE_API IfcRelContainedInSpatialStructure : public IfcRelConnects {
public:
    /// Set of elements products, which are contained within this level of the spatial structure hierarchy.
    /// 
    /// IFC2x PLATFORM CHANGE  The data type has been changed from IfcElement to IfcProduct with upward compatibility
    IfcTemplatedEntityList< IfcProduct >::ptr RelatedElements() const;
    void setRelatedElements(IfcTemplatedEntityList< IfcProduct >::ptr v);
    /// Spatial structure element, within which the element is contained. Any element can only be contained within one element of the project spatial structure.
    IfcSpatialElement* RelatingStructure() const;
    void setRelatingStructure(IfcSpatialElement* v);
    virtual unsigned int getArgumentCount() const { return 6; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 4: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 5: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcRelConnects::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 4: return Type::IfcProduct; case 5: return Type::IfcSpatialElement; } return IfcRelConnects::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 4: return "RelatedElements"; case 5: return "RelatingStructure"; } return IfcRelConnects::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRelContainedInSpatialStructure (IfcEntityInstanceData* e);
    IfcRelContainedInSpatialStructure (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcTemplatedEntityList< IfcProduct >::ptr v5_RelatedElements, IfcSpatialElement* v6_RelatingStructure);
    typedef IfcTemplatedEntityList< IfcRelContainedInSpatialStructure > list;
};
/// Definition from IAI: The
/// IfcRelCoversBldgElements is an objectified relationship
/// between an element and one to many coverings, which cover the
/// building element.
/// 
/// IfcRelCoversBldgElements, this relationship, expresses
/// the primary relation to the element,
/// IfcRelCoversSpaces expresses the primary relation to
/// the space.
/// 
/// HISTORY New Entity in
/// IFC Release 1.5
/// IFC2x4 CHANGE: The data
/// type of the attribute RelatingElement has been changed
/// from IfcElement to its subtype
/// IfcBuildingElement.
class IFC_PARSE_API IfcRelCoversBldgElements : public IfcRelConnects {
public:
    /// Relationship to the building element that is covered. 
    /// 
    /// IFC2x4 CHANGE: The attribute type has been changed from IfcElement to IfcBuildingElement.
    IfcElement* RelatingBuildingElement() const;
    void setRelatingBuildingElement(IfcElement* v);
    /// Relationship to the set of coverings at this element.
    IfcTemplatedEntityList< IfcCovering >::ptr RelatedCoverings() const;
    void setRelatedCoverings(IfcTemplatedEntityList< IfcCovering >::ptr v);
    virtual unsigned int getArgumentCount() const { return 6; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 4: return IfcUtil::Argument_ENTITY_INSTANCE; case 5: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } return IfcRelConnects::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 4: return Type::IfcElement; case 5: return Type::IfcCovering; } return IfcRelConnects::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 4: return "RelatingBuildingElement"; case 5: return "RelatedCoverings"; } return IfcRelConnects::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRelCoversBldgElements (IfcEntityInstanceData* e);
    IfcRelCoversBldgElements (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcElement* v5_RelatingBuildingElement, IfcTemplatedEntityList< IfcCovering >::ptr v6_RelatedCoverings);
    typedef IfcTemplatedEntityList< IfcRelCoversBldgElements > list;
};
/// Definition from IAI: The objectified relationship,
///   IfcRelCoversSpace, relatesÿa space object to one or
///   many coverings, which faces (or is assigned to) the space.
/// 
/// NOTE Particularly floorings, ceilings and wall
///   coverings, such as claddings or tiling are often
///   considered as space coverings, rather then wall or slab
///   coverings. In some life cycle phases, such as the
///   operation phase, the relationship is always made to the
///   space.
/// 
/// The IFC specification provides two relationships:
/// 
/// IfcRelCoversBldgElements to assign coverings to
///   elements, and
/// 
/// IfcRelCoversSpaces to assign coverings to spaces
/// 
/// Which relationship should be applied has to be determined
///   by the context of the project or application .
/// 
/// NOTE View definition may determine the necessity
///   to use either of the two relationship elements
/// 
/// HISTORYÿ New Entity in Release
///   IFC 2x Edition 3.
class IFC_PARSE_API IfcRelCoversSpaces : public IfcRelConnects {
public:
    /// Relationship to the space object that is covered.
    /// 
    /// IFC2x4 CHANGE: The attribute name has been changed from RelatedSpace to RelatingSpace with upward compatibility for file based exchange.
    IfcSpace* RelatingSpace() const;
    void setRelatingSpace(IfcSpace* v);
    /// Relationship to the set of coverings covering this space.
    IfcTemplatedEntityList< IfcCovering >::ptr RelatedCoverings() const;
    void setRelatedCoverings(IfcTemplatedEntityList< IfcCovering >::ptr v);
    virtual unsigned int getArgumentCount() const { return 6; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 4: return IfcUtil::Argument_ENTITY_INSTANCE; case 5: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } return IfcRelConnects::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 4: return Type::IfcSpace; case 5: return Type::IfcCovering; } return IfcRelConnects::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 4: return "RelatingSpace"; case 5: return "RelatedCoverings"; } return IfcRelConnects::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRelCoversSpaces (IfcEntityInstanceData* e);
    IfcRelCoversSpaces (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcSpace* v5_RelatingSpace, IfcTemplatedEntityList< IfcCovering >::ptr v6_RelatedCoverings);
    typedef IfcTemplatedEntityList< IfcRelCoversSpaces > list;
};
/// The objectified relationship IfcRelDeclares handles the declaration of objects (subtypes of IfcObject) or properties (subtypes of IfcPropertyDefinition) to a project or project library (represented by IfcProject, or IfcProjectLibrary).
/// 
/// The relationship handles the assignment of other objects, like IfcActor, or IfcTypeObject to the project, or project libary. The attribute RelatedDefinitions provides the references to the first level objects, that are the elements within the context. All other objects that relate to the first level objects are also defined in the context.
/// 
/// NOTE 1  Every object (as subtype of IfcObject) has to be declared within the context of a single IfcProject, or of a IfcProjectLibrary assigned to a single IfcProject. This declaration is transitive. For example: the IfcWorkPlan as first level object is declared within the context of IfcProject via IfcRelDeclares, all related IfcWorkSchedule's are related to the context in a transitive way through IfcWorkPlan.
/// 
/// NOTE 2  The assignment excludes subtypes of IfcProduct's, these are assigned to the IfcProject using the spatial structure approach through IfcSpatialStructureElement(s), where the outer container element such as IfcSite or IfcBuilding has an IfcRelAggregates relationship with the IfcProject.
/// 
/// The RelatingContext is the project, or project library that comprises all elements. The unit assignments and the presentation contexts defined at IfcProject or IfcProjectLibrary apply to all these elements.
/// 
/// HISTORY New entity in Release IFC2x4.
class IFC_PARSE_API IfcRelDeclares : public IfcRelationship {
public:
    /// Reference to the IfcProject to which additional information is assigned.
    IfcContext* RelatingContext() const;
    void setRelatingContext(IfcContext* v);
    /// Set of object or property definitions that are assigned to a context and to which the unit and representation context definitions of that context apply.
    IfcEntityList::ptr RelatedDefinitions() const;
    void setRelatedDefinitions(IfcEntityList::ptr v);
    virtual unsigned int getArgumentCount() const { return 6; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 4: return IfcUtil::Argument_ENTITY_INSTANCE; case 5: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } return IfcRelationship::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 4: return Type::IfcContext; case 5: return Type::IfcDefinitionSelect; } return IfcRelationship::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 4: return "RelatingContext"; case 5: return "RelatedDefinitions"; } return IfcRelationship::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRelDeclares (IfcEntityInstanceData* e);
    IfcRelDeclares (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcContext* v5_RelatingContext, IfcEntityList::ptr v6_RelatedDefinitions);
    typedef IfcTemplatedEntityList< IfcRelDeclares > list;
};
/// The decomposition relationship,
/// IfcRelDecomposes, defines the general concept of elements
/// being composed or decomposed. The decomposition relationship
/// denotes a whole/part hierarchy with the ability to navigate from
/// the whole (the composition) to the parts and vice versa.
/// Decompositions may be constrained by requiring both, the whole
/// and its parts, to be of the same type - thus establishing a
/// nesting relationship. Or they may require some form of physical
/// containment, thus establishing special types of aggregation
/// relationships.
/// NOTE There are two special names for
/// decomposition, which are linguistically distinguished, nesting
/// and aggregation. The subtypes of IfcRelDecomposes will
/// introduce either the nesting or aggregation convention (see
/// IfcRelNests and
/// IfcRelAggregates).
/// EXAMPLE A cost element is a nest of other cost
/// elements. Or a structural frame is an aggregation of beams and
/// columns. Both are applications of decomposition
/// relationship.
/// Decompositions imply a dependency, i.e. the definition of the
/// whole depends on the definition of the parts and the parts depend
/// on the existence of the whole. The decomposition relationship can
/// be applied in a recursive manner, i.e. a decomposed element can
/// be part in another decomposition. Cyclic references have to be
/// prevented at application level.
/// 
/// HISTORY New entity in IFC Release 1.5, it is a generalisation of the IFC2.0 entity IfcRelNests.
/// 
/// IFC2x4 CHANGE The differentiation between the aggregation and nesting is determined to be a non-ordered or an ordered collection of parts. The attributes RelatingObject and RelatedObjects have been demoted to the subtypes.
class IFC_PARSE_API IfcRelDecomposes : public IfcRelationship {
public:
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcRelationship::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcRelationship::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcRelationship::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRelDecomposes (IfcEntityInstanceData* e);
    IfcRelDecomposes (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description);
    typedef IfcTemplatedEntityList< IfcRelDecomposes > list;
};
/// A generic and abstract relationship which subtypes are used to:
/// 
/// assign a object type to an object occurrence
/// assign a property set to an object instance
/// assign a property set template to a property set
/// 
/// EXAMPLE ÿSeveral instances of windows within
/// the IFC project model may be of the same (catalogue or
/// manufacturer) type. Thereby they share the same properties. This
/// relationship is established by the subtype
/// IfcRelDefinesByType of IfcRelDefines relationship
/// assigning an IfcWindowStyle to multiple occurrences
/// IfcWindow.
/// 
/// EXAMPLE ÿThe (same) property set, e.g.ÿ
/// Pset_ProductManufacturerInfo, keeping the manufacturer name,
/// label and production year of a product, can be assigned to one,
/// or many instances of furnishing. This relationship is established
/// by the subtype IfcRelDefinesByProperties of
/// IfcRelDefines relationship assigning an
/// IfcPropertySet to one or more instances of
/// IfcFurnishingElement.
/// 
/// HISTORY New entity in IFC2x.
/// 
/// IFC2x4 CHANGE The attribute RelatedObjects had been demoted to the subtypes IfcRelDefinesByProperties and
/// IfcRelDefinesByType.
class IFC_PARSE_API IfcRelDefines : public IfcRelationship {
public:
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcRelationship::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcRelationship::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcRelationship::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRelDefines (IfcEntityInstanceData* e);
    IfcRelDefines (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description);
    typedef IfcTemplatedEntityList< IfcRelDefines > list;
};
/// The objectified relationship IfcRelDefinesByObject defines the relationship between an object taking part in an object type decomposition and an object occurrences taking part in an occurrence decomposition of that type.
/// The IfcRelDefinesByObject is a 1-to-N relationship, as it allows for the assignment of one declaring object information to a single or to many reflected objects. Those objects then share the same object property sets and, for subtypes of IfcProduct, the eventually assigned representation maps.
/// Only objects that take part in a type decomposition and in an occurrence decomposition of the same type can be connected by the IfcRelDefinesByObject relationship.
/// 
/// HISTORY New entity in IFC2x4.
/// 
/// Relationship use definition
/// 
/// The IfcRelDefinesByObject links the decomposed object type part, also called the "declaring part" with the occurrence of that part inside the occurrence of the decomposed type, also called the "reflected part", as shown in Figure 6.
/// 
/// Figure 6 — Part definition relationships
/// 
/// The IfcRelDefinesByObject can be used together with the shape representations of the product type as shown in Figure 7. The IfcShapeRepresentation of the "declaring part" is referenced by the "reflected part". The IfcObjectPlacement of the model occurrence (the whole) determines the position within the project context.
/// 
/// Figure 7 — Part definition relationships with shape representation
class IFC_PARSE_API IfcRelDefinesByObject : public IfcRelDefines {
public:
    /// Objects being part of an object occurrence decomposition, acting as the "reflecting parts" in the relationship.
    IfcTemplatedEntityList< IfcObject >::ptr RelatedObjects() const;
    void setRelatedObjects(IfcTemplatedEntityList< IfcObject >::ptr v);
    /// Object being part of an object type decomposition, acting as the "declaring part" in the relationship.
    IfcObject* RelatingObject() const;
    void setRelatingObject(IfcObject* v);
    virtual unsigned int getArgumentCount() const { return 6; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 4: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 5: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcRelDefines::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 4: return Type::IfcObject; case 5: return Type::IfcObject; } return IfcRelDefines::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 4: return "RelatedObjects"; case 5: return "RelatingObject"; } return IfcRelDefines::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRelDefinesByObject (IfcEntityInstanceData* e);
    IfcRelDefinesByObject (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcTemplatedEntityList< IfcObject >::ptr v5_RelatedObjects, IfcObject* v6_RelatingObject);
    typedef IfcTemplatedEntityList< IfcRelDefinesByObject > list;
};
/// The objectified relationship
/// IfcRelDefinesByProperties defines the relationships
/// between property set definitions and objects. Properties are
/// aggregated in property sets. Property sets can be either directly
/// assigned to occurrence objects using this relationship, or
/// assigned to an object type and assigned via that type to
/// occurrence objects.
/// The IfcRelDefinesByProperties is a 1-to-N relationship,
/// as it allows for the assignment of one property set to a single
/// or to many objects. Those objects then share the same property
/// definition.
/// 
/// HISTORY New Entity in IFC Release 2.0. Has been renamed from IfcRelAssignsProperties in IFC Release 2x.
/// 
/// IFC2x4 CHANGE The attribute RelatedObjects had been demoted from the supertype IfcRelDefines to IfcRelDefinesByProperties.
class IFC_PARSE_API IfcRelDefinesByProperties : public IfcRelDefines {
public:
    /// Reference to the objects (or single object) to which the property definition applies.
    IfcTemplatedEntityList< IfcObjectDefinition >::ptr RelatedObjects() const;
    void setRelatedObjects(IfcTemplatedEntityList< IfcObjectDefinition >::ptr v);
    /// Reference to the property set definition for that object or set of objects.
    IfcPropertySetDefinitionSelect* RelatingPropertyDefinition() const;
    void setRelatingPropertyDefinition(IfcPropertySetDefinitionSelect* v);
    virtual unsigned int getArgumentCount() const { return 6; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 4: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 5: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcRelDefines::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 4: return Type::IfcObjectDefinition; case 5: return Type::IfcPropertySetDefinitionSelect; } return IfcRelDefines::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 4: return "RelatedObjects"; case 5: return "RelatingPropertyDefinition"; } return IfcRelDefines::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRelDefinesByProperties (IfcEntityInstanceData* e);
    IfcRelDefinesByProperties (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcTemplatedEntityList< IfcObjectDefinition >::ptr v5_RelatedObjects, IfcPropertySetDefinitionSelect* v6_RelatingPropertyDefinition);
    typedef IfcTemplatedEntityList< IfcRelDefinesByProperties > list;
};
/// The objectified relationship
/// IfcRelDefinesByTemplate defines the relationships between
/// property set template and property sets. Common information about
/// property sets, e.g. the applicable name, description, contained
/// properties, is defined by the property set template and assigned
/// to all property sets.
/// The IfcRelDefinesByTemplate is a 1-to-N relationship,
/// as it allows for the assignment of one property set template to a
/// single or to many property sets. Those property sets then share
/// the same property set template definition.
/// 
/// HISTORY New Entity in IFC2x4.
class IFC_PARSE_API IfcRelDefinesByTemplate : public IfcRelDefines {
public:
    /// One or many property sets defined by a single property set template.
    IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr RelatedPropertySets() const;
    void setRelatedPropertySets(IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr v);
    /// Property set template that provides the common definition of related property sets.
    IfcPropertySetTemplate* RelatingTemplate() const;
    void setRelatingTemplate(IfcPropertySetTemplate* v);
    virtual unsigned int getArgumentCount() const { return 6; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 4: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 5: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcRelDefines::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 4: return Type::IfcPropertySetDefinition; case 5: return Type::IfcPropertySetTemplate; } return IfcRelDefines::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 4: return "RelatedPropertySets"; case 5: return "RelatingTemplate"; } return IfcRelDefines::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRelDefinesByTemplate (IfcEntityInstanceData* e);
    IfcRelDefinesByTemplate (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr v5_RelatedPropertySets, IfcPropertySetTemplate* v6_RelatingTemplate);
    typedef IfcTemplatedEntityList< IfcRelDefinesByTemplate > list;
};
/// The objectified relationship
/// IfcRelDefinesByType defines the relationship between an
/// object type and object occurrences.
/// The IfcRelDefinesByType is a 1-to-N relationship, as it
/// allows for the assignment of one type information to a single or
/// to many objects. Those objects then share the same object type,
/// and the property sets and properties assigned to the object
/// type.
/// 
/// HISTORY New entity in IFC2x.
/// 
/// IFC2x4 CHANGE The attribute RelatedObjects had been demoted from the supertype IfcRelDefines to IfcRelDefinesByType.
/// 
/// Relationship use definition
/// 
/// The IfcRelDefinesByType links the object type
/// definition with the object occurrence. Both may define properties
/// by assigning an IfcPropertySet, including one or many
/// subtypes of IfcProperty to either the object type or
/// object occurrence, as shown in Figure 8.
/// There are several scenarios to define the same property
/// set on the object type definition and object occurrence
/// side:
/// 
/// All properties for all object occurrences of a common
/// object type have the same value - then only the object type
/// definition has a property set assigned.
/// All properties for all object occurrences are
/// different, that is there are no common property values for the
/// object type definition - then each of the object occurrence has a
/// property set assigned.
/// Some properties within the same property set have
/// common values and are assigned to the object type definition and
/// some are occurrence specific and assigned (with potentially
/// different values) to the object occurrences - then:
/// 
/// The sum of all properties within a given property set
/// applicable to an object occurrence is the union of properties
/// assigned to the object type definition plus the properties
/// assigned to the object occurrence.
/// If the object occurrence has a property with the same
/// IfcProperty.Name in an IfcPropertySet, as the
/// corresponding object type definition, then the occurrence
/// property value overrides the type property value.
/// 
/// Figure 8 — Type definition relationships
/// 
/// The following table provides an example of assigning
/// 
/// properties assigned to
/// IfcWall
/// properties assigned to
/// IfcWallType
/// resulting property value for individual
/// wall
/// 
/// Pset_WallCommon
/// Pset_WallCommon
/// ÿ
/// 
/// ÿ-ÿExtendToStructure = TRUE
/// ÿ
/// TRUE
/// 
/// ÿ
/// ÿ-ÿThermalTransmittance = 0.375
/// 0.375
/// 
/// ÿ-ÿExtendToStructure = FALSE
/// ÿ-ÿExtendToStructure = TRUE
/// FALSE
class IFC_PARSE_API IfcRelDefinesByType : public IfcRelDefines {
public:
    IfcTemplatedEntityList< IfcObject >::ptr RelatedObjects() const;
    void setRelatedObjects(IfcTemplatedEntityList< IfcObject >::ptr v);
    /// Reference to the type (or style) information for that object or set of objects.
    IfcTypeObject* RelatingType() const;
    void setRelatingType(IfcTypeObject* v);
    virtual unsigned int getArgumentCount() const { return 6; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 4: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 5: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcRelDefines::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 4: return Type::IfcObject; case 5: return Type::IfcTypeObject; } return IfcRelDefines::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 4: return "RelatedObjects"; case 5: return "RelatingType"; } return IfcRelDefines::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRelDefinesByType (IfcEntityInstanceData* e);
    IfcRelDefinesByType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcTemplatedEntityList< IfcObject >::ptr v5_RelatedObjects, IfcTypeObject* v6_RelatingType);
    typedef IfcTemplatedEntityList< IfcRelDefinesByType > list;
};
/// IfcRelFillsElement is an objectified relationship between an opening element and an element that fills (or partially fills) the opening element. It is an one-to-one relationship.
/// 
/// NOTE view definitions or implementer agreements may restrict an opening to be filled by one filling element only.
/// 
/// HISTORY New entity in IFC Release 1.0
/// 
/// As shown in Figure 40, the insertion of a door into a wall is represented by two separate relationships. First the door opening is created within the wall by IfcWall(StandardCase) o-- IfcRelVoidsElement --o IfcOpeningElement, then the door is inserted within the opening by IfcOpeningElement o-- IfcRelFillsElement --o IfcDoor.
/// 
/// Figure 40 — Relationships for element filling
class IFC_PARSE_API IfcRelFillsElement : public IfcRelConnects {
public:
    /// Opening Element being filled by virtue of this relationship.
    IfcOpeningElement* RelatingOpeningElement() const;
    void setRelatingOpeningElement(IfcOpeningElement* v);
    /// Reference to building element that occupies fully or partially the associated opening.
    /// 
    /// IFC2x PLATFORM CHANGE: The data type has been changed from IfcBuildingElement to IfcElement with upward compatibility for file based exchange.
    IfcElement* RelatedBuildingElement() const;
    void setRelatedBuildingElement(IfcElement* v);
    virtual unsigned int getArgumentCount() const { return 6; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 4: return IfcUtil::Argument_ENTITY_INSTANCE; case 5: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcRelConnects::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 4: return Type::IfcOpeningElement; case 5: return Type::IfcElement; } return IfcRelConnects::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 4: return "RelatingOpeningElement"; case 5: return "RelatedBuildingElement"; } return IfcRelConnects::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRelFillsElement (IfcEntityInstanceData* e);
    IfcRelFillsElement (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcOpeningElement* v5_RelatingOpeningElement, IfcElement* v6_RelatedBuildingElement);
    typedef IfcTemplatedEntityList< IfcRelFillsElement > list;
};
/// Objectified relationship between a distribution flow element occurrence instance and one-to-many control element occurrence instances indicating that the control element(s) sense or control some aspect of the flow element. It is applied to IfcDistributionFlowElement and IfcDistributionControlElement.
/// 
/// This relationship may be used to indicate an operation relationship such as an actuator operating a valve, damper, or switch.  It may also be used to indicate a sensing relationship such as a sensor detecting conditions of fluid flow.
/// 
/// This relationship implies a sensing or controlling relationship; if elements are merely connected without any control relationship, then IfcRelConnectsElements should be used.
/// 
/// HISTORY: New entity in IFC R2x.
class IFC_PARSE_API IfcRelFlowControlElements : public IfcRelConnects {
public:
    /// References control elements which may be used to impart control on the Distribution Element.
    IfcTemplatedEntityList< IfcDistributionControlElement >::ptr RelatedControlElements() const;
    void setRelatedControlElements(IfcTemplatedEntityList< IfcDistributionControlElement >::ptr v);
    /// Relationship to a distribution flow element
    IfcDistributionFlowElement* RelatingFlowElement() const;
    void setRelatingFlowElement(IfcDistributionFlowElement* v);
    virtual unsigned int getArgumentCount() const { return 6; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 4: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 5: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcRelConnects::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 4: return Type::IfcDistributionControlElement; case 5: return Type::IfcDistributionFlowElement; } return IfcRelConnects::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 4: return "RelatedControlElements"; case 5: return "RelatingFlowElement"; } return IfcRelConnects::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRelFlowControlElements (IfcEntityInstanceData* e);
    IfcRelFlowControlElements (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcTemplatedEntityList< IfcDistributionControlElement >::ptr v5_RelatedControlElements, IfcDistributionFlowElement* v6_RelatingFlowElement);
    typedef IfcTemplatedEntityList< IfcRelFlowControlElements > list;
};
/// Definition from IAI: The
/// IfcRelInterferesElements objectified relationship
/// indicates that two elements interfere. Interference is a spatial
/// overlap between the two elements. It is a 1 to 1 relationship.
/// The concept of two elements interfering physically or logically
/// is described independently from the elements. The interference
/// may be related to the shape representation of the entities by
/// providing an interference geometry.
/// 
/// When the interference geometry is available it can be passed
/// by the optional attribute InterferenceGeometry pointing to
/// IfcConnectionGeometry. The connection geometry is provided
/// as a point, curve, surface, or volume within the local placement
/// coordinate systems of the connecting elements. The
/// IfcConnectionVolumeGeometry is the default type to be used
/// for interference in 3D space, as indicated in e.g. clash
/// detections.
/// If the interference geometry is omitted then the interference
/// is provided as a logical relationship. Under this circumstance,
/// the connection point, curve, surface, or solid has to be
/// recalculated by the receiving application.
/// 
/// The RelatingElement and RelatedElement define
/// the two elements in the relationship, that may have different
/// roles. This is controlled by the attribute
/// ImpliedOrder.
/// 
/// ImpliedOrder=TRUEÿ The RelatingElement
/// constitutes the primary element of the interference relationship.
/// If the interference is to be resolved by subtracting the
/// overlapping part, it should be subtracted from the
/// RelatingElement. The net result would be the
/// RelatingElement subtracted by the
/// InterferenceGeometry. This would be the case in
/// interference relationships where the RelatedElement
/// creates a void in the RelatingElement dynamically.
/// ImpliedOrder=FALSEÿ The RelatingElement and
/// RelatedElement have no priority among each other. If the
/// interference is to be resolved then no information about whether
/// the InterferenceGeometry should be subtracted from the
/// RelatingElement or thed RelatedElement can be
/// traced. This would be the case for clash detection results.
/// ImpliedOrder=UNKNOWÿ No information about the
/// priorities is provided.
/// 
/// HISTORYÿ New entity in
/// IFC2x4.
class IFC_PARSE_API IfcRelInterferesElements : public IfcRelConnects {
public:
    /// Reference to a subtype of IfcElement that is the RelatingElement in the interference relationship. Depending on the value of ImpliedOrder the RelatingElement may carry the notion to be the element from which the interference geometry should be subtracted.
    IfcElement* RelatingElement() const;
    void setRelatingElement(IfcElement* v);
    /// Reference to a subtype of IfcElement that is the RelatedElement in the interference relationship. Depending on the value of ImpliedOrder the RelatedElement may carry the notion to be the element from which the interference geometry should not be subtracted.
    IfcElement* RelatedElement() const;
    void setRelatedElement(IfcElement* v);
    /// Whether the optional attribute InterferenceGeometry is defined for this IfcRelInterferesElements
    bool hasInterferenceGeometry() const;
    /// The geometric shape representation of the interference geometry that is provided in the object coordinate system of the RelatingElement (mandatory) and in the object coordinate system of the RelatedElement (optionally).
    IfcConnectionGeometry* InterferenceGeometry() const;
    void setInterferenceGeometry(IfcConnectionGeometry* v);
    /// Whether the optional attribute InterferenceType is defined for this IfcRelInterferesElements
    bool hasInterferenceType() const;
    /// Optional identifier that describes the nature of the interference. Examples could include 'Clash', 'ProvisionForVoid', etc.
    std::string InterferenceType() const;
    void setInterferenceType(std::string v);
    /// Logical value indicating whether the interference geometry should be subtracted from the RelatingElement (if TRUE), or whether it should be either subtracted from the RelatingElement or the RelatedElement (if FALSE), or whether no indication can be provided (if UNKNOWN).
    bool ImpliedOrder() const;
    void setImpliedOrder(bool v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 4: return IfcUtil::Argument_ENTITY_INSTANCE; case 5: return IfcUtil::Argument_ENTITY_INSTANCE; case 6: return IfcUtil::Argument_ENTITY_INSTANCE; case 7: return IfcUtil::Argument_STRING; case 8: return IfcUtil::Argument_BOOL; } return IfcRelConnects::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 4: return Type::IfcElement; case 5: return Type::IfcElement; case 6: return Type::IfcConnectionGeometry; case 7: return Type::IfcIdentifier; case 8: return Type::UNDEFINED; } return IfcRelConnects::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 4: return "RelatingElement"; case 5: return "RelatedElement"; case 6: return "InterferenceGeometry"; case 7: return "InterferenceType"; case 8: return "ImpliedOrder"; } return IfcRelConnects::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRelInterferesElements (IfcEntityInstanceData* e);
    IfcRelInterferesElements (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcElement* v5_RelatingElement, IfcElement* v6_RelatedElement, IfcConnectionGeometry* v7_InterferenceGeometry, boost::optional< std::string > v8_InterferenceType, bool v9_ImpliedOrder);
    typedef IfcTemplatedEntityList< IfcRelInterferesElements > list;
};
/// The nesting relationship
/// IfcRelNests is a special type of the general
/// composition/decomposition (or whole/part) relationship
/// IfcRelDecomposes. The nesting relationship can be applied
/// to all non physical subtypes of object and object types, namely
/// processes, controls (like cost items), and resources. The nesting
/// implies an order among the nested parts.
/// EXAMPLE1 A nesting of costs items in a cost
/// schedule is the composition of complex cost items from other cost
/// items. The order of the nested cost items underneath the parent
/// cost item is determined by the order of the list of
/// RelatedObjects.
/// EXAMPLE2 A nesting of work tasks within a work
/// schedule is the composition of a parent work task from more
/// specific sub work tasks. The order of the sub tasks underneath
/// the parent task is determined by the order of the list of
/// RelatedObjects..
/// Decompositions imply a dependency, i.e. the definition of the
/// whole depends on the definition of the parts and the parts depend
/// on the existence of the whole. The behaviour that is implied from
/// the dependency has to be established inside the applications.
/// 
/// HISTORY New entity in IFC Release 2.0
/// 
/// IFC2x4 CHANGE The attributes RelatingObject and RelatedObjects are demoted from the supertype IfcRelDecomposes, and RelatedObjects is refined to be a list. The use of IfcRelNests is repurposed to be a nesting of an ordered collections of parts.
class IFC_PARSE_API IfcRelNests : public IfcRelDecomposes {
public:
    /// The object definition, either an non-product object type or a non-product object occurrence, that represents the nest. It is the whole within the whole/part relationship.
    /// 
    /// IFC2x4 CHANGE  The attribute has been demoted from the supertype IfcRelDecomposes and defines the ordered nesting relationship.
    IfcObjectDefinition* RelatingObject() const;
    void setRelatingObject(IfcObjectDefinition* v);
    /// The object definitions, either non-product object occurrences or non-product object types, that are being nestes. They are defined as the parts in the ordered whole/part relationship -  i.e. there is an implied order among the parts expressed by the position within the list of RelatedObjects.
    /// 
    /// IFC2x4 CHANGE  The attribute has been demoted from the supertype IfcRelDecomposes and defines the ordered set of parts within the nest.
    IfcTemplatedEntityList< IfcObjectDefinition >::ptr RelatedObjects() const;
    void setRelatedObjects(IfcTemplatedEntityList< IfcObjectDefinition >::ptr v);
    virtual unsigned int getArgumentCount() const { return 6; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 4: return IfcUtil::Argument_ENTITY_INSTANCE; case 5: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } return IfcRelDecomposes::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 4: return Type::IfcObjectDefinition; case 5: return Type::IfcObjectDefinition; } return IfcRelDecomposes::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 4: return "RelatingObject"; case 5: return "RelatedObjects"; } return IfcRelDecomposes::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRelNests (IfcEntityInstanceData* e);
    IfcRelNests (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcObjectDefinition* v5_RelatingObject, IfcTemplatedEntityList< IfcObjectDefinition >::ptr v6_RelatedObjects);
    typedef IfcTemplatedEntityList< IfcRelNests > list;
};
/// The IfcRelProjectsElement is an objectified relationship
/// between an element and one projection element that creates a
/// modifier to the shape of the element. The relationship is defined
/// to be a 1:1 relationship, if an element has more than one
/// projection, several relationship objects have to be used, each
/// pointing to a different projection element. The
/// IfcRelProjectsElement establishes an aggregation
/// relationship between the main element and a sub ordinary addition
/// feature.
/// 
/// NOTE  In contrary the
/// IfcRelAggregates relationship established an aggregation
/// of equal parts to a whole.
/// 
/// The IfcRelProjectsElement implies a Boolean operation of
/// addition for the geometric bodies of the element and the feature
/// element. As with all decomposition relationships it determines:
/// 
/// existence dependency - the RelatedFeatureElement
/// cannot exist without the RelatingElement
/// hierarchical and non-cyclical relationship - the
/// IfcRelProjectsElement can only alter a single
/// IfcElement
/// no spatial containment - the IfcFeatureElementAddition
/// as related element never participates in the hiearchical spatial
/// containment relationship
/// IfcRelContainedInSpatialStructure
/// 
/// HISTORY New entity in
/// Release IFC2x Edition 2.
/// IFC2x4 CHANGE 
/// Supertype changed to IfcRelDecomposes.
class IFC_PARSE_API IfcRelProjectsElement : public IfcRelDecomposes {
public:
    /// Element at which a projection is created by the associated IfcProjectionElement.
    IfcElement* RelatingElement() const;
    void setRelatingElement(IfcElement* v);
    /// Reference to the IfcFeatureElementAddition that defines an addition to the volume of the element, by using a Boolean addition operation. An example is a projection at the associated element.
    IfcFeatureElementAddition* RelatedFeatureElement() const;
    void setRelatedFeatureElement(IfcFeatureElementAddition* v);
    virtual unsigned int getArgumentCount() const { return 6; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 4: return IfcUtil::Argument_ENTITY_INSTANCE; case 5: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcRelDecomposes::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 4: return Type::IfcElement; case 5: return Type::IfcFeatureElementAddition; } return IfcRelDecomposes::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 4: return "RelatingElement"; case 5: return "RelatedFeatureElement"; } return IfcRelDecomposes::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRelProjectsElement (IfcEntityInstanceData* e);
    IfcRelProjectsElement (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcElement* v5_RelatingElement, IfcFeatureElementAddition* v6_RelatedFeatureElement);
    typedef IfcTemplatedEntityList< IfcRelProjectsElement > list;
};
/// The objectified relationship,
///   IfcRelReferencedInSpatialStructure is used to
///   assign elements in addition to those levels of the project
///   spatialÿstructure, in which they are referenced, but not
///   primarily contained.ÿ
/// 
/// NOTE ÿThe primary containment relationship between
///   an element and the spatial structure is handled
///   byÿIfcRelContainsInSpatialStructure.
/// 
/// Any element can be referencedÿto zero, one or several
///   levels of the spatial structure. Whereas the
///   IfcRelContainsInSpatialStructure relationship is
///   required to be hierarchical (an element can only be
///   contained in exactly one spatial structure element), the
///   IfcRelReferencedInSpatialStructure is not restricted
///   to be hierarchical.
/// 
/// EXAMPLE A wall might be normally contained within
///   a storey, and since it does not span through several
///   stories, it is not referenced in any additional storey.
///   However a curtain wall might span through several
///   stories, in this case it can be contained within the
///   ground floor, but it would be referenced by all
///   additional stories, it spans.
/// 
/// Predefined spatial structure elements to which elements can
///   be assigned are
/// 
/// site as IfcSite
/// 
/// building as IfcBuilding
/// 
/// storey as IfcBuildingStorey
/// 
/// space as IfcSpace
/// 
/// Elements can also be references in a spatial zone that is provided as IfcSpatialZone.
/// 
/// The same element can be assigned to different spatial
///   structure elements depending on the context.
/// 
/// HISTORY New entity
///   inÿRelease IFC2x Edition 3.
/// 
/// Use Definition
/// Figure 41 shows the use of IfcRelContainedInSpatialStructure and IfcRelReferencedInSpatialStructure to assign an IfcCurtainWallÿto two different levels within the spatial structure. It is primarily contained within the ground floor, and additionally referenced within the first and second floor.
/// 
/// Figure 41 — Relationship for spatial structure referencing
class IFC_PARSE_API IfcRelReferencedInSpatialStructure : public IfcRelConnects {
public:
    /// Set of products, which are referenced within this level of the spatial structure hierarchy.
    /// NOTE  Referenced elements are contained elsewhere within the spatial structure, they are referenced additionally by this spatial structure element, e.g., because they span several stories.
    IfcTemplatedEntityList< IfcProduct >::ptr RelatedElements() const;
    void setRelatedElements(IfcTemplatedEntityList< IfcProduct >::ptr v);
    /// Spatial structure element, within which the element is referenced. Any element can be contained within zero, one or many elements of the project spatial and zoning structure.
    /// 
    /// IFC2x Edition 4 CHANGE  The attribute relatingStructure as been promoted to the new supertype IfcSpatialElement with upward compatibility for file based exchange.
    IfcSpatialElement* RelatingStructure() const;
    void setRelatingStructure(IfcSpatialElement* v);
    virtual unsigned int getArgumentCount() const { return 6; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 4: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 5: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcRelConnects::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 4: return Type::IfcProduct; case 5: return Type::IfcSpatialElement; } return IfcRelConnects::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 4: return "RelatedElements"; case 5: return "RelatingStructure"; } return IfcRelConnects::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRelReferencedInSpatialStructure (IfcEntityInstanceData* e);
    IfcRelReferencedInSpatialStructure (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcTemplatedEntityList< IfcProduct >::ptr v5_RelatedElements, IfcSpatialElement* v6_RelatingStructure);
    typedef IfcTemplatedEntityList< IfcRelReferencedInSpatialStructure > list;
};
/// IfcRelSequence is a
///   sequential relationship between processes where one process
///   must occur before the other in time and where the timing of
///   the relationship may be described as a type of sequence.
///   The relating process
///   (IfcRelSequence.RelatingProcess) is considered to be
///   the predecessor in the relationship (has precedence) whilst
///   the related process (IfcRelSequence.RelatedProcess)
///   is the successor.
/// 
/// IfcRelSequence is defined as one-to-one
///   relationship; therefore it assigns one predecessor to one
///   successor.
/// 
/// HISTORY  New entity in IFC 1.0.
/// 
/// IFC2x4 CHANGE  Relocated to IfcProcessExtension schema.
///   TimeLag and SequenceType made optional.
///   USERDEFINED added to the IfcSequenceType
///   enumeration. UserDefinedSequenceType attribute
///   added. WHERE rule controlling use of the USERDEFINED
///   enumeration added.
/// 
/// Use definitions
/// 
/// IfcRelSequence is used to describe the logical
///   sequence relationship that exists between two processes.
///   This logical relationship identifies that there is a
///   predecessor or relating process and a successor or related
///   process. In IFC, there may be one predecessor and one
///   successor in the relationship. Many occurrences of
///   IfcRelSequence may exist to describe the sequence
///   relationships of a predecessor task with many successor
///   tasks or of many predecessor tasks with one successor task,
///   thus enabling a m:n sequence relationship between tasks.
///   Please note that sequence relationships always should stay
///   within the limits of a directed, non-cyclic graph.
/// 
/// A sequence type may be set for a sequence. For tasks
///   assigned to a work schedule, it is expected that the
///   sequence type will be asserted. For a process map, where
///   the sequence relationship between processes is simply a
///   logical flow, it need not be asserted.
/// 
/// A time lag may be assigned to a sequence, and the sequence
///   type defines the way in which the time lag applies to the
///   sequence either as a ratio or percentage of time duration
///   (e.g. start successor task when predecessor is 50%
///   complete) or as a time measure (e.g. start successor task 1
///   week after commencement of the predecessor task). Care
///   should be used when assigning a time lag to a sequence
///   depending on the setting of the sequence type since there
///   is no checking that the time lag value is in keeping with
///   the sequence type set.
class IFC_PARSE_API IfcRelSequence : public IfcRelConnects {
public:
    /// Reference to the process, that is the predecessor.
    IfcProcess* RelatingProcess() const;
    void setRelatingProcess(IfcProcess* v);
    /// Reference to the process, that is the successor.
    IfcProcess* RelatedProcess() const;
    void setRelatedProcess(IfcProcess* v);
    /// Whether the optional attribute TimeLag is defined for this IfcRelSequence
    bool hasTimeLag() const;
    /// Time duration of the sequence, it is the time lag between the
    ///   predecessor and the successor as specified by the
    ///   SequenceType.
    IfcLagTime* TimeLag() const;
    void setTimeLag(IfcLagTime* v);
    /// Whether the optional attribute SequenceType is defined for this IfcRelSequence
    bool hasSequenceType() const;
    /// The way in which the time lag applies to the sequence.
    IfcSequenceEnum::IfcSequenceEnum SequenceType() const;
    void setSequenceType(IfcSequenceEnum::IfcSequenceEnum v);
    /// Whether the optional attribute UserDefinedSequenceType is defined for this IfcRelSequence
    bool hasUserDefinedSequenceType() const;
    /// Allows for specification of user defined type of the sequence
    ///   beyond the enumeration values (START_START, START_FINISH,
    ///   FINISH_START, FINISH_FINISH) provided by SequenceType
    ///   attribute of type IfcSequenceEnum. When a value is
    ///   provided for attribute UserDefinedSequenceType in
    ///   parallel the attribute SequenceType shall have
    ///   enumeration value USERDEFINED.
    /// 
    /// Added in IFC 2x4
    std::string UserDefinedSequenceType() const;
    void setUserDefinedSequenceType(std::string v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 4: return IfcUtil::Argument_ENTITY_INSTANCE; case 5: return IfcUtil::Argument_ENTITY_INSTANCE; case 6: return IfcUtil::Argument_ENTITY_INSTANCE; case 7: return IfcUtil::Argument_ENUMERATION; case 8: return IfcUtil::Argument_STRING; } return IfcRelConnects::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 4: return Type::IfcProcess; case 5: return Type::IfcProcess; case 6: return Type::IfcLagTime; case 7: return Type::IfcSequenceEnum; case 8: return Type::IfcLabel; } return IfcRelConnects::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 4: return "RelatingProcess"; case 5: return "RelatedProcess"; case 6: return "TimeLag"; case 7: return "SequenceType"; case 8: return "UserDefinedSequenceType"; } return IfcRelConnects::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRelSequence (IfcEntityInstanceData* e);
    IfcRelSequence (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcProcess* v5_RelatingProcess, IfcProcess* v6_RelatedProcess, IfcLagTime* v7_TimeLag, boost::optional< IfcSequenceEnum::IfcSequenceEnum > v8_SequenceType, boost::optional< std::string > v9_UserDefinedSequenceType);
    typedef IfcTemplatedEntityList< IfcRelSequence > list;
};
/// Definition from IAI: An objectified relationship
///   that defines the relationship between a system and the
///   sites, buildings, storeys or spaces, it serves. Examples of
///   systems are:
/// 
/// building service systems (heating, cooling, waste water
///   system) represented by instances of IfcSystem
/// 
/// idealized structural analysis systems represented by
///   instances of IfcStructuralAnalysisSystem
/// 
/// HISTORY New entity in IFC
///   Release 1.0
/// 
/// IFC2x PLATFORM CHANGEÿ The
///   data type of the attributeRelatedBuildings has been
///   changed from IfcBuilding to its supertype
///   IfcSpatialStructureElement with upward compatibility
///   for file based exchange. The name
///   IfcRelServicesBuildings is a knownÿanomaly, as the
///   relationship is not restricted to buildings anymore.
class IFC_PARSE_API IfcRelServicesBuildings : public IfcRelConnects {
public:
    /// System that services the Buildings.
    IfcSystem* RelatingSystem() const;
    void setRelatingSystem(IfcSystem* v);
    /// Spatial structure elements (including site, building, storeys) that are serviced by the system.
    /// 
    /// IFC2x PLATFORM CHANGE  The data type has been changed from IfcBuilding to IfcSpatialStructureElement with upward compatibility for file based exchange.
    /// 
    /// IFC2x Edition 4 CHANGE  The data type has been changed from IfcSpatialStructureElement to IfcSpatialElement with upward compatibility for file based exchange.
    IfcTemplatedEntityList< IfcSpatialElement >::ptr RelatedBuildings() const;
    void setRelatedBuildings(IfcTemplatedEntityList< IfcSpatialElement >::ptr v);
    virtual unsigned int getArgumentCount() const { return 6; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 4: return IfcUtil::Argument_ENTITY_INSTANCE; case 5: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } return IfcRelConnects::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 4: return Type::IfcSystem; case 5: return Type::IfcSpatialElement; } return IfcRelConnects::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 4: return "RelatingSystem"; case 5: return "RelatedBuildings"; } return IfcRelConnects::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRelServicesBuildings (IfcEntityInstanceData* e);
    IfcRelServicesBuildings (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcSystem* v5_RelatingSystem, IfcTemplatedEntityList< IfcSpatialElement >::ptr v6_RelatedBuildings);
    typedef IfcTemplatedEntityList< IfcRelServicesBuildings > list;
};
/// The space boundary defines the
/// physical or virtual delimiter of a space by the relationship
/// IfcRelSpaceBoundary to the surrounding elements.
/// 
/// In the case of a physical space boundary, the placement and
/// shape of the boundary may be given, and the building element,
/// providing the boundary, is referenced,
/// In the case of a virtual space boundary, the placement and
/// shape of the boundary may be given, but no building element is
/// referenced and a virtual element is
/// referenced instead.
/// 
/// The IfcRelSpaceBoundary is defined as an objectified
/// relationship that handles the element to space relationship by
/// objectifying the relationship between an element and the space it
/// bounds. It is given as a one-to-one relationship, but allows each
/// element (including virutal elements and openings) to define many
/// such relationship and each space to be defined by many such
/// relationships.
/// Space boundaries are always defined as seen from the space. In
/// general two basic types of space boundaries are
/// distinguished:
/// 
/// 1st level space boundary: defined
/// as boundaries of the space, not taking into account any change in
/// building element or spaces on the other side.
/// 2nd level space boundary: defined
/// as boundary taking any change in building element or spaces on
/// the other side into account. It can be further distinguished into
/// 
/// 2nd level type A: There is a space
/// on the other side.
/// 2nd level type B: There is a
/// building element on the other side.
/// 
/// The exact definition of how space boundaries
/// are broken down depends on the view definition, more detailed
/// conventions on how space boundaries are decomposed can only be
/// given at the domain or application type level.
/// 
/// In an architectural or FM related view, a space
/// boundary is defined totally from inside the space. This is a
/// 1st level space boundary.
/// In a thermal view, the decomposition of the space
/// boundary depends on the material of the providing building
/// element and the adjacent spaces behind. This is a
/// 2nd level space boundary.
/// 
/// Figure 42 — Space boundary at first level
/// Figure 43 — Space boundary at second level
/// 
/// Figure 44 — Space boundary at second level type A
/// Figure 45 — Space boundary at second level type B
/// 
/// HISTORY New entity in IFC Release 1.5, the entity has been modified in IFC Release
/// 2x.
/// IFC2x CHANGE The data type of the attributeRelatedBuildingElement has
/// been changed from IfcBuildingElement to its supertype IfcElement. The data type of the attribute
/// ConnectionGeometry has been changed from IfcConnectionSurfaceGeometry to its supertype
/// IfcConnectionGeometry.
/// IFC2x4 CHANGE The attribute RelatedBuildingElement has been made mandatory. For virtual boundaries the reference to IfcVirtualElement is now mandatory.
/// 
/// Attribute Use Definitions
/// The differences between the 1st and
/// 2nd level space boundaries is
/// identified by:
/// 
/// 1st level:
/// SELF\IfcRoot.Name = "1stLevel"
/// SELF\IfcRootDescription = NIL
/// 2nd level:
/// SELF\IfcRoot.Name = "2ndLevel"
/// SELF\IfcRootDescription = "2a", or "2b"
/// 
/// Differentiation between physical and virtual space boundary is illustrated in Figure 46 and Figure 47.
/// 
/// As shown in Figure 46, if the IfcRelSpaceBoundary is used to express a virtual boundary, the attribute PhysicalOrVirtualBoundary has to be set to VIRTUAL. The attribute RelatedBuildingElement shall point to an instance of IfcVirtualElement. If the correct location is of interest, the attribute ConnectionGeometry is required.
/// NOTE The connection geometry, either by a 2D curve or a 3D surface, is used to describe the portion of the "virtual wall" that separates the two spaces. All instances of IfcRelSpaceBoundary given at the adjacent spaces share the same instance of IfcVirtualElement. Each instance of IfcRelSpaceBoundary provides in addition the ConnectionGeometry given within the local placement of each space.
/// 
/// Figure 46 — Space boundary of virtual element
/// 
/// As shown in Figure 47, if the IfcRelSpaceBoundary is used to express a physical boundary between two spaces, the attribute PhysicalOrVirtualBoundary has to be set to PHYSICAL. The attribute RelatedBuildingElement has to be given and points to the element providing the space boundary. The attribute ConnectionGeometry may be inserted, in this case it describes the physical space boundary geometically, or it may be omited, in that case it describes a physical space boundary logically.
/// 
/// Figure 47 — Space boundary of physical element
/// 
/// Geometry Use Definitions
/// The IfcRelSpaceBoundary may have geometry attached. If
/// geometry is not attached, the relationship between space and
/// building element is handled only on a logical level. If geometry
/// is attached, it is given within the local coordinate systems of
/// the space.
/// NOTE: The attributes
/// CurveOnRelatingElement at
/// IfcConnectionCurveGeometry or
/// SurfaceOnRelatingElement at
/// IfcConnectionSurfaceGeometry provide the geometry within
/// the local coordinate system of the IfcSpace, whereas the
/// attributes CurveOnRelatedElement at
/// IfcConnectionCurveGeometry or
/// SurfaceOnRelatedElement at
/// IfcConnectionSurfaceGeometry provide the geometry within
/// the local coordinate system of the subtype of
/// IfcElement.
/// NOTE In most view definitions the connection geometry for
/// the related IfcElement is not
/// provided.
/// The geometric representation (through the
/// ConnectionGeometry attribute) is defined using either 2D
/// curve geometry or 3D surface geometry for space boundaries. In
/// most view definitions the 3D connection surface geometry is
/// required.
/// 
/// 1st level space boundary:
/// 
/// only connection geometry for related space shall be
/// provided
/// only surface connection geometry shall be provided
/// only the following surface representations are supported:
/// 
/// IfcSurfaceOfLinearExtrusion
/// IfcCurveBoundedPlane
/// IfcCurveBoundedSurface
/// IfcFaceBasedSurfaceModel
/// 
/// 2nd level space boundary:
/// 
/// only connection geometry for related space shall be
/// provided
/// only surface connection geometry shall be provided
/// only the following surface representations are supported:
/// 
/// IfcCurveBoundedPlane with restrictions to have
/// polygonal boundaries only
/// IfcFaceBasedSurfaceModel
/// 
/// Surface connection geometry
/// The following constraints apply to the surface connection
/// geometry representation:
/// 
/// planar boundaries:
/// 
/// IfcSurfaceOfLinearExtrusion defined by a
/// SweptCurve being an IfcArbitraryOpenProfileDef with
/// straight segements, or
/// IfcCurveBoundedPlane
/// 
/// curved boundaries
/// 
/// IfcSurfaceOfLinearExtrusion defined by a
/// SweptCurve being an IfcArbitraryOpenProfileDef with
/// curves segements, or
/// IfcCurveBoundedSurface with a BasisSurface
/// being a non planar surface, such as IfcCylindricalSurface,
/// or
/// IfcFaceBasedSurfaceModel if already faceted.
/// 
/// Curve connection geometry
/// The following constraints apply to the 2D curve
/// representation:
/// 
/// Curve: IfcPolyline, IfcTrimmedCurve or
/// IfcCompositeCurve
class IFC_PARSE_API IfcRelSpaceBoundary : public IfcRelConnects {
public:
    /// Reference to one spaces that is delimited by this boundary.
    IfcSpaceBoundarySelect* RelatingSpace() const;
    void setRelatingSpace(IfcSpaceBoundarySelect* v);
    /// Reference to Building Element, that defines the Space Boundaries.
    /// 
    /// IFC2x PLATFORM CHANGE  The data type has been changed from IfcBuildingElement to IfcElement with upward compatibility for file based exchange.
    /// 
    /// IFC2x4 CHANGE  The attribute has been changed to be mandatory.
    IfcElement* RelatedBuildingElement() const;
    void setRelatedBuildingElement(IfcElement* v);
    /// Whether the optional attribute ConnectionGeometry is defined for this IfcRelSpaceBoundary
    bool hasConnectionGeometry() const;
    /// Physical representation of the space boundary. Provided as a curve or surface given within the LCS of the space.
    /// 
    /// IFC2x PLATFORM CHANGE  The data type has been changed from IfcConnectionSurfaceGeometry to IfcConnectionGeometry with upward compatibility for file based exchange.
    IfcConnectionGeometry* ConnectionGeometry() const;
    void setConnectionGeometry(IfcConnectionGeometry* v);
    /// Defines, whether the Space Boundary is physical (Physical) or virtual (Virtual).
    IfcPhysicalOrVirtualEnum::IfcPhysicalOrVirtualEnum PhysicalOrVirtualBoundary() const;
    void setPhysicalOrVirtualBoundary(IfcPhysicalOrVirtualEnum::IfcPhysicalOrVirtualEnum v);
    /// Defines, whether the Space Boundary is internal (Internal), or external, i.e. adjacent to open space (that can be an partially enclosed space, such as terrace (External).
    IfcInternalOrExternalEnum::IfcInternalOrExternalEnum InternalOrExternalBoundary() const;
    void setInternalOrExternalBoundary(IfcInternalOrExternalEnum::IfcInternalOrExternalEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 4: return IfcUtil::Argument_ENTITY_INSTANCE; case 5: return IfcUtil::Argument_ENTITY_INSTANCE; case 6: return IfcUtil::Argument_ENTITY_INSTANCE; case 7: return IfcUtil::Argument_ENUMERATION; case 8: return IfcUtil::Argument_ENUMERATION; } return IfcRelConnects::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 4: return Type::IfcSpaceBoundarySelect; case 5: return Type::IfcElement; case 6: return Type::IfcConnectionGeometry; case 7: return Type::IfcPhysicalOrVirtualEnum; case 8: return Type::IfcInternalOrExternalEnum; } return IfcRelConnects::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 4: return "RelatingSpace"; case 5: return "RelatedBuildingElement"; case 6: return "ConnectionGeometry"; case 7: return "PhysicalOrVirtualBoundary"; case 8: return "InternalOrExternalBoundary"; } return IfcRelConnects::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRelSpaceBoundary (IfcEntityInstanceData* e);
    IfcRelSpaceBoundary (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcSpaceBoundarySelect* v5_RelatingSpace, IfcElement* v6_RelatedBuildingElement, IfcConnectionGeometry* v7_ConnectionGeometry, IfcPhysicalOrVirtualEnum::IfcPhysicalOrVirtualEnum v8_PhysicalOrVirtualBoundary, IfcInternalOrExternalEnum::IfcInternalOrExternalEnum v9_InternalOrExternalBoundary);
    typedef IfcTemplatedEntityList< IfcRelSpaceBoundary > list;
};
/// The 1st level space boundary
/// defines the physical or virtual delimiter of a space by the
/// relationship IfcRelSpaceBoundary1stLevel to the
/// surrounding elements. 1st level space boundaries are
/// characterizeda by:
/// 
/// 1st level space boundaries are the boundaries of a space
/// defined by the surfaces of building elements bounding this space
/// (physical space boundaries) or by virtual surfaces provided by an
/// adjacent space with no dividing wall.
/// 1st level space boundaries do not consider any change of
/// material in the bounding building elements, or different
/// spaces/zones behind a wall or slab (floor or ceiling).
/// 1st level space boundaries are differentiated in two ways:
/// virtual or physical and internal,external, or undefined (internal
/// and external) e.g. for a wall that is partially inside and
/// outside.
/// 1st level space boundaries form a closed shell around the
/// space (so long as the space is completely enclosed) and include
/// overlapping boundaries representing openings (filled or not) in
/// the building elements (see implementers agreement below).
/// 
/// 1st level space boundaries define a space by its boundary
/// surfaces without taking anything on the other side of the
/// bounding elements into account.
/// NOTE 1st level space boundaries are used e.g.
/// in quantity take-off and facility management as they describe the
/// surfaces for finishes. They cannot be directly used for thermal
/// analysis. However 1st level space boundaries can provide the
/// input to preprocessors to thermal analysis software that take 1st
/// level space boundaries and perform the necessary transformation
/// into 2nd level space boundaries that are required for energy
/// analysis.
/// 
/// HISTORY New entity in IFC2x4.
/// 
/// Relationship Use Definitions
/// 
/// As shown in Figure 48, the attribute ParentBoundary with inverse InnerBoundaries is provided to link the space boundaries of doors, windows, and openings to the parent boundary, such as of a wall or slab.
/// NOTE The space boundary of the parent is not cut by the inner boundary - both overlap.
/// 
/// Figure 48 — Space boundary first level relationships
/// 
/// Geometry Use Definitions
/// See the definition at the supertype IfcRelSpaceBoundary for
/// guidance on using the connection geometry for first level space
/// boundaries.
class IFC_PARSE_API IfcRelSpaceBoundary1stLevel : public IfcRelSpaceBoundary {
public:
    /// Whether the optional attribute ParentBoundary is defined for this IfcRelSpaceBoundary1stLevel
    bool hasParentBoundary() const;
    /// Reference to the host, or parent, space boundary within which this inner boundary is defined.
    IfcRelSpaceBoundary1stLevel* ParentBoundary() const;
    void setParentBoundary(IfcRelSpaceBoundary1stLevel* v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcRelSpaceBoundary::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcRelSpaceBoundary1stLevel; } return IfcRelSpaceBoundary::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "ParentBoundary"; } return IfcRelSpaceBoundary::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcRelSpaceBoundary1stLevel >::ptr InnerBoundaries() const; // INVERSE IfcRelSpaceBoundary1stLevel::ParentBoundary
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRelSpaceBoundary1stLevel (IfcEntityInstanceData* e);
    IfcRelSpaceBoundary1stLevel (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcSpaceBoundarySelect* v5_RelatingSpace, IfcElement* v6_RelatedBuildingElement, IfcConnectionGeometry* v7_ConnectionGeometry, IfcPhysicalOrVirtualEnum::IfcPhysicalOrVirtualEnum v8_PhysicalOrVirtualBoundary, IfcInternalOrExternalEnum::IfcInternalOrExternalEnum v9_InternalOrExternalBoundary, IfcRelSpaceBoundary1stLevel* v10_ParentBoundary);
    typedef IfcTemplatedEntityList< IfcRelSpaceBoundary1stLevel > list;
};
/// The 2nd level space boundary defines the physical or virtual delimiter of a space by the relationship IfcRelSpaceBoundary2ndLevel to the surrounding elements. 2nd level space boundaries are characterized by:
/// 
/// 2nd level space boundaries still represent building elements that bound the space, but are more granular in that they are subdivided in any of the following cases:
/// 
/// Differences in materials and/or material assemblies (for example, a wainscot or paneling on the lower portion of a wall).
/// Differences in spaces or zones on the other side of the building element (or virtual boundary) represented by the space boundary (for example, two different spaces on the other side of a wall)
/// 
/// 2nd level space boundaries are differentiated in two ways: virtual or physical and internal or external, whereby any space boundary that is both internal and external has to be split into segments being either or.
/// 2nd level space boundaries represent both sides of a heat transfer surface separated by the thickness of the building element. They can be further differentiated in:
/// 
/// Type 2a that occurs when there is a space on the opposite side of the building element providing the space boundary
/// Type 2b occurs if there is a building element on the opposite side of the building element providing the space boundary.
/// 
/// The connection geometry of 2nd level space boundaries is restricted to planar surfaces only. This means that curved surfaces must be segmented.
/// 
/// 2nd level space boundaries define the heat transfer surfaces on both sides of building elements that separate spaces. The generation of 2nd level space boundaries has to take building elements and spaces on the other side into account.
/// NOTE 2nd level space boundaries are used by many analysis packages that require a surface view of the building that can be transformed into the various simple topological models. Examples of such analysis packages include: (1) energy analysis, (2) lighting analysis, (3) fluid dynamics
/// 
/// HISTORY New entity in IFC2x4.
/// 
/// Relationship Use Definitions
/// As shown in Figure 49, the attribute ParentBoundary with inverse InnerBoundaries is provided to link the space boundaries of doors, windows, and openings to the parent boundary, such as of a wall or slab.
/// NOTE The space boundary of the parent is not cut by the inner boundary - both overlap.
/// The attribute CorrespondingBoundary with inverse Corresponds is provided to link the pair of space boundaries on the opposite sides of the building element.
/// NOTE Only 2nd level space boundaries of type A have corresponding boundaries.
/// 
/// Figure 49 — Space boundary second level relationships
/// 
/// Geometry Use Definitions
/// See the definition at the supertype IfcRelSpaceBoundary
/// for guidance on using the connection geometry for second level
/// space boundaries.
class IFC_PARSE_API IfcRelSpaceBoundary2ndLevel : public IfcRelSpaceBoundary1stLevel {
public:
    /// Whether the optional attribute CorrespondingBoundary is defined for this IfcRelSpaceBoundary2ndLevel
    bool hasCorrespondingBoundary() const;
    /// Reference to the other space boundary of the pair of two space boundaries on either side of a space separating thermal boundary element.
    IfcRelSpaceBoundary2ndLevel* CorrespondingBoundary() const;
    void setCorrespondingBoundary(IfcRelSpaceBoundary2ndLevel* v);
    virtual unsigned int getArgumentCount() const { return 11; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 10: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcRelSpaceBoundary1stLevel::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 10: return Type::IfcRelSpaceBoundary2ndLevel; } return IfcRelSpaceBoundary1stLevel::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 10: return "CorrespondingBoundary"; } return IfcRelSpaceBoundary1stLevel::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcRelSpaceBoundary2ndLevel >::ptr Corresponds() const; // INVERSE IfcRelSpaceBoundary2ndLevel::CorrespondingBoundary
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRelSpaceBoundary2ndLevel (IfcEntityInstanceData* e);
    IfcRelSpaceBoundary2ndLevel (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcSpaceBoundarySelect* v5_RelatingSpace, IfcElement* v6_RelatedBuildingElement, IfcConnectionGeometry* v7_ConnectionGeometry, IfcPhysicalOrVirtualEnum::IfcPhysicalOrVirtualEnum v8_PhysicalOrVirtualBoundary, IfcInternalOrExternalEnum::IfcInternalOrExternalEnum v9_InternalOrExternalBoundary, IfcRelSpaceBoundary1stLevel* v10_ParentBoundary, IfcRelSpaceBoundary2ndLevel* v11_CorrespondingBoundary);
    typedef IfcTemplatedEntityList< IfcRelSpaceBoundary2ndLevel > list;
};
/// IfcRelVoidsElement is an objectified relationship between a building element and one opening element that creates a void in the element. It is a one-to-one relationship. This relationship implies a Boolean operation of subtraction between the geometric bodies of the element and the opening.
/// 
/// As shown in Figure 50, the insertion of a void into a wall is represented by the relationship IfcRelVoidsElement. The opening is created within the wall by IfcWall(StandardCase) o-- IfcRelVoidsElement --o IfcOpeningElement.
/// 
/// Figure 50 — Relationship for element voiding
/// 
/// HISTORY New entity in IFC Release 1.0
class IFC_PARSE_API IfcRelVoidsElement : public IfcRelDecomposes {
public:
    IfcElement* RelatingBuildingElement() const;
    void setRelatingBuildingElement(IfcElement* v);
    IfcFeatureElementSubtraction* RelatedOpeningElement() const;
    void setRelatedOpeningElement(IfcFeatureElementSubtraction* v);
    virtual unsigned int getArgumentCount() const { return 6; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 4: return IfcUtil::Argument_ENTITY_INSTANCE; case 5: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcRelDecomposes::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 4: return Type::IfcElement; case 5: return Type::IfcFeatureElementSubtraction; } return IfcRelDecomposes::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 4: return "RelatingBuildingElement"; case 5: return "RelatedOpeningElement"; } return IfcRelDecomposes::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRelVoidsElement (IfcEntityInstanceData* e);
    IfcRelVoidsElement (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcElement* v5_RelatingBuildingElement, IfcFeatureElementSubtraction* v6_RelatedOpeningElement);
    typedef IfcTemplatedEntityList< IfcRelVoidsElement > list;
};
/// Definition from ISO/CD 10303-42:1992: The
///   reparametrised composite curve segment is a special type of
///   composite curve segment which provides the capability to
///   re-define its parametric length without changing its
///   geometry.
/// 
/// Let l = ParamLength.
/// 
/// If t0 ≤ t ≤
///   t1 is the parameter range of
///   ParentCurve, the new parameter . for the
///   reparametrised composite curve segment is given by the
///   equation:
/// 
/// if SameSense = TRUE;
/// 
/// or by the equation:
/// 
/// if SameSense = FALSE;
/// 
/// NOTE Corresponding STEP entity: reparametrised_composite_curve_segment. Please refer to ISO/IS 10303-42:1994, p.59 for the final definition of the formal standard.
/// 
/// HISTORY New class in IFC2x4
class IFC_PARSE_API IfcReparametrisedCompositeCurveSegment : public IfcCompositeCurveSegment {
public:
    double ParamLength() const;
    void setParamLength(double v);
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 3: return IfcUtil::Argument_DOUBLE; } return IfcCompositeCurveSegment::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 3: return Type::IfcParameterValue; } return IfcCompositeCurveSegment::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 3: return "ParamLength"; } return IfcCompositeCurveSegment::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcReparametrisedCompositeCurveSegment (IfcEntityInstanceData* e);
    IfcReparametrisedCompositeCurveSegment (IfcTransitionCode::IfcTransitionCode v1_Transition, bool v2_SameSense, IfcCurve* v3_ParentCurve, double v4_ParamLength);
    typedef IfcTemplatedEntityList< IfcReparametrisedCompositeCurveSegment > list;
};
/// IfcResource contains the information needed to represent the costs, schedule, and other impacts from the use of a thing in a process. It is not intended to use IfcResource to model the general properties of the things themselves, while an optional linkage from IfcResource to the things to be used can be specified (specifically, the relationship from subtypes of IfcResource to IfcProduct through the IfcRelAssignsToResource relationship).  
/// 
/// There are two basic intended uses of IfcResource. First, if the attributes of the thing are not needed for the purpose of the use of IfcResource, or the types of things are not explicitly modeled in IFC yet, then the linkage between the resource and the thing doesn't have to be instantiated in the system. That is, the attributes of IfcResource (or its subtypes) alone are sufficient to represent the use of the thing as a resource for the purpose of the project.  
/// 
/// EXAMPLE: construction equipment such as earth-moving vehicles or tools are not currently modeled within the IFC. For the purpose of estimating and scheduling, these can be represented using subtypes of IfcResource alone.
/// 
/// Second, if the attributes of the thing are needed for the use of IfcResource objects, and they are modeled explicitly as objects, then the IfcResource instances can be linked to the instances of the type of the things being referenced. Things that might be used as resources and that are already modeled in the IFC include physical products, people and organizations, and materials. The relationship object IfcRelAssignsToResource is provided for this approach. 
/// 
/// The inherited attribute ObjectType is used as a textual code that identifies the resource type.  
/// 
/// HISTORY New entity in IFC Release 1.0
/// 
/// IFC2x PLATFORM CHANGE: The attributes BaseUnit and ResourceConsumption have been removed from the abstract entity; they are reintroduced at a lower level in the hierarchy.
class IFC_PARSE_API IfcResource : public IfcObject {
public:
    /// Whether the optional attribute Identification is defined for this IfcResource
    bool hasIdentification() const;
    /// An identifying designation given to a resource.
    ///   It is the identifier at the occurrence level. 
    /// 
    /// IFC2x4 CHANGE  Attribute promoted from subtype IfcConstructionResource.
    std::string Identification() const;
    void setIdentification(std::string v);
    /// Whether the optional attribute LongDescription is defined for this IfcResource
    bool hasLongDescription() const;
    /// A detailed description of the resource (e.g. the skillset for a labor resource).  
    /// 
    /// IFC2x4 NOTE:  The attribute LongDescription is added replacing the ResourceGroup attribute at subtype IfcConstructionResource.
    std::string LongDescription() const;
    void setLongDescription(std::string v);
    virtual unsigned int getArgumentCount() const { return 7; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 5: return IfcUtil::Argument_STRING; case 6: return IfcUtil::Argument_STRING; } return IfcObject::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 5: return Type::IfcIdentifier; case 6: return Type::IfcText; } return IfcObject::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 5: return "Identification"; case 6: return "LongDescription"; } return IfcObject::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcRelAssignsToResource >::ptr ResourceOf() const; // INVERSE IfcRelAssignsToResource::RelatingResource
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcResource (IfcEntityInstanceData* e);
    IfcResource (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, boost::optional< std::string > v6_Identification, boost::optional< std::string > v7_LongDescription);
    typedef IfcTemplatedEntityList< IfcResource > list;
};
/// An IfcRevolvedAreaSolid is a solid created by revolving
/// a cross section provided by a profile definition about an axis. The
/// axis and the cross section shall be in the same plane.
/// NOTE Both the axis and the cross section are
/// required to lie in the xy plane of the object position coordinate
/// system.
/// The following definitions from ISO 10303-42 apply:
/// 
/// A revolved area solid
/// is a solid formed by revolving a planar bounded surface about an
/// axis. The axis shall be in the plane of the surface and the axis
/// shall not intersect the interior of the bounded surface. The
/// bounded surface may have holes which will sweep into holes in the
/// solid. The direction of revolution is clockwise when viewed along
/// the axis in the positive direction. More precisely if A is
/// the axis location and d is the axis direction and C
/// is an arc on the surface of revolution generated by an arbitrary
/// point p on the boundary of the swept area, then C
/// leaves p in direction d x (p - A) as
/// the area is revolved.
/// 
/// Figure 262 illustrates geometric parameters of the revolved solid. The revolved area solid defines the revolution of a 2D area (given by a profile definition) by an axis and angle. The result is a solid. The swept area is given by a profile definition. This profile is defined: 
/// 
/// as a 2D bounded curve within the xy plane of the position coordinate system,
/// as a 2D bounded curve with holes within the xy plane of the position coordinate system,
/// or as a 2D primitive, defined within a 2D position coordinate system, that is placed relative to the xy plane of the position coordinate system
/// 
/// The AxisLine can have any orientation within the XY plane, it does not have to be parallel to the y-axis as shown in the illustration.
/// 
/// Figure 262 — Revolved area solid geometry
/// 
/// NOTE  Corresponding ISO 10303-42 entity: revolved_area_solid. Please refer to ISO/IS 10303-42:1994, p. 184 for the final definition of the formal standard. The data type of the inherited SweptArea attribute is different, i.e. of type IfcProfileDef. The position attribute has been added to position the cross section used for the revolution.
/// 
/// HISTORY  New entity in IFC Release 1.5, capabilities of this entity have been enhanced in IFC Release 2x.
/// 
/// Informal propositions:
/// 
/// The AxisLine shall lie in the plane of the
/// SweptArea (as defined at supertype
/// IfcSweptAreaSolid).
/// The AxisLine shall not intersect the interior of the
/// SweptArea (as defined at supertype
/// IfcSweptAreaSolid).
/// The Angle shall be between 0° and 360°, or 0
/// and 2π (depending on the unit type for
/// IfcPlaneAngleMeasure).
/// 
/// Texture Use Definition
/// For side faces, textures are aligned facing upright along the
/// sides with origin at the first point of an arbitrary profile, and
/// following the outer bound of the profile counter-clockwise (as seen
/// from above). For parameterized profiles, the origin is defined at
/// the +Y extent for rounded profiles (having no sharp edge) and the
/// first sharp edge counter-clockwise from the +Y extent for all other
/// profiles. Textures are stretched or repeated on each side along the
/// outer boundary of the profile according to RepeatS.
/// Textures are stretched or repeated on each side along the outermost
/// (longest) revolution path according to RepeatT, where
/// coordinates are compressed towards the axis of revolution.
/// For top and bottom caps, textures are aligned facing
/// front-to-back, with the origin at the minimum X and Y extent.
/// Textures are stretched or repeated on the top and bottom to the
/// extent of each face according to RepeatS and
/// RepeatT.
/// For profiles with voids, textures are aligned facing upright
/// along the inner side with origin at the first point of an arbitrary
/// profile, and following the inner bound of the profile clockwise (as
/// seen from above). For parameterized profiles, the origin of inner
/// sides is defined at the +Y extent for rounded profiles (having no
/// sharp edge such as hollow ellipses or rounded rectangles) and the
/// first sharp edge clockwise from the +Y extent for all other
/// profiles.
/// 
/// Figure 263 illustrates default texture mapping with a repeated texture (RepeatS=True and RepeatT=True). The image on the left shows the texture where the S axis points to the right and the T axis points up. The image on the right shows the texture applied to the geometry where the X axis points back to the right, the Y axis points back to the left, and the Z axis points up. For an IfcRevolvedAreaSolid having a profile of IfcTShapeProfileDef and revolved at 22.5 degrees, the side texture coordinate origin is the first corner counter-clockwise from the +Y axis, which equals (-0.5*IfcTShapeProfileDef.OverallWidth, +0.5*IfcTShapeProfileDef.OverallDepth), while the top (end cap) texture coordinates start at (-0.5*IfcTShapeProfileDef.OverallWidth, -0.5*IfcTShapeProfileDef.OverallDepth).
/// 
/// Figure 263 — Revolved area solid textures
class IFC_PARSE_API IfcRevolvedAreaSolid : public IfcSweptAreaSolid {
public:
    /// Axis about which revolution will take place.
    IfcAxis1Placement* Axis() const;
    void setAxis(IfcAxis1Placement* v);
    /// The angle through which the sweep will be made. This angle is measured from the plane of the swept area provided by the XY plane of the position coordinate system.
    double Angle() const;
    void setAngle(double v);
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 2: return IfcUtil::Argument_ENTITY_INSTANCE; case 3: return IfcUtil::Argument_DOUBLE; } return IfcSweptAreaSolid::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 2: return Type::IfcAxis1Placement; case 3: return Type::IfcPlaneAngleMeasure; } return IfcSweptAreaSolid::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 2: return "Axis"; case 3: return "Angle"; } return IfcSweptAreaSolid::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRevolvedAreaSolid (IfcEntityInstanceData* e);
    IfcRevolvedAreaSolid (IfcProfileDef* v1_SweptArea, IfcAxis2Placement3D* v2_Position, IfcAxis1Placement* v3_Axis, double v4_Angle);
    typedef IfcTemplatedEntityList< IfcRevolvedAreaSolid > list;
};
/// IfcRevolvedAreaSolidTapered is defined by revolving a
/// cross section along a circular arc. The cross section may change
/// along the revolving sweep from the shape of the start cross
/// section into the shape of the end cross section. Corresponding
/// vertices of the start and end cross sections are then connected.
/// The bounded surface may have holes which will sweep into holes in
/// the solid.
/// The rotation axis is defined by:
/// 
/// Start point:
/// SELF\IfcSweptAreaSolid.Position.Location
/// Direction: SELF\IfcRevolvedAreaSolid.Axis
/// Rotation axis: SELF\IfcRevolvedAreaSolid.AxisLine,
/// created from start point and direction by appying a 1 unit
/// magnitude.
/// Orientation: Positive angles are applied clockwise when
/// looking into the positive direction of the rotation axis.
/// 
/// The start cross section is defined by
/// SELF\IfcSweptAreaSolid.SweptArea:
/// 
/// A bounded planar surface lying in the XY plane of the
/// position coordinate system defined by
/// SELF\IfcSweptAreaSolid.Position.P[1] and
/// SELF\IfcSweptAreaSolid.Position.P[2]
/// The rotation axis lies in the plane of the start cross
/// section but shall not intersect the interior of the start cross
/// section.
/// 
/// The end cross section is defined by EndSweptArea:
/// 
/// A bounded planar surface lying in the XY plane of the
/// position coordinate system defined by rotating the start position
/// coordinates provided by SELF\IfcSweptAreaSolid.Position
/// around the rotation axis by the angle given by
/// SELF\IfcRevolvedAreaSolid.Angle.
/// 
/// The end cross section is topologically similar to the start
/// cross section (having the same number of vertices and edges).
/// The end cross section can either be defined by the same
/// paramteric profile using different parameter values, or by a 2D
/// Cartesian transformation of the start profile within the end
/// cross section plane.
/// 
/// The solid is generated by transforming the start cross section
/// into to end cross section. A start face, an end face (each
/// defined by start and end cross sections), and one or more lateral
/// faces. Each lateral face is a ruled surface defined by a pair of
/// corresponding edges of the start and end section. The ruled
/// surfaces are constructed in the cylindrical coordinate space
/// defined by the supertype IfcRevolvedAreaSolid."
/// 
/// HISTORY New entity in IFC2x4.
/// 
/// Informal propositions
/// 
/// Mirroring within IfcDerivedProfileDef.Operator shall
/// not be used
class IFC_PARSE_API IfcRevolvedAreaSolidTapered : public IfcRevolvedAreaSolid {
public:
    IfcProfileDef* EndSweptArea() const;
    void setEndSweptArea(IfcProfileDef* v);
    virtual unsigned int getArgumentCount() const { return 5; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 4: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcRevolvedAreaSolid::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 4: return Type::IfcProfileDef; } return IfcRevolvedAreaSolid::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 4: return "EndSweptArea"; } return IfcRevolvedAreaSolid::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRevolvedAreaSolidTapered (IfcEntityInstanceData* e);
    IfcRevolvedAreaSolidTapered (IfcProfileDef* v1_SweptArea, IfcAxis2Placement3D* v2_Position, IfcAxis1Placement* v3_Axis, double v4_Angle, IfcProfileDef* v5_EndSweptArea);
    typedef IfcTemplatedEntityList< IfcRevolvedAreaSolidTapered > list;
};
/// The IfcRightCircularCone is a Construction Solid
/// Geometry (CSG) 3D primitive. It is a solid with a circular base and
/// a point called apex as the top. The tapers from the base to the
/// top. The axis from the center of the circular base to the apex is
/// perpendicular to the base. The inherited Position
/// attribute defines the IfcAxisPlacement3D and provides the
/// location and orientation of the cone:
/// 
/// SELF\IfcCsgPrimitive3D.Position: The location and
/// orientation of the axis system for the primitive. 
/// SELF\IfcCsgPrimitive3D.Position.Location: The center
/// of the circular area being the bottom face of the cone.
/// SELF\IfcCsgPrimitive3D.Position.Position[3]: The
/// z-axis of the inherited placement coordinate system provides the
/// center axis of the IfcRightCircularCone, and the apex is
/// at the Height value applied to the positive direction of
/// the z-axis. The BottomRadius defines the circular base at
/// the xy-plane of the placement coordinate system.
/// 
/// Figure 264 illustrates geometric parameters of the cone. The cone is positioned within its own placement coordinate system. The origin is the center of the bottom circular disk, that lies in the XY plane. The apex lies on the positive z axis at [0, 0, Height].
/// 
/// Figure 264 — Right circular cone geometry
/// 
/// NOTE  Corresponding ISO 10303 entity: right_circular_cone, the position attribute has been promoted to the immediate supertype IfcCsgPrimitive3D. No semi_angle attribute, and the radius defines the bottom radius, since only a non-truncated cone is in scope. Please refer to ISO/IS 10303-42:1994, p. 176 for the final definition of the formal standard.
/// 
/// HISTORY  New entity in IFC2x3
/// 
/// Texture use definition
/// On the circular side, textures are aligned facing upright with
/// origin at the back (+Y direction) revolving counter-clockwise.
/// Textures are stretched or repeated to the extent of the base
/// circumference according to RepeatS. Textures are compressed
/// linearly going upwards towards the top point according to
/// RepeatT.
/// On the bottom face, textures are aligned facing front-to-back,
/// with the center of the circle aligned to the center of the
/// texture.
/// 
/// Figure 265 illustrates default texture mapping with a clamped texture (RepeatS=False and RepeatT=False). The image on the left shows the texture where the S axis points to the right and the T axis points up. The image on the right shows the texture applied to the geometry where the X axis points back to the right, the Y axis points back to the left, and the Z axis points up.
/// 
/// Side
/// Normal
/// Origin X
/// Origin Y
/// Origin Z
/// S Axis
/// T Axis
/// 
/// Side
/// -Y
/// 0
/// +Radius
/// 0
/// -X
/// (towards top point)
/// 
/// Bottom
/// -Z
/// 0
/// 0
/// 0
/// -X
/// +Y
/// 
/// Figure 265 — Right circular cone textures
class IFC_PARSE_API IfcRightCircularCone : public IfcCsgPrimitive3D {
public:
    /// The distance between the base of the cone and the apex.
    double Height() const;
    void setHeight(double v);
    /// The radius of the cone at the base.
    double BottomRadius() const;
    void setBottomRadius(double v);
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 1: return IfcUtil::Argument_DOUBLE; case 2: return IfcUtil::Argument_DOUBLE; } return IfcCsgPrimitive3D::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 1: return Type::IfcPositiveLengthMeasure; case 2: return Type::IfcPositiveLengthMeasure; } return IfcCsgPrimitive3D::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 1: return "Height"; case 2: return "BottomRadius"; } return IfcCsgPrimitive3D::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRightCircularCone (IfcEntityInstanceData* e);
    IfcRightCircularCone (IfcAxis2Placement3D* v1_Position, double v2_Height, double v3_BottomRadius);
    typedef IfcTemplatedEntityList< IfcRightCircularCone > list;
};
/// The IfcRightCircularCylinder is a Construction Solid
/// Geometry (CSG) 3D primitive. It is a solid with a circular base and
/// top. The cylindrical surface between if formed by points at a fixed
/// distance from the axis of the cylinder. The inherited
/// Position attribute defines the IfcAxisPlacement3D
/// and provides:
/// 
/// SELF\IfcCsgPrimitive3D.Position: The location and
/// orientation of the axis system for the primitive.
/// SELF\IfcCsgPrimitive3D.Position.Location: The center
/// of the circular area being the bottom face of the cylinder.
/// SELF\IfcCsgPrimitive3D.Position.Position[3]: The z
/// axis provides the center axis and the height is measured from the
/// origin along the positive direction of the z axis.
/// 
/// The following definitions from ISO 10303-42 apply:
/// 
/// A right circular
/// cylinder is a CSG primitive in the form of a solid cylinder of
/// finite height. It is defined by an axis point at the centre of one
/// planar circular face, an axis, a height, and a radius. The faces
/// are perpendicular to the axis and are circular discs with the
/// specified radius. The height is the distance from the first
/// circular face centre in the positive direction of the axis to the
/// second circular face centre.
/// 
/// Figure 266 illustrates geometric parameters of the cylinder. The cylinder is positioned within its own placement coordiante system. The origin is the center of the bottom circular disk, that lies in the XY plane. The center of the top circular disk is on the positive z axis at [0, 0, Height].
/// 
/// Figure 266 — Right circular cylinder geometry
/// 
/// NOTE  Corresponding ISO 10303 entity: right_circular_cyclinder, the position attribute has been promoted to the immediate supertype IfcCsgPrimitive3D. Please refer to ISO/IS 10303-42:1994, p. 177 for the definition in the international standard.
/// 
/// HISTORY  New entity in IFC2x3.
/// 
/// Texture use definition
/// On the circular side, textures are aligned facing upright with
/// origin at the back (+Y direction) revolving counter-clockwise.
/// Textures are stretched or repeated to the extent of the
/// circumference according to RepeatS. Textures are stretched or
/// repeated to the extent of the Height according to
/// RepeatT.
/// On the top and bottom faces, textures are aligned facing
/// front-to-back, with the center of the circle aligned to the center
/// of the texture.
/// 
/// Figure 267 illustrates default texture mapping with a clamped texture (RepeatS=False and RepeatT=False). The image on the left shows the texture where the S axis points to the right and the T axis points up. The image on the right shows the texture applied to the geometry where the X axis points back to the right, the Y axis
/// points back to the left, and the Z axis points up.
/// 
/// Side
/// Normal
/// Origin X
/// Origin Y
/// Origin Z
/// S Axis
/// T Axis
/// 
/// Side
/// -Y
/// 0
/// +Radius
/// 0
/// -X
/// +Z
/// 
/// Bottom
/// -Z
/// 0
/// 0
/// 0
/// -X
/// +Y
/// 
/// Top
/// +Z
/// 0
/// 0
/// +Height
/// +X
/// +Y
/// 
/// Figure 267 — Right circular cylinder textures
class IFC_PARSE_API IfcRightCircularCylinder : public IfcCsgPrimitive3D {
public:
    /// The distance between the planar circular faces of the cylinder.
    double Height() const;
    void setHeight(double v);
    /// The radius of the cylinder.
    double Radius() const;
    void setRadius(double v);
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 1: return IfcUtil::Argument_DOUBLE; case 2: return IfcUtil::Argument_DOUBLE; } return IfcCsgPrimitive3D::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 1: return Type::IfcPositiveLengthMeasure; case 2: return Type::IfcPositiveLengthMeasure; } return IfcCsgPrimitive3D::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 1: return "Height"; case 2: return "Radius"; } return IfcCsgPrimitive3D::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRightCircularCylinder (IfcEntityInstanceData* e);
    IfcRightCircularCylinder (IfcAxis2Placement3D* v1_Position, double v2_Height, double v3_Radius);
    typedef IfcTemplatedEntityList< IfcRightCircularCylinder > list;
};
/// The IfcSimplePropertyTemplate defines the template for
/// all dynamically extensible properties, either the subtypes of
/// IfcSimpleProperty, or the subtypes of
/// IfcPhysicalSimpleQuantity. The individual property
/// templates are interpreted according to their Name
/// attribute and may have a predefined template type, property units,
/// and property data types. The correct interpretation of the
/// attributes:
/// 
/// PrimaryUnit
/// SecondaryUnit
/// PrimaryDataType
/// SecondaryDataType
/// 
/// is determined by the TemplateType. The
/// TemplateType also controls, which subtype of either
/// IfcSimpleProperty or IfcPhysicalSimpleQuantity
/// shall be used for property occurrences corresponding to this
/// template.
/// 
/// HISTORY  New entity in IFC2x4.
/// 
/// Relationship use definition
/// The IfcSimplePropertyTemplate is part of the set of
/// templates included in the IfcPropertySetTemplate. The
/// template can be accessed throught the inverse attribute
/// PartOfPsetTemplate The IfcPropertySetTemplate may
/// define one or several instances of IfcPropertySet (or
/// IfcElementQuantity). The definition assignment is
/// established by the objectified relationship
/// IfcRelDefinesByTemplate.
/// There is no direct link between an
/// IfcSimplePropertyTemplate and a subtype of either
/// IfcSimpleProperty or IfcPhysicalSimpleQuantity.
/// The definition relationship between the template and the individual
/// properties (or quantities) is established by the Name
/// attributes.
/// 
/// Constraints at
/// IfcPropertySetTemplate and IfcPropertySet (and
/// IfcElementQuantity) guarantee that the Name
/// attributes of included property templates and individual properties
/// are unique.
/// 
/// Figure 9 — Property template relationships
class IFC_PARSE_API IfcSimplePropertyTemplate : public IfcPropertyTemplate {
public:
    /// Whether the optional attribute TemplateType is defined for this IfcSimplePropertyTemplate
    bool hasTemplateType() const;
    /// Property type defining whether the property template defines a property with a single value, a bounded value, a list value, a table value, an enumerated value, or a reference value. Or the quantity type defining whether the template defines a quantity with a length, area, volume, weight or time value.
    /// 
    /// NOTE the value of this property determines the correct use of the PrimaryUnit, SecondaryUnit, PrimaryDataType, SecondaryDataType, and Expression attributes.
    IfcSimplePropertyTemplateTypeEnum::IfcSimplePropertyTemplateTypeEnum TemplateType() const;
    void setTemplateType(IfcSimplePropertyTemplateTypeEnum::IfcSimplePropertyTemplateTypeEnum v);
    /// Whether the optional attribute PrimaryMeasureType is defined for this IfcSimplePropertyTemplate
    bool hasPrimaryMeasureType() const;
    std::string PrimaryMeasureType() const;
    void setPrimaryMeasureType(std::string v);
    /// Whether the optional attribute SecondaryMeasureType is defined for this IfcSimplePropertyTemplate
    bool hasSecondaryMeasureType() const;
    std::string SecondaryMeasureType() const;
    void setSecondaryMeasureType(std::string v);
    /// Whether the optional attribute Enumerators is defined for this IfcSimplePropertyTemplate
    bool hasEnumerators() const;
    IfcPropertyEnumeration* Enumerators() const;
    void setEnumerators(IfcPropertyEnumeration* v);
    /// Whether the optional attribute PrimaryUnit is defined for this IfcSimplePropertyTemplate
    bool hasPrimaryUnit() const;
    /// Primary unit assigned to the definition of the property. It should be provided, if the PropertyType is set to:
    /// 
    /// P_SINGLEVALUE: determining the IfcPropertySingleValue.Unit
    /// P_ENUMERATEDVALUE: determining the IfcPropertyEnumeration.Unit
    /// P_BOUNDEDVALUE: determining the IfcPropertyBoundedValue.Unit
    /// P_LISTVALUE: determining the IfcPropertyListValue.Unit
    /// P_TABLEVALUE: determining the IfcPropertyTableValue.DefiningUnit
    IfcUnit* PrimaryUnit() const;
    void setPrimaryUnit(IfcUnit* v);
    /// Whether the optional attribute SecondaryUnit is defined for this IfcSimplePropertyTemplate
    bool hasSecondaryUnit() const;
    /// Secondary unit assigned to the definition of the property. It should be provided, if the PropertyType is set to:
    /// 
    /// P_TABLEVALUE: determining the IfcPropertyTableValue.DefinedUnit
    IfcUnit* SecondaryUnit() const;
    void setSecondaryUnit(IfcUnit* v);
    /// Whether the optional attribute Expression is defined for this IfcSimplePropertyTemplate
    bool hasExpression() const;
    /// The expression used to store additional information for the property template depending on the PropertyType. It should the following definitions, if the PropertyType is set to:
    /// 
    /// P_TABLEVALUE: the expression that could be evaluated to define the correlation between the defining values and the defined values.
    /// Q_LENGTH, Q_AREA, Q_VOLUME, Q_COUNT, Q_WEIGTH, Q_TIME: the formula to be used to calculate the quantity
    /// 
    /// NOTE No value shall be asserted if the PropertyType is not listed above.
    std::string Expression() const;
    void setExpression(std::string v);
    /// Whether the optional attribute AccessState is defined for this IfcSimplePropertyTemplate
    bool hasAccessState() const;
    /// Information about the access state of the property. It determines whether a property be viewed and/or modified by any receiving application without specific knowledge of it. 
    /// Attribute use definition for IfcStateEnum
    /// 
    /// READWRITE: Properties of this template are readable and writable. They may be viewed and modified by users of any application. These are typical informational properties set by a user.
    /// 
    /// READONLY: Properties of this template are read-only. They may be viewed but not modified by users of any application. (Applications may generate such values). These are typical automatically generated properties that should be displayed only, but not written back.
    /// 
    /// LOCKED: Properties of this template are locked. They may only be accessed by the owning application (the publisher of the property set template). These are typically application depended, internal properties that should not be published.
    /// 
    /// READWRITELOCKED: Properties of this template are locked, readable, and writable. They may only be accessed by the owning application.
    /// 
    /// READONLYLOCKED: Properties of this template are locked and read-only. They may only be accessed by the owning application.
    IfcStateEnum::IfcStateEnum AccessState() const;
    void setAccessState(IfcStateEnum::IfcStateEnum v);
    virtual unsigned int getArgumentCount() const { return 12; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 4: return IfcUtil::Argument_ENUMERATION; case 5: return IfcUtil::Argument_STRING; case 6: return IfcUtil::Argument_STRING; case 7: return IfcUtil::Argument_ENTITY_INSTANCE; case 8: return IfcUtil::Argument_ENTITY_INSTANCE; case 9: return IfcUtil::Argument_ENTITY_INSTANCE; case 10: return IfcUtil::Argument_STRING; case 11: return IfcUtil::Argument_ENUMERATION; } return IfcPropertyTemplate::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 4: return Type::IfcSimplePropertyTemplateTypeEnum; case 5: return Type::IfcLabel; case 6: return Type::IfcLabel; case 7: return Type::IfcPropertyEnumeration; case 8: return Type::IfcUnit; case 9: return Type::IfcUnit; case 10: return Type::IfcLabel; case 11: return Type::IfcStateEnum; } return IfcPropertyTemplate::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 4: return "TemplateType"; case 5: return "PrimaryMeasureType"; case 6: return "SecondaryMeasureType"; case 7: return "Enumerators"; case 8: return "PrimaryUnit"; case 9: return "SecondaryUnit"; case 10: return "Expression"; case 11: return "AccessState"; } return IfcPropertyTemplate::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcSimplePropertyTemplate (IfcEntityInstanceData* e);
    IfcSimplePropertyTemplate (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< IfcSimplePropertyTemplateTypeEnum::IfcSimplePropertyTemplateTypeEnum > v5_TemplateType, boost::optional< std::string > v6_PrimaryMeasureType, boost::optional< std::string > v7_SecondaryMeasureType, IfcPropertyEnumeration* v8_Enumerators, IfcUnit* v9_PrimaryUnit, IfcUnit* v10_SecondaryUnit, boost::optional< std::string > v11_Expression, boost::optional< IfcStateEnum::IfcStateEnum > v12_AccessState);
    typedef IfcTemplatedEntityList< IfcSimplePropertyTemplate > list;
};
/// Definition from IAI: A spatial element is the
///   generalization of all spatial elements that might be used
///   to define a spatial structure or to define spatial zones.
/// 
/// a hierarchical spatial structure element as
///   IfcSpatialStructureElement
/// 
/// a spatial structure is a hiearchical decomposition
///   of the project. That spatial structure is often used to
///   provide a project structure to organize a building
///   project.
/// 
/// A spatial project structure might define as many
///   levels of decomposition as necessary for the building
///   project. Elements within the spatial project structure
///   are site, building, storey, and space
/// 
/// a spatial zone as IfcSpatialZone
/// 
/// a spatial zone is a non-hierarchical and
///   potentially overlapping decomposition of the project
///   under some functional consideration.
/// 
/// a spatial zone might be used to represent a thermal
///   zone, a lighting zone, a usable area zone.
/// 
/// a spatial zone might have its independent placement
///   and shape representation.
/// 
/// HISTORY New entity in IFC
///   Release 2x Edition 4.
class IFC_PARSE_API IfcSpatialElement : public IfcProduct {
public:
    /// Whether the optional attribute LongName is defined for this IfcSpatialElement
    bool hasLongName() const;
    /// Long name for a spatial structure element, used for informal purposes. It should be used, if available, in conjunction with the inherited Name attribute.
    /// 
    /// NOTE  In many scenarios the Name attribute refers to the short name or number of a spacial element, and the LongName refers to the full name.
    std::string LongName() const;
    void setLongName(std::string v);
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 7: return IfcUtil::Argument_STRING; } return IfcProduct::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 7: return Type::IfcLabel; } return IfcProduct::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 7: return "LongName"; } return IfcProduct::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcRelContainedInSpatialStructure >::ptr ContainsElements() const; // INVERSE IfcRelContainedInSpatialStructure::RelatingStructure
    IfcTemplatedEntityList< IfcRelServicesBuildings >::ptr ServicedBySystems() const; // INVERSE IfcRelServicesBuildings::RelatedBuildings
    IfcTemplatedEntityList< IfcRelReferencedInSpatialStructure >::ptr ReferencesElements() const; // INVERSE IfcRelReferencedInSpatialStructure::RelatingStructure
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcSpatialElement (IfcEntityInstanceData* e);
    IfcSpatialElement (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_LongName);
    typedef IfcTemplatedEntityList< IfcSpatialElement > list;
};
/// Definition from IAI: The IfcSpatialElementType
/// defines a list of commonly shared property set definitions of a
/// spatial structure element and an optional set of product
/// representations. It is used to define a spatial element
/// specification (i.e. the specific element information, that is
/// common to all occurrences of that element type).
/// 
/// NOTE ÿThe product representations are defined as
/// representation maps (at the level of the supertype
/// IfcTypeProduct, which gets assigned by an element
/// occurrence instance through the
/// IfcShapeRepresentation.Item[1] being an
/// IfcMappedItem.
/// 
/// A spatial element type is used to define the common properties
/// of a certain type of a spatial structure element that may be
/// applied to many instances of thatÿtype to assign a specific
/// style. Spatial element types (i.e. the instantiable subtypes) may
/// be exchanged without being already assigned to occurrences.
/// 
/// NOTE ÿThe spatial element types are often used to
/// represent catalogues of predefined spatial types for shared
/// attributes, less so for sharing a common representation
/// map.
/// 
/// The occurrences of subtypes of the abstract
/// IfcSpatialElementType are represented by instances of
/// subtypes of the abstract IfcSpatialElement.
/// 
/// HISTORY ÿNew entity in Release
/// IFC2x Edition 4.
class IFC_PARSE_API IfcSpatialElementType : public IfcTypeProduct {
public:
    /// Whether the optional attribute ElementType is defined for this IfcSpatialElementType
    bool hasElementType() const;
    /// The type denotes a particular type that indicates the object further. The use has to be established at the level of instantiable subtypes. In particular it holds the user defined type, if the enumeration of the attribute 'PredefinedType' is set to USERDEFINED.
    std::string ElementType() const;
    void setElementType(std::string v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_STRING; } return IfcTypeProduct::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcLabel; } return IfcTypeProduct::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "ElementType"; } return IfcTypeProduct::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcSpatialElementType (IfcEntityInstanceData* e);
    IfcSpatialElementType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType);
    typedef IfcTemplatedEntityList< IfcSpatialElementType > list;
};
/// A spatial structure element
/// (IfcSpatialStructureElement) is the generalization of all
/// spatial elements that might be used to define a spatial
/// structure. That spatial structure is often used to provide a
/// project structure to organize a building project.
/// A spatial project structure might define as many levels of
/// decomposition as necessary for the building project. Elements
/// within the spatial project structure are:
/// 
/// site as IfcSite
/// building as IfcBuilding
/// storey as IfcBuildingStorey
/// space as IfcSpace
/// 
/// or aggregations or parts thereof. The composition type
/// declares an element to be either an element itself, or an
/// aggregation (complex) or a decomposition (part). The
/// interpretation of these types is given at each subtype of
/// IfcSpatialStructureElement.
/// The IfcRelAggregates is defined as an 1-to-many
/// relationship and used to establish the relationship between
/// exactly two levels within the spatial project structure. Finally
/// the highest level of the spatial structure is assigned to
/// IfcProject using the IfcRelAggregates.
/// Informal proposition:
/// 
/// The spatial project structure, established by the
/// IfcRelAggregates, shall be acyclic.
/// A site should not be (directly or indirectly) associated to a
/// building, storey or space.
/// A building should not be (directly or indirectly) associated
/// to a storey or space.
/// A storey should not be (directly or indirectly) associated to
/// a space.
/// 
/// HISTORY New entity in IFC Release 2x.
/// 
/// Relationship Use Definition
/// The subtypes of IfcSpatialStructureElement relate to
/// other elements and systems by establishing the following
/// relationships:
/// 
/// Containment of elements :
/// IfcRelContainedInSpatialStructure by inverse attribute
/// ContainsElements, used to assign any element, like
/// building elements, MEP elements, etc. to the spatial structure
/// element in which they are primarily contained.
/// 
/// NOTE This relationship is
/// mandatory for elements in several view definitions and
/// implementer agreements.
/// 
/// Reference of elements :
/// IfcRelReferencedInSpatialStructure by inverse attribute
/// ReferencesElements, used to reference any element, like
/// building elements, MEP elements, etc. in spatial structure
/// elements, other then the one, where it is contained.
/// Reference of systems : IfcRelServicesBuildings
/// by inverse attribute ServicedBySystems, used to reference
/// a sytem, like a building service or electrical distribution
/// system, a zonal system, or a structural analysis system, that is
/// assigned to this spatial structure element.
/// 
/// NOTE Elements within the
/// referenced system may be directly contained (or referenced) by
/// other spatial structure elements.
/// 
/// The subtypes of IfcSpatialStructureElement relate to
/// each other by using the IfcRelAggregates relationship to
/// build the project spatial structure.
/// 
/// Figure 62 shows the use of IfcRelAggregates to establish a spatial structure including site, building, building section and storey. More information is provided at the level of the subtypes.
/// 
/// Figure 62 — Spatial structure element composition
class IFC_PARSE_API IfcSpatialStructureElement : public IfcSpatialElement {
public:
    /// Whether the optional attribute CompositionType is defined for this IfcSpatialStructureElement
    bool hasCompositionType() const;
    /// Denotes, whether the predefined spatial structure element represents itself, or an aggregate (complex) or a part (part). The interpretation is given separately for each subtype of spatial structure element. If no CompositionType is asserted, the dafault value 'ELEMENT' applies.
    /// 
    /// IFC2x4 CHANGE&nbsp
    ///   Attribute made optional.
    IfcElementCompositionEnum::IfcElementCompositionEnum CompositionType() const;
    void setCompositionType(IfcElementCompositionEnum::IfcElementCompositionEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcSpatialElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcElementCompositionEnum; } return IfcSpatialElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "CompositionType"; } return IfcSpatialElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcSpatialStructureElement (IfcEntityInstanceData* e);
    IfcSpatialStructureElement (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_LongName, boost::optional< IfcElementCompositionEnum::IfcElementCompositionEnum > v9_CompositionType);
    typedef IfcTemplatedEntityList< IfcSpatialStructureElement > list;
};
/// Definition from IAI: The element type
///   (IfcSpatialStructureElementType) defines a list of
///   commonly shared property set definitions of a spatial
///   structure element and an optional set of product
///   representations. It is used to define an element
///   specification (i.e. the specific element information, that
///   is common to all occurrences of that element type).
/// 
/// NOTE ÿThe product representations are defined as
///   representation maps (at the level of the supertype
///   IfcTypeProduct, which gets assigned by an element
///   occurrence instance through the
///   IfcShapeRepresentation.Item[1] being an
///   IfcMappedItem.
/// 
/// A spatial structure element type is used to define the
///   common properties of a certain type of a spatial structure
///   element that may be applied to many instances of thatÿtype
///   to assign a specific style. Spatial structure element types
///   (i.e. the instantiable subtypes) may be exchanged without
///   being already assigned to occurrences.
/// 
/// NOTE ÿThe spatial structure element types are
///   often used to represent catalogues of predefined spatial
///   types for shared attributes, less so for sharing a common
///   representation map.
/// 
/// The occurrences of subtypes of the
///   abstractÿIfcSpatialStructureElementType are
///   represented by instances of subtypes of
///   IfcSpatialStructureElement.
/// 
/// HISTORY ÿNew entity in
///   Release IFC2x Edition 3.
class IFC_PARSE_API IfcSpatialStructureElementType : public IfcSpatialElementType {
public:
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcSpatialElementType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcSpatialElementType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcSpatialElementType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcSpatialStructureElementType (IfcEntityInstanceData* e);
    IfcSpatialStructureElementType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType);
    typedef IfcTemplatedEntityList< IfcSpatialStructureElementType > list;
};
/// Definition from IAI: A spatial element is the
/// generalization of all spatial elements that might be used to
/// define a spatial structure or to define spatial zones.
/// 
/// a hierarchical spatial structure element as
/// IfcSpatialStructureElement
/// 
/// a spatial structure is a hiearchical decomposition of the
/// project. That spatial structure is often used to provide a
/// project structure to organize a building project.
/// a spatial project structure might define as many levels of
/// decomposition as necessary for the building project. Elements
/// within the spatial project structure are site, building, storey,
/// and space
/// 
/// a spatial zone as IfcSpatialZone
/// 
/// a spatial zone is a non-hierarchical and potentially
/// overlapping decomposition of the project under some functional
/// consideration.
/// a spatial zone might be used to represent a thermal zone, a
/// construction zone, a lighting zone, a usable area zone.
/// a spatial zone might have its independent placement and shape
/// representation.
/// 
/// NOTE The IfcSpatialZone is different to
/// the IfcZone entity by allowing an own placement and shape
/// representation, whereas IfcZone is only a grouping of
/// IfcSpace's.
/// Attribute Use Definition
/// The IfcSpatialZone inherits and declares these
/// attributes that shall have the following meaning:
/// 
/// Name: A number or designator provided by the user or
/// system for the spatial element, e.g. a space number "1-003",
/// could also be a running number provided by default by the
/// application
/// LongName: Name of the spatial element provided by the
/// user, e.g. a space name "Office".
/// Description: Any additional description provided by
/// the user, e.g. a space description "Corner office with habour
/// view".
/// ObjectType: reserved for typing of spatial elements in
/// case of PredefinedType = .USERDEFINED., restrictions on
/// applicable values might be published in view definitions or
/// implementer agreements.
/// 
/// HISTORY New entity in
/// IFC Release 2x Edition 4.
class IFC_PARSE_API IfcSpatialZone : public IfcSpatialElement {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcSpatialZone
    bool hasPredefinedType() const;
    /// Predefined types to define the particular type of the spatial zone. There may be property set definitions available for each predefined type.
    IfcSpatialZoneTypeEnum::IfcSpatialZoneTypeEnum PredefinedType() const;
    void setPredefinedType(IfcSpatialZoneTypeEnum::IfcSpatialZoneTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcSpatialElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcSpatialZoneTypeEnum; } return IfcSpatialElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "PredefinedType"; } return IfcSpatialElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcSpatialZone (IfcEntityInstanceData* e);
    IfcSpatialZone (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_LongName, boost::optional< IfcSpatialZoneTypeEnum::IfcSpatialZoneTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcSpatialZone > list;
};
/// Definition from IAI: The IfcSpatialZoneType
/// defines a list of commonly shared property set definitions of a
/// space and an optional set of product representations. It is used
/// to define a space specification (i.e. the specific space
/// information, that is common to all occurrences of that space
/// type).
/// 
/// NOTE ÿThe product representations are defined as
/// representation maps (at the level of the supertype
/// IfcTypeProduct, which gets assigned by an element
/// occurrence instance through the
/// IfcShapeRepresentation.Item[1] being an
/// IfcMappedItem.
/// 
/// A spatial zone type is used to define the common properties of
/// a certain type of space that may be applied to many instances of
/// that type to assign a specific style. Space types may be
/// exchanged without being already assigned to occurrences.
/// 
/// NOTE ÿThe spatial zone types are often used to
/// represent space catalogues, less so for sharing a common
/// representation map. Spatial zone types in a space catalogue share
/// same space classification and a common set of space requirement
/// properties.
/// 
/// The occurrences of IfcSpatialZoneType are represented
/// by instances of IfcSpatialZone.
/// 
/// HISTORY ÿNew entity in Release
/// IFC2x Edition 4.
class IFC_PARSE_API IfcSpatialZoneType : public IfcSpatialElementType {
public:
    /// Predefined types to define the particular type of the spatial zone. There may be property set definitions available for each predefined type.
    IfcSpatialZoneTypeEnum::IfcSpatialZoneTypeEnum PredefinedType() const;
    void setPredefinedType(IfcSpatialZoneTypeEnum::IfcSpatialZoneTypeEnum v);
    /// Whether the optional attribute LongName is defined for this IfcSpatialZoneType
    bool hasLongName() const;
    std::string LongName() const;
    void setLongName(std::string v);
    virtual unsigned int getArgumentCount() const { return 11; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; case 10: return IfcUtil::Argument_STRING; } return IfcSpatialElementType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcSpatialZoneTypeEnum; case 10: return Type::IfcLabel; } return IfcSpatialElementType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; case 10: return "LongName"; } return IfcSpatialElementType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcSpatialZoneType (IfcEntityInstanceData* e);
    IfcSpatialZoneType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcSpatialZoneTypeEnum::IfcSpatialZoneTypeEnum v10_PredefinedType, boost::optional< std::string > v11_LongName);
    typedef IfcTemplatedEntityList< IfcSpatialZoneType > list;
};
/// The IfcSphere is a Construction Solid Geometry (CSG) 3D
/// primitive. It is a solid where all points at the surface have the
/// same distance from the center point. The inherited
/// Position attribute defines the IfcAxisPlacement3D
/// and provides:
/// 
/// SELF\IfcCsgPrimitive3D.Position: The location and
/// orientation of the axis system for the primitive. 
/// SELF\IfcCsgPrimitive3D.Position.Location: The center
/// of the sphere.
/// SELF\IfcCsgPrimitive3D.Position.Position[3]: The z
/// axis points at its positve direction towards the north pole, and by
/// its negative directions towards the south pole.
/// 
/// The following definitions from ISO 10303-42 apply:
/// 
/// A sphere is a CSG
/// primitive with a spherical shape defined by a centre and a
/// radius.
/// 
/// Figure 270 illustrates geometric parameters of the sphere. The sphere is positioned within its own placement coordiante system. The origin is the center of the sphere.
/// 
/// Figure 270 — Sphere geometry
/// 
/// NOTE  Corresponding STEP entity: sphere, the position attribute, including the centre point,  has been promoted to the immediate supertype IfcCsgPrimitive3D. Please refer to ISO/IS 10303-42:1994, p. 175 for the final definition of the formal standard.
/// 
/// HISTORY  New entity in IFC2x3.
/// 
/// Texture Use Definition
/// Textures are aligned facing upright with origin at the back (+Y direction) revolving counter-clockwise. Textures are stretched or repeated to the extent of the circumference at the equator according to RepeatS and RepeatT.
/// 
/// Figure 271 illustrates default texture mapping with a clamped texture (RepeatS=False and RepeatT=False). The image on the left shows the texture where the S axis points to the right and the T axis points up. The image on the right shows the texture applied to the geometry where the X axis points back to the right, the Y axis points back to the left, and the Z axis points up.
/// 
/// Side
/// Normal
/// Origin X
/// Origin Y
/// Origin Z
/// S Axis
/// T Axis
/// 
/// Side
/// -Y
/// 0
/// +Radius
/// 0
/// (-X, then curving counter-clockwise)
/// (+Y, then curving towards top)
/// 
/// Figure 271 — Sphere textures
class IFC_PARSE_API IfcSphere : public IfcCsgPrimitive3D {
public:
    /// The radius of the sphere.
    double Radius() const;
    void setRadius(double v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 1: return IfcUtil::Argument_DOUBLE; } return IfcCsgPrimitive3D::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 1: return Type::IfcPositiveLengthMeasure; } return IfcCsgPrimitive3D::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 1: return "Radius"; } return IfcCsgPrimitive3D::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcSphere (IfcEntityInstanceData* e);
    IfcSphere (IfcAxis2Placement3D* v1_Position, double v2_Radius);
    typedef IfcTemplatedEntityList< IfcSphere > list;
};

class IFC_PARSE_API IfcSphericalSurface : public IfcElementarySurface {
public:
    double Radius() const;
    void setRadius(double v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 1: return IfcUtil::Argument_DOUBLE; } return IfcElementarySurface::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 1: return Type::IfcPositiveLengthMeasure; } return IfcElementarySurface::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 1: return "Radius"; } return IfcElementarySurface::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcSphericalSurface (IfcEntityInstanceData* e);
    IfcSphericalSurface (IfcAxis2Placement3D* v1_Position, double v2_Radius);
    typedef IfcTemplatedEntityList< IfcSphericalSurface > list;
};
/// Definition from IAI: The abstract entity IfcStructuralActivity combines the definition of actions (such as forces, displacements, etc.) and reactions (support reactions, internal forces, deflections, etc.) which are specified by using the basic load definitions from the IfcStructuralLoadResource.
/// 
/// The differentiation between actions and reactions is realized by instantiating objects either from subclasses of IfcStructuralAction or IfcStructuralReaction respectively.  They inherit commonly needed attributes from the abstract superclass IfcStructuralActivity, notably the relationship which connects actions or reactions with connections, analysis members, or elements (subtypes of IfcStructuralItem or IfcElement).
/// 
/// NOTE  Instances of IfcStructuralActivity which are connected with an IfcElement are subject to agreements outside the scope of this specification.
/// 
/// NOTE  The semantics of IfcStructuralActivity are only fully defined
/// if an activity instance is connected with exactly one structural item.  The inverse attribute
/// AssignedToStructuralItem can only be empty in incomplete models or in conceptual models
/// which are not yet ready for analysis.
/// 
/// HISTORY: New entity in IFC 2x2.
/// 
/// IFC 2x4 change:  Cardinality of attribute
/// AssignedToStructuralItem relaxed from 1 to 0..1 in order to allow for schema-compliant
/// incomplete models as well as conceptual models without load—item relationships.
/// 
/// Coordinate Systems:
/// 
/// The following coordinate systems are distinguished:
/// 
/// The so-called global coordinate system is the coordinate system shared by all items and activities which are grouped in a common IfcStructuralAnalysisModel.  This coordinate system is established by an ObjectPlacement.  (This coordinate system is not necessarily the same as the IfcProject's world coordinate system.)
///   The so-called local coordinate system is a coordinate system local to a structural item (connection or member).  This coordinate system is established by a Representation in conjunction with further use definitions and attributes of subtypes of IfcStructuralItem.
/// 
/// Representation items in topology representations are always given within the ObjectPlacement, i.e. in so-called global coordinates (global with respect to the IfcStructuralAnalysisModel to which this activity belongs).
/// 
/// Locations of the load objects in the AppliedLoad attribute (if of type IfcStructuralLoadConfiguration) are always given in local coordinates.
/// 
/// Directions of the load objects in the AppliedLoad attribute refer to global or local coordinates according to the GlobalOrLocal attribute.
/// 
/// The ObjectPlacement and Representation are sometimes not explicitly instantiated; instead they may be implied as described below.  Global and local coordinate systems are then determined in the same way as with explicit placement and representation.
/// 
/// Topology Use Definitions:
/// 
/// Instances of IfcStructuralActivity which are connected with a structural item of same dimensionality, i.e.
/// 
/// a point action or reaction connected with a point item (IfcStructuralPointConnection),
///   a curve action or reaction connected with a curve item (IfcStructuralCurveConnection, IfcStructuralCurveMember), or
///   a surface action or reaction connected with a surface item (IfcStructuralSurfaceConnection, IfcStructuralSurfaceMember) and which acts on the entire surface of the item and is not specified by isocontours
/// 
/// shall not have an ObjectPlacement nor a Representation.  It is implied that the placement and representation of the IfcStructuralActivity is the same as the ones of the IfcStructuralItem.
/// 
/// Instances of IfcStructuralActivity which are connected with
/// 
/// a curve item (IfcStructuralCurveConnection, IfcStructuralCurveMember) and act on a point of the item, or
///   a surface item (IfcStructuralSurfaceConnection, IfcStructuralSurfaceMember) and act on a point or on a curve or on a part of the surface of the item
/// 
/// shall have a topology representation as specified below.  It includes a placement and a product representation. The IfcProductRepresentation shall be given by an item in a Representation of type IfcTopologyRepresentation.
/// 
/// Instances of IfcStructuralActivity which are connected with
/// 
/// a surface item (IfcStructuralSurfaceConnection, IfcStructuralSurfaceMember) and are specified by isocontours
/// 
/// shall have a shape representation as specified below.  It includes a placement and a product representation. The IfcProductRepresentation shall be given by items in a Representation of type IfcShapeRepresentation.  Shape representation and topology representation may be combined.
/// 
/// Local Placement
/// 
/// The local placement for IfcStructuralActivity is defined in its supertype IfcProduct.  It is defined by the IfcLocalPlacement, which establishes a global coordinate system which shall be common to all items and activities in an IfcStructuralAnalysisModel.
/// 
/// Topology Representation
/// 
/// Instances of IfcStructuralActivity which act on parts of a surface item shall have a topology representation given by a face with underlying surface geometry, IfcFaceSurface, which should be the single item of IfcTopologyRepresentation.Items.  The surface establishes a local coordinate system of the activity:
/// 
/// The origin of surface parameters u,v is the origin of the local coordinate system.
///   The local x and y directions follow the tangents on the surface and are in parallel with and directed like u and v respectively.
///   The local z direction is in parallel with and directed like the surface normal.
/// 
/// RepresentationIdentifier: 'Reference'
///   RepresentationType: 'Face'
/// 
/// Instances of IfcStructuralActivity which act on a curve on a surface item shall have a topology representation given by an edge (IfcEdge or subtype), which should be the single item of IfcTopologyRepresentation.Items.  The curve geometry shall be compatible with the surface geometry of the connected item.  In conjunction with this surface, the curve establishes a local coordinate system of the activity:
/// 
/// The origin of the curve parameter u is the origin of the local coordinate system.
///   The local x direction follows the tangent on the curve and is directed like u.
///   The local z direction is in parallel with and directed like the surface normal of the connected surface item.
///   The local x,y,z directions form a right-handed Cartesian coordinate system.
/// 
/// RepresentationIdentifier: 'Reference'
///   RepresentationType: 'Edge'
/// 
/// NOTE  While an IfcEdge (or IfcOrientedEdge with underlying IfcEdge) does not provide an explicit underlying curve geometry, it may be used to imply an underlying straight line as reference curve with the origin of the curve parameter at the start vertex point.
/// 
/// Instances of IfcStructuralActivity which act on a single point on a curve or surface item shall have a topology representation given by an IfcVertexPoint, which should be the single item of IfcTopologyRepresentation.Items.  The point geometry shall be compatible with the curve or surface geometry of the connected item.  The local coordinate system of the activity is oriented by the curve or surface geometry of the connected item as described above for activities with edge or face topology.
/// 
/// RepresentationIdentifier: 'Reference'
///   RepresentationType: 'Vertex'
/// 
/// Shape Representation
/// 
/// Instances of IfcStructuralActivity which act on a surface item and are specified by isocontours (level sets) shall have a shape representation given by a set of curves on a surface, IfcPCurve.  The basis surface shall comply with or preferably be identical with the surface of the structural item to which the activity is connected.  The representation identifier and type of this geometric representation is:
/// 
/// RepresentationIdentifier: 'Level set'
///   RepresentationType: 'GeometricCurveSet'
class IFC_PARSE_API IfcStructuralActivity : public IfcProduct {
public:
    /// Load or result resource object which defines the load type, direction, and load values.
    /// 
    /// In case of activities which are variably distributed over curves or surfaces, IfcStructuralLoadConfiguration is used which provides a list of load samples and their locations within the load distribution, measured in local coordinates of the curve or surface on which this activity acts.  The contents of this load or result distribution may be further restricted by definitions at subtypes of IfcStructuralActivity.
    IfcStructuralLoad* AppliedLoad() const;
    void setAppliedLoad(IfcStructuralLoad* v);
    /// Indicates whether the load directions refer to the global coordinate system (global to
    /// the analysis model, i.e. as established by IfcStructuralAnalysisModel.SharedPlacement)
    /// or to the local coordinate system (local to the activity or connected item, as established by
    /// an explicit or implied representation and its parameter space).
    /// 
    /// NOTE, the informal definition of
    /// IfcRepresentationResource.IfcGlobalOrLocalEnum doe s not distinguish between
    /// "global coordinate system" and "world coordinate system".
    /// On the other hand, this distinction is necessary in the IfcStructuralAnalysisDomain
    /// where the shared "global" coordinate system of an analysis model may very well
    /// not be the same as the project-wide world coordinate system.
    /// 
    /// In the scope of IfcStructuralActivity.GlobalOrLocal,
    /// the meaning of GLOBAL_COORDS is therefore not to be taken as world coordinate system
    /// but as the analysis model specific shared coordinate system.  In contrast, LOCAL_COORDS
    /// is to be taken as coordinates which are local to individual structural items and activities,
    /// as established by subclass-specific geometry use definitions.
    IfcGlobalOrLocalEnum::IfcGlobalOrLocalEnum GlobalOrLocal() const;
    void setGlobalOrLocal(IfcGlobalOrLocalEnum::IfcGlobalOrLocalEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 7: return IfcUtil::Argument_ENTITY_INSTANCE; case 8: return IfcUtil::Argument_ENUMERATION; } return IfcProduct::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 7: return Type::IfcStructuralLoad; case 8: return Type::IfcGlobalOrLocalEnum; } return IfcProduct::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 7: return "AppliedLoad"; case 8: return "GlobalOrLocal"; } return IfcProduct::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcRelConnectsStructuralActivity >::ptr AssignedToStructuralItem() const; // INVERSE IfcRelConnectsStructuralActivity::RelatedStructuralActivity
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcStructuralActivity (IfcEntityInstanceData* e);
    IfcStructuralActivity (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, IfcStructuralLoad* v8_AppliedLoad, IfcGlobalOrLocalEnum::IfcGlobalOrLocalEnum v9_GlobalOrLocal);
    typedef IfcTemplatedEntityList< IfcStructuralActivity > list;
};
/// Definition from IAI: The abstract entity IfcStructuralItem is the generalization of structural members and structural connections, i.e. analysis idealizations of elements in the building model.  It defines the relation between structural members and connections with structural activities (actions and reactions).
/// 
/// Relationships between elements in the building model and structural items as their idealizations can be expressed by instances of IfcRelAssignsToProduct.
/// 
/// HISTORY: New entity in IFC 2x2.
/// IFC 2x4 change:  Use definitions and informal proposition added.
/// 
/// Coordinate Systems:
/// 
/// The following coordinate systems are distinguished:
/// 
/// The so-called global coordinate system is the coordinate system shared by all items and activities which are grouped in a common IfcStructuralAnalysisModel.  This coordinate system is established by SELF\IfcProduct.ObjectPlacement.  (This coordinate system is not necessarily the same as the IfcProject's world coordinate system.)
///   The so-called local coordinate system is a coordinate system local to a structural item (connection or member).  This coordinate system is established by a Representation (attribute inherited from IfcProduct) in conjunction with further use definitions and attributes of subtypes of IfcStructuralItem.
/// 
/// Representation items in topology representations are always given within the ObjectPlacement, i.e. in so-called global coordinates (global with respect to the IfcStructuralAnalysisModel to which this item belongs).
/// 
/// The usage of local coordinate systems is further defined in subtypes.
/// 
/// Topology Use Definitions:
/// 
/// Instances of IfcStructuralItem shall have a topology representation.  It includes a placement and a product representation. The IfcProductRepresentation shall be given by an item in a Representation of type IfcTopologyRepresentation.
/// 
/// Local Placement
/// 
/// The local placement for IfcStructuralActivity is defined in its supertype IfcProduct.  It is defined by the IfcLocalPlacement, which establishes a global coordinate system which shall be common to all items and activities in an IfcStructuralAnalysisModel.
/// 
/// Topology Representation
/// 
/// Instances of IfcStructuralItem shall have a topology representation given by an instance of a subtype of IfcTopologicalRepresentationItem, which should be the single item of IfcTopologyRepresentation.Items.  Depending on the dimensionality of the structural item, one of the following types of toplogical representation items shall be used:
/// 
/// Point connections shall be represented by an IfcVertexPoint with an underlying IfcCartesianPoint.
///   The Cartesian point is the reference point of the connection in the so-called global coordinate system.
///   The following labels are used in the IfcTopologyRepresentation:
/// 
/// RepresentationIdentifier: 'Reference'
///   RepresentationType: 'Vertex'
/// 
/// Curve members and curve connections shall either be represented by an IfcOrientedEdge,
///   IfcEdgeCurve, or IfcEdge.  The curve to which the IfcEdgeCurve (or an
///   IfcOrientedEdge's underlying IfcEdgeCurve) refers to is the reference curve of the structural
///   item in the global coordinate system.  Start and end vertex of the edge shall be IfcVertexPoints
///   with underlying IfcCartesianPoints.
///   The following labels are used in the IfcTopologyRepresentation:
/// 
/// RepresentationIdentifier: 'Reference'
///   RepresentationType: 'Edge'
/// 
/// NOTE  While an IfcEdge (or IfcOrientedEdge with underlying
///   IfcEdge) does not provide an explicit underlying curve geometry, it may be used to imply an
///   underlying straight line as reference curve with the origin of the curve parameter at the start vertex
///   point.
/// 
/// Surface members and surface connections shall be represented by an IfcFaceSurface.
///   The underlying surface defeines the reference surface of the structural surface item in the global
///   coordiante system.  All edges in the bounds of the face shall conform to the rules for edge
///   representations of structural curve item.
///   The following labels are used in the IfcTopologyRepresentation:
/// 
/// RepresentationIdentifier: 'Reference'
///   RepresentationType: 'Face'
/// 
/// The reference point, reference curve, or reference surface partially or completely defines the local coordinate system of the represented structural item according to the following rules.  In all cases, The local x,y,z directions form a right-handed Cartesian coordinate system.
/// 
/// Structural point items
/// 
/// The reference point in the representation is the origin of the local coordinate system of the structural item.
///   The axes of the local coordiante system are either parallel with and directed like the so-called global coordinate axes, or are oriented according to definitions at the respective subtype of IfcStructuralItem.
/// 
/// Structural curve items
/// 
/// The u parameter origin of the reference curve in the representation is the origin of the local coordinate system of the structural item.
///   The local x axis is parallel with the tangent on the curve and directed like the u parameter direction.
///   The local y and z axes are oriented according to definitions at the respective subtypes of IfcStructuralItem.
/// 
/// Structural surface items
/// 
/// The u,v parameter origin of the reference surface in the representation is the origin of the local coordinate system of the structural item.
///   The local x and y directions follow the tangents on the surface and are in parallel with and directed like u and v respectively.
///   The local z direction is in parallel with and directed like the surface normal.
/// 
/// Informal propositions:
/// 
/// The ObjectPlacements of all structural items which are grouped into the same instance of IfcStructuralAnalysisModel shall refer to the same instance of IfcObjectPlacement.
/// 
/// NOTE  This rule is necessary to achieve consistent topology representations.  The topology representations of structural items in an analysis model are meant to share vertices and edges und must therefore have the same object placement.
/// 
/// NOTE  A structural item may be grouped into more than one analysis model.  In this case, all these models must use the same instance of IfcObjectPlacement.
class IFC_PARSE_API IfcStructuralItem : public IfcProduct {
public:
    virtual unsigned int getArgumentCount() const { return 7; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcProduct::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcProduct::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcProduct::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcRelConnectsStructuralActivity >::ptr AssignedStructuralActivity() const; // INVERSE IfcRelConnectsStructuralActivity::RelatingElement
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcStructuralItem (IfcEntityInstanceData* e);
    IfcStructuralItem (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation);
    typedef IfcTemplatedEntityList< IfcStructuralItem > list;
};
/// Definition from IAI: The abstract entity IfcStructuralMember is the superclass of all structural items which represent the idealized structural behavior of building elements.
/// 
/// HISTORY: New entity in IFC 2x2.
/// IFC 2x4 change:  Use definitions moved to supertype and subtypes.
class IFC_PARSE_API IfcStructuralMember : public IfcStructuralItem {
public:
    virtual unsigned int getArgumentCount() const { return 7; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcStructuralItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcStructuralItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcStructuralItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcRelConnectsStructuralMember >::ptr ConnectedBy() const; // INVERSE IfcRelConnectsStructuralMember::RelatingStructuralMember
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcStructuralMember (IfcEntityInstanceData* e);
    IfcStructuralMember (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation);
    typedef IfcTemplatedEntityList< IfcStructuralMember > list;
};
/// Definition from IAI: A structural reaction is a structural activity that results from a
/// structural action imposed to a structural item or building element.  Examples are support reactions,
/// internal forces, and deflections.
/// 
/// HISTORY  New entity in IFC 2x2.
/// 
/// IFC 2x4 change:  Inverse attribute Causes deleted; use IfcRelAssignsToProduct via HasAssignments instead.
/// 
/// Structural reactions are grouped into IfcStructuralResultGroups via the inverse
/// relationship HasAssignments and an IfcRelAssignsToGroup relationship object.
/// IfcStructuralResultGroup.ResultGroupFor finally refers to the structural analysis model
/// in which the results occur.
/// 
/// It is furthermore possible to establish relationships between reactions in one analysis model
/// and actions which they cause in another analysis model.  For example, a support reaction from one
/// structural system may be taken over as a load onto another supporting structural system.  This is
/// expressed by means of the inverse relationship HasAssignments of the reaction and an
/// IfcRelAssignsToProduct relationship object.  IfcRelAssignsToProduct.Name is set to
/// 'Causes' and IfcRelAssignsToProduct.RelatingProduct refers to an instance of a subtype of
/// IfcStructuralAction.
class IFC_PARSE_API IfcStructuralReaction : public IfcStructuralActivity {
public:
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcStructuralActivity::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcStructuralActivity::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcStructuralActivity::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcStructuralReaction (IfcEntityInstanceData* e);
    IfcStructuralReaction (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, IfcStructuralLoad* v8_AppliedLoad, IfcGlobalOrLocalEnum::IfcGlobalOrLocalEnum v9_GlobalOrLocal);
    typedef IfcTemplatedEntityList< IfcStructuralReaction > list;
};
/// Definition from IAI: Instances of IfcStructuralSurfaceMember describe face members, i.e. structural analysis idealizations of slabs, walls, shells, etc..  Surface members may be planar or curved.
/// 
/// HISTORY: New entity in IFC 2x2.
/// IFC 2x4 change:  Use definitions changed, WHERE rule added.
/// 
/// Coordinate Systems:
/// 
/// See definitions at IfcStructuralItem.  The local coordinate system is established by the reference surface given by topology representation.
/// 
/// Material Use Definition
/// 
/// The material of direct instances IfcStructuralSurfaceMember (in contrast to instances of the subtype IfcStructuralSurfaceMemberVarying) is defined by IfcMaterial and attached by the IfcRelAssociatesMaterial.RelatingMaterial.  It is accessible by the inverse HasAssociations relationship.
/// 
/// The material is specified minimally by a name which corresponds with an agreed upon standardized structural material designation.  An external reference to the source which specifies the material designation should be provided.  Alternatively, structural material properties may be provided by means of IfcMechanicalMaterialProperties and IfcExtendedMaterialProperties.
/// 
/// Direct instances of IfcStructuralSurfaceMember are assumed to be located centrically relative to their reference surface.  Their depth is provided in the attribute Thickness.
/// 
/// Topology Use Definitions:
/// 
/// Direct instances of IfcStructuralSurfaceMember shall have a topology representation which consists of one IfcFaceSurface, representing the reference surface of the surface member.  See definitions at IfcStructuralItem for further specifications.
class IFC_PARSE_API IfcStructuralSurfaceMember : public IfcStructuralMember {
public:
    /// Type of member with respect to its load carrying behavior in this analysis idealization.
    IfcStructuralSurfaceMemberTypeEnum::IfcStructuralSurfaceMemberTypeEnum PredefinedType() const;
    void setPredefinedType(IfcStructuralSurfaceMemberTypeEnum::IfcStructuralSurfaceMemberTypeEnum v);
    /// Whether the optional attribute Thickness is defined for this IfcStructuralSurfaceMember
    bool hasThickness() const;
    /// Defines the typically understood thickness of the structural surface member, measured normal to its reference surface.
    double Thickness() const;
    void setThickness(double v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 7: return IfcUtil::Argument_ENUMERATION; case 8: return IfcUtil::Argument_DOUBLE; } return IfcStructuralMember::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 7: return Type::IfcStructuralSurfaceMemberTypeEnum; case 8: return Type::IfcPositiveLengthMeasure; } return IfcStructuralMember::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 7: return "PredefinedType"; case 8: return "Thickness"; } return IfcStructuralMember::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcStructuralSurfaceMember (IfcEntityInstanceData* e);
    IfcStructuralSurfaceMember (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, IfcStructuralSurfaceMemberTypeEnum::IfcStructuralSurfaceMemberTypeEnum v8_PredefinedType, boost::optional< double > v9_Thickness);
    typedef IfcTemplatedEntityList< IfcStructuralSurfaceMember > list;
};
/// Definition from IAI: Describes surface members with varying section properties.  The properties are provided by means of a property set and IfcRelDefinesByProperties or by means of aggregation:  An instance of IfcStructuralSurfaceMemberVarying may be composed of two or more instances of IfcStructuralSurfaceMember with differing section properties.  These subordinate members relate to the instance of IfcStructuralSurfaceMemberVarying by IfcRelAggregates.
/// 
/// NOTE   It is recommended that structural activities (actions or reactions) are not connected with aggregated IfcStructuralSurfaceMemberVarying but only with the IfcStructuralSurfaceMembers in the aggregation.  That way, difficulties in interpretation of local coordinates are avoided.
/// 
/// HISTORY: New entity in IFC 2x2.
/// Use definition changed and attributes deleted in IFC 2x4.
/// 
/// Coordinate Systems:
/// 
/// See definitions at IfcStructuralItem and IfcStructuralSurfaceMember.  The local coordinates of an aggregate are generally undefined since continuity of local coordinates of the parts is not ensured.
/// 
/// Material Use Definition
/// 
/// In case of aggregation, only the individual parts (direct instances of IfcStructuralSurfaceMember) carry material and thickness information.  Otherwise, definitions at IfcStructuralSurfaceMember apply.
/// 
/// Topology Use Definitions:
/// 
/// In case of aggregation, instances of IfcStructuralSurfaceMemberVarying may have a topology representation which contains a single IfcConnectedFaceSet, based upon the faces of the parts.  Otherwise, definitions at IfcStructuralSurfaceMember apply.
class IFC_PARSE_API IfcStructuralSurfaceMemberVarying : public IfcStructuralSurfaceMember {
public:
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcStructuralSurfaceMember::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcStructuralSurfaceMember::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcStructuralSurfaceMember::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcStructuralSurfaceMemberVarying (IfcEntityInstanceData* e);
    IfcStructuralSurfaceMemberVarying (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, IfcStructuralSurfaceMemberTypeEnum::IfcStructuralSurfaceMemberTypeEnum v8_PredefinedType, boost::optional< double > v9_Thickness);
    typedef IfcTemplatedEntityList< IfcStructuralSurfaceMemberVarying > list;
};
/// Definition from IAI: Defines a reaction which occurs distributed over a surface.  A surface reaction may be connected with a surface member or surface connection.
/// 
/// HISTORY: New entity in IFC 2x4.
/// 
/// Coordinate Systems:
/// 
/// See definitions at IfcStructuralActivity.
/// 
/// Topology Use Definitions:
/// 
/// See definitions at IfcStructuralActivity.
/// 
/// Informal propositions:
/// 
/// If the surface reaction is of the predefined type CONST, SELF\IfcStructuralActivity.AppliedLoad must not be of type IfcStructuralLoadConfiguration.
///   If the surface reaction is of the predefined type BILINEAR, SELF\IfcStructuralActivity.AppliedLoad shall be of type IfcStructuralLoadConfiguration and shall contain three items with two-dimensional IfcStructuralLoadConfiguration.Locations, defining the location of the result samples in local coordinates of the surface reaction.
///   If the surface reaction is of the predefined type DISCRETE, SELF\IfcStructuralActivity.AppliedLoad shall be of type IfcStructuralLoadConfiguration and shall contain two or more items with two-dimensional locations.
///   If the surface reaction is of the predefined type ISOCONTOUR, SELF\IfcStructuralActivity.AppliedLoad shall be of type IfcStructuralLoadConfiguration and shall contain the same number of items as the set SELF.IfcProduct.Representation.Representations[?].Items.  Each item in the load configuration shall have a two-dimensional location, defining the location of the result samples in local coordinates of the surface reaction.  Each item in SELF\IfcStructuralActivity.AppliedLoad shall be located at exactly one of the isocontours.
///   NOTE   The set of representation items is unordered, hence result locations are required to correlate result values and isocontours.
///   NOTE   Isocontours are represented as IfcPCurves which are defined in terms of surface parameters u,v, while result locations are given in local surface item coordinates x,y.  It is strongly recommended that the surface parameterization u,v is scaled 1:1 in order to avoid different scales of u,v versus x,y.  If u,v are scaled 1:1 and the IfcPCurve's base surface is identical with the surface item's base surface, u,v and local x,y are identical.
/// 
/// All items in SELF\IfcStructuralActivity.AppliedLoad\IfcStructuralLoadConfiguration.Values shall be of the same entity type.
class IFC_PARSE_API IfcStructuralSurfaceReaction : public IfcStructuralReaction {
public:
    /// Type of reaction according to its distribution of load values.
    IfcStructuralSurfaceActivityTypeEnum::IfcStructuralSurfaceActivityTypeEnum PredefinedType() const;
    void setPredefinedType(IfcStructuralSurfaceActivityTypeEnum::IfcStructuralSurfaceActivityTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcStructuralReaction::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcStructuralSurfaceActivityTypeEnum; } return IfcStructuralReaction::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcStructuralReaction::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcStructuralSurfaceReaction (IfcEntityInstanceData* e);
    IfcStructuralSurfaceReaction (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, IfcStructuralLoad* v8_AppliedLoad, IfcGlobalOrLocalEnum::IfcGlobalOrLocalEnum v9_GlobalOrLocal, IfcStructuralSurfaceActivityTypeEnum::IfcStructuralSurfaceActivityTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcStructuralSurfaceReaction > list;
};
/// The resource type IfcSubContractResourceType defines commonly shared information for occurrences of subcontract resources. The set of shared information may include:
/// 
/// common productivities
/// common cost rates
/// common properties within shared property sets
/// 
/// It is used to define a subcontract resource specification (the specific resource information that is common to all
/// occurrences of that resource). Resource types may be exchanged without being already assigned to occurrences.
/// Occurrences of the IfcSubContractResourceType are represented by instances of IfcSubContractResource.
/// 
/// HISTORY New entity in IFC2x4.
class IFC_PARSE_API IfcSubContractResourceType : public IfcConstructionResourceType {
public:
    /// Defines types of subcontract resources.
    IfcSubContractResourceTypeEnum::IfcSubContractResourceTypeEnum PredefinedType() const;
    void setPredefinedType(IfcSubContractResourceTypeEnum::IfcSubContractResourceTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 12; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 11: return IfcUtil::Argument_ENUMERATION; } return IfcConstructionResourceType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 11: return Type::IfcSubContractResourceTypeEnum; } return IfcConstructionResourceType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 11: return "PredefinedType"; } return IfcConstructionResourceType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcSubContractResourceType (IfcEntityInstanceData* e);
    IfcSubContractResourceType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< std::string > v7_Identification, boost::optional< std::string > v8_LongDescription, boost::optional< std::string > v9_ResourceType, boost::optional< IfcTemplatedEntityList< IfcAppliedValue >::ptr > v10_BaseCosts, IfcPhysicalQuantity* v11_BaseQuantity, IfcSubContractResourceTypeEnum::IfcSubContractResourceTypeEnum v12_PredefinedType);
    typedef IfcTemplatedEntityList< IfcSubContractResourceType > list;
};

class IFC_PARSE_API IfcSurfaceCurve : public IfcCurve {
public:
    IfcCurve* Curve3D() const;
    void setCurve3D(IfcCurve* v);
    IfcTemplatedEntityList< IfcPcurve >::ptr AssociatedGeometry() const;
    void setAssociatedGeometry(IfcTemplatedEntityList< IfcPcurve >::ptr v);
    IfcPreferredSurfaceCurveRepresentation::IfcPreferredSurfaceCurveRepresentation MasterRepresentation() const;
    void setMasterRepresentation(IfcPreferredSurfaceCurveRepresentation::IfcPreferredSurfaceCurveRepresentation v);
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 2: return IfcUtil::Argument_ENUMERATION; } return IfcCurve::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcCurve; case 1: return Type::IfcPcurve; case 2: return Type::IfcPreferredSurfaceCurveRepresentation; } return IfcCurve::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Curve3D"; case 1: return "AssociatedGeometry"; case 2: return "MasterRepresentation"; } return IfcCurve::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcSurfaceCurve (IfcEntityInstanceData* e);
    IfcSurfaceCurve (IfcCurve* v1_Curve3D, IfcTemplatedEntityList< IfcPcurve >::ptr v2_AssociatedGeometry, IfcPreferredSurfaceCurveRepresentation::IfcPreferredSurfaceCurveRepresentation v3_MasterRepresentation);
    typedef IfcTemplatedEntityList< IfcSurfaceCurve > list;
};
/// The IfcSurfaceCurveSweptAreaSolid is the result of
/// sweeping an area along a directrix that lies on a reference
/// surface. The swept area is provided by an IfcProfileDef
/// (or subtypes). The profile definition is based on a 2D coordinate
/// system, which is inserted into the XY plane of the 3D
/// Position coordinate system inherited from the supertype
/// IfcSweptAreaSolid.
/// The following definitions from ISO 10303-42 apply:
/// 
/// A surface curve swept
/// area solid is a type of swept area solid which is the result of
/// sweeping a face along a Directrix lying on a
/// ReferenceSurface. The orientation of the
/// SweptArea is related to the direction of the surface
/// normal.
/// The
/// SweptArea is required to be a curve bounded surface lying
/// in the plane z = 0 and this is swept along the Directrix
/// in such a way that the origin of the local coordinate system used
/// to define the SweptArea is on the Directrix and
/// the local x-axis is in the direction of the normal to the
/// ReferenceSurface at the current point. The resulting solid
/// has the property that the cross section of the surface by the
/// normal plane to the Directrix at any point is a copy of
/// the SweptArea.
/// The orientation of
/// the SweptArea as it sweeps along the Directrix is
/// precisely defined by a Cartesian Transformation Operator 3D with
/// attributes:
/// 
/// LocalOrigin
/// as point (0; 0; 0),
/// Axis1 as
/// the normal N to the ReferenceSurface at the point of the
/// Directrix with parameter u.
/// Axis3 as
/// the direction of the tangent vector t at the point of the
/// Directrix with parameter u.
/// The remaining attributes are defaulted to define a corresponding
/// transformation matrix T(u), which varies with the
/// Directrix parameter u.
/// 
/// NOTE  The
/// geometric shape of the solid is not dependent upon the curve
/// parameterization; the volume depends upon the area swept and the
/// length of the Directrix.
/// 
/// The attributes of the Cartesian Transformation Operator (as
/// shown above) should apply to the Position coordinate
/// system, in which the profile is inserted. The Directrix
/// and the ReferenceSurface are positioned within the 3D
/// Position coordinate system.
/// 
/// NOTE  Corresponding ISO 10303-42 entity: surface_curve_swept_area_solid. Please refer to ISO 10303-42 ed.2:1999, p. 274 for the definition in the international standard.
/// 
/// HISTORY  New entity in IFC2x2.
/// 
/// Informal propositions:
/// 
/// The SweptArea shall lie in the plane z = 0.
/// The Directrix shall lie on the
/// ReferenceSurface.
class IFC_PARSE_API IfcSurfaceCurveSweptAreaSolid : public IfcSweptAreaSolid {
public:
    /// The curve used to define the sweeping operation. The solid is generated by sweeping the SELF\IfcSweptAreaSolid.SweptArea along the Directrix.
    IfcCurve* Directrix() const;
    void setDirectrix(IfcCurve* v);
    /// Whether the optional attribute StartParam is defined for this IfcSurfaceCurveSweptAreaSolid
    bool hasStartParam() const;
    /// The parameter value on the Directrix at which the sweeping operation commences. If no value is provided the start of the sweeping operation is at the start of the Directrix..
    /// 
    /// IFC2x4 CHANGE  The attribute has been changed to OPTIONAL with upward compatibility for file-based exchange.
    double StartParam() const;
    void setStartParam(double v);
    /// Whether the optional attribute EndParam is defined for this IfcSurfaceCurveSweptAreaSolid
    bool hasEndParam() const;
    /// The parameter value on the Directrix at which the sweeping operation ends. If no value is provided the end of the sweeping operation is at the end of the Directrix..
    /// 
    /// IFC2x4 CHANGE  The attribute has been changed to OPTIONAL with upward compatibility for file-based exchange.
    double EndParam() const;
    void setEndParam(double v);
    /// The surface containing the Directrix.
    IfcSurface* ReferenceSurface() const;
    void setReferenceSurface(IfcSurface* v);
    virtual unsigned int getArgumentCount() const { return 6; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 2: return IfcUtil::Argument_ENTITY_INSTANCE; case 3: return IfcUtil::Argument_DOUBLE; case 4: return IfcUtil::Argument_DOUBLE; case 5: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcSweptAreaSolid::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 2: return Type::IfcCurve; case 3: return Type::IfcParameterValue; case 4: return Type::IfcParameterValue; case 5: return Type::IfcSurface; } return IfcSweptAreaSolid::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 2: return "Directrix"; case 3: return "StartParam"; case 4: return "EndParam"; case 5: return "ReferenceSurface"; } return IfcSweptAreaSolid::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcSurfaceCurveSweptAreaSolid (IfcEntityInstanceData* e);
    IfcSurfaceCurveSweptAreaSolid (IfcProfileDef* v1_SweptArea, IfcAxis2Placement3D* v2_Position, IfcCurve* v3_Directrix, boost::optional< double > v4_StartParam, boost::optional< double > v5_EndParam, IfcSurface* v6_ReferenceSurface);
    typedef IfcTemplatedEntityList< IfcSurfaceCurveSweptAreaSolid > list;
};
/// Definition from ISO/CD 10303-42:1992: This surface is a simple swept surface or a generalized cylinder obtained by sweeping a curve in a given direction. The parameterization is as follows where the curve has a parameterization l(u): 
/// 
/// V = ExtrusionAxis 
/// 
/// The parameterization range for v is -¥ < v < ¥ and for u it is defined by the curve parameterization. 
/// 
/// NOTE: Corresponding ISO 10303 entity: surface_of_linear_extrusion. Please refer to ISO/IS 10303-42:1994, p.76 for the final definition of the formal standard. The following adaption has been made. The ExtrusionAxis and the Direction are defined as two separate attributes in correlation to the definition of the extruded_area_solid, and not as a single vector attribute. The vector is derived as ExtrusionAxis.
/// 
/// HISTORY: New entity in IFC Release 2x.
/// 
/// Informal propositions: 
/// 
/// The surface shall not self-intersect
class IFC_PARSE_API IfcSurfaceOfLinearExtrusion : public IfcSweptSurface {
public:
    /// The direction of the extrusion.
    IfcDirection* ExtrudedDirection() const;
    void setExtrudedDirection(IfcDirection* v);
    /// The depth of the extrusion, it determines the parameterization.
    double Depth() const;
    void setDepth(double v);
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 2: return IfcUtil::Argument_ENTITY_INSTANCE; case 3: return IfcUtil::Argument_DOUBLE; } return IfcSweptSurface::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 2: return Type::IfcDirection; case 3: return Type::IfcLengthMeasure; } return IfcSweptSurface::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 2: return "ExtrudedDirection"; case 3: return "Depth"; } return IfcSweptSurface::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcSurfaceOfLinearExtrusion (IfcEntityInstanceData* e);
    IfcSurfaceOfLinearExtrusion (IfcProfileDef* v1_SweptCurve, IfcAxis2Placement3D* v2_Position, IfcDirection* v3_ExtrudedDirection, double v4_Depth);
    typedef IfcTemplatedEntityList< IfcSurfaceOfLinearExtrusion > list;
};
/// Definition from ISO/CD 10303-42:1992: A surface of revolution (IfcSurfaceOfRevolution) is the surface obtained by rotating a curve one complete revolution about an axis. The data shall be interpreted as below. 
/// 
/// The parameterization is as follows where the curve has a parameterization l(u): 
/// 
/// C = AxisPosition.LocationV = AxisPosition.Z
/// 
/// In order to produce a single-value surface the a complete revolution, the curve shall be such that when expressed in a cylindrical coordinate system the curve shall be such that when expressed in a cylindrical coordinate system (r,φ ,z) centred at C with an axis V no two distinct parametric points on the curve shall have the same values for (r, z).  
/// For a surface of revolution the parametric range is 0 < u < 360 degree. The parameterization range for v is defined by referenced curve. 
/// 
/// NOTE: Corresponding ISO 10303 entity: surface_of_revolution. Please refer to ISO/IS 10303-42:1994, p.76 for the final definition of the formal standard.
/// 
/// HISTORY: New entity in IFC2x.
/// 
/// Informal propositions: 
/// 
/// The surface shall not self-intersect 
/// The swept curve shall not be coincident with the axis line for any finite part of its legth.
class IFC_PARSE_API IfcSurfaceOfRevolution : public IfcSweptSurface {
public:
    /// A point on the axis of revolution and the direction of the axis of revolution.
    IfcAxis1Placement* AxisPosition() const;
    void setAxisPosition(IfcAxis1Placement* v);
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 2: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcSweptSurface::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 2: return Type::IfcAxis1Placement; } return IfcSweptSurface::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 2: return "AxisPosition"; } return IfcSweptSurface::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcSurfaceOfRevolution (IfcEntityInstanceData* e);
    IfcSurfaceOfRevolution (IfcProfileDef* v1_SweptCurve, IfcAxis2Placement3D* v2_Position, IfcAxis1Placement* v3_AxisPosition);
    typedef IfcTemplatedEntityList< IfcSurfaceOfRevolution > list;
};
/// The furnishing element type IfcSystemFurnitureElementType defines commonly shared information for occurrences of furniture elements.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// applicable assignment of process types 
/// 
/// It is used to define a furniture element specification (i.e. the specific product information, that is common to all occurrences of that product type).  Furniture Element types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcSystemFurnitureElementType are represented by instances of IfcSystemFurnitureElement. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcFurnishingElementType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_SystemFurnitureElementTypeCommon 
/// 
/// The following property set definitions are applicable to this entity according to the PredefinedType attribute:  
/// Pset_SystemFurnitureElementTypePanel (PANEL) 
/// Pset_SystemFurnitureElementTypeWorkSurface (WORKSURFACE) 
/// 
/// Material Use Definition 
/// The material of the IfcSystemFurnitureElementType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Finish': The finish, typically at visible aspects of the furniture. 
/// 'Frame': The frame from which the object is constructed. 
/// 'Hardware': Finish hardware such as knobs or handles. 
/// 'Padding': Padding such as cushions. 
/// 'Panel': Panels such as glass.
class IFC_PARSE_API IfcSystemFurnitureElementType : public IfcFurnishingElementType {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcSystemFurnitureElementType
    bool hasPredefinedType() const;
    IfcSystemFurnitureElementTypeEnum::IfcSystemFurnitureElementTypeEnum PredefinedType() const;
    void setPredefinedType(IfcSystemFurnitureElementTypeEnum::IfcSystemFurnitureElementTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcFurnishingElementType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcSystemFurnitureElementTypeEnum; } return IfcFurnishingElementType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcFurnishingElementType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcSystemFurnitureElementType (IfcEntityInstanceData* e);
    IfcSystemFurnitureElementType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, boost::optional< IfcSystemFurnitureElementTypeEnum::IfcSystemFurnitureElementTypeEnum > v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcSystemFurnitureElementType > list;
};
/// An IfcTask is an identifiable unit of work to be
///   carried out in a construction project.
/// 
/// A task is typically used to describe an activity for the
///   construction or installation of products, but is not
///   limited to these types. For example it might be used to
///   describe design processes, move operations and other
///   design, construction and operation related activities as
///   well.
/// 
/// HISTORY  New entity in IFC 1.0. Renamed from IfcWorkTask in IFC 2x.
/// 
/// IFC2x4 CHANGE  Attributes TaskTime and PredefinedType added.  IfcMove and IfcOrderRequest has been removed in IFC2x4 and are now represented by IfcTask. Further information can be found in the description below.
/// 
/// Type use definition
/// 
/// IfcTask defines the anticipated or actual occurrence
///   of any task; common information about task types is handled
///   by IfcTaskType. The IfcTaskType (if present)
///   may establish the common type name, usage (or predefined)
///   type, common set of properties, and common product
///   assignment using IfcRelAssignsToProduct. The
///   IfcTaskType is attached using the
///   IfcRelDefinesByType.RelatingType objectified
///   relationship and is accessible by the inverse
///   IsTypedBy attribute. Special type information
///   relating to a task occurrence is asserted using
///   IfcTask.ObjectType (inherited from
///   IfcObject). Examples that may be used include fixed
///   duration, fixed unit or fixed work. IfcTask can be
///   aggregated to a task type in order to specify a task
///   sequence or any time related information, e.g. the duration
///   of a task. Please see the documentation of
///   IfcTaskType for further information.
/// 
/// Attribute use definition
/// 
/// Each occurrence of IfcTask is given a name that is
///   indicative of its content (IfcRoot.Name). A textual
///   description of the task may be provided and this may be
///   further elaborated by a narrative long description
///   (IfcProcess.LongDescription). A work method may be
///   declared for the method of work used in carrying out a
///   task. A task is identified as being either a milestone task
///   or not. A milestone task is defined by the marker
///   IsMilestone. and has no duration. A status and
///   priority for each task may also be set.
/// 
/// Property set use definition
/// 
/// The property sets relating to IfcTask are defined by
///   IfcPropertySet and attached by the
///   IfcRelDefinesByProperties relationship. They are
///   accessible by the inverse IsDefinedBy relationship.
///   Such property sets may define task parameters. No property
///   sets for IfcTask are currently defined by IFC.
/// 
/// Connectivity Use Definition
/// 
/// The relationship IfcRelSequence is used to indicate
///   control flow. An IfcTask as a successor to an
///   IfcTask indicates logical sequence how these tasks
///   should be performed. IfcTask's can be triggered or
///   can trigger IfcEvent's, which is also defined
///   through the relationship IfcRelSequence.
/// 
/// Composition use definition
/// 
/// IfcTask may be contained within an IfcTask
///   using the IfcRelNests relationship. An
///   IfcTask may in turn nest other IfcTask,
///   IfcProcedure or IfcEvent entities. Such
///   nesting indicates decomposed level of detail. From IFC2x4
///   onwards it is required to have a summary task (root of all
///   tasks), which is used to define a link to the work plan or
///   work schedule. All subtasks of the summary tasks are then
///   implicitly linked to this work plan or work schedule.
///   Please note that the summary task is used for data
///   organization and not meant to store typical task
///   information as defined by the user. It is therefore
///   recommended that the summary task is hidden from the user
///   to avoid confusion. Please also note that
///   IfcRelNests is used to show the dependency between
///   regular tasks and recurring task definitions (please see
///   the section about time and duration use definitions).
/// 
/// As shown in Figure 13, the installation of a number of items of equipment within a
///   particular space may be the subject of a single task which
///   is identified as 'fix equipment in space 123'.
///   IfcTask represents the occurrence of a work
///   performance of a type of process in a construction plan.
/// 
/// Figure 13 — Task visualization
/// 
/// A task may nest other tasks as sub-items; the nesting
///   relationship is modeled by IfcRelNests as shown in Figure 14. For example,
///   the construction of a stud wall may be designated as a
///   nesting task named 'install wall #1' including other tasks
///   such as 'install dry wall', 'install studs', 'wall taping',
///   and 'erect wall' as sub-processes. A value that indicates
///   the relative tree view position of the task (in comparison
///   to the tree view position of other tasks and the task
///   hierarchy defined by IfcRelNests).
///   The task order information that is used for viewing
///   purposes is derived from the order defined by the
///   IfcRelNests relationship and thus is independent of
///   the logical task order defined through
///   IfcRelSequence. The hierarchy and order defined
///   through IfcRelNests enables to order the tasks in a
///   tree view or list view structure.
/// 
/// Figure 14 — Task nesting relationships
/// 
/// Time and duration use definition
/// 
/// Compared to previous IFC releases, basic task time
///   information (scheduled start time, scheduled finish
///   time, duration) is now directly attached to IfcTask
///   through the TaskTime attribute. Regular tasks are
///   defined through IfcTaskTime. Recurring tasks are
///   defined through IfcTaskTimeRecurring. In case a
///   regular task is derived from a recurring task both tasks
///   should be linked together through a IfcRelNests
///   relationship, where IfcRelNests.IsNestedBy points to
///   the recurring task and IfcRelNests.Nests points to
///   all regular tasks that have been derived from the recurring
///   task.
/// 
/// Assignment use definition
/// 
/// Occurrences of IfcTask may be assigned to an
///   IfcWorkControl (either a work plan or a work
///   schedule) through IfcRelAssignsToControl. From
///   IFC2x4 onwards it is suggested to use the 'summary task'
///   (root element of the task hierarchy that is required for
///   task management purposes) to assign all subtask to a work
///   plan or work schedule. Resources used by tasks are assigned
///   by IfcRelAssignsToProcess. Quantities of resources
///   consumed by the task are dealt with by defining the
///   IfcElementQuantity for the resource and not at the
///   instance of IfcTask. Please note that the
///   IfcRelAssignsTasks relationship class has been
///   removed in IFC2x4 and is no longer available.
/// 
/// An IfcTask may be assigned a Work Breakdown
///   Structure (WBS) code. A WBS code is dealt with as a
///   classification of task and is associated to a task
///   occurrence using the IfcRelAssociatesClassification
///   relationship class. As well as being to designate the code,
///   the classification structure of the IFC model also enables
///   the source of the work breakdown structure classification
///   to be identified.
/// 
/// Constraint use definition
/// 
/// Constraints may be applied to a task to indicate fixed task
///   duration, fixed start or fixed finish (see Figure 15). The relationship
///   IfcRelAssociatesConstraint is used where
///   RelatingConstraint points to an IfcMetric and
///   RelatedObjects includes the IfcTask.
///   IfcRelAssociatesConstraint.Name identifies the
///   attribute to be constrained using a period (".") to
///   dereference; for example, "TaskTime.ScheduleStart" refers
///   to the ScheduleStart attribute on the
///   IfcTaskTime entity referenced on the TaskTime
///   attribute. The following attributes may be constrained:
/// 
/// 'TaskTime.ScheduleDuration': Indicate fixed
///   duration of task with ConstraintGrade=HARD and
///   Benchmark=EQUALTO such that changes to an assigned
///   IfcConstructionResource.ResourceTime.ScheduleWork
///   should impact
///   IfcConstructionResource.ResourceTime.ScheduleUsage,
///   and vice-versa.
/// 
/// 'TaskTime.ScheduleStart': Indicate constrained
///   start date with ConstraintGrade=HARD and Benchmark of
///   EQUALTO, GREATERTHANOREQUALTO, or LESSTHANOREQUALTO to
///   indicate "must start on", "start no earlier than" or
///   "start no later than" respectively where
///   IfcMetric.DataValue indicates the specific
///   IfcDateTime. Use SOFT constraint having LESSTHAN
///   benchmark to indicate "start as soon as possible".
/// 
/// 'TaskTime.ScheduleFinish': Indicate constrained
///   finish date with ConstraintGrade=HARD and Benchmark of
///   EQUALTO, GREATERTHANOREQUALTO, or LESSTHANOREQUALTO to
///   indicate "must finish on", "finish no earlier than" or
///   "finish no later than" respectively where
///   IfcMetric.DateValue indicates the specific
///   IfcDateTime. Use SOFT constraint having
///   GREATERTHAN benchmark to indicate "finish as late as
///   possible".
/// 
/// A "manual scheduled task" is indicated with
///   ConstraintGrade=HARD and Benchmark=EQUALTO for both
///   TaskTime.ScheduleStart and
///   TaskTime.ScheduleFinish.
/// 
/// Figure 15 — Task constraints
/// 
/// Use Definition to represent other activities
/// 
/// The use definitions for IfcTask have been generalised to
///   represent other activities as well, including actitities
///   that had been defined by own entities in previous IFC
///   releases. This includes
/// 
/// Order actions
///   Move operations
/// 
/// IfcTask represents an order that might be carried
///   out by a Helpdesk acting the role of interface for the
///   organization between the facility user and the functional
///   requirement of fulfilling their needs. The actual task
///   represented by the IfcTask entity is turning a
///   request into an order and initiating the action that will
///   enable the order to be completed. The
///   IfcProjectOrder or one of its subtypes including
///   maintenance work order, is related to the IfcTask
///   using IfcRelAssignsToControl.
/// 
/// IfcTask can also be used to describe an activity
///   that moves people, groups within an organization or
///   complete organizations together with their associated
///   furniture and equipment from one place to another. It thus
///   replaces the previous IFC entity IfcMove. The functionality
///   is represented in IfcTask as follows:
/// 
/// Move from: The place from which actors and their
///   associated equipment are moving.
///   Use IfcRelAssignsToProcess where
///   RelatingProcess points to the task and
///   RelatedObjects holds the location(s) from which to
///   move.
///   Move to: The place to which actors and their
///   associated equipment are moving.
///   Use IfcRelAssignsToProduct where
///   RelatedObjects points to the task(s) and
///   RelatingProduct points to the location to which to
///   move.
///   Punch list: A list of points concerning a move that
///   require attention.
///   Use LongDescription or else identify sub-tasks to
///   track punch list items individually via IfcRelNests.
class IFC_PARSE_API IfcTask : public IfcProcess {
public:
    /// Whether the optional attribute Status is defined for this IfcTask
    bool hasStatus() const;
    /// Current status of the task.
    /// 
    /// NOTE: Particular values for status are not
    ///   specified, these should be determined and agreed by local
    ///   usage. Examples of possible status values include 'Not Yet
    ///   Started', 'Started', 'Completed'.
    std::string Status() const;
    void setStatus(std::string v);
    /// Whether the optional attribute WorkMethod is defined for this IfcTask
    bool hasWorkMethod() const;
    /// The method of work used in carrying out a task.
    /// 
    /// NOTE: This attribute should
    ///   not be used if the work method is specified for the
    ///   IfcTaskType
    std::string WorkMethod() const;
    void setWorkMethod(std::string v);
    /// Identifies whether a task is a milestone task (=TRUE) or not
    ///   (= FALSE).
    /// 
    /// NOTE: In small project planning applications,
    ///   a milestone task may be understood to be a task having no
    ///   duration. As such, it represents a singular point in
    ///   time.
    bool IsMilestone() const;
    void setIsMilestone(bool v);
    /// Whether the optional attribute Priority is defined for this IfcTask
    bool hasPriority() const;
    /// A value that indicates the relative priority of the task (in
    ///   comparison to the priorities of other tasks).
    int Priority() const;
    void setPriority(int v);
    /// Whether the optional attribute TaskTime is defined for this IfcTask
    bool hasTaskTime() const;
    /// Time related information for the task.
    /// 
    /// Added in IFC 2x4
    IfcTaskTime* TaskTime() const;
    void setTaskTime(IfcTaskTime* v);
    /// Whether the optional attribute PredefinedType is defined for this IfcTask
    bool hasPredefinedType() const;
    /// Identifies the predefined types of a task from which 
    ///   the type required may be set.
    /// 
    /// Added in IFC 2x4
    IfcTaskTypeEnum::IfcTaskTypeEnum PredefinedType() const;
    void setPredefinedType(IfcTaskTypeEnum::IfcTaskTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 13; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 7: return IfcUtil::Argument_STRING; case 8: return IfcUtil::Argument_STRING; case 9: return IfcUtil::Argument_BOOL; case 10: return IfcUtil::Argument_INT; case 11: return IfcUtil::Argument_ENTITY_INSTANCE; case 12: return IfcUtil::Argument_ENUMERATION; } return IfcProcess::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 7: return Type::IfcLabel; case 8: return Type::IfcLabel; case 9: return Type::IfcBoolean; case 10: return Type::IfcInteger; case 11: return Type::IfcTaskTime; case 12: return Type::IfcTaskTypeEnum; } return IfcProcess::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 7: return "Status"; case 8: return "WorkMethod"; case 9: return "IsMilestone"; case 10: return "Priority"; case 11: return "TaskTime"; case 12: return "PredefinedType"; } return IfcProcess::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcTask (IfcEntityInstanceData* e);
    IfcTask (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, boost::optional< std::string > v6_Identification, boost::optional< std::string > v7_LongDescription, boost::optional< std::string > v8_Status, boost::optional< std::string > v9_WorkMethod, bool v10_IsMilestone, boost::optional< int > v11_Priority, IfcTaskTime* v12_TaskTime, boost::optional< IfcTaskTypeEnum::IfcTaskTypeEnum > v13_PredefinedType);
    typedef IfcTemplatedEntityList< IfcTask > list;
};
/// An IfcTaskType defines a
///   particular type of task that may be specified for use
///   within a work control.
/// 
/// HISTORY  New entity in IFC2x4
/// 
/// An IfcTaskType provides for all forms of types of
///   task that may be specified.
/// 
/// Usage of IfcTaskType defines the parameters for one
///   or more occurrences of IfcTask. Parameters may be
///   specified through property sets that may be enumerated in
///   the IfcTaskTypeEnum data type or through explict
///   attributes of IfcTaskType. Task occurrences
///   (IfcTask entities) are linked to the task type
///   through the IfcRelDefinesByType relationship.
/// 
/// Composition use definition
/// 
/// IfcTaskType may nest other IfcTaskType or
///   IfcTask entities using the IfcRelNests
///   relationship. Such nesting indicates decomposed level of
///   detail. Nesting of IfcTask entities is used if a
///   task type shall be detailed by a sequence of tasks or if
///   there is a need to include additional time information such
///   as the duration of subtasks. Please note that
///   IfcTask entities being contained within an
///   IfcTaskType are linked with their task occurrences
///   via IfcRelDefinesByObject relationships. It is also
///   possible to define a task type for these IfcTask
///   entities via IfcRelDefinesByType relationships. For
///   further information please see the documentation of
///   IfcRelDefinesByObject.
/// 
/// Figure 16 shows the definition of a task type that is part
///   of a task template library. Please note that in this
///   example the task type is further subdivided into tasks that
///   define task times (for example, duration) and/or a task sequence.
/// 
/// Figure 16 — Task type relationships
class IFC_PARSE_API IfcTaskType : public IfcTypeProcess {
public:
    /// Identifies the predefined types of a task type from which 
    ///   the type required may be set.
    IfcTaskTypeEnum::IfcTaskTypeEnum PredefinedType() const;
    void setPredefinedType(IfcTaskTypeEnum::IfcTaskTypeEnum v);
    /// Whether the optional attribute WorkMethod is defined for this IfcTaskType
    bool hasWorkMethod() const;
    /// The method of work used in carrying out a task.
    std::string WorkMethod() const;
    void setWorkMethod(std::string v);
    virtual unsigned int getArgumentCount() const { return 11; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; case 10: return IfcUtil::Argument_STRING; } return IfcTypeProcess::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcTaskTypeEnum; case 10: return Type::IfcLabel; } return IfcTypeProcess::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; case 10: return "WorkMethod"; } return IfcTypeProcess::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcTaskType (IfcEntityInstanceData* e);
    IfcTaskType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< std::string > v7_Identification, boost::optional< std::string > v8_LongDescription, boost::optional< std::string > v9_ProcessType, IfcTaskTypeEnum::IfcTaskTypeEnum v10_PredefinedType, boost::optional< std::string > v11_WorkMethod);
    typedef IfcTemplatedEntityList< IfcTaskType > list;
};

class IFC_PARSE_API IfcTessellatedFaceSet : public IfcTessellatedItem {
public:
    IfcCartesianPointList3D* Coordinates() const;
    void setCoordinates(IfcCartesianPointList3D* v);
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcTessellatedItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcCartesianPointList3D; } return IfcTessellatedItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Coordinates"; } return IfcTessellatedItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcIndexedColourMap >::ptr HasColours() const; // INVERSE IfcIndexedColourMap::MappedTo
    IfcTemplatedEntityList< IfcIndexedTextureMap >::ptr HasTextures() const; // INVERSE IfcIndexedTextureMap::MappedTo
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcTessellatedFaceSet (IfcEntityInstanceData* e);
    IfcTessellatedFaceSet (IfcCartesianPointList3D* v1_Coordinates);
    typedef IfcTemplatedEntityList< IfcTessellatedFaceSet > list;
};

class IFC_PARSE_API IfcToroidalSurface : public IfcElementarySurface {
public:
    double MajorRadius() const;
    void setMajorRadius(double v);
    double MinorRadius() const;
    void setMinorRadius(double v);
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 1: return IfcUtil::Argument_DOUBLE; case 2: return IfcUtil::Argument_DOUBLE; } return IfcElementarySurface::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 1: return Type::IfcPositiveLengthMeasure; case 2: return Type::IfcPositiveLengthMeasure; } return IfcElementarySurface::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 1: return "MajorRadius"; case 2: return "MinorRadius"; } return IfcElementarySurface::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcToroidalSurface (IfcEntityInstanceData* e);
    IfcToroidalSurface (IfcAxis2Placement3D* v1_Position, double v2_MajorRadius, double v3_MinorRadius);
    typedef IfcTemplatedEntityList< IfcToroidalSurface > list;
};
/// Definition from IAI: The element type
/// IfcTransportElementType defines commonly shared
/// information for occurrences of transport elements. The set of
/// shared information may include:
/// 
/// common properties within shared property sets
/// common material information
/// common shape representations
/// 
/// It is used to define a transport element specification (i.e.
/// the specific product information that is common to all
/// occurrences of that beam type). Transport element types (or the
/// instantiable subtypes) may be exchanged without being already
/// assigned to occurrences.
/// The occurrences of the IfcTransportElementType are
/// represented by instances of IfcTransportElement (or its
/// subtypes).
/// 
/// HISTORY: New entity in Release
/// IFC2x Edition 2.
/// 
/// Property Set Use Definition:
/// The shared property sets relating to the
/// IfcTransportElementType are defined by the
/// IfcPropertySet and are attached by the
/// HasPropertySets attribute. The following property set
/// definitions specific to the IfcTransportElementType are
/// part of this IFC release:
/// NOTE There is no differentiation between
/// properties within the property set that are only assignable to
/// IfcTransportElementType and those that are only assignable
/// to IfcTransportElement. If the same property is assigned
/// to the IfcTransportElementType and the
/// IfcTransportElement being an occurrence of the
/// IfcTransportElementType, then the occurrence property
/// overrides the type property.
/// 
/// Pset_TransportElementCommon: common property
/// set for all transport element types
/// 
/// Pset_TransportElementElevator: specific
/// property set for all types of transport elements with the
/// PredefinedType: ELEVATOR
/// 
/// Geometry Use Definition:
/// The IfcTransportElementType may define the shared
/// geometric representation for all transport element occurrences.
/// The RepresentationMaps attribute refers to a list of
/// IfcRepresentationMap's, that allow for multiple geometric
/// representations (e.g. with IfcShaperepresentation's having
/// an RepresentationIdentifier 'Box', 'FootPrint', or
/// 'Body').
/// NOTE The product shape representations are
/// defined as RepresentationMaps (attribute of the supertype
/// IfcTypeProduct), which get assigned by an element
/// occurrence instance through the
/// IfcShapeRepresentation.Item[n] being an
/// IfcMappedItem. See IfcTypeProduct for further
/// information.
/// NOTE The values of attributes
/// RepresentationIdentifier and RepresentationType of
/// IfcShapeRepresentation are restricted in the same way as
/// those for IfcTransportElementType.
class IFC_PARSE_API IfcTransportElementType : public IfcElementType {
public:
    /// Predefined types to define the particular type of the transport element. There may be property set definitions available for each predefined type.
    IfcTransportElementTypeEnum::IfcTransportElementTypeEnum PredefinedType() const;
    void setPredefinedType(IfcTransportElementTypeEnum::IfcTransportElementTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcElementType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcTransportElementTypeEnum; } return IfcElementType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcElementType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcTransportElementType (IfcEntityInstanceData* e);
    IfcTransportElementType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcTransportElementTypeEnum::IfcTransportElementTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcTransportElementType > list;
};

class IFC_PARSE_API IfcTriangulatedFaceSet : public IfcTessellatedFaceSet {
public:
    /// Whether the optional attribute Normals is defined for this IfcTriangulatedFaceSet
    bool hasNormals() const;
    std::vector< std::vector< double > > Normals() const;
    void setNormals(std::vector< std::vector< double > > v);
    /// Whether the optional attribute Closed is defined for this IfcTriangulatedFaceSet
    bool hasClosed() const;
    bool Closed() const;
    void setClosed(bool v);
    std::vector< std::vector< int > > CoordIndex() const;
    void setCoordIndex(std::vector< std::vector< int > > v);
    /// Whether the optional attribute PnIndex is defined for this IfcTriangulatedFaceSet
    bool hasPnIndex() const;
    std::vector< int > /*[1:?]*/ PnIndex() const;
    void setPnIndex(std::vector< int > /*[1:?]*/ v);
    virtual unsigned int getArgumentCount() const { return 5; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 1: return IfcUtil::Argument_AGGREGATE_OF_AGGREGATE_OF_DOUBLE; case 2: return IfcUtil::Argument_BOOL; case 3: return IfcUtil::Argument_AGGREGATE_OF_AGGREGATE_OF_INT; case 4: return IfcUtil::Argument_AGGREGATE_OF_INT; } return IfcTessellatedFaceSet::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 1: return Type::IfcParameterValue; case 2: return Type::IfcBoolean; case 3: return Type::IfcPositiveInteger; case 4: return Type::IfcPositiveInteger; } return IfcTessellatedFaceSet::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 1: return "Normals"; case 2: return "Closed"; case 3: return "CoordIndex"; case 4: return "PnIndex"; } return IfcTessellatedFaceSet::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcTriangulatedFaceSet (IfcEntityInstanceData* e);
    IfcTriangulatedFaceSet (IfcCartesianPointList3D* v1_Coordinates, boost::optional< std::vector< std::vector< double > > > v2_Normals, boost::optional< bool > v3_Closed, std::vector< std::vector< int > > v4_CoordIndex, boost::optional< std::vector< int > /*[1:?]*/ > v5_PnIndex);
    typedef IfcTemplatedEntityList< IfcTriangulatedFaceSet > list;
};
/// The window lining is the outer
/// frame which enables the window to be fixed in position. The
/// window lining is used to hold the window panels or other
/// casements. The parameter of the IfcWindowLiningProperties
/// define the geometrically relevant parameter of the lining.
/// 
/// NOTEÿ The IfcWindowLiningProperties
/// shall only be applied to construct the 3D shape of a window, if
/// the attribute IfcWindowStyle.ParameterTakesPrecedence is
/// set TRUE.
/// 
/// The IfcWindowLiningProperties are included in the set
/// of properties of IfcWindowStyle.HasPropertySets. More
/// information about the window lining can be included in the same
/// set of the IfcWindowStyle using another
/// IfcPropertySet for dynamic extensions.
/// 
/// HISTORY New Entity in IFC Release 2.0. Has been renamed from IfcWindowLining in
/// IFC Release 2x.
/// 
/// IFC2x4 CHANGEÿ The following attributes have been added LiningOffset,
/// LiningToPanelOffsetX, LiningToPanelOffsetY. The
/// attribute ShapeAspectStyle is deprecated and shall no
/// longer be used. Supertype changed to new
/// IfcPreDefinedPropertySet.
/// 
/// Geometry use definitions
/// The IfcWindowLiningProperties does not hold a geometric representation. However it defines parameters which can be used to create the shape of the window style (which is inserted by the IfcWindow into the spatial context of the project) as shown in Figure 175.
/// The parameters at the IfcWindowLiningProperties define a standard window lining, including (if given) a mullion and a transom (for horizontal and vertical splits). The outer boundary of the lining is determined by the occurrence parameter assigned to the IfcWindow, which inserts the IfcWindowStyle.
/// 
/// The lining is applied to all faces
/// of the opening reveal. The parameter are:
/// 
/// LiningDepth
/// LiningThickness
/// LiningOffset
/// LiningToPanelOffsetX
/// LiningToPanelOffsetY
/// 
/// NOTE Parameters added in
/// IFC2x4.
/// 
/// Inner side is defined as the direction of the window panel
/// opening operation.
/// 
/// If the OperationType of the
/// window style is
/// 
/// DoublePanelVertical (shown)
/// TriplePanelBottom
/// TriplePanelTop
/// TriplePanelLeft
/// TriplePanelRight
/// 
/// the following additional parameter apply:
/// 
/// MullionThickness
/// FirstMullionOffset - measured as offset to the Z axis
/// (in XZ plane)
/// 
/// If the OperationType of the
/// window style is
/// 
/// DoublePanelHorizontal
/// TriplePanelBottom
/// TriplePanelTop
/// TriplePanelLeft
/// TriplePanelRight
/// 
/// the following additional parameter apply
/// 
/// TransomThickness
/// FirstTransomOffset measured as offset to the X axis
/// (in XZ plane)
/// 
/// If the OperationType of the
/// window style is
/// 
/// TriplePanelVertical
/// 
/// the following additional parameter apply
/// 
/// SecondMullionOffset
/// 
/// If the OperationType of the
/// window style is
/// 
/// TriplePanelHorizontal
/// 
/// the following additional parameter apply
/// 
/// SecondTransomOffset
/// 
/// Figure 175 — Window lining properties
/// 
/// NOTE
/// 
/// All offsets are given as a normalized ratio measure.
class IFC_PARSE_API IfcWindowLiningProperties : public IfcPreDefinedPropertySet {
public:
    /// Whether the optional attribute LiningDepth is defined for this IfcWindowLiningProperties
    bool hasLiningDepth() const;
    /// Depth of the window lining (dimension measured perpendicular to window elevation plane).
    double LiningDepth() const;
    void setLiningDepth(double v);
    /// Whether the optional attribute LiningThickness is defined for this IfcWindowLiningProperties
    bool hasLiningThickness() const;
    /// Thickness of the window lining (measured parallel to the window elevation plane).
    double LiningThickness() const;
    void setLiningThickness(double v);
    /// Whether the optional attribute TransomThickness is defined for this IfcWindowLiningProperties
    bool hasTransomThickness() const;
    /// Thickness of the transom (horizontal separator of window panels within a window), measured parallel to the window elevation plane. The transom is part of the lining and the transom depth is assumed to be identical to the lining depth.
    double TransomThickness() const;
    void setTransomThickness(double v);
    /// Whether the optional attribute MullionThickness is defined for this IfcWindowLiningProperties
    bool hasMullionThickness() const;
    /// Thickness of the mullion (vertical separator of window panels within a window), measured parallel to the window elevation plane. The mullion is part of the lining and the mullion depth is assumed to be identical to the lining depth.
    double MullionThickness() const;
    void setMullionThickness(double v);
    /// Whether the optional attribute FirstTransomOffset is defined for this IfcWindowLiningProperties
    bool hasFirstTransomOffset() const;
    /// Offset of the transom centerline, measured along the z-axis of the window placement co-ordinate system. An offset value = 0.5 indicates that the transom is positioned in the middle of the window.
    double FirstTransomOffset() const;
    void setFirstTransomOffset(double v);
    /// Whether the optional attribute SecondTransomOffset is defined for this IfcWindowLiningProperties
    bool hasSecondTransomOffset() const;
    /// Offset of the transom centerline for the second transom, measured along the x-axis of the window placement co-ordinate system. An offset value = 0.666 indicates that the second transom is positioned at two/third of the window.
    double SecondTransomOffset() const;
    void setSecondTransomOffset(double v);
    /// Whether the optional attribute FirstMullionOffset is defined for this IfcWindowLiningProperties
    bool hasFirstMullionOffset() const;
    /// Offset of the mullion centerline, measured along the x-axis of the window placement co-ordinate system. An offset value = 0.5 indicates that the mullion is positioned in the middle of the window.
    double FirstMullionOffset() const;
    void setFirstMullionOffset(double v);
    /// Whether the optional attribute SecondMullionOffset is defined for this IfcWindowLiningProperties
    bool hasSecondMullionOffset() const;
    /// Offset of the mullion centerline for the second mullion, measured along the x-axis of the window placement co-ordinate system. An offset value = 0.666 indicates that the second mullion is positioned at two/third of the window.
    double SecondMullionOffset() const;
    void setSecondMullionOffset(double v);
    /// Whether the optional attribute ShapeAspectStyle is defined for this IfcWindowLiningProperties
    bool hasShapeAspectStyle() const;
    /// Optional link to a shape aspect definition, which points to the part of the geometric representation of the window style, which is used to represent the lining.
    /// 
    /// IFC2x4 CHANGE The attribute is deprecated and shall no longer be used, i.e. the value shall be NIL ($).
    IfcShapeAspect* ShapeAspectStyle() const;
    void setShapeAspectStyle(IfcShapeAspect* v);
    /// Whether the optional attribute LiningOffset is defined for this IfcWindowLiningProperties
    bool hasLiningOffset() const;
    /// Offset of the window lining. The offset is given as distance along the y axis of the local placement (perpendicular to the window plane).
    /// 
    /// IFC2x4 CHANGE: New attribute added at the end of the entity definition.
    double LiningOffset() const;
    void setLiningOffset(double v);
    /// Whether the optional attribute LiningToPanelOffsetX is defined for this IfcWindowLiningProperties
    bool hasLiningToPanelOffsetX() const;
    /// Offset between the lining and the window panel measured along the x-axis of the local placement. Should be smaller or equal to the LiningThickness.
    /// 
    /// IFC2x4 CHANGE: New attribute added at the end of the entity definition.
    double LiningToPanelOffsetX() const;
    void setLiningToPanelOffsetX(double v);
    /// Whether the optional attribute LiningToPanelOffsetY is defined for this IfcWindowLiningProperties
    bool hasLiningToPanelOffsetY() const;
    /// Offset between the lining and the window panel measured along the y-axis of the local placement. Should be smaller or equal to the IfcWindowPanelProperties.PanelThickness.
    /// 
    /// IFC2x4 CHANGE: New attribute added at the end of the entity definition.
    double LiningToPanelOffsetY() const;
    void setLiningToPanelOffsetY(double v);
    virtual unsigned int getArgumentCount() const { return 16; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 4: return IfcUtil::Argument_DOUBLE; case 5: return IfcUtil::Argument_DOUBLE; case 6: return IfcUtil::Argument_DOUBLE; case 7: return IfcUtil::Argument_DOUBLE; case 8: return IfcUtil::Argument_DOUBLE; case 9: return IfcUtil::Argument_DOUBLE; case 10: return IfcUtil::Argument_DOUBLE; case 11: return IfcUtil::Argument_DOUBLE; case 12: return IfcUtil::Argument_ENTITY_INSTANCE; case 13: return IfcUtil::Argument_DOUBLE; case 14: return IfcUtil::Argument_DOUBLE; case 15: return IfcUtil::Argument_DOUBLE; } return IfcPreDefinedPropertySet::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 4: return Type::IfcPositiveLengthMeasure; case 5: return Type::IfcNonNegativeLengthMeasure; case 6: return Type::IfcNonNegativeLengthMeasure; case 7: return Type::IfcNonNegativeLengthMeasure; case 8: return Type::IfcNormalisedRatioMeasure; case 9: return Type::IfcNormalisedRatioMeasure; case 10: return Type::IfcNormalisedRatioMeasure; case 11: return Type::IfcNormalisedRatioMeasure; case 12: return Type::IfcShapeAspect; case 13: return Type::IfcLengthMeasure; case 14: return Type::IfcLengthMeasure; case 15: return Type::IfcLengthMeasure; } return IfcPreDefinedPropertySet::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 4: return "LiningDepth"; case 5: return "LiningThickness"; case 6: return "TransomThickness"; case 7: return "MullionThickness"; case 8: return "FirstTransomOffset"; case 9: return "SecondTransomOffset"; case 10: return "FirstMullionOffset"; case 11: return "SecondMullionOffset"; case 12: return "ShapeAspectStyle"; case 13: return "LiningOffset"; case 14: return "LiningToPanelOffsetX"; case 15: return "LiningToPanelOffsetY"; } return IfcPreDefinedPropertySet::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcWindowLiningProperties (IfcEntityInstanceData* e);
    IfcWindowLiningProperties (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< double > v5_LiningDepth, boost::optional< double > v6_LiningThickness, boost::optional< double > v7_TransomThickness, boost::optional< double > v8_MullionThickness, boost::optional< double > v9_FirstTransomOffset, boost::optional< double > v10_SecondTransomOffset, boost::optional< double > v11_FirstMullionOffset, boost::optional< double > v12_SecondMullionOffset, IfcShapeAspect* v13_ShapeAspectStyle, boost::optional< double > v14_LiningOffset, boost::optional< double > v15_LiningToPanelOffsetX, boost::optional< double > v16_LiningToPanelOffsetY);
    typedef IfcTemplatedEntityList< IfcWindowLiningProperties > list;
};
/// A window panel is a casement, that is, a component, fixed or opening,
/// consisting essentially of a frame and the infilling. The
/// infilling of a window panel is normally glazing. The way of
/// operation is defined in the operation type.
/// The IfcWindowPanelProperties are used to parametrically
/// describe the shape and operation of window panels. The parametric
/// definition can be added solely or additionally to the explicit
/// shape representation of the window.
/// The IfcWindowStyle can define windows consisting of
/// more then one panel. In this case, one instance of
/// IfcWindowPanelProperties has to be included for each
/// window panel. The PanelPosition attribute, in conjunction
/// with the IfcWindowStyle.OperationType attribute,
/// determines to which panel the IfcWindowPanelProperties
/// apply.
/// The IfcWindowPanelProperties are included in the list
/// of properties (HasPropertySets) of the
/// IfcWindowStyle. More information about the window panel
/// can be included in the same list of the IfcWindowStyle
/// using the IfcPropertySet for dynamic extensions.
/// 
/// HISTORY New entity in
/// IFC Release 2.0, it had been renamed from IfcWindowPanel in IFC
/// Release 2x.
/// 
/// IFC2x4 CHANGE Supertype changed to
/// new IfcPreDefinedPropertySet.
/// 
/// Geometry use definitions
/// The IfcWindowPanelProperties does not hold an own
/// geometric representation. However it defines parameter, which can
/// be used to create the shape of the IfcWindowStyle (which
/// is inserted by the IfcWindow into the spatial context of
/// the project).
/// The parameters at the IfcWindowPanelProperties define a
/// standard window panel. The outer boundary of the panel is
/// determined by the occurrence parameter assigned to the IfcWindow,
/// which inserts the IfcWindowStyle. It has to take the lining
/// parameter into account as well. The position of the window panel
/// within the overall window is determined by the
/// PanelPosition attribute.
/// 
/// As shown in Figure 176, the panel is applied to the position within the lining as defined by the panel position attribute. The following parameter apply to that panel: FrameDepth, FrameThickness.
/// 
/// Figure 176 — Window panel properties
class IFC_PARSE_API IfcWindowPanelProperties : public IfcPreDefinedPropertySet {
public:
    /// Types of window panel operations. Also used to assign standard symbolic presentations according to national building standards.
    IfcWindowPanelOperationEnum::IfcWindowPanelOperationEnum OperationType() const;
    void setOperationType(IfcWindowPanelOperationEnum::IfcWindowPanelOperationEnum v);
    /// Position of this panel within the overall window style.
    IfcWindowPanelPositionEnum::IfcWindowPanelPositionEnum PanelPosition() const;
    void setPanelPosition(IfcWindowPanelPositionEnum::IfcWindowPanelPositionEnum v);
    /// Whether the optional attribute FrameDepth is defined for this IfcWindowPanelProperties
    bool hasFrameDepth() const;
    /// Depth of panel frame, measured from front face to back face horizontally (i.e. perpendicular to the window (elevation) plane.
    double FrameDepth() const;
    void setFrameDepth(double v);
    /// Whether the optional attribute FrameThickness is defined for this IfcWindowPanelProperties
    bool hasFrameThickness() const;
    /// Width of panel frame, measured from inside of panel (at glazing) to outside of panel (at lining), i.e. parallel to the window (elevation) plane.
    double FrameThickness() const;
    void setFrameThickness(double v);
    /// Whether the optional attribute ShapeAspectStyle is defined for this IfcWindowPanelProperties
    bool hasShapeAspectStyle() const;
    /// Optional link to a shape aspect definition, which points to the part of the geometric representation of the window style, which is used to represent the panel.
    /// 
    /// IFC2x4 CHANGE The attribute is deprecated and shall no longer be used, i.e. the value shall be NIL ($).
    IfcShapeAspect* ShapeAspectStyle() const;
    void setShapeAspectStyle(IfcShapeAspect* v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 4: return IfcUtil::Argument_ENUMERATION; case 5: return IfcUtil::Argument_ENUMERATION; case 6: return IfcUtil::Argument_DOUBLE; case 7: return IfcUtil::Argument_DOUBLE; case 8: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcPreDefinedPropertySet::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 4: return Type::IfcWindowPanelOperationEnum; case 5: return Type::IfcWindowPanelPositionEnum; case 6: return Type::IfcPositiveLengthMeasure; case 7: return Type::IfcPositiveLengthMeasure; case 8: return Type::IfcShapeAspect; } return IfcPreDefinedPropertySet::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 4: return "OperationType"; case 5: return "PanelPosition"; case 6: return "FrameDepth"; case 7: return "FrameThickness"; case 8: return "ShapeAspectStyle"; } return IfcPreDefinedPropertySet::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcWindowPanelProperties (IfcEntityInstanceData* e);
    IfcWindowPanelProperties (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcWindowPanelOperationEnum::IfcWindowPanelOperationEnum v5_OperationType, IfcWindowPanelPositionEnum::IfcWindowPanelPositionEnum v6_PanelPosition, boost::optional< double > v7_FrameDepth, boost::optional< double > v8_FrameThickness, IfcShapeAspect* v9_ShapeAspectStyle);
    typedef IfcTemplatedEntityList< IfcWindowPanelProperties > list;
};
/// The IfcActor defines all actors or human agents involved in a project during its full life cycle. It facilitates the use of person and organization definitions in the resource part of the IFC object model. This includes name, address, telecommunication addresses, and roles.
/// 
/// HISTORY New Entity in IFC Release 2.0
/// 
/// Relationship use definition
/// Actors are assigned (such as to a process or a resource) by the relationship object that refers to the corresponding object:
/// 
/// Process: assigned using IfcRelAssignsToProcess
/// Resource: assigned using IfcRelAssignsToResource
/// 
/// Property set use definition
/// The property sets relating to the IfcActor are defined by IfcPropertySet and attached by the
/// IfcRelDefinesByProperties relationship. They are accessible by the inverse IsDefinedBy relationship. The following property set definitions specific to IfcActor are part of this IFC release:
/// 
/// Pset_ActorCommon: common property set for all actor occurrences
class IFC_PARSE_API IfcActor : public IfcObject {
public:
    /// Information about the actor.
    IfcActorSelect* TheActor() const;
    void setTheActor(IfcActorSelect* v);
    virtual unsigned int getArgumentCount() const { return 6; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 5: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcObject::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 5: return Type::IfcActorSelect; } return IfcObject::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 5: return "TheActor"; } return IfcObject::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcRelAssignsToActor >::ptr IsActingUpon() const; // INVERSE IfcRelAssignsToActor::RelatingActor
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcActor (IfcEntityInstanceData* e);
    IfcActor (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcActorSelect* v6_TheActor);
    typedef IfcTemplatedEntityList< IfcActor > list;
};
/// An advanced B-rep is a boundary
/// representation model in which all faces, edges and vertices are
/// explicitly represented. It is a solid with explicit topology and
/// elementaty or free-form geometry. The faces of the B-rep are of
/// type IfcAdvancedFace. An advanced B-rep has to meet the
/// same topological constraints as the manifold solid B-rep.
/// NOTE The advanced B-rep has been introduced in
/// order to support the increasing number of applications that can
/// define and exchange B-rep models based on NURBS or other b-spline
/// surfaces.
/// 
/// NOTE Corresponding ISO 10303-42 entity: advanced_brep_shape_representation. Please refer to ISO/IS 10303-514:1999 for the final definition of the formal standard. There is no explicit entity in ISO 10303-42 for an advanced B-rep, the advanced_brep_shape_representation only ensures that only such kind of manifold B-rep's are used in a shape representation.
/// 
/// HISTORY New entity in IFC2x4
/// 
/// Informal proposition:
/// 
/// each face is a face surface;
/// each face surface has its geometry defined by an elementary
/// surface, swept surface or a b-spline surface;
/// the edges used to define the boundaries of the face shall all
/// reference an edge curve
/// each curve used to define the geometry of the faces and face
/// bounds shall be either a conic, or a line or a polyline or a
/// b-spline curve
/// the edges used to define the face boundaries shall all be
/// trimmed by vertices of type vertex point
/// no loop used to define a face bound shall be of the oriented
/// subtype
/// 
/// Figure 249 illustrates use of IfcAdvancedBrep for boundary representation models with b-spline surfaces. The diagram shows the topological and geometric representation items that are used for advanced B-reps, based on IfcAdvancedFace.
/// 
/// Figure 249 — Advanced Brep
class IFC_PARSE_API IfcAdvancedBrep : public IfcManifoldSolidBrep {
public:
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcManifoldSolidBrep::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcManifoldSolidBrep::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcManifoldSolidBrep::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcAdvancedBrep (IfcEntityInstanceData* e);
    IfcAdvancedBrep (IfcClosedShell* v1_Outer);
    typedef IfcTemplatedEntityList< IfcAdvancedBrep > list;
};
/// The IfcAdvancedBrepWithVoids is a specialization of an
/// advanced B-rep which contains one or more voids in its interior.
/// The voids are represented as closed shells which are defined so
/// that the shell normal point into the void.
/// 
/// NOTEÿ Corresponding ISO 10303-42 entity: brep_with_voids (see note above). Please refer to ISO/IS 10303-42:1994, p. 173 for the final definition of the formal standard. In IFC advanced B-rep with voids is represented by this subtype IfcAdvancedBrepWithVoids and not defined via an implicit ANDOR supertype constraint as in ISO/IS 10303-42:1994 between an instance of manifold_solid_brep AND brep_with_voids. This change has been made due to the fact, that only ONEOF supertype constraint is allowed within the IFC object model.
/// 
/// HISTORYÿ New entity in IFC2x4
/// 
/// Informal propositions:
/// 
/// Each void shell shall be disjoint from the outer shell and
/// from every other void shell
/// Each void shell shall be enclosed within the outer shell but
/// not within any other void shell. In particular the outer shell is
/// not in the set of void shells
/// Each shell in the IfcManifoldSolidBrep shall be
/// referenced only once.
/// All the faces of all the shells in the IfcAdvancedBrep
/// and the IfcAdvancedBrepWithVoids.Voids shall be of type
/// IfcAdvancedFace.
class IFC_PARSE_API IfcAdvancedBrepWithVoids : public IfcAdvancedBrep {
public:
    IfcTemplatedEntityList< IfcClosedShell >::ptr Voids() const;
    void setVoids(IfcTemplatedEntityList< IfcClosedShell >::ptr v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 1: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } return IfcAdvancedBrep::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 1: return Type::IfcClosedShell; } return IfcAdvancedBrep::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 1: return "Voids"; } return IfcAdvancedBrep::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcAdvancedBrepWithVoids (IfcEntityInstanceData* e);
    IfcAdvancedBrepWithVoids (IfcClosedShell* v1_Outer, IfcTemplatedEntityList< IfcClosedShell >::ptr v2_Voids);
    typedef IfcTemplatedEntityList< IfcAdvancedBrepWithVoids > list;
};
/// Definition from IAI: An annotation is a graphical
///   representation within the geometric (and spatial) context
///   of a project, that adds a note or meaning to the objects
///   which constitutes the project model. Annotations include
///   additional line drawings, text, dimensioning, hatching and
///   other forms of graphical notes.
/// 
/// NOTE Additional presentation information (often
///   2D) such as tag number, hatching, etc., that is directly
///   related to a particular product representation is
///   included within the IfcProductDefinitionShape
///   having various IfcShapeRepresentation's of the
///   IfcElement (and its subtypes). Only those
///   presentation information, that cannot be directly related
///   to a single product, have to be wrapped within the
///   IfcAnnotation.
/// 
/// If available, the annotation should be related to the
///   spatial context of the project, by containing the
///   annotation within the appropriate level of the building
///   structure (site, building, storey, or space). This is
///   handled by the IfcRelContainedInSpatialStructure
///   relationship.
/// 
/// HISTORY: New entity in
///   Release IFC2x Edition 2.
/// 
/// Use definition
/// 
/// The IfcAnnotation can provide specific 0D, 1D, and
///   2D geometric items as representation of the annotation,
///   offering annotation point, curves, and surfaces.
/// 
/// 'Annotation point' is an annotation provided by a
///   point that has additional semantic. The inherited
///   attribute ObjectType should be used to capture the
///   type of point annotation, some predefined values are:
/// 
/// 'Survey': A survey point has a set of
///   cartesian coordinates determined by its location at
///   point. These coordinates are determined relative to the
///   coordinates of a reference point, which acts as the
///   datum for the survey. The difference in elevation of
///   the survey points enables terrain to be determined.
/// 
/// 'Annotation curve' is an annotation provided by a
///   curve that has additional semantic. The inherited
///   attribute ObjectType should be used to capture the
///   type of curve annotation, some predefined values are:
/// 
/// 'ContourLine': A line of constant
///   elevation typically used on geographic maps where the
///   spacing of lines at constant intervals of elevation may
///   be used as an indication of slope.
/// 
/// 'IsoBar': A line of constant pressure
///   typically used on weather maps or to show pressure
///   gradient in spaces, chambers or externally.
/// 
/// 'IsoLux': A line of constant illumination
///   typically used to show the distribution of illumination
///   levels and/or daylighting in a space or externally.
/// 
/// 'IsoTherm': A line of constant temperature
///   typically used to show the distribution and effect of
///   heating or cooling within a space or to show
///   temperature distribution on a geographic map.
/// 
/// 'Annotation surface' is an annotation provided by
///   a surface that has additional semantic. The inherited
///   attribute ObjectType should be used to capture the
///   type of surface annotation, some predefined values are:
/// 
/// 'SurveyArea': A surface patch based on
///   survey points.
/// 
/// Geometry Use Definitions
/// 
/// The geometric representation of any IfcAnnotation is
///   given by the IfcProductDefinitionShape and
///   IfcLocalPlacement allowing multiple geometric
///   representations.
/// 
/// Local Placement
/// 
/// The local placement for any IfcAnnotation is defined
///   in its supertype IfcProduct. It is defined by the
///   IfcLocalPlacement, which defines the local
///   coordinate system that is referenced by all geometric
///   representations.
/// 
/// The PlacementRelTo relationship of
///   IfcLocalPlacement shall point (if given) to the
///   local placement of the same
///   IfcSpatialStructureElement, which is used in the 
///   ContainedInStructure inverse attribute, or to a
///   spatial structure element at a higher level, referenced
///   by that.
/// 
/// If the relative placement is not used, the absolute
///   placement is defined within the world coordinate system.
/// 
/// Geometric Representations
/// 
/// The standard representation of IfcAnnotation is
///   defined using 'Annotation2D', when using 2D geometry,
///   hatching and text, 'GeometricCurveSet' when using points
///   and curves, or, when including als surfaces, the
///   'GeometricSet' geometry. Geometric representation items may
///   be styled items by adding the style information.
/// 
/// Annotation2D Representation
///   This representation is used, when the representation of the
///   IfcAnnotation includes specific drafting
///   representation elements. The Annotation may have:
/// 
/// subtypes of IfcPoint, IfcCurve being 2D
/// 
/// directly as Items, or
///   within an IfcGeometricCurveSet
/// 
/// subtypes of IfcAnnotationFillArea for hatches
/// 
/// subtypes of IfcDefinedSymbol for symbols
/// 
/// subtypes of IfcTextLiteral for text
/// 
/// subtypes of IfcDraughtingCallout for dimensions
/// 
/// The following attribute values for the
///   IfcShapeRepresentation holding this geometric
///   representation shall be used:
/// 
/// RepresentationIdentifier : 'Annotation'
/// 
/// RepresentationType : 'Annotation2D'
/// 
/// Annotation Curve Representation
///   This representation is used, when the representation of the
///   IfcAnnotation does not includes specific drafting
///   representation elements. The Annotation may have:
/// 
/// subtypes of IfcPoint, IfcCurve being 2D
/// 
/// directly as Items, or
///   within an IfcGeometricCurveSet
/// 
/// The following attribute values for the
///   IfcShapeRepresentation holding this geometric
///   representation shall be used:
/// 
/// RepresentationIdentifier : 'Annotation'
/// 
/// RepresentationType : 'GeometricCurveSet'
/// 
/// Annotation Surface Representation
///   This representation is used, when the representation of the
///   IfcAnnotation does includes surfaces. The Annotation
///   may have:
/// 
/// subtypes of IfcPoint, IfcCurve, or
///   IfcSurface
/// 
/// directly as Items, or
///   within an IfcGeometricCurveSet
/// 
/// The following attribute values for the
///   IfcShapeRepresentation holding this geometric
///   representation shall be used:
/// 
/// RepresentationIdentifier : 'Annotation'
/// 
/// RepresentationType : 'GeometricSet'
class IFC_PARSE_API IfcAnnotation : public IfcProduct {
public:
    virtual unsigned int getArgumentCount() const { return 7; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcProduct::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcProduct::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcProduct::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcRelContainedInSpatialStructure >::ptr ContainedInStructure() const; // INVERSE IfcRelContainedInSpatialStructure::RelatedElements
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcAnnotation (IfcEntityInstanceData* e);
    IfcAnnotation (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation);
    typedef IfcTemplatedEntityList< IfcAnnotation > list;
};
/// Definition from ISO/CD 10303-42:1992: A b_spline_surface is a general form of rational or polynomial parametric surface which is represented by control points, basis functions, and possibly, weights. As with the corresponding curve entity it has some special subtypes where some of the data can be derived.
/// 
/// The symbology used here is:
/// 
/// K1
/// = upper_index_on_u_control_points
/// 
/// K2
/// = upper_index_on_v_control_points
/// 
/// Pij
/// = control_points
/// 
/// wij
/// = weights
/// 
/// d1
/// = u_degree
/// 
/// d2
/// = v_degree
/// 
/// The control points are ordered as
/// P00, P01, P02,
/// ......, PK1(K2-1),
/// PK1K2
/// The weights, in the case of the rational subtype, are ordered
/// similarly.
/// 
/// For each parameter, s = u or v, if
/// k is the upper index on the control points and d is
/// the degree for s, the knot array is an array of (k
/// + d + 2) real numbers [s-d, ....,
/// sk+1], such that for all indices j in
/// [-d, k]; sj ≤
/// sj+1. This array is obtained from the
/// appropriate u_knots or v_knots list by repeating each multiple
/// knot according to the multiplicity.
/// 
/// Nid, the ith
/// normalised B-spline basis function of degree d, is defined
/// on the subset [si-d, ....,
/// si+1] of this array.
/// 
/// Let L denote the number of distinct values amongst the
/// knots in the knot list; L will be referred to as the
/// ‘upper index on knots’. Let
/// mj denote the multiplicity (i.e., number
/// of repetitions) of the jth distinct knot value. Then:
/// 
/// All knot multiplicities except the first and the last shall be in
/// the range 1, ...., d; the first and last may have a
/// maximum value of d+1. In evaluating the basis functions, a
/// knot u of, e.g., multiplicity 3 is interpreted as a
/// sequence u, u, u, in the knot array.
/// 
/// The surface form is used to identify specific quadric surface
/// types (which shall have degree two), ruled surfaces and surfaces
/// of revolution. As with the b-spline curve, the surface form is
/// informational only and the spline data takes precedence.
/// 
/// The surface is to be interpreted as follows: In the
/// polynomial case the surface is given by the equation:
/// 
/// In the rational case the surface equation is:
/// 
/// NOTE Corresponding ISO 10303 entity: b_spline_surface. Please refer to ISO/IS 10303-42:1994, p. 78 for the final definition of the formal standard.
/// 
/// HISTORY New entity in IFC2x4.
class IFC_PARSE_API IfcBSplineSurface : public IfcBoundedSurface {
public:
    /// Algebraic degree of basis functions in u.
    int UDegree() const;
    void setUDegree(int v);
    /// Algebraic degree of basis functions in v.
    int VDegree() const;
    void setVDegree(int v);
    /// This is a list of lists of control points.
    IfcTemplatedEntityListList< IfcCartesianPoint >::ptr ControlPointsList() const;
    void setControlPointsList(IfcTemplatedEntityListList< IfcCartesianPoint >::ptr v);
    /// Indicator of special surface types.
    IfcBSplineSurfaceForm::IfcBSplineSurfaceForm SurfaceForm() const;
    void setSurfaceForm(IfcBSplineSurfaceForm::IfcBSplineSurfaceForm v);
    /// Indication of whether the surface is closed in the u direction; this is for information only.
    bool UClosed() const;
    void setUClosed(bool v);
    /// Indication of whether the surface is closed in the v direction; this is for information only.
    bool VClosed() const;
    void setVClosed(bool v);
    /// Flag to indicate whether, or not, surface is self-intersecting; this is for information only.
    bool SelfIntersect() const;
    void setSelfIntersect(bool v);
    virtual unsigned int getArgumentCount() const { return 7; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_INT; case 1: return IfcUtil::Argument_INT; case 2: return IfcUtil::Argument_AGGREGATE_OF_AGGREGATE_OF_ENTITY_INSTANCE; case 3: return IfcUtil::Argument_ENUMERATION; case 4: return IfcUtil::Argument_BOOL; case 5: return IfcUtil::Argument_BOOL; case 6: return IfcUtil::Argument_BOOL; } return IfcBoundedSurface::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcInteger; case 1: return Type::IfcInteger; case 2: return Type::IfcCartesianPoint; case 3: return Type::IfcBSplineSurfaceForm; case 4: return Type::IfcLogical; case 5: return Type::IfcLogical; case 6: return Type::IfcLogical; } return IfcBoundedSurface::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "UDegree"; case 1: return "VDegree"; case 2: return "ControlPointsList"; case 3: return "SurfaceForm"; case 4: return "UClosed"; case 5: return "VClosed"; case 6: return "SelfIntersect"; } return IfcBoundedSurface::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcBSplineSurface (IfcEntityInstanceData* e);
    IfcBSplineSurface (int v1_UDegree, int v2_VDegree, IfcTemplatedEntityListList< IfcCartesianPoint >::ptr v3_ControlPointsList, IfcBSplineSurfaceForm::IfcBSplineSurfaceForm v4_SurfaceForm, bool v5_UClosed, bool v6_VClosed, bool v7_SelfIntersect);
    typedef IfcTemplatedEntityList< IfcBSplineSurface > list;
};
/// Definition from ISO 10303:42:1994: This is a B-spline surface in which the knot values are explicitly given. This subtype shall be used to represent non-uniform B-spline surfaces, and may also be used for other knot types.
/// 
/// All knot multiplicities except the first and the last shall be in the range 1,....,d; the first and last may have a maximum value of d + 1. In evaluating the basis functions, a knot u of, e.g., multiplicity 3 is interpreted as a sequence u, u, u, in the knot array.
/// 
/// NOTE Corresponding ISO 10303 entity: b_spline_surface_with_knots. Please refer to ISO/IS 10303-42:1994, p. 81 for the final definition of the formal standard.
/// 
/// HISTORY New entity in IFC2x4.
class IFC_PARSE_API IfcBSplineSurfaceWithKnots : public IfcBSplineSurface {
public:
    /// The multiplicities of the knots in the u parameter direction.
    std::vector< int > /*[2:?]*/ UMultiplicities() const;
    void setUMultiplicities(std::vector< int > /*[2:?]*/ v);
    /// The multiplicities of the knots in the v parameter direction.
    std::vector< int > /*[2:?]*/ VMultiplicities() const;
    void setVMultiplicities(std::vector< int > /*[2:?]*/ v);
    /// The list of the distinct knots in the u parameter direction.
    std::vector< double > /*[2:?]*/ UKnots() const;
    void setUKnots(std::vector< double > /*[2:?]*/ v);
    /// The list of the distinct knots in the v parameter direction.
    std::vector< double > /*[2:?]*/ VKnots() const;
    void setVKnots(std::vector< double > /*[2:?]*/ v);
    /// The description of the knot type.
    IfcKnotType::IfcKnotType KnotSpec() const;
    void setKnotSpec(IfcKnotType::IfcKnotType v);
    virtual unsigned int getArgumentCount() const { return 12; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 7: return IfcUtil::Argument_AGGREGATE_OF_INT; case 8: return IfcUtil::Argument_AGGREGATE_OF_INT; case 9: return IfcUtil::Argument_AGGREGATE_OF_DOUBLE; case 10: return IfcUtil::Argument_AGGREGATE_OF_DOUBLE; case 11: return IfcUtil::Argument_ENUMERATION; } return IfcBSplineSurface::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 7: return Type::IfcInteger; case 8: return Type::IfcInteger; case 9: return Type::IfcParameterValue; case 10: return Type::IfcParameterValue; case 11: return Type::IfcKnotType; } return IfcBSplineSurface::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 7: return "UMultiplicities"; case 8: return "VMultiplicities"; case 9: return "UKnots"; case 10: return "VKnots"; case 11: return "KnotSpec"; } return IfcBSplineSurface::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcBSplineSurfaceWithKnots (IfcEntityInstanceData* e);
    IfcBSplineSurfaceWithKnots (int v1_UDegree, int v2_VDegree, IfcTemplatedEntityListList< IfcCartesianPoint >::ptr v3_ControlPointsList, IfcBSplineSurfaceForm::IfcBSplineSurfaceForm v4_SurfaceForm, bool v5_UClosed, bool v6_VClosed, bool v7_SelfIntersect, std::vector< int > /*[2:?]*/ v8_UMultiplicities, std::vector< int > /*[2:?]*/ v9_VMultiplicities, std::vector< double > /*[2:?]*/ v10_UKnots, std::vector< double > /*[2:?]*/ v11_VKnots, IfcKnotType::IfcKnotType v12_KnotSpec);
    typedef IfcTemplatedEntityList< IfcBSplineSurfaceWithKnots > list;
};
/// The IfcBlock is a Construction Solid Geometry (CSG) 3D
/// primitive. It is defined by a position and a positve distance along
/// the three orthogonal axes. The inherited Position
/// attribute has the IfcAxisPlacement3D type and
/// provides:
/// 
/// SELF\IfcCsgPrimitive3D.Position: The location and
/// orientation of the axis system for the primitive.
/// SELF\IfcCsgPrimitive3D.Position.Location: The block
/// has one vertex at location and the edges are aligned with the
/// placement axes in the positive sense.
/// 
/// The XLength, YLength, and ZLength
/// attributes define the size of the IfcBlock along the three
/// axes.
/// The following definitions from ISO 10303-42 apply:
/// 
/// A block is a solid
/// rectangular parallelepiped, defined with a location and placement
/// coordinate system. The block is specified by the positive lengths
/// x, y, and z along the axes of the placement coordinate system, and
/// has one vertex at the origin of the placement coordinate
/// system.
/// 
/// Figure 250 illustrates geometric parameters of a block where the block positioned within its own placement coordinate system. The values for XLength, YLength, and ZLength are applied to the positive direction of the X, Y, and Z axis.
/// 
/// Figure 250 — Block geometry
/// 
/// NOTE  Corresponding ISO 10303-42 entity: block, the position attribute has been promoted to the immediate supertype IfcCsgPrimitive3D. Please refer to ISO 10303-42:1994, p. 244 for the definition in the international standard.
/// 
/// HISTORY  New entity in IFC2x3.
/// 
/// Texture use definition
/// On each side face, textures are aligned facing upright. On the
/// top and bottom faces, textures are aligned facing front-to-back.
/// Textures are stretched or repeated to the extent of each face
/// according to RepeatS and RepeatT.
/// 
/// Figure 251 illustrates default texture mapping with a clamped texture (RepeatS=False and RepeatT=False). The image on the left shows the texture where the S axis points to the right and the T axis points up. The image on the right shows the texture applied to the geometry where the X axis points back to the right, the Y axis points back to the left, and the Z axis points up.
/// 
/// Side
/// Normal
/// Origin X
/// Origin Y
/// Origin Z
/// S Axis
/// T Axis
/// 
/// Left
/// -X
/// 0
/// +YLength
/// 0
/// -Y
/// +Z
/// 
/// Right
/// +X
/// 0
/// +YLength
/// 0
/// +Y
/// +Z
/// 
/// Front
/// +X
/// 0
/// 0
/// 0
/// +X
/// +Z
/// 
/// Back
/// +Y
/// +XLength
/// +YLength
/// 0
/// -X
/// +Z
/// 
/// Bottom
/// -Z
/// +XLength
/// 0
/// 0
/// -X
/// +Y
/// 
/// Top
/// +Z
/// 0
/// 0
/// +ZLength
/// +X
/// +Y
/// 
/// Figure 251 — Block textures
class IFC_PARSE_API IfcBlock : public IfcCsgPrimitive3D {
public:
    /// The size of the block along the placement X axis. It is provided by the inherited axis placement through SELF\IfcCsgPrimitive3D.Position.P[1].
    double XLength() const;
    void setXLength(double v);
    /// The size of the block along the placement Y axis. It is provided by the inherited axis placement through SELF\IfcCsgPrimitive3D.Position.P[2].
    double YLength() const;
    void setYLength(double v);
    /// The size of the block along the placement Z axis. It is provided by the inherited axis placement through SELF\IfcCsgPrimitive3D.Position.P[3].
    double ZLength() const;
    void setZLength(double v);
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 1: return IfcUtil::Argument_DOUBLE; case 2: return IfcUtil::Argument_DOUBLE; case 3: return IfcUtil::Argument_DOUBLE; } return IfcCsgPrimitive3D::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 1: return Type::IfcPositiveLengthMeasure; case 2: return Type::IfcPositiveLengthMeasure; case 3: return Type::IfcPositiveLengthMeasure; } return IfcCsgPrimitive3D::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 1: return "XLength"; case 2: return "YLength"; case 3: return "ZLength"; } return IfcCsgPrimitive3D::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcBlock (IfcEntityInstanceData* e);
    IfcBlock (IfcAxis2Placement3D* v1_Position, double v2_XLength, double v3_YLength, double v4_ZLength);
    typedef IfcTemplatedEntityList< IfcBlock > list;
};
/// A clipping result is defined as a special subtype of the general Boolean result (IfcBooleanResult). It constrains the operands and the operator of the Boolean result. 
/// 
/// A clipping result is the Boolean difference between a solid (restricted to swept area solid) and a half space solid, whereas more than one difference operation can be applied to the Boolean result. 
/// 
/// NOTE The IfcBooleanClippingResult is defined as a special case of the boolean_result, as defined in ISO 10303-42:1994, p. 175. It has been added to apply further constraints to the CSG representation type.
/// 
/// HISTORY New entity in IFC Release 2.x.
class IFC_PARSE_API IfcBooleanClippingResult : public IfcBooleanResult {
public:
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcBooleanResult::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcBooleanResult::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcBooleanResult::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcBooleanClippingResult (IfcEntityInstanceData* e);
    IfcBooleanClippingResult (IfcBooleanOperator::IfcBooleanOperator v1_Operator, IfcBooleanOperand* v2_FirstOperand, IfcBooleanOperand* v3_SecondOperand);
    typedef IfcTemplatedEntityList< IfcBooleanClippingResult > list;
};
/// Definition from ISO/CD 10303-42:1992: A bounded curve is a curve of finite arc length with identifiable end points. 
/// 
/// NOTE Corresponding ISO 10303 name: bounded_curve, only the following subtypes have been incorporated into IFC: polyline as IfcPolyline, trimmed_curve as IfcTrimmedCurve, composite_curve as IfcCompositeCurve. Please refer to ISO/IS 10303-42:1994, p.44 for the final definition of the formal standard.
/// 
/// HISTORY New class in IFC Release 1.0
/// 
/// Informal propositions: 
/// 
/// A bounded curve has finite arc length. 
/// A bounded curve has a start point and an end point.
class IFC_PARSE_API IfcBoundedCurve : public IfcCurve {
public:
    virtual unsigned int getArgumentCount() const { return 0; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcCurve::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcCurve::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcCurve::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcBoundedCurve (IfcEntityInstanceData* e);
    IfcBoundedCurve ();
    typedef IfcTemplatedEntityList< IfcBoundedCurve > list;
};
/// Definition from ISO 6707-1:1989: Construction work that
/// has the provision of shelter for its occupants or contents as one
/// of its main purpose and is normally designed to stand permanently
/// in one place.
/// A building represents a structure
/// that provides shelter for its occupants or contents and stands in
/// one place. The building is also used to provide a basic element
/// within the spatial structure hierarchy for the components of a
/// building project (together with site, storey, and space).
/// A building is (if specified) associated to a site. A building
/// may span over several connected or disconnected buildings.
/// Therefore building complex provides for a collection of buildings
/// included in a site. A building can also be decomposed in
/// (vertical) parts, where each part defines a building section.
/// This is defined by the composition type attribute of the
/// supertype IfcSpatialStructureElements which is interpreted
/// as follow:
/// 
/// COMPLEX = building complex
/// ELEMENT = building
/// PARTIAL = building section
/// 
/// HISTORY New entity in IFC Release 1.0.
/// 
/// Property Set Use Definition
/// The property sets relating to the IfcBuilding are
/// defined by the IfcPropertySet and attached by the
/// IfcRelDefinesByProperties relationship. It is accessible
/// by the inverse IsDefinedBy relationship. The following
/// property set definitions specific to the IfcBuilding are
/// part of this IFC release:
/// 
/// Pset_BuildingCommon: common property set for all
/// types of buildings
/// Pset_BuildingWaterStorage: specific property
/// set for buildings to capture the water supply requirements
/// Pset_BuildingUse: specific property set for
/// buildings to capture the current and anticipated real estate
/// context.
/// Pset_BuildingUseAdjacent: specific property
/// set for buildings to capture the use information about the
/// adjacent buildings.
/// 
/// Quantity Use Definition
/// The quantities relating to the IfcBuilding are defined
/// by the IfcElementQuantity and attached by the
/// IfcRelDefinesByProperties relationship. It is accessible
/// by the inverse IsDefinedBy relationship. The following
/// base quantities are defined and should be exchanged with the
/// IfcElementQuantity.Name = 'BaseQuantities'. Other
/// quantities, being subjected to local standard of measurement, can
/// be defined with another string value assigned to Name. In
/// this case a valid value for MethodOfMeasurement has to be
/// provided.
/// 
/// Qto_BuildingBaseQuantities: base quantities
/// for all building occurrences.
/// 
/// Spatial Structure Use Definition
/// The IfcBuilding is used to build the spatial structure
/// of a building (that serves as the primary project breakdown and
/// is required to be hierarchical). The spatial structure elements
/// are linked together by using the objectified relationship
/// IfcRelAggregates. The IfcBuilding references them
/// by its inverse relationships:
/// 
/// IfcBuilding.Decomposes -- referencing (IfcSite
/// || IfcBuilding) by IfcRelAggregates.RelatingObject,
/// If it refers to another instance of IfcBuilding, the
/// referenced IfcBuilding needs to have a different and
/// higher CompositionType, i.e. COMPLEX (if the other
/// IfcBuilding has ELEMENT), or ELEMENT (if the other
/// IfcBuilding has PARTIAL).
/// IfcBuilding.IsDecomposedBy -- referencing
/// (IfcBuilding || IfcBuildingStorey) by
/// IfcRelAggregates.RelatedObjects. If it refers to another
/// instance ofÿIfcBuilding, the referenced IfcBuilding
/// needs to have a different and lower CompositionType, i.e. ELEMENT
/// (if the other IfcBuilding has COMPLEX), or PARTIAL (if the
/// other IfcBuilding has ELEMENT).
/// 
/// If there are building elements and/or other elements directly
/// related to the IfcBuildingÿ(like a curtain wall spanning
/// several stories), they are associated with the IfcBuilding
/// by using the objectified relationship
/// IfcRelContainedInSpatialStructure. The IfcBuilding
/// references them by its inverse relationship:
/// 
/// IfcBuilding.ContainsElements -- referencing any
/// subtype of IfcProduct (with the exception of other spatial
/// structure element) by
/// IfcRelContainedInSpatialStructure.RelatedElements.
/// 
/// Figure 20 shows the IfcBuilding as part of the spatial
/// structure. It also serves as the spatial container for building
/// and other elements.
/// NOTE Detailed requirements on mandatory element
/// containment and placement structure relationships are given in
/// view definitions and implementer agreements.
/// 
/// Figure 20 — Building composition
/// 
/// Systems, such as building service or electrical distribution
/// systems, zonal systems, or structural analysis systems, relate to
/// IfcBuilding by using the objectified relationship
/// IfcRelServicesBuildings.
/// 
/// Attribute Use Definition
/// 
/// Figure 21 describes the heights and elevations  of the IfcBuilding. It is used to provide the height above sea level of the project height datum for this building, that is, the internal height 0.00. The height 0.00 is often used as a building internal reference height and equal to the floor finish level of the ground floor.
/// 
/// base elevation of building provided by: IfcBuilding.ElevationOfRefHeight, it is usually the top of construction slab
/// base elevation of terrain at the perimeter of the building provided by: IfcBuilding.ElevationOfTerrain, it is usually the minimum elevation is sloped terrain
/// total height of building, also referred to as ridge height (top of roof structure, e.g the ridge against terrain): provided by BaseQuantity with Name="TotalHeight"
/// eaves height of building (base of roof structure, e.g the eaves against terrain): provided by BaseQuantity with Name="EavesHeight"
/// 
/// ÿ
/// Figure 21 — Building elevations
/// 
/// Geometry Use Definitions
/// The geometric representation of IfcBuilding is given by
/// the IfcProductDefinitionShape and
/// IfcLocalPlacement, allowing multiple geometric
/// representation.
/// Local Placement
/// The local placement for IfcBuilding is defined in its
/// supertype IfcProduct. It is defined by the
/// IfcLocalPlacement, which defines the local coordinate
/// system that is referenced by all geometric representations.
/// 
/// The PlacementRelTo relationship of
/// IfcLocalPlacement shall point (if relative placement is
/// used) to the IfcSpatialStructureElement of type
/// IfcSite, or of type IfcBuilding (e.g. to position a
/// building relative to a building complex, or a building section to
/// a building).
/// If the relative placement is not used, the absolute placement
/// is defined within the world coordinate system.
/// 
/// Geometric Representations
/// Currently, the use of a 2D 'FootPrint' representation of type
/// 'GeometricCurveSet' and a 3D 'Body' representation of type 'Brep'
/// is supported.
/// Foot Print Representation
/// The foot print representation of IfcBuilding is given
/// by either a single 2D curve (such as IfcPolyline or
/// IfcCompositeCurve), or by a list of 2D curves (in case of
/// inner boundaries), if the building has an independent geometric
/// representation.
/// The representation identifier and type of this geometric
/// representation of IfcBuilding is:
/// 
/// IfcShapeRepresentation.RepresentationIdentifier =
/// 'FootPrint'
/// IfcShapeRepresentation.RepresentationType =
/// 'GeometricCurveSet'
/// 
/// Body Representation
/// The body (or solid model) geometric representation (if the
/// building has an independent geometric representation) of
/// IfcBuilding is defined using faceted B-Rep capabilities
/// (with or without voids), based on the IfcFacetedBrep or on
/// the IfcFacetedBrepWithVoids.
/// The representation identifier and type of this representation
/// of IfcBuilding is:
/// 
/// IfcShapeRepresentation.RepresentationIdentifier =
/// 'Body'
/// IfcShapeRepresentation.RepresentationType =
/// 'Brep'
/// 
/// Since the building shape is usually described by the exterior
/// building elements, an independent shape representation shall only
/// be given, if the building is exposed independently from its
/// constituting elements.
class IFC_PARSE_API IfcBuilding : public IfcSpatialStructureElement {
public:
    /// Whether the optional attribute ElevationOfRefHeight is defined for this IfcBuilding
    bool hasElevationOfRefHeight() const;
    /// Elevation above sea level of the reference height used for all storey elevation measures, equals to height 0.0. It is usually the ground floor level.
    double ElevationOfRefHeight() const;
    void setElevationOfRefHeight(double v);
    /// Whether the optional attribute ElevationOfTerrain is defined for this IfcBuilding
    bool hasElevationOfTerrain() const;
    /// Elevation above the minimal terrain level around the foot print of the building, given in elevation above sea level.
    double ElevationOfTerrain() const;
    void setElevationOfTerrain(double v);
    /// Whether the optional attribute BuildingAddress is defined for this IfcBuilding
    bool hasBuildingAddress() const;
    /// Address given to the building for postal purposes.
    IfcPostalAddress* BuildingAddress() const;
    void setBuildingAddress(IfcPostalAddress* v);
    virtual unsigned int getArgumentCount() const { return 12; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_DOUBLE; case 10: return IfcUtil::Argument_DOUBLE; case 11: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcSpatialStructureElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcLengthMeasure; case 10: return Type::IfcLengthMeasure; case 11: return Type::IfcPostalAddress; } return IfcSpatialStructureElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "ElevationOfRefHeight"; case 10: return "ElevationOfTerrain"; case 11: return "BuildingAddress"; } return IfcSpatialStructureElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcBuilding (IfcEntityInstanceData* e);
    IfcBuilding (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_LongName, boost::optional< IfcElementCompositionEnum::IfcElementCompositionEnum > v9_CompositionType, boost::optional< double > v10_ElevationOfRefHeight, boost::optional< double > v11_ElevationOfTerrain, IfcPostalAddress* v12_BuildingAddress);
    typedef IfcTemplatedEntityList< IfcBuilding > list;
};
/// Definition from IAI: The element type
///   (IfcBuildingElementType) defines a list of commonly
///   shared property set definitions of a building element and
///   an optional set of product representations. It is used to
///   define an element specification (i.e. the specific product
///   information, that is common to all occurrences of that
///   product type).
/// 
/// NOTE: The product representations are
///   defined as representation maps (at the level of the
///   supertype IfcTypeProduct, which gets assigned by
///   an element occurrence instance through the
///   IfcShapeRepresentation.Item[1] being an
///   IfcMappedItem.
/// 
/// A building element type is used to define the common
///   properties of a certain type of a building element that may
///   be applied to many instances of that feature type to assign
///   a specific style. Building element types (or the
///   instantiable subtypes) may be exchanged without being
///   already assigned to occurrences.
/// 
/// The IfcBuildingElementType is an abstract type.
///   Occurrences of subtypes of the
///   IfcBuildingElementType are represented by instances
///   of the appropriate subtypes of IfcBuildingElement.
/// 
/// HISTORY  New entity in
///   Release IFC2x Edition 2.
class IFC_PARSE_API IfcBuildingElementType : public IfcElementType {
public:
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcElementType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcElementType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcElementType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcBuildingElementType (IfcEntityInstanceData* e);
    IfcBuildingElementType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType);
    typedef IfcTemplatedEntityList< IfcBuildingElementType > list;
};
/// The building storey has an
/// elevation and typically represents a (nearly) horizontal
/// aggregation of spaces that are vertically bound.
/// A storey is (if specified) associated to a building. A storey
/// may span over several connected storeys. Therefore storey complex
/// provides for a collection of storeys included in a building. A
/// storey can also be decomposed in (horizontical) parts, where each
/// part defines a partial storey. This is defihned by the composition
/// type attribute of the supertype
/// IfcSpatialStructureElements which is interpreted as
/// follow:
/// 
/// COMPLEX = building storey complex
/// ELEMENT = building storey
/// PARTIAL = partial building storey
/// 
/// EXAMPLE In split level houses, a storey is split into two or more partial storeys, each with a different elevation. It can be handled by defining a storey, which includes two or more partial storeys with the individual elevations.
/// HISTORY New entity in IFC Release 1.0
/// 
/// Property Set Use Definition
/// The property sets relating to the IfcBuildingStorey are
/// defined by the IfcPropertySet and attached by the
/// IfcRelDefinesByProperties relationship. It is accessible
/// by the inverse IsDefinedBy relationship. The following
/// property set definitions specific to the IfcBuildingStorey
/// are part of this IFC release:
/// 
/// Pset_BuildingStoreyCommon: common property
/// set for all types of building stories
/// 
/// Quantity Use Definition
/// The quantities relating to the IfcBuildingStorey are
/// defined by the IfcElementQuantity and attached by the
/// IfcRelDefinesByProperties relationship. It is accessible
/// by the inverse IsDefinedBy relationship. The following
/// base quantities are defined and should be exchanged with the
/// IfcElementQuantity.Name = 'BaseQuantities'. Other
/// quantities, being subjected to local standard of measurement, can
/// be defined with another string value assigned to Name. In
/// this case a valid value for MethodOfMeasurement has to be
/// provided.
/// 
/// Qto_BuildingStoreyBaseQuantities: base
/// quantities for all building storey occurrences.
/// 
/// Spatial Structure Use Definition
/// The IfcBuildingStorey is used to build the spatial
/// structure of a building (that serves as the primary project
/// breakdown and is required to be hierarchical). The spatial
/// structure elements are linked together by using the objectified
/// relationship IfcRelAggregates. The
/// IfcBuildingStoreyreferences them by its inverse
/// relationships:
/// 
/// IfcBuildingStorey.Decomposes -- referencing
/// (IfcBuilding || IfcBuildingStorey) by
/// IfcRelAggregates.RelatingObject, If it refers to another
/// instance ofÿIfcBuildingStorey, the referenced
/// IfcBuildingStorey needs to have a different and higher
/// CompositionType, i.e. COMPLEX (if the other
/// IfcBuildingStorey has ELEMENT), or ELEMENT (if the other
/// IfcBuildingStorey has PARTIAL).
/// IfcBuildingStorey.IsDecomposedBy -- referencing
/// (IfcBuildingStorey || IfcSpace) by
/// IfcRelAggregates.RelatedObjects. If it refers to another
/// instance ofÿIfcBuildingStorey, the referenced
/// IfcBuildingStorey needs to have a different and lower
/// CompositionType, i.e. ELEMENT (if the other
/// IfcBuildingStorey has COMPLEX), or PARTIAL (if the other
/// IfcBuildingStorey has ELEMENT).
/// 
/// If there are building elements and/or other elements directly
/// related to the IfcBuildingStorey (like most building
/// elements, such as walls, columns, etc.), they are associated with
/// the IfcBuildingStorey by using the objectified
/// relationship IfcRelContainedInSpatialStructure. The
/// IfcBuildingStorey references them by its inverse
/// relationship:
/// 
/// IfcBuildingStorey.ContainsElements -- referencing any
/// subtype of IfcProduct (with the exception of other spatial
/// structure element) by
/// IfcRelContainedInSpatialStructure.RelatedElements.
/// 
/// Figure 25 shows the IfcBuildingStorey as part of the
/// spatial structure. It also serves as the spatial container for
/// building and other elements.
/// NOTE Detailed requirements on mandatory element
/// containment and placement structure relationships are given in
/// view definitions and implementer agreements.
/// 
/// Figure 25 — Building storey composition
/// 
/// Elements can also be referenced in an
/// IfcBuildingStorey, for example, if they span through several
/// storeys. This is expressed by using the objectified relationship
/// IfcRelReferencedInSpatialStructure. Systems, such as
/// building service or electrical distribution systems, zonal
/// systems, or structural analysis systems, relate to
/// IfcBuildingStorey by using the objectified relationship
/// IfcRelServicesBuildings.
/// 
/// Attribute Use Definition
/// 
/// Figure 26 describes the heights and elevations of the IfcBuildingStorey.
/// 
/// elevation of storey provided by: IfcBuildingStorey.Elevation as a local height value
/// relative to IfcBuilding.ElevationOfRefHeight, it is usually the top of construction slab
/// net height of storey, also referred to as total height or system height (top of construction slab to top of construction slab above): provided by BaseQuantity with Name="GrossHeight"
/// net height of storey (top of construction slab to bottom of construction slab above): provided by BaseQuantity with Name="NetHeight"
/// 
/// Figure 26 — Building storey elevations
/// 
/// Geometry Use Definitions
/// The geometric representation of IfcBuildingStorey is
/// given by the IfcProductDefinitionShape and
/// IfcLocalPlacement, allowing multiple geometric
/// representation.
/// Local Placement
/// The local placement for IfcBuildingStorey is defined in
/// its supertype IfcProduct. It is defined by the
/// IfcLocalPlacement, which defines the local coordinate
/// system that is referenced by all geometric representations.
/// 
/// The PlacementRelTo relationship of
/// IfcLocalPlacement shall point (if relative placement is
/// used) to the IfcSpatialStructureElement of type
/// IfcBuilding, or of type IfcBuildingStorey (e.g. to
/// position a building storey relative to a building storey complex,
/// or a partial building storey to a building storey).
/// If the relative placement is not used, the absolute placement
/// is defined within the world coordinate system.
/// 
/// Geometric Representations
/// Currently, the use of a 2D 'FootPrint' representation of type
/// 'GeometricCurveSet' and a 3D 'Body' representation of type 'Brep'
/// is supported.
/// 
/// NOTE The independent geometric representation of
/// IfcBuildingStorey may not be required or allowed in
/// certain view definitions. In those cases only the contained
/// elements and spaces have an independent geometric
/// representation.
/// 
/// Foot Print Representation
/// The foot print representation of IfcBuildingStorey is
/// given by either a single 2D curve (such as IfcPolyline or
/// IfcCompositeCurve), or by a list of 2D curves (in case of
/// inner boundaries), if the building storey has an independent
/// geometric representation.
/// The representation identifier and type of this geometric
/// representation of IfcBuildingStorey is:
/// 
/// IfcShapeRepresentation.RepresentationIdentifier =
/// 'FootPrint'
/// IfcShapeRepresentation.RepresentationType =
/// 'GeometricCurveSet'
/// 
/// Body Representation
/// The body (or solid model) geometric representation (if the
/// building storey has an independent geometric representation) of
/// IfcBuildingStorey is defined using faceted B-Rep
/// capabilities (with or without voids), based on the
/// IfcFacetedBrep or on the
/// IfcFacetedBrepWithVoids.
/// The representation identifier and type of this representation
/// of IfcBuildingStorey is:
/// 
/// IfcShapeRepresentation.RepresentationIdentifier =
/// 'Body'
/// IfcShapeRepresentation.RepresentationType =
/// 'Brep'
/// 
/// Since the building storey shape is usually described by the
/// exterior building elements, an independent shape representation
/// shall only be given, if the building storey is exposed
/// independently from its constituting elements.
class IFC_PARSE_API IfcBuildingStorey : public IfcSpatialStructureElement {
public:
    /// Whether the optional attribute Elevation is defined for this IfcBuildingStorey
    bool hasElevation() const;
    /// Elevation of the base of this storey, relative to the 0,00 internal reference height of the building. The 0.00 level is given by the absolute above sea level height by the ElevationOfRefHeight attribute given at IfcBuilding.
    double Elevation() const;
    void setElevation(double v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_DOUBLE; } return IfcSpatialStructureElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcLengthMeasure; } return IfcSpatialStructureElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "Elevation"; } return IfcSpatialStructureElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcBuildingStorey (IfcEntityInstanceData* e);
    IfcBuildingStorey (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_LongName, boost::optional< IfcElementCompositionEnum::IfcElementCompositionEnum > v9_CompositionType, boost::optional< double > v10_Elevation);
    typedef IfcTemplatedEntityList< IfcBuildingStorey > list;
};
/// Definition from IAI: The IfcChimneyType
///   defines a list of commonly shared property set definitions
///   of a chimney element and an optional set of product
///   representations. It is used to define a chimney
///   specification (i.e. the specific product information, that
///   is common to all occurrences of that product type).
/// 
/// NOTE: The product representations are defined as
///   representation maps (at the level of the supertype
///   IfcTypeProduct, which gets assigned by an element
///   occurrence instance through the
///   IfcShapeRepresentation.Item[1] being an
///   IfcMappedItem.
/// 
/// A chimney type is used to define the common properties of a
///   certain type of chimney that may be applied to many
///   instances of that type to assign a specific style. Chimney
///   types may be exchanged without being already assigned to
///   occurrences.
/// 
/// The occurrences of the IfcChimneyType are
///   represented by instances of IfcChimney.
/// 
/// HISTORY New entity in Release
///   IFC2x4.
class IFC_PARSE_API IfcChimneyType : public IfcBuildingElementType {
public:
    /// Identifies the predefined types of a chimney element from which the type required may be set.
    IfcChimneyTypeEnum::IfcChimneyTypeEnum PredefinedType() const;
    void setPredefinedType(IfcChimneyTypeEnum::IfcChimneyTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcBuildingElementType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcChimneyTypeEnum; } return IfcBuildingElementType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcBuildingElementType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcChimneyType (IfcEntityInstanceData* e);
    IfcChimneyType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcChimneyTypeEnum::IfcChimneyTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcChimneyType > list;
};
/// IfcCircleHollowProfileDef
/// defines a section profile that provides the defining parameters of a
/// circular hollow section (tube) to be used by the swept area solid. Its
/// parameters and orientation relative to the
/// position coordinate system are according to the following
/// illustration.The centre of the position coordinate system is in the
/// profile's centre of the bounding box (for symmetric profiles identical
/// with the centre of gravity).
/// 
/// HISTORY  New entity in IFC2x2.
/// 
/// Figure 312 illustrates parameters of the circular hollow profile definition. The parameterized profile defines its own position coordinate system. The underlying coordinate system is defined by the swept area solid that uses the profile definition. It is the xy plane of:
/// 
/// IfcSweptAreaSolid.Position
/// 
/// By using offsets of the position location, the parameterized profile can be positioned centric (using x,y offsets = 0.), or at any position relative to the profile. Explicit coordinate offsets are used to define cardinal points (for example, upper-left bound). The parameterized profile is defined by a set of parameter attributes.
/// 
/// Figure 312 — Circle hollow profile
class IFC_PARSE_API IfcCircleHollowProfileDef : public IfcCircleProfileDef {
public:
    /// Thickness of the material, it is the difference between the outer and inner radius.
    double WallThickness() const;
    void setWallThickness(double v);
    virtual unsigned int getArgumentCount() const { return 5; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 4: return IfcUtil::Argument_DOUBLE; } return IfcCircleProfileDef::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 4: return Type::IfcPositiveLengthMeasure; } return IfcCircleProfileDef::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 4: return "WallThickness"; } return IfcCircleProfileDef::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCircleHollowProfileDef (IfcEntityInstanceData* e);
    IfcCircleHollowProfileDef (IfcProfileTypeEnum::IfcProfileTypeEnum v1_ProfileType, boost::optional< std::string > v2_ProfileName, IfcAxis2Placement2D* v3_Position, double v4_Radius, double v5_WallThickness);
    typedef IfcTemplatedEntityList< IfcCircleHollowProfileDef > list;
};

class IFC_PARSE_API IfcCivilElementType : public IfcElementType {
public:
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcElementType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcElementType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcElementType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCivilElementType (IfcEntityInstanceData* e);
    IfcCivilElementType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType);
    typedef IfcTemplatedEntityList< IfcCivilElementType > list;
};
/// Definition from IAI: The element type
/// IfcColumnType defines commonly shared information for
/// occurrences of columns. The set of shared information may
/// include:
/// 
/// common properties within shared property sets
/// common material information
/// common profile definitions
/// common shape representations
/// 
/// It is used to define a column specification, or column style
/// (i.e. the specific product information that is common to all
/// occurrences of that column type). Column types may be exchanged
/// without being already assigned to occurrences.
/// Occurrences of the IfcColumnType within building models
/// are represented by instances of IfcColumnStandardCase if
/// the IfcColumnType has a single associated
/// IfcMaterialProfileSet; otherwise they are represented by
/// instances of IfcColumn. Occurrences of the
/// IfcColumnType within structural analysis models are
/// represented by instances of IfcStructuralCurveMember, or
/// its applicable subtypes.
/// HISTORY New entity in
/// Release IFC2x Edition 2.
/// Material Use Definition
/// The material of the IfcColumnType is defined by the
/// IfcMaterialProfileSet or as fall back by
/// IfcMaterial and attached by the
/// IfcRelAssociatesMaterial.RelatingMaterial. It is
/// accessible by the inverse HasAssociations
/// relationship.
/// Note: It is illegal to assign an
/// IfcMaterial to an IfcColumnType, if there is at
/// least one occurrences of IfcColumnStandardCase for this
/// type.
/// Property Set Use Definition:
/// The shared property sets relating to the IfcColumnType
/// are defined by the IfcPropertySet and are attached by the
/// HasPropertySets attribute. The following property set
/// definitions specific to the IfcColumnType are part of this
/// IFC release:
/// NOTE There is no differentiation between
/// properties within the property set that are only assignable to
/// IfcColumnType and those that are only assignable to
/// IfcColumn. If the same property is assigned to the
/// IfcColumnType and the IfcColumn being an occurrence
/// of the IfcColumnType, then the occurrence property
/// overrides the type property.
/// 
/// Pset_ColumnCommon: common property set for all
/// column types.
/// 
/// Profile Use Definition:
/// The shared profile definition is defined by assigning an
/// IfcMaterialProfileSet (see material use definition above).
/// The IfcMaterialProfile refers to the subtype of
/// IfcProfileDef that is the common profile for all column
/// occurrence, if used. It is only applicable if the
/// IfcColumnType has only occurrences of type
/// IfcColumnStandardCase (see definition of
/// IfcColumnStandardCase for further information).
/// NOTE The attribute ProfileName of the
/// IfcProfileDef subtype, referenced in
/// IfcMaterialProfile should contain a standardized profile
/// name according to local standards. However, an additional
/// geometric representation of the profile is necessary (e.g. as
/// IfcExtrudedAreaSolid). An importing application is allowed
/// to check for the existence of the profile name: in case of
/// identifying it as a standardized name, the corresponding profile
/// geometry and possibly other cross sectional properties can be
/// read from a library. Otherwise the geometric representation and
/// possible non geometric IfcProfileProperties have to be
/// used.
/// Geometry Use Definition:
/// The IfcColumnType may define the shared geometric
/// representation for all column occurrences. The
/// RepresentationMaps attribute refers to a list of
/// IfcRepresentationMap's, that allow for multiple geometric
/// representations (e.g. with IfcShaperepresentation's having
/// an RepresentationIdentifier 'Box', 'Axis', or 'Body'). It
/// is only applicable if the IfcColumnType has only
/// occurrences of type IfcColumn (See geometric use
/// definition of IfcColumn for further information).
/// NOTE If the IfcColumnType has an
/// associated IfcMaterialProfileSet, then no shared geometric
/// representation shall be provided.
/// NOTE The product shape representations are
/// defined as RepresentationMaps (attribute of the supertype
/// IfcTypeProduct), which get assigned by an element
/// occurrence instance through the
/// IfcShapeRepresentation.Item[n] being an
/// IfcMappedItem. See IfcTypeProduct for further
/// information.
/// NOTE The values of attributes
/// RepresentationIdentifier and RepresentationType of
/// IfcShapeRepresentation are restricted in the same way as
/// those for IfcColumn and
/// IfcColumnStandardCase
class IFC_PARSE_API IfcColumnType : public IfcBuildingElementType {
public:
    /// Identifies the predefined types of a column element from which the type required may be set.
    IfcColumnTypeEnum::IfcColumnTypeEnum PredefinedType() const;
    void setPredefinedType(IfcColumnTypeEnum::IfcColumnTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcBuildingElementType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcColumnTypeEnum; } return IfcBuildingElementType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcBuildingElementType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcColumnType (IfcEntityInstanceData* e);
    IfcColumnType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcColumnTypeEnum::IfcColumnTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcColumnType > list;
};
/// The IfcComplexPropertyTemplate defines the template for
/// all complex properties, either the IfcComplexProperty's,
/// or the IfcPhysicalComplexQuantity's. The individual
/// complex property templates are interpreted according to their
/// Name attribute and and optional UsageName
/// attribute.
/// 
/// HISTORY  New entity in IFC2x4.
class IFC_PARSE_API IfcComplexPropertyTemplate : public IfcPropertyTemplate {
public:
    /// Whether the optional attribute UsageName is defined for this IfcComplexPropertyTemplate
    bool hasUsageName() const;
    std::string UsageName() const;
    void setUsageName(std::string v);
    /// Whether the optional attribute TemplateType is defined for this IfcComplexPropertyTemplate
    bool hasTemplateType() const;
    IfcComplexPropertyTemplateTypeEnum::IfcComplexPropertyTemplateTypeEnum TemplateType() const;
    void setTemplateType(IfcComplexPropertyTemplateTypeEnum::IfcComplexPropertyTemplateTypeEnum v);
    /// Whether the optional attribute HasPropertyTemplates is defined for this IfcComplexPropertyTemplate
    bool hasHasPropertyTemplates() const;
    /// Reference to a set of property templates. It should only be provided, if the PropertyType is set to COMPLEX.
    IfcTemplatedEntityList< IfcPropertyTemplate >::ptr HasPropertyTemplates() const;
    void setHasPropertyTemplates(IfcTemplatedEntityList< IfcPropertyTemplate >::ptr v);
    virtual unsigned int getArgumentCount() const { return 7; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 4: return IfcUtil::Argument_STRING; case 5: return IfcUtil::Argument_ENUMERATION; case 6: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } return IfcPropertyTemplate::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 4: return Type::IfcLabel; case 5: return Type::IfcComplexPropertyTemplateTypeEnum; case 6: return Type::IfcPropertyTemplate; } return IfcPropertyTemplate::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 4: return "UsageName"; case 5: return "TemplateType"; case 6: return "HasPropertyTemplates"; } return IfcPropertyTemplate::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcComplexPropertyTemplate (IfcEntityInstanceData* e);
    IfcComplexPropertyTemplate (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_UsageName, boost::optional< IfcComplexPropertyTemplateTypeEnum::IfcComplexPropertyTemplateTypeEnum > v6_TemplateType, boost::optional< IfcTemplatedEntityList< IfcPropertyTemplate >::ptr > v7_HasPropertyTemplates);
    typedef IfcTemplatedEntityList< IfcComplexPropertyTemplate > list;
};
/// Definition from ISO/CD 10303-42:1992: A composite
///   curve is a collection of curves joined end-to-end. The
///   individual segments of the curve are themselves defined as
///   composite curve segments. The parameterization of the
///   composite curve is an accumulation of the parametric ranges
///   of the referenced bounded curves. The first segment is
///   parameterized from 0 to
///   l1 and for i
///   ≤ 2, the
///   ith segment is
///   parameterized from:
/// 
/// where lk is the parametric
///   length (i.e., difference between maximum and minimum
///   parameter values) of the curve underlying the
///   kth segment.
/// 
/// Let T denote the parameter for the composite curve.
///   Then, if the ith segment is not a reparameterised
///   composite curve segment, T is related to the
///   parameter ti; ti0
///   ≤ ti ≤
///   ti1; for the ith segment by the
///   equation:
/// 
/// if Segments[i].SameSense =
///   TRUE;
/// 
/// or by the equation:
/// 
/// if Segments[i].SameSense =
///   FALSE;
/// 
/// If the segments[i] is of type reparameterised composite
///   curve segment,
/// 
/// where τ is defined at
///   reparameterized composite curve segment (see
///   IfcReparameterizedCompositeCurveSegment).
/// 
/// Figure 279 illustrates an example of a composite curve.
/// 
/// Figure 279 — Composite curve
/// 
/// Consider an IfcCompositeCurve having line segment and an arc segment. The line should be parameterized:
/// 
/// IfcPolyline with start= 0.,0. end= 0.,1., SameSense= TRUE, parametric length = 1.
/// 
/// The arch should be parameterized:
/// 
/// IfcTrimmedCurve with start= 180', end= 90', SameSense= FALSE, parametric length = 90.
/// 
/// Then the parameterization of the composite curve is:
/// 
/// IfcCompositeCurve with 0. ≤ T ≤ 1. (line segment) and 1. ≤ T ≤ 91. (arc segment), parametric length = 91.
/// 
/// NOTE Corresponding ISO 10303 entity: composite_curve, please refer to ISO/IS 10303-42:1994, p. 56 for the final definition of the formal standard. The WR2 is added to ensure consistent Dim at all segments.
/// 
/// HISTORY New class in IFC Release 1.0
/// 
/// Informal Propositions:
/// 
/// The SameSense attribute of each segment
///   correctly specifies the senses of the component curves.
///   When traversed in the direction indicated by
///   SameSense, the segments shall join end-to-end.
class IFC_PARSE_API IfcCompositeCurve : public IfcBoundedCurve {
public:
    /// The component bounded curves, their transitions and senses. The transition attribute for the last segment defines the transition between the end of the last segment and the start of the first; this transition attribute may take the value discontinuous, which indicates an open curve.
    IfcTemplatedEntityList< IfcCompositeCurveSegment >::ptr Segments() const;
    void setSegments(IfcTemplatedEntityList< IfcCompositeCurveSegment >::ptr v);
    /// Indication of whether the curve intersects itself or not; this is for information only.
    bool SelfIntersect() const;
    void setSelfIntersect(bool v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_BOOL; } return IfcBoundedCurve::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcCompositeCurveSegment; case 1: return Type::IfcLogical; } return IfcBoundedCurve::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Segments"; case 1: return "SelfIntersect"; } return IfcBoundedCurve::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCompositeCurve (IfcEntityInstanceData* e);
    IfcCompositeCurve (IfcTemplatedEntityList< IfcCompositeCurveSegment >::ptr v1_Segments, bool v2_SelfIntersect);
    typedef IfcTemplatedEntityList< IfcCompositeCurve > list;
};
/// Definition from ISO/CD 10303-42:1992 A composite curve on surface is a collection of segments which are curves on a surface. Each segment shall lie on the basis surface.
/// 
/// There shall be at least positional continuity between adjacent segments. The parameterization of the composite curve is obtained from the accumulation of the parametric ranges of the segments. The first segment is parameterized from 0 to l1, and, for i ≥ 2, the ith segment is parameterized from
/// 
/// where lk is the parametric length (that is, the difference between maximum and minimum parameter values) of the kth curve segment.
/// 
/// The IfcCompositeCurveOnSurface is a collection of segments, based on p-curves. i.e. a curve which lies on the basis of a surface and is defined in the parameter space of that surface. The p-curve segment is a special type of a composite curve segment and shall only be used to bound a surface.
/// 
/// NOTE Corresponding ISO 10303 entity: composite_curve_on_surface. Please refer to ISO/IS 10303-42:1994, p.64 for the final definition of the formal standard.
/// 
/// HISTORY New entity in IFC2x4.
class IFC_PARSE_API IfcCompositeCurveOnSurface : public IfcCompositeCurve {
public:
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcCompositeCurve::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcCompositeCurve::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcCompositeCurve::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCompositeCurveOnSurface (IfcEntityInstanceData* e);
    IfcCompositeCurveOnSurface (IfcTemplatedEntityList< IfcCompositeCurveSegment >::ptr v1_Segments, bool v2_SelfIntersect);
    typedef IfcTemplatedEntityList< IfcCompositeCurveOnSurface > list;
};
/// Definition from ISO/CD 10303-42:1992: A conic (IfcConic) is a planar curve which could be produced by intersecting a plane with a cone. A conic is defined in terms of its intrinsic geometric properties rather than being described in terms of other geometry. A conic class always has a placement coordinate system defined by a two or three dimensional placement. The parametric representation is defined in terms of this placement coordinate system.
/// 
/// NOTE Corresponding ISO 10303 entity: conic, only the following subtypes have been incorporated into IFC 1.0, 1.5 & 2.0: circle as IfcCircle, ellipse as IfcEllipse. The derived attribute Dim has been added at this level and was therefore demoted from the geometric_representation_item. Please refer to ISO/IS 10303-42:1994, p. 38 for the final definition of the formal standard.
/// 
/// HISTORY New class in IFC Release 1.0
class IFC_PARSE_API IfcConic : public IfcCurve {
public:
    /// The location and orientation of the conic. Further details of the interpretation of this attribute are given for the individual subtypes."
    IfcAxis2Placement* Position() const;
    void setPosition(IfcAxis2Placement* v);
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcCurve::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcAxis2Placement; } return IfcCurve::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Position"; } return IfcCurve::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcConic (IfcEntityInstanceData* e);
    IfcConic (IfcAxis2Placement* v1_Position);
    typedef IfcTemplatedEntityList< IfcConic > list;
};
/// The resource type IfcConstructionEquipmentType defines commonly shared information for occurrences of construction equipment resources. The set of shared information may include:
/// 
/// common productivities
/// common cost rates
/// common properties within shared property sets
/// 
/// It is used to define a construction equipment resource specification (the specific resource information that is common to all occurrences of that resource). Resource types may be exchanged without being already assigned to occurrences.
/// Occurrences of the IfcConstructionEquipmentResourceType are represented by instances of IfcConstructionEquipmentResource.
/// 
/// HISTORY New entity in IFC2x4.
/// 
/// Assignment use definition
/// In addition to assignments specified at the base class IfcConstructionResourceType, a construction equipment resource type may have assignments of its own using IfcRelAssignsToResource where RelatingResource refers to the IfcConstructionEquipmentResourceType and RelatedObjects contains one or more IfcTypeProduct subtypes.  Such relationship indicates the type of equipment to be used as input, which is instantiated as an occurrence assigned for each resource occurrence.  There may be multiple chains of production where such product type may have its own task and resource types assigned indicating how to assemble such equipment.
class IFC_PARSE_API IfcConstructionEquipmentResourceType : public IfcConstructionResourceType {
public:
    /// Defines types of construction equipment resources.
    IfcConstructionEquipmentResourceTypeEnum::IfcConstructionEquipmentResourceTypeEnum PredefinedType() const;
    void setPredefinedType(IfcConstructionEquipmentResourceTypeEnum::IfcConstructionEquipmentResourceTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 12; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 11: return IfcUtil::Argument_ENUMERATION; } return IfcConstructionResourceType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 11: return Type::IfcConstructionEquipmentResourceTypeEnum; } return IfcConstructionResourceType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 11: return "PredefinedType"; } return IfcConstructionResourceType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcConstructionEquipmentResourceType (IfcEntityInstanceData* e);
    IfcConstructionEquipmentResourceType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< std::string > v7_Identification, boost::optional< std::string > v8_LongDescription, boost::optional< std::string > v9_ResourceType, boost::optional< IfcTemplatedEntityList< IfcAppliedValue >::ptr > v10_BaseCosts, IfcPhysicalQuantity* v11_BaseQuantity, IfcConstructionEquipmentResourceTypeEnum::IfcConstructionEquipmentResourceTypeEnum v12_PredefinedType);
    typedef IfcTemplatedEntityList< IfcConstructionEquipmentResourceType > list;
};
/// The resource type IfcConstructionMaterialType defines commonly shared information for occurrences of construction material resources. The set of shared information may include:
/// 
/// common productivities
/// common cost rates
/// common properties within shared property sets
/// 
/// It is used to define a construction material resource specification (i.e. the specific resource information that is common to all occurrences of that resource). Resource types may be exchanged without being already assigned to occurrences.
/// Occurrences of the IfcConstructionMaterialResourceType are represented by instances of IfcConstructionMaterialResource.
/// 
/// HISTORY New entity in IFC2x4.
/// 
/// Assignment Use Definition
/// In addition to assignments specified at the base class IfcConstructionResourceType, a construction material resource type may have assignments of its own using IfcRelAssignsToResource where RelatingResource refers to the IfcConstructionMaterialResourceType and RelatedObjects contains one or more IfcTypeProduct subtypes.  Such relationship indicates material specifications to be used as input, which is instantiated as an occurrence assigned for each resource occurrence.  The IfcGeographicElementType product type may be used to hold the material representation (via IfcRelAssociatesMaterial. There may be multiple chains of production where such product type may have its own task and resource types assigned indicating how to transport or extract such material.
class IFC_PARSE_API IfcConstructionMaterialResourceType : public IfcConstructionResourceType {
public:
    /// Defines types of construction material resources.
    IfcConstructionMaterialResourceTypeEnum::IfcConstructionMaterialResourceTypeEnum PredefinedType() const;
    void setPredefinedType(IfcConstructionMaterialResourceTypeEnum::IfcConstructionMaterialResourceTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 12; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 11: return IfcUtil::Argument_ENUMERATION; } return IfcConstructionResourceType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 11: return Type::IfcConstructionMaterialResourceTypeEnum; } return IfcConstructionResourceType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 11: return "PredefinedType"; } return IfcConstructionResourceType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcConstructionMaterialResourceType (IfcEntityInstanceData* e);
    IfcConstructionMaterialResourceType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< std::string > v7_Identification, boost::optional< std::string > v8_LongDescription, boost::optional< std::string > v9_ResourceType, boost::optional< IfcTemplatedEntityList< IfcAppliedValue >::ptr > v10_BaseCosts, IfcPhysicalQuantity* v11_BaseQuantity, IfcConstructionMaterialResourceTypeEnum::IfcConstructionMaterialResourceTypeEnum v12_PredefinedType);
    typedef IfcTemplatedEntityList< IfcConstructionMaterialResourceType > list;
};
/// The resource type IfcConstructionProductType defines commonly shared information for occurrences of construction product resources. The set of shared information may include:
/// 
/// common productivities
/// common cost rates
/// common properties within shared property sets
/// 
/// It is used to define a construction product resource specification (i.e. the specific resource information that is common to all occurrences of that resource). Resource types may be exchanged without being already assigned to occurrences.
/// Occurrences of the IfcConstructionProductResourceType are represented by instances of IfcConstructionProductResource.
/// 
/// HISTORY New entity in IFC2x4.
/// 
/// Assignment use definition
/// In addition to assignments specified at the base class IfcConstructionResourceType, a construction product resource type may have assignments of its own using IfcRelAssignsToResource where RelatingResource refers to the IfcConstructionProductResourceType and RelatedObjects contains one or more IfcTypeProduct subtypes.  Such relationship indicates the type of product to be used as input, which is instantiated as an occurrence assigned for each resource occurrence.  There may be multiple chains of production where such product type may have its own task and resource types assigned.
class IFC_PARSE_API IfcConstructionProductResourceType : public IfcConstructionResourceType {
public:
    /// Defines types of construction product resources.
    IfcConstructionProductResourceTypeEnum::IfcConstructionProductResourceTypeEnum PredefinedType() const;
    void setPredefinedType(IfcConstructionProductResourceTypeEnum::IfcConstructionProductResourceTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 12; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 11: return IfcUtil::Argument_ENUMERATION; } return IfcConstructionResourceType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 11: return Type::IfcConstructionProductResourceTypeEnum; } return IfcConstructionResourceType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 11: return "PredefinedType"; } return IfcConstructionResourceType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcConstructionProductResourceType (IfcEntityInstanceData* e);
    IfcConstructionProductResourceType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< std::string > v7_Identification, boost::optional< std::string > v8_LongDescription, boost::optional< std::string > v9_ResourceType, boost::optional< IfcTemplatedEntityList< IfcAppliedValue >::ptr > v10_BaseCosts, IfcPhysicalQuantity* v11_BaseQuantity, IfcConstructionProductResourceTypeEnum::IfcConstructionProductResourceTypeEnum v12_PredefinedType);
    typedef IfcTemplatedEntityList< IfcConstructionProductResourceType > list;
};
/// IfcConstructionResource is an abstract generalization of the different resources used in
/// construction projects, mainly labor, material, equipment and product resources, plus subcontracted resources and aggregations such as a crew resource.
/// 
/// A resource represents "use of something" and does not necessarily correspond to a single item such as a person or vehicle, but
/// represents a pool of items having limited availability such as general labor or an equipment fleet. A resource can represent either a generic resource pool (not having any task assignment) or a task-specific resource allocation (having an IfcTask
/// assignment).
/// 
/// HISTORY  New entity in IFC2x2.
/// 
/// IFC2x4 CHANGE  Modified in to promote ResourceIdentifer and ResourceGroup (renamed to LongDescription) to supertype IfcResource and add attributes as described.
/// 
/// Type use definition
/// IfcConstructionResource defines the occurrence of any construction resource; common information about construction resource types is handled by IfcConstructionResourceType. The IfcConstructionResourceType (if present) may establish the common type name, common properties, common cost rates, and common productivities applied to specific task types. The IfcConstructionResourceType is attached using the IfcRelDefinesByType.RelatingType objectified relationship and is accessible by the inverse IsTypedBy attribute as shown in Figure 186.
/// The resource type may provide shared productivity and cost information, allowing tasks and resources to be selected according to lowest cost and/or shortest duration. Given an IfcProduct of a particular IfcTypeProduct type, an IfcTypeProcess may be selected from those assigned to the product type using IfcRelAssignsToProduct, and an IfcTypeResource may be selected from those assigned to the process type using IfcRelAssignsToProcess. Then IfcTask and IfcConstructionResource occurrences may be instantiated from the type definitions, applying productivitity and rate information to assigned quantities to calculate ResourceTime.ScheduleWork. Task durations can then be calculated by dividing ResourceTime.ScheduleWork by ResourceTime.ScheduleUsage.
/// 
/// Figure 186 — Construction resource type use
/// 
/// Composition use definition
/// Resources may be decomposed into allocation pools using the IfcRelNests relationship as shown in Figure 187. For example, an IfcLaborResource for "Electrician" may be decomposed into three task-specific IfcLaborResource objects: "Electrical Rough-in", "First Floor Circuits", and "Second Floor Circuits". Both relating and related sides may represent the same ResourceTime.ScheduleUsage quantity (for example, 6 workers time-shared), or the related side may break out ResourceTime.ScheduleUsage quantities for reserved use (for example, 4 workers and 2 workers). 
/// A common scenario is two nesting levels where the first-level resources have no task assignments; while second-level resources have specific task assignments indicating that the resource is subdivided into allocations for specific tasks. While the model allows unlimited nesting of resources, implementer agreements may restrict to two nesting levels with task assignments specifically at the second level.
/// 
/// Figure 187 — Construction resource composition use
/// 
/// Declaration use definition
/// A root-level resource (specifically IfcCrewResource or IfcSubContractResource) is declared within the project by IfcRelDeclares where RelatingContext refers to the single IfcProject and RelatedObjects refers to one or more IfcConstructionResource, and other root-level objects within the project.
/// 
/// Assignment use definition
/// A resource may be assigned to an actor by IfcRelAssignsToActor where RelatingActor refers to an IfcActor and RelatedObjects refers to one or more IfcConstructionResource or other objects. Such relationship indicates the actor responsible for allocating the resource such as partitioning into task-specific allocations, delegating to other actors, and/or scheduling over time. Note that this assignment does not indicate the person or organization performing the work; that is indicated by IfcRelAssignsToResource. The actor responsible for the resource may or may not be the same as any actor(s) performing work.
/// A resource may be assigned to a control by IfcRelAssignsToControl where RelatingProduct refers to an IfcControl and RelatedObjects refers to one or more IfcConstructionResource or other objects. Most commonly an IfcWorkCalendar is assigned indicating availability of the resource, where such calendar is nested within a base calendar or an IfcWorkPlan which in turn is assigned to the IfcProject.
/// A resource may be assigned to a group by IfcRelAssignsToGroup where RelatingGroup refers to an IfcGroup and RelatedObjects refers to one or more IfcConstructionResource or other objects. Most commonly an IfcAsset is assigned indicating the asset to be tracked, where such asset is nested within an IfcInventory which in turn is assigned to the IfcProject.
/// A resource may be assigned to a product by IfcRelAssignsToProduct where RelatingProduct refers to an IfcProduct and RelatedObjects refers to one or more IfcConstructionResource or other objects. Most commonly an IfcElement subtype is assigned indicating the product to be constructed, where such product is connected to a spatial
/// structure which in turn is aggregated within the IfcProject.
/// A resource may be assigned to a process by IfcRelAssignsToProcess where RelatingProcess refers to an IfcProcess and RelatedObjects refers to one or more IfcConstructionResource or other objects. Most commonly an IfcTask is assigned indicating the task to be performed by the resource, where such task is nested within a summary task which in turn is assigned to the IfcProject. 
/// A resource may have assignments of other objects using IfcRelAssignsToResource where RelatingResource refers to the IfcConstructionResource and RelatedObjects refers to one or more objects such as IfcActor or IfcProduct subtypes. This relationship indicates specific objects assigned to fulfill resource usage.
/// Figure 188 illustrates resource assignment.
/// 
/// Figure 188 — Construction resource assignment use
/// 
/// Constraint use definition
/// Constraints may be applied to a resource to indicate fixed work (such as total person-hours) or fixed usage (such as simultaneous workers). The relationship IfcRelAssociatesConstraint is used where RelatingConstraint points to an IfcMetric and RelatedObjects includes the IfcConstructionResource as shown in Figure 189. IfcRelAssociatesConstraint.Name identifies the attribute to be constrained using a period (".") to dereference; for example, "ResourceTime.ScheduleWork" refers to the ScheduleWork attribute on the IfcResourceTime entity referenced on the ResourceTime attribute. The following attributes may be constrained:
/// 
/// 'ResourceTime.ScheduleUsage': Indicate fixed usage (e.g.
/// simultaneous workers) with ConstraintGrade=HARD and
/// Benchmark=EQUALTO such that changes to
/// ResourceTime.ScheduleWork should impact the assigned
/// IfcTask.TaskTime.ScheduleDuration and vice-versa
/// 'ResourceTime.ScheduleWork': Indicate fixed work (e.g.
/// total person-hours) with ConstraintGrade=HARD and
/// Benchmark=EQUALTO such that changes to
/// ResourceTime.ScheduleUsage should impact the assigned
/// IfcTask.TaskTime.ScheduleDuration and vice-versa.
/// 
/// Figure 189 — Construction resource constraint use
/// 
/// Time series use definition
/// Time series may be applied to a resource to indicate the break-out of attribute values over time. The relationship IfcRelAssociatesTimeSeries is used where RelatingTimeSeries points to an IfcTimeSeries (either IfcRegularTimeSeries or IfcIrregularTimeSeries) and RelatedObjects includes the IfcConstructionResource as shown in Figure 190. IfcRelAssociatesTimeSeries.Name identifies the attribute to be constrained using a period (".") to dereference; for example, "ResourceTime.ScheduleWork" refers to the ScheduleWork attribute on the IfcResourceTime entity referenced on the ResourceTime attribute. Refer to attribute descriptions on IfcResourceTime for attribute-specific usage.
/// Each IfcTimeSeriesValue indicates a LIST of values, where the sequence of the value corresponds to the IfcCostValue at IfcConstructionResource.CostRatesConsumed. For example, if CostRatesConsumed has two IfcCostValue items in the LIST, "Standard" and "Overtime", then IfcTimeSeriesValue(IfcDuration('T8H0M0S'),IfcDuration('T2H0M0S')) would indicate 8 hours at Standard rate and 2 hours at Overtime rate. If the list of values at IfcTimeSeriesValue.ListValues is less than the size of CostRatesConsumed, then subsequent values are considered to be zero.
/// 
/// Figure 190 — Construction resource time series use
/// 
/// Document use definition
/// Documents may be published for work plans consisting of schedules, calendars, tasks, and resources. The relationship IfcRelAssociatesDocument may be used to preserve mappings to such document where RelatingDocument points to an IfcDocumentReference and RelatedObjects includes the IfcConstructionResource as shown in Figure 191.
/// IfcDocumentReference.ItemReference identifies the resource within the scope of the document, such as an integer or guid. The IfcDocumentReference.ReferencedDocument corresponds to the document which is uniquely identified by IfcDocumentInformation.DocumentId and/or IfcDocumentInformation.PublicationLocation. Such document mapping allows items in the document to be updated from the building information model and vice-versa.
/// 
/// Figure 191 — Construction resource document use
/// 
/// Baseline use definition
/// A resource may have any number of baselines defined using the relationship IfcRelDefinesByObject where RelatingObject is the "current" resource and RelatedObjects consists of multiple "baseline" resources, each representing a copy of the resource as it existed at an earlier point in time as shown in Figure 192. Each baseline IfcConstructionResource is identified by its nested IfcRelAssignsToControl relationship to an IfcWorkSchedule having
/// PredefinedType=BASELINE, IfcWorkSchedule.CreationDate indicating the date of the baseline, and
/// IfcWorkSchedule.Name indicating the name of the baseline.
/// 
/// Figure 192 — Construction resource baseline use
class IFC_PARSE_API IfcConstructionResource : public IfcResource {
public:
    /// Whether the optional attribute Usage is defined for this IfcConstructionResource
    bool hasUsage() const;
    IfcResourceTime* Usage() const;
    void setUsage(IfcResourceTime* v);
    /// Whether the optional attribute BaseCosts is defined for this IfcConstructionResource
    bool hasBaseCosts() const;
    IfcTemplatedEntityList< IfcAppliedValue >::ptr BaseCosts() const;
    void setBaseCosts(IfcTemplatedEntityList< IfcAppliedValue >::ptr v);
    /// Whether the optional attribute BaseQuantity is defined for this IfcConstructionResource
    bool hasBaseQuantity() const;
    IfcPhysicalQuantity* BaseQuantity() const;
    void setBaseQuantity(IfcPhysicalQuantity* v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 7: return IfcUtil::Argument_ENTITY_INSTANCE; case 8: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 9: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcResource::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 7: return Type::IfcResourceTime; case 8: return Type::IfcAppliedValue; case 9: return Type::IfcPhysicalQuantity; } return IfcResource::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 7: return "Usage"; case 8: return "BaseCosts"; case 9: return "BaseQuantity"; } return IfcResource::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcConstructionResource (IfcEntityInstanceData* e);
    IfcConstructionResource (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, boost::optional< std::string > v6_Identification, boost::optional< std::string > v7_LongDescription, IfcResourceTime* v8_Usage, boost::optional< IfcTemplatedEntityList< IfcAppliedValue >::ptr > v9_BaseCosts, IfcPhysicalQuantity* v10_BaseQuantity);
    typedef IfcTemplatedEntityList< IfcConstructionResource > list;
};
/// IfcControl is the abstract generalization of all concepts that control or constrain the utilization of products, processes, or resources in general. It can be seen as a regulation, cost schedule, request or order, or other requirements applied to a product, process or resource whose requirements and provisions must be fulfilled.
/// 
/// EXAMPLE Controls include action requests, cost schedules, project orders, work plans, and work calendars.
/// 
/// HISTORY New entity in IFC Release 1.0.
/// 
/// IFC2x4 CHANGE Attribute Identification added.
/// 
/// Relationship use definition
/// Controls have assignments from products, processes, or other objects by using the relationship object IfcRelAssignsToControl.
class IFC_PARSE_API IfcControl : public IfcObject {
public:
    /// Whether the optional attribute Identification is defined for this IfcControl
    bool hasIdentification() const;
    /// An identifying designation given to a control
    ///   It is the identifier at the occurrence level. 
    /// 
    /// IFC2x4 CHANGE  Attribute unified by promoting from various subtypes of IfcControl.
    std::string Identification() const;
    void setIdentification(std::string v);
    virtual unsigned int getArgumentCount() const { return 6; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 5: return IfcUtil::Argument_STRING; } return IfcObject::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 5: return Type::IfcIdentifier; } return IfcObject::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 5: return "Identification"; } return IfcObject::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcRelAssignsToControl >::ptr Controls() const; // INVERSE IfcRelAssignsToControl::RelatingControl
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcControl (IfcEntityInstanceData* e);
    IfcControl (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, boost::optional< std::string > v6_Identification);
    typedef IfcTemplatedEntityList< IfcControl > list;
};
/// An IfcCostItem describes a cost or financial value together with descriptive information that describes its context in a form that enables it to be used within a cost schedule. An IfcCostItem can be used to represent the cost of goods and services, the execution of works by a process, lifecycle cost and more.
/// 
/// Each instance of IfcCostItem may have a name and a description. Depending on the use for which the cost is intended, these values should be asserted on the basis of agreement. For instance, the Name attribute could be used to provide a common value that enables distinct instances to be brought together in a nesting arrangement (see below) while the Description attribute may be used to provide text used for item description in a costing schedule.
/// 
/// An IfcCostItem can link one or many IfcCostValue's representing a unit cost, total cost, or a unit cost with one or many quantities used to generate the total cost. The quantities can be given as individual quantities, or those quantities are provided as element quantities by one or many building elements.  The IfcCostValue.CostType attribute indicates the category of cost, which may be used to present the value in a particular column.  For nested cost items (having IfcRelNests relationship), IfcCostValue.CostType is significant such that IfcCostValue.AppliedValue is calculated as the sum of all nested costs having the same IfcCostValue.CostType or if set to an asterisk ('*'), then the sum of all nested costs of all cost types. An IfcCostValue may represent an original value or a value derived from formulas using IfcAppliedValueRelationship.  For example, taxes may be calculated as a percentage of a subtotal.
/// 
/// HISTORY New Entity in IFC Release 2.0.
/// IFC2x4 CHANGE Attribute PredefinedType, CostValues, and CostQuantities added.
/// 
/// Classification Use Definition
/// 
/// Instances of IfcCostItem are used for cost estimates, budgets, and other forms, where a variety of identification codes are used extensively to identify the meaning of the cost. Examples include project phase codes, CSI codes, takeoff sequence numbers, and cost accounts. The model allows for all classes that are ultimately subtypes of IfcObject to inherit the ability to have one or more instances of IfcClassificationReference to be assigned. Where identification codes are required, the generic IfcRelAssociatesClassification facility should be used.
/// 
/// Composition Use Definition
/// 
/// An IfcCostItem can nest other instances of IfcCostItem through its relationships to IfcRelNests. This can be used to enable the development of complex groups of costs as may be found in cost schedules through to pages, sections and complete cost schedules.
/// 
/// There is always a summary cost item as the root item of the tree representing the cost item nesting. Subsequent instances of IfcCostItem are assigned to the summary cost item using IfcRelNests.  The summary cost item itself is assigned to IfcCostSchedule through the IfcRelAssignsToControl relationship.
/// 
/// Figure 157 illustrates a cost item composition used for a cost schedule.  Each line item has a quantity and separate unit costs where IfcCostValue.CostType indicates the category of cost.  The summary item has a hierarchy of costs calculated according to IfcAppliedValueRelationship.ArithmeticOperator, where IfcCostValue.CostType identifies the category to be totalled.  The Tax component has IfcCostValue.CostType set to 'Material' which indicates it is the sum of all nested values of the 'Material' category ($3 x 3000 + $118 x 100 = $20800).  The Subtotal component has IfcCostValue.CostType set to an asterisk ('*') which indicates it is the sum of all nested values of all categories.
/// 
/// Figure 157 — Cost composition
/// 
/// Assignment Use Definition
/// 
/// An IfcCostItem can be calculated based on quantities from objects through its relationship to IfcRelAssignsToControl.
/// 
/// For quantity-based costing, IfcElement, IfcTask, or IfcResource occurrence subtypes may be used.  Multiple elements may be assigned of the same or different types, using IfcPhysicalQuantity entities defined at each object.  Each IfcPhysicalQuantity type must be identical (for example, all values are IfcAreaQuantity) such that they can be added together.
/// 
/// For rate-based costing (specifically for IfcCostScheduleTypeEnum.SCHEDULEOFRATES), a single IfcTypeProduct, IfcTypeProcess, or IfcTypeResource subtype may be used to reflect rates for occurrences of such types.  This enables the possibility to generate a quantity-based cost schedule for occurrences based on types with rate-based cost schedules.
/// 
/// IfcRelAssignsToControl is also used in the opposite direction to link the root IfcCostItem to an IfcCostSchedule where RelatingControl is the IfcCostSchedule. 
/// 
/// Figure 158 illustrates cost item assignment derived from building elements.  The IfcRelAssignsToControl relationship indicates building elements for which quantities are derived.  Not shown, costs may also be derived from building elements by traversing assignment relationships from the assigned IfcProduct to IfcProcess to IfcResource, where all costs ultimately originate at resources.  It is also possible for cost items to have assignments from processes or resources directly.
/// 
/// Figure 168 — Cost assignment
class IFC_PARSE_API IfcCostItem : public IfcControl {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcCostItem
    bool hasPredefinedType() const;
    /// Predefined generic type for a cost item that is specified in an enumeration. There may be a property set given specificly for the predefined types.
    /// 
    /// IFC2x4 CHANGE  The attribute has been added.
    IfcCostItemTypeEnum::IfcCostItemTypeEnum PredefinedType() const;
    void setPredefinedType(IfcCostItemTypeEnum::IfcCostItemTypeEnum v);
    /// Whether the optional attribute CostValues is defined for this IfcCostItem
    bool hasCostValues() const;
    /// Component costs for which the total cost for the cost item is calculated, and then multiplied by the total CostQuantities if provided.  
    /// 
    /// If CostQuantities is provided then values indicate unit costs, otherwise values indicate total costs.
    /// 
    /// For calculation purposes, the cost values may be directly added unless they have qualifications.  Cost values with qualifications (e.g. IfcCostValue.ApplicableDate, IfcCostValue.FixedUntilDate) should be excluded from such calculation if they do not apply.
    /// 
    /// IFC2x4 CHANGE  The attribute has been added.
    IfcTemplatedEntityList< IfcCostValue >::ptr CostValues() const;
    void setCostValues(IfcTemplatedEntityList< IfcCostValue >::ptr v);
    /// Whether the optional attribute CostQuantities is defined for this IfcCostItem
    bool hasCostQuantities() const;
    /// Component quantities of the same type for which the total quantity for the cost item is calculated as the sum.
    /// 
    /// IFC2x4 CHANGE  The attribute has been added.
    IfcTemplatedEntityList< IfcPhysicalQuantity >::ptr CostQuantities() const;
    void setCostQuantities(IfcTemplatedEntityList< IfcPhysicalQuantity >::ptr v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 6: return IfcUtil::Argument_ENUMERATION; case 7: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 8: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } return IfcControl::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 6: return Type::IfcCostItemTypeEnum; case 7: return Type::IfcCostValue; case 8: return Type::IfcPhysicalQuantity; } return IfcControl::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 6: return "PredefinedType"; case 7: return "CostValues"; case 8: return "CostQuantities"; } return IfcControl::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCostItem (IfcEntityInstanceData* e);
    IfcCostItem (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, boost::optional< std::string > v6_Identification, boost::optional< IfcCostItemTypeEnum::IfcCostItemTypeEnum > v7_PredefinedType, boost::optional< IfcTemplatedEntityList< IfcCostValue >::ptr > v8_CostValues, boost::optional< IfcTemplatedEntityList< IfcPhysicalQuantity >::ptr > v9_CostQuantities);
    typedef IfcTemplatedEntityList< IfcCostItem > list;
};
/// An IfcCostSchedule brings together instances of IfcCostItem either for the purpose of identifying purely cost information as in an estimate for constructions costs or for including cost information within another presentation form such as a work order.
/// 
/// HISTORY New Entity in IFC Release 2.0. Modified in IFC 2x2
/// IFC2x4 CHANGE Attribute 'ID' changed to Identification and promoted to supertype IfcControl, PredefinedType made optional, attributes PreparedBy, SubmittedBy, TargetUsers removed.
/// 
/// Declaration Use Definition 
/// The IfcCostSchedule may be declared within the project using the IfcRelDeclares relationship where RelatingContext refers to the single IfcProject and RelatedDefinitions contains the IfcCostSchedule.  Alternatively, if the IfcCostSchedule is aggregated within another IfcControl object, then it shall not have a direct declaration relationship (whereas the containing object may have a declaration relationship). 
/// 
/// Assignment Use Definition 
///   The IfcCostSchedule may be assigned to the following entities using relationships as indicated: 
/// 
/// IfcActor (IfcRelAssignsToActor): Persons and organizations involved in the preparation, submittal, and as target users. 
/// 
/// The IfcCostSchedule may have assignments of its own using the IfcRelAssignsToControl relationship where RelatingControl refers to the IfcCostSchedule and RelatedObjects contains one or more objects of the following types:  
/// IfcCostItem: Indicates costs published within this cost schedule, typically a single root cost item forming a hierarchy of nested cost items. 
/// 
/// Classification Use Definition 
/// Classifications may be applied using IfcRelAssociatesClassification where RelatedObjects contains the  IfcCostSchedule and RelatingClassification refers to an IfcClassification or IfcClassificationReference. 
/// 
/// IfcClassification: Classifications to be used for cost items within the cost schedule. 
/// 
/// Approval Use Definition 
/// Approvals may be associated to indicate the status of acceptance or rejection using the IfcRelAssociatesApproval relationship where RelatingApproval refers to an IfcApproval and RelatedObjects contains the IfcCostSchedule.  Approvals may be split into sub-approvals using IfcApprovalRelationship to track approval status separately for each party where RelatingApproval refers to the higher-level approval and RelatedApprovals contains one or more lower-level approvals.  The hierarchy of approvals implies sequencing such that a higher-level approval is not executed until all of its lower-level approvals have been accepted.
class IFC_PARSE_API IfcCostSchedule : public IfcControl {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcCostSchedule
    bool hasPredefinedType() const;
    /// Predefined generic type for a cost schedule that is specified in an enumeration. There may be a property set given specifically for the predefined types.
    /// 
    /// IFC2x4 CHANGE  The attribute has been made optional.
    IfcCostScheduleTypeEnum::IfcCostScheduleTypeEnum PredefinedType() const;
    void setPredefinedType(IfcCostScheduleTypeEnum::IfcCostScheduleTypeEnum v);
    /// Whether the optional attribute Status is defined for this IfcCostSchedule
    bool hasStatus() const;
    /// The current status of a cost schedule. Examples of status values that might be used for a cost schedule status include:
    /// 
    /// PLANNED 
    ///   APPROVED 
    ///   AGREED 
    ///   ISSUED 
    ///   STARTED
    std::string Status() const;
    void setStatus(std::string v);
    /// Whether the optional attribute SubmittedOn is defined for this IfcCostSchedule
    bool hasSubmittedOn() const;
    /// The date and time on which the cost schedule was submitted.
    /// 
    /// IFC2x4 CHANGE Type changed from IfcDateTimeSelect.
    std::string SubmittedOn() const;
    void setSubmittedOn(std::string v);
    /// Whether the optional attribute UpdateDate is defined for this IfcCostSchedule
    bool hasUpdateDate() const;
    /// The date and time that this cost schedule is updated; this allows tracking the schedule history.
    /// 
    /// IFC2x4 CHANGE Type changed from IfcDateTimeSelect.
    std::string UpdateDate() const;
    void setUpdateDate(std::string v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 6: return IfcUtil::Argument_ENUMERATION; case 7: return IfcUtil::Argument_STRING; case 8: return IfcUtil::Argument_STRING; case 9: return IfcUtil::Argument_STRING; } return IfcControl::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 6: return Type::IfcCostScheduleTypeEnum; case 7: return Type::IfcLabel; case 8: return Type::IfcDateTime; case 9: return Type::IfcDateTime; } return IfcControl::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 6: return "PredefinedType"; case 7: return "Status"; case 8: return "SubmittedOn"; case 9: return "UpdateDate"; } return IfcControl::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCostSchedule (IfcEntityInstanceData* e);
    IfcCostSchedule (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, boost::optional< std::string > v6_Identification, boost::optional< IfcCostScheduleTypeEnum::IfcCostScheduleTypeEnum > v7_PredefinedType, boost::optional< std::string > v8_Status, boost::optional< std::string > v9_SubmittedOn, boost::optional< std::string > v10_UpdateDate);
    typedef IfcTemplatedEntityList< IfcCostSchedule > list;
};
/// Definition from IAI: The element type
/// IfcCoveringType defines commonly shared information for
/// occurrences of coverings. The set of shared information may
/// include:
/// 
/// common properties within shared property sets
/// common material (layer set) information
/// common shape representations
/// 
/// It is used to define an covering specification or covering
/// style (i.e. the specific product information, that is common to
/// all occurrences of that product type). Covering types may be
/// exchanged without being already assigned to occurrences.
/// The occurrences of the IfcCoveringType are represented
/// by instances of IfcCovering
/// 
/// HISTORY New entity in Release
/// IFC2x Edition 2.
/// 
/// Informal proposition
/// 
/// The material assignment, if provided using the
/// IfcRelAssociatesMaterial relationship, shall not reference
/// the IfcMaterialLayerSetUsage.
/// 
/// Material Use Definition
/// The material of the IfcCoveringType is defined by the
/// IfcMaterialLayerSet or as fall back by IfcMaterial
/// and attached by the
/// IfcRelAssociatesMaterial.RelatingMaterial. It is
/// accessible by the inverse HasAssociations
/// relationship.
/// Property Set Use Definition:
/// The shared property sets relating to the
/// IfcCoveringType are defined by the IfcPropertySet
/// and are attached by the HasPropertySets attribute. The
/// following property set definitions specific to the
/// IfcCoveringType are part of this IFC release:
/// NOTE There is no differentiation between
/// properties within the property set that are only assignable to
/// IfcCoveringType and those that are only assignable to
/// IfcCovering. If the same property is assigned to the
/// IfcCoveringType and the IfcCovering being an
/// occurrence of the IfcCoveringType, then the occurrence
/// property overrides the type property.
/// 
/// Pset_CoveringCommon: common property set for all
/// covering types
/// 
/// Pset_CoveringCeiling: specific property set
/// for all occurrences of covering types with the PredefinedType:
/// CEILING
/// Pset_CoveringFlooring: specific property set
/// for all occurrences of coverings with the PredefinedType:
/// FLOORING
/// 
/// Geometry Use Definition:
/// The IfcCoveringType may define the shared geometric
/// representation for all covering occurrences. The
/// RepresentationMaps attribute refers to a list of
/// IfcRepresentationMap's, that allow for multiple geometric
/// representations (e.g. with IfcShaperepresentation's having
/// an RepresentationIdentifier 'Box', 'Surface', or 'Body').
/// (See geometric use definition of IfcCovering for further
/// information).
/// NOTE If the IfcCoveringType has an
/// associated IfcMaterialLayerSet, then no shared geometric
/// representation shall be provided.
/// NOTE The product shape representations are
/// defined as RepresentationMaps (attribute of the supertype
/// IfcTypeProduct), which get assigned by an element
/// occurrence instance through the
/// IfcShapeRepresentation.Item[n] being an
/// IfcMappedItem. See IfcTypeProduct for further
/// information.
/// NOTE The values of attributes
/// RepresentationIdentifier and RepresentationType of
/// IfcShapeRepresentation are restricted in the same way as
/// those for IfcCoveringType.
class IFC_PARSE_API IfcCoveringType : public IfcBuildingElementType {
public:
    /// Predefined types to define the particular type of the covering. There may be property set definitions available for each predefined type.
    IfcCoveringTypeEnum::IfcCoveringTypeEnum PredefinedType() const;
    void setPredefinedType(IfcCoveringTypeEnum::IfcCoveringTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcBuildingElementType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcCoveringTypeEnum; } return IfcBuildingElementType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcBuildingElementType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCoveringType (IfcEntityInstanceData* e);
    IfcCoveringType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcCoveringTypeEnum::IfcCoveringTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcCoveringType > list;
};
/// IfcCrewResource represents a collection of internal resources used in construction processes. 
/// 
/// HISTORY: New Entity in IFC Release 2.0.  Base type and documentation extended in IFC2x4
/// 
/// Identification of people and equipment of a crew is achieved through their specification at the level of the component. Therefore, knowing which persons are within a crew is achieved through identifying the persons assigned to each IfcLaborResource within the IfcCrewResource.  Similarly, identifying that a screwing machine for pipe fitting forms part of the crew is achieved by relating an appropriate instance of IfcElementComponent to the IfcConstructionEquipmentResource forming an element of the IfcCrewResource.
/// 
/// Use definitions for composition, assignment, constraints, time series, and baselines are described at the base type IfcConstructionResource.
/// 
/// Type use definition
/// IfcCrewResource defines the occurrence of any crew resource; common information about crew resource types is handled by IfcCrewResourceType.  The IfcCrewResourceType (if present) may establish the common type name, common properties, and common productivities for various task types using IfcRelAssignsToProcess.  The IfcCrewResourceType is attached using the IfcRelDefinesByType.RelatingType objectified relationship and is accessible by the inverse IsTypedBy attribute.
class IFC_PARSE_API IfcCrewResource : public IfcConstructionResource {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcCrewResource
    bool hasPredefinedType() const;
    /// Defines types of crew resources.
    /// IFC2x4 New attribute
    IfcCrewResourceTypeEnum::IfcCrewResourceTypeEnum PredefinedType() const;
    void setPredefinedType(IfcCrewResourceTypeEnum::IfcCrewResourceTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 11; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 10: return IfcUtil::Argument_ENUMERATION; } return IfcConstructionResource::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 10: return Type::IfcCrewResourceTypeEnum; } return IfcConstructionResource::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 10: return "PredefinedType"; } return IfcConstructionResource::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCrewResource (IfcEntityInstanceData* e);
    IfcCrewResource (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, boost::optional< std::string > v6_Identification, boost::optional< std::string > v7_LongDescription, IfcResourceTime* v8_Usage, boost::optional< IfcTemplatedEntityList< IfcAppliedValue >::ptr > v9_BaseCosts, IfcPhysicalQuantity* v10_BaseQuantity, boost::optional< IfcCrewResourceTypeEnum::IfcCrewResourceTypeEnum > v11_PredefinedType);
    typedef IfcTemplatedEntityList< IfcCrewResource > list;
};
/// Definition from IAI: The element type (IfcCurtainWallType)
/// defines a list of commonly shared property set definitions of a curtain
/// wall element and an optional set of product representations. It is used
/// to define a curtain wall specification (i.e. the specific product
/// information, that is common to all occurrences of that product type).
/// 
/// NOTE: The product
/// representations are defined as representation maps (at the level of the
/// supertype IfcTypeProduct, which gets assigned by an
/// element occurrence instance through the IfcShapeRepresentation.Item[1]
/// being an IfcMappedItem.
/// 
/// A curtain wall type is used to define the common properties of
/// a certain type of curtain wall that may be applied to many instances of
/// that type to assign a specific style. Curtain wall types may be
/// exchanged without being already assigned to occurrences.
/// The occurrences of the IfcCurtainWallType
/// are represented by instances of IfcCurtainWall.
/// 
/// HISTORY
/// New entity in Release IFC2x Editon 3.
class IFC_PARSE_API IfcCurtainWallType : public IfcBuildingElementType {
public:
    /// Identifies the predefined types of a curtain wall element from which the type required may be set.
    IfcCurtainWallTypeEnum::IfcCurtainWallTypeEnum PredefinedType() const;
    void setPredefinedType(IfcCurtainWallTypeEnum::IfcCurtainWallTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcBuildingElementType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcCurtainWallTypeEnum; } return IfcBuildingElementType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcBuildingElementType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCurtainWallType (IfcEntityInstanceData* e);
    IfcCurtainWallType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcCurtainWallTypeEnum::IfcCurtainWallTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcCurtainWallType > list;
};
/// Definition from ISO/CD 10303-42:1992: A cylindrical surface is a surface at a constant distance (the radius) from a straight line. A cylindrical surface is defined by its radius and its orientation and location. The data is to be interpreted as follows:
/// 
/// C = Position.Location
/// x = Position.P[1]
/// y = Position.P[2]
/// z = Position.P[3]
/// R = Radius
/// 
/// and the surface is parameterized as:
/// 
/// where the parametric range is -∞ < u,v <
/// ∞ .
/// In the above parameterization the length unit for the unit
/// vectors z is equal to that of the radius R.
/// In the placement coordinate system defined above, the surface is
/// represented by the equation S = 0, where
/// 
/// The positive direction of the normal to the surface at any
/// point on the surface is given by
/// 
/// , or as unit normal by
/// 
/// The direction of the normal is away from the axis of the cylinder.
/// 
/// The cylindrical surface is a surface unbounded in the direction of z. Bounded cylindrical surfaces are defined by using a subtype of IfcBoundedSurface with BasisSurface being a cylindrical surface.
/// 
/// NOTE A bounded cylindrical surface can be
/// defined by an IfcRectangularTrimmedSurface with
/// BasisSurface being the cylindrical surface and U1 =
/// 0°, U2 = 360° and V1 = lower bound in
/// z, V2 = upper bound in z (if the plane angle
/// measure is degree). A bounded cylindrical arc surface is provided
/// with |U1 - U2| < 360° (assuming the Usense and Vsense
/// agree to the sense of the basis surface).
/// NOTE A non-rectangular bounded cylindrical
/// surface, e.g. the surface of a round wall underneath a sloped
/// roof, cab be defined by an IfcCurveBoundedSurface with
/// IfcBoundaryCurve's, being a collection of p-curve
/// segments. A p-curve is curve which lies on the basis of a surface
/// and is defined in the parameter space of that
/// surface.
/// 
/// The inherited attributes are interpreted as
/// 
/// SELF\IfcElementarySurface.Position defines the
/// location and orientation of the cylindrical surface.
/// SELF\IfcElementarySurface.Position.Location definesd a
/// point on the axis of the cylindrical surface.
/// SELF\IfcElementarySurface.Position.P[3] defines the
/// direction of the axis of the cylindrical surface.
/// 
/// NOTE Corresponding ISO 10303 entity: plane. Please refer to ISO/IS 10303-42:1994, p.70 for the final definition of the formal standard.
/// 
/// HISTORY New class in IFC2x4.
class IFC_PARSE_API IfcCylindricalSurface : public IfcElementarySurface {
public:
    /// The radius of the cylindrical surface.
    double Radius() const;
    void setRadius(double v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 1: return IfcUtil::Argument_DOUBLE; } return IfcElementarySurface::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 1: return Type::IfcPositiveLengthMeasure; } return IfcElementarySurface::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 1: return "Radius"; } return IfcElementarySurface::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCylindricalSurface (IfcEntityInstanceData* e);
    IfcCylindricalSurface (IfcAxis2Placement3D* v1_Position, double v2_Radius);
    typedef IfcTemplatedEntityList< IfcCylindricalSurface > list;
};
/// Definition from IAI: The
/// IfcDistributionElementType defines a list of commonly
/// shared property set definitions of an element and an optional set
/// of product representations. It is used to define an element
/// specification (i.e. the specific product information, that is
/// common to all occurrences of that product type).
/// NOTEÿ The product representations are defined
/// as representation maps (at the level of the supertype
/// IfcTypeProduct, which gets assigned by an element
/// occurrence instance through the
/// IfcShapeRepresentation.Item[1] being an
/// IfcMappedItem.
/// A distribution element type is used to define the common
/// properties of a certain type of a distribution element that may
/// be applied to many instances of that feature type to assign a
/// specific style. Distribution element types (or the instantiable
/// subtypes) may be exchanged without being already assigned to
/// occurrences.
/// The occurrences of the IfcDistributionElementType are
/// represented by instances of IfcDistributionElement (or its
/// subtypes).
/// HISTORYÿ New entity in
/// Release IFC2x Edition 2.
/// IFC2x3 CHANGEÿ The entity has been made
/// non-abstract
/// IFC2x4 CHANGE The entity is marked
/// as deprecated for instantiation - will be made ABSTRACT after
/// IFC2x4.
class IFC_PARSE_API IfcDistributionElementType : public IfcElementType {
public:
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcElementType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcElementType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcElementType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcDistributionElementType (IfcEntityInstanceData* e);
    IfcDistributionElementType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType);
    typedef IfcTemplatedEntityList< IfcDistributionElementType > list;
};
/// The element type IfcDistributionFlowElementType defines a list of commonly shared property set definitions of an element and an optional set of product representations.  It is used to define an element specification (the specific product information that is common to all occurrences of that product type). 
/// 
/// Distribution flow element types (orthe instantiable subtypes) may be exchanged without being already assigned to occurrences. 
/// 
/// The occurrences of the IfcDistributionFlowElementType are represented	by instances of IfcDistributionFlowElement or its subtypes. 
/// 
/// HISTORY: New entity in IFC Release 2x2.
/// 
/// Declaration Use Definition
/// The IfcDistributionFlowElementType may be declared within a project or project library using IfcRelDeclares where RelatingContext refers to the project or library and RelatedDefinitions includes the element type.  Inclusion within IfcProject indicates the type is editable within the direct project and may be available to other referencing projects that may incorporate the type.  Inclusion within IfcProjectLibrary indicates the type is incorporated from a referenced project.  Default units and coordinate systems (used for representations, materials, and property sets) are indicated by the declaring project or library.
/// 
/// Classification Use Definition
/// The IfcDistributionFlowElementType may be classified using IfcRelAssociatesClassification where RelatingClassification refers to an IfcClassificationReference indicating a classification notation. Classifications may refer to industry standards such as MasterFormat, OmniFormat, or UniFormat.  Classifications may also refer to organization-specific, project-specific, or system-specific designations.  Classification reference identification schemes are described by IfcClassification.ReferenceTokens.
/// 
/// Document Use Definition
/// The IfcDistributionFlowElementType may be documented using IfcRelAssociatesDocument where RelatingDocument refers to an IfcDocumentReference indicating content within a document, or IfcDocumentInformation indicating an entire document. Document information may refer to arbitrary attachments such as text or multimedia, while document references may refer to items within particular formats (such as XML element IDs) where there is need to synchronize document information with model information.  Document reference identification schemes depend on the particular document format.
/// 
/// Library Use Definition
/// The IfcDistributionFlowElementType may be published to a model server using IfcRelAssociatesLibrary where RelatingLibrary refers to an IfcLibraryReference indicating the unique identification within the published project.  If the published project is IFC format, then IfcLibraryReference.Identification shall match IfcRoot.GlobalID of the published (master) project, using the same encoding as described for IfcGloballyUniqueId.  Multiple library references may be provided to indicate alternate names and descriptions for particular languages.  If the element type is declared within IfcProject, then IfcLibraryInformation.Location and IfcLibraryInformation.Version indicate the URL and version as last published.  If the element type is declared within IfcProjectLibrary, then the library information indicates the location and version of the definition as last retrieved.
/// 
/// Figure 148 illustrates a project containing a light fixture in a building, where the definition of the light fixture is obtained from an external project.
/// 
/// Figure 148 — Distribution flow element library
/// 
/// Composition Use Definition
/// The IfcDistributionFlowElementType may be decomposed into components using IfcRelAggregates where RelatingObject refers to the enclosing IfcDistributionFlowElementType and RelatedObjects contains one or more components.  For example, a cable type may be decomposed into wires.  Standard types for composition are defined at occurrences for subtypes.
/// 
/// Connection Use Definition
/// The IfcDistributionFlowElementType may be connected to other objects as follows using the indicated relationship:
/// 
/// IfcDistributionPort (IfcRelConnectsPortToElement) : Indicates port definitions on the element to be instantiated at occurrences.  Standard port names, types, and directions are defined at occurrences for subtypes.
/// 
/// Assignment Use Definition
///   The IfcDistributionFlowElementType may have assignments of its own using the IfcRelAssignsToProduct relationship where RelatingProduct refers to the IfcDistributionFlowElementType and RelatedObjects contains one or more objects of the following types: 
/// 
/// IfcTaskType: Indicates task types available to purchase, install, renovate, demolish, operate, or otherwise act upon occurrences of the element type.  Such task types may be instantiated as task occurrences assigned to occurrences of the element type.  Prices (such as for purchasing or shipping) may be established by resource types assigned to task types.
/// IfcProcedureType: Indicates procedure types available to operate occurrences of the element type.  Such procedure types may be instantiated as procedure occurrences assigned to occurrences of the element type.
/// IfcEventType: Indicates event types available to be raised by occurrences of the element, sequenced by procedures to be followed.  Such event types may be instantiated as event occurrences assigned to occurrences of the element type.
/// 
/// Material Use Definition
/// The material of the IfcDistributionFlowElementType is defined using one of the following entities:
/// 
/// IfcMaterialProfileSet: For elements having a constant cross-section, this defines the material profile which may be used to generate the 'Body' representation at occurrences (for parametric definitions not having representation), or for analysis purposes.
/// IfcMaterialConstituentSet: For elements containing multiple materials, this indicates materials at named aspects.
/// 
/// IfcMaterial: For elements comprised of a single material, this indicates the material.
/// 
/// The material is attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.
/// 
/// Representation Use Definition
/// The following shape representations are supported for subtypes of IfcDistributionFlowElementType, distinguished by IfcShapeRepresentation.RepresentationIdentifier:
/// 
/// 'Axis': Represents the 3D flow path of the item having IfcShapeRepresentation.RepresentationType of 'Curve3D' and containing a single IfcBoundedCurve subtype such as IfcPolyline, IfcTrimmedCurve, or IfcCompositeCurve.  For elements containing directional ports (IfcDistributionPort with FlowDirection of SOURCE or SINK), the direction of the curve indicates direction of flow where a SINK port is positioned at the start of the curve and a SOURCE port is positioned at the end of the curve.  This representation is most applicable to flow segment types (pipes, ducts, cables), however may be used at other elements to define a primary flow path if applicable. 
/// 
/// 'Footprint': Represents the 2D footprint outline of the item having IfcShapeRepresentation.RepresentationType of 'GeometricCurveSet' and containing a single IfcGeometricCurveSet consisting of one or more IfcCurve subtypes such as IfcPolyline, IfcTrimmedCurve, IfcCompositeCurve, or IfcCircle.
/// 
/// 'Body': Represents the 3D shape of the item having IfcShapeRepresentation.RepresentationType of 'SurfaceModel', 'SolidModel', or any solid model specializations including 'Brep', 'AdvancedBrep', 'SweptSolid', 'AdvancedSweptSolid', 'CSG', 'Clipping', or 'SectionedSpine').
/// 
/// 'Clearance': Represents the 3D clearance volume of the item having RepresentationType of 'Surface3D'.  Such clearance region indicates space that should not intersect with the 'Body' representation between element occurrences, though may intersect with the 'Clearance' representation of other element occurrences.  The particular use of clearance space may be for safety, maintenance, or other purpose.
/// 
/// 'Lighting': Represents the light emission of the item having IfcShapeRepresentation.RepresentationType of 'LightSource' and containing one or more IfcLightSource subtypes.  This representation is most applicable to lamps and light fixtures, however may be used at other elements that emit light.
/// 
/// If an element type is defined parametrically (such as a flow segment type defining common material profile but no particular length or path), then no representations shall be asserted at the type.
/// 
/// NOTE: The product representations are defined as representation maps (at the level of the supertype IfcTypeProduct, which get assigned by an element occurrence instance through the IfcShapeRepresentation.Item[1] being an IfcMappedItem.
class IFC_PARSE_API IfcDistributionFlowElementType : public IfcDistributionElementType {
public:
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcDistributionElementType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcDistributionElementType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcDistributionElementType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcDistributionFlowElementType (IfcEntityInstanceData* e);
    IfcDistributionFlowElementType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType);
    typedef IfcTemplatedEntityList< IfcDistributionFlowElementType > list;
};
/// The door lining is the frame which
/// enables the door leaf to be fixed in position. The door lining is
/// used to hang the door leaf. The parameters of the door lining
/// (IfcDoorLiningProperties) define the geometrically
/// relevant parameter of the lining.
/// 
/// NOTEÿ The IfcDoorLiningProperties
/// shall only be applied to construct the 3D shape of a door, if the
/// attribute IfcDoorStyle.ParameterTakesPrecedence is set
/// TRUE.
/// 
/// The IfcDoorLiningProperties are included in the list of
/// properties of IfcDoorStyle.HasPropertySets. More
/// information about the door lining can be included in the same
/// list of the IfcDoorStyle using another
/// IfcPropertySet for dynamic extensions.
/// 
/// HISTORY New entity in IFC Release 2.0. Has been renamed from IfcDoorLining in IFC Release 2x.
/// 
/// IFC2x4 CHANGEÿ The following attributes have been added LiningToPanelOffsetX, LiningToPanelOffsetY. The attribute ShapeAspectStyle is deprecated and shall no longer be used. Supertype changed to new IfcPreDefinedPropertySet.
/// 
/// Geometry use definitions
/// The IfcDoorLiningProperties does not hold its own
/// geometric representation. However it defines parameters which can
/// be used to create the shape of the door style (which is inserted
/// by the IfcDoor into the spatial context of the
/// project) as shown in Figure 172.
/// The parameters of the IfcDoorLiningProperties define a
/// standard door lining, including (if given) a threshold and a
/// transom. The outer boundary of the lining is determined by the
/// occurrence parameter assigned to the IfcDoor, which
/// inserts the IfcDoorStyle.
/// 
/// The lining is applied to the left,
/// right and upper side of the opening reveal. The parameters are:
/// 
/// LiningDepth, if omited, equal to
/// wall thickness - this only takes effect if a value for
/// LiningThickness is given. If both parameters are not
/// given, then there is no lining.
/// LiningThickness
/// LiningToPanelOffsetX
/// LiningToPanelOffsetY
/// 
/// NOTE Parameters added in
/// IFC2x4.
/// 
/// The lining can only cover part of
/// the opening reveal.
/// 
/// LiningOffset : given if lining edge has an offset to
/// the x axis of the local placement.
/// 
/// NOTE ÿIn addition to theÿLiningOffset,
/// the local placement of the IfcDoor can already have an
/// offset to the wall edge and thereby shift the lining along the y
/// axis. The actual position of the lining is calculated from the
/// origin of the local placement along the positive y axis with the
/// distance given by LiningOffset.
/// 
/// The lining may include a casing,
/// which covers part of the wall faces around the opening. The
/// casing covers the left, right and upper side of the lining on
/// both sides of the wall. The parameters are:
/// 
/// CasingDepth
/// CasingThickness
/// 
/// The lining may include a threshold,
/// which covers the bottom side of the opening. The parameters are:
/// 
/// ThresholdDepth
/// if omited, equal to wall thickness - this
/// only takes effect if a value for ThresholdThickness is
/// given. If both parameters are not given, then there is no
/// threshold.
/// ThresholdThickness
/// ThresholdOffset (not shown in figure): given, if the
/// threshold edge has an offset to the x axis of the local
/// placement.
/// 
/// The lining may have a transom which
/// separates the door panel from a window panel. The transom, if
/// given, is defined by:
/// 
/// TransomOffset : a parallel edge to the x axis of the
/// local placement
/// TransomThickness
/// 
/// The depth of the transom is identical to the depth of the
/// lining and not given as separate parameter.
/// 
/// Figure 172 — Door lining properties
/// 
/// NOTE LiningDepth describes the length of the lining along the reveal of the door opening. It can be given by an absolute value if the door lining has a specific depth depending on the door style. However often it is equal to the wall thickness. If the same door style is used (like the same type of single swing door), but inserted into different walls with different thicknesses, it would be necessary to create a special door style for each wall thickness. Therefore several CAD systems allow to set the value to "automatically aligned" to wall thickness. This should be exchanged by leaving the optional attribute LiningDepth unassigned. The same agreement applies to ThresholdDepth.
class IFC_PARSE_API IfcDoorLiningProperties : public IfcPreDefinedPropertySet {
public:
    /// Whether the optional attribute LiningDepth is defined for this IfcDoorLiningProperties
    bool hasLiningDepth() const;
    /// Depth of the door lining, measured perpendicular to the plane of the door lining. If omitted (and with a given value to lining thickness) it indicates an adjustable depth (i.e. a depth that adjusts to the thickness of the wall into which the occurrence of this door style is inserted).
    double LiningDepth() const;
    void setLiningDepth(double v);
    /// Whether the optional attribute LiningThickness is defined for this IfcDoorLiningProperties
    bool hasLiningThickness() const;
    /// Thickness (width in plane parallel to door leaf) of the door lining.
    double LiningThickness() const;
    void setLiningThickness(double v);
    /// Whether the optional attribute ThresholdDepth is defined for this IfcDoorLiningProperties
    bool hasThresholdDepth() const;
    /// Depth (dimension in plane perpendicular to door leaf) of the door threshold. Only given if the door lining includes a threshold. If omitted (and with a given value to threshold thickness) it indicates an adjustable depth (i.e. a depth that adjusts to the thickness of the wall into which the occurrence of this door style is inserted).
    double ThresholdDepth() const;
    void setThresholdDepth(double v);
    /// Whether the optional attribute ThresholdThickness is defined for this IfcDoorLiningProperties
    bool hasThresholdThickness() const;
    /// Thickness (width in plane parallel to door leaf) of the door threshold. Only given if the door lining includes a threshold and the parameter is known.
    double ThresholdThickness() const;
    void setThresholdThickness(double v);
    /// Whether the optional attribute TransomThickness is defined for this IfcDoorLiningProperties
    bool hasTransomThickness() const;
    /// Thickness (width in plane parallel to door leaf) of the transom (if given) which divides the door leaf from a glazing (or window) above.
    double TransomThickness() const;
    void setTransomThickness(double v);
    /// Whether the optional attribute TransomOffset is defined for this IfcDoorLiningProperties
    bool hasTransomOffset() const;
    /// Offset of the transom (if given) which divides the door leaf from a glazing (or window) above. The offset is given from the bottom of the door opening.
    double TransomOffset() const;
    void setTransomOffset(double v);
    /// Whether the optional attribute LiningOffset is defined for this IfcDoorLiningProperties
    bool hasLiningOffset() const;
    /// Offset (dimension in plane perpendicular to door leaf) of the door lining. The offset is given as distance to the x axis of the local placement.
    double LiningOffset() const;
    void setLiningOffset(double v);
    /// Whether the optional attribute ThresholdOffset is defined for this IfcDoorLiningProperties
    bool hasThresholdOffset() const;
    /// Offset (dimension in plane perpendicular to door leaf) of the door threshold. The offset is given as distance to the x axis of the local placement. Only given if the door lining includes a threshold and the parameter is known.
    double ThresholdOffset() const;
    void setThresholdOffset(double v);
    /// Whether the optional attribute CasingThickness is defined for this IfcDoorLiningProperties
    bool hasCasingThickness() const;
    /// Thickness of the casing (dimension in plane of the door leaf). If given it is applied equally to all four sides of the adjacent wall.
    double CasingThickness() const;
    void setCasingThickness(double v);
    /// Whether the optional attribute CasingDepth is defined for this IfcDoorLiningProperties
    bool hasCasingDepth() const;
    /// Depth of the casing (dimension in plane perpendicular to door leaf). If given it is applied equally to all four sides of the adjacent wall.
    double CasingDepth() const;
    void setCasingDepth(double v);
    /// Whether the optional attribute ShapeAspectStyle is defined for this IfcDoorLiningProperties
    bool hasShapeAspectStyle() const;
    /// Pointer to the shape aspect, if given. The shape aspect reflects the part of the door shape, which represents the door lining.
    /// 
    /// IFC2x4 CHANGE The attribute is deprecated and shall no longer be used, i.e. the value shall be NIL ($).
    IfcShapeAspect* ShapeAspectStyle() const;
    void setShapeAspectStyle(IfcShapeAspect* v);
    /// Whether the optional attribute LiningToPanelOffsetX is defined for this IfcDoorLiningProperties
    bool hasLiningToPanelOffsetX() const;
    /// Offset between the lining and the window panel measured along the x-axis of the local placement.
    /// 
    /// IFC2x4 CHANGE: New attribute added at the end of the entity definition.
    double LiningToPanelOffsetX() const;
    void setLiningToPanelOffsetX(double v);
    /// Whether the optional attribute LiningToPanelOffsetY is defined for this IfcDoorLiningProperties
    bool hasLiningToPanelOffsetY() const;
    /// Offset between the lining and the door panel measured along the y-axis of the local placement.
    /// 
    /// IFC2x4 CHANGE: New attribute added at the end of the entity definition.
    double LiningToPanelOffsetY() const;
    void setLiningToPanelOffsetY(double v);
    virtual unsigned int getArgumentCount() const { return 17; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 4: return IfcUtil::Argument_DOUBLE; case 5: return IfcUtil::Argument_DOUBLE; case 6: return IfcUtil::Argument_DOUBLE; case 7: return IfcUtil::Argument_DOUBLE; case 8: return IfcUtil::Argument_DOUBLE; case 9: return IfcUtil::Argument_DOUBLE; case 10: return IfcUtil::Argument_DOUBLE; case 11: return IfcUtil::Argument_DOUBLE; case 12: return IfcUtil::Argument_DOUBLE; case 13: return IfcUtil::Argument_DOUBLE; case 14: return IfcUtil::Argument_ENTITY_INSTANCE; case 15: return IfcUtil::Argument_DOUBLE; case 16: return IfcUtil::Argument_DOUBLE; } return IfcPreDefinedPropertySet::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 4: return Type::IfcPositiveLengthMeasure; case 5: return Type::IfcNonNegativeLengthMeasure; case 6: return Type::IfcPositiveLengthMeasure; case 7: return Type::IfcNonNegativeLengthMeasure; case 8: return Type::IfcNonNegativeLengthMeasure; case 9: return Type::IfcLengthMeasure; case 10: return Type::IfcLengthMeasure; case 11: return Type::IfcLengthMeasure; case 12: return Type::IfcPositiveLengthMeasure; case 13: return Type::IfcPositiveLengthMeasure; case 14: return Type::IfcShapeAspect; case 15: return Type::IfcLengthMeasure; case 16: return Type::IfcLengthMeasure; } return IfcPreDefinedPropertySet::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 4: return "LiningDepth"; case 5: return "LiningThickness"; case 6: return "ThresholdDepth"; case 7: return "ThresholdThickness"; case 8: return "TransomThickness"; case 9: return "TransomOffset"; case 10: return "LiningOffset"; case 11: return "ThresholdOffset"; case 12: return "CasingThickness"; case 13: return "CasingDepth"; case 14: return "ShapeAspectStyle"; case 15: return "LiningToPanelOffsetX"; case 16: return "LiningToPanelOffsetY"; } return IfcPreDefinedPropertySet::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcDoorLiningProperties (IfcEntityInstanceData* e);
    IfcDoorLiningProperties (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< double > v5_LiningDepth, boost::optional< double > v6_LiningThickness, boost::optional< double > v7_ThresholdDepth, boost::optional< double > v8_ThresholdThickness, boost::optional< double > v9_TransomThickness, boost::optional< double > v10_TransomOffset, boost::optional< double > v11_LiningOffset, boost::optional< double > v12_ThresholdOffset, boost::optional< double > v13_CasingThickness, boost::optional< double > v14_CasingDepth, IfcShapeAspect* v15_ShapeAspectStyle, boost::optional< double > v16_LiningToPanelOffsetX, boost::optional< double > v17_LiningToPanelOffsetY);
    typedef IfcTemplatedEntityList< IfcDoorLiningProperties > list;
};
/// A door panel is normally a door leaf that opens to allow people or
/// goods to pass. The parameters of the door panel define the
/// geometrically relevant parameter of the panel,
/// 
/// The IfcDoorPanelProperties are used to parametrically
/// describe the shape and operation of door panels. The parametric
/// definition can be added solely or additionally to the explicit
/// shape representation of the door.
/// 
/// The IfcDoorStyle can define doors consisting of more
/// then one panel. In this case, one instance of
/// IfcDoorPanelProperties has to be included for each door
/// panel. The PanelPosition attribute, in conjunction with
/// the IfcDoorStyle.OperationType attribute, determines to
/// which panel the IfcDoorPanelProperties apply.
/// The IfcDoorPanelProperties are included in the list of
/// properties , given by attribute HasPropertySets of the
/// IfcDoorStyle. More information about the door panel can be
/// included in the same list of the IfcDoorStyle using the
/// IfcPropertySet for dynamic extensions.
/// 
/// HISTORYÿ New Entity in IFC Release 2.0.
/// 
/// IFC2x4 CHANGE Supertype changed to new IfcPreDefinedPropertySet.
/// 
/// Geometry use definitions
/// 
/// The IfcDoorPanelProperties does not hold a geometric representation. However it defines parameters which can be used to create the shape of the door style (which is inserted by the IfcDoor into the spatial context of the project) as shown in Figure 173.
/// The parameters of the IfcDoorPanelProperties define a standard door panel, including (if given) a proportional width to define non-uniform double swing (or sliding, or folding) doors. The outer boundary of the panel is determined by the occurrence parameter assigned to the IfcDoor, which inserts the IfcDoorStyle. It has to take the lining parameter into account as well.
/// 
/// The depth of the panel (swinging,
/// double-acting, and sliding panels) is defined by the
/// PanelDepth parameter.
/// 
/// PanelDepth
/// 
/// For door operation types that
/// include more than one panel, the width of (at least) one panel is
/// given by a normalised ratio measure. It determines the width of
/// that panel, which is defined as a ratio of the overall width of
/// the door opening.
/// 
/// PanelWidth
/// 
/// Figure 173 — Door panel properties
class IFC_PARSE_API IfcDoorPanelProperties : public IfcPreDefinedPropertySet {
public:
    /// Whether the optional attribute PanelDepth is defined for this IfcDoorPanelProperties
    bool hasPanelDepth() const;
    /// Depth of the door panel, measured perpendicular to the plane of the door leaf.
    double PanelDepth() const;
    void setPanelDepth(double v);
    /// The PanelOperation defines the way of operation of that panel. The PanelOperation of the door panel has to correspond with the OperationType of the IfcDoorStyle by which it is referenced.
    IfcDoorPanelOperationEnum::IfcDoorPanelOperationEnum PanelOperation() const;
    void setPanelOperation(IfcDoorPanelOperationEnum::IfcDoorPanelOperationEnum v);
    /// Whether the optional attribute PanelWidth is defined for this IfcDoorPanelProperties
    bool hasPanelWidth() const;
    /// Width of this panel, given as ratio relative to the total clear opening width of the door. If omited, it defaults to 1. A value has to be provided for all doors with OperationType's at IfcDoorStyle defining a door with more then one panel.
    double PanelWidth() const;
    void setPanelWidth(double v);
    /// Position of this panel within the door. The PanelPosition of the door panel has to correspond with the OperationType of the IfcDoorStyle by which it is referenced.
    IfcDoorPanelPositionEnum::IfcDoorPanelPositionEnum PanelPosition() const;
    void setPanelPosition(IfcDoorPanelPositionEnum::IfcDoorPanelPositionEnum v);
    /// Whether the optional attribute ShapeAspectStyle is defined for this IfcDoorPanelProperties
    bool hasShapeAspectStyle() const;
    /// Pointer to the shape aspect, if given. The shape aspect reflects the part of the door shape, which represents the door panel.
    /// 
    /// IFC2x4 CHANGE The attribute is deprecated and shall no longer be used, i.e. the value shall be NIL ($).
    IfcShapeAspect* ShapeAspectStyle() const;
    void setShapeAspectStyle(IfcShapeAspect* v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 4: return IfcUtil::Argument_DOUBLE; case 5: return IfcUtil::Argument_ENUMERATION; case 6: return IfcUtil::Argument_DOUBLE; case 7: return IfcUtil::Argument_ENUMERATION; case 8: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcPreDefinedPropertySet::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 4: return Type::IfcPositiveLengthMeasure; case 5: return Type::IfcDoorPanelOperationEnum; case 6: return Type::IfcNormalisedRatioMeasure; case 7: return Type::IfcDoorPanelPositionEnum; case 8: return Type::IfcShapeAspect; } return IfcPreDefinedPropertySet::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 4: return "PanelDepth"; case 5: return "PanelOperation"; case 6: return "PanelWidth"; case 7: return "PanelPosition"; case 8: return "ShapeAspectStyle"; } return IfcPreDefinedPropertySet::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcDoorPanelProperties (IfcEntityInstanceData* e);
    IfcDoorPanelProperties (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< double > v5_PanelDepth, IfcDoorPanelOperationEnum::IfcDoorPanelOperationEnum v6_PanelOperation, boost::optional< double > v7_PanelWidth, IfcDoorPanelPositionEnum::IfcDoorPanelPositionEnum v8_PanelPosition, IfcShapeAspect* v9_ShapeAspectStyle);
    typedef IfcTemplatedEntityList< IfcDoorPanelProperties > list;
};
/// Definition from IAI: The element type
/// IfcDoorType defines commonly shared information
/// for occurrences of doors. The set of shared information may
/// include:
/// 
/// common properties within shared property sets
/// common material information
/// common operation type definitions
/// common shape representations
/// 
/// A door type defines the particular parameter of the lining and
/// one (or several) panels through the
/// IfcDoorLiningProperties and the
/// IfcDoorPanelProperties as predefined property sets
/// applicable to doors only.
/// It is used to define a door specification, or door style (i.e.
/// the specific product information that is common to all
/// occurrences of that door type). Door types may be exchanged
/// without being already assigned to occurrences.
/// NOTE The product representations are defined
/// as representation maps (at the level of the supertype
/// IfcTypeProduct, which gets assigned by an element
/// occurrence instance through the
/// IfcShapeRepresentation.Item[1] being an
/// IfcMappedItem.
/// Occurrences of the IfcDoorType within building models
/// are represented by instances of IfcDoor or
/// IfcDoorStandardCase.
/// HISTORY New entity in
/// IFC2x4 .
/// NOTE The entity IfcDoorType
/// replaces the previous definition IfcDoorStyle (which is
/// deprecated in IFC2x4).
/// Operation type use definition
/// The IfcDoorTypeOperationEnum defines the general layout
/// of the door type and its symbolic presentation. Depending on the
/// enumerator, the appropriate instances of
/// IfcDoorLiningProperties and IfcDoorPanelProperties
/// are attached in the list of HasPropertySets. The
/// IfcDoorTypeOperationEnum mainly determines the hinge side
/// (left hung, or right hung), the operation (swinging, sliding,
/// folding, etc.) and the number of panels.
/// Note ÿThere are different definitions in
/// various countries on what a left opening or left hung or left
/// swing door is (same for right). Therefore the IFC definition may
/// derivate from the local standard and may need to be mapped
/// appropriately.
/// See geometry use definitions at
/// IfcDoorTypeOperationEnum for the correct usage of opening
/// symbols for different operation types.
/// Material Use Definition
/// The material of the IfcDoorType is defined by the
/// IfcMaterialConstituentSet or as fall back by
/// IfcMaterial and attached by the
/// IfcRelAssociatesMaterial.RelatingMaterial. It is
/// accessible by the inverse HasAssociations
/// relationship.
/// The following keywords for
/// IfcMaterialConstituentSet.MaterialConstituents[n].Name
/// shall be used:
/// 
/// 'Lining' - to indicate that the material constituent applies
/// to to the door lining
/// 'Framing' - to indicate that the material constituent applies
/// to to the door framing, if not provided, the 'Lining' material
/// information applied to frams as well
/// 'Glazing' - to indicate that the material constituent applies
/// to to the glazing as well
/// 
/// If the fall back single IfcMaterial is referenced, it
/// applies to the lining and framing of the door.
/// Property Set Use Definition:
/// The shared property sets relating to the IfcDoorType
/// are defined by the IfcPropertySet and are attached by the
/// HasPropertySets attribute. The following property set
/// definitions specific to the IfcDoorType are part of this
/// IFC release:
/// NOTE There is no differentiation between
/// properties within the property set that are only assignable to
/// IfcDoorType and those that are only assignable to
/// IfcDoor. If the same property is assigned to the
/// IfcDoorType and the IfcDoor being an occurrence of
/// the IfcDoorType, then the occurrence property overrides
/// the type property.
/// 
/// Pset_WallCommon: common property set for all
/// door types.
/// Pset_DoorWindowGlazingType: specific property
/// set for the glazing properties of the door type glazing
/// Pset_DoorWindowShadingType: specific property
/// set for the shading properties of the door type shading
/// 
/// Two subtypes of IfcPreDefinedPropertySet are applicable
/// to IfcDoorType:
/// 
/// IfcDoorLiningProperties - a single instance to define
/// the shape parameters of the door lining
/// IfcDoorPanelProperties - one or several instances to
/// define the shape parameters of the door panel(s)
/// 
/// Geometry Use Definitions:
/// The IfcDoorType may define the common shape of door
/// occurrences. The common shape can be defined by
/// 
/// applying shape parameters defined within the associated
/// IfcDoorLiningProperties and IfcDoorPanelProperties
/// applied to the 'Profile' geometric representation. It is only
/// applicable if the IfcDoorType has only occurrences of type
/// IfcDoorStandardCase (See geometric use definition of
/// IfcDoorStandardCase for further information).
/// applying the RepresentationMaps attribute to refer to
/// a list of IfcRepresentationMap's, that allow for multiple
/// geometric representations (e.g. with
/// IfcShapeRepresentation's having an
/// RepresentationIdentifier 'Box', 'Profile', 'FootPrint', or
/// 'Body')
/// NOTE The product shape representations are
/// defined as RepresentationMaps (attribute of the supertype
/// IfcTypeProduct), which get assigned by an element
/// occurrence instance through the
/// IfcShapeRepresentation.Item[n] being an
/// IfcMappedItem. See IfcTypeProduct for further
/// information.
/// NOTE The values of attributes
/// RepresentationIdentifier and RepresentationType of
/// IfcShapeRepresentation are restricted in the same way as
/// those for IfcDoor and
/// IfcDoorStandardCase
class IFC_PARSE_API IfcDoorType : public IfcBuildingElementType {
public:
    /// Identifies the predefined types of a door element from which the type required may be set.
    IfcDoorTypeEnum::IfcDoorTypeEnum PredefinedType() const;
    void setPredefinedType(IfcDoorTypeEnum::IfcDoorTypeEnum v);
    /// Type defining the general layout and operation of the door type in terms of the partitioning of panels and panel operations.
    IfcDoorTypeOperationEnum::IfcDoorTypeOperationEnum OperationType() const;
    void setOperationType(IfcDoorTypeOperationEnum::IfcDoorTypeOperationEnum v);
    /// Whether the optional attribute ParameterTakesPrecedence is defined for this IfcDoorType
    bool hasParameterTakesPrecedence() const;
    bool ParameterTakesPrecedence() const;
    void setParameterTakesPrecedence(bool v);
    /// Whether the optional attribute UserDefinedOperationType is defined for this IfcDoorType
    bool hasUserDefinedOperationType() const;
    std::string UserDefinedOperationType() const;
    void setUserDefinedOperationType(std::string v);
    virtual unsigned int getArgumentCount() const { return 13; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; case 10: return IfcUtil::Argument_ENUMERATION; case 11: return IfcUtil::Argument_BOOL; case 12: return IfcUtil::Argument_STRING; } return IfcBuildingElementType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcDoorTypeEnum; case 10: return Type::IfcDoorTypeOperationEnum; case 11: return Type::IfcBoolean; case 12: return Type::IfcLabel; } return IfcBuildingElementType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; case 10: return "OperationType"; case 11: return "ParameterTakesPrecedence"; case 12: return "UserDefinedOperationType"; } return IfcBuildingElementType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcDoorType (IfcEntityInstanceData* e);
    IfcDoorType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcDoorTypeEnum::IfcDoorTypeEnum v10_PredefinedType, IfcDoorTypeOperationEnum::IfcDoorTypeOperationEnum v11_OperationType, boost::optional< bool > v12_ParameterTakesPrecedence, boost::optional< std::string > v13_UserDefinedOperationType);
    typedef IfcTemplatedEntityList< IfcDoorType > list;
};
/// The draughting pre defined colour is a pre defined colour for the purpose to identify a colour by name. Allowable names are:
/// 
/// 'black',
/// 'red',
/// 'green',
/// 'blue',
/// 'yellow',
/// 'magenta',
/// 'cyan',
/// 'white',
/// 'by layer'
/// 
/// NOTE ÿThe IfcDraughtingPreDefinedColour is an entity that had been adopted from ISO 10303-202, Industrial automation systems and integration—Product data representation and exchange, Part 202: Application protocol: Associative draughting.
/// 
/// The following table states the RGB values associated with the names given by the IfcDraughtingPreDefinedColour.
/// 
/// Colour name
/// Red
/// Green
/// Blue
/// 
/// black
/// 0
/// 0
/// 0
/// 
/// red
/// 1.0
/// 0
/// 0
/// 
/// green
/// 0
/// 1.0
/// 0
/// 
/// blue
/// 0
/// 0
/// 1.0
/// 
/// yellow
/// 1.0
/// 1.0
/// 0
/// 
/// magenta
/// 1.0
/// 0
/// 1.0
/// 
/// cyan
/// 0
/// 1.0
/// 1.0
/// 
/// white
/// 1.0
/// 1.0
/// 1.0
/// 
/// by layer
/// colour values obtained from
/// IfcPresentationLayerWithStyle.
/// 
/// NOTE ÿCorresponding ISO 10303 name: draughting_pre_defined_colour. Please refer to ISO/IS 10303-202:1994 page 194 for the final definition of the formal standard.
/// 
/// HISTORY ÿNew entity in IFC2x2.
/// 
/// Informal proposition
/// 
/// The value 'by layer' shall only be inserted, if the geometric representation item using the colour definition has an association to IfcPresentationLayerWithStyle, and if that instance of IfcPresentationLayerWithStyle has a valid colour definition for IfcCurveStyle, IfcSymbolStyle, or IfcSurfaceStyle (depending on what is applicable).
class IFC_PARSE_API IfcDraughtingPreDefinedColour : public IfcPreDefinedColour {
public:
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcPreDefinedColour::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcPreDefinedColour::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcPreDefinedColour::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcDraughtingPreDefinedColour (IfcEntityInstanceData* e);
    IfcDraughtingPreDefinedColour (std::string v1_Name);
    typedef IfcTemplatedEntityList< IfcDraughtingPreDefinedColour > list;
};
/// The draughting predefined curve font type defines a selection of widely used curve fonts for draughting purposes by name. 
/// 
/// NOTE  The IfcDraughtingPreDefinedCurveFont is an entity that had been adopted from ISO 10303, Industrial automation systems and integration&#151;Product data representation and exchange, Part 46 Technical Corrigendum 2: Integrated generic resources: Visual presentation.
/// 
/// Figure 291 (from ISO 10303-46 TC2) illustrates predefined curve fonts.
/// 
/// Figure 291 — Draughting predefined curve font
/// 
/// NOTE  If the IfcDraughtingPreDefinedCurveFont is used within an IfcCurveStyleFontAndScaling then the segment and space lengths that are given in the table are as such for the scale factor 1.0
/// 
/// NOTE  Corresponding ISO 10303 name: pre_defined_curve_font. Please refer to ISO/IS 10303-46:1994 TC2, page 12 for the final definition of the formal standard.
/// 
/// HISTORY  New entity in IFC2x2.
class IFC_PARSE_API IfcDraughtingPreDefinedCurveFont : public IfcPreDefinedCurveFont {
public:
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcPreDefinedCurveFont::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcPreDefinedCurveFont::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcPreDefinedCurveFont::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcDraughtingPreDefinedCurveFont (IfcEntityInstanceData* e);
    IfcDraughtingPreDefinedCurveFont (std::string v1_Name);
    typedef IfcTemplatedEntityList< IfcDraughtingPreDefinedCurveFont > list;
};
/// Definition from IAI: Generalization of all components
/// that make up an AEC product. Those elements can be logically
/// contained by a spatial structure element that constitutes a
/// certain level within a project structure hierarchy (e.g., site,
/// building, storey or space). This is done by using the
/// IfcRelContainedInSpatialStructure relationship.
/// Elements are physically existent objects, although they might
/// be void elements, such as holes. Elements either remain
/// permanently in the AEC product, or only temporarily, as formwork
/// does. Elements can be either assembled on site or
/// pre-manufactured and built in on site.
/// EXAMPLEs of elements in a building
/// construction context are walls, floors, windows and
/// recesses.
/// An element can have material and quantity information assigned
/// through the IfcRelAssociatesMaterial and
/// IfcRelDefinesByProperties relationship.
/// In addition an element can be declared to be a specific
/// occurrence of an element type (and thereby be defined by the
/// element type properties) using the IfcRelDefinesByType
/// relationship.
/// An element can also be defined as an element assembly that is
/// a group of semantically and topologically related elements that
/// form a higher level part of the AEC product. Those element
/// assemblies are defined by virtue of the IfcRelAggregates
/// relationship.
/// EXAMPLEs for element assembly are
/// complete Roof Structures, made by several Roof Areas, or a Stair,
/// composed by Flights and Landings.
/// Elements that performs the same function may be grouped by an
/// "Element Group By Function". It is realized by an instance of
/// IfcGroup with the ObjectType =
/// 'ElementGroupByFunction".
/// HISTORY New entity in
/// IFC Release 1.0
/// Property Set Use Definition:
/// The property sets relating to the IfcElement are
/// defined by the IfcPropertySet and attached by the
/// IfcRelDefinesByProperties relationship. It is accessible
/// by the inverse IsDefinedBy relationship.
/// Quantity Use Definition:
/// The quantities relating to the IfcElement are defined
/// by the IfcElementQuantity and attached by the
/// IfcRelDefinesByProperties. A detailed specification for
/// individual quantities is introduced at the level of subtypes of
/// IfcElement.
/// Geometry Use Definitions
/// The geometric representation of any IfcElement is given
/// by the IfcProductDefinitionShape and
/// IfcLocalPlacement allowing multiple geometric
/// representations. A detailed specification for the local placement
/// and shape representaion is introduced at the level of subtypes of
/// IfcElement.
class IFC_PARSE_API IfcElement : public IfcProduct {
public:
    /// Whether the optional attribute Tag is defined for this IfcElement
    bool hasTag() const;
    /// The tag (or label) identifier at the particular instance of a product, e.g. the serial number, or the position number. It is the identifier at the occurrence level.
    std::string Tag() const;
    void setTag(std::string v);
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 7: return IfcUtil::Argument_STRING; } return IfcProduct::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 7: return Type::IfcIdentifier; } return IfcProduct::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 7: return "Tag"; } return IfcProduct::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcRelFillsElement >::ptr FillsVoids() const; // INVERSE IfcRelFillsElement::RelatedBuildingElement
    IfcTemplatedEntityList< IfcRelConnectsElements >::ptr ConnectedTo() const; // INVERSE IfcRelConnectsElements::RelatingElement
    IfcTemplatedEntityList< IfcRelInterferesElements >::ptr IsInterferedByElements() const; // INVERSE IfcRelInterferesElements::RelatedElement
    IfcTemplatedEntityList< IfcRelInterferesElements >::ptr InterferesElements() const; // INVERSE IfcRelInterferesElements::RelatingElement
    IfcTemplatedEntityList< IfcRelProjectsElement >::ptr HasProjections() const; // INVERSE IfcRelProjectsElement::RelatingElement
    IfcTemplatedEntityList< IfcRelReferencedInSpatialStructure >::ptr ReferencedInStructures() const; // INVERSE IfcRelReferencedInSpatialStructure::RelatedElements
    IfcTemplatedEntityList< IfcRelVoidsElement >::ptr HasOpenings() const; // INVERSE IfcRelVoidsElement::RelatingBuildingElement
    IfcTemplatedEntityList< IfcRelConnectsWithRealizingElements >::ptr IsConnectionRealization() const; // INVERSE IfcRelConnectsWithRealizingElements::RealizingElements
    IfcTemplatedEntityList< IfcRelSpaceBoundary >::ptr ProvidesBoundaries() const; // INVERSE IfcRelSpaceBoundary::RelatedBuildingElement
    IfcTemplatedEntityList< IfcRelConnectsElements >::ptr ConnectedFrom() const; // INVERSE IfcRelConnectsElements::RelatedElement
    IfcTemplatedEntityList< IfcRelContainedInSpatialStructure >::ptr ContainedInStructure() const; // INVERSE IfcRelContainedInSpatialStructure::RelatedElements
    IfcTemplatedEntityList< IfcRelCoversBldgElements >::ptr HasCoverings() const; // INVERSE IfcRelCoversBldgElements::RelatingBuildingElement
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcElement (IfcEntityInstanceData* e);
    IfcElement (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag);
    typedef IfcTemplatedEntityList< IfcElement > list;
};
/// The IfcElementAssembly
/// represents complex element assemblies aggregated from several
/// elements, such as discrete elements, building elements, or other
/// elements.
/// EXAMPLE Steel construction assemblies, such as
/// trusses and different kinds of frames, can be represented by the
/// IfcElementAssembly entity. Other examples include slab
/// fields aggregated from a number of precast concrete slabs or
/// reinforcement units made from several reinforcement bars. Also
/// bathroom units, staircase sections and other premanufactured or
/// precast elements are examples of the general
/// IfcElementAssembly entity
/// NOTE The IfcElementAssembly is a
/// general purpose entity that is required to be decomposed. Also
/// other subtypes of IfcElement can be decomposed, with some
/// dedicated entities such as IfcWallElementedCase and
/// IfcSlabElementedCase.
/// The assembly structure can be nested, i.e. an
/// IfcElementAssembly could be an aggregated part within
/// another IfcElementAssembly.
/// NOTE View definitions and/or implementer
/// agreements may restrict the number of allowed levels of
/// nesting.
/// HISTORY New Entity for
/// Release IFC2x Edition 2.
/// 
/// Containment Use Definition
/// The IfcElementAssembly should have (and in most
/// implementation scenarios it is mandatory) a relationship for its
/// hierachical containment in the spatial structure of the
/// project.
/// 
/// The IfcElementAssembly is places within the project
/// spatial hierarchy using the objectified relationship
/// IfcRelContainedInSpatialStructure, refering to it by its
/// inverse attribute SELF\IfcElement.ContainedInStructure.
/// Subtypes of IfcSpatialStructureElement are valid spatial
/// containers, with IfcBuildingStorey being the default
/// container.
/// 
/// The IfcElementAssembly shall represent an aggregate,
/// i.e. it should have other elements, being subtypes of
/// IfcElement, as contained (sub)parts.
/// 
/// The IfcElementAssembly is an aggregate i.e. being
/// composed by other elements and acting as an assembly using the
/// objectified relationship IfcRelAggregates, refering to it
/// by its inverse attribute
/// SELF\IfcObjectDefinition.IsDecomposedBy. Components of an
/// assembly are described by instances of subtypes of
/// IfcElement.
/// In this case, the containedÿsubtypes of IfcElement
/// shall not be additionally contained in the project spatial
/// hierarchy, i.e. the inverse attribute
/// SELF\IfcElement.ContainedInStructure of those
/// IfcElement's shall be NIL.
/// 
/// Figure 27 illustrates spatial containment and element aggregation relationships.
/// 
/// Figure 27 — Element assembly containment
/// 
/// Geometry Use Definitions
/// The geometric representation of IfcElementAssembly is
/// given by the IfcProductDefinitionShape, allowing multiple
/// geometric representations.
/// Local Placement
/// The local placement for IfcElementAssembly is defined
/// in its supertype IfcProduct. It is defined by the
/// IfcLocalPlacement, which defines the local coordinate
/// system that is referenced by all geometric representations.
/// 
/// The PlacementRelTo relationship of
/// IfcLocalPlacement shall point (if given) to the local
/// placement of the same IfcSpatialStructureElement that is
/// used in the ContainedInStructure inverse attribute or to a
/// referenced spatial structure element at a higher level.
/// If the relative placement is not used, the absolute placement
/// is defined within the world coordinate system.
/// 
/// Geometric Representations
/// The geometry of an IfcElementAssembly is generally
/// formed from its components, in which case it does not need to
/// have an explicit geometric representation. In some cases it may
/// be useful to also expose an own explicit representation of the
/// aggregate.
/// NOTEÿ View definitions or implementer
/// agreements may further constrain the applicability of certain
/// shape representations at the IfcElementAssembly in respect
/// of the shape representations of its parts.
/// Informal proposition
/// 
/// The IfcElementAssembly shall have an aggregation
/// relationship to the contained parts, i.e. the (INV)
/// IsDecomposedBy relationship shall be utilzed.
class IFC_PARSE_API IfcElementAssembly : public IfcElement {
public:
    /// Whether the optional attribute AssemblyPlace is defined for this IfcElementAssembly
    bool hasAssemblyPlace() const;
    /// A designation of where the assembly is intended to take place defined by an Enum.
    IfcAssemblyPlaceEnum::IfcAssemblyPlaceEnum AssemblyPlace() const;
    void setAssemblyPlace(IfcAssemblyPlaceEnum::IfcAssemblyPlaceEnum v);
    /// Whether the optional attribute PredefinedType is defined for this IfcElementAssembly
    bool hasPredefinedType() const;
    /// Predefined generic types for a element assembly that are specified in an enumeration. There might be property sets defined specifically for each predefined type.
    /// 
    /// IFC2x4 CHANGE  The attribute has been changed to be optional.
    IfcElementAssemblyTypeEnum::IfcElementAssemblyTypeEnum PredefinedType() const;
    void setPredefinedType(IfcElementAssemblyTypeEnum::IfcElementAssemblyTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; case 9: return IfcUtil::Argument_ENUMERATION; } return IfcElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcAssemblyPlaceEnum; case 9: return Type::IfcElementAssemblyTypeEnum; } return IfcElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "AssemblyPlace"; case 9: return "PredefinedType"; } return IfcElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcElementAssembly (IfcEntityInstanceData* e);
    IfcElementAssembly (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcAssemblyPlaceEnum::IfcAssemblyPlaceEnum > v9_AssemblyPlace, boost::optional< IfcElementAssemblyTypeEnum::IfcElementAssemblyTypeEnum > v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcElementAssembly > list;
};
/// Definition from IAI: The IfcElementAssemblyType
/// defines a list of commonly shared property set definitions of an
/// element and an optional set of product representations. It is
/// used to define an element specification (i.e. the specific
/// product information, that is common to all occurrences of that
/// product type).
/// NOTEÿ The product representations are defined
/// as representation maps (at the level of the supertype
/// IfcTypeProduct, which gets assigned by an element
/// occurrence instance through the
/// IfcShapeRepresentation.Item[1] being an
/// IfcMappedItem.
/// An element assembly type is used to define the common
/// properties of a certain type of an element assembly that may be
/// applied to many instances of that type to assign a specific
/// style. An element assembly types (or the instantiable subtypes)
/// may be exchanged without being already assigned to
/// occurrences.
/// The occurrences of the IfcElementAssemblyType are
/// represented by instances of IfcElementAssembly.
/// HISTORYÿ New entity in
/// Release IFC2x Edition 4.
class IFC_PARSE_API IfcElementAssemblyType : public IfcElementType {
public:
    /// Predefined types to define the particular type of the transport element. There may be property set definitions available for each predefined type.
    IfcElementAssemblyTypeEnum::IfcElementAssemblyTypeEnum PredefinedType() const;
    void setPredefinedType(IfcElementAssemblyTypeEnum::IfcElementAssemblyTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcElementType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcElementAssemblyTypeEnum; } return IfcElementType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcElementType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcElementAssemblyType (IfcEntityInstanceData* e);
    IfcElementAssemblyType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcElementAssemblyTypeEnum::IfcElementAssemblyTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcElementAssemblyType > list;
};
/// An element component is a representation for minor items included in, added to or connecting to or between
///   elements, which usually are not of interest from the overall building structure viewpoint.
///   However, these small parts may have vital and load carrying functions within the construction.
///   These items do not provide any actual space boundaries.
///   Typical examples of IfcElementComponents include different kinds of fasteners and various accessories.
/// 
/// HISTORY New entity in IFC Release 2x2
/// 
/// It is often desirable to model a number of same-shaped element components by means of a single
/// occurrence object, e.g. several bolts within a connection or a row of reinforcement elements.
/// In this IFC release, this is possible by means of multiple mapped representation as documented below.
/// 
/// To express the multiplicity of element components also on a higher semantic level,
/// an IfcElementQuantity should be provided via IfcRelDefinesByProperties.
/// The quantity should contain an IfcQuantityCount named 'Count' with the number of components.
/// 
/// Geometry Use Definition
/// 
/// The geometric representation of IfcElementComponent is given by the IfcProductDefinitionShape,
///   allowing multiple geometric representations. Included are:
/// 
/// Local Placement
///   The local placement for IfcElementComponent is defined in its supertype IfcProduct.
///   It is defined by the IfcLocalPlacement, which defines the local coordinate system that is
///   referenced by all geometric representations. 
/// 
/// The PlacementRelTo relationship of IfcLocalPlacement shall point (if given) to
///   the local placement of the same IfcElement or IfcElementAssembly, which is
///   used in the Decomposes inverse attribute, i.e. the local placement is defined relative to
///   the local placement of the element or element assembly in which the component is contained. 
///   If the relative placement is not used, the absolute placement is defined within the world coordinate system. 
/// 
/// Surface Model Representation
/// 
/// Any IfcElementComponent (if no further constraints are defined at the level of its subtypes)
///   may be represented as a single or multiple surface models, based on either shell or face based models.
///   The following attribute values for the IfcShapeRepresentation holding this geometric representation
///   shall be used:
/// 
/// RepresentationIdentifier : 'Body'
///   RepresentationType : 'SurfaceModel'
/// 
/// Brep Representation
/// 
/// Any IfcElementComponent (if no further constraints are defined at the level of its subtypes)
///   may be represented as a single or multiple Boundary Representation elements (which are restricted to faceted
///   Brep with or without voids). The Brep representation allows for the representation of complex element shape.
///   The following attribute values for the IfcShapeRepresentation holding this geometric representation
///   shall be used:
/// 
/// RepresentationIdentifier : 'Body'
///   RepresentationType : 'Brep'
/// 
/// Mapped Representation
/// 
/// The mapped item, IfcMappedItem, should be used if appropriate as it allows for reusing the geometry
///   definition of a type at occurrences of the same type.
///   The following attribute values for the IfcShapeRepresentation holding this geometric representation
///   shall be used:
/// 
/// RepresentationIdentifier : 'Body'
///   RepresentationType : 'MappedRepresentation'
/// 
/// Multiple Mapped Representation
/// 
/// A single instance of a subtype of IfcElementComponent can stand for several
/// actual element components at once.  In this case, the IfcShapeRepresentation
/// contains as many mapped items as there are element components combined within this
/// occurrence object:
/// 
/// Figure 151 illustrates multiple components modeled as a single occurrence object (here: IfcFastener)
/// 
/// Figure 151 — Element component mapped representation
/// 
/// Representation identifier and type are the same as in single mapped representation.
/// The number of mapped items in the representation corresponds with the count of
/// element components in the IfcElementQuantity.
class IFC_PARSE_API IfcElementComponent : public IfcElement {
public:
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcElementComponent (IfcEntityInstanceData* e);
    IfcElementComponent (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag);
    typedef IfcTemplatedEntityList< IfcElementComponent > list;
};
/// Definition from IAI:
///   The element type (IfcElementComponentType) represents the supertype for element 
///   types which define lists of commonly shared property set definitions of various small parts and       accessories and an optional set of product
///   representations. It is used to define a supporting element mainly within 
///   structural and building services domains (i.e. the specific type information  
///   common to all occurrences of that type). 
/// 
/// HISTORY New entity in IFC
///   Release 2x2
class IFC_PARSE_API IfcElementComponentType : public IfcElementType {
public:
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcElementType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcElementType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcElementType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcElementComponentType (IfcEntityInstanceData* e);
    IfcElementComponentType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType);
    typedef IfcTemplatedEntityList< IfcElementComponentType > list;
};
/// Definition from ISO/CD 10303-42:1992: An ellipse (IfcEllipse) is a conic section defined by the lengths of the semi-major and semi-minor diameters and the position (center or mid point of the line joining the foci) and orientation of the curve. Interpretation of the data shall be as follows:
/// 
/// C  = SELF\IfcConic.Position.Location  
///   x  = SELF\IfcConic.Position.P[1]  
///   y  = SELF\IfcConic.Position.P[2]  
///   z  = SELF\IfcConic.Position.P[3]  
///   R1 = SemiAxis1 
///   R2 = SemiAxis2 
///   and the ellipse is parameterized as:  
/// 
/// The parameterization range is 0 £
///   u £ 2p (or 0
///   £ u £
///   360 degree). In the placement coordinate system defined above, the ellipse is
///   the equation C = 0, where 
/// 
/// The positive sense of the ellipse at any point is in the tangent direction, T, to the curve at the point, where 
/// 
/// The inherited Position.Location from IfcConic is the center of the IfcEllipse, and the inherited Position.P[1] from IfcConic the direction of the SemiAxis1.  
/// 
/// NOTE  Corresponding ISO 10303 entity: ellipse. Please refer to ISO/IS 10303-42:1994, p. 39 for the final definition of the formal standard.
/// 
/// HISTORY  New class in IFC Release 1.0
/// 
/// Figure 280 illustrates the definition of the IfcEllipse within the (in this case three-dimensional) position coordinate system. 
/// 
/// Figure 280 — Ellipse geometry
class IFC_PARSE_API IfcEllipse : public IfcConic {
public:
    /// The first radius of the ellipse which shall be positive. Placement.Axes[1] gives the direction of the SemiAxis1.
    double SemiAxis1() const;
    void setSemiAxis1(double v);
    /// The second radius of the ellipse which shall be positive.
    double SemiAxis2() const;
    void setSemiAxis2(double v);
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 1: return IfcUtil::Argument_DOUBLE; case 2: return IfcUtil::Argument_DOUBLE; } return IfcConic::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 1: return Type::IfcPositiveLengthMeasure; case 2: return Type::IfcPositiveLengthMeasure; } return IfcConic::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 1: return "SemiAxis1"; case 2: return "SemiAxis2"; } return IfcConic::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcEllipse (IfcEntityInstanceData* e);
    IfcEllipse (IfcAxis2Placement* v1_Position, double v2_SemiAxis1, double v3_SemiAxis2);
    typedef IfcTemplatedEntityList< IfcEllipse > list;
};
/// The element type IfcEnergyConversionType defines a list of commonly shared property
///   set definitions of an energy conversion device and an optional set of product representations.
///   It is used to define an energy conversion device specification (i.e. the specific product
///   information, that is common to all occurrences of that product type). 
/// 
/// NOTE: The product representations are defined as
///   representation maps (at the level of the supertype IfcTypeProduct, which
///   get assigned by an element occurrence instance through the
///   IfcShapeRepresentation.Item[1] being an
///   IfcMappedItem.
/// 
/// A energy conversion type is used to define the common properties of a
///   energy conversion device that may be applied to many occurrences of that type. 
/// An energy conversion device is a building systems device that converts energy from one form into another such 
/// 
/// as a boiler (i.e., combusting gas to heat water), chiller (i.e., using a refrigeration cycle to cool a 
/// 
/// liquid), or a cooling coil (i.e., using the phase-change characteristics of a refrigerant to cool air).
///   Energy conversion types (or the instantiable subtypes) may be exchanged 
///   without being already assigned to occurrences. 
/// 
/// The occurrences of the IfcEnergyConversionType are represented
///   by instances of IfcEnergyConversionDevice. 
/// 
/// HISTORY: New entity in IFC Release 2x2.
class IFC_PARSE_API IfcEnergyConversionDeviceType : public IfcDistributionFlowElementType {
public:
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcDistributionFlowElementType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcDistributionFlowElementType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcDistributionFlowElementType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcEnergyConversionDeviceType (IfcEntityInstanceData* e);
    IfcEnergyConversionDeviceType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType);
    typedef IfcTemplatedEntityList< IfcEnergyConversionDeviceType > list;
};
/// The energy conversion device type IfcEngineType defines commonly shared information for occurrences of engines.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a engine specification (i.e. the specific product information, that is common to all occurrences of that product type).  Engine types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcEngineType are represented by instances of IfcEngine. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcEnergyConversionDeviceType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_EngineTypeCommon 
/// 
/// Material Use Definition 
/// The material of the IfcEngineType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Casing': Material from which the casing is constructed. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcEngineType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcEngine for standard port definitions.
class IFC_PARSE_API IfcEngineType : public IfcEnergyConversionDeviceType {
public:
    IfcEngineTypeEnum::IfcEngineTypeEnum PredefinedType() const;
    void setPredefinedType(IfcEngineTypeEnum::IfcEngineTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcEnergyConversionDeviceType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcEngineTypeEnum; } return IfcEnergyConversionDeviceType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcEnergyConversionDeviceType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcEngineType (IfcEntityInstanceData* e);
    IfcEngineType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcEngineTypeEnum::IfcEngineTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcEngineType > list;
};
/// The energy conversion device type IfcEvaporativeCoolerType defines commonly shared information for occurrences of evaporative coolers.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a evaporative cooler specification (i.e. the specific product information, that is common to all occurrences of that product type).  Evaporative Cooler types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcEvaporativeCoolerType are represented by instances of IfcEvaporativeCooler. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcEnergyConversionDeviceType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_EvaporativeCoolerTypeCommon 
/// 
/// Material Use Definition 
/// The material of the IfcEvaporativeCoolerType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Media': Heat exchanger media material. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcEvaporativeCoolerType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcEvaporativeCooler for standard port definitions.
class IFC_PARSE_API IfcEvaporativeCoolerType : public IfcEnergyConversionDeviceType {
public:
    /// Defines the type of evaporative cooler.
    IfcEvaporativeCoolerTypeEnum::IfcEvaporativeCoolerTypeEnum PredefinedType() const;
    void setPredefinedType(IfcEvaporativeCoolerTypeEnum::IfcEvaporativeCoolerTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcEnergyConversionDeviceType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcEvaporativeCoolerTypeEnum; } return IfcEnergyConversionDeviceType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcEnergyConversionDeviceType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcEvaporativeCoolerType (IfcEntityInstanceData* e);
    IfcEvaporativeCoolerType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcEvaporativeCoolerTypeEnum::IfcEvaporativeCoolerTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcEvaporativeCoolerType > list;
};
/// The energy conversion device type IfcEvaporatorType defines commonly shared information for occurrences of evaporators.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a evaporator specification (i.e. the specific product information, that is common to all occurrences of that product type).  Evaporator types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcEvaporatorType are represented by instances of IfcEvaporator. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcEnergyConversionDeviceType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_EvaporatorTypeCommon 
/// 
/// Material Use Definition 
/// The material of the IfcEvaporatorType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Refrigerant': Refrigerant material. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcEvaporatorType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcEvaporator for standard port definitions.
class IFC_PARSE_API IfcEvaporatorType : public IfcEnergyConversionDeviceType {
public:
    /// Defines the type of evaporator.
    IfcEvaporatorTypeEnum::IfcEvaporatorTypeEnum PredefinedType() const;
    void setPredefinedType(IfcEvaporatorTypeEnum::IfcEvaporatorTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcEnergyConversionDeviceType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcEvaporatorTypeEnum; } return IfcEnergyConversionDeviceType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcEnergyConversionDeviceType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcEvaporatorType (IfcEntityInstanceData* e);
    IfcEvaporatorType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcEvaporatorTypeEnum::IfcEvaporatorTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcEvaporatorType > list;
};
/// An IfcEvent is something
///   that happens that triggers an action or response.
/// 
/// HISTORY  New entity in IFC2x4
/// 
/// Use definitions
/// 
/// IfcEvent is used to capture information about
///   particular things that happen or that may happen.
///   Particularly used in work plans (or process maps) they
///   identify e.g. a point at which a message containing
///   information may be issued or at which a rule or constraint
///   is invoked.
/// 
/// Type use definition
/// 
/// IfcEvent defines the anticipated or actual occurrence of
///   any event; common information about event types is handled
///   by IfcEventType. The IfcEventType (if present) may
///   establish the common type name, usage (or predefined) type,
///   common set of properties, and common product assignment
///   using IfcRelAssignsToProduct. The IfcEventType is attached
///   using the IfcRelDefinesByType.RelatingType objectified
///   relationship and is accessible by the inverse IsTypedBy
///   attribute.
/// 
/// Property set use definition
/// 
/// The property sets relating to IfcEvent are defined by
///   IfcPropertySet and attached by the
///   IfcRelDefinesByProperties relationship. They are accessible
///   by the inverse IsDefinedBy relationship. Such property sets
///   may define event parameters. No property sets for IfcEvent
///   are currently defined by IFC.
/// 
/// Connectivity use definition
/// 
/// The relationship IfcRelSequence is used to indicate control
///   flow. An IfcEvent as a predecessor
///   (IfcRelSequence.RelatingProcess) indicates that the
///   succeeding process (typically IfcProcedure or IfcTask) is
///   triggered in response to the event. An IfcEvent as a
///   successor (IfcRelSequence.RelatedProcess) indicates that
///   the completion of the preceeding process causes the event
///   to be triggered. As events have zero duration, the
///   IfcRelSequence.SequenceType attribute has no effect on an
///   IfcEvent but still applies to the opposite end of the
///   relationship if IfcTask is used.
/// 
/// Composition use definition
/// 
/// IfcEvent may be contained within an IfcTask using the
///   IfcRelNests relationship. The event is considered active
///   during the time period of the enclosing task (including any
///   assigned IfcWorkCalendar); that is such event may be
///   triggered within the task time period but not outside of
///   it. As an IfcEvent is considered to be atomic, no use is
///   anticipated for nesting processes inside the event.
/// 
/// Assignment use definition
/// 
/// An IfcEvent may be assigned to an IfcWorkCalendar to
///   indicate times when such event is active using
///   IfcRelAssignsToControl; otherwise the effective calendar is
///   determined by the nearest IfcProcess ancestor with a
///   calendar assigned.
/// 
/// For building operation scenarios, IfcEvent may be assigned
///   to a product (IfcElement subtype) using
///   IfcRelAssignsToProduct to indicate a specific product
///   occurrence that sources the event. For example, an
///   IfcSensor for a motion sensor may have a "Motion Sensed"
///   event. If the IfcEvent is defined by an IfcEventType and
///   the IfcEventType is assigned to a product type (using
///   IfcRelAssignsToProduct), then the IfcEvent must be assigned
///   to one or more occurrences of the specified product type
///   using IfcRelAssignsToProduct.
class IFC_PARSE_API IfcEvent : public IfcProcess {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcEvent
    bool hasPredefinedType() const;
    /// Identifies the predefined types of an event from which 
    ///   the type required may be set.
    IfcEventTypeEnum::IfcEventTypeEnum PredefinedType() const;
    void setPredefinedType(IfcEventTypeEnum::IfcEventTypeEnum v);
    /// Whether the optional attribute EventTriggerType is defined for this IfcEvent
    bool hasEventTriggerType() const;
    /// Identifies the predefined types of event trigger from which 
    ///   the type required may be set.
    IfcEventTriggerTypeEnum::IfcEventTriggerTypeEnum EventTriggerType() const;
    void setEventTriggerType(IfcEventTriggerTypeEnum::IfcEventTriggerTypeEnum v);
    /// Whether the optional attribute UserDefinedEventTriggerType is defined for this IfcEvent
    bool hasUserDefinedEventTriggerType() const;
    /// A user defined event trigger type, the value of which is 
    ///   asserted when the value of an event trigger type is declared 
    ///   as USERDEFINED.
    std::string UserDefinedEventTriggerType() const;
    void setUserDefinedEventTriggerType(std::string v);
    /// Whether the optional attribute EventOccurenceTime is defined for this IfcEvent
    bool hasEventOccurenceTime() const;
    /// The date and/or time at which an event occurs.
    IfcEventTime* EventOccurenceTime() const;
    void setEventOccurenceTime(IfcEventTime* v);
    virtual unsigned int getArgumentCount() const { return 11; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 7: return IfcUtil::Argument_ENUMERATION; case 8: return IfcUtil::Argument_ENUMERATION; case 9: return IfcUtil::Argument_STRING; case 10: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcProcess::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 7: return Type::IfcEventTypeEnum; case 8: return Type::IfcEventTriggerTypeEnum; case 9: return Type::IfcLabel; case 10: return Type::IfcEventTime; } return IfcProcess::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 7: return "PredefinedType"; case 8: return "EventTriggerType"; case 9: return "UserDefinedEventTriggerType"; case 10: return "EventOccurenceTime"; } return IfcProcess::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcEvent (IfcEntityInstanceData* e);
    IfcEvent (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, boost::optional< std::string > v6_Identification, boost::optional< std::string > v7_LongDescription, boost::optional< IfcEventTypeEnum::IfcEventTypeEnum > v8_PredefinedType, boost::optional< IfcEventTriggerTypeEnum::IfcEventTriggerTypeEnum > v9_EventTriggerType, boost::optional< std::string > v10_UserDefinedEventTriggerType, IfcEventTime* v11_EventOccurenceTime);
    typedef IfcTemplatedEntityList< IfcEvent > list;
};
/// Definition from IAI: The external spatial structure
/// element is an abstract entity provided for different kind of
/// external spaces, regions, and volumes.
/// HISTORY New entity in
/// IFC2x4.
class IFC_PARSE_API IfcExternalSpatialStructureElement : public IfcSpatialElement {
public:
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcSpatialElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcSpatialElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcSpatialElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcExternalSpatialStructureElement (IfcEntityInstanceData* e);
    IfcExternalSpatialStructureElement (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_LongName);
    typedef IfcTemplatedEntityList< IfcExternalSpatialStructureElement > list;
};
/// Definition from ISO/CD 10303-42:1992: A faceted B-rep
/// is a simple form of boundary representation model in which all
/// faces are planar and all edges are straight lines. Unlike the
/// B-rep model, edges and vertices are not represented explicitly in
/// the model but are implicitly available through the poly loop
/// entity. A faceted B-rep has to meet the same topological
/// constraints as the manifold solid B-rep.
/// 
/// NOTE The faceted B-rep has been introduced in order to support the larger number of systems that allow boundary type solid representations with planar surfaces only.
/// 
/// NOTE Corresponding ISO 10303-42 entity: faceted_brep. Please refer to ISO/IS 10303-42:1994, p. 173 for the final definition of the formal standard. In the current IFC Release faceted B-rep with voids is represented by an own subtype and not defined via an implicit ANDOR supertype constraint as in ISO/IS 10303-42:1994. This change has been made due to the fact, that only ONEOF supertype constraint is allowed within the IFC data schema.
/// 
/// HISTORY  New entity in IFC Release 1.0
/// 
/// Informal proposition:
/// 
/// All the bounding loops of all the faces of all the shells in
/// the IfcFacetedBrep shall be of type
/// IfcPolyLoop.
/// All vertices shall be referenced by all polyloops, sharing the vertex. That is, each Cartesian point shall be referenced by at least three polyloops.
/// 
/// Figure 257 illustrates use of IfcFacetedBrep for boundary representation models with planar surfaces only. The diagram shows the topological and geometric representation items that are used for faceted breps. Each IfcCartesianPoint, used within the IfcFacetedBrep shall be referenced three times by an IfcPolyLoop bounding a different IfcFace.
/// 
/// Figure 257 — Faceted B-rep
class IFC_PARSE_API IfcFacetedBrep : public IfcManifoldSolidBrep {
public:
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcManifoldSolidBrep::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcManifoldSolidBrep::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcManifoldSolidBrep::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcFacetedBrep (IfcEntityInstanceData* e);
    IfcFacetedBrep (IfcClosedShell* v1_Outer);
    typedef IfcTemplatedEntityList< IfcFacetedBrep > list;
};
/// The IfcFacetedBrepWithVoids
/// is a specialization of a faceted B-rep which contains one or more
/// voids in its interior. The voids are represented as closed shells
/// which are defined so that the shell normal point into the
/// void.
/// 
/// NOTEÿ Corresponding ISO 10303-42 entity: brep_with_voids (see note above). Please refer to ISO/IS 10303-42:1994, p. 173 for the final definition of the formal standard. In IFC faceted B-rep with voids is represented by this subtype IfcFacetedBrepWithVoids and not defined via an implicit ANDOR supertype constraint as in ISO/IS 10303-42:1994 between an instance of faceted_brep AND brep_with_voids. This change has been made due to the fact, that only ONEOF supertype constraint is allowed within the IFC object model.
/// 
/// HISTORYÿ New entity in IFC Release 1.0
/// 
/// IFC2x4 CHANGEÿ Subtyping changed from IfcManifoldSolidBrep to IfcFacetedBrep with upward compatibility for file based exchange.
/// 
/// Informal propositions:
/// 
/// Each void shell shall be disjoint from the outer shell and
/// from every other void shell
/// Each void shell shall be enclosed within the outer shell but
/// not within any other void shell. In particular the outer shell is
/// not in the set of void shells
/// Each shell in the IfcManifoldSolidBrep shall be
/// referenced only once.
/// All the bounding loops of all the faces of all the shells in
/// the IfcFacetedBrep shall be of type
/// IfcPolyLoop.
class IFC_PARSE_API IfcFacetedBrepWithVoids : public IfcFacetedBrep {
public:
    /// Set of closed shells defining voids within the solid.
    IfcTemplatedEntityList< IfcClosedShell >::ptr Voids() const;
    void setVoids(IfcTemplatedEntityList< IfcClosedShell >::ptr v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 1: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } return IfcFacetedBrep::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 1: return Type::IfcClosedShell; } return IfcFacetedBrep::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 1: return "Voids"; } return IfcFacetedBrep::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcFacetedBrepWithVoids (IfcEntityInstanceData* e);
    IfcFacetedBrepWithVoids (IfcClosedShell* v1_Outer, IfcTemplatedEntityList< IfcClosedShell >::ptr v2_Voids);
    typedef IfcTemplatedEntityList< IfcFacetedBrepWithVoids > list;
};
/// Definition from IAI:
///   Representations of fixing parts which are used as fasteners to connect or join elements with 
///   other elements.
/// 
/// HISTORY New entity in IFC Release 2x2
/// 
/// IFC 2x4 change:
/// Attribute PredefinedType added.
class IFC_PARSE_API IfcFastener : public IfcElementComponent {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcFastener
    bool hasPredefinedType() const;
    /// Subtype of fastener
    IfcFastenerTypeEnum::IfcFastenerTypeEnum PredefinedType() const;
    void setPredefinedType(IfcFastenerTypeEnum::IfcFastenerTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcElementComponent::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcFastenerTypeEnum; } return IfcElementComponent::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "PredefinedType"; } return IfcElementComponent::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcFastener (IfcEntityInstanceData* e);
    IfcFastener (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcFastenerTypeEnum::IfcFastenerTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcFastener > list;
};
/// Definition from IAI:
///   The element type (IfcFastenerType) defines a list of commonly shared
///   property set definitions of a fastener and an optional set of product
///   representations. It is used to define fasteners mainly within 
///   structural and building services domains (i.e. the specific type information  
///   common to all occurrences of that type). 
/// 
/// The occurrences of the IfcFastenerType are represented by
///   instances of IfcFastener.
/// 
/// HISTORY New entity in IFC Release 2x2
/// 
/// IFC 2x4 change:
/// Attribute PredefinedType added.
/// Subtype IfcMechanicalFastenerType redefined as direct subtype of IfcElementComponentType.
/// 
/// Property Set Use Definition
/// 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.
/// 
/// The following property set definitions are applicable to this entity according to the PredefinedType attribute:
/// 
/// Pset_FastenerWeld (WELD)
class IFC_PARSE_API IfcFastenerType : public IfcElementComponentType {
public:
    /// Subtype of fastener
    IfcFastenerTypeEnum::IfcFastenerTypeEnum PredefinedType() const;
    void setPredefinedType(IfcFastenerTypeEnum::IfcFastenerTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcElementComponentType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcFastenerTypeEnum; } return IfcElementComponentType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcElementComponentType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcFastenerType (IfcEntityInstanceData* e);
    IfcFastenerType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcFastenerTypeEnum::IfcFastenerTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcFastenerType > list;
};
/// Definition from IAI: Generalization of all existence
/// dependent elements which modify the shape and appearance of the
/// associated master element. The IfcFeatureElement offers
/// the ability to handle shape modifiers as semantic objects within
/// the IFC object model.
/// 
/// NOTE The term "feature" has a predefined meaning in a
/// context of "feature-based modeling" and within steel construction
/// work. It is introduced here in a broader sense to cover all
/// existence dependent, but semantically described, modifiers of an
/// element's shape and appearance. It is envisioned that future
/// releases enhance the feature-based capabilities of the IFC
/// model.
/// 
/// In contrary to the aggregation, as used in
/// IfcElementAssembly, that defines the aggregate as a
/// container element, that has equally treated parts, the feature
/// concept introduced by IfcFeatureElement defines the master
/// element with subordinate parts as additions, or with voids or
/// cut-outs as subtractions.
/// 
/// HISTORY New entity in Release
/// IFC2x Edition 2.
/// NOTE The entity is introduced as an
/// upward compatible extension of the IFC2x platform. It is an
/// intermediate abstract supertype without defining its own explicit
/// attributes.
/// 
/// Containment Use Definition
/// As a subordinate part being fully dependent on the master
/// element the IfcFeatureElement shall have no independent
/// containment relationship to the spatial structure.
/// 
/// The SELF\IfcElement.ContainedInStructure relationship
/// shall be NIL.
/// 
/// Geometry Use Definition
/// The geometric representation of IfcFeatureElement is
/// given by the IfcProductDefinitionShape, allowing multiple
/// geometric representation.
/// Local Placement
/// The local placement for IfcFeatureElement is defined in
/// its supertype IfcProduct. It is defined by the
/// IfcLocalPlacement, which defines the local coordinate
/// system that is referenced by all geometric representations.
/// 
/// The PlacementRelTo relationship of
/// IfcLocalPlacement shall point (if given) to the local
/// placement of the master IfcElement (its relevant
/// subtypes), which is associated to the IfcFeatureElement by
/// the appropriate relationship object.
/// If the relative placement is not used, the absolute placement
/// is defined within the world coordinate system.
/// 
/// Geometric Representations
/// Any IfcFeatureElement can be represented by one or
/// several geometric representations. A detailed specification is
/// introduced at the level of subtypes. Only the general
/// representation identifier 'Box' with representation type
/// 'BoundingBox', and representation identifier 'Body' with
/// representation type 'Brep' are defined here.
/// Box Representation
/// Any IfcFeatureElement may be represented as a bounding
/// box, which shows the maximum extend of the body within the
/// coordinated system established by the IfcLocalPlacement.
/// The bounding box representation is the simplest geometric
/// representation available. The following attribute values for the
/// IfcShapeRepresentation holding this geometric
/// representation shall be used:
/// 
/// RepresentationIdentifier : 'Box'
/// RepresentationType : 'BoundingBox'
/// 
/// Body Representation
/// The body representation of any IfcFeatureElement can
/// have the following representation types: 'Brep'. Other
/// representation types might be specified at the level of
/// subtypes.
/// Brep Representation Type
/// Any IfcFeatureElement (so far no further constraints
/// are defined at the level of its subtypes) may be represented as a
/// single or multiple Boundary Representation elements (which are
/// restricted to faceted Brep with or without voids). The Brep
/// representation allows for the representation of complex element
/// shape. The following attribute values for the
/// IfcShapeRepresentation holding this geometric
/// representation shall be used:
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'Brep'
/// 
/// In some cases it may be useful to also expose a simple
/// representation as a bounding box representation of the same
/// complex shape.
class IFC_PARSE_API IfcFeatureElement : public IfcElement {
public:
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcFeatureElement (IfcEntityInstanceData* e);
    IfcFeatureElement (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag);
    typedef IfcTemplatedEntityList< IfcFeatureElement > list;
};
/// Definition from IAI: A specialization of the general
///   feature element, that represents an existence dependent
///   element which modifies the shape and appearance of the
///   associated master element. The
///   IfcFeatureElementAddition offers the ability to
///   handle shape modifiers as semantic objects within the IFC
///   object model that add to the shape of the master element.
/// 
/// HISTORY New entity in
///   Release IFC2x Edition 2.
///   NOTE The entity is
///   introduced as an upward compatible extension of the IFC2x
///   platform. It is an intermediate abstract supertype
///   without defining its own explicit
///   attributes.
/// 
/// The IfcFeatureElementAddition is associated to its
///   master element by virtue of the objectified relationship
///   IfcRelProjectsElement. This relationship implies a
///   Boolean 'union' operation between the shape of the master
///   element and the shape of the addition feature.
/// 
/// Containment use definition
/// 
/// The containment to the spatial structure is defined at the
///   level of the supertype IfcFeatureElement
/// 
/// Geometry Use Definitions
/// 
/// The geometric representation of
///   IfcFeatureElementAddition is given by the
///   IfcProductDefinitionShape, allowing multiple
///   geometric representations.
/// 
/// Local Placement
/// 
/// The local placement for IfcFeatureElementAddition is
///   defined in its supertype IfcProduct. It is defined
///   by the IfcLocalPlacement, which defines the local
///   coordinate system that is referenced by all geometric
///   representations. The local placement is always defined in
///   relation to the local placement of the element to which the
///   feature element is added:
/// 
/// The PlacementRelTo relationship of
///   IfcLocalPlacement shall point to the local placement
///   of the same IfcElement, which is used in the
///   HasAdditionFeature.RelatingElement inverse
///   attribute.
/// 
/// Shape Representation
/// 
/// The geometry use definitions for the shape representation
///   of the IfcFeatureElementAddition is given at the
///   level of its subtypes.
class IFC_PARSE_API IfcFeatureElementAddition : public IfcFeatureElement {
public:
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcFeatureElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcFeatureElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcFeatureElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcRelProjectsElement >::ptr ProjectsElements() const; // INVERSE IfcRelProjectsElement::RelatedFeatureElement
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcFeatureElementAddition (IfcEntityInstanceData* e);
    IfcFeatureElementAddition (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag);
    typedef IfcTemplatedEntityList< IfcFeatureElementAddition > list;
};
/// The IfcFeatureElementSubtraction is specialization of
/// the general feature element, that represents an existence dependent
/// elements which modifies the shape and appearance of the associated
/// master element. The IfcFeatureElementSubtraction offers the
/// ability to handle shape modifiers as semantic objects within the
/// IFC object model that subtract from the shape of the master
/// element.
/// 
/// A single subtraction feature
/// such as the subtype IfcOpeningElement is assigned by a
/// single subtraction relationship IfcRelVoidsElement to one
/// occurrences of IfcElement. It establishes a 1:1
/// relationship between the opening and the element. An element may
/// have several IfcRelVoidsElement relationships, enabling
/// several voids.
/// 
/// The voiding relationship between a master element and a
/// subtraction feature is geometrically resolved by a Boolean
/// difference operation.
/// 
/// HISTORY New entity in
/// Release IFC2x Edition 2.
/// 
/// Containment use definition
/// The IfcFeatureElementSubtraction shall have no
/// independent containment relationship to the spatial structure. See
/// explanation at supertype IfcFeatureElement
/// Geometry Use Definitions
/// The geometric representation of
/// IfcFeatureElementSubtraction is given by the
/// IfcProductDefinitionShape, allowing multiple geometric
/// representations.
/// Local Placement
/// The local placement for IfcFeatureElementSubtraction is
/// defined in its supertype IfcProduct. It is defined by the
/// IfcLocalPlacement, which defines the local coordinate system
/// that is referenced by all geometric representations. The local
/// placement is always defined in relation to the local placement of
/// the building element from which the feature element substration is
/// substracted:
/// 
/// The PlacementRelTo relationship of
/// IfcLocalPlacement shall point (if given) to the local
/// placement of the same IfcElement, which is used in the
/// VoidsElements.RelatingElement inverse attribute.
/// 
/// Shape Representation
/// The geometry use definitions for the shape representation of the
/// IfcFeatureElementSubtraction is given at the level of its
/// subtypes.
class IFC_PARSE_API IfcFeatureElementSubtraction : public IfcFeatureElement {
public:
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcFeatureElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcFeatureElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcFeatureElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcRelVoidsElement >::ptr VoidsElements() const; // INVERSE IfcRelVoidsElement::RelatedOpeningElement
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcFeatureElementSubtraction (IfcEntityInstanceData* e);
    IfcFeatureElementSubtraction (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag);
    typedef IfcTemplatedEntityList< IfcFeatureElementSubtraction > list;
};
/// The element type IfcFlowControllerType defines a list of commonly shared property
///   set definitions of a flow controller and an optional set of product representations.
///   It is used to define a flow controller specification (i.e. the specific product
///   information, that is common to all occurrences of that product type). 
/// 
/// NOTE: The product representations are defined as
///   representation maps (at the level of the supertype IfcTypeProduct, which
///   get assigned by an element occurrence instance through the
///   IfcShapeRepresentation.Item[1] being an
///   IfcMappedItem.
/// 
/// A flow controller type is used to define the common properties of a
///   flow controller that may be applied to many occurrences of that type.
/// A flow controller is a device that regulates flow within a distribution system, such as a valve in a piping 
/// 
/// system, modulating damper in an air distribution system, or electrical switch in an electrical distribution 
/// 
/// system. Flow controller types (or the instantiable subtypes) may be exchanged 
///   without being already assigned to occurrences. 
/// 
/// The occurrences of the IfcFlowControllerType are represented
///   by instances of IfcFlowController or its subtypes. 
/// 
/// HISTORY: New entity in IFC Release 2x2.
class IFC_PARSE_API IfcFlowControllerType : public IfcDistributionFlowElementType {
public:
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcDistributionFlowElementType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcDistributionFlowElementType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcDistributionFlowElementType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcFlowControllerType (IfcEntityInstanceData* e);
    IfcFlowControllerType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType);
    typedef IfcTemplatedEntityList< IfcFlowControllerType > list;
};
/// The element type IfcFlowFittingType defines a list of commonly shared property
///   set definitions of a flow fitting and an optional set of product representations.
///   It is used to define a flow fitting specification (i.e. the specific product
///   information, that is common to all occurrences of that product type). 
/// 
/// NOTE: The product representations are defined as
///   representation maps (at the level of the supertype IfcTypeProduct, which
///   get assigned by an element occurrence instance through the
///   IfcShapeRepresentation.Item[1] being an
///   IfcMappedItem.
/// 
/// A flow fitting type is used to define the common properties of a
///   flow fitting that may be applied to many occurrences of that type.
/// A flow fitting is a device that is used to interconnect flow segments or other fittings within a distribution 
/// 
/// system, such as a tee in a ducted system that branches flow into two directions, a junction box in an 
/// 
/// electrical distribution system, etc. 
///   Flow fitting types (or the instantiable subtypes) may be exchanged 
///   without being already assigned to occurrences. 
/// 
/// The occurrences of the IfcFlowFittingType are represented
///   by instances of IfcFlowFitting or its subtypes. 
/// 
/// HISTORY: New entity in IFC Release 2x2.
class IFC_PARSE_API IfcFlowFittingType : public IfcDistributionFlowElementType {
public:
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcDistributionFlowElementType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcDistributionFlowElementType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcDistributionFlowElementType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcFlowFittingType (IfcEntityInstanceData* e);
    IfcFlowFittingType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType);
    typedef IfcTemplatedEntityList< IfcFlowFittingType > list;
};
/// The flow controller type IfcFlowMeterType defines commonly shared information for occurrences of flow meters.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a flow meter specification (i.e. the specific product information, that is common to all occurrences of that product type).  Flow Meter types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcFlowMeterType are represented by instances of IfcFlowMeter. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcFlowControllerType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_FlowMeterTypeCommon 
/// 
/// The following property set definitions are applicable to this entity according to the PredefinedType attribute:  
/// Pset_FlowMeterTypeEnergyMeter (ENERGYMETER) 
/// Pset_FlowMeterTypeGasMeter (GASMETER) 
/// Pset_FlowMeterTypeOilMeter (OILMETER) 
/// Pset_FlowMeterTypeWaterMeter (WATERMETER) 
/// 
/// Material Use Definition 
/// The material of the IfcFlowMeterType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Casing': Material from which the casing is constructed. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcFlowMeterType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcFlowMeter for standard port definitions.
class IFC_PARSE_API IfcFlowMeterType : public IfcFlowControllerType {
public:
    /// Defines the type of flow meter.
    IfcFlowMeterTypeEnum::IfcFlowMeterTypeEnum PredefinedType() const;
    void setPredefinedType(IfcFlowMeterTypeEnum::IfcFlowMeterTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcFlowControllerType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcFlowMeterTypeEnum; } return IfcFlowControllerType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcFlowControllerType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcFlowMeterType (IfcEntityInstanceData* e);
    IfcFlowMeterType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcFlowMeterTypeEnum::IfcFlowMeterTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcFlowMeterType > list;
};
/// The element type IfcFlowMovingDeviceType defines a list of commonly shared property
///   set definitions of a flow moving device and an optional set of product representations.
///   It is used to define a flow moving device specification (i.e. the specific product
///   information, that is common to all occurrences of that product type). 
/// 
/// NOTE: The product representations are defined as
///   representation maps (at the level of the supertype IfcTypeProduct, which
///   get assigned by an element occurrence instance through the
///   IfcShapeRepresentation.Item[1] being an
///   IfcMappedItem.
/// 
/// A flow moving type is used to define the common properties of a
///   flow moving device that may be applied to many occurrences of that type.
/// A flow moving device is a device that is used to produce a pressure differential in a distribution system, 
/// 
/// such as a pump, fan, compressor, etc. 
///   Flow moving types (or the instantiable subtypes) may be exchanged 
///   without being already assigned to occurrences. 
/// 
/// The occurrences of the IfcFlowMovingDeviceType are represented
///   by instances of IfcFlowMovingDevice. 
/// 
/// HISTORY: New entity in IFC Release 2x2.
class IFC_PARSE_API IfcFlowMovingDeviceType : public IfcDistributionFlowElementType {
public:
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcDistributionFlowElementType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcDistributionFlowElementType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcDistributionFlowElementType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcFlowMovingDeviceType (IfcEntityInstanceData* e);
    IfcFlowMovingDeviceType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType);
    typedef IfcTemplatedEntityList< IfcFlowMovingDeviceType > list;
};
/// The element type IfcFlowSegmentType defines a list of commonly shared property
///   set definitions of a flow segment and an optional set of product representations.
///   It is used to define a flow segment specification (i.e. the specific product
///   information, that is common to all occurrences of that product type). 
/// 
/// NOTE: The product representations are defined as
///   representation maps (at the level of the supertype IfcTypeProduct, which
///   get assigned by an element occurrence instance through the
///   IfcShapeRepresentation.Item[1] being an
///   IfcMappedItem.
/// 
/// A flow segment type is used to define the common properties of a
///   flow segment that may be applied to many occurrences of that type.
/// A flow segment is a section of a distribution system, such as a duct, pipe, conduit, etc. that typically has 
/// 
/// only two ports. 
///   Flow segment types (or the instantiable subtypes) may be exchanged 
///   without being already assigned to occurrences. 
/// 
/// The occurrences of the IfcFlowSegmentType are represented
///   by instances of IfcFlowSegment or its subtypes. 
/// 
/// HISTORY: New entity in IFC Release 2x2.
/// 
/// Material Use Definition
/// The material of the IfcDistributionFlowSegmentType is defined using one of the following entities:
/// 
/// IfcMaterialProfileSet : This defines the material cross section which may be used to generate the 'Body' representation at occurrences (for parametric definitions not having representation), or for analysis purposes.
/// 
/// IfcMaterialConstituentSet : For elements containing multiple materials where profiles are not applicable, this indicates materials at named aspects.
/// 
/// IfcMaterial : For elements comprised of a single material where profiles are not applicable, this indicates the material.
class IFC_PARSE_API IfcFlowSegmentType : public IfcDistributionFlowElementType {
public:
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcDistributionFlowElementType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcDistributionFlowElementType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcDistributionFlowElementType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcFlowSegmentType (IfcEntityInstanceData* e);
    IfcFlowSegmentType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType);
    typedef IfcTemplatedEntityList< IfcFlowSegmentType > list;
};
/// The element type IfcFlowStorageDeviceType defines a list of commonly shared property set definitions of a flow storage device and an optional set of product representations.  It is used to define a flow storage device specification (the specific product information that is common to all occurrences of that product type). 
/// 
/// A flow storage device is a device used for the temporary storage of a fluid (such as a tank) or the voltage potential induced by the induced electron flow (such as a battery). Flow storage types (or the instantiable subtypes) may be exchanged without being already assigned to occurrences. 
/// 
/// The occurrences of the IfcFlowStorageDeviceType are represented by instances of IfcFlowStorageDevice or its subtypes. 
/// 
/// HISTORY: New entity in IFC Release 2x2.
class IFC_PARSE_API IfcFlowStorageDeviceType : public IfcDistributionFlowElementType {
public:
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcDistributionFlowElementType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcDistributionFlowElementType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcDistributionFlowElementType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcFlowStorageDeviceType (IfcEntityInstanceData* e);
    IfcFlowStorageDeviceType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType);
    typedef IfcTemplatedEntityList< IfcFlowStorageDeviceType > list;
};
/// The element type IfcFlowTerminalType defines a list of commonly shared property set definitions of a flow terminal and an optional set of product representations.  It is used to define a flow terminal specification (the specific product information that is common to all occurrences of that product type). 
/// 
/// A flow terminal type is used to define the common properties of a flow terminal that may be applied to many occurrences of that type.  A flow terminal acts as a terminus or beginning element in a distribution system such as a ceiling register in a ducted air distribution system, a sink in a waste-water system, or a light fixture in an electrical lighting system. Flow terminal types (or the instantiable subtypes) may be exchanged without being already assigned to occurrences. 
/// 
/// The occurrences of the IfcFlowTerminalType are represented by instances of IfcFlowTerminal or its subtypes. 
/// 
/// HISTORY: New entity in IFC Release 2x2.
class IFC_PARSE_API IfcFlowTerminalType : public IfcDistributionFlowElementType {
public:
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcDistributionFlowElementType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcDistributionFlowElementType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcDistributionFlowElementType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcFlowTerminalType (IfcEntityInstanceData* e);
    IfcFlowTerminalType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType);
    typedef IfcTemplatedEntityList< IfcFlowTerminalType > list;
};
/// The element type IfcFlowTreatmentDeviceType defines a list of commonly shared property set definitions of a flow treatment device and an optional set of product representations. It is used to define a flow treatment device specification (the specific product information that is common to all occurrences of that product type). 
/// 
/// A flow treatment device is a device used to change the physical properties of the medium, such as an air, oil 
/// 
/// or water filter (used to remove particulates from the fluid), or a duct silencer (used to attenuate noise).  Flow treatment types (or the instantiable subtypes) may be exchanged without being already assigned to occurrences. 
/// 
/// The occurrences of the IfcFlowTreatmentDeviceType are represented by instances of IfcFlowTreatmentDevice or its subtypes. 
/// 
/// HISTORY: New entity in IFC Release 2x2.
class IFC_PARSE_API IfcFlowTreatmentDeviceType : public IfcDistributionFlowElementType {
public:
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcDistributionFlowElementType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcDistributionFlowElementType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcDistributionFlowElementType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcFlowTreatmentDeviceType (IfcEntityInstanceData* e);
    IfcFlowTreatmentDeviceType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType);
    typedef IfcTemplatedEntityList< IfcFlowTreatmentDeviceType > list;
};
/// Definition from IAI: Provides shared material, decomposition, representation maps, and property sets for instances of IfcFooting.
/// 
/// HISTORY New entity in IFC Release 2x4
/// 
/// Note, slab foundation types are not instantiated as IfcFootingType but as IfcSlabType with a predefined type of IfcSlabTypeEnum.BASESLAB.
/// 
/// Material Use Definition:
/// 
/// Material profile set or material layer set association analogous to IfcBeamStandardCase or IfcSlabStandardCase should be used when applicable.
class IFC_PARSE_API IfcFootingType : public IfcBuildingElementType {
public:
    /// Subtype of footing.
    IfcFootingTypeEnum::IfcFootingTypeEnum PredefinedType() const;
    void setPredefinedType(IfcFootingTypeEnum::IfcFootingTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcBuildingElementType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcFootingTypeEnum; } return IfcBuildingElementType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcBuildingElementType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcFootingType (IfcEntityInstanceData* e);
    IfcFootingType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcFootingTypeEnum::IfcFootingTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcFootingType > list;
};
/// Definition from IAI: Generalization of all furniture
/// related objects. Furnishing objects are characterized as
/// being
/// 
/// pre-manufactured and assembled on-site, or
/// manufactured on-site (built-in)
/// 
/// Thus furnishing elements can either be movable, or not (as the
/// built-ins).
/// HISTORY New entity in
/// IFC Release 2x.
/// IFC2x4 CHANGE The entity is marked
/// as deprecated for instantiation - will be made ABSTRACT after
/// IFC2x4.
/// Geometry Use Definitions:
/// The geometric representation of IfcFurnishingElement is
/// given by the IfcProductDefinitionShape and
/// IfcLocalPlacement allowing multiple geometric
/// representation.
/// Local Placement
/// The local placement for IfcFurnishingElement is defined
/// in its supertype IfcProduct. It is defined by the
/// IfcLocalPlacement, which defines the local coordinate
/// system that is referenced by all geometric representations.
/// 
/// The PlacementRelTo relationship of
/// IfcLocalPlacement shall point (if given) to the local
/// placement of the same IfcSpatialStructureElement , which
/// is used in the ContainedInStructure inverse attribute, or
/// to a spatial structure element at a higher level, referenced by
/// that.
/// If the relative placement is not used, the absolute placement
/// is defined within the world coordinate system.
/// 
/// Geometric Representations
/// Any IfcFurnishingElement can be represented by one or
/// several geometric representations. This includes the general
/// representation types 'BoundingBox', 'GeometricCurveSet',
/// 'SurfaceModel', 'Brep', and 'MappedRepresentation' being defined
/// here.
/// Bounding Box Representation
/// Any IfcFurnishingElement may be represented as a
/// bounding box, which shows the maximum extend of the body within
/// the coordinated system established by the
/// IfcLocalPlacement. The bounding box representation is the
/// simplest geometric representation available. The following
/// attribute values for the IfcShapeRepresentation holding
/// this geometric representation shall be used:
/// 
/// RepresentationIdentifier : 'Box'
/// RepresentationType : 'BoundingBox'
/// 
/// Foot Print Representation
/// The foot print representation of IfcFurnishingElement
/// is given by either a single or multiple 2D points and curves. The
/// representation identifier and type of this geometric
/// representation are:
/// 
/// IfcShapeRepresentation.RepresentationIdentifier =
/// 'FootPrint'
/// IfcShapeRepresentation.RepresentationType =
/// 'GeometricCurveSet'
/// 
/// SurfaceModel Representation
/// Any IfcFurnishingElement (so far no further constraints
/// are defined at the level of its subtypes) may be represented as a
/// single or multiple surface models, based on either shell or face
/// based models. In some cases it may be useful to also expose a
/// simple representation as a bounding box representation of the
/// same complex shape. The representation identifier and type of
/// this geometric representation are:
/// 
/// IfcShapeRepresentation.RepresentationIdentifier =
/// 'Body'
/// IfcShapeRepresentation.RepresentationType =
/// 'SurfaceModel'
/// 
/// Brep Representation
/// Any IfcFurnishingElement (so far no further constraints
/// are defined at the level of its subtypes) may be represented as a
/// single or multiple Boundary Representation elements (which are
/// restricted to faceted Brep with or without voids). The Brep
/// representation allows for the representation of complex element
/// shape. In some cases it may be useful to also expose a simple
/// representation as a bounding box representation of the same
/// complex shape. The representation identifier and type of this
/// geometric representation are:
/// 
/// IfcShapeRepresentation.RepresentationIdentifier =
/// 'Body'
/// IfcShapeRepresentation.RepresentationType =
/// 'Brep'
/// 
/// MappedRepresentation
/// The IfcMappedItem should always be used in appropriate
/// cases as it allows for reusing the geometry definition of the
/// furnishing type for all occurrences of the same type. The
/// representation identifier and type of this geometric
/// representation are:
/// 
/// IfcShapeRepresentation.RepresentationIdentifier =
/// 'FootPrint', or 'Body' (depending of the representation map)
/// IfcShapeRepresentation.RepresentationType =
/// 'MappedRepresentation'
class IFC_PARSE_API IfcFurnishingElement : public IfcElement {
public:
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcFurnishingElement (IfcEntityInstanceData* e);
    IfcFurnishingElement (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag);
    typedef IfcTemplatedEntityList< IfcFurnishingElement > list;
};
/// Furniture defines complete furnishings such as a table, desk, chair, or cabinet, which may or may not be permanently attached to a building structure. 
/// 
/// Occurrences of furniture that are built in (where the property Pset_FurnitureTypeCommon.IsBuiltIn is asserted to be TRUE) should have their connection relationship with a building element occurrence defined through the IfcRelConnectsElements relationship.HISTORY: New entity in IFC2x2 
/// 
/// Type Use Definition 
/// IfcFurniture defines the occurrence of any furniture; common information about furniture types is handled by IfcFurnitureType.  The IfcFurnitureType (if present) may establish the common type name, usage (predefined type), properties, materials, composition, assignments, and representations.  The IfcFurnitureType is attached using the IfcRelDefinesByType objectified relationship and is accessible by the IsTypedBy inverse attribute.  If the IfcFurnitureType has aggregated elements, such objects are reflected at the IfcFurniture occurrence using the IfcRelDefinesByObject relationship. 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the IfcRelDefinesByProperties relationship. They are accessible by the IsDefinedBy inverse attribute.  Property sets may also be specified at the IfcFurnitureType, defining the common property data for all occurrences of the same type.  They are then accessible by the IsTypedBy inverse attribute pointing to IfcFurnitureType.HasPropertySets. If both are given, then the properties directly defined at IfcFurniture override the properties defined at IfcFurnitureType.  Refer to the documentation at the supertype IfcFurnishingElement and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_FurnitureTypeCommon 
/// 
/// The following property set definitions are applicable to this entity according to the PredefinedType attribute:  
/// Pset_FurnitureTypeChair (CHAIR) 
/// Pset_FurnitureTypeDesk (DESK) 
/// Pset_FurnitureTypeFileCabinet (FILECABINET) 
/// Pset_FurnitureTypeTable (TABLE) 
/// 
/// Material Use Definition 
/// The material of the IfcFurniture is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.  Material information can also be given at the IfcFurnitureType, defining the common attribute data for all occurrences of the same type.  The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Finish': The finish, typically at visible aspects of the furniture. 
/// 'Frame': The frame from which the object is constructed. 
/// 'Hardware': Finish hardware such as knobs or handles. 
/// 'Padding': Padding such as cushions. 
/// 'Panel': Panels such as glass. 
/// 
/// Composition Use Definition 
/// The IfcFurniture may be decomposed into components using IfcRelAggregates where RelatingObject refers to the enclosing IfcFurniture and RelatedObjects contains one or more components.  Composition use is defined for the following predefined types:
/// 
/// (All Types): May contain IfcSystemFurnitureElement components.  Modular furniture may be aggregated into components.
class IFC_PARSE_API IfcFurniture : public IfcFurnishingElement {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcFurniture
    bool hasPredefinedType() const;
    IfcFurnitureTypeEnum::IfcFurnitureTypeEnum PredefinedType() const;
    void setPredefinedType(IfcFurnitureTypeEnum::IfcFurnitureTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcFurnishingElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcFurnitureTypeEnum; } return IfcFurnishingElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "PredefinedType"; } return IfcFurnishingElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcFurniture (IfcEntityInstanceData* e);
    IfcFurniture (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcFurnitureTypeEnum::IfcFurnitureTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcFurniture > list;
};
/// Definition from IAI: An IfcGeographicElement is
/// a generalization of all elements within a geographical landscape.
/// It includes occurrences of typical geographical element, often
/// referred to as features, such as roads, zones, trees, etc. Common
/// type information behind several occurrences of
/// IfcGeographicElement is provided by the
/// IfcGeographicElementType.ÿ
/// HISTORY ÿNew entity in
/// Release IFC2x4.
/// Type Use Definition
/// An IfcGeographicElement defines the occuurence of any
/// element within a geographic landscape, common information about
/// geographic elements is handled by
/// IfcGeographicElementType. The
/// IfcGeographicElementType (if present) may establish the
/// commonÿtype name, usage (or predefined) type, common set of
/// properties and common shape representations (using
/// IfcRepresentationMap). The IfcGeographicElementType
/// is attached using the IfcRelDefinedByType.RelatingType
/// objectified relationship and is accessible by the inverse
/// IsDefinedBy attribute.
/// Classification Use Definition
/// An IfcGeographicElement might be further qualified by
/// referencing a feature catalog as a particular classification. The
/// feature classification is assigned using the inverse relationship
/// HasAssociations pointing to
/// IfcClassificationReference. The attributes should have the
/// following meaning:
/// 
/// Catalog : IfcClassification.Name
/// Identity:
/// IfcClassificationReference.ItemReference
/// ElementName: IfcClassificationReference.Name
/// if there is a differentiation between an main element and a
/// sub element without a unique notation facet, then the main
/// element and sub element(s) can be established by using the
/// subtype
/// 
/// IfcClassificationReferenceWithFacets.ItemReferenceFacets
/// 
/// Containment Use Definition
/// The IfcGeographicElement, as any subtype of
/// IfcElement, may participate in two different containment
/// relationships. The first (and in most implementation scenarios
/// mandatory) relationship is the hierachical spatial containment,
/// the second (optional) relationship is the aggregation within
/// anÿelement assembly.
/// 
/// The IfcGeographicElement is places within the project
/// spatial hierarchy using the objectified relationship
/// IfcRelContainedInSpatialStructure, refering to it by its
/// inverse attribute SELF\IfcElement.ContainedInStructure.
/// Subtypes ofÿIfcSpatialStructureElement are valid spatial
/// containers, with IfcSite being the default container.
/// The IfcGeographicElement may be aggregated into an
/// element assembly using the objectified relationship
/// IfcRelAggregates, refering to it by its inverse attribute
/// SELF\IfcObjectDefinition.Decomposes. Any subtype of
/// IfcElement can be an element assembly, with
/// IfcElementAssembly as a special focus subtype. In this
/// case it should not be additionally contained in the project
/// spatial hierarchy,
/// i.e.ÿSELF\IfcElement.ContainedInStructure should be
/// NIL.
/// 
/// Geometry Use Definitions
/// The geometric representation of IfcGeographicElement is
/// given by the IfcProductDefinitionShape, allowing multiple
/// geometric representation.
/// Local Placement
/// The local placement for IfcGeographicElement is defined
/// in its supertype IfcProduct. It is defined by the
/// IfcLocalPlacement, which defines the local coordinate
/// system that is referenced by all geometric representations.
/// 
/// The PlacementRelTo relationship of
/// IfcLocalPlacement shall point (if given) to the local
/// placement of the same IfcSpatialStructureElement , which
/// is used in the ContainedInStructure inverse attribute, or
/// to a spatial structure element at a higher level, referenced by
/// that.
/// If the relative placement is not used, the absolute placement
/// is defined within the world coordinate system.
/// 
/// Geometric Representation
/// GeometricCurveSet and GeometricSet Representation
/// The standard representation of IfcGeographicElement is
/// defined using 'GeometricCurveSet' or, when including surfaces,
/// the 'GeometricSet' geometry. This also supports a 2D
/// representation of IfcGeographicElement.ÿ
/// The following attribute values for the
/// IfcShapeRepresentation holding this geometric
/// representation shall be used:
/// 
/// RepresentationIdentifier : 'FootPrint' for 2D
/// representation
/// RepresentationType :ÿ'GeometricCurveSet'
/// orÿ'GeometricSet'
/// 
/// Annotation2D Representation
/// Additional annotation objects, like text or hatching, and
/// style information to the 2D representations, may be exchanged
/// using the 'Annotation2D' representation. Style information is
/// assigned to the geometric representation items within the set of
/// Items at IfcShapeRepresentation using the inverse
/// StyledByItem relationship.
/// The following attribute values for the
/// IfcShapeRepresentation holding this geometric
/// representation shall be used:
/// 
/// RepresentationIdentifier : 'FootPrint' for 2D
/// representation
/// RepresentationType :ÿ'Annotation2D'
/// 
/// SurfaceModel and Brep Representation
/// For full 3D representations, the use of 'SurfaceModel' and
/// 'Brep' geometry is supported. This supports a 3D representation,
/// including support for 3D digital terrain models.
/// The following attribute values for the
/// IfcShapeRepresentation holding this geometric
/// representation shall be used:
/// 
/// RepresentationIdentifier : 'Body' for 3D
/// representation
/// RepresentationType :ÿ'SurfaceModel' orÿ'Brep'
/// 
/// MappedRepresentation Representation
/// When using the IfcGeographicElement in conjunction with
/// the IfcGeographicElementType having
/// RepresentationMaps defined, the geometric representation
/// ofÿIfcGeographicElementÿshall be based on
/// 'MappedRepresentation', referencing the
/// IfcRepresentationMap given at the type object.
/// The following attribute values for the
/// IfcShapeRepresentation holding this geometric
/// representation shall be used:
/// 
/// RepresentationIdentifier : 'FootPrint' for 2D
/// representation, 'Body' for 3D representation
/// RepresentationType :ÿ'MappedRepresentation'
class IFC_PARSE_API IfcGeographicElement : public IfcElement {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcGeographicElement
    bool hasPredefinedType() const;
    /// Predefined generic types for a geographic element that are specified in an enumeration. There might be property sets defined specifically for each predefined type.
    IfcGeographicElementTypeEnum::IfcGeographicElementTypeEnum PredefinedType() const;
    void setPredefinedType(IfcGeographicElementTypeEnum::IfcGeographicElementTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcGeographicElementTypeEnum; } return IfcElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "PredefinedType"; } return IfcElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcGeographicElement (IfcEntityInstanceData* e);
    IfcGeographicElement (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcGeographicElementTypeEnum::IfcGeographicElementTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcGeographicElement > list;
};
/// IfcGrid ia a planar design
/// grid defined in 3D space used as an aid in locating structural and
/// design elements. The position of the grid (ObjectPlacement)
/// is defined by a 3D coordinate system (and thereby the design grid
/// can be used in plan, section or in any position relative to the
/// world coordinate system). The position can be relative to the
/// object placement of other products or grids. The XY plane of the 3D
/// coordinate system is used to place the grid axes, which are 2D
/// curves (for example, line, circle, trimmed curve, polyline, or composite
/// curve).
/// The inherited attributes Name and Description can
/// be used to define a descriptive name of the grid and to indicate
/// the grid's purpose. A grid is defined by (normally) two, or
/// (in case of a triangular grid) three lists of grid axes. The
/// following table shows some examples.
/// A grid may support a rectangular layout (Figure 28), a radial layout (Figure 29), or a triangular layout (Figure 30).
/// 
/// Figure 28 — Grid rectangular layout
/// Figure 29 — Grid radial layout
/// Figure 30 — Grid triangular layout
/// 
/// The grid axes, defined within the design grid, are those
/// elements to which project objects will be placed relatively using
/// the IfcGridPlacement.
/// 
/// HISTORY New entity in IFC Release 1.0.
/// Informal Proposition
/// 
/// Grid axes, which are referenced in different lists of axes
/// (UAxes, VAxes, WAxes) shall not be parallel.
/// Grid axes should be defined such as there are no two grid axes
/// which intersect twice (see Figure 31).
/// 
/// left side: ambiguous intersections A1 and A2, a grid containing
/// such grid axes is not a valid design grid.
/// right side: the conflict can be resolved by splitting one grid
/// axis in a way, such as no ambiguous intersections exist.
/// 
/// Figure 31 — Grid intersections
/// 
/// Geometry Use Definitions
/// The geometric representation of IfcGrid is given by the
/// IfcProductDefinitionShape, allowing geometric
/// representations. Included are:
/// Local Placement
/// The local placement for IfcGrid is defined in its
/// supertype IfcProduct. It is defined by the
/// IfcLocalPlacement, which defines the local coordinate system
/// that is referenced by all geometric representations.
/// 
/// The PlacementRelTo relationship of
/// IfcLocalPlacement shall point (if given) to the local
/// placement of the same IfcSpatialStructureElement, which is
/// used in the ContainedInStructure inverse attribute, or to a
/// spatial structure element at a higher level, referenced by
/// that.
/// If the relative placement is not used, the absolute placement
/// is defined within the world coordinate system.
/// 
/// Geometric Representations
/// Currently, the use of a 2D 'FootPrint' representation of type
/// 'GeometricCurveSet' is supported.
/// GeometricCurveSet representation
/// The 2D geometric representation of IfcGrid is defined
/// using the 'GeometricCurveSet' geometry. The following attribute
/// values should be inserted
/// 
/// IfcShapeRepresentation.RepresentationIdentifier =
/// 'FootPrint'.
/// IfcShapeRepresentation.RepresentationType =
/// 'GeometricCurveSet' .
/// 
/// The following constraints apply to the 2D representation:
/// 
/// The IfcGeometricCurveSet shall be an (and the only)
/// Item of the IfcShapeRepresentation. It should contain
/// an IfcGeometricCurveSet containing subtypes of
/// IfcCurve, each representing a grid axis. Applicable subtypes
/// of IfcCurve are: IfcPolyline, IfcCircle,
/// IfcTrimmedCurve (based on BaseCurve referencing
/// IfcLine or IfcCircle). 
/// Each subtype of IfcCurve may have a curve style
/// assigned, using IfcAnnotationCurveOccurrence referencing
/// IfcCurveStyle.
/// Optionally the grid axis labels may be added as
/// IfcTextLiteral, and they may have text styles assigned,
/// using IfcAnnotationTextOccurrence referencing
/// IfcTextStyle.
/// 
/// As shown in Figure 32, the IfcGrid defines a placement coordinate system using the ObjectPlacement. The XY plane of the coordinate system is used to place the 2D grid axes. The Representation of IfcGrid is defined using IfcProductRepresentation, referencing an IfcShapeRepresentation, that includes IfcGeometricCurveSet as Items. All grid axes are added as IfcPolyline to the IfcGeometricCurveSet.
/// 
/// Figure 32 — Grid layout
/// 
/// As shown in Figure 33, the attributes UAxes and VAxes define lists of IfcGridAxis within the context of the grid. Each instance of IfcGridAxis refers to the same instance of IfcCurve (here the subtype IfcPolyline) that is contained within the IfcGeometricCurveSet that represents the IfcGrid.
/// 
/// Figure 33 — Grid representation
class IFC_PARSE_API IfcGrid : public IfcProduct {
public:
    /// List of grid axes defining the first row of grid lines.
    IfcTemplatedEntityList< IfcGridAxis >::ptr UAxes() const;
    void setUAxes(IfcTemplatedEntityList< IfcGridAxis >::ptr v);
    /// List of grid axes defining the second row of grid lines.
    IfcTemplatedEntityList< IfcGridAxis >::ptr VAxes() const;
    void setVAxes(IfcTemplatedEntityList< IfcGridAxis >::ptr v);
    /// Whether the optional attribute WAxes is defined for this IfcGrid
    bool hasWAxes() const;
    /// List of grid axes defining the third row of grid lines. It may be given in the case of a triangular grid.
    IfcTemplatedEntityList< IfcGridAxis >::ptr WAxes() const;
    void setWAxes(IfcTemplatedEntityList< IfcGridAxis >::ptr v);
    /// Whether the optional attribute PredefinedType is defined for this IfcGrid
    bool hasPredefinedType() const;
    IfcGridTypeEnum::IfcGridTypeEnum PredefinedType() const;
    void setPredefinedType(IfcGridTypeEnum::IfcGridTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 11; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 7: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 8: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 9: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 10: return IfcUtil::Argument_ENUMERATION; } return IfcProduct::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 7: return Type::IfcGridAxis; case 8: return Type::IfcGridAxis; case 9: return Type::IfcGridAxis; case 10: return Type::IfcGridTypeEnum; } return IfcProduct::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 7: return "UAxes"; case 8: return "VAxes"; case 9: return "WAxes"; case 10: return "PredefinedType"; } return IfcProduct::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcRelContainedInSpatialStructure >::ptr ContainedInStructure() const; // INVERSE IfcRelContainedInSpatialStructure::RelatedElements
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcGrid (IfcEntityInstanceData* e);
    IfcGrid (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, IfcTemplatedEntityList< IfcGridAxis >::ptr v8_UAxes, IfcTemplatedEntityList< IfcGridAxis >::ptr v9_VAxes, boost::optional< IfcTemplatedEntityList< IfcGridAxis >::ptr > v10_WAxes, boost::optional< IfcGridTypeEnum::IfcGridTypeEnum > v11_PredefinedType);
    typedef IfcTemplatedEntityList< IfcGrid > list;
};
/// IfcGroup is an generalization of any arbitrary group. A group is a logical collection of objects. It does not have its own position, nor can it hold its own shape representation. Therefore a group is an aggregation under some non-geometrical / topological grouping aspects.
/// 
/// NOTE Use IfcRelDecomposes together with the appropriate subtypes of IfcProduct to define an aggregation of products that may have its own position and shape representation.
/// 
/// EXAMPLE An example for a group is a system, since it groups elements under the aspect of their role, regardless of their position in a building.
/// 
/// A group can hold any collection of objects (beingÿproducts, processes, controls, resources, actors or other groups). Thus groups can be nested. An object can be part of zero, one, or many groups. Grouping relationships are not required to be hierarchical nor do they imply a dependency.
/// 
/// NOTE Use IfcRelDecomposes together with the appropriate subtypes of IfcProduct to define an hierarchical aggregation of products.
/// 
/// A group can be exchanged without having already objects within the group collection.
/// 
/// HISTORY New entity in IFC Release 1.0.
/// 
/// IFC2x4 CHANGE The inverse IsGroupedBy relationship is set to 0..n
/// 
/// Relationship use definition
/// The group collection is handled by an instance of IfcRelAssignsToGroup, which assigns all group members to the IfcGroup.
/// 
/// Objects: included in group using IfcRelAssignsToGroup
/// 
/// Groups are assigned to other objects (such as a process or a resource) by the relationship object that refers to the corresponding
/// object:
/// 
/// Process: assigned using IfcRelAssignsToProcess
/// Resource: assigned using IfcRelAssignsToResource
/// 
/// Groups can be subjected to a control. The control information is then assigned:
/// 
/// Controls: affecting the group using IfcRelAssignsToControl
class IFC_PARSE_API IfcGroup : public IfcObject {
public:
    virtual unsigned int getArgumentCount() const { return 5; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcObject::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcObject::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcObject::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcRelAssignsToGroup >::ptr IsGroupedBy() const; // INVERSE IfcRelAssignsToGroup::RelatingGroup
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcGroup (IfcEntityInstanceData* e);
    IfcGroup (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType);
    typedef IfcTemplatedEntityList< IfcGroup > list;
};
/// The energy conversion device type IfcHeatExchangerType defines commonly shared information for occurrences of heat exchangers.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a heat exchanger specification (i.e. the specific product information, that is common to all occurrences of that product type).  Heat Exchanger types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcHeatExchangerType are represented by instances of IfcHeatExchanger. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcEnergyConversionDeviceType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_HeatExchangerTypeCommon 
/// 
/// The following property set definitions are applicable to this entity according to the PredefinedType attribute:  
/// Pset_HeatExchangerTypePlate (PLATE) 
/// 
/// Material Use Definition 
/// The material of the IfcHeatExchangerType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Shell': Material used to construct the shell of the heat exchanger. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcHeatExchangerType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcHeatExchanger for standard port definitions.
class IFC_PARSE_API IfcHeatExchangerType : public IfcEnergyConversionDeviceType {
public:
    /// Defines the basic types of heat exchanger (e.g., plate, shell and tube, etc.).
    IfcHeatExchangerTypeEnum::IfcHeatExchangerTypeEnum PredefinedType() const;
    void setPredefinedType(IfcHeatExchangerTypeEnum::IfcHeatExchangerTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcEnergyConversionDeviceType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcHeatExchangerTypeEnum; } return IfcEnergyConversionDeviceType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcEnergyConversionDeviceType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcHeatExchangerType (IfcEntityInstanceData* e);
    IfcHeatExchangerType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcHeatExchangerTypeEnum::IfcHeatExchangerTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcHeatExchangerType > list;
};
/// The energy conversion device type IfcHumidifierType defines commonly shared information for occurrences of humidifiers.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a humidifier specification (i.e. the specific product information, that is common to all occurrences of that product type).  Humidifier types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcHumidifierType are represented by instances of IfcHumidifier. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcEnergyConversionDeviceType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_HumidifierTypeCommon 
/// 
/// Material Use Definition 
/// The material of the IfcHumidifierType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Casing': Material from which the casing is constructed. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcHumidifierType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcHumidifier for standard port definitions.
class IFC_PARSE_API IfcHumidifierType : public IfcEnergyConversionDeviceType {
public:
    /// Defines the type of humidifier.
    IfcHumidifierTypeEnum::IfcHumidifierTypeEnum PredefinedType() const;
    void setPredefinedType(IfcHumidifierTypeEnum::IfcHumidifierTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcEnergyConversionDeviceType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcHumidifierTypeEnum; } return IfcEnergyConversionDeviceType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcEnergyConversionDeviceType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcHumidifierType (IfcEntityInstanceData* e);
    IfcHumidifierType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcHumidifierTypeEnum::IfcHumidifierTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcHumidifierType > list;
};

class IFC_PARSE_API IfcIndexedPolyCurve : public IfcBoundedCurve {
public:
    IfcCartesianPointList* Points() const;
    void setPoints(IfcCartesianPointList* v);
    /// Whether the optional attribute Segments is defined for this IfcIndexedPolyCurve
    bool hasSegments() const;
    IfcEntityList::ptr Segments() const;
    void setSegments(IfcEntityList::ptr v);
    /// Whether the optional attribute SelfIntersect is defined for this IfcIndexedPolyCurve
    bool hasSelfIntersect() const;
    bool SelfIntersect() const;
    void setSelfIntersect(bool v);
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 2: return IfcUtil::Argument_BOOL; } return IfcBoundedCurve::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcCartesianPointList; case 1: return Type::IfcSegmentIndexSelect; case 2: return Type::IfcBoolean; } return IfcBoundedCurve::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Points"; case 1: return "Segments"; case 2: return "SelfIntersect"; } return IfcBoundedCurve::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcIndexedPolyCurve (IfcEntityInstanceData* e);
    IfcIndexedPolyCurve (IfcCartesianPointList* v1_Points, boost::optional< IfcEntityList::ptr > v2_Segments, boost::optional< bool > v3_SelfIntersect);
    typedef IfcTemplatedEntityList< IfcIndexedPolyCurve > list;
};
/// The flow treatment device type IfcInterceptorType defines commonly shared information for occurrences of interceptors.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a interceptor specification (i.e. the specific product information, that is common to all occurrences of that product type).  Interceptor types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcInterceptorType are represented by instances of IfcInterceptor. 
/// 
/// HISTORY: New entity in IFC2x4 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcFlowTreatmentDeviceType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_InterceptorTypeCommon 
/// 
/// The following property set definitions are applicable to this entity according to the PredefinedType attribute:  
/// Pset_InterceptorTypeGrease (GREASE) 
/// Pset_InterceptorTypeOil (OIL) 
/// Pset_InterceptorTypePetrol (PETROL) 
/// 
/// Material Use Definition 
/// The material of the IfcInterceptorType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Body': The primary material from which the object is constructed. 
/// 'Cover': Material from which the cover or grating is constructed. 
/// 'Strainer': Material from which the strainer is constructed. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcInterceptorType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcInterceptor for standard port definitions.
class IFC_PARSE_API IfcInterceptorType : public IfcFlowTreatmentDeviceType {
public:
    IfcInterceptorTypeEnum::IfcInterceptorTypeEnum PredefinedType() const;
    void setPredefinedType(IfcInterceptorTypeEnum::IfcInterceptorTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcFlowTreatmentDeviceType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcInterceptorTypeEnum; } return IfcFlowTreatmentDeviceType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcFlowTreatmentDeviceType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcInterceptorType (IfcEntityInstanceData* e);
    IfcInterceptorType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcInterceptorTypeEnum::IfcInterceptorTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcInterceptorType > list;
};

class IFC_PARSE_API IfcIntersectionCurve : public IfcSurfaceCurve {
public:
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcSurfaceCurve::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcSurfaceCurve::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcSurfaceCurve::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcIntersectionCurve (IfcEntityInstanceData* e);
    IfcIntersectionCurve (IfcCurve* v1_Curve3D, IfcTemplatedEntityList< IfcPcurve >::ptr v2_AssociatedGeometry, IfcPreferredSurfaceCurveRepresentation::IfcPreferredSurfaceCurveRepresentation v3_MasterRepresentation);
    typedef IfcTemplatedEntityList< IfcIntersectionCurve > list;
};
/// An inventory is a list of items within an enterprise. 
/// 
/// Various types of inventory can be included. These are identified by the range of values within the inventory type enumeration which includes space, asset, and furniture. User defined inventories can also be defined for lists of particular types of element such as may be required in operating and maintenance instructions. Such inventories should be constrained to contain a list of elements of a restricted type.There are a number of actors that can be associated with an inventory, each actor having a role. Actors within the scope of the project are indicated using the IfcRelAssignsToActor relationship in which case roles should be defined through the IfcActorRole class; otherwise principal actors are identified as attributes of the class. In the existence of both, direct attributes take precedence.There are a number of costs that can be associated with an inventory, each cost having a role. These are specified through the CurrentValue and OriginalValue attributes.HISTORY: New entity in IFC2.0.  Modified in IFC2x4 to make all attributes optional and remove Where Rule. 
/// 
/// Assignment Use Definition 
///   The IfcInventory may have assignments of its own using the IfcRelAssignsToGroup relationship where RelatingGroup refers to the IfcInventory and RelatedObjects contains one or more objects of the following types:  
/// IfcAsset: Assets included in the inventory.
/// 
/// IfcElement: Elements such as furniture included in the inventory.
/// 
/// IfcSpace: Spaces included in the inventory.
class IFC_PARSE_API IfcInventory : public IfcGroup {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcInventory
    bool hasPredefinedType() const;
    /// A list of the types of inventories from which that required may be selected.
    /// 
    /// IFC2x4 CHANGE Attribute made optional.
    IfcInventoryTypeEnum::IfcInventoryTypeEnum PredefinedType() const;
    void setPredefinedType(IfcInventoryTypeEnum::IfcInventoryTypeEnum v);
    /// Whether the optional attribute Jurisdiction is defined for this IfcInventory
    bool hasJurisdiction() const;
    /// The organizational unit to which the inventory is applicable.
    IfcActorSelect* Jurisdiction() const;
    void setJurisdiction(IfcActorSelect* v);
    /// Whether the optional attribute ResponsiblePersons is defined for this IfcInventory
    bool hasResponsiblePersons() const;
    /// Persons who are responsible for the inventory.
    IfcTemplatedEntityList< IfcPerson >::ptr ResponsiblePersons() const;
    void setResponsiblePersons(IfcTemplatedEntityList< IfcPerson >::ptr v);
    /// Whether the optional attribute LastUpdateDate is defined for this IfcInventory
    bool hasLastUpdateDate() const;
    /// The date on which the last update of the inventory was carried out.
    /// 
    /// IFC2x4 CHANGE Type changed from IfcDateTimeSelect.
    std::string LastUpdateDate() const;
    void setLastUpdateDate(std::string v);
    /// Whether the optional attribute CurrentValue is defined for this IfcInventory
    bool hasCurrentValue() const;
    /// An estimate of the current cost value of the inventory.
    IfcCostValue* CurrentValue() const;
    void setCurrentValue(IfcCostValue* v);
    /// Whether the optional attribute OriginalValue is defined for this IfcInventory
    bool hasOriginalValue() const;
    /// An estimate of the original cost value of the inventory.
    IfcCostValue* OriginalValue() const;
    void setOriginalValue(IfcCostValue* v);
    virtual unsigned int getArgumentCount() const { return 11; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 5: return IfcUtil::Argument_ENUMERATION; case 6: return IfcUtil::Argument_ENTITY_INSTANCE; case 7: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 8: return IfcUtil::Argument_STRING; case 9: return IfcUtil::Argument_ENTITY_INSTANCE; case 10: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcGroup::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 5: return Type::IfcInventoryTypeEnum; case 6: return Type::IfcActorSelect; case 7: return Type::IfcPerson; case 8: return Type::IfcDate; case 9: return Type::IfcCostValue; case 10: return Type::IfcCostValue; } return IfcGroup::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 5: return "PredefinedType"; case 6: return "Jurisdiction"; case 7: return "ResponsiblePersons"; case 8: return "LastUpdateDate"; case 9: return "CurrentValue"; case 10: return "OriginalValue"; } return IfcGroup::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcInventory (IfcEntityInstanceData* e);
    IfcInventory (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, boost::optional< IfcInventoryTypeEnum::IfcInventoryTypeEnum > v6_PredefinedType, IfcActorSelect* v7_Jurisdiction, boost::optional< IfcTemplatedEntityList< IfcPerson >::ptr > v8_ResponsiblePersons, boost::optional< std::string > v9_LastUpdateDate, IfcCostValue* v10_CurrentValue, IfcCostValue* v11_OriginalValue);
    typedef IfcTemplatedEntityList< IfcInventory > list;
};
/// The flow fitting type IfcJunctionBoxType defines commonly shared information for occurrences of junction boxs.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a junction box specification (i.e. the specific product information, that is common to all occurrences of that product type).  Junction Box types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcJunctionBoxType are represented by instances of IfcJunctionBox. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcFlowFittingType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_ElectricalDeviceCommon 
/// Pset_JunctionBoxTypeCommon 
/// 
/// Material Use Definition 
/// The material of the IfcJunctionBoxType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Casing': Material from which the casing is constructed. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcJunctionBoxType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcJunctionBox for standard port definitions.
class IFC_PARSE_API IfcJunctionBoxType : public IfcFlowFittingType {
public:
    /// Identifies the predefined types of junction boxes from which the type required may be set.
    IfcJunctionBoxTypeEnum::IfcJunctionBoxTypeEnum PredefinedType() const;
    void setPredefinedType(IfcJunctionBoxTypeEnum::IfcJunctionBoxTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcFlowFittingType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcJunctionBoxTypeEnum; } return IfcFlowFittingType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcFlowFittingType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcJunctionBoxType (IfcEntityInstanceData* e);
    IfcJunctionBoxType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcJunctionBoxTypeEnum::IfcJunctionBoxTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcJunctionBoxType > list;
};
/// An IfcLaborResource is used in construction with particular skills or crafts required to perform certain types of construction or management related work.  
/// 
/// HISTORY: New Entity in IFC Release 2.0.  Base type and documentation extended in IFC 2x4.
/// 
/// IFC2x4 CHANGE: The attribute Skillset has been deleted; use LongDescription to describe the skillset.
/// 
/// The purpose of an IfcLaborResource is to identify a skillset that may be required or used. The skillset identified may be (for instance) chargehand, foreman, labourer, plumbers mate etc. and provides a designation of a particular level of skill. It can be used to identify the generic type of labor resource that is required for a purpose without having to be specific about the actor (person or organization) providing the resource occurrence. It may be particularly useful when creating an overall plan for a process or processes. For instance, within maintenance or work planning there may be a known task that needs to be done which is planned to require a 'chargehand pipe fitter'. There may be several such labor resources available and so the need to identify which will be used is not necessary at the planning stage.
/// 
/// At a later stage, individual actors can be determined for the labor resources. This is achieved through specifiying the actor through IfcActor. The actor is then identified as the labour resource occurrence through the IfcRelAssignsToResource.RelatedResource attribute. The IfcLaborResource provides the IfcRelAssignsToResource.RelatingResource attribute. 
/// 
/// Use definitions for composition, assignment, constraints, time series, and baselines are described at the base type IfcConstructionResource.
/// 
/// Type use definition
/// IfcLaborResource defines the occurrence of any labor resource; common information about labor resource types is handled by IfcLaborResourceType.  The IfcLaborResourceType (if present) may establish the common type name, common properties, common productivities for various task types using IfcRelAssignsToProcess.  The IfcLaborResourceType is attached using the IfcRelDefinesByType.RelatingType objectified relationship and is accessible by the inverse IsTypedBy attribute.
/// 
/// Quantity use definition
/// The quantities relating to the IfcLaborResource are defined by IfcElementQuantity and attached by the IfcRelDefinesByProperties relationship. It is accessible by the inverse IsDefinedBy relationship. The following base quantities are defined and should be exchanged with the IfcElementQuantity.Name = 'BaseQuantities'. Other quantities can be defined being subjected to local standard of measurement with another string value assigned to Name and a value provided for MethodOfMeasurement.
/// 
/// Qto_LaborResourceBaseQuantities: base quantities for all labor resources.
/// 
/// Assignment use definition
/// In addition to assignments specified at the base class IfcConstructionResource, a labor resource may have assignments of its own using IfcRelAssignsToResource where RelatingResource refers to the IfcLaborResource and RelatedObjects contains one or more IfcActor subtypes as shown in Figure 194.  Such relationship indicates the specific people used as input for the resource.  Such actors are nested according to organizational structure with the root organization assigned to the IfcProject.  The IfcActor entity is used to represent the people or organizations.
/// 
/// Figure 194 — Labor resource assignment use
class IFC_PARSE_API IfcLaborResource : public IfcConstructionResource {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcLaborResource
    bool hasPredefinedType() const;
    /// Defines types of labor resources.
    /// IFC2x4 New attribute
    IfcLaborResourceTypeEnum::IfcLaborResourceTypeEnum PredefinedType() const;
    void setPredefinedType(IfcLaborResourceTypeEnum::IfcLaborResourceTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 11; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 10: return IfcUtil::Argument_ENUMERATION; } return IfcConstructionResource::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 10: return Type::IfcLaborResourceTypeEnum; } return IfcConstructionResource::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 10: return "PredefinedType"; } return IfcConstructionResource::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcLaborResource (IfcEntityInstanceData* e);
    IfcLaborResource (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, boost::optional< std::string > v6_Identification, boost::optional< std::string > v7_LongDescription, IfcResourceTime* v8_Usage, boost::optional< IfcTemplatedEntityList< IfcAppliedValue >::ptr > v9_BaseCosts, IfcPhysicalQuantity* v10_BaseQuantity, boost::optional< IfcLaborResourceTypeEnum::IfcLaborResourceTypeEnum > v11_PredefinedType);
    typedef IfcTemplatedEntityList< IfcLaborResource > list;
};
/// The flow terminal type IfcLampType defines commonly shared information for occurrences of lamps.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a lamp specification (i.e. the specific product information, that is common to all occurrences of that product type).  Lamp types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcLampType are represented by instances of IfcLamp. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcFlowTerminalType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_ElectricalDeviceCommon 
/// Pset_LampTypeCommon 
/// 
/// Material Use Definition 
/// The material of the IfcLampType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Bulb': Material from which the bulb is constructed (e.g. glass). 
/// 'Conductor': Material from which the conductor is constructed. 
/// 'Filament': Material from which the filament is constructed. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcLampType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcLamp for standard port definitions.
class IFC_PARSE_API IfcLampType : public IfcFlowTerminalType {
public:
    /// Identifies the predefined types of lamp from which the type required may be set.
    IfcLampTypeEnum::IfcLampTypeEnum PredefinedType() const;
    void setPredefinedType(IfcLampTypeEnum::IfcLampTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcFlowTerminalType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcLampTypeEnum; } return IfcFlowTerminalType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcFlowTerminalType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcLampType (IfcEntityInstanceData* e);
    IfcLampType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcLampTypeEnum::IfcLampTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcLampType > list;
};
/// The flow terminal type IfcLightFixtureType defines commonly shared information for occurrences of light fixtures.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a light fixture specification (i.e. the specific product information, that is common to all occurrences of that product type).  Light Fixture types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcLightFixtureType are represented by instances of IfcLightFixture. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcFlowTerminalType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_ElectricalDeviceCommon 
/// Pset_LightFixtureTypeCommon 
/// Pset_LightFixtureTypeThermal 
/// 
/// The following property set definitions are applicable to this entity according to the PredefinedType attribute:  
/// Pset_LightFixtureTypeSecurityLighting (SECURITYLIGHTING) 
/// 
/// Material Use Definition 
/// The material of the IfcLightFixtureType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Casing': Material from which the casing is constructed. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcLightFixtureType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcLightFixture for standard port definitions.
class IFC_PARSE_API IfcLightFixtureType : public IfcFlowTerminalType {
public:
    /// Identifies the predefined types of light fixture from which the type required may be set.
    IfcLightFixtureTypeEnum::IfcLightFixtureTypeEnum PredefinedType() const;
    void setPredefinedType(IfcLightFixtureTypeEnum::IfcLightFixtureTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcFlowTerminalType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcLightFixtureTypeEnum; } return IfcFlowTerminalType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcFlowTerminalType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcLightFixtureType (IfcEntityInstanceData* e);
    IfcLightFixtureType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcLightFixtureTypeEnum::IfcLightFixtureTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcLightFixtureType > list;
};
/// Definition from IAI: Fasteners connecting building elements mechanically.  A single instance of this class may represent one or many of actual mechanical fasteners, for example an array of bolts or a row of nails.
/// 
/// HISTORY New entity in IFC Release 2x2
/// 
/// IFC 2x4 change:
/// Supertype changed from IfcFastener to IfcElementComponent.
/// Attribute PredefinedType added.
/// Attributes NominalDiameter and NominalLength moved to IfcMechanicalFastenerType.
/// 
/// Geometry Use Definition
/// 
/// See definitions at the supertype IfcElementComponent.
/// 
/// In addition, a symbolic representation is defined for a row of fasteners or several rows of
/// fasteners within a single instance of IfcMechanicalFastener.  Such rows or arrays may
/// contain possibly large numbers of individual pieces.  The product definition shape consists of
/// an IfcShapeRepresentation with the attribute values
/// 
/// RepresentationIdentifier : 'Row'
///   RepresentationType : 'GeometricCurveSet'
/// 
/// and one or several curves as geometric items.  The curves represent where the heads of the fasteners
/// are located.  The local placement of the IfcMechanicalFastener shall be located and oriented such
/// that the local z axis is parallel with the axes of the fasteners (bolts, nails, staples or similar).
/// 
/// In case of such a symbolic 'Row' representation, an IfcElementQuantity should be attached to
/// the IfcMechanicalFastener via IfcRelDefinesByProperties.  The quantity should contain an
/// IfcQuantityCount named 'Count' with the number of fasteners and an IfcQuantityLength
/// named 'Spacing' which expresses the center-to-center distances of fasteners.
class IFC_PARSE_API IfcMechanicalFastener : public IfcElementComponent {
public:
    /// Whether the optional attribute NominalDiameter is defined for this IfcMechanicalFastener
    bool hasNominalDiameter() const;
    double NominalDiameter() const;
    void setNominalDiameter(double v);
    /// Whether the optional attribute NominalLength is defined for this IfcMechanicalFastener
    bool hasNominalLength() const;
    double NominalLength() const;
    void setNominalLength(double v);
    /// Whether the optional attribute PredefinedType is defined for this IfcMechanicalFastener
    bool hasPredefinedType() const;
    /// Subtype of mechanical fastener
    IfcMechanicalFastenerTypeEnum::IfcMechanicalFastenerTypeEnum PredefinedType() const;
    void setPredefinedType(IfcMechanicalFastenerTypeEnum::IfcMechanicalFastenerTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 11; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_DOUBLE; case 9: return IfcUtil::Argument_DOUBLE; case 10: return IfcUtil::Argument_ENUMERATION; } return IfcElementComponent::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcPositiveLengthMeasure; case 9: return Type::IfcPositiveLengthMeasure; case 10: return Type::IfcMechanicalFastenerTypeEnum; } return IfcElementComponent::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "NominalDiameter"; case 9: return "NominalLength"; case 10: return "PredefinedType"; } return IfcElementComponent::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcMechanicalFastener (IfcEntityInstanceData* e);
    IfcMechanicalFastener (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< double > v9_NominalDiameter, boost::optional< double > v10_NominalLength, boost::optional< IfcMechanicalFastenerTypeEnum::IfcMechanicalFastenerTypeEnum > v11_PredefinedType);
    typedef IfcTemplatedEntityList< IfcMechanicalFastener > list;
};
/// Definition from IAI: The element type (IfcMechanicalFastenerType) defines a list of commonly shared property set definitions of a fastener and an optional set of product representations. It is used to define mechanical fasteners mainly within structural and building services domains (i.e. the specific type information common to all occurrences of that type). 
/// 
/// The occurrences of the IfcMechanicalFastenerType are represented by instances of IfcMechanicalFastener. 
/// 
/// HISTORY New entity in IFC Release 2x2
/// 
/// IFC 2x4 change:
/// Supertype changed from IfcFastenerType to IfcElementComponentType.
/// Attributes PredefinedType, NominalDiameter, NominalLength added.
/// 
/// Mechanical fasteners, especially bolts, are often standardized.  To refer to a formal fastener
/// designation according to a standard (a product norm), IfcRelAssociatesClassification together
/// with IfcClassificationReference should be used.
/// 
/// IfcClassificationReference.ItemReference
/// contains a machine-readable form of the formal fastener designation from the norm.
/// Example: 'M16X80-10.9-HV' for a high-strength structural bolting assembly for preloading with
/// hexagon bolt and nut.  (On the other hand, IfcMechanicalFastenerType.Name contains a
/// displayable name which may not necessarily be the same as the formal designation.)
/// IfcClassificationReference.Name carries the short name of the fastener norm.
/// Example: 'EN 14399-4' as the respective European standard for high-strength hexagon bolts.
/// Optionally, the norm can be further described by
/// IfcClassificationReference.ReferencedSource, including information like publisher and
/// date of issue of the norm.
/// 
/// Furthermore, IfcRelAssociatesLibrary together with IfcLibraryReference may be
/// used to refer to a library which contains fastener definitions.
/// 
/// Property Set Use Definition
/// 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.
/// 
/// The following property set definitions are applicable to this entity according to the PredefinedType attribute:
/// 
/// Pset_MechanicalFastenerBolt (BOLT)
class IFC_PARSE_API IfcMechanicalFastenerType : public IfcElementComponentType {
public:
    /// Subtype of mechanical fastener
    IfcMechanicalFastenerTypeEnum::IfcMechanicalFastenerTypeEnum PredefinedType() const;
    void setPredefinedType(IfcMechanicalFastenerTypeEnum::IfcMechanicalFastenerTypeEnum v);
    /// Whether the optional attribute NominalDiameter is defined for this IfcMechanicalFastenerType
    bool hasNominalDiameter() const;
    /// The nominal diameter describing the cross-section size of the fastener type.
    double NominalDiameter() const;
    void setNominalDiameter(double v);
    /// Whether the optional attribute NominalLength is defined for this IfcMechanicalFastenerType
    bool hasNominalLength() const;
    /// The nominal length describing the longitudinal dimensions of the fastener type.
    double NominalLength() const;
    void setNominalLength(double v);
    virtual unsigned int getArgumentCount() const { return 12; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; case 10: return IfcUtil::Argument_DOUBLE; case 11: return IfcUtil::Argument_DOUBLE; } return IfcElementComponentType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcMechanicalFastenerTypeEnum; case 10: return Type::IfcPositiveLengthMeasure; case 11: return Type::IfcPositiveLengthMeasure; } return IfcElementComponentType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; case 10: return "NominalDiameter"; case 11: return "NominalLength"; } return IfcElementComponentType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcMechanicalFastenerType (IfcEntityInstanceData* e);
    IfcMechanicalFastenerType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcMechanicalFastenerTypeEnum::IfcMechanicalFastenerTypeEnum v10_PredefinedType, boost::optional< double > v11_NominalDiameter, boost::optional< double > v12_NominalLength);
    typedef IfcTemplatedEntityList< IfcMechanicalFastenerType > list;
};
/// The flow terminal type IfcMedicalDeviceType defines commonly shared information for occurrences of medical devices.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a medical device specification (i.e. the specific product information, that is common to all occurrences of that product type).  Medical Device types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcMedicalDeviceType are represented by instances of IfcMedicalDevice. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcFlowTerminalType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_MedicalDeviceTypeCommon 
/// 
/// Material Use Definition 
/// The material of the IfcMedicalDeviceType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Body': The primary material from which the object is constructed. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcMedicalDeviceType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcMedicalDevice for standard port definitions.
class IFC_PARSE_API IfcMedicalDeviceType : public IfcFlowTerminalType {
public:
    IfcMedicalDeviceTypeEnum::IfcMedicalDeviceTypeEnum PredefinedType() const;
    void setPredefinedType(IfcMedicalDeviceTypeEnum::IfcMedicalDeviceTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcFlowTerminalType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcMedicalDeviceTypeEnum; } return IfcFlowTerminalType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcFlowTerminalType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcMedicalDeviceType (IfcEntityInstanceData* e);
    IfcMedicalDeviceType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcMedicalDeviceTypeEnum::IfcMedicalDeviceTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcMedicalDeviceType > list;
};
/// Definition from IAI: The element type
/// IfcMemberType defines commonly shared information for
/// occurrences of members. Members are predominately linear building
/// elements, often forming part of a structural system. The
/// orientation of the member (being horizontal, vertical or sloped)
/// is not relevant to its definition (in contrary to beam and
/// column). The set of shared information may include:
/// 
/// common properties within shared property sets
/// common material information
/// common profile definitions
/// common shape representations
/// 
/// It is used to define a member specification, or member style
/// (i.e. the specific product information that is common to all
/// occurrences of that member type). Member types may be exchanged
/// without being already assigned to occurrences.
/// Occurrences of the IfcMemberType within building models
/// are represented by instances of IfcMemberStandardCase if
/// the IfcMemberType has a single associated
/// IfcMaterialProfileSet; otherwise they are represented by
/// instances of IfcMember. Occurrences of the
/// IfcMemberType within structural analysis models are
/// represented by instances of IfcStructuralCurveMember, or
/// its applicable subtypes.
/// HISTORY New entity in
/// Release IFC2x2 Addendum 1.
/// Material Use Definition
/// The material of the IfcMemberType is defined by the
/// IfcMaterialProfileSet or as fall back by
/// IfcMaterial and attached by the
/// IfcRelAssociatesMaterial.RelatingMaterial. It is
/// accessible by the inverse HasAssociations
/// relationship.
/// Note: It is illegal to assign an
/// IfcMaterial to an IfcMemberType, if there is at
/// least one occurrences of IfcMemberStandardCase for this
/// type.
/// Property Set Use Definition:
/// The shared property sets relating to the IfcMemberType
/// are defined by the IfcPropertySet and are attached by the
/// HasPropertySets attribute. The following property set
/// definitions specific to the IfcMemberType are part of this
/// IFC release:
/// NOTE There is no differentiation between
/// properties within the property set that are only assignable to
/// IfcMemberType and those that are only assignable to
/// IfcMember. If the same property is assigned to the
/// IfcMemberType and the IfcMember being an occurrence
/// of the IfcMemberType, then the occurrence property
/// overrides the type property.
/// 
/// Pset_MemberCommon: common property set for all
/// member types.
/// 
/// Profile Use Definition:
/// The shared profile definition is defined by assigning an
/// IfcMaterialProfileSet (see material use definition above).
/// The IfcMaterialProfile refers to the subtype of
/// IfcProfileDef that is the common profile for all member
/// occurrence, if used. It is only applicable if the
/// IfcMemberType has only occurrences of type
/// IfcMemberStandardCase (see definition of
/// IfcMemberStandardCase for further information).
/// NOTE The attribute ProfileName of the
/// IfcProfileDef subtype, referenced in
/// IfcMaterialProfile should contain a standardized profile
/// name according to local standards. However, an additional
/// geometric representation of the profile is necessary (e.g. as
/// IfcExtrudedAreaSolid). An importing application is allowed
/// to check for the existence of the profile name: in case of
/// identifying it as a standardized name, the corresponding profile
/// geometry and possibly other cross sectional properties can be
/// read from a library. Otherwise the geometric representation and
/// possible non geometric IfcProfileProperties have to be
/// used.
/// Geometry Use Definition:
/// The IfcMemberType may define the shared geometric
/// representation for all member occurrences. The
/// RepresentationMaps attribute refers to a list of
/// IfcRepresentationMap's, that allow for multiple geometric
/// representations (e.g. with IfcShaperepresentation's having
/// an RepresentationIdentifier 'Box', 'Axis', or 'Body'). It
/// is only applicable if the IfcMemberType has only
/// occurrences of type IfcMember (See geometric use
/// definition of IfcMember for further information).
/// NOTE If the IfcMemberType has an
/// associated IfcMaterialProfileSet, then no shared geometric
/// representation shall be provided.
/// NOTE The product shape representations are
/// defined as RepresentationMaps (attribute of the supertype
/// IfcTypeProduct), which get assigned by an element
/// occurrence instance through the
/// IfcShapeRepresentation.Item[n] being an
/// IfcMappedItem. See IfcTypeProduct for further
/// information.
/// NOTE The values of attributes
/// RepresentationIdentifier and RepresentationType of
/// IfcShapeRepresentation are restricted in the same way as
/// those for IfcMember and
/// IfcMemberStandardCase
class IFC_PARSE_API IfcMemberType : public IfcBuildingElementType {
public:
    /// Identifies the predefined types of a linear structural member element from which the type required may be set.
    IfcMemberTypeEnum::IfcMemberTypeEnum PredefinedType() const;
    void setPredefinedType(IfcMemberTypeEnum::IfcMemberTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcBuildingElementType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcMemberTypeEnum; } return IfcBuildingElementType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcBuildingElementType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcMemberType (IfcEntityInstanceData* e);
    IfcMemberType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcMemberTypeEnum::IfcMemberTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcMemberType > list;
};
/// The energy conversion device type IfcMotorConnectionType defines commonly shared information for occurrences of motor connections.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a motor connection specification (i.e. the specific product information, that is common to all occurrences of that product type).  Motor Connection types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcMotorConnectionType are represented by instances of IfcMotorConnection. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcEnergyConversionDeviceType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_ElectricalDeviceCommon 
/// Pset_MotorConnectionTypeCommon 
/// 
/// Material Use Definition 
/// The material of the IfcMotorConnectionType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Casing': Material from which the casing is constructed. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcMotorConnectionType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcMotorConnection for standard port definitions.
class IFC_PARSE_API IfcMotorConnectionType : public IfcEnergyConversionDeviceType {
public:
    /// Identifies the predefined types of motor connection from which the type required may be set.
    IfcMotorConnectionTypeEnum::IfcMotorConnectionTypeEnum PredefinedType() const;
    void setPredefinedType(IfcMotorConnectionTypeEnum::IfcMotorConnectionTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcEnergyConversionDeviceType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcMotorConnectionTypeEnum; } return IfcEnergyConversionDeviceType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcEnergyConversionDeviceType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcMotorConnectionType (IfcEntityInstanceData* e);
    IfcMotorConnectionType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcMotorConnectionTypeEnum::IfcMotorConnectionTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcMotorConnectionType > list;
};
/// An occupant is a type of actor that defines the form of occupancy of a property. 
/// 
/// The principal purpose of IfcOccupant is to determine the nature of occupancy of a property for a particular actor. All characteristics relating to the actor (name and organization details) are inherited from the IfcActor class.HISTORY: New entity in IFC2x 
/// 
/// Assignment Use Definition 
///   The IfcOccupant may have assignments of its own using the IfcRelAssignsToActor relationship where RelatingActor refers to the IfcOccupant and RelatedObjects contains one or more objects of the following types:  
/// IfcSpatialStructureElement: Indicates the property to be occupied. Particular details of the agreement relating to the occupancy of a property are dealt within the Pset_PropertyAgreement that is defined for the instance of IfcSpatialStructureElement. This means that an occupant may be related to a site, building, building storey or space through the IfcSpatialStructureElement.ElementComposition attribute. For instance, if the property concerned is several office spaces on a building storey, it might be appropriate to reference IfcBuildingStorey.ElementComposition=PARTIAL.  Occupants of a property may be considered to be the parties to an agreement. The roles that the occupant may play in respect to an agreement are defined in the IfcOccupantTypeEnum enumeration. If the role is not specified by the predefined contents of this enumeration, the value USERDEFINED may be set and the ObjectType attribute asserted.
class IFC_PARSE_API IfcOccupant : public IfcActor {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcOccupant
    bool hasPredefinedType() const;
    /// Predefined occupant types from which that required may be set.
    /// 
    /// IFC2x4 CHANGE Attribute made optional.
    IfcOccupantTypeEnum::IfcOccupantTypeEnum PredefinedType() const;
    void setPredefinedType(IfcOccupantTypeEnum::IfcOccupantTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 7; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 6: return IfcUtil::Argument_ENUMERATION; } return IfcActor::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 6: return Type::IfcOccupantTypeEnum; } return IfcActor::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 6: return "PredefinedType"; } return IfcActor::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcOccupant (IfcEntityInstanceData* e);
    IfcOccupant (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcActorSelect* v6_TheActor, boost::optional< IfcOccupantTypeEnum::IfcOccupantTypeEnum > v7_PredefinedType);
    typedef IfcTemplatedEntityList< IfcOccupant > list;
};
/// The opening element stands for
/// opening, recess or chase, all reflecting voids. It represents a
/// void within any element that has physical manifestation. Openings
/// can be inserted into walls, slabs, beams, columns, or other
/// elements.
/// The IFC specification provides two entities for opening
/// elements:
/// 
/// IfcOpeningStandardCase is used for all openings that
/// have a constant profile along a linear extrusion. They are placed
/// relative to the voided elements and the extrusion direction is
/// perpendicular to the plane of the element (horizontally for
/// walls, vertically for slabs). Only a single extrusion body is
/// allowed. It cuts through the whole thickness of the voided
/// element, i.e. it reflects a true opening.
/// IfcOpeningElement is used for all other occurrences of
/// openings and in particular also for niches or recesses.
/// 
/// NOTE View definitions or implementer
/// agreements may restrict the types of elements which can be voided
/// by an IfcOpeningElement or
/// IfcOpeningStandardCase
/// There are two different types of opening elements:
/// 
/// an opening, where the thickness of the opening is greater or
/// equal to the thickness of the element;
/// a recess or niche, where the thickness of the recess is
/// smaller than the thickness of the element.
/// 
/// The attribute PredefinedType should be used to capture
/// the differences,
/// 
/// the attribute is set to OPENING for an opening or
/// the attribute is set to RECESS for a recess or niche.
/// If the value for PredefinedType is omitted, or the
/// value is set to NOTDEFINED, no specific information of whether it
/// is an opening or recess shall be assumed.
/// 
/// NOTE Until IFC2x3 the information had been
/// provided by the inherited attribute
/// ObjectType.
/// An IfcOpeningElement has to be inserted into an
/// IfcElement by using the IfcRelVoidsElement
/// relationship. The relationship implies a Boolean subtraction
/// operation between the volume of the voided element and the volume
/// of the opening. It may be filled by an IfcDoor,
/// IfcWindow, or another filling element by using the
/// relationship IfcRelFillsElements.
/// HISTORY New entity in
/// IFC Release 1.0
/// IFC2x CHANGE The intermediate
/// ABSTRACT supertypes IfcFeatureElement and
/// IfcFeatureSubtraction have been added.
/// IFC2x4 CHANGE The attribute
/// PredefinedType has been added at the end of attribute
/// list.
/// Property Set Use Definition:
/// The property sets relating to the IfcOpeningElement are
/// defined by the IfcPropertySet and attached by the
/// IfcRelDefinesByProperties relationship. It is accessible
/// by the inverse IsDefinedBy relationship. The following
/// property set definitions specific to the IfcOpeningElement
/// are part of this IFC release:
/// 
/// Pset_OpeningElementCommon: common property
/// set for all opening occurrences
/// 
/// Quantity Use Definition:
/// The quantities relating to the IfcOpeningElement are
/// defined by the IfcElementQuantity and attached by the
/// IfcRelDefinesByProperties relationship. It is accessible
/// by the inverse IsDefinedBy relationship. The following
/// base quantities are defined and should be exchanged with the
/// IfcElementQuantity.Name = 'BaseQuantities'. Other
/// quantities, being subjected to local standard of measurement, can
/// be defined with another string value assigned to Name. In
/// this case a valid value for MethodOfMeasurement has to be
/// provided.
/// 
/// Qto_OpeningElementBaseQuantities: base
/// quantities for all opening occurrences.
/// 
/// Containment Use Definition
/// The IfcOpeningElement shall not participate in the
/// containment relationship, i.e. it is not linked directly to the
/// spatial structure of the project. It has a mandatory
/// VoidsElements inverse relationship pointing to the
/// IfcElement that is contained in the spatial structure.
/// 
/// The inverse relationship ContainedInStructure shall be
/// NIL.
/// 
/// NOTE See IfcRelVoidsElement for a
/// diagram on how to apply spatial containment and the voiding
/// relationship.
/// Geometry Use Definitions
/// The geometric representation of IfcOpeningElement is
/// given by the IfcProductDefinitionShape and
/// IfcLocalPlacement allowing multiple geometric
/// representations.
/// Local Placement
/// The local placement for IfcOpeningElement is defined in
/// its supertype IfcProduct. It is defined by the
/// IfcLocalPlacement, which defines the local coordinate
/// system that is referenced by all geometric representations.
/// 
/// The PlacementRelTo relationship of
/// IfcLocalPlacement should point to the local placement of
/// the same element, which is voided by the opening, i.e. referred
/// to by VoidsElement.RelatingBuildingElement.
/// 
/// Geometric Representation
/// Currently, the 'Body', and 'Box' representations are
/// supported. The 'Box' representation includes the representation
/// type 'BoundingBox' and is explained at
/// IfcFeatureElement.
/// Body Representation
/// The 'Body' representation of IfcOpeningElement can be
/// represented using the representation types 'SweptSolid', and
/// 'Brep'. The representation type 'Brep' is explained at
/// IfcFeatureElement
/// Swept Solid Representation Type with Horizontal
/// Extrusion
/// The 'SweptSolid' geometric representation of
/// IfcOpeningElement, using horizontal extrusion direction
/// (for walls), is defined using the swept area solid geometry. The
/// following attribute values for the IfcShapeRepresentation
/// holding this geometric representation shall be used:
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'SweptSolid'
/// 
/// The following additional constraints apply to the swept solid
/// representation:
/// 
/// Solid: IfcExtrudedAreaSolid is required, the
/// set of IfcShapeRepresentation.Items may include a single,
/// or multiple, instances of IfcExtrudedAreaSolid.
/// Profile: IfcRectangleProfileDef,
/// IfcCircleProfileDef and
/// IfcArbitraryClosedProfileDef shall be supported.
/// Extrusion: The profile shall be extruded horizontally
/// (i.e. perpendicular to the extrusion direction of the voided
/// element), e.g. for wall openings, or vertically (i.e. in the
/// extrusion direction of the voided element), e.g., for floor
/// openings. If multiple instances of IfcExtrudedAreaSolid
/// are used, the extrusion direction of each extrusion should be
/// equal.
/// 
/// NOTE In case of non-parallel jambs, the shape
/// representation shall be a 'SweptSolid' representation with
/// vertical extrusion.
/// 
/// Figure 34 illustrates an opening with horizontal extrusion.
/// NOTE  The local placement directions for the IfcOpeningElement are only given as an example, other directions are valid as well.
/// 
/// Figure 34 — Opening with full extrusion
/// 
/// Figure 35 illustrates an opening for a recess.
/// NOTE  The local placement directions for the IfcOpeningElement are only given as an example, other directions are valid as well.
/// NOTE  Rectangles are now defined centric, the placement
/// location has to be set:
/// 
/// IfcCartesianPoint(XDim/2,YDim/2)
/// 
/// Figure 35 — Opening with recess extrusion
/// 
/// Swept Solid Representation with Vertical Extrusion
/// The 'SweptSolid' geometric representation of
/// IfcOpeningElement, using vertical extrusion direction (for
/// walls), is defined using the swept area solid geometry, however
/// the extrusion direction may be vertical, i.e. in case of a wall
/// opening, the extrusion would be in the direction of the wall
/// height. The following attribute values for the
/// IfcShapeRepresentation holding this geometric
/// representation shall be used:
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'SweptSolid'
/// 
/// The following additional constraints apply to the swept solid
/// representation:
/// 
/// Solid: IfcExtrudedAreaSolid is required, the
/// set of IfcShapeRepresentation.Items may include a single,
/// or multiple, instances of IfcExtrudedAreaSolid.
/// Profile: IfcRectangleProfileDef,
/// IfcCircleProfileDef and
/// IfcArbitraryClosedProfileDef shall be supported.
/// Extrusion: The profile shall be extruded vertically,
/// i.e. for wall openings along the extrusion direction of the
/// voided element.ÿ If multiple instances of
/// IfcExtrudedAreaSolid are used, the extrusion direction
/// should be equal.
/// 
/// Vertical extrusions shall be used when an opening or recess
/// has a non rectangular foot print geometry that does not change
/// along the height of the opening or recess.
/// Figure 36 shows a vertical extrusion with multiple extrusion bodies for the opening. Each extrusion body has a different extrusion lenght.
/// NOTE  The local placement directions for the IfcOpeningElement are only given as an example, other directions are valid as well.
/// 
/// Figure 36 — Opening with multiple extrusions
class IFC_PARSE_API IfcOpeningElement : public IfcFeatureElementSubtraction {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcOpeningElement
    bool hasPredefinedType() const;
    /// Predefined generic type for an opening that is specified in an enumeration. There may be a property set given specificly for the predefined types.
    /// 
    /// IFC2x4 CHANGE  The attribute has been added at the end of the entity definition.
    IfcOpeningElementTypeEnum::IfcOpeningElementTypeEnum PredefinedType() const;
    void setPredefinedType(IfcOpeningElementTypeEnum::IfcOpeningElementTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcFeatureElementSubtraction::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcOpeningElementTypeEnum; } return IfcFeatureElementSubtraction::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "PredefinedType"; } return IfcFeatureElementSubtraction::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcRelFillsElement >::ptr HasFillings() const; // INVERSE IfcRelFillsElement::RelatingOpeningElement
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcOpeningElement (IfcEntityInstanceData* e);
    IfcOpeningElement (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcOpeningElementTypeEnum::IfcOpeningElementTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcOpeningElement > list;
};
/// The standard opening,
/// IfcOpeningStandardCase, defines an opening with certain
/// constraints for the dimension parameters, position within the
/// voided element, and with certain constraints for the geometric
/// representation. The IfcOpeningStandardCase handles all
/// cases of openings, that:
/// 
/// are true openings by cutting through the body of the voided
/// element, i.e. where the opening depth is >= to the thickness
/// of the element,
/// are extruded perpendicular to the wall plane in case of
/// openings in a wall
/// are extruded perpendicular to the slab plane in case of
/// openings in a slab
/// have a local placement relative to the local placement of the
/// voided element
/// have a 'Body' shape representation with 'SweptSolid'
/// representation type
/// have only a single extrusion body within the 'Body' shape
/// representation
/// 
/// HISTORY New entity in
/// IFC2x4
/// Property Set Use Definition:
/// The property sets relating to the
/// IfcOpeningStandardCase are defined at the supertype
/// IfcOpeningElement.
/// Quantity Use Definition:
/// The quantities relating to the IfcOpeningStandardCase
/// are defined at the supertype IfcOpeningElement.
/// Containment Use Definition
/// The containment use definitions relating to the
/// IfcOpeningStandardCase are defined at the supertype
/// IfcOpeningElement.
/// Geometry Use Definitions
/// The geometric representation of IfcOpeningStandardCase
/// is given by the IfcProductDefinitionShape and
/// IfcLocalPlacement allowing multiple geometric
/// representations.
/// Local Placement
/// The following constraint is mandatory for
/// IfcOpeningStandardCase
/// 
/// The PlacementRelTo relationship of
/// IfcLocalPlacement should point to the local placement of
/// the same element, which is voided by the opening, i.e. referred
/// to by VoidsElement.RelatingBuildingElement.
/// 
/// Geometric Representation
/// The geometric representation of IfcOpeningStandardCase
/// is defined using the following multiple shape representations for
/// its definition:
/// 
/// Body: A SweptSolid representation defining the 3D subtraction
/// shape of the standard opening
/// 
/// Body Representation
/// The body representation of IfcOpeningStandardCase is
/// represented using the representation type 'SweptSolid'.
/// Swept Solid Representation Type with Horizontal
/// Extrusion
/// The standard geometric representation of
/// IfcOpeningStandardCase is defined using the 'SweptSolid'
/// representation. The following attribute values for the
/// IfcShapeRepresentation holding this geometric
/// representation shall be used::
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'SweptSolid'
/// 
/// The following additional constraints apply to the swept solid
/// representation:
/// 
/// Solid: a single IfcExtrudedAreaSolid is
/// required
/// Profile: IfcRectangleProfileDef,
/// IfcCircleProfileDef and
/// IfcArbitraryClosedProfileDef shall be supported.
/// Extrusion: The profile shall be extruded horizontally
/// (i.e. perpendicular to the extrusion direction of the voided
/// element) for wall openings, or vertically (i.e. in the extrusion
/// direction of the voided element), for slab openings.
/// 
/// As shown in Figure 37, the orientation of the opening profile that is extruded
/// for the opening body shall guarantee the following interpretation
/// of dimension parameter for rectangular openings:
/// 
/// IfcRectangleProfileDef.YDim interpreted as
/// opening width
/// IfcRectangleProfileDef.XDim interpreted as
/// opening height
/// 
/// Figure 37 — Opening standard representation
class IFC_PARSE_API IfcOpeningStandardCase : public IfcOpeningElement {
public:
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcOpeningElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcOpeningElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcOpeningElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcOpeningStandardCase (IfcEntityInstanceData* e);
    IfcOpeningStandardCase (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcOpeningElementTypeEnum::IfcOpeningElementTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcOpeningStandardCase > list;
};
/// The flow terminal type IfcOutletType defines commonly shared information for occurrences of outlets.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a outlet specification (i.e. the specific product information, that is common to all occurrences of that product type).  Outlet types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcOutletType are represented by instances of IfcOutlet. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcFlowTerminalType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_ElectricalDeviceCommon 
/// Pset_OutletTypeCommon 
/// 
/// Material Use Definition 
/// The material of the IfcOutletType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Casing': Material from which the casing is constructed. 
/// 'Conductor': Material from which the conductors are constructed. 
/// 'Surface': Material from which the outlet plate is constructed. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcOutletType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcOutlet for standard port definitions.
class IFC_PARSE_API IfcOutletType : public IfcFlowTerminalType {
public:
    /// Identifies the predefined types of outlet from which the type required may be set.
    IfcOutletTypeEnum::IfcOutletTypeEnum PredefinedType() const;
    void setPredefinedType(IfcOutletTypeEnum::IfcOutletTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcFlowTerminalType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcOutletTypeEnum; } return IfcFlowTerminalType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcFlowTerminalType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcOutletType (IfcEntityInstanceData* e);
    IfcOutletType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcOutletTypeEnum::IfcOutletTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcOutletType > list;
};
/// IfcPerformanceHistory is used to document the actual performance of an occurrence instance over time. In practice, performance-related data are generally not easy to obtain as they can originate from different sources (predicted, simulated, or measured) and occur during different stages of the building life-cycle. Such time-related data cover a large spectrum, including meteorological data, schedules, operational status measurements, trend reports, etc.
/// 
/// IfcPerformanceHistory is assigned to other objects (represented by subtypes of IfcObjectDefinition, excluding subtypes of IfcControl), by the objectified relationship IfcRelAssignsToControl.
/// 
/// HISTORY: New entity in Release IFC2x Edition 2.
class IFC_PARSE_API IfcPerformanceHistory : public IfcControl {
public:
    /// Describes the applicable building life-cycle phase. Typical values should be DESIGNDEVELOPMENT, SCHEMATICDEVELOPMENT, CONSTRUCTIONDOCUMENT, CONSTRUCTION, ASBUILT, COMMISSIONING, OPERATION, etc.
    std::string LifeCyclePhase() const;
    void setLifeCyclePhase(std::string v);
    /// Whether the optional attribute PredefinedType is defined for this IfcPerformanceHistory
    bool hasPredefinedType() const;
    /// Predefined generic type for a performace history that is specified in an enumeration.
    /// 
    /// IFC2x4 CHANGE  The attribute has been added at the end of the entity definition.
    IfcPerformanceHistoryTypeEnum::IfcPerformanceHistoryTypeEnum PredefinedType() const;
    void setPredefinedType(IfcPerformanceHistoryTypeEnum::IfcPerformanceHistoryTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 6: return IfcUtil::Argument_STRING; case 7: return IfcUtil::Argument_ENUMERATION; } return IfcControl::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 6: return Type::IfcLabel; case 7: return Type::IfcPerformanceHistoryTypeEnum; } return IfcControl::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 6: return "LifeCyclePhase"; case 7: return "PredefinedType"; } return IfcControl::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPerformanceHistory (IfcEntityInstanceData* e);
    IfcPerformanceHistory (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, boost::optional< std::string > v6_Identification, std::string v7_LifeCyclePhase, boost::optional< IfcPerformanceHistoryTypeEnum::IfcPerformanceHistoryTypeEnum > v8_PredefinedType);
    typedef IfcTemplatedEntityList< IfcPerformanceHistory > list;
};
/// This entity is a description of a panel within a
/// door or window (as fillers for opening) which allows for air
/// flow. It is given by its properties
/// (IfcPermeableCoveringProperties). A permeable covering is
/// a casement, such as a component, fixed or opening, consisting
/// essentially of a frame and the infilling. The infilling is
/// normally a grill, a louver or a screen. The way of operation is
/// defined in the operation type.
/// The IfcPermeableCoveringProperties are included in the
/// list of properties (HasPropertySets) of the
/// IfcWindowStyle or the IfcDoorStyle. More
/// information about the permeable covering can be included in the
/// same list of the window or door style using the
/// IfcPropertySet for dynamic extensions. This particularly
/// applies for additional properties for the various operation
/// types
/// 
/// HISTORY New entity in IFC Release 2.0, it had been renamed from
/// IfcPermeableCovering in IFC Release 2x.
/// 
/// IFC2x4 CHANGE Supertype changed to new IfcPreDefinedPropertySet.
/// 
/// Geometry use definitions
/// The IfcPermeableCoveringProperties does not hold a geometric representation. However it defines parameters which can be used to create the shape of the IfcWindowStyle (which is inserted by the IfcWindow into the spatial context of the project), or of the IfcDoorStyle (which is inserted by the IfcDoor).
/// The parameters at the IfcPermeableCoveringProperties define a standard permeable covering. The outer boundary of the panel is determined by the occurrence parameter assigned to the
/// IfcWindow or IfcDoor. It has to take the lining parameter into account as well. The position of the permeable covering within the overall window or door is determined by the
/// PanelPosition attribute.
/// 
/// As shown in Figure 174, the panel is applied to the position within the lining, as defined by the panel position attribute. The following parameters apply to that panel: FrameDepth, FrameThickness.
/// 
/// Figure 174 — Permeable covering properties
class IFC_PARSE_API IfcPermeableCoveringProperties : public IfcPreDefinedPropertySet {
public:
    /// Types of permeable covering operations. Also used to assign standard symbolic presentations according to national building standards.
    IfcPermeableCoveringOperationEnum::IfcPermeableCoveringOperationEnum OperationType() const;
    void setOperationType(IfcPermeableCoveringOperationEnum::IfcPermeableCoveringOperationEnum v);
    /// Position of this permeable covering panel within the overall window or door type.
    IfcWindowPanelPositionEnum::IfcWindowPanelPositionEnum PanelPosition() const;
    void setPanelPosition(IfcWindowPanelPositionEnum::IfcWindowPanelPositionEnum v);
    /// Whether the optional attribute FrameDepth is defined for this IfcPermeableCoveringProperties
    bool hasFrameDepth() const;
    /// Depth of panel frame (used to include the permeable covering), measured from front face to back face horizontally (i.e. perpendicular to the window or door (elevation) plane.
    double FrameDepth() const;
    void setFrameDepth(double v);
    /// Whether the optional attribute FrameThickness is defined for this IfcPermeableCoveringProperties
    bool hasFrameThickness() const;
    /// Width of panel frame (used to include the permeable covering), measured from inside of panel (at permeable covering) to outside of panel (at lining), i.e. parallel to the window or door (elevation) plane.
    double FrameThickness() const;
    void setFrameThickness(double v);
    /// Whether the optional attribute ShapeAspectStyle is defined for this IfcPermeableCoveringProperties
    bool hasShapeAspectStyle() const;
    /// Optional link to a shape aspect definition, which points to the part of the geometric representation of the window style, which is used to represent the permeable covering.
    IfcShapeAspect* ShapeAspectStyle() const;
    void setShapeAspectStyle(IfcShapeAspect* v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 4: return IfcUtil::Argument_ENUMERATION; case 5: return IfcUtil::Argument_ENUMERATION; case 6: return IfcUtil::Argument_DOUBLE; case 7: return IfcUtil::Argument_DOUBLE; case 8: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcPreDefinedPropertySet::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 4: return Type::IfcPermeableCoveringOperationEnum; case 5: return Type::IfcWindowPanelPositionEnum; case 6: return Type::IfcPositiveLengthMeasure; case 7: return Type::IfcPositiveLengthMeasure; case 8: return Type::IfcShapeAspect; } return IfcPreDefinedPropertySet::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 4: return "OperationType"; case 5: return "PanelPosition"; case 6: return "FrameDepth"; case 7: return "FrameThickness"; case 8: return "ShapeAspectStyle"; } return IfcPreDefinedPropertySet::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPermeableCoveringProperties (IfcEntityInstanceData* e);
    IfcPermeableCoveringProperties (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcPermeableCoveringOperationEnum::IfcPermeableCoveringOperationEnum v5_OperationType, IfcWindowPanelPositionEnum::IfcWindowPanelPositionEnum v6_PanelPosition, boost::optional< double > v7_FrameDepth, boost::optional< double > v8_FrameThickness, IfcShapeAspect* v9_ShapeAspectStyle);
    typedef IfcTemplatedEntityList< IfcPermeableCoveringProperties > list;
};
/// A permit is a permission to perform work in places and on artifacts where regulatory, security or other access restrictions apply. 
/// 
/// HISTORY New entity in IFC2x2 
/// IFC2x4 CHANGE  PermitID renamed to Identification and promoted to supertype IfcControl, Attributes PredefinedType, Status, and LongDescription added.
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the IfcRelDefinesByProperties relationship. They are accessible by the IsDefinedBy inverse attribute.  Refer to the documentation at the supertype IfcControl and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_Permit 
/// 
/// Declaration Use Definition 
/// The IfcPermit may be declared within the project using the IfcRelDeclares relationship where RelatingContext refers to the single IfcProject and RelatedDefinitions contains the IfcPermit.  Alternatively, if the IfcPermit is aggregated within an IfcWorkPlan, then it shall not have a direct declaration relationship (whereas the containing work plan may have a declaration relationship). 
/// 
/// Composition Use Definition 
/// The IfcPermit may be aggregated into components using IfcRelAggregates where RelatingObject refers to the enclosing IfcPermit and RelatedObjects contains one or more components.  Aggregation use is defined for the following predefined types:
/// 
/// ACCESS: May contain IfcWorkCalendar components.  A work calendar may indicate the time period of the permit and allowed times when work may be performed.  Such work calendar may have assigned resources indicating equipment or labor permitted at various times. 
/// WORK: May contain IfcWorkSchedule components.  A work schedule may indicate tasks and scheduled times where the work schedule type may designate whether tasks and/or times are planned or actual.  Such work schedule may have assigned tasks indicating detail, where tasks may be assigned to products and may have assigned resources. 
/// 
/// As shown in Figure 159, an IfcPermit may be nested into sub-items using IfcRelNests where RelatingObject refers to the enclosing IfcPermit and RelatedObjects contains one or more sub-items.  Nesting use is defined for the following predefined types:
/// 
/// (All Types): May contain IfcPermit sub-items.  A permit may be nested to indicate permit ammendments, in order of issue. 
/// 
/// Figure 159 — Permit composition
/// 
/// Assignment Use Definition 
/// As shown in Figure 160, an IfcPermit may be assigned to the following entities using relationships as indicated: 
/// 
/// IfcActor (IfcRelAssignsToActor): Organization issuing the permit such as a local government agency or security organization. 
/// 
/// The IfcPermit may have assignments of its own using the IfcRelAssignsToControl relationship where RelatingControl refers to the IfcPermit and RelatedObjects contains one or more objects of the following types:  
/// IfcActor: Organization(s) bound to the permit, typically a single contractor.
/// 
/// Figure 160 — Permit assignment
/// 
/// Approval Use Definition 
/// Approvals may be associated to indicate the status of acceptance or rejection using the IfcRelAssociatesApproval relationship where RelatingApproval refers to an IfcApproval and RelatedObjects contains the IfcPermit.  Approvals may be split into sub-approvals using IfcApprovalRelationship to track approval status separately for each party where RelatingApproval refers to the higher-level approval and RelatedApprovals contains one or more lower-level approvals.  The hierarchy of approvals implies sequencing such that a higher-level approval is not executed until all of its lower-level approvals have been accepted.
class IFC_PARSE_API IfcPermit : public IfcControl {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcPermit
    bool hasPredefinedType() const;
    /// Identifies the predefined types of permit that can be granted.
    /// 
    /// IFC2x4 CHANGE  The attribute has been added.
    IfcPermitTypeEnum::IfcPermitTypeEnum PredefinedType() const;
    void setPredefinedType(IfcPermitTypeEnum::IfcPermitTypeEnum v);
    /// Whether the optional attribute Status is defined for this IfcPermit
    bool hasStatus() const;
    /// The status currently assigned to the permit.
    /// 
    /// IFC2x4 CHANGE  The attribute has been added.
    std::string Status() const;
    void setStatus(std::string v);
    /// Whether the optional attribute LongDescription is defined for this IfcPermit
    bool hasLongDescription() const;
    /// Detailed description of the request.
    /// 
    /// IFC2x4 CHANGE  The attribute has been added.
    std::string LongDescription() const;
    void setLongDescription(std::string v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 6: return IfcUtil::Argument_ENUMERATION; case 7: return IfcUtil::Argument_STRING; case 8: return IfcUtil::Argument_STRING; } return IfcControl::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 6: return Type::IfcPermitTypeEnum; case 7: return Type::IfcLabel; case 8: return Type::IfcText; } return IfcControl::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 6: return "PredefinedType"; case 7: return "Status"; case 8: return "LongDescription"; } return IfcControl::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPermit (IfcEntityInstanceData* e);
    IfcPermit (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, boost::optional< std::string > v6_Identification, boost::optional< IfcPermitTypeEnum::IfcPermitTypeEnum > v7_PredefinedType, boost::optional< std::string > v8_Status, boost::optional< std::string > v9_LongDescription);
    typedef IfcTemplatedEntityList< IfcPermit > list;
};
/// Definition from IAI: Provides shared material, decomposition, representation maps, and property sets for instances of IfcPile.
/// 
/// HISTORY New entity in IFC Release 2x4
/// 
/// Material Use Definition:
/// 
/// Material profile set association analogous to IfcColumnStandardCase should be used when applicable.
class IFC_PARSE_API IfcPileType : public IfcBuildingElementType {
public:
    /// Subtype of pile.
    IfcPileTypeEnum::IfcPileTypeEnum PredefinedType() const;
    void setPredefinedType(IfcPileTypeEnum::IfcPileTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcBuildingElementType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcPileTypeEnum; } return IfcBuildingElementType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcBuildingElementType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPileType (IfcEntityInstanceData* e);
    IfcPileType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcPileTypeEnum::IfcPileTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcPileType > list;
};
/// The flow fitting type IfcPipeFittingType defines commonly shared information for occurrences of pipe fittings.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a pipe fitting specification (i.e. the specific product information, that is common to all occurrences of that product type).  Pipe Fitting types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcPipeFittingType are represented by instances of IfcPipeFitting. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcFlowFittingType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_PipeFittingTypeCommon 
/// 
/// Material Use Definition 
/// The material of the IfcPipeFittingType is defined by IfcMaterialProfileSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialProfileSet.MaterialProfiles[n].Name shall be used: 
/// 
/// 'Body': Material from which the pipe fitting is constructed. 
/// 'Coating': The outer coating, if applicable. 
/// 'Insulation': The insulating wrapping, if applicable. 
/// 'Lining': The inner lining, if applicable. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcPipeFittingType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcPipeFitting for standard port definitions.
class IFC_PARSE_API IfcPipeFittingType : public IfcFlowFittingType {
public:
    /// The type of pipe fitting.
    IfcPipeFittingTypeEnum::IfcPipeFittingTypeEnum PredefinedType() const;
    void setPredefinedType(IfcPipeFittingTypeEnum::IfcPipeFittingTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcFlowFittingType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcPipeFittingTypeEnum; } return IfcFlowFittingType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcFlowFittingType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPipeFittingType (IfcEntityInstanceData* e);
    IfcPipeFittingType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcPipeFittingTypeEnum::IfcPipeFittingTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcPipeFittingType > list;
};
/// The flow segment type IfcPipeSegmentType defines commonly shared information for occurrences of pipe segments.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a pipe segment specification (i.e. the specific product information, that is common to all occurrences of that product type).  Pipe Segment types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcPipeSegmentType are represented by instances of IfcPipeSegment. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcFlowSegmentType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_PipeSegmentTypeCommon 
/// 
/// The following property set definitions are applicable to this entity according to the PredefinedType attribute:  
/// Pset_PipeSegmentTypeCulvert (CULVERT) 
/// Pset_PipeSegmentTypeGutter (GUTTER) 
/// 
/// Material Use Definition 
/// The material of the IfcPipeSegmentType is defined by IfcMaterialProfileSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialProfileSet.MaterialProfiles[n].Name shall be used: 
/// 
/// 'Body': Material from which the pipe segment is constructed. 
/// 'Coating': The outer coating, if applicable. 
/// 'Insulation': The insulating wrapping, if applicable. 
/// 'Lining': The inner lining, if applicable. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcPipeSegmentType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcPipeSegment for standard port definitions.
class IFC_PARSE_API IfcPipeSegmentType : public IfcFlowSegmentType {
public:
    /// The type of pipe segment.
    IfcPipeSegmentTypeEnum::IfcPipeSegmentTypeEnum PredefinedType() const;
    void setPredefinedType(IfcPipeSegmentTypeEnum::IfcPipeSegmentTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcFlowSegmentType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcPipeSegmentTypeEnum; } return IfcFlowSegmentType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcFlowSegmentType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPipeSegmentType (IfcEntityInstanceData* e);
    IfcPipeSegmentType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcPipeSegmentTypeEnum::IfcPipeSegmentTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcPipeSegmentType > list;
};
/// The element type IfcPlateType defines commonly shared
/// information for occurrences of plates. The set of shared
/// information may include:
/// 
/// common properties within shared property sets
/// common material information
/// common material layer definitions
/// common shape representations
/// 
/// NOTE It is illegal to share shape
/// representations as representation maps for occurrences of
/// IfcPlateStandardCase.
/// 
/// It is used to define a plate specification (i.e. the specific
/// product information, that is common to all occurrences of that
/// product type). Plate types may be exchanged without being already
/// assigned to occurrences.
/// NOTE The product representations are defined as
/// representation maps (at the level of the supertype
/// IfcTypeProduct, which gets assigned by an element occurrence
/// instance through the IfcShapeRepresentation.Item[1] being an
/// IfcMappedItem.
/// The occurrences of the IfcPlateType within building
/// models are represented by instances of IfcPlateStandardCase
/// if the IfcPlateType has a single associated
/// IfcMaterialLayerSet; otherwise they are represented by
/// instances of IfcPlate.
/// 
/// HISTORY  New
/// entity in Release IFC2x2.
/// 
/// Informal proposition:
/// 
/// The material assignment, if provided using the
/// IfcRelAssociatesMaterial relationship, shall not reference
/// the IfcMaterialLayerSetUsage.
/// 
/// Material Use Definition
/// The material of the IfcPlateType is defined by the
/// IfcMaterialLayerSet or as fall back by IfcMaterial
/// and attached by the
/// IfcRelAssociatesMaterial.RelatingMaterial. It is
/// accessible by the inverse HasAssociations relationship.
/// Note: It is illegal to assign an
/// IfcMaterial to an IfcPlateType, if there is at least
/// one occurrences of IfcPlateStandardCase for this
/// type.
/// Layer Set Use Definition:
/// The shared material layer set definition is defined by assigning
/// an IfcMaterialLayerSet (see material use definition above).
/// The IfcMaterialLayer refers to one or several of
/// IfcMaterial that is the common for all plate occurrence, if
/// used. It is only applicable if the IfcPlateType has only
/// occurrences of type IfcPlateStandardCase (see definition of
/// IfcPlateStandardCase for further information).
/// NOTE Since each individual instance of
/// IfcPlateStandardCase defines its own
/// IfcMaterialLayerSetUsage including the offset from the
/// reference plane, the same IfcPlateType can be used
/// independently of the reference plane alignment of its
/// occurrences.
/// Property Set Use Definition:
/// The shared property sets relating to the IfcPlateType are
/// defined by the IfcPropertySet and are attached by the
/// HasPropertySets attribute. The following property set
/// definitions specific to the IfcWallType are part of this IFC
/// release:
/// NOTE There is no differentiation between
/// properties within the property set that are only assignable to
/// IfcPlateType and those that are only assignable to
/// IfcPlate. If the same property is assigned to the
/// IfcPlateType and the IfcPlate being an occurrence of
/// the IfcPlateType, then the occurrence property overrides the
/// type property.
/// 
/// Pset_PlateCommon: common property set for all
/// plate types.
class IFC_PARSE_API IfcPlateType : public IfcBuildingElementType {
public:
    /// Identifies the predefined types of a planar member element from which the type required may be set.
    IfcPlateTypeEnum::IfcPlateTypeEnum PredefinedType() const;
    void setPredefinedType(IfcPlateTypeEnum::IfcPlateTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcBuildingElementType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcPlateTypeEnum; } return IfcBuildingElementType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcBuildingElementType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPlateType (IfcEntityInstanceData* e);
    IfcPlateType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcPlateTypeEnum::IfcPlateTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcPlateType > list;
};

class IFC_PARSE_API IfcPolygonalFaceSet : public IfcTessellatedFaceSet {
public:
    /// Whether the optional attribute Closed is defined for this IfcPolygonalFaceSet
    bool hasClosed() const;
    bool Closed() const;
    void setClosed(bool v);
    IfcTemplatedEntityList< IfcIndexedPolygonalFace >::ptr Faces() const;
    void setFaces(IfcTemplatedEntityList< IfcIndexedPolygonalFace >::ptr v);
    /// Whether the optional attribute PnIndex is defined for this IfcPolygonalFaceSet
    bool hasPnIndex() const;
    std::vector< int > /*[1:?]*/ PnIndex() const;
    void setPnIndex(std::vector< int > /*[1:?]*/ v);
    virtual unsigned int getArgumentCount() const { return 4; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 1: return IfcUtil::Argument_BOOL; case 2: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 3: return IfcUtil::Argument_AGGREGATE_OF_INT; } return IfcTessellatedFaceSet::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 1: return Type::IfcBoolean; case 2: return Type::IfcIndexedPolygonalFace; case 3: return Type::IfcPositiveInteger; } return IfcTessellatedFaceSet::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 1: return "Closed"; case 2: return "Faces"; case 3: return "PnIndex"; } return IfcTessellatedFaceSet::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPolygonalFaceSet (IfcEntityInstanceData* e);
    IfcPolygonalFaceSet (IfcCartesianPointList3D* v1_Coordinates, boost::optional< bool > v2_Closed, IfcTemplatedEntityList< IfcIndexedPolygonalFace >::ptr v3_Faces, boost::optional< std::vector< int > /*[1:?]*/ > v4_PnIndex);
    typedef IfcTemplatedEntityList< IfcPolygonalFaceSet > list;
};
/// Definition from ISO/CD 10303-42:1992: A polyline
///   is a bounded curve of n - 1 linear segments, defined by a
///   list of n points, P1, P2 ... Pn. 
///   The ith segment of the curve is parameterized as follows:
/// 
///    
///   for 1 ≤ i ≤ n - 1
/// 
/// where i - 1 ≤ u ≤ i and
///   with parametric range of 0 <≤ u ≤ n - 1.
/// 
/// NOTE  Corresponding ISO 10303 entity: polyline. Please refer to ISO/IS 10303-42:1994, p. 45 for the final definition of the formal standard.
/// 
/// HISTORY  New class in IFC Release 1.0
class IFC_PARSE_API IfcPolyline : public IfcBoundedCurve {
public:
    /// The points defining the polyline.
    IfcTemplatedEntityList< IfcCartesianPoint >::ptr Points() const;
    void setPoints(IfcTemplatedEntityList< IfcCartesianPoint >::ptr v);
    virtual unsigned int getArgumentCount() const { return 1; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } return IfcBoundedCurve::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcCartesianPoint; } return IfcBoundedCurve::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Points"; } return IfcBoundedCurve::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPolyline (IfcEntityInstanceData* e);
    IfcPolyline (IfcTemplatedEntityList< IfcCartesianPoint >::ptr v1_Points);
    typedef IfcTemplatedEntityList< IfcPolyline > list;
};
/// Definition from IAI: An IfcPort provides the
///   means for an element to connect to other elements.
/// 
/// An IfcPort is associated with an IfcElement,
///   it belongs to, through the objectified relationship
///   IfcRelConnectsPortToElement. Exactly two ports,
///   belonging to two different elements, are connected with
///   each other through the objectified relationship
///   IfcRelConnectsPorts.
/// 
/// An instance of IfcElement may have one or more
///   points at which it connects to other instances of
///   IfcElement. An instance of IfcPort is located
///   at a point where a connection can occur. The location of
///   the port is determined in the context of the local
///   coordinate system of the element to which it belongs.
/// 
/// HISTORY New entity in
///   Release IFC2x Edition 2.
/// 
/// Containment Use Definitions
/// 
/// As a subordinate part being fully dependent on the master
///   element the IfcPort shall have no
///   independent containment relationship to the spatial
///   structure.
/// 
/// Geometry Use Definition
/// 
/// The geometric representation of IfcPort is
///   given by the IfcProductDefinitionShape, allowing
///   multiple geometric representation.
/// 
/// Local Placement
/// 
/// The local placement for IfcPort is defined
///   in its supertype IfcProduct. It is defined by the
///   IfcLocalPlacement, which defines the local
///   coordinate system that is referenced by all geometric
///   representations.
/// 
/// The PlacementRelTo relationship of
///   IfcLocalPlacement shall point to the
///   local placement of the master IfcElement (its
///   relevant subtypes), which is associated to the
///   IfcPort by the relationship object
///   IfcRelConnectsPortToElement.
/// 
/// Shape Representation
/// 
/// The geometry use definitions for the shape representation
///   of the IfcPort is given at the level of
///   its subtypes.
class IFC_PARSE_API IfcPort : public IfcProduct {
public:
    virtual unsigned int getArgumentCount() const { return 7; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcProduct::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcProduct::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcProduct::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcRelConnectsPortToElement >::ptr ContainedIn() const; // INVERSE IfcRelConnectsPortToElement::RelatingPort
    IfcTemplatedEntityList< IfcRelConnectsPorts >::ptr ConnectedFrom() const; // INVERSE IfcRelConnectsPorts::RelatedPort
    IfcTemplatedEntityList< IfcRelConnectsPorts >::ptr ConnectedTo() const; // INVERSE IfcRelConnectsPorts::RelatingPort
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPort (IfcEntityInstanceData* e);
    IfcPort (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation);
    typedef IfcTemplatedEntityList< IfcPort > list;
};
/// An IfcProcedure is a
///   logical set of actions to be taken in response to an event
///   or to cause an event to occur.
/// 
/// HISTORY  New entity in IFC2x2
/// 
/// IFC2x4 CHANGE  ProcedureType renamed to PredefinedType and made optional (upward compatible).  Where rules WR1 and WR2 have been removed.
/// 
/// Use definitions
/// 
/// IfcProcedure is used to capture information about
///   stepped processes such as calibration, start/stop
///   procedures for equipment items, designated actions to take
///   in the event of an emergency etc. A procedure is not a
///   task, but may describe a set of tasks and their order of
///   occurrence in response to or to cause an event.
/// 
/// Type use definition
/// 
/// IfcProcedure defines the anticipated or actual
///   occurrence of any procedure; common information about
///   procedure types is handled by IfcProcedureType. The
///   IfcProcedureType (if present) may establish the
///   common type name, usage (or predefined) type, common nested
///   procedures (using IfcRelNests), common set of
///   properties, and common product assignment using
///   IfcRelAssignsToProduct. The IfcProcedureType
///   is attached using the
///   IfcRelDefinesByType.RelatingType objectified
///   relationship and is accessible by the inverse
///   IsTypedBy attribute.
/// 
/// Property set use definition
/// 
/// The property sets relating to IfcProcedure are
///   defined by IfcPropertySet and attached by the
///   IfcRelDefinesByProperties relationship. They are
///   accessible by the inverse IsDefinedBy relationship.
///   Such property sets may define procedure parameters. No
///   property sets for IfcProcedure are currently defined
///   by IFC.
/// 
/// Connectivity use definition
/// 
/// The relationship IfcRelSequence is used to indicate
///   control flow. An IfcProcedure as a successor to an
///   IfcEvent indicates that the procedure should be
///   performed in response to the event. An IfcProcedure
///   as a predecessor to an IfcEvent indicates that the
///   event should be trigerred following the procedure. As
///   procedures have arbitrary duration, the
///   IfcRelSequence.SequenceType attribute has no effect
///   on an IfcProcedure but still applies to the opposite
///   end of the relationship if IfcTask is used.
/// 
/// Composition use definition
/// 
/// IfcProcedure may be contained within an
///   IfcTask or IfcProcedure using the
///   IfcRelNests relationship. An IfcProcedure may
///   in turn nest other IfcProcedure or IfcEvent
///   entities. Such nesting indicates decomposed level of
///   detail.
/// 
/// Note that a particular type of IfcProcedure is a
///   caution, warning or other form of advisory note. Typically,
///   it is anticipated that such a procedure would be assigned
///   to the specific IfcProcess for which it gives advice
///   using IfcRelAssignsToProcess.
/// 
/// Assignment use definition
/// 
/// An IfcProcedure may be assigned to an
///   IfcWorkCalendar to indicate times when such
///   procedure may be performed using
///   IfcRelAssignsToControl; otherwise the effective
///   calendar is determined by the nearest IfcProcess
///   ancestor with a calendar assigned. Advisory notes should be
///   assigned to the specific IfcProcess for which it
///   gives advice using IfcRelAssignsToProcess.
/// 
/// For building operation scenarios, IfcProcedure may
///   be assigned to a product (IfcElement subtype) using
///   IfcRelAssignsToProduct to indicate a specific
///   product occurrence that performs the procedure. For
///   example, an IfcActuator may have a "Close"
///   procedure. If the IfcProcedure is defined by an
///   IfcProcedureType and the IfcProcedureType is
///   assigned to a product type (using
///   IfcRelAssignsToProduct), then the
///   IfcProcedure must be assigned to one or more
///   occurrences of the specified product type using
///   IfcRelAssignsToProduct.
/// 
/// As shown in Figure 12, IfcProcedure does not restrict anything but
///   describes specific steps of how something should happen.
///   While a procedure does control/restrict in the sense of
///   indicating "this is how the task should be performed" by
///   nature of describing inner detail, this is not different than
///   parts of a product indicating "this is how the parts should
///   be assembled". Consequently, it doesn't restrict the outer
///   item as a whole but provides inner detail of the item.
/// 
/// Figure 12 — Procedure relationships
class IFC_PARSE_API IfcProcedure : public IfcProcess {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcProcedure
    bool hasPredefinedType() const;
    /// Identifies the predefined types of a procedure from which 
    ///   the type required may be set.
    IfcProcedureTypeEnum::IfcProcedureTypeEnum PredefinedType() const;
    void setPredefinedType(IfcProcedureTypeEnum::IfcProcedureTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 7: return IfcUtil::Argument_ENUMERATION; } return IfcProcess::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 7: return Type::IfcProcedureTypeEnum; } return IfcProcess::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 7: return "PredefinedType"; } return IfcProcess::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcProcedure (IfcEntityInstanceData* e);
    IfcProcedure (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, boost::optional< std::string > v6_Identification, boost::optional< std::string > v7_LongDescription, boost::optional< IfcProcedureTypeEnum::IfcProcedureTypeEnum > v8_PredefinedType);
    typedef IfcTemplatedEntityList< IfcProcedure > list;
};
/// A project order is a directive to purchase products and/or perform work, such as for construction or facilities management. 
/// 
/// Project orders are typically formal contracts between two organizations, where cost and time information may be rigid or flexible according to contained schedule types and constraints. 
/// 
/// HISTORY New entity in IFC 2.0 
/// IFC2x4 CHANGE Attribute 'ID' changed to Identification and promoted to supertype IfcControl.  Attribute 'LongDescription' added.
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the IfcRelDefinesByProperties relationship. They are accessible by the IsDefinedBy inverse attribute.  Refer to the documentation at the supertype IfcControl and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity according to the PredefinedType attribute:  
/// Pset_ProjectOrderChangeOrder (CHANGEORDER) 
/// Pset_ProjectOrderMaintenanceWorkOrder (MAINTENANCEWORKORDER) 
/// Pset_ProjectOrderMoveOrder (MOVEORDER) 
/// Pset_ProjectOrderPurchaseOrder (PURCHASEORDER) 
/// Pset_ProjectOrderWorkOrder (WORKORDER) 
/// 
/// Declaration Use Definition 
/// The IfcProjectOrder may be declared within the project using the IfcRelDeclares relationship where RelatingContext refers to the single IfcProject and RelatedDefinitions contains the IfcProjectOrder.  Alternatively, if the IfcProjectOrder is aggregated within an IfcWorkPlan, then it shall not have a direct declaration relationship (whereas the containing work plan may have a declaration relationship). 
/// 
/// Composition Use Definition 
/// As shown in Figure 160, an IfcProjectOrder may be aggregated into components using IfcRelAggregates where RelatingObject refers to the enclosing IfcProjectOrder and RelatedObjects contains one or more components.  Aggregation use is defined for the following predefined types:
/// 
/// (All Types): May contain IfcCostSchedule components.  A cost schedule may indicate costs and quantities where the cost schedule type may designate whether rates and/or quantities are estimated or final.  Such cost schedule may have assigned cost items indicating detail, where each cost item may have assigned products, processes, or resources. 
/// WORKORDER: May contain IfcWorkSchedule components.  A work schedule may indicate tasks and scheduled times where the work schedule type may designate whether tasks and/or times are planned or actual.  Such work schedule may have assigned tasks indicating detail, where tasks may be assigned to products and may have assigned resources. 
/// 
/// The IfcProjectOrder may be nested into sub-items using IfcRelNests where RelatingObject refers to the enclosing IfcProjectOrder and RelatedObjects contains one or more sub-items.  Nesting use is defined for the following predefined types:
/// 
/// WORKORDER: May contain IfcProjectOrder sub-items having PredefinedType CHANGEORDER.  A work order may be nested into change orders to indicate contract ammendment, in order of issue. 
/// 
/// Figure 161 — Project order composition
/// 
/// Assignment Use Definition 
/// As shown in Figure 161, an IfcProjectOrder may be assigned to the following entities using relationships as indicated: 
/// 
/// IfcActor (IfcRelAssignsToActor): Organization issuing the order such as an owner or contractor. 
/// 
/// The IfcProjectOrder may have assignments of its own using the IfcRelAssignsToControl relationship where RelatingControl refers to the IfcProjectOrder and RelatedObjects contains one or more objects of the following types:  
/// IfcActor: Organization(s) contracted to fulfill the order, typically a single contractor, subcontractor, or supplier.
/// 
/// Figure 162 — Project order assignment
/// 
/// Approval Use Definition 
/// Approvals may be associated to indicate the status of acceptance or rejection using the IfcRelAssociatesApproval relationship where RelatingApproval refers to an IfcApproval and RelatedObjects contains the IfcProjectOrder.  Approvals may be split into sub-approvals using IfcApprovalRelationship to track approval status separately for each party where RelatingApproval refers to the higher-level approval and RelatedApprovals contains one or more lower-level approvals.  The hierarchy of approvals implies sequencing such that a higher-level approval is not executed until all of its lower-level approvals have been accepted.
class IFC_PARSE_API IfcProjectOrder : public IfcControl {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcProjectOrder
    bool hasPredefinedType() const;
    /// Predefined generic type for a project order that is specified in an enumeration. There may be a property set given specificly for the predefined types.
    /// 
    /// IFC2x4 CHANGE  The attribute has been made optional.
    IfcProjectOrderTypeEnum::IfcProjectOrderTypeEnum PredefinedType() const;
    void setPredefinedType(IfcProjectOrderTypeEnum::IfcProjectOrderTypeEnum v);
    /// Whether the optional attribute Status is defined for this IfcProjectOrder
    bool hasStatus() const;
    /// The current status of a project order.Examples of status values that might be used for a project order status include:
    /// 
    /// PLANNED
    /// REQUESTED
    /// APPROVED
    /// ISSUED
    /// STARTED
    /// DELAYED
    /// DONE
    std::string Status() const;
    void setStatus(std::string v);
    /// Whether the optional attribute LongDescription is defined for this IfcProjectOrder
    bool hasLongDescription() const;
    /// A detailed description of the project order describing the work to be completed.
    std::string LongDescription() const;
    void setLongDescription(std::string v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 6: return IfcUtil::Argument_ENUMERATION; case 7: return IfcUtil::Argument_STRING; case 8: return IfcUtil::Argument_STRING; } return IfcControl::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 6: return Type::IfcProjectOrderTypeEnum; case 7: return Type::IfcLabel; case 8: return Type::IfcText; } return IfcControl::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 6: return "PredefinedType"; case 7: return "Status"; case 8: return "LongDescription"; } return IfcControl::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcProjectOrder (IfcEntityInstanceData* e);
    IfcProjectOrder (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, boost::optional< std::string > v6_Identification, boost::optional< IfcProjectOrderTypeEnum::IfcProjectOrderTypeEnum > v7_PredefinedType, boost::optional< std::string > v8_Status, boost::optional< std::string > v9_LongDescription);
    typedef IfcTemplatedEntityList< IfcProjectOrder > list;
};
/// The projection element is a
/// specialization of the general feature element to represent
/// projections applied to building elements. It represents a solid
/// attached to any element that has physical manifestation.
/// EXAMPLE A wall projection such as a pilaster
/// strip is handled by
/// IfcProjectionElement
/// NOTE View definitions or implementer agreements
/// may restrict the types of elements to which
/// IfcProjectionElement can be applied.
/// An IfcProjectionElement has to be linked to a element
/// (all subtypes of IfcElement) by using the
/// IfcRelProjectsElement relationship. Its existence depends on
/// the existence of the master element. The relationship implies a
/// Boolean union operation between the volume of the projection
/// element and the volume of the element.
/// HISTORY New entity in IFC2x2.
/// IFC2x4 CHANGE The attribute PredefinedType has been added at the end of attribute
/// list.
/// The quantities relating to the IfcProjectionElement are
/// defined by the IfcElementQuantity and attached by the
/// IfcRelDefinesByProperties relationship. It is accessible by
/// the inverse IsDefinedBy relationship. The following base
/// quantities are defined and should be exchanged with the
/// IfcElementQuantity.Name = 'BaseQuantities'. Other
/// quantities, being subjected to local standard of measurement, can
/// be defined with another string value assigned to Name. In
/// this case a valid value for MethodOfMeasurement has to be
/// provided.
/// 
/// Qto_ProjectionElementBaseQuantities: base
/// quantities for all opening occurrences.
/// 
/// Containment Use Definition
/// The IfcProjectionElement shall not participate in the
/// containment relationship, i.e. it is not linked directly to the
/// spatial structure of the project. It has a mandatory
/// ProjectsElements inverse relationship pointing to the
/// IfcElement that is contained in the spatial structure.
/// 
/// The inverse relationship ContainedInStructure shall be
/// NIL.
/// 
/// Geometry Use Definition
/// The geometric representation of IfcProjectionElement is
/// given by the IfcProductDefinitionShape and
/// IfcLocalPlacement allowing multiple geometric
/// representations.
/// Local Placement
/// The local placement for IfcOpeningRecess is defined in
/// its supertype IfcProduct. It is defined by the
/// IfcLocalPlacement, which defines the local coordinate system
/// that is referenced by all geometric representations.
/// 
/// The PlacementRelTo relationship of
/// IfcLocalPlacement should point to the local placement of the
/// same element, to which the projection adds, i.e. referred to by
/// ProjectsElement.RelatingBuildingElement.
/// 
/// Swept Solid Representation
/// The geometric representation of IfcProjectionElement is
/// defined using the swept area solid geometry. The following
/// attribute values for the IfcShapeRepresentation holding this
/// geometric representation shall be used:
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'SweptSolid'
/// 
/// The following additional constraints apply to the swept solid
/// representation:
/// 
/// Solid: IfcExtrudedAreaSolid is required.
/// Profile: IfcRectangleProfileDef,
/// IfcCircleProfileDef and IfcArbitraryClosedProfileDef
/// shall be supported.
/// Extrusion: The profile shall be extruded horizontally
/// (that is, perpendicular to the extrusion direction of the modified
/// element), such as for wall projections, or vertically (that is, in the
/// extrusion direction of the projected element), such as for floor
/// projections.
/// 
/// As shown in Figure 38, the following interpretation of dimension parameter applies for
/// rectangular projection:
/// 
/// IfcRectangleProfileDef.YDim interpreted as projection
/// width
/// IfcRectangleProfileDef.XDim interpreted as projection
/// height
/// IfcExtrudedAreaSolid.Depth is interpreted as projection
/// depth
/// 
/// NOTE  Rectangles are now defined centric, the placement location has to be set:
/// IfcCartesianPoint(XDim/2,YDim/2)
/// NOTE  The local placement directions for the IfcProjectionElement are only given as an example, other directions are valid as well.
/// 
/// Figure 38 — Projection representation
/// 
/// Brep Representation
/// The general b-rep geometric representation of
/// IfcProjectionElement is defined using the Brep geometry. The
/// Brep representation allows for the representation of complex
/// element shape. The following attribute values for the
/// IfcShapeRepresentation holding this geometric representation
/// shall be used:
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'Brep'
class IFC_PARSE_API IfcProjectionElement : public IfcFeatureElementAddition {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcProjectionElement
    bool hasPredefinedType() const;
    /// Predefined generic type for a projection element that is specified in an enumeration. There may be a property set given specificly for the predefined types.
    /// 
    /// IFC2x4 CHANGE  The attribute has been added at the end of the entity definition.
    IfcProjectionElementTypeEnum::IfcProjectionElementTypeEnum PredefinedType() const;
    void setPredefinedType(IfcProjectionElementTypeEnum::IfcProjectionElementTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcFeatureElementAddition::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcProjectionElementTypeEnum; } return IfcFeatureElementAddition::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "PredefinedType"; } return IfcFeatureElementAddition::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcProjectionElement (IfcEntityInstanceData* e);
    IfcProjectionElement (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcProjectionElementTypeEnum::IfcProjectionElementTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcProjectionElement > list;
};
/// The flow controller type IfcProtectiveDeviceType defines commonly shared information for occurrences of protective devices.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a protective device specification (i.e. the specific product information, that is common to all occurrences of that product type).  Protective Device types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcProtectiveDeviceType are represented by instances of IfcProtectiveDevice. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcFlowControllerType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_ElectricalDeviceCommon 
/// Pset_ProtectiveDeviceTypeCommon 
/// 
/// The following property set definitions are applicable to this entity according to the PredefinedType attribute:  
/// Pset_ProtectiveDeviceTypeCircuitBreaker (CIRCUITBREAKER) 
/// Pset_ProtectiveDeviceTypeEarthLeakageCircuitBreaker (EARTHLEAKAGECIRCUITBREAKER) 
/// Pset_ProtectiveDeviceTypeFuseDisconnector (FUSEDISCONNECTOR) 
/// Pset_ProtectiveDeviceTypeResidualCurrentCircuitBreaker (RESIDUALCURRENTCIRCUITBREAKER) 
/// Pset_ProtectiveDeviceTypeResidualCurrentSwitch (RESIDUALCURRENTSWITCH) 
/// Pset_ProtectiveDeviceTypeVaristor (VARISTOR) 
/// 
/// Material Use Definition 
/// The material of the IfcProtectiveDeviceType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Casing': Material from which the casing is constructed. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcProtectiveDeviceType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcProtectiveDevice for standard port definitions.
class IFC_PARSE_API IfcProtectiveDeviceType : public IfcFlowControllerType {
public:
    /// Identifies the predefined types of protective device from which the type required may be set.
    IfcProtectiveDeviceTypeEnum::IfcProtectiveDeviceTypeEnum PredefinedType() const;
    void setPredefinedType(IfcProtectiveDeviceTypeEnum::IfcProtectiveDeviceTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcFlowControllerType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcProtectiveDeviceTypeEnum; } return IfcFlowControllerType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcFlowControllerType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcProtectiveDeviceType (IfcEntityInstanceData* e);
    IfcProtectiveDeviceType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcProtectiveDeviceTypeEnum::IfcProtectiveDeviceTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcProtectiveDeviceType > list;
};
/// The flow moving device type IfcPumpType defines commonly shared information for occurrences of pumps.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a pump specification (i.e. the specific product information, that is common to all occurrences of that product type).  Pump types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcPumpType are represented by instances of IfcPump. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcFlowMovingDeviceType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_PumpTypeCommon 
/// 
/// Material Use Definition 
/// The material of the IfcPumpType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Casing': Material from which the casing is constructed. 
/// 'Impeller': Material from which the impeller of the pump is constructed. In the case of a positive displacement pump, the piston acts as the impeller. 
/// 'ImpellerSeal': Material from which the impeller shaft seal of the pump is constructed. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcPumpType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcPump for standard port definitions.
class IFC_PARSE_API IfcPumpType : public IfcFlowMovingDeviceType {
public:
    /// Defines the type of pump typically used in building services.
    IfcPumpTypeEnum::IfcPumpTypeEnum PredefinedType() const;
    void setPredefinedType(IfcPumpTypeEnum::IfcPumpTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcFlowMovingDeviceType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcPumpTypeEnum; } return IfcFlowMovingDeviceType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcFlowMovingDeviceType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPumpType (IfcEntityInstanceData* e);
    IfcPumpType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcPumpTypeEnum::IfcPumpTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcPumpType > list;
};
/// Definition from IAI: The element type (IfcRailingType)
///   defines a list of commonly shared property set definitions of a railing element
///   and an optional set of product representations. It is used to define a railing
///   specification (i.e. the specific product information, that is common to all
///   occurrences of that product type). 
/// 
/// NOTE: The product representations are defined as
///   representation maps (at the level of the supertype IfcTypeProduct, which
///   gets assigned by an element occurrence instance through the
///   IfcShapeRepresentation.Item[1] being an
///   IfcMappedItem. 
///   A railing type is used to define the common properties of a certain type
///   of railing that may be applied to many instances of that type to assign a
///   specific style. Railing types may be exchanged without being already assigned
///   to occurrences. 
///   The occurrences of the IfcRailingType are represented by
///   instances of IfcRailing. 
/// 
/// HISTORY New entity in Release IFC2x
///   Editon 2.
class IFC_PARSE_API IfcRailingType : public IfcBuildingElementType {
public:
    /// Identifies the predefined types of a railing element from which the type required may be set.
    IfcRailingTypeEnum::IfcRailingTypeEnum PredefinedType() const;
    void setPredefinedType(IfcRailingTypeEnum::IfcRailingTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcBuildingElementType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcRailingTypeEnum; } return IfcBuildingElementType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcBuildingElementType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRailingType (IfcEntityInstanceData* e);
    IfcRailingType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcRailingTypeEnum::IfcRailingTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcRailingType > list;
};
/// Definition from IAI: The element type (IfcRampFlightType)
///   defines a list of commonly shared property set definitions of a ramp flight and
///   an optional set of product representations. It is used to define an ramp flight
///   specification (i.e. the specific product information, that is common to all
///   occurrences of that product type). 
/// 
/// NOTE: The product representations are defined as
///   representation maps (at the level of the supertype IfcTypeProduct, which
///   gets assigned by an element occurrence instance through the
///   IfcShapeRepresentation.Item[1] being an
///   IfcMappedItem. 
///   A ramp flight type is used to define the common properties of a certain
///   type of a ramp flight that may be applied to many instances of that type to
///   assign a specific style. Ramp flight types may be exchanged without being
///   already assigned to occurrences. 
///   The occurrences of the IfcRampFlightType are represented by
///   instances of IfcRampFlight. 
/// 
/// HISTORY New entity in Release IFC2x
///   Edition 2.
class IFC_PARSE_API IfcRampFlightType : public IfcBuildingElementType {
public:
    /// Identifies the predefined types of a ramp flight element from which the type required may be set.
    IfcRampFlightTypeEnum::IfcRampFlightTypeEnum PredefinedType() const;
    void setPredefinedType(IfcRampFlightTypeEnum::IfcRampFlightTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcBuildingElementType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcRampFlightTypeEnum; } return IfcBuildingElementType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcBuildingElementType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRampFlightType (IfcEntityInstanceData* e);
    IfcRampFlightType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcRampFlightTypeEnum::IfcRampFlightTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcRampFlightType > list;
};
/// Definition from IAI: The element type
///   IfcRampType defines a list of commonly shared
///   property set definitions of a ramp and an optional set of
///   product representations. It is used to define a ramp
///   specification (i.e. the specific product information, that
///   is common to all occurrences of that product type).
/// 
/// NOTE The product representations are defined as
///   representation maps (at the level of the supertype
///   IfcTypeProduct, which gets assigned by an element
///   occurrence instance through the
///   IfcShapeRepresentation.Item[1] being an
///   IfcMappedItem.
/// 
/// An IfcRampTypeÿis used to define the common
///   properties of a specific ramp that may be applied to many
///   instances of that type to assign a specific style. 
///   Building element types (or the instantiable subtypes) 
///   may be exchanged without being
///   already assigned to occurrences.
/// 
/// The IfcRampType can have common material (using the
///   inverse relationship HasAssociations) or property
///   set information (using HasPropertySets) assigned. If
///   present, it does apply equally to all occurrences of the
///   IfcRampType. Property set information may be
///   overridden at the occurrence.
/// 
/// The occurrences of the IfcRampType are represented
///   by instances of IfcRamp.
/// 
/// HISTORY New entity in Release
///   IFC2x Edition 4.
class IFC_PARSE_API IfcRampType : public IfcBuildingElementType {
public:
    /// Identifies the predefined types of a ramp element from which the type required may be set.
    IfcRampTypeEnum::IfcRampTypeEnum PredefinedType() const;
    void setPredefinedType(IfcRampTypeEnum::IfcRampTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcBuildingElementType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcRampTypeEnum; } return IfcBuildingElementType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcBuildingElementType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRampType (IfcEntityInstanceData* e);
    IfcRampType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcRampTypeEnum::IfcRampTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcRampType > list;
};
/// A rational B-spline surface with knots is a piecewise parametric rational surface described in terms of control points, and associated weight values.
/// 
/// The surface is to be interpreted as follows:
/// 
/// σ
/// 
/// NOTE: The IfcRationalBSplineSurfaceWithKnots is an entity that had been adopted from ISO 10303, Industrial automation systems and integration — Product data representation and exchange, Part 42: Integrated generic resource: Geometric and topological representation.
/// 
/// NOTE: The specific subtype IfcRationalBSplineSurfaceWithKnots has been introduced to avoid the complexity of ANDOR subtype relationships in the ISO 10303-42 specification
/// 
/// NOTE: Corresponding ISO 10303 entity: rational_b_spline_surface. Please refer to ISO/IS 10303-42:1994, p. 85 for the final definition of the formal standard.
/// 
/// HISTORY: New entity in IFC2x4.
class IFC_PARSE_API IfcRationalBSplineSurfaceWithKnots : public IfcBSplineSurfaceWithKnots {
public:
    /// The weights associated with the control points in the rational case.
    std::vector< std::vector< double > > WeightsData() const;
    void setWeightsData(std::vector< std::vector< double > > v);
    virtual unsigned int getArgumentCount() const { return 13; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 12: return IfcUtil::Argument_AGGREGATE_OF_AGGREGATE_OF_DOUBLE; } return IfcBSplineSurfaceWithKnots::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 12: return Type::IfcReal; } return IfcBSplineSurfaceWithKnots::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 12: return "WeightsData"; } return IfcBSplineSurfaceWithKnots::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRationalBSplineSurfaceWithKnots (IfcEntityInstanceData* e);
    IfcRationalBSplineSurfaceWithKnots (int v1_UDegree, int v2_VDegree, IfcTemplatedEntityListList< IfcCartesianPoint >::ptr v3_ControlPointsList, IfcBSplineSurfaceForm::IfcBSplineSurfaceForm v4_SurfaceForm, bool v5_UClosed, bool v6_VClosed, bool v7_SelfIntersect, std::vector< int > /*[2:?]*/ v8_UMultiplicities, std::vector< int > /*[2:?]*/ v9_VMultiplicities, std::vector< double > /*[2:?]*/ v10_UKnots, std::vector< double > /*[2:?]*/ v11_VKnots, IfcKnotType::IfcKnotType v12_KnotSpec, std::vector< std::vector< double > > v13_WeightsData);
    typedef IfcTemplatedEntityList< IfcRationalBSplineSurfaceWithKnots > list;
};
/// Definition from IAI: Bars, wires, strands, meshes, tendons, and other components embedded in concrete in such a manner that the reinforcement and the concrete act together in resisting forces.
/// 
/// HISTORY New entity in IFC Release 2x2
/// 
/// IFC 2x4 CHANGE Entity made non-abstract.
/// Subtypes IfcTendon and IfcTendonAnchor removed.
/// Attribute SteelGrade removed.
/// Attributes PredefinedType and Role added.
class IFC_PARSE_API IfcReinforcingElement : public IfcElementComponent {
public:
    /// Whether the optional attribute SteelGrade is defined for this IfcReinforcingElement
    bool hasSteelGrade() const;
    std::string SteelGrade() const;
    void setSteelGrade(std::string v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_STRING; } return IfcElementComponent::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcLabel; } return IfcElementComponent::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "SteelGrade"; } return IfcElementComponent::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcReinforcingElement (IfcEntityInstanceData* e);
    IfcReinforcingElement (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_SteelGrade);
    typedef IfcTemplatedEntityList< IfcReinforcingElement > list;
};
/// Definition from IAI: Types of bars, wires, strands, meshes, tendons, and other components embedded in concrete in such a manner that the reinforcement and the concrete act together in resisting forces.
/// 
/// HISTORY New entity in IFC Release 2x4
class IFC_PARSE_API IfcReinforcingElementType : public IfcElementComponentType {
public:
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcElementComponentType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcElementComponentType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcElementComponentType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcReinforcingElementType (IfcEntityInstanceData* e);
    IfcReinforcingElementType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType);
    typedef IfcTemplatedEntityList< IfcReinforcingElementType > list;
};
/// Definition from IAI: A series of longitudinal and transverse wires or bars of various gauges, arranged at right angles to each other and welded at all points of intersection; usually used for concrete slab reinforcement. Also known as welded wire fabric.
/// 
/// HISTORY New entity in IFC Release 2x2
/// 
/// IFC 2x4 CHANGE All attributes removed; information now provided by IfcReinforcingMeshType.
/// 
/// Geometry Use Definition
/// 
/// The geometric representation of IfcReinforcingBar is given by the IfcProductDefinitionShape,
/// allowing multiple geometric representations. Included are:
/// 
/// Local Placement
/// The use of local placement is defined at the supertype IfcElementComponent.
/// 
/// Multiple Mapped Representation
/// See supertype IfcElementComponent.  This method of representation allows for several meshes
/// represented by a single instance of IfcReinforcingMesh.
/// 
/// An IfcElementQuantity,
/// attached via IfcRelDefinesByProperties, should contain an IfcQuantityCount named 'Count'
/// with the number of meshes represented by this instance.
/// 
/// Simplified Geometric Representation
/// Simplified geometric representations may be used based on local agreements.
class IFC_PARSE_API IfcReinforcingMesh : public IfcReinforcingElement {
public:
    /// Whether the optional attribute MeshLength is defined for this IfcReinforcingMesh
    bool hasMeshLength() const;
    double MeshLength() const;
    void setMeshLength(double v);
    /// Whether the optional attribute MeshWidth is defined for this IfcReinforcingMesh
    bool hasMeshWidth() const;
    double MeshWidth() const;
    void setMeshWidth(double v);
    /// Whether the optional attribute LongitudinalBarNominalDiameter is defined for this IfcReinforcingMesh
    bool hasLongitudinalBarNominalDiameter() const;
    double LongitudinalBarNominalDiameter() const;
    void setLongitudinalBarNominalDiameter(double v);
    /// Whether the optional attribute TransverseBarNominalDiameter is defined for this IfcReinforcingMesh
    bool hasTransverseBarNominalDiameter() const;
    double TransverseBarNominalDiameter() const;
    void setTransverseBarNominalDiameter(double v);
    /// Whether the optional attribute LongitudinalBarCrossSectionArea is defined for this IfcReinforcingMesh
    bool hasLongitudinalBarCrossSectionArea() const;
    double LongitudinalBarCrossSectionArea() const;
    void setLongitudinalBarCrossSectionArea(double v);
    /// Whether the optional attribute TransverseBarCrossSectionArea is defined for this IfcReinforcingMesh
    bool hasTransverseBarCrossSectionArea() const;
    double TransverseBarCrossSectionArea() const;
    void setTransverseBarCrossSectionArea(double v);
    /// Whether the optional attribute LongitudinalBarSpacing is defined for this IfcReinforcingMesh
    bool hasLongitudinalBarSpacing() const;
    double LongitudinalBarSpacing() const;
    void setLongitudinalBarSpacing(double v);
    /// Whether the optional attribute TransverseBarSpacing is defined for this IfcReinforcingMesh
    bool hasTransverseBarSpacing() const;
    double TransverseBarSpacing() const;
    void setTransverseBarSpacing(double v);
    /// Whether the optional attribute PredefinedType is defined for this IfcReinforcingMesh
    bool hasPredefinedType() const;
    /// The predefined type is always MESH.
    IfcReinforcingMeshTypeEnum::IfcReinforcingMeshTypeEnum PredefinedType() const;
    void setPredefinedType(IfcReinforcingMeshTypeEnum::IfcReinforcingMeshTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 18; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_DOUBLE; case 10: return IfcUtil::Argument_DOUBLE; case 11: return IfcUtil::Argument_DOUBLE; case 12: return IfcUtil::Argument_DOUBLE; case 13: return IfcUtil::Argument_DOUBLE; case 14: return IfcUtil::Argument_DOUBLE; case 15: return IfcUtil::Argument_DOUBLE; case 16: return IfcUtil::Argument_DOUBLE; case 17: return IfcUtil::Argument_ENUMERATION; } return IfcReinforcingElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcPositiveLengthMeasure; case 10: return Type::IfcPositiveLengthMeasure; case 11: return Type::IfcPositiveLengthMeasure; case 12: return Type::IfcPositiveLengthMeasure; case 13: return Type::IfcAreaMeasure; case 14: return Type::IfcAreaMeasure; case 15: return Type::IfcPositiveLengthMeasure; case 16: return Type::IfcPositiveLengthMeasure; case 17: return Type::IfcReinforcingMeshTypeEnum; } return IfcReinforcingElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "MeshLength"; case 10: return "MeshWidth"; case 11: return "LongitudinalBarNominalDiameter"; case 12: return "TransverseBarNominalDiameter"; case 13: return "LongitudinalBarCrossSectionArea"; case 14: return "TransverseBarCrossSectionArea"; case 15: return "LongitudinalBarSpacing"; case 16: return "TransverseBarSpacing"; case 17: return "PredefinedType"; } return IfcReinforcingElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcReinforcingMesh (IfcEntityInstanceData* e);
    IfcReinforcingMesh (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_SteelGrade, boost::optional< double > v10_MeshLength, boost::optional< double > v11_MeshWidth, boost::optional< double > v12_LongitudinalBarNominalDiameter, boost::optional< double > v13_TransverseBarNominalDiameter, boost::optional< double > v14_LongitudinalBarCrossSectionArea, boost::optional< double > v15_TransverseBarCrossSectionArea, boost::optional< double > v16_LongitudinalBarSpacing, boost::optional< double > v17_TransverseBarSpacing, boost::optional< IfcReinforcingMeshTypeEnum::IfcReinforcingMeshTypeEnum > v18_PredefinedType);
    typedef IfcTemplatedEntityList< IfcReinforcingMesh > list;
};
/// Definition from IAI: A series of longitudinal and transverse wires or bars of various gauges, arranged at right angles to each other and welded at all points of intersection; usually used for concrete slab reinforcement. Also known as welded wire fabric.
/// 
/// HISTORY New entity in IFC Release 2x4
/// 
/// Material Use Definition:
/// 
/// An associated material denotes the steel grade, preferrably via material classification.
/// 
/// Geometry Use Definition:
/// 
/// The IfcReinforcingMeshType may define the shared geometric representation for all mesh occurrences. The RepresentationMaps attribute refers to a list of IfcRepresentationMap's, that allow for multiple geometric representations.
class IFC_PARSE_API IfcReinforcingMeshType : public IfcReinforcingElementType {
public:
    /// The predefined type is always MESH.
    IfcReinforcingMeshTypeEnum::IfcReinforcingMeshTypeEnum PredefinedType() const;
    void setPredefinedType(IfcReinforcingMeshTypeEnum::IfcReinforcingMeshTypeEnum v);
    /// Whether the optional attribute MeshLength is defined for this IfcReinforcingMeshType
    bool hasMeshLength() const;
    /// The overall length of the mesh measured in its longitudinal direction.
    double MeshLength() const;
    void setMeshLength(double v);
    /// Whether the optional attribute MeshWidth is defined for this IfcReinforcingMeshType
    bool hasMeshWidth() const;
    /// The overall width of the mesh measured in its transversal direction.
    double MeshWidth() const;
    void setMeshWidth(double v);
    /// Whether the optional attribute LongitudinalBarNominalDiameter is defined for this IfcReinforcingMeshType
    bool hasLongitudinalBarNominalDiameter() const;
    /// The nominal diameter denoting the cross-section size of the longitudinal bars.
    double LongitudinalBarNominalDiameter() const;
    void setLongitudinalBarNominalDiameter(double v);
    /// Whether the optional attribute TransverseBarNominalDiameter is defined for this IfcReinforcingMeshType
    bool hasTransverseBarNominalDiameter() const;
    /// The nominal diameter denoting the cross-section size of the transverse bars.
    double TransverseBarNominalDiameter() const;
    void setTransverseBarNominalDiameter(double v);
    /// Whether the optional attribute LongitudinalBarCrossSectionArea is defined for this IfcReinforcingMeshType
    bool hasLongitudinalBarCrossSectionArea() const;
    /// The effective cross-section area of the longitudinal bars of the mesh.
    double LongitudinalBarCrossSectionArea() const;
    void setLongitudinalBarCrossSectionArea(double v);
    /// Whether the optional attribute TransverseBarCrossSectionArea is defined for this IfcReinforcingMeshType
    bool hasTransverseBarCrossSectionArea() const;
    /// The effective cross-section area of the transverse bars of the mesh.
    double TransverseBarCrossSectionArea() const;
    void setTransverseBarCrossSectionArea(double v);
    /// Whether the optional attribute LongitudinalBarSpacing is defined for this IfcReinforcingMeshType
    bool hasLongitudinalBarSpacing() const;
    /// The spacing between the longitudinal bars.  Note: an even distribution of bars is presumed; other cases are handled by classification or property sets.
    double LongitudinalBarSpacing() const;
    void setLongitudinalBarSpacing(double v);
    /// Whether the optional attribute TransverseBarSpacing is defined for this IfcReinforcingMeshType
    bool hasTransverseBarSpacing() const;
    /// The spacing between the transverse bars.  Note: an even distribution of bars is presumed; other cases are handled by classification or property sets.
    double TransverseBarSpacing() const;
    void setTransverseBarSpacing(double v);
    /// Whether the optional attribute BendingShapeCode is defined for this IfcReinforcingMeshType
    bool hasBendingShapeCode() const;
    std::string BendingShapeCode() const;
    void setBendingShapeCode(std::string v);
    /// Whether the optional attribute BendingParameters is defined for this IfcReinforcingMeshType
    bool hasBendingParameters() const;
    IfcEntityList::ptr BendingParameters() const;
    void setBendingParameters(IfcEntityList::ptr v);
    virtual unsigned int getArgumentCount() const { return 20; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; case 10: return IfcUtil::Argument_DOUBLE; case 11: return IfcUtil::Argument_DOUBLE; case 12: return IfcUtil::Argument_DOUBLE; case 13: return IfcUtil::Argument_DOUBLE; case 14: return IfcUtil::Argument_DOUBLE; case 15: return IfcUtil::Argument_DOUBLE; case 16: return IfcUtil::Argument_DOUBLE; case 17: return IfcUtil::Argument_DOUBLE; case 18: return IfcUtil::Argument_STRING; case 19: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } return IfcReinforcingElementType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcReinforcingMeshTypeEnum; case 10: return Type::IfcPositiveLengthMeasure; case 11: return Type::IfcPositiveLengthMeasure; case 12: return Type::IfcPositiveLengthMeasure; case 13: return Type::IfcPositiveLengthMeasure; case 14: return Type::IfcAreaMeasure; case 15: return Type::IfcAreaMeasure; case 16: return Type::IfcPositiveLengthMeasure; case 17: return Type::IfcPositiveLengthMeasure; case 18: return Type::IfcLabel; case 19: return Type::IfcBendingParameterSelect; } return IfcReinforcingElementType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; case 10: return "MeshLength"; case 11: return "MeshWidth"; case 12: return "LongitudinalBarNominalDiameter"; case 13: return "TransverseBarNominalDiameter"; case 14: return "LongitudinalBarCrossSectionArea"; case 15: return "TransverseBarCrossSectionArea"; case 16: return "LongitudinalBarSpacing"; case 17: return "TransverseBarSpacing"; case 18: return "BendingShapeCode"; case 19: return "BendingParameters"; } return IfcReinforcingElementType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcReinforcingMeshType (IfcEntityInstanceData* e);
    IfcReinforcingMeshType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcReinforcingMeshTypeEnum::IfcReinforcingMeshTypeEnum v10_PredefinedType, boost::optional< double > v11_MeshLength, boost::optional< double > v12_MeshWidth, boost::optional< double > v13_LongitudinalBarNominalDiameter, boost::optional< double > v14_TransverseBarNominalDiameter, boost::optional< double > v15_LongitudinalBarCrossSectionArea, boost::optional< double > v16_TransverseBarCrossSectionArea, boost::optional< double > v17_LongitudinalBarSpacing, boost::optional< double > v18_TransverseBarSpacing, boost::optional< std::string > v19_BendingShapeCode, boost::optional< IfcEntityList::ptr > v20_BendingParameters);
    typedef IfcTemplatedEntityList< IfcReinforcingMeshType > list;
};
/// The aggregation relationship
/// IfcRelAggregates is a special type of the general
/// composition/decomposition (or whole/part) relationship
/// IfcRelDecomposes. The aggregation relationship can be
/// applied to all subtypes of IfcObjectDefinition.
/// In cases of aggregation of physical elements into a physical
/// aggregate the shape representation of the whole (within the same
/// representation identifier) can be taken from the sum of the shape
/// representations of the parts.
/// EXAMPLE A roof is the aggregation of the roof
/// elements, such as roof slabs, rafters, purlins, etc. Within the
/// same representation identifier, e.g. the body geometric
/// representation, the shape representation of the roof is given by
/// the shape representation of its parts
/// Decompositions imply a dependency, i.e. the definition of the
/// whole depends on the definition of the parts and the parts depend
/// on the existence of the whole. The behaviour that is implied from
/// the dependency has to be established inside the applications.
/// 
/// HISTORY New entity in IFC Release 2x.
/// 
/// IFC2x4 CHANGE The attributes RelatingObject and RelatedObjects are demoted from the supertype IfcRelDecomposes.
class IFC_PARSE_API IfcRelAggregates : public IfcRelDecomposes {
public:
    /// The object definition, either an object type or an object occurrence, that represents the aggregation. It is the whole within the whole/part relationship.
    /// 
    /// IFC2x4 CHANGE  The attribute has been demoted from the supertype IfcRelDecomposes and defines the non-ordered aggregation relationship.
    IfcObjectDefinition* RelatingObject() const;
    void setRelatingObject(IfcObjectDefinition* v);
    /// The object definitions, either object occurrences or object types, that are being aggregated. They are defined as the parts in the whole/part relationship. No order is implied between the parts.
    /// 
    /// IFC2x4 CHANGE  The attribute has been demoted from the supertype IfcRelDecomposes and defines the non-ordered set of parts within the aggregation.
    IfcTemplatedEntityList< IfcObjectDefinition >::ptr RelatedObjects() const;
    void setRelatedObjects(IfcTemplatedEntityList< IfcObjectDefinition >::ptr v);
    virtual unsigned int getArgumentCount() const { return 6; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 4: return IfcUtil::Argument_ENTITY_INSTANCE; case 5: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } return IfcRelDecomposes::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 4: return Type::IfcObjectDefinition; case 5: return Type::IfcObjectDefinition; } return IfcRelDecomposes::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 4: return "RelatingObject"; case 5: return "RelatedObjects"; } return IfcRelDecomposes::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRelAggregates (IfcEntityInstanceData* e);
    IfcRelAggregates (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, IfcObjectDefinition* v5_RelatingObject, IfcTemplatedEntityList< IfcObjectDefinition >::ptr v6_RelatedObjects);
    typedef IfcTemplatedEntityList< IfcRelAggregates > list;
};
/// Definition from IAI: The element type
///   IfcRoofType defines a list of commonly shared
///   property set definitions of a roof and an optional set of
///   product representations. It is used to define a roof
///   specification (i.e. the specific product information, that
///   is common to all occurrences of that product type).
/// 
/// NOTE The product representations are defined as
///   representation maps (at the level of the supertype
///   IfcTypeProduct, which gets assigned by an element
///   occurrence instance through the
///   IfcShapeRepresentation.Item[1] being an
///   IfcMappedItem.
/// 
/// An IfcRoofTypeÿis used to define the common
///   properties of a specific roof that may be applied to many
///   instances of that type to assign a specific style. Building
///   element types (or the instantiable subtypes) may be
///   exchanged without being already assigned to occurrences.
/// 
/// The IfcRoofType can have common material (using the
///   inverse relationship HasAssociations) or property
///   set information (using HasPropertySets) assigned. If
///   present, it does apply equally to all occurrences of the
///   IfcRoofType. Property set information may be
///   overridden at the occurrence.
/// 
/// The occurrences of the IfcRoofType are represented
///   by instances of IfcRoof.
/// 
/// HISTORY New entity in Release
///   IFC2x Edition 4.
class IFC_PARSE_API IfcRoofType : public IfcBuildingElementType {
public:
    /// Identifies the predefined types of a roof element from which the type required may be set.
    IfcRoofTypeEnum::IfcRoofTypeEnum PredefinedType() const;
    void setPredefinedType(IfcRoofTypeEnum::IfcRoofTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcBuildingElementType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcRoofTypeEnum; } return IfcBuildingElementType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcBuildingElementType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRoofType (IfcEntityInstanceData* e);
    IfcRoofType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcRoofTypeEnum::IfcRoofTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcRoofType > list;
};
/// The flow terminal type IfcSanitaryTerminalType defines commonly shared information for occurrences of sanitary terminals.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a sanitary terminal specification (i.e. the specific product information, that is common to all occurrences of that product type).  Sanitary Terminal types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcSanitaryTerminalType are represented by instances of IfcSanitaryTerminal. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcFlowTerminalType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_SanitaryTerminalTypeCommon 
/// 
/// The following property set definitions are applicable to this entity according to the PredefinedType attribute:  
/// Pset_SanitaryTerminalTypeBath (BATH) 
/// Pset_SanitaryTerminalTypeBidet (BIDET) 
/// Pset_SanitaryTerminalTypeCistern (CISTERN) 
/// Pset_SanitaryTerminalTypeSanitaryFountain (SANITARYFOUNTAIN) 
/// Pset_SanitaryTerminalTypeShower (SHOWER) 
/// Pset_SanitaryTerminalTypeSink (SINK) 
/// Pset_SanitaryTerminalTypeToiletPan (TOILETPAN) 
/// Pset_SanitaryTerminalTypeUrinal (URINAL) 
/// Pset_SanitaryTerminalTypeWashHandBasin (WASHHANDBASIN) 
/// 
/// Material Use Definition 
/// The material of the IfcSanitaryTerminalType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Body': The primary material from which the object is constructed. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcSanitaryTerminalType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcSanitaryTerminal for standard port definitions.
class IFC_PARSE_API IfcSanitaryTerminalType : public IfcFlowTerminalType {
public:
    /// Identifies the predefined types of sanitary terminal from which the type required may be set.
    IfcSanitaryTerminalTypeEnum::IfcSanitaryTerminalTypeEnum PredefinedType() const;
    void setPredefinedType(IfcSanitaryTerminalTypeEnum::IfcSanitaryTerminalTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcFlowTerminalType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcSanitaryTerminalTypeEnum; } return IfcFlowTerminalType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcFlowTerminalType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcSanitaryTerminalType (IfcEntityInstanceData* e);
    IfcSanitaryTerminalType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcSanitaryTerminalTypeEnum::IfcSanitaryTerminalTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcSanitaryTerminalType > list;
};

class IFC_PARSE_API IfcSeamCurve : public IfcSurfaceCurve {
public:
    virtual unsigned int getArgumentCount() const { return 3; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcSurfaceCurve::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcSurfaceCurve::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcSurfaceCurve::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcSeamCurve (IfcEntityInstanceData* e);
    IfcSeamCurve (IfcCurve* v1_Curve3D, IfcTemplatedEntityList< IfcPcurve >::ptr v2_AssociatedGeometry, IfcPreferredSurfaceCurveRepresentation::IfcPreferredSurfaceCurveRepresentation v3_MasterRepresentation);
    typedef IfcTemplatedEntityList< IfcSeamCurve > list;
};
/// Definition from IAI: The IfcShadingDeviceType
/// defines a list of commonly shared property set definitions of a
/// shading device element and an optional set of product
/// representations. It is used to define a shading device
/// specification (i.e. the specific product information, that is
/// common to all occurrences of that product type).
/// NOTE: The product representations are defined
/// as representation maps (at the level of the supertype
/// IfcTypeProduct, which gets assigned by an element
/// occurrence instance through the
/// IfcShapeRepresentation.Item[1] being an
/// IfcMappedItem.
/// A shading device type is used to define the common properties
/// of a certain type of chimney that may be applied to many
/// instances of that type to assign a specific style. Shading device
/// types may be exchanged without being already assigned to
/// occurrences.
/// The occurrences of the IfcShadingDeviceType are
/// represented by instances of IfcShadingDevice.
/// HISTORY New entity in
/// Release IFC2x4.
class IFC_PARSE_API IfcShadingDeviceType : public IfcBuildingElementType {
public:
    /// Identifies the predefined types of a shading device element from which the type required may be set.
    IfcShadingDeviceTypeEnum::IfcShadingDeviceTypeEnum PredefinedType() const;
    void setPredefinedType(IfcShadingDeviceTypeEnum::IfcShadingDeviceTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcBuildingElementType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcShadingDeviceTypeEnum; } return IfcBuildingElementType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcBuildingElementType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcShadingDeviceType (IfcEntityInstanceData* e);
    IfcShadingDeviceType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcShadingDeviceTypeEnum::IfcShadingDeviceTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcShadingDeviceType > list;
};
/// Definition from ISO 6707-1:1989: Area where construction
/// works are undertaken.
/// A site is a defined area of land, possibly
/// covered with water, on which the project construction is to be
/// completed. A site may be used to erect building(s) or other AEC
/// products.
/// A site (IfcSite) may include a definition of the single
/// geographic reference point for this site (global position using
/// WGS84 with Longitude, Latitude and Elevation).
/// The precision is provided up to millionth of a second and it
/// provides an absolute placement in relation to the real world as
/// used in exchange with geospational information systems. If
/// asserted, the Longitude, Latitude and
/// Elevation establish the point in WGS84 where the point
/// 0.,0.,0. of the LocalPlacement of IfcSite is
/// situated.
/// The geometrical placement of the site, defined by the
/// IfcLocalPlacement, shall be always relative to the spatial
/// structure element, in which this site is included, or absolute,
/// i.e. to the world coordinate system, as established by the
/// geometric representation context of the project. The world
/// coordinate system, established at the
/// IfcProject.RepresentationContexts, may include a definition
/// of the true north within the XY plane of the world coordinate
/// system, if provided, it can be obtained at
/// IfcGeometricRepresentationContext.TrueNorth.
/// A project may span over several connected or disconnected sites.
/// Therefore site complex provides for a collection of sites included
/// in a project. A site can also be decomposed in parts, where each
/// part defines a site section. This is defined by the composition
/// type attribute of the supertype IfcSpatialStructureElements
/// which is interpreted as follow:
/// 
/// COMPLEX = site complex
/// ELEMENT = site
/// PARTIAL = site section
/// 
/// HISTORY  New entity in IFC Release 1.0.
/// 
/// Property Set Use Definition
/// The property sets relating to the IfcSite are defined by
/// the IfcPropertySet and attached by the
/// IfcRelDefinesByProperties relationship. It is accessible by
/// the inverse IsDefinedBy relationship. The following property
/// set definitions specific to the IfcSite are part of this IFC
/// release:
/// 
/// Pset_SiteCommon: common property set for all
/// types of site
/// 
/// Quantity Use Definition
/// The quantities relating to the IfcSite are defined by the
/// IfcElementQuantity and attached by the
/// IfcRelDefinesByProperties relationship. It is accessible by
/// the inverse IsDefinedBy relationship. The following base
/// quantities are defined and should be exchanged with the
/// IfcElementQuantity.Name = 'BaseQuantities'. Other
/// quantities, being subjected to local standard of measurement, can
/// be defined with another string value assigned to Name. In
/// this case a valid value for MethodOfMeasurement has to be
/// provided.
/// 
/// Qto_SiteBaseQuantities: base quantities for all site
/// occurrences.
/// 
/// Spatial Structure Use Definition
/// The IfcSite is used to build the spatial structure of a
/// building (that serves as the primary project breakdown and is
/// required to be hierarchical). The spatial structure elements are
/// linked together by using the objectified relationship
/// IfcRelAggregates. The IfcSite references them by its
/// inverse relationships:
/// 
/// IfcSite.Decomposes -- referencing (IfcProject ||
/// IfcSite) by IfcRelAggregates.RelatingObject, If it
/// refers to another instance of IfcSite, the referenced
/// IfcSite needs to have a different and higher
/// CompositionType, i.e. COMPLEX (if the other IfcSite
/// has ELEMENT), or ELEMENT (if the other IfcSite has
/// PARTIAL).
/// IfcSite.IsDecomposedBy -- referencing (IfcSite ||
/// IfcBuilding || IfcSpace) by
/// IfcRelAggregates.RelatedObjects. If it refers to another
/// instance of IfcSite, the referenced IfcSite needs to
/// have a different and lower CompositionType, i.e. ELEMENT (if the
/// other IfcSite has COMPLEX), or PARTIAL (if the other
/// IfcSite has ELEMENT).
/// 
/// If there are building elements and/or other elements directly
/// related to the IfcSite (like a fence, or a shear wall), they
/// are associated with the IfcSite by using the objectified
/// relationship IfcRelContainedInSpatialStructure. The
/// IfcIfcSite references them by its inverse relationship:
/// 
/// IfcSite.ContainsElements -- referencing any subtype of
/// IfcProduct (with the exception of other spatial structure
/// element) by
/// IfcRelContainedInSpatialStructure.RelatedElements.
/// 
/// Figure 51 shows the IfcSite as part of the spatial structure. In addition to the logical spatial structure, also the placement hierarchy is shown. In this example the spatial structure hierarchy and the placement hierarchy are identical.
/// NOTE Detailed requirements on mandatory element containment and placement structure relationships are given in view definitions and implementer agreements.
/// 
/// Figure 51 — Site composition
/// 
/// Attribute Use Definition
/// Figure 52 describes the heights and elevations of the IfcSite. It is used to provide the geographic longitude, latitude, and height above sea level for the origin of the site. The origin of the site is the local placement.
/// The provision of longitude, latitude, height at the IfcSite for georeferencing is provided for upward compatibility reasons. It requires a single instance of IfcSite and WGS84 as coordinate reference system.
/// For exact georeferencing the new entities IfcCoordinateReferenceSystem and IfcMapConversion should be used.
/// 
/// reference height of site is provided by: IfcSite.RefElevation, it is given according to the height datum used at this location.
/// the reference height of each building situated at the site is given againt the same height datum used at this location.
/// the elevations of each storey belonging to each building are given as local height relative to the reference height of the building.
/// 
///  
/// Figure 52 — Site elevations
/// 
/// Geometry Use Definitions
/// The geometric representation of IfcSite is given by the
/// IfcProductDefinitionShape and IfcLocalPlacement
/// allowing multiple geometric representations.
/// Local placement
/// The local placement for IfcSite is defined in its
/// supertype IfcProduct. It is defined by the
/// IfcLocalPlacement, which defines the local coordinate system
/// that is referenced by all geometric representations.
/// 
/// The PlacementRelTo relationship of
/// IfcLocalPlacement shall point to the
/// IfcSpatialStructureElement of type "IfcSite", if
/// relative placement is used (e.g. to position a site relative a a
/// site complex, or a site section to a site).
/// If the relative placement is not used, the absolute placement
/// is defined within the world coordinate system. If there is only one
/// site object, then this is the default situation.
/// 
/// Foot Print Representation
/// The foot print representation of IfcSite is given by
/// either a single 2D curve (such as IfcPolyline or
/// IfcCompositeCurve), or by a list of 2D curves (in case of
/// inner boundaries).
/// The representation identifier and type of this geometric
/// representation of IfcSite is:
/// 
/// IfcShapeRepresentation.RepresentationIdentifier =
/// 'FootPrint'
/// IfcShapeRepresentation.RepresentationType =
/// 'GeometricCurveSet', or 'Annotation2D'
/// 
/// Survey Points Representation
/// The survey point representation of IfcSite is defined
/// using a set of survey points and optionally breaklines. The
/// breaklines are restricted to only connect points given in the set
/// of survey points. Breaklines, if given, are used to constrain the
/// triangulation.
/// The representation identifier and type of this geometric
/// representation of IfcSite is:
/// 
/// IfcShapeRepresentation.RepresentationIdentifier =
/// 'SurveyPoints'
/// IfcShapeRepresentation.RepresentationType =
/// 'GeometricCurveSet'
/// 
/// Figure 53 shows a set of survey points, given as 3D Cartesian points within the object coordinate system of the site.  Figure 54 shows the result after facetation.
/// The set of IfcCartesianPoint is included in the set of IfcGeometricCurveSet.Elements.
/// 
/// Figure 53 — Site survey points
/// Figure 54 — Site survey points facetation
/// 
/// Figure 55 shows A set of survey points, given as 3D Cartesian points, and a set of break points, given as a set of lines, connecting some survey points, within the object coordinate system of the site.  Figure 56 shows the result after facetation.
/// The set of IfcCartesianPoint and the set of IfcPolyline are included in the set of IfcGeometricCurveSet.Elements.
/// 
/// Figure 55 — Site breaklines
/// Figure 56 — Site breaklines facetation
/// 
/// NOTE  The geometric representation of the site has been based on the ARM level description of the site_shape_representation given within the ISO 10303-225 "Building Elements using explicit shape representation".
/// 
/// Body Representation
/// The body representation of IfcSite is defined using a
/// solid or surface model. Applicable solids are the
/// IfcFacetedBrep or on the IfcFacetedBrepWithVoids,
/// applicable surface models are the IfcFaceBasedSurfaceModel
/// and the IfcShellBasedSurfaceModel.
/// The representation identifier and type of this representation of
/// IfcSite is:
/// 
/// IfcShapeRepresentation.RepresentationIdentifier =
/// 'Body'
/// IfcShapeRepresentation.RepresentationType = 'Brep', or
/// 'SurfaceModel'
class IFC_PARSE_API IfcSite : public IfcSpatialStructureElement {
public:
    /// Whether the optional attribute RefLatitude is defined for this IfcSite
    bool hasRefLatitude() const;
    /// World Latitude at reference point (most likely defined in legal description). Defined as integer values for degrees, minutes, seconds, and, optionally, millionths of seconds with respect to the world geodetic system WGS84.
    ///   Latitudes are measured relative to the geodetic equator, north of the equator by positive values - from 0 till +90,   south of the equator by negative values - from 0 till  -90.
    std::vector< int > /*[3:4]*/ RefLatitude() const;
    void setRefLatitude(std::vector< int > /*[3:4]*/ v);
    /// Whether the optional attribute RefLongitude is defined for this IfcSite
    bool hasRefLongitude() const;
    /// World Longitude at reference point (most likely defined in legal description). Defined as integer values for degrees, minutes, seconds, and, optionally, millionths of seconds with respect to the world geodetic system WGS84.
    ///   Longitudes are measured relative to the geodetic zero meridian, nominally the same as the Greenwich prime meridian: longitudes west of the zero meridian have negative values - from 0 till -180, longitudes east of the zero meridian have positive values - from 0 till -180.
    /// Example: Chicago Harbor Light has according to WGS84 a longitude -87.35.40 (or 87.35.40W) and a latitude 41.53.30 (or 41.53.30N).
    std::vector< int > /*[3:4]*/ RefLongitude() const;
    void setRefLongitude(std::vector< int > /*[3:4]*/ v);
    /// Whether the optional attribute RefElevation is defined for this IfcSite
    bool hasRefElevation() const;
    /// Datum elevation relative to sea level.
    double RefElevation() const;
    void setRefElevation(double v);
    /// Whether the optional attribute LandTitleNumber is defined for this IfcSite
    bool hasLandTitleNumber() const;
    /// The land title number (designation of the site within a regional system).
    std::string LandTitleNumber() const;
    void setLandTitleNumber(std::string v);
    /// Whether the optional attribute SiteAddress is defined for this IfcSite
    bool hasSiteAddress() const;
    /// Address given to the site for postal purposes.
    IfcPostalAddress* SiteAddress() const;
    void setSiteAddress(IfcPostalAddress* v);
    virtual unsigned int getArgumentCount() const { return 14; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_AGGREGATE_OF_INT; case 10: return IfcUtil::Argument_AGGREGATE_OF_INT; case 11: return IfcUtil::Argument_DOUBLE; case 12: return IfcUtil::Argument_STRING; case 13: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcSpatialStructureElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcCompoundPlaneAngleMeasure; case 10: return Type::IfcCompoundPlaneAngleMeasure; case 11: return Type::IfcLengthMeasure; case 12: return Type::IfcLabel; case 13: return Type::IfcPostalAddress; } return IfcSpatialStructureElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "RefLatitude"; case 10: return "RefLongitude"; case 11: return "RefElevation"; case 12: return "LandTitleNumber"; case 13: return "SiteAddress"; } return IfcSpatialStructureElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcSite (IfcEntityInstanceData* e);
    IfcSite (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_LongName, boost::optional< IfcElementCompositionEnum::IfcElementCompositionEnum > v9_CompositionType, boost::optional< std::vector< int > /*[3:4]*/ > v10_RefLatitude, boost::optional< std::vector< int > /*[3:4]*/ > v11_RefLongitude, boost::optional< double > v12_RefElevation, boost::optional< std::string > v13_LandTitleNumber, IfcPostalAddress* v14_SiteAddress);
    typedef IfcTemplatedEntityList< IfcSite > list;
};
/// The element type IfcSlabType defines commonly shared
/// information for occurrences of slabs. The set of shared information
/// may include:
/// 
/// common properties within shared property sets
/// common material information
/// common material layer definitions
/// common shape representations
/// 
/// NOTE It is illegal to share shape
/// representations as representation maps for occurrences of
/// IfcSlabStandardCase.
/// 
/// It is used to define a slab specification (i.e. the specific
/// product information, that is common to all occurrences of that
/// product type). Slab types may be exchanged without being already
/// assigned to occurrences.
/// NOTE The product representations are defined as
/// representation maps (at the level of the supertype
/// IfcTypeProduct, which gets assigned by an element occurrence
/// instance through the IfcShapeRepresentation.Item[1] being an
/// IfcMappedItem.
/// The occurrences of the IfcSlabType within building models
/// are represented by instances of IfcSlabStandardCase if the
/// IfcSlabType has a single associated
/// IfcMaterialLayerSet; otherwise they are represented by
/// instances of IfcSlab, or IfcSlabElementedCase.
/// 
/// HISTORY  New
/// entity in Release IFC2x2.
/// 
/// Informal proposition:
/// 
/// The material assignment, if provided using the
/// IfcRelAssociatesMaterial relationship, shall not reference
/// the IfcMaterialLayerSetUsage.
/// 
/// Material Use Definition
/// The material of the IfcSlabType is defined by the
/// IfcMaterialLayerSet or as fall back by IfcMaterial
/// and attached by the
/// IfcRelAssociatesMaterial.RelatingMaterial. It is
/// accessible by the inverse HasAssociations relationship.
/// Note: It is illegal to assign an
/// IfcMaterial to an IfcSlabType, if there is at least
/// one occurrences. of IfcSlabStandardCase for this
/// type.
/// Layer Set Use Definition:
/// The shared material layer set definition is defined by assigning
/// an IfcMaterialLayerSet (see material use definition above).
/// The IfcMaterialLayer refers to one or several of
/// IfcMaterial that is the common for all slab occurrence, if
/// used. It is only applicable if the IfcSlabType has only
/// occurrences of type IfcSlabStandardCase (see definition of
/// IfcSlabStandardCase for further information).
/// NOTE Since each individual instance of
/// IfcSlabStandardCase defines its own
/// IfcMaterialLayerSetUsage including the offset from the
/// reference plane, the same IfcSlabType can be used
/// independently of the reference plane alignment of its
/// occurrences.
/// Property Set Use Definition:
/// The shared property sets relating to the IfcSlabType are
/// defined by the IfcPropertySet and are attached by the
/// HasPropertySets attribute. The following property set
/// definitions specific to the IfcWallType are part of this IFC
/// release:
/// NOTE There is no differentiation between
/// properties within the property set that are only assignable to
/// IfcSlabType and those that are only assignable to
/// IfcSlab. If the same property is assigned to the
/// IfcSlabType and the IfcSlab being an occurrence of
/// the IfcSlabType, then the occurrence property overrides the
/// type property.
/// 
/// Pset_SlabCommon: common property set for all
/// slab types.
class IFC_PARSE_API IfcSlabType : public IfcBuildingElementType {
public:
    /// Identifies the predefined types of a slab element from which the type required may be set.
    IfcSlabTypeEnum::IfcSlabTypeEnum PredefinedType() const;
    void setPredefinedType(IfcSlabTypeEnum::IfcSlabTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcBuildingElementType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcSlabTypeEnum; } return IfcBuildingElementType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcBuildingElementType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcSlabType (IfcEntityInstanceData* e);
    IfcSlabType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcSlabTypeEnum::IfcSlabTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcSlabType > list;
};
/// The energy conversion device type IfcSolarDeviceType defines commonly shared information for occurrences of solar devices.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a solar device specification (i.e. the specific product information, that is common to all occurrences of that product type).  Solar Device types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcSolarDeviceType are represented by instances of IfcSolarDevice. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcEnergyConversionDeviceType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_SolarDeviceTypeCommon 
/// 
/// Material Use Definition 
/// The material of the IfcSolarDeviceType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Casing': Material from which the casing is constructed. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcSolarDeviceType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcSolarDevice for standard port definitions.
class IFC_PARSE_API IfcSolarDeviceType : public IfcEnergyConversionDeviceType {
public:
    IfcSolarDeviceTypeEnum::IfcSolarDeviceTypeEnum PredefinedType() const;
    void setPredefinedType(IfcSolarDeviceTypeEnum::IfcSolarDeviceTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcEnergyConversionDeviceType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcSolarDeviceTypeEnum; } return IfcEnergyConversionDeviceType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcEnergyConversionDeviceType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcSolarDeviceType (IfcEntityInstanceData* e);
    IfcSolarDeviceType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcSolarDeviceTypeEnum::IfcSolarDeviceTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcSolarDeviceType > list;
};
/// A space represents an area or volume
/// bounded actually or theoretically. Spaces are areas or volumes that
/// provide for certain functions within a building.
/// A space is associated to a building storey (or in case of
/// exterior spaces to a site). A space may span over several connected
/// spaces. Therefore a space group provides for a collection of spaces
/// included in a storey. A space can also be decomposed in parts,
/// where each part defines a partial space. This is defined by the
/// CompositionType attribute of the supertype
/// IfcSpatialStructureElement which is interpreted as
/// follow:
/// 
/// COMPLEX = space group
/// ELEMENT = space
/// PARTIAL = partial space
/// 
/// NOTE View definitions and implementation
/// agreements may restrict spaces with CompositionType=ELEMENT
/// to be non-overlapping.
/// The following guidelines should apply for using the Name,
/// Description, LongName and ObjectType
/// attributes.
/// 
/// Name holds the unique name (or space number) from the
/// plan.
/// Description holds any additional information field the
/// user may have specified, there are no further recommendations.
/// LongName holds the full name of the space, it is often
/// used in addition to the Name, if a number is assigned to the
/// room, then the descriptive name is exchanged as
/// LongName.
/// ObjectType holds the space type, i.e. usually the
/// functional category of the space .
/// 
/// HISTORY New Entity in IFC Release 1.0
/// 
/// Property Set Use Definition
/// The property sets relating to the IfcSpace are defined by
/// the IfcPropertySet and attached by the
/// IfcRelDefinesByProperties relationship. It is accessible by
/// the inverse IsDefinedBy relationship. The following property
/// set definitions specific to the IfcSpace are part of this
/// IFC release:
/// 
/// Pset_SpaceCommon: common property set for all
/// types of spaces
/// 
/// Pset_SpaceParking: specific property set for
/// only those spaces that are used to define parking spaces by
/// PredefinedType: PARKING
/// 
/// Pset_SpaceFireSafetyRequirements: common
/// property set for all types of spaces to capture the fire safety
/// requirements
/// Pset_SpaceLightingRequirements: common property
/// set for all types of spaces to capture the lighting
/// requirements
/// Pset_SpaceOccupancyRequirements: common
/// property set for all types of spaces to capture the occupancy
/// requirements
/// Pset_SpaceThermalRequirements: common property
/// set for all types of spaces to capture the thermal
/// requirements
/// Pset_SpaceThermalDesign: common property set
/// for all all types of spaces to capture building service design
/// values
/// 
/// Quantity Use Definition
/// The quantities relating to the IfcSpace are defined by
/// the IfcElementQuantity and attached by the
/// IfcRelDefinesByProperties relationship. It is accessible by
/// the inverse IsDefinedBy relationship. The following base
/// quantities are defined and should be exchanged with the
/// IfcElementQuantity.Name = 'BaseQuantities'. Other
/// quantities, being subjected to local standard of measurement, can
/// be defined with another string value assigned to Name. In
/// this case a valid value for MethodOfMeasurement has to be
/// provided.
/// 
/// Qto_SpaceBaseQuantities: base quantities for all space
/// occurrences.
/// 
/// Spatial Structure Use Definition
/// The IfcSpace is used to build the spatial structure of a
/// building (that serves as the primary project breakdown and is
/// required to be hierarchical). The spatial structure elements are
/// linked together by using the objectified relationship
/// IfcRelAggregates. The IfcSpace references them by its
/// inverse relationships:
/// 
/// IfcSpace.Decomposes -- referencing (IfcSite ||
/// IfcBuildingStorey || IfcSpace) by
/// IfcRelAggregates.RelatingObject, If it refers to another
/// instance of IfcSpace, the referenced IfcSpace
/// needs to have a different and higher CompositionType, i.e.
/// COMPLEX (if the other IfcSpace has ELEMENT), or ELEMENT (if
/// the other IfcSpace has PARTIAL).
/// IfcSpace.IsDecomposedBy -- referencing (IfcSpace)
/// by IfcRelAggregates.RelatedObjects. If it refers to another
/// instance of IfcSpace, the referenced IfcSpace needs
/// to have a different and lower CompositionType, i.e. ELEMENT
/// (if the other IfcSpace has COMPLEX), or PARTIAL (if the
/// other IfcSpace has ELEMENT).
/// 
/// If there are building elements and/or other elements directly
/// related to the IfcSpace (like most furniture and
/// distribution elements), they are associated with the
/// IfcSpace by using the objectified relationship
/// IfcRelContainedInSpatialStructure. The IfcSpace
/// references them by its inverse relationship:
/// 
/// IfcSpace.ContainsElements -- referencing any subtype of
/// IfcProduct (with the exception of other spatial structure
/// element) by
/// IfcRelContainedInSpatialStructure.RelatedElements.
/// 
/// Figure 57 shows the IfcSpace as part of the spatial structure. It also serves as the spatial container for space related elements.
/// NOTE Detailed requirements on mandatory element containment and placement structure relationships are given in view definitions and implementer agreements.
/// 
/// Figure 57 — Space composition
/// 
/// Attribute Use Definition
/// 
/// Figure 58 describes the heights and elevations of the IfcSpace.
/// 
/// elevation of the space (top of construction slab) equals elevation of storey: provided by IfcBuildingStorey.Elevation relative to IfcBuilding.ElevationOfRefHeight
/// elevation of the space flooring (top of flooring on top of slab): provided by IfcSpace.ElevationWithFlooring relative to IfcBuilding.ElevationOfRefHeight
/// height of space (top of slab below to bottom of slab above): provided by BaseQuantity with Name="Height"
/// floor height of space (top of slab below to top of flooring): provided by BaseQuantity with Name="FinishFloorHeight"
/// net height of space (top of flooring to bottom of suspended ceiling): provided by BaseQuantity with Name="FinishCeilingHeight"
/// 
/// Figure 58 — Space elevations
/// 
/// Geometry Use Definition
/// The geometric representation of IfcSpace is given by the
/// IfcProductDefinitionShape and IfcLocalPlacement
/// allowing multiple geometric representations.
/// NOTE In cases of inconsistency between the
/// geometric representation of the IfcSpace and the combined
/// geometric representations of the surrounding
/// IfcRelSpaceBoundary, the geometric representation of the
/// space should take priority over the geometric representation of the
/// surrounding space boundaries.
/// Local Placement
/// The local placement for IfcSpace is defined in its
/// supertype IfcProduct. It is defined by the
/// IfcLocalPlacement, which defines the local coordinate system
/// that is referenced by all geometric representations.
/// 
/// The PlacementRelTo relationship of
/// IfcLocalPlacement shall point to the local placement of the
/// IfcSpatialStructureElement of type "IfcBuildingStorey", if
/// relative placement is used, or of type "IfcSpace" (e.g. to position
/// a space relative to a space group, or a partial space to a
/// space).
/// If the relative placement is not used, the absolute placement
/// is defined within the world coordinate system.
/// 
/// Geometric Representations
/// Currently, the use of a 2D 'FootPrint' representation of type
/// 'Curve2D' or 'GeometricCurveSet' and a 3D 'Body' representation of
/// type 'SweptSolid, 'Clipping' and 'Brep' is supported.
/// 'Foot Print' Representation
/// The 2D geometric representation of IfcSpace is defined
/// using the 'Curve2D' or 'GeometricCurveSet' geometry. The following
/// attribute values should be inserted
/// 
/// IfcShapeRepresentation.RepresentationIdentifier =
/// 'FootPrint'.
/// IfcShapeRepresentation.RepresentationType = 'Curve2D' or
/// 'GeometricCurveSet' .
/// 
/// The following constraints apply to the 2D representation:
/// 
/// Profile: IfcBoundedCurve is required, using
/// IfcPolyline for faceted space contours or
/// IfcCompositeCurve for space contours with arc segments. For
/// spaces with inner boundaries, a set of IfcBoundedCurve's is
/// used, that should be grouped into an
/// IfcGeometricCurveSet.
/// 
/// Figure 59 shows a two-dimensional bounded curve representing the
/// foot print of IfcSpace.
/// 
/// Figure 59 — Space footprint
/// 
/// 'Swept Solid' Representation
/// The standard geometric representation of IfcSpace is
/// defined using the swept area solid geometry. The following
/// attribute values should be inserted
/// 
/// IfcShapeRepresentation.RepresentationIdentifier =
/// 'Body'.
/// IfcShapeRepresentation.RepresentationType =
/// 'SweptSolid'.
/// 
/// The following constraints apply to the standard
/// representation:
/// 
/// Solid: IfcExtrudedAreaSolid is required,
/// Profile: IfcArbitraryClosedProfileDef is
/// required, IfcArbitraryProfileDefWithVoids shall be
/// supported.
/// Extrusion: The extrusion direction shall be vertically,
/// i.e., along the positive Z Axis of the co-ordinate system of the
/// containing spatial structure element.
/// 
/// Figure 60 shows an extrusion of an arbitrary profile definition with voids into the swept area solid of IfcSpace.
/// 
/// Figure 60 — Space body swept solid
/// 
/// 'Clipping' representation
/// The advanced geometric representation of IfcSpace is
/// defined using the swept area solid geometry that can be subjected
/// to a Boolean expression. The following attribute values should be
/// inserted.
/// 
/// IfcShapeRepresentation.RepresentationIdentifier =
/// 'Body'.
/// IfcShapeRepresentation.RepresentationType =
/// 'Clipping'.
/// 
/// The following additional constraints apply to the advanced
/// representation:
/// 
/// Solid: see standard geometric representation,
/// Profile: see standard geometric representation,
/// Extrusion: see standard geometric representation,
/// Boolean result: The difference operation with the second
/// operand being of type IfcHalfSpaceSolid (or one of its
/// subtypes) shall be supported.
/// 
/// Figure 61 shows an extrusion of an arbitrary profile definition into the swept area solid. The solid and an half space solid are operands of the Boolean result of IfcSpace.
/// 
/// Figure 61 — Space body clipping
/// 
/// 'Brep' representation
/// The fallback advanced geometric representation of
/// IfcSpace is defined using the Brep solid geometry. may
/// be represented as a single or multiple instances of
/// IfcFacetedBrep or IfcFacetedBrepWithVoids. The Brep
/// representation allows for the representation of complex element
/// shape. The following attribute values for the
/// IfcShapeRepresentation holding this geometric representation
/// shall be used:
/// 
/// IfcShapeRepresentation.RepresentationIdentifier :
/// 'Body'
/// IfcShapeRepresentation.RepresentationType :
/// 'Brep'
class IFC_PARSE_API IfcSpace : public IfcSpatialStructureElement {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcSpace
    bool hasPredefinedType() const;
    /// Predefined generic types for a space that are specified in an enumeration. There might be property sets defined specifically for each predefined type.
    /// 
    /// Previous use, prior to IFC2x4, had been to indicates whether the IfcSpace is an interior space by value INTERNAL, or an exterior space by value EXTERNAL. This use is now deprecated, the property 'IsExternal' at 'Pset_SpaceCommon' should be used instead. 
    /// 
    /// IFC2x4 CHANGE  The attribute has been renamed from ExteriorOrInteriorSpace with upward compatibility for file based exchange.
    IfcSpaceTypeEnum::IfcSpaceTypeEnum PredefinedType() const;
    void setPredefinedType(IfcSpaceTypeEnum::IfcSpaceTypeEnum v);
    /// Whether the optional attribute ElevationWithFlooring is defined for this IfcSpace
    bool hasElevationWithFlooring() const;
    /// Level of flooring of this space; the average shall be taken, if the space ground surface is sloping or if there are level differences within this space.
    double ElevationWithFlooring() const;
    void setElevationWithFlooring(double v);
    virtual unsigned int getArgumentCount() const { return 11; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; case 10: return IfcUtil::Argument_DOUBLE; } return IfcSpatialStructureElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcSpaceTypeEnum; case 10: return Type::IfcLengthMeasure; } return IfcSpatialStructureElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; case 10: return "ElevationWithFlooring"; } return IfcSpatialStructureElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcRelCoversSpaces >::ptr HasCoverings() const; // INVERSE IfcRelCoversSpaces::RelatingSpace
    IfcTemplatedEntityList< IfcRelSpaceBoundary >::ptr BoundedBy() const; // INVERSE IfcRelSpaceBoundary::RelatingSpace
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcSpace (IfcEntityInstanceData* e);
    IfcSpace (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_LongName, boost::optional< IfcElementCompositionEnum::IfcElementCompositionEnum > v9_CompositionType, boost::optional< IfcSpaceTypeEnum::IfcSpaceTypeEnum > v10_PredefinedType, boost::optional< double > v11_ElevationWithFlooring);
    typedef IfcTemplatedEntityList< IfcSpace > list;
};
/// The energy conversion device type IfcSpaceHeaterType defines commonly shared information for occurrences of space heaters.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a space heater specification (i.e. the specific product information, that is common to all occurrences of that product type).  Space Heater types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcSpaceHeaterType are represented by instances of IfcSpaceHeater. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcEnergyConversionDeviceType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_SpaceHeaterTypeCommon 
/// 
/// The following property set definitions are applicable to this entity according to the PredefinedType attribute:  
/// Pset_SpaceHeaterTypeConvector (CONVECTOR) 
/// Pset_SpaceHeaterTypeRadiator (RADIATOR) 
/// 
/// Material Use Definition 
/// The material of the IfcSpaceHeaterType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Body': The primary material from which the object is constructed. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcSpaceHeaterType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcSpaceHeater for standard port definitions.
class IFC_PARSE_API IfcSpaceHeaterType : public IfcFlowTerminalType {
public:
    /// Enumeration of possible types of space heater (e.g., baseboard heater, convector, radiator, etc.).
    IfcSpaceHeaterTypeEnum::IfcSpaceHeaterTypeEnum PredefinedType() const;
    void setPredefinedType(IfcSpaceHeaterTypeEnum::IfcSpaceHeaterTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcFlowTerminalType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcSpaceHeaterTypeEnum; } return IfcFlowTerminalType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcFlowTerminalType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcSpaceHeaterType (IfcEntityInstanceData* e);
    IfcSpaceHeaterType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcSpaceHeaterTypeEnum::IfcSpaceHeaterTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcSpaceHeaterType > list;
};
/// Definition from IAI: A space represents an area or
/// volume bounded actually or theoretically. Spaces are areas or
/// volumes that provide for certain functions within a building.
/// The IfcSpaceType defines a list of commonly shared
/// defines commonly shared information for occurrences of spaces.
/// The set of shared information may include:
/// 
/// common properties within shared property sets
/// common shape representations
/// 
/// It is used to define an space specification (i.e. the specific
/// space information, that is common to all occurrences of that
/// space type. Space types may be exchanged without being already
/// assigned to occurrences.
/// NOTE ÿThe space types are often used to
/// represent space catalogues, less so for sharing a common
/// representation map. Space types in a space catalogue share same
/// space classification and a common set of space requirement
/// properties.
/// The occurrences of IfcSpaceType are represented by
/// instances of IfcSpace.
/// 
/// HISTORY ÿNew entity in
/// IFC2x3.
/// 
/// Property Set Use Definition:
/// The shared property sets relating to the IfcSpaceType
/// are defined by the IfcPropertySet and are attached by the
/// HasPropertySets attribute. The following property set
/// definitions specific to the IfcSpaceType are part of this
/// IFC release:
/// NOTE There is no differentiation between
/// properties within the property set that are only assignable to
/// IfcSpaceType and those that are only assignable to
/// IfcSpace. If the same property is assigned to the
/// IfcSpaceType and the IfcSpace being an occurrence
/// of the IfcSpaceType, then the occurrence property
/// overrides the type property.
/// 
/// Pset_SpaceCommon: common property set for all
/// types of spaces
/// 
/// Pset_SpaceParking: specific property set for
/// only those spaces that are used to define parking spaces by
/// PredefinedType: PARKING
/// 
/// Pset_SpaceFireSafetyRequirements: common
/// property set for all types of spaces to capture the fire safety
/// requirements
/// Pset_SpaceLightingRequirements: common
/// property set for all types of spaces to capture the lighting
/// requirements
/// Pset_SpaceOccupancyRequirements: common
/// property set for all types of spaces to capture the occupancy
/// requirements
/// Pset_SpaceThermalRequirements: common
/// property set for all types of spaces to capture the thermal
/// requirements
/// Pset_SpaceThermalDesign: common property set
/// for allÿall types of spaces to capture building service design
/// values
/// 
/// Geometry Use Definition:
/// The IfcSpaceType may define the shared geometric
/// representation for all space occurrences. The
/// RepresentationMaps attribute refers to a list of
/// IfcRepresentationMap's, that allow for multiple geometric
/// representations (e.g. with IfcShaperepresentation's having
/// an RepresentationIdentifier 'Box', 'FootPrint', or 'Body').
/// 
/// NOTE ÿThe product representations are defined as
/// representation maps (at the level of the supertype
/// IfcTypeProduct, which gets assigned by an element
/// occurrence instance through the
/// IfcShapeRepresentation.Item[1] being an
/// IfcMappedItem.
/// 
/// However view definitions and implementer
/// agreements may prevent the usage of shared geometry for
/// spaces.
/// .
class IFC_PARSE_API IfcSpaceType : public IfcSpatialStructureElementType {
public:
    /// Predefined types to define the particular type of space. There may be property set definitions available for each predefined type.
    IfcSpaceTypeEnum::IfcSpaceTypeEnum PredefinedType() const;
    void setPredefinedType(IfcSpaceTypeEnum::IfcSpaceTypeEnum v);
    /// Whether the optional attribute LongName is defined for this IfcSpaceType
    bool hasLongName() const;
    std::string LongName() const;
    void setLongName(std::string v);
    virtual unsigned int getArgumentCount() const { return 11; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; case 10: return IfcUtil::Argument_STRING; } return IfcSpatialStructureElementType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcSpaceTypeEnum; case 10: return Type::IfcLabel; } return IfcSpatialStructureElementType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; case 10: return "LongName"; } return IfcSpatialStructureElementType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcSpaceType (IfcEntityInstanceData* e);
    IfcSpaceType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcSpaceTypeEnum::IfcSpaceTypeEnum v10_PredefinedType, boost::optional< std::string > v11_LongName);
    typedef IfcTemplatedEntityList< IfcSpaceType > list;
};
/// The flow terminal type IfcStackTerminalType defines commonly shared information for occurrences of stack terminals.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a stack terminal specification (i.e. the specific product information, that is common to all occurrences of that product type).  Stack Terminal types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcStackTerminalType are represented by instances of IfcStackTerminal. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcFlowTerminalType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_StackTerminalTypeCommon 
/// 
/// Material Use Definition 
/// The material of the IfcStackTerminalType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Body': The primary material from which the object is constructed. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcStackTerminalType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcStackTerminal for standard port definitions.
class IFC_PARSE_API IfcStackTerminalType : public IfcFlowTerminalType {
public:
    /// Identifies the predefined types of stack terminal from which the type required may be set.
    IfcStackTerminalTypeEnum::IfcStackTerminalTypeEnum PredefinedType() const;
    void setPredefinedType(IfcStackTerminalTypeEnum::IfcStackTerminalTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcFlowTerminalType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcStackTerminalTypeEnum; } return IfcFlowTerminalType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcFlowTerminalType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcStackTerminalType (IfcEntityInstanceData* e);
    IfcStackTerminalType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcStackTerminalTypeEnum::IfcStackTerminalTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcStackTerminalType > list;
};
/// Definition from IAI: The element type (IfcStairFlightType)
///   defines a list of commonly shared property set definitions of a stair flight
///   and an optional set of product representations. It is used to define an stair
///   flight specification (i.e. the specific product information, that is common to
///   all occurrences of that product type). 
/// 
/// NOTE: The product representations are defined as
///   representation maps (at the level of the supertype IfcTypeProduct, which
///   gets assigned by an element occurrence instance through the
///   IfcShapeRepresentation.Item[1] being an
///   IfcMappedItem. 
///   A stair flight type is used to define the common properties of a certain
///   type of a stair flight that may be applied to many instances of that type to
///   assign a specific style. Stair flight types may be exchanged without being
///   already assigned to occurrences. 
///   The occurrences of the IfcStairFlightType are represented by
///   instances of IfcStairFlight. 
/// 
/// HISTORY: New entity in Release IFC2x
///   Edition 2.
class IFC_PARSE_API IfcStairFlightType : public IfcBuildingElementType {
public:
    /// Identifies the predefined types of a stair flight element from which the type required may be set.
    IfcStairFlightTypeEnum::IfcStairFlightTypeEnum PredefinedType() const;
    void setPredefinedType(IfcStairFlightTypeEnum::IfcStairFlightTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcBuildingElementType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcStairFlightTypeEnum; } return IfcBuildingElementType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcBuildingElementType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcStairFlightType (IfcEntityInstanceData* e);
    IfcStairFlightType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcStairFlightTypeEnum::IfcStairFlightTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcStairFlightType > list;
};
/// Definition from IAI: The element type
///   IfcStairType defines a list of commonly shared
///   property set definitions of a stair and an optional set of
///   product representations. It is used to define a stair
///   specification (i.e. the specific product information, that
///   is common to all occurrences of that product type).
/// 
/// NOTE The product representations are defined as
///   representation maps (at the level of the supertype
///   IfcTypeProduct, which gets assigned by an element
///   occurrence instance through the
///   IfcShapeRepresentation.Item[1] being an
///   IfcMappedItem.
/// 
/// An IfcStairTypeÿis used to define the common
///   properties of a specific stair that may be applied to many
///   instances of that type to assign a specific style. 
///   Building element types (or the instantiable subtypes) 
///   may be exchanged without being
///   already assigned to occurrences.
/// 
/// The IfcStairType can have common material (using the
///   inverse relationship HasAssociations) or property
///   set information (using HasPropertySets) assigned. If
///   present, it does apply equally to all occurrences of the
///   IfcStairType. Property set information may be
///   overridden at the occurrence.
/// 
/// The occurrences of the IfcStairType are represented
///   by instances of IfcStair.
/// 
/// HISTORY New entity in Release
///   IFC2x Edition 4.
class IFC_PARSE_API IfcStairType : public IfcBuildingElementType {
public:
    /// Identifies the predefined types of a stair element from which the type required may be set.
    IfcStairTypeEnum::IfcStairTypeEnum PredefinedType() const;
    void setPredefinedType(IfcStairTypeEnum::IfcStairTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcBuildingElementType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcStairTypeEnum; } return IfcBuildingElementType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcBuildingElementType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcStairType (IfcEntityInstanceData* e);
    IfcStairType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcStairTypeEnum::IfcStairTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcStairType > list;
};
/// Definition from IAI: A structural action is a structural activity that acts upon
/// a structural item or building element.
/// 
/// HISTORY  New entity in IFC 2x2.
/// IFC 2x4 change:  Attribute DestabilizingLoad made optional.  Attribute CausedBy deleted; use IfcRelAssignsToProduct via ReferencedBy instead.
/// 
/// Structural actions are grouped into either an IfcStructuralLoadGroup of predefined
/// type LOAD_GROUP or, more often, an IfcStructuralLoadCase.  This is accomplished via the
/// inverse relationship HasAssignments and an IfcRelAssignsToGroup relationship object.
/// IfcStructuralLoadGroup.LoadGroupFor or IfcStructuralLoadCase.LoadGroupFor respectively
/// refers to the structural analysis model(s) in which the loads are used.
/// 
/// It is furthermore possible to establish relationships between actions in one analysis model
/// and reactions in another analysis model which cause the actions.  For example, a support reaction
/// from one structural system may be taken over as a load onto another supporting structural system.
/// This is expressed by means of the inverse relationship ReferencedBy of the action and an
/// IfcRelAssignsToProduct relationship object.  IfcRelAssignsToProduct.Name is set to
/// 'Causes' and IfcRelAssignsToProduct.RelatedObjects refers to an instance of a subtype of
/// IfcStructuralReaction.
class IFC_PARSE_API IfcStructuralAction : public IfcStructuralActivity {
public:
    /// Whether the optional attribute DestabilizingLoad is defined for this IfcStructuralAction
    bool hasDestabilizingLoad() const;
    /// Indicates if this action may cause a stability problem. If it is 'FALSE', no further investigations regarding stability problems are necessary.
    bool DestabilizingLoad() const;
    void setDestabilizingLoad(bool v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_BOOL; } return IfcStructuralActivity::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcBoolean; } return IfcStructuralActivity::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "DestabilizingLoad"; } return IfcStructuralActivity::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcStructuralAction (IfcEntityInstanceData* e);
    IfcStructuralAction (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, IfcStructuralLoad* v8_AppliedLoad, IfcGlobalOrLocalEnum::IfcGlobalOrLocalEnum v9_GlobalOrLocal, boost::optional< bool > v10_DestabilizingLoad);
    typedef IfcTemplatedEntityList< IfcStructuralAction > list;
};
/// Definition from IAI: An IfcStructuralConnection represents a structural connection object (node i.e. vertex connection, or edge connection, or surface connection) or supports.
/// 
/// HISTORY: New entity in IFC 2x2.
class IFC_PARSE_API IfcStructuralConnection : public IfcStructuralItem {
public:
    /// Whether the optional attribute AppliedCondition is defined for this IfcStructuralConnection
    bool hasAppliedCondition() const;
    /// Optional boundary conditions which define support conditions of this connection object, given in local coordinate directions of the connection object.  If left unspecified, the connection object is assumed to have no supports besides being connected with members.
    IfcBoundaryCondition* AppliedCondition() const;
    void setAppliedCondition(IfcBoundaryCondition* v);
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 7: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcStructuralItem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 7: return Type::IfcBoundaryCondition; } return IfcStructuralItem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 7: return "AppliedCondition"; } return IfcStructuralItem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcRelConnectsStructuralMember >::ptr ConnectsStructuralMembers() const; // INVERSE IfcRelConnectsStructuralMember::RelatedStructuralConnection
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcStructuralConnection (IfcEntityInstanceData* e);
    IfcStructuralConnection (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, IfcBoundaryCondition* v8_AppliedCondition);
    typedef IfcTemplatedEntityList< IfcStructuralConnection > list;
};
/// Definition from IAI: Defines an action which is distributed over a curve.
/// A curve action may be connected with a curve member or curve connection, or
/// surface member or surface connection.
/// 
/// HISTORY: New entity in IFC 2x4.
/// 
/// IFC 2x4 change:  Former entitiy
/// IfcStructuralLinearActionVarying from IFC 2x2 has been removed and are replaced
/// by this entity.
/// 
/// Coordinate Systems:
/// 
/// See definitions at IfcStructuralActivity.
/// 
/// Topology Use Definitions:
/// 
/// Standard Case:
/// If connected with a curve item, instances of IfcStructuralCurveAction shall not have an
/// ObjectPlacement nor a Representation.  It is implied that the placement and
/// representation of the IfcStructuralActivity is the same as the ones of the member or
/// connection.
/// 
/// Special Case 1:
/// If connected with a surface item, instances of IfcStructuralCurveAction shall have an
/// ObjectPlacement and Representation, containing an IfcEdgeCurve.  See
/// IfcStructuralActivity for further definitions.
/// 
/// Special Case 2:
/// If not connected with a structural item (which may happen in an incomplete or conceptual model),
/// a curve action should have an ObjectPlacement and Representation, containing an
/// IfcEdgeCurve.  See IfcStructuralActivity for further definitions.
/// 
/// Informal propositions:
/// 
/// If the curve action is of the predefined type CONST, SINUS, or PARABOLA,
///   SELF\IfcStructuralActivity.AppliedLoad must not be of type
///   IfcStructuralLoadConfiguration.  In case of SINUS and PARABOLA, the load item
///   defines the maximum of the load at the centre of the load distribution.
///   If the curve action is of the predefined type LINEAR,
///   SELF\IfcStructuralActivity.AppliedLoad shall be of type
///   IfcStructuralLoadConfiguration and shall contain two items.
///   If the curve action is of the predefined type POLYGONAL,
///   SELF\IfcStructuralActivity.AppliedLoad shall be of type
///   IfcStructuralLoadConfiguration and shall contain three or more items.
///   If the curve action is of the predefined type DISCRETE,
///   SELF\IfcStructuralActivity.AppliedLoad shall be of type
///   IfcStructuralLoadConfiguration and shall contain two or more items.
///   In case of types LINEAR, POLYGONAL, and DISCRETE, the load items shall have
///   one-dimensional IfcStructuralLoadConfiguration.Locations, defining the
///   location of the load samples in local coordinates of the curve action.
///   The load items shall be provided in ascending order according to their locations.
///   The first and the last load item define the extent of the load distribution.
///   Point actions must be of type DISCRETE, thus contain two or more load points.
///   (Single point loads are modeled by IfcStructuralPointAction.)
///   All items in SELF\IfcStructuralActivity.AppliedLoad\IfcStructuralLoadConfiguration.Values
///   shall be of the same entity type.
class IFC_PARSE_API IfcStructuralCurveAction : public IfcStructuralAction {
public:
    /// Whether the optional attribute ProjectedOrTrue is defined for this IfcStructuralCurveAction
    bool hasProjectedOrTrue() const;
    /// Defines whether load values are given per true length of the curve on which they act, or per length of the projection of the curve in load direction.  The latter is only applicable to loads which act in global coordinate directions.
    IfcProjectedOrTrueLengthEnum::IfcProjectedOrTrueLengthEnum ProjectedOrTrue() const;
    void setProjectedOrTrue(IfcProjectedOrTrueLengthEnum::IfcProjectedOrTrueLengthEnum v);
    /// Type of action according to its distribution of load values.
    IfcStructuralCurveActivityTypeEnum::IfcStructuralCurveActivityTypeEnum PredefinedType() const;
    void setPredefinedType(IfcStructuralCurveActivityTypeEnum::IfcStructuralCurveActivityTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 12; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 10: return IfcUtil::Argument_ENUMERATION; case 11: return IfcUtil::Argument_ENUMERATION; } return IfcStructuralAction::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 10: return Type::IfcProjectedOrTrueLengthEnum; case 11: return Type::IfcStructuralCurveActivityTypeEnum; } return IfcStructuralAction::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 10: return "ProjectedOrTrue"; case 11: return "PredefinedType"; } return IfcStructuralAction::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcStructuralCurveAction (IfcEntityInstanceData* e);
    IfcStructuralCurveAction (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, IfcStructuralLoad* v8_AppliedLoad, IfcGlobalOrLocalEnum::IfcGlobalOrLocalEnum v9_GlobalOrLocal, boost::optional< bool > v10_DestabilizingLoad, boost::optional< IfcProjectedOrTrueLengthEnum::IfcProjectedOrTrueLengthEnum > v11_ProjectedOrTrue, IfcStructuralCurveActivityTypeEnum::IfcStructuralCurveActivityTypeEnum v12_PredefinedType);
    typedef IfcTemplatedEntityList< IfcStructuralCurveAction > list;
};
/// Definition from IAI: Instances of IfcStructuralCurveConnection describe edge 'nodes', i.e. edges where two or more surface members are joined, or edge supports.  Edge curves may be straight or curved.
/// 
/// HISTORY: New entity in IFC 2x2.
/// 
/// IFC 2x4 change:  Attribute Axis added, allowing for skewed supports.  Use definitions added.
/// 
/// Coordinate Systems:
/// 
/// See definitions at IfcStructuralItem.  The local coordinate system is established by the reference curve given by topology representation and by the attribute Axis.  The local x axis is parallel with the tangent on the reference curve.  The local z axis is located in the surface which is created by sweeping Axis along the reference curve and is directed according to Axis.  The local y axis is directed such that x,y,z form a right-handed Cartesian coordinate system.
/// 
/// Topology Use Definitions:
/// 
/// Instances of IfcStructuralCurveConnection shall have a topology representation which consists of one instance of IfcEdge or a subtype, representing the reference curve of the curve connection.  See definitions at IfcStructuralItem for further specifications.
/// 
/// Informal propositions:
/// 
/// The reference curve must not be parallel with Axis at any point within the curve connections's domain.
class IFC_PARSE_API IfcStructuralCurveConnection : public IfcStructuralConnection {
public:
    /// Direction which is used in the definition of the local z axis.  Axis is specified relative to the so-called global coordinate system, i.e. the SELF\IfcProduct.ObjectPlacement.
    /// 
    /// NOTE  It is desirable and usually possible that many instances of IfcStructuralCurveConnection and IfcStructuralCurveMember share a common instance of IfcDirection as their Axis attribute.
    IfcDirection* Axis() const;
    void setAxis(IfcDirection* v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcStructuralConnection::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcDirection; } return IfcStructuralConnection::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "Axis"; } return IfcStructuralConnection::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcStructuralCurveConnection (IfcEntityInstanceData* e);
    IfcStructuralCurveConnection (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, IfcBoundaryCondition* v8_AppliedCondition, IfcDirection* v9_Axis);
    typedef IfcTemplatedEntityList< IfcStructuralCurveConnection > list;
};
/// Definition from IAI: Instances of IfcStructuralCurveMember describe edge members, i.e. structural analysis idealizations of beams, columns, rods etc..  Curve members may be straight or curved.
/// 
/// HISTORY: New entity in IFC 2x2.
/// 
/// IFC 2x4 change:  Attribute Axis and WHERE rule added.  Use definitions changed.
/// 
/// Coordinate Systems:
/// 
/// See definitions at IfcStructuralItem.  The local coordinate system is established by the reference curve given by topology representation and by the attribute Axis.  The local x axis is parallel with the tangent on the reference curve.  The local z axis is located in the surface which is created by sweeping Axis along the reference curve and is directed according to Axis.  The local y axis is directed such that x,y,z form a right-handed Cartesian coordinate system.
/// 
/// Material Use Definition
/// 
/// The material of direct instances IfcStructuralCurveMember (in contrast to instances of the subtype IfcStructuralCurveMemberVarying) is defined by IfcMaterialProfileSetUsage and attached by the IfcRelAssociatesMaterial.RelatingMaterial.  It is accessible by the inverse HasAssociations relationship.  Composite profile beams can be represented by refering to several IfcMaterialProfiles within the IfcMaterialProfileSet that is referenced from the IfcMaterialProfileSetUsage.  In case of tapered members, the material profile usage subtype IfcMaterialProfileSetUsageDual is used which specifies IfcMaterialProfileSets separately at the start and the end of the tapered member.
/// 
/// The material (IfcMaterial) in each IfcMaterialProfile(Set) is specified minimally by a name which corresponds with an agreed upon standardized structural material designation.  An external reference to the source which specifies the material designation should be provided.  Alternatively, structural material properties may be provided by means of IfcMechanicalMaterialProperties and IfcExtendedMaterialProperties.
/// 
/// The profile (IfcProfileDef) in each IfcMaterialProfile(Set) is specified minimally by a name which corresponds with an agreed upon standardized structural profile designation.  An external reference to the source which specifies the profile designation should be provided.  Alternatively or additionally, explicit profile geometry should be provided by using respective subtypes of IfcProfileDef.  Alternatively or additionally, structural profile properties may be provided by means of subtypes of IfcProfileProperties.
/// 
/// An IfcProfileDef is a two-dimensional geometric object with a xp,yp coordinate system.  The profile is inserted into the curve member model thus that the origin of xp,yp is located at the member's reference curve and that xp,yp are parallel with and directed like the local y,z.
/// 
/// NOTE   Due to convention in structural mechanics, axis names of IfcStructuralCurveMember differ from axis names of building elements like IfcBeamStandardCase:  The extrusion axis of IfcStructuralCurveMember is called x while the extrusion axis of IfcBeamStandardCase is called z.  Hence x,y,z of IfcStructuralCurveMember correspond with z,x,y of IfcBeamStandardCase.
/// 
/// If the profile is meant to be inserted centrically in terms of structural section properties, it is necessary that the origin of xp,yp is identical with the geometric centroid of the profile (commonly also called centre of gravity).  If subtypes of IfcParameterizedProfileDef are used which are only singly symmetric or are asymmetric, an explicit translation by IfcParameterizedProfileDef.Position.Location is required then.
/// 
/// If the profile is inserted at its geometric centroid, IfcMaterialProfileSetUsage.CardinalPoint shall be set to 10.
/// 
/// Otherwise, the profile is inserted eccentrically and a different cardinal point should be set accordingly.
/// 
/// NOTE   Another eccentricity model is available independently of eccentric profile specification:  The reference curve of the member may be located eccentrically relative to the reference points of the connected IfcStructuralPointConnections.  The connection relationship is then established by IfcRelConnectsWithEccentricity.  Whether one or the other or both eccentricity models may be used is subject to information requirements and local agreements.
/// 
/// Topology Use Definitions:
/// 
/// Direct instances of IfcStructuralCurveMember shall have a topology representation which consists of one instance of IfcEdge or a subtype, representing the reference curve of the curve member.  See definitions at IfcStructuralItem for further specifications.
/// 
/// Informal propositions:
/// 
/// The reference curve must not be parallel with Axis at any point within the curve member's domain.
class IFC_PARSE_API IfcStructuralCurveMember : public IfcStructuralMember {
public:
    /// Type of member with respect to its load carrying behavior in this analysis idealization.
    IfcStructuralCurveMemberTypeEnum::IfcStructuralCurveMemberTypeEnum PredefinedType() const;
    void setPredefinedType(IfcStructuralCurveMemberTypeEnum::IfcStructuralCurveMemberTypeEnum v);
    /// Direction which is used in the definition of the local z axis.  Axis is specified relative to the so-called global coordinate system, i.e. the SELF\IfcProduct.ObjectPlacement.
    /// 
    /// NOTE  It is desirable and usually possible that many instances of IfcStructuralCurveConnection and IfcStructuralCurveMember share a common instance of IfcDirection as their Axis attribute.
    IfcDirection* Axis() const;
    void setAxis(IfcDirection* v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 7: return IfcUtil::Argument_ENUMERATION; case 8: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcStructuralMember::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 7: return Type::IfcStructuralCurveMemberTypeEnum; case 8: return Type::IfcDirection; } return IfcStructuralMember::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 7: return "PredefinedType"; case 8: return "Axis"; } return IfcStructuralMember::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcStructuralCurveMember (IfcEntityInstanceData* e);
    IfcStructuralCurveMember (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, IfcStructuralCurveMemberTypeEnum::IfcStructuralCurveMemberTypeEnum v8_PredefinedType, IfcDirection* v9_Axis);
    typedef IfcTemplatedEntityList< IfcStructuralCurveMember > list;
};
/// Definition from IAI: Describes edge members with varying profile properties.  Each instance of IfcStructuralCurveMemberVarying is composed of two or more instances of IfcStructuralCurveMember with differing profile properties.  These subordinate members relate to the instance of IfcStructuralCurveMemberVarying by IfcRelAggregates.
/// 
/// NOTE   A curve member whose variation of profile properties can be sufficiently described by a start profile and an end profile (e.g. tapers) shall be modeled as a single direct instance of the supertype IfcStructuralCurveMember.
/// 
/// NOTE   It is recommended that structural activities (actions or reactions) are not connected with aggregated IfcStructuralCurveMemberVarying but only with the IfcStructuralCurveMembers in the aggregation.  That way, difficulties in interpretation of local coordinates are avoided.
/// 
/// HISTORY: New entity in IFC 2x2.
/// Use definition changed in IFC 2x4.
/// 
/// Coordinate Systems:
/// 
/// See definitions at IfcStructuralItem and IfcStructuralCurveMember.  The local coordinates of the aggregate are derived from those of its parts.  Length measures in local x direction of the aggregate depend on continuity and lengths of the parts.  The Axis of the aggregate shal be the same as the Axis of the part at the start of the aggregate.
/// 
/// Material Use Definition
/// 
/// Only the individual parts (direct instances of IfcStructuralCurveMember) carry material and profile information.
/// 
/// Topology Use Definitions:
/// 
/// Instances of IfcStructuralCurveMemberVarying may have a topology representation which contains a single IfcEdgeLoop, based upon the edges of the parts.
class IFC_PARSE_API IfcStructuralCurveMemberVarying : public IfcStructuralCurveMember {
public:
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcStructuralCurveMember::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcStructuralCurveMember::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcStructuralCurveMember::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcStructuralCurveMemberVarying (IfcEntityInstanceData* e);
    IfcStructuralCurveMemberVarying (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, IfcStructuralCurveMemberTypeEnum::IfcStructuralCurveMemberTypeEnum v8_PredefinedType, IfcDirection* v9_Axis);
    typedef IfcTemplatedEntityList< IfcStructuralCurveMemberVarying > list;
};
/// Definition from IAI: Defines a reaction which occurs distributed over a curve.
/// A curve reaction may be connected with a curve member or curve connection,
/// or surface member or surface connection.
/// 
/// HISTORY: New entity in IFC 2x4.
/// 
/// Coordinate Systems:
/// 
/// See definitions at IfcStructuralActivity.
/// 
/// Topology Use Definitions:
/// 
/// Standard Case:
/// If connected with a curve item, instances of IfcStructuralCurveRection shall not
/// have an ObjectPlacement nor a Representation.  It is implied that the
/// placement and representation of the IfcStructuralActivity is the same as the ones
/// of the member or connection.
/// 
/// Special Case:
/// If connected with a surface item, instances of IfcStructuralCurveReaction shall
/// have an ObjectPlacement and Representation, containing an IfcEdgeCurve.
/// See IfcStructuralActivity for further definitions.
/// 
/// Informal propositions:
/// 
/// If the curve reaction is of the predefined type CONST,
///   SELF\IfcStructuralActivity.AppliedLoad must not be of type
///   IfcStructuralLoadConfiguration.
///   If the curve reaction is of the predefined type LINEAR,
///   SELF\IfcStructuralActivity.AppliedLoad shall be of type
///   IfcStructuralLoadConfiguration and shall contain two items.
///   If the curve reaction is of the predefined type POLYGONAL,
///   SELF\IfcStructuralActivity.AppliedLoad shall be of type
///   IfcStructuralLoadConfiguration and shall contain three or more items.
///   If the curve action is of the predefined type DISCRETE,
///   SELF\IfcStructuralActivity.AppliedLoad shall be of type
///   IfcStructuralLoadConfiguration and shall contain two or more items.
///   In case of types LINEAR, POLYGONAL, and DISCRETE, the load items shall have
///   one-dimensional IfcStructuralLoadConfiguration.Locations, defining the
///   location of the result samples in local coordinates of the curve reaction.
///   The load items shall be provided in ascending order according to their locations.
///   The first and the last load item define the extent of the result distribution.
///   If the curve reaction is of the predefined type EQUIDISTANT,
///   SELF\IfcStructuralActivity.AppliedLoad shall be of type
///   IfcStructuralLoadConfiguration and shall contain two or more items.
///   IfcStructuralLoadConfiguration.Locations shall be omitted as it is implicit.
///   The load items shall be provided in ascending order.  The first and the last load
///   item are located at the beginning and end of the result distribution, respectively.
///   All items in SELF\IfcStructuralActivity.AppliedLoad\IfcStructuralLoadConfiguration.Values
///   shall be of the same entity type.
class IFC_PARSE_API IfcStructuralCurveReaction : public IfcStructuralReaction {
public:
    /// Type of reaction according to its distribution of load values.
    IfcStructuralCurveActivityTypeEnum::IfcStructuralCurveActivityTypeEnum PredefinedType() const;
    void setPredefinedType(IfcStructuralCurveActivityTypeEnum::IfcStructuralCurveActivityTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcStructuralReaction::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcStructuralCurveActivityTypeEnum; } return IfcStructuralReaction::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcStructuralReaction::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcStructuralCurveReaction (IfcEntityInstanceData* e);
    IfcStructuralCurveReaction (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, IfcStructuralLoad* v8_AppliedLoad, IfcGlobalOrLocalEnum::IfcGlobalOrLocalEnum v9_GlobalOrLocal, IfcStructuralCurveActivityTypeEnum::IfcStructuralCurveActivityTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcStructuralCurveReaction > list;
};
/// Definition from IAI: Defines an action with constant value which is distributed over a curve.
/// 
/// HISTORY: New entity in IFC 2x2.
/// 
/// IFC 2x4 change:  Intermediate supertype IfcStructuralCurveAction inserted.  Derived attribute PredefinedType added.
/// 
/// NOTE  Like its supertype IfcStructuralCurveAction, this action type may also act on curved edges.
class IFC_PARSE_API IfcStructuralLinearAction : public IfcStructuralCurveAction {
public:
    virtual unsigned int getArgumentCount() const { return 12; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcStructuralCurveAction::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcStructuralCurveAction::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcStructuralCurveAction::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcStructuralLinearAction (IfcEntityInstanceData* e);
    IfcStructuralLinearAction (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, IfcStructuralLoad* v8_AppliedLoad, IfcGlobalOrLocalEnum::IfcGlobalOrLocalEnum v9_GlobalOrLocal, boost::optional< bool > v10_DestabilizingLoad, boost::optional< IfcProjectedOrTrueLengthEnum::IfcProjectedOrTrueLengthEnum > v11_ProjectedOrTrue, IfcStructuralCurveActivityTypeEnum::IfcStructuralCurveActivityTypeEnum v12_PredefinedType);
    typedef IfcTemplatedEntityList< IfcStructuralLinearAction > list;
};
/// Definition from IAI: The entity IfcStructuralLoadGroup is used to structure the
/// physical impacts.  By using the grouping features inherited from IfcGroup, instances of
/// IfcStructuralAction (or its subclasses) and of IfcStructuralLoadGroup can be used to
/// define load groups, load cases and load combinations.  (See also IfcLoadGroupTypeEnum.)
/// 
/// NOTE: Important functionality for the description of a load-bearing system
/// is derived from the existing IFC entity IfcGroup.  This class provides, via the relationship
/// class IfcRelAssignsToGroup, the needed grouping mechanism.  In this way, instances of
/// IfcStructuralAction belonging to a specific load group can be unambiguously determined.
/// 
/// NOTE: The relationship class IfcRelAssignsToGroupByFactor is
/// used to group load cases into load combinations.  The factor provided in this assignment relationship
/// is to applied together with the optional IfcStructuralLoadGroup.Coefficient.  Unlike this
/// coefficient which always affects the load group, the IfcRelAssignsToGroupByFactor.Factor is
/// specific for a load case—load combination pair.  As many instances of
/// IfcRelAssignsToGroupByFactor are used within one load combination as there are different
/// Factors to be applied to load cases in the load combination.
/// 
/// On the other hand, a load case may appear in more than one load combination
/// and can have a different Factor in each assignment by IfcRelAssignsToGroupByFactor.
/// 
/// HISTORY: New entity in IFC 2x2.
/// IFC 2x4 change: Subtype IfcStructuralLoadCase added.  Informal propositions and WHERE rule added.
/// Predefined type LOAD_COMBINATION_GROUP made obsolete and removed.
/// 
/// Informal propositions:
/// 
/// Load groups of type LOAD_GROUP shall only contain instances of IfcStructuralAction.
///   Load groups of type LOAD_CASE shall always be instantiated from the subtype IfcStructuralLoadCase,
///   not directly from the generic type IfcStructuralLoadGroup itself.
///   Instances of IfcStructuralLoadCase shall only contain instances of IfcStructuralAction
///   or/ and instances of IfcStructuralLoadGroup of type LOAD_GROUP.
///   Load groups of type LOAD_COMBINATION shall only contain instances of IfcStructuralLoadCase.
class IFC_PARSE_API IfcStructuralLoadGroup : public IfcGroup {
public:
    /// Selects a predefined type for the load group.  It can be differentiated between load groups, load cases, load combinations, or userdefined grouping levels.
    IfcLoadGroupTypeEnum::IfcLoadGroupTypeEnum PredefinedType() const;
    void setPredefinedType(IfcLoadGroupTypeEnum::IfcLoadGroupTypeEnum v);
    /// Type of actions in the group. Normally needed if 'PredefinedType' specifies a LOAD_CASE.
    IfcActionTypeEnum::IfcActionTypeEnum ActionType() const;
    void setActionType(IfcActionTypeEnum::IfcActionTypeEnum v);
    /// Source of actions in the group. Normally needed if 'PredefinedType' specifies a LOAD_CASE.
    IfcActionSourceTypeEnum::IfcActionSourceTypeEnum ActionSource() const;
    void setActionSource(IfcActionSourceTypeEnum::IfcActionSourceTypeEnum v);
    /// Whether the optional attribute Coefficient is defined for this IfcStructuralLoadGroup
    bool hasCoefficient() const;
    /// Load factor. If omitted, a factor is not yet known or not specified. A load factor of 1.0 shall be explicitly exported as Coefficient = 1.0.
    double Coefficient() const;
    void setCoefficient(double v);
    /// Whether the optional attribute Purpose is defined for this IfcStructuralLoadGroup
    bool hasPurpose() const;
    /// Description of the purpose of this instance. Among else, possible values of the Purpose of load combinations are 'SLS', 'ULS', 'ALS' to indicate serviceability, ultimate, or accidental limit state.
    std::string Purpose() const;
    void setPurpose(std::string v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 5: return IfcUtil::Argument_ENUMERATION; case 6: return IfcUtil::Argument_ENUMERATION; case 7: return IfcUtil::Argument_ENUMERATION; case 8: return IfcUtil::Argument_DOUBLE; case 9: return IfcUtil::Argument_STRING; } return IfcGroup::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 5: return Type::IfcLoadGroupTypeEnum; case 6: return Type::IfcActionTypeEnum; case 7: return Type::IfcActionSourceTypeEnum; case 8: return Type::IfcRatioMeasure; case 9: return Type::IfcLabel; } return IfcGroup::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 5: return "PredefinedType"; case 6: return "ActionType"; case 7: return "ActionSource"; case 8: return "Coefficient"; case 9: return "Purpose"; } return IfcGroup::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcStructuralResultGroup >::ptr SourceOfResultGroup() const; // INVERSE IfcStructuralResultGroup::ResultForLoadGroup
    IfcTemplatedEntityList< IfcStructuralAnalysisModel >::ptr LoadGroupFor() const; // INVERSE IfcStructuralAnalysisModel::LoadedBy
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcStructuralLoadGroup (IfcEntityInstanceData* e);
    IfcStructuralLoadGroup (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcLoadGroupTypeEnum::IfcLoadGroupTypeEnum v6_PredefinedType, IfcActionTypeEnum::IfcActionTypeEnum v7_ActionType, IfcActionSourceTypeEnum::IfcActionSourceTypeEnum v8_ActionSource, boost::optional< double > v9_Coefficient, boost::optional< std::string > v10_Purpose);
    typedef IfcTemplatedEntityList< IfcStructuralLoadGroup > list;
};
/// Definition from IAI: Defines an action which acts on a point.
/// A point action is typically connected with a point connection.
/// It may also be connected with a curve member or curve connection,
/// or surface member or surface connection.
/// 
/// HISTORY: New entity in IFC 2x2.
/// 
/// IFC 2x4 change:  Attributes in the supertypes
/// IfcStructuralActivity and IfcStructuralAction changed.  Use definitions changed,
/// informal propositions added.
/// 
/// Coordinate Systems:
/// 
/// See definitions at IfcStructuralActivity.
/// 
/// Topology Use Definitions:
/// 
/// Standard Case:
/// If connected with a point item, instances of IfcStructuralPointAction
/// shall not have an ObjectPlacement nor a Representation.
/// It is implied that the placement and representation of the action is the same
/// as the structural item.
/// 
/// Special Case 1:
/// If connected with a curve item or surface item, instances of IfcStructuralPointAction
/// shall have an ObjectPlacement and Representation, containing an IfcVertexPoint.
/// See IfcStructuralActivity for further definitions.
/// 
/// NOTE In order to model concentrated actions on a curve or surface item,
/// IfcStructuralCurveAction or IfcStructuralSurfaceAction of type DISCRETE is
/// preferable since they do not require an extra topology representation in this case.
/// An IfcStructuralPointAction should be used for a concentrated action on a curve or surface
/// item only when an explicit vertex point representation is actually desired.
/// 
/// Special Case 2:
/// If not connected with a structural item (which may happen in an incomplete or
/// conceptual model), a point action should have an ObjectPlacement and
/// Representation, containing an IfcVertexPoint.
/// See IfcStructuralActivity for further definitions.
/// 
/// Informal propositions:
/// 
/// SELF\IfcStructuralActivity.AppliedLoad shall be of type
///   IfcStructuralLoadSingleForce or
///   IfcStructuralLoadSingleDisplacement.
class IFC_PARSE_API IfcStructuralPointAction : public IfcStructuralAction {
public:
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcStructuralAction::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcStructuralAction::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcStructuralAction::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcStructuralPointAction (IfcEntityInstanceData* e);
    IfcStructuralPointAction (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, IfcStructuralLoad* v8_AppliedLoad, IfcGlobalOrLocalEnum::IfcGlobalOrLocalEnum v9_GlobalOrLocal, boost::optional< bool > v10_DestabilizingLoad);
    typedef IfcTemplatedEntityList< IfcStructuralPointAction > list;
};
/// Definition from IAI: Instances of IfcStructuralPointConnection describe structural nodes or point supports.
/// 
/// HISTORY: New entity in IFC 2x2.
/// 
/// IFC 2x4 change:  Attribute ConditionCoordinateSystem added, allowing for skewed supports.  Use definitions added.
/// 
/// Coordinate Systems:
/// 
/// See definitions at IfcStructuralItem.  The local coordinate system is established by the reference point given by topology representation and by the attribute ConditionCoordinateSystem.
/// 
/// Topology Use Definitions:
/// 
/// Instances of IfcStructuralPointConnection shall have a topology representation which consists of one IfcVertexPoint, representing the reference point of the point connection.  See definitions at IfcStructuralItem for further specifications.
class IFC_PARSE_API IfcStructuralPointConnection : public IfcStructuralConnection {
public:
    /// Whether the optional attribute ConditionCoordinateSystem is defined for this IfcStructuralPointConnection
    bool hasConditionCoordinateSystem() const;
    /// Defines a coordinate system used for the description of the support condition properties in SELF\IfcStructuralConnection.SupportCondition, specified relative to the global coordinate system (global to the structural analysis model) established by SELF.\IfcProduct.ObjectPlacement.  If left unspecified, the placement IfcAxis2Placement3D((x,y,z), ?, ?) is implied with x,y,z being the coordinates of the reference point of this IfcStructuralPointConnection and the default axes directions being in parallel with the global axes.
    IfcAxis2Placement3D* ConditionCoordinateSystem() const;
    void setConditionCoordinateSystem(IfcAxis2Placement3D* v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcStructuralConnection::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcAxis2Placement3D; } return IfcStructuralConnection::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "ConditionCoordinateSystem"; } return IfcStructuralConnection::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcStructuralPointConnection (IfcEntityInstanceData* e);
    IfcStructuralPointConnection (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, IfcBoundaryCondition* v8_AppliedCondition, IfcAxis2Placement3D* v9_ConditionCoordinateSystem);
    typedef IfcTemplatedEntityList< IfcStructuralPointConnection > list;
};
/// Definition from IAI: Defines a reaction which occurs at a point.
/// A point reaction is typically connected with a point connection.
/// It may also be connected with a curve member or curve connection,
/// or surface member or surface connection.
/// 
/// HISTORY: New entity in IFC 2x2.
/// 
/// IFC 2x4 change:  Attributes in the supertypes IfcStructuralActivity and IfcStructuralReaction changed.  Use definitions changed, informal propositions added.
/// 
/// Coordinate Systems:
/// 
/// See definitions at IfcStructuralActivity.
/// 
/// Topology Use Definitions:
/// 
/// Standard Case:
/// If connected with a point item, instances of IfcStructuralPointReaction
/// shall not have an ObjectPlacement nor a Representation.
/// It is implied that the placement and representation of the reaction is the same
/// as the structural item.
/// 
/// Special Case 1:
/// If connected with a curve item or surface item, instances of IfcStructuralPointReaction
/// shall have an ObjectPlacement and Representation, containing an IfcVertexPoint.
/// See IfcStructuralActivity for further definitions.
/// 
/// NOTE In order to model concentrated reactions on a curve or surface item,
/// IfcStructuralCurveReaction or IfcStructuralSurfaceAction of type DISCRETE is
/// preferable since they do not require an extra topology representation in this case.
/// An IfcStructuralPointReaction should be used for a concentrated reaction on a curve or surface
/// item only when an explicit vertex point representation is actually desired.
/// 
/// Special Case 2:
/// If not connected with a structural item (which may happen in an incomplete or
/// conceptual model), a point action should have an ObjectPlacement and
/// Representation, containing an IfcVertexPoint.
/// See IfcStructuralActivity for further definitions.
/// 
/// Informal propositions:
/// 
/// SELF\IfcStructuralActivity.AppliedLoad shall be of type
///   IfcStructuralLoadSingleForce or
///   IfcStructuralLoadSingleDisplacement.
class IFC_PARSE_API IfcStructuralPointReaction : public IfcStructuralReaction {
public:
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcStructuralReaction::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcStructuralReaction::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcStructuralReaction::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcStructuralPointReaction (IfcEntityInstanceData* e);
    IfcStructuralPointReaction (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, IfcStructuralLoad* v8_AppliedLoad, IfcGlobalOrLocalEnum::IfcGlobalOrLocalEnum v9_GlobalOrLocal);
    typedef IfcTemplatedEntityList< IfcStructuralPointReaction > list;
};
/// Definition from IAI: Instances of the entity IfcStructuralResultGroup are used to group results of structural analysis calculations and to capture the connection to the underlying basic load group.  The basic functionality for grouping inherited from IfcGroup is used to collect instances from IfcStructuralReaction or its respective subclasses.
/// 
/// HISTORY: New entity in IFC 2x2.
/// IFC 2x4 change: WHERE rule added.
class IFC_PARSE_API IfcStructuralResultGroup : public IfcGroup {
public:
    /// Specifies the analysis theory used to obtain the respective results.
    IfcAnalysisTheoryTypeEnum::IfcAnalysisTheoryTypeEnum TheoryType() const;
    void setTheoryType(IfcAnalysisTheoryTypeEnum::IfcAnalysisTheoryTypeEnum v);
    /// Whether the optional attribute ResultForLoadGroup is defined for this IfcStructuralResultGroup
    bool hasResultForLoadGroup() const;
    /// Reference to an instance of IfcStructuralLoadGroup for which this instance represents the result.
    IfcStructuralLoadGroup* ResultForLoadGroup() const;
    void setResultForLoadGroup(IfcStructuralLoadGroup* v);
    /// This value allows to easily recognize whether a linear analysis has been applied (allowing the superposition of analysis results).
    bool IsLinear() const;
    void setIsLinear(bool v);
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 5: return IfcUtil::Argument_ENUMERATION; case 6: return IfcUtil::Argument_ENTITY_INSTANCE; case 7: return IfcUtil::Argument_BOOL; } return IfcGroup::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 5: return Type::IfcAnalysisTheoryTypeEnum; case 6: return Type::IfcStructuralLoadGroup; case 7: return Type::IfcBoolean; } return IfcGroup::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 5: return "TheoryType"; case 6: return "ResultForLoadGroup"; case 7: return "IsLinear"; } return IfcGroup::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcStructuralAnalysisModel >::ptr ResultGroupFor() const; // INVERSE IfcStructuralAnalysisModel::HasResults
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcStructuralResultGroup (IfcEntityInstanceData* e);
    IfcStructuralResultGroup (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcAnalysisTheoryTypeEnum::IfcAnalysisTheoryTypeEnum v6_TheoryType, IfcStructuralLoadGroup* v7_ResultForLoadGroup, bool v8_IsLinear);
    typedef IfcTemplatedEntityList< IfcStructuralResultGroup > list;
};
/// Definition from IAI: Defines an action which is distributed over a surface.
/// A surface action may be connected with a surface member or surface connection.
/// 
/// HISTORY: New entity in IFC 2x4.
/// 
/// IFC 2x4 change:  Former entity
/// IfcStructuralPlanarActionVarying from IFC 2x2 has been removed and are replaced
/// by this entity.
/// 
/// Coordinate Systems:
/// 
/// See definitions at IfcStructuralActivity.
/// 
/// Topology Use Definitions:
/// 
/// Standard Case:
/// If connected with a surface item and acting on its entirety, instances of
/// IfcStructuralCurveAction shall not have an ObjectPlacement nor a
/// Representation.  It is implied that the placement and representation of the
/// IfcStructuralActivity is the same as the ones of the member or connection.
/// 
/// Special Case 1:
/// If connected with a surface item but acting only on a part of it, instances of
/// IfcStructuralSurfaceAction shall have an ObjectPlacement and
/// Representation, containing an IfcFaceSurface which topologically
/// defines the loaded part of the surface.  See IfcStructuralActivity for further
/// definitions.
/// 
/// Special Case 2:
/// If not connected with a structural item (which may happen in an incomplete or conceptual model),
/// a surface action should have an ObjectPlacement and Representation, containing an
/// IfcFaceSurface.  See IfcStructuralActivity for further definitions.
/// 
/// Informal propositions:
/// 
/// If the surface action is of the predefined type CONST,
///   SELF\IfcStructuralActivity.AppliedLoad must not be of type
///   IfcStructuralLoadConfiguration.
///   If the surface action is of the predefined type BILINEAR,
///   SELF\IfcStructuralActivity.AppliedLoad shall be of type
///   IfcStructuralLoadConfiguration and shall contain three items
///   with two-dimensional IfcStructuralLoadConfiguration.Locations,
///   defining the location of the load samples in local coordinates of the
///   surface action.
///   If the surface action is of the predefined type DISCRETE,
///   SELF\IfcStructuralActivity.AppliedLoad shall be of type
///   IfcStructuralLoadConfiguration and shall contain two or more
///   items with two-dimensional locations.
///   Point loads must be of type DISCRETE, thus contain two or more load points.
///   (Single point loads are modeled by IfcStructuralPointLoad.)
///   All items in SELF\IfcStructuralActivity.AppliedLoad\IfcStructuralLoadConfiguration.Values
///   shall be of the same entity type.
class IFC_PARSE_API IfcStructuralSurfaceAction : public IfcStructuralAction {
public:
    /// Whether the optional attribute ProjectedOrTrue is defined for this IfcStructuralSurfaceAction
    bool hasProjectedOrTrue() const;
    /// Defines whether load values are given per true lengths of the surface on which they act, or per lengths of the projection of the surface in load direction.  The latter is only applicable to loads which act in global coordinate directions.
    IfcProjectedOrTrueLengthEnum::IfcProjectedOrTrueLengthEnum ProjectedOrTrue() const;
    void setProjectedOrTrue(IfcProjectedOrTrueLengthEnum::IfcProjectedOrTrueLengthEnum v);
    /// Type of action according to its distribution of load values.
    IfcStructuralSurfaceActivityTypeEnum::IfcStructuralSurfaceActivityTypeEnum PredefinedType() const;
    void setPredefinedType(IfcStructuralSurfaceActivityTypeEnum::IfcStructuralSurfaceActivityTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 12; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 10: return IfcUtil::Argument_ENUMERATION; case 11: return IfcUtil::Argument_ENUMERATION; } return IfcStructuralAction::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 10: return Type::IfcProjectedOrTrueLengthEnum; case 11: return Type::IfcStructuralSurfaceActivityTypeEnum; } return IfcStructuralAction::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 10: return "ProjectedOrTrue"; case 11: return "PredefinedType"; } return IfcStructuralAction::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcStructuralSurfaceAction (IfcEntityInstanceData* e);
    IfcStructuralSurfaceAction (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, IfcStructuralLoad* v8_AppliedLoad, IfcGlobalOrLocalEnum::IfcGlobalOrLocalEnum v9_GlobalOrLocal, boost::optional< bool > v10_DestabilizingLoad, boost::optional< IfcProjectedOrTrueLengthEnum::IfcProjectedOrTrueLengthEnum > v11_ProjectedOrTrue, IfcStructuralSurfaceActivityTypeEnum::IfcStructuralSurfaceActivityTypeEnum v12_PredefinedType);
    typedef IfcTemplatedEntityList< IfcStructuralSurfaceAction > list;
};
/// Definition from IAI: Instances of IfcStructuralSurfaceConnection describe face 'nodes', i.e. faces where two or more surface members are joined, or face supports.  Face surfaces may be planar or curved.
/// 
/// HISTORY: New entity in IFC 2x2.
/// IFC 2x4 change:  Use definitions added.
/// 
/// Coordinate Systems:
/// 
/// See definitions at IfcStructuralItem.  The local coordinate system is established by the reference surface given by topology representation.
/// 
/// Topology Use Definitions:
/// 
/// Instances of IfcStructuralSurfaceConnection shall have a topology representation which consists of one IfcFaceSurface, representing the reference surface of the surface connection.  See definitions at IfcStructuralItem for further specifications.
class IFC_PARSE_API IfcStructuralSurfaceConnection : public IfcStructuralConnection {
public:
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcStructuralConnection::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcStructuralConnection::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcStructuralConnection::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcStructuralSurfaceConnection (IfcEntityInstanceData* e);
    IfcStructuralSurfaceConnection (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, IfcBoundaryCondition* v8_AppliedCondition);
    typedef IfcTemplatedEntityList< IfcStructuralSurfaceConnection > list;
};
/// IfcSubContractResource is a construction resource needed in a construction process that represents a sub-contractor.  
/// 
/// HISTORY: New Entity in IFC Release 2.0.  Base type and documentation extended in IFC 2x4.
/// 
/// IFC2x4 CHANGE: The attribute SubContractor has been deleted; use IfcRelAssignsToResource to assign an IfcActor to fulfill the role as the subcontractor.  The attribute JobDescription has been deleted; use LongDescription to describe the job.
/// 
/// An IfcSubContractResource can be used in cost estimating and work planning with or without specifying the subcontractor and contract agreement. 
/// The purpose of an IfcSubContractResource is to indicate work of a particular type that is that is to be engaged through the use of a sub-contract. It's aim is to identify the description of the sub-contract work required. It can be used to identify the generic type of sub-contract resource that is required for a purpose without having to be specific about the actor (person or organization) providing the resource occurrence. It may be particularly useful when creating an overall plan for a process or processes. For instance, within maintenance or work planning there may be a known task that needs to be done which is planned to require an 'insulation specialist'. 
/// A subcontract resource may be described at various stages and levels of detail through its assignments:
/// 
/// Subcontract resource designated for particular tasks
/// Actors identified to request bids
/// Cost schedules (bids) received from actors
/// Project order (work order, change order, etc.) executed
/// 
/// Use definitions for composition, assignment, constraints, time series, and baselines are described at the base type IfcConstructionResource.
/// 
/// Type use definition
/// IfcSubContractResource defines the occurrence of any subcontract resource; common information about subcontract resource types is handled by IfcSubContractResourceType.  The IfcSubContractResourceType (if present) may establish the common type name, common properties, and common productivities for various task types using IfcRelAssignsToProcess.  The IfcSubContractResourceType is attached using the IfcRelDefinesByType.RelatingType objectified relationship and is accessible by the inverse IsTypedBy attribute.
/// 
/// Assignment use definition
/// In addition to assignments specified at the base class IfcConstructionResource, a subcontract resource may have assignments of its own using IfcRelAssignsToResource where RelatingResource refers to the IfcSubContractResource and RelatedObjects contains one or more IfcActor, IfcCostSchedule, and/or IfcWorkOrder objects as shown in Figure 195.  An IfcActor indicates a specific organization to be considered to fulfill the resource or invited to bid on the resource.  An IfcCostSchedule indicates a bid or price quote made on behalf of an organization.  An IfcProjectOrder indicates a specific work order committed to fulfill the resource.
/// 
/// Figure 195 — Subcontract assignment use
class IFC_PARSE_API IfcSubContractResource : public IfcConstructionResource {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcSubContractResource
    bool hasPredefinedType() const;
    /// Defines types of subcontract resources.
    /// IFC2x4 New attribute
    IfcSubContractResourceTypeEnum::IfcSubContractResourceTypeEnum PredefinedType() const;
    void setPredefinedType(IfcSubContractResourceTypeEnum::IfcSubContractResourceTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 11; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 10: return IfcUtil::Argument_ENUMERATION; } return IfcConstructionResource::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 10: return Type::IfcSubContractResourceTypeEnum; } return IfcConstructionResource::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 10: return "PredefinedType"; } return IfcConstructionResource::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcSubContractResource (IfcEntityInstanceData* e);
    IfcSubContractResource (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, boost::optional< std::string > v6_Identification, boost::optional< std::string > v7_LongDescription, IfcResourceTime* v8_Usage, boost::optional< IfcTemplatedEntityList< IfcAppliedValue >::ptr > v9_BaseCosts, IfcPhysicalQuantity* v10_BaseQuantity, boost::optional< IfcSubContractResourceTypeEnum::IfcSubContractResourceTypeEnum > v11_PredefinedType);
    typedef IfcTemplatedEntityList< IfcSubContractResource > list;
};
/// Definition from IAI: A surface feature is a modification at (onto, or into) of the surface of an element.  Parts of the surface of the entire surface may be affected.  The volume and mass of the element may be increased, remain unchanged, or be decreased by the surface feature, depending on manufacturing technology.
/// 
/// The standard use of instances of IfcSurfaceFeature is as a part of element type objects (instances of subtypes of IfcElementType).  The part–whole relationship is established by an aggregation relationship object, expressing the decomposition of an element type into one or more additive elements (element parts) and zero or more feature elements.
/// 
/// HISTORY New type in IFC 2x4.
/// 
/// Containment Use Definition:
/// 
/// Surface features shall have no spatial containment relationship to the spatial structure since they are dependent on element types without spatial containment relationships or on an element occurrence with own spatial containment relationship.
/// 
/// The SELF\IfcElement.ContainedInStructure relationship shall be NIL.
/// 
/// Geometry use definition:
/// 
/// The geometric representation of IfcSurfaceFeatureElement is given by the IfcProductDefinitionShape, allowing multiple geometric representation.
/// 
/// Local Placement
/// 
/// The local placement for IfcSurfaceFeatureElement is defined in its supertype IfcProduct. It is defined by the IfcLocalPlacement, which defines the local coordinate system that is referenced by all geometric representations.
/// 
/// In case of features which are part of an element type, absolute placement into the type object's implied coordinate system shall be used.
///   In case of features which are voiding an element occurrence, the PlacementRelTo relationship of IfcLocalPlacement shall point to the local placement of the respective element.
/// 
/// Shape representation
/// 
/// Different shape representations may be used, depending on the nature of the feature and information requirements:
/// 
/// Symbolic representation, such as the two-dimensional bounding box of a tag.
///   A geometric set representing the geometric items of a mark.
///   Surface representations of treated parts of the lement surface by means of IfcShellBasedSurfaceModel.  The faces within the surface model may be included into a B-Rep model within a representation map of the parent element type.
/// 
/// Higher-level parameters (geometric and non-geometric) may be provided by property sets based on local agreements.
class IFC_PARSE_API IfcSurfaceFeature : public IfcFeatureElement {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcSurfaceFeature
    bool hasPredefinedType() const;
    /// Indicates the kind of surface feature.
    IfcSurfaceFeatureTypeEnum::IfcSurfaceFeatureTypeEnum PredefinedType() const;
    void setPredefinedType(IfcSurfaceFeatureTypeEnum::IfcSurfaceFeatureTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcFeatureElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcSurfaceFeatureTypeEnum; } return IfcFeatureElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "PredefinedType"; } return IfcFeatureElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcSurfaceFeature (IfcEntityInstanceData* e);
    IfcSurfaceFeature (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcSurfaceFeatureTypeEnum::IfcSurfaceFeatureTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcSurfaceFeature > list;
};
/// The flow controller type IfcSwitchingDeviceType defines commonly shared information for occurrences of switching devices.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a switching device specification (i.e. the specific product information, that is common to all occurrences of that product type).  Switching Device types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcSwitchingDeviceType are represented by instances of IfcSwitchingDevice. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcFlowControllerType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_SwitchingDeviceTypeCommon 
/// 
/// The following property set definitions are applicable to this entity according to the PredefinedType attribute:  
/// Pset_ElectricalDeviceCommon 
/// Pset_SwitchingDeviceTypeContactor (CONTACTOR) 
/// Pset_SwitchingDeviceTypeDimmerSwitch (DIMMERSWITCH) 
/// Pset_SwitchingDeviceTypeEmergencyStop (EMERGENCYSTOP) 
/// Pset_SwitchingDeviceTypeKeypad (KEYPAD) 
/// Pset_SwitchingDeviceTypeMomentarySwitch (MOMENTARYSWITCH) 
/// Pset_SwitchingDeviceTypeSelectorSwitch (SELECTORSWITCH) 
/// Pset_SwitchingDeviceTypeStarter (STARTER) 
/// Pset_SwitchingDeviceTypeSwitchDisconnector (SWITCHDISCONNECTOR) 
/// Pset_SwitchingDeviceTypeToggleSwitch (TOGGLESWITCH) 
/// 
/// Material Use Definition 
/// The material of the IfcSwitchingDeviceType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Casing': Material from which the casing is constructed. 
/// 'Conductor': Material from which the conductors are constructed. 
/// 'Surface': Material from which the switch surface is constructed. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcSwitchingDeviceType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcSwitchingDevice for standard port definitions.
class IFC_PARSE_API IfcSwitchingDeviceType : public IfcFlowControllerType {
public:
    /// Identifies the predefined types of switch from which the type required may be set.
    IfcSwitchingDeviceTypeEnum::IfcSwitchingDeviceTypeEnum PredefinedType() const;
    void setPredefinedType(IfcSwitchingDeviceTypeEnum::IfcSwitchingDeviceTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcFlowControllerType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcSwitchingDeviceTypeEnum; } return IfcFlowControllerType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcFlowControllerType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcSwitchingDeviceType (IfcEntityInstanceData* e);
    IfcSwitchingDeviceType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcSwitchingDeviceTypeEnum::IfcSwitchingDeviceTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcSwitchingDeviceType > list;
};
/// Definition from IAI: Organized combination of
///   related parts within an AEC product, composed for a common
///   purpose or function or to provide a service. System is
///   essentially a functionally related aggregation of products.
///   The grouping relationship to one or several instances of
///   IfcProduct (the system members) is handled by
///   IfcRelAssignsToGroup.
/// 
/// NOTE: The use of IfcSystem often
///   applies to the representation of building services related
///   systems, such as the piping system, cold water system, etc.
///   Members within such a system may or may not be connected
///   using the connectivity related entities (e.g. through
///   IfcPort).
/// 
/// HISTORY: New entity in
///   IFC Release 1.0
class IFC_PARSE_API IfcSystem : public IfcGroup {
public:
    virtual unsigned int getArgumentCount() const { return 5; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcGroup::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcGroup::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcGroup::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcRelServicesBuildings >::ptr ServicesBuildings() const; // INVERSE IfcRelServicesBuildings::RelatingSystem
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcSystem (IfcEntityInstanceData* e);
    IfcSystem (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType);
    typedef IfcTemplatedEntityList< IfcSystem > list;
};
/// A system furniture element defines components of modular furniture which are not directly placed in a building structure but aggregated inside furniture. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Type Use Definition 
/// IfcSystemFurnitureElement defines the occurrence of any furniture element; common information about furniture element types is handled by IfcSystemFurnitureElementType.  The IfcSystemFurnitureElementType (if present) may establish the common type name, usage (predefined type), properties, materials, composition, assignments, and representations.  The IfcSystemFurnitureElementType is attached using the IfcRelDefinesByType objectified relationship and is accessible by the IsTypedBy inverse attribute.  If the IfcSystemFurnitureElementType has aggregated elements, such objects are reflected at the IfcSystemFurnitureElement occurrence using the IfcRelDefinesByObject relationship. 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the IfcRelDefinesByProperties relationship. They are accessible by the IsDefinedBy inverse attribute.  Property sets may also be specified at the IfcSystemFurnitureElementType, defining the common property data for all occurrences of the same type.  They are then accessible by the IsTypedBy inverse attribute pointing to IfcSystemFurnitureElementType.HasPropertySets. If both are given, then the properties directly defined at IfcSystemFurnitureElement override the properties defined at IfcSystemFurnitureElementType.  Refer to the documentation at the supertype IfcFurnishingElement and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_SystemFurnitureElementTypeCommon 
/// 
/// The following property set definitions are applicable to this entity according to the PredefinedType attribute:  
/// Pset_SystemFurnitureElementTypePanel (PANEL) 
/// Pset_SystemFurnitureElementTypeWorkSurface (WORKSURFACE) 
/// 
/// Material Use Definition 
/// The material of the IfcSystemFurnitureElement is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.  Material information can also be given at the IfcSystemFurnitureElementType, defining the common attribute data for all occurrences of the same type.  The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Finish': The finish, typically at visible aspects of the furniture. 
/// 'Frame': The frame from which the object is constructed. 
/// 'Hardware': Finish hardware such as knobs or handles. 
/// 'Padding': Padding such as cushions. 
/// 'Panel': Panels such as glass.
class IFC_PARSE_API IfcSystemFurnitureElement : public IfcFurnishingElement {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcSystemFurnitureElement
    bool hasPredefinedType() const;
    IfcSystemFurnitureElementTypeEnum::IfcSystemFurnitureElementTypeEnum PredefinedType() const;
    void setPredefinedType(IfcSystemFurnitureElementTypeEnum::IfcSystemFurnitureElementTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcFurnishingElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcSystemFurnitureElementTypeEnum; } return IfcFurnishingElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "PredefinedType"; } return IfcFurnishingElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcSystemFurnitureElement (IfcEntityInstanceData* e);
    IfcSystemFurnitureElement (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcSystemFurnitureElementTypeEnum::IfcSystemFurnitureElementTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcSystemFurnitureElement > list;
};
/// The flow storage device type IfcTankType defines commonly shared information for occurrences of tanks.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a tank specification (i.e. the specific product information, that is common to all occurrences of that product type).  Tank types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcTankType are represented by instances of IfcTank. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcFlowStorageDeviceType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_TankTypeCommon 
/// 
/// The following property set definitions are applicable to this entity according to the PredefinedType attribute:  
/// Pset_TankTypeExpansion (EXPANSION) 
/// Pset_TankTypePreformed (PREFORMED) 
/// Pset_TankTypePressureVessel (PRESSUREVESSEL) 
/// Pset_TankTypeSectional (SECTIONAL) 
/// 
/// Material Use Definition 
/// The material of the IfcTankType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Body': The primary material from which the object is constructed. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcTankType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcTank for standard port definitions.
class IFC_PARSE_API IfcTankType : public IfcFlowStorageDeviceType {
public:
    /// Defines the type of tank.
    IfcTankTypeEnum::IfcTankTypeEnum PredefinedType() const;
    void setPredefinedType(IfcTankTypeEnum::IfcTankTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcFlowStorageDeviceType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcTankTypeEnum; } return IfcFlowStorageDeviceType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcFlowStorageDeviceType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcTankType (IfcEntityInstanceData* e);
    IfcTankType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcTankTypeEnum::IfcTankTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcTankType > list;
};

class IFC_PARSE_API IfcTendon : public IfcReinforcingElement {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcTendon
    bool hasPredefinedType() const;
    IfcTendonTypeEnum::IfcTendonTypeEnum PredefinedType() const;
    void setPredefinedType(IfcTendonTypeEnum::IfcTendonTypeEnum v);
    /// Whether the optional attribute NominalDiameter is defined for this IfcTendon
    bool hasNominalDiameter() const;
    double NominalDiameter() const;
    void setNominalDiameter(double v);
    /// Whether the optional attribute CrossSectionArea is defined for this IfcTendon
    bool hasCrossSectionArea() const;
    double CrossSectionArea() const;
    void setCrossSectionArea(double v);
    /// Whether the optional attribute TensionForce is defined for this IfcTendon
    bool hasTensionForce() const;
    double TensionForce() const;
    void setTensionForce(double v);
    /// Whether the optional attribute PreStress is defined for this IfcTendon
    bool hasPreStress() const;
    double PreStress() const;
    void setPreStress(double v);
    /// Whether the optional attribute FrictionCoefficient is defined for this IfcTendon
    bool hasFrictionCoefficient() const;
    double FrictionCoefficient() const;
    void setFrictionCoefficient(double v);
    /// Whether the optional attribute AnchorageSlip is defined for this IfcTendon
    bool hasAnchorageSlip() const;
    double AnchorageSlip() const;
    void setAnchorageSlip(double v);
    /// Whether the optional attribute MinCurvatureRadius is defined for this IfcTendon
    bool hasMinCurvatureRadius() const;
    double MinCurvatureRadius() const;
    void setMinCurvatureRadius(double v);
    virtual unsigned int getArgumentCount() const { return 17; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; case 10: return IfcUtil::Argument_DOUBLE; case 11: return IfcUtil::Argument_DOUBLE; case 12: return IfcUtil::Argument_DOUBLE; case 13: return IfcUtil::Argument_DOUBLE; case 14: return IfcUtil::Argument_DOUBLE; case 15: return IfcUtil::Argument_DOUBLE; case 16: return IfcUtil::Argument_DOUBLE; } return IfcReinforcingElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcTendonTypeEnum; case 10: return Type::IfcPositiveLengthMeasure; case 11: return Type::IfcAreaMeasure; case 12: return Type::IfcForceMeasure; case 13: return Type::IfcPressureMeasure; case 14: return Type::IfcNormalisedRatioMeasure; case 15: return Type::IfcPositiveLengthMeasure; case 16: return Type::IfcPositiveLengthMeasure; } return IfcReinforcingElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; case 10: return "NominalDiameter"; case 11: return "CrossSectionArea"; case 12: return "TensionForce"; case 13: return "PreStress"; case 14: return "FrictionCoefficient"; case 15: return "AnchorageSlip"; case 16: return "MinCurvatureRadius"; } return IfcReinforcingElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcTendon (IfcEntityInstanceData* e);
    IfcTendon (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_SteelGrade, boost::optional< IfcTendonTypeEnum::IfcTendonTypeEnum > v10_PredefinedType, boost::optional< double > v11_NominalDiameter, boost::optional< double > v12_CrossSectionArea, boost::optional< double > v13_TensionForce, boost::optional< double > v14_PreStress, boost::optional< double > v15_FrictionCoefficient, boost::optional< double > v16_AnchorageSlip, boost::optional< double > v17_MinCurvatureRadius);
    typedef IfcTemplatedEntityList< IfcTendon > list;
};

class IFC_PARSE_API IfcTendonAnchor : public IfcReinforcingElement {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcTendonAnchor
    bool hasPredefinedType() const;
    IfcTendonAnchorTypeEnum::IfcTendonAnchorTypeEnum PredefinedType() const;
    void setPredefinedType(IfcTendonAnchorTypeEnum::IfcTendonAnchorTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcReinforcingElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcTendonAnchorTypeEnum; } return IfcReinforcingElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcReinforcingElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcTendonAnchor (IfcEntityInstanceData* e);
    IfcTendonAnchor (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_SteelGrade, boost::optional< IfcTendonAnchorTypeEnum::IfcTendonAnchorTypeEnum > v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcTendonAnchor > list;
};

class IFC_PARSE_API IfcTendonAnchorType : public IfcReinforcingElementType {
public:
    IfcTendonAnchorTypeEnum::IfcTendonAnchorTypeEnum PredefinedType() const;
    void setPredefinedType(IfcTendonAnchorTypeEnum::IfcTendonAnchorTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcReinforcingElementType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcTendonAnchorTypeEnum; } return IfcReinforcingElementType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcReinforcingElementType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcTendonAnchorType (IfcEntityInstanceData* e);
    IfcTendonAnchorType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcTendonAnchorTypeEnum::IfcTendonAnchorTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcTendonAnchorType > list;
};

class IFC_PARSE_API IfcTendonType : public IfcReinforcingElementType {
public:
    IfcTendonTypeEnum::IfcTendonTypeEnum PredefinedType() const;
    void setPredefinedType(IfcTendonTypeEnum::IfcTendonTypeEnum v);
    /// Whether the optional attribute NominalDiameter is defined for this IfcTendonType
    bool hasNominalDiameter() const;
    double NominalDiameter() const;
    void setNominalDiameter(double v);
    /// Whether the optional attribute CrossSectionArea is defined for this IfcTendonType
    bool hasCrossSectionArea() const;
    double CrossSectionArea() const;
    void setCrossSectionArea(double v);
    /// Whether the optional attribute SheathDiameter is defined for this IfcTendonType
    bool hasSheathDiameter() const;
    double SheathDiameter() const;
    void setSheathDiameter(double v);
    virtual unsigned int getArgumentCount() const { return 13; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; case 10: return IfcUtil::Argument_DOUBLE; case 11: return IfcUtil::Argument_DOUBLE; case 12: return IfcUtil::Argument_DOUBLE; } return IfcReinforcingElementType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcTendonTypeEnum; case 10: return Type::IfcPositiveLengthMeasure; case 11: return Type::IfcAreaMeasure; case 12: return Type::IfcPositiveLengthMeasure; } return IfcReinforcingElementType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; case 10: return "NominalDiameter"; case 11: return "CrossSectionArea"; case 12: return "SheathDiameter"; } return IfcReinforcingElementType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcTendonType (IfcEntityInstanceData* e);
    IfcTendonType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcTendonTypeEnum::IfcTendonTypeEnum v10_PredefinedType, boost::optional< double > v11_NominalDiameter, boost::optional< double > v12_CrossSectionArea, boost::optional< double > v13_SheathDiameter);
    typedef IfcTemplatedEntityList< IfcTendonType > list;
};
/// The energy conversion device type IfcTransformerType defines commonly shared information for occurrences of transformers.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a transformer specification (i.e. the specific product information, that is common to all occurrences of that product type).  Transformer types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcTransformerType are represented by instances of IfcTransformer. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcEnergyConversionDeviceType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_ElectricalDeviceCommon 
/// Pset_TransformerTypeCommon 
/// 
/// Material Use Definition 
/// The material of the IfcTransformerType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Casing': Material from which the casing is constructed. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcTransformerType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcTransformer for standard port definitions.
class IFC_PARSE_API IfcTransformerType : public IfcEnergyConversionDeviceType {
public:
    /// Identifies the predefined types of transformer from which the type required may be set.
    IfcTransformerTypeEnum::IfcTransformerTypeEnum PredefinedType() const;
    void setPredefinedType(IfcTransformerTypeEnum::IfcTransformerTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcEnergyConversionDeviceType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcTransformerTypeEnum; } return IfcEnergyConversionDeviceType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcEnergyConversionDeviceType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcTransformerType (IfcEntityInstanceData* e);
    IfcTransformerType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcTransformerTypeEnum::IfcTransformerTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcTransformerType > list;
};
/// Definition from IAI: Generalization of all transport
/// related objects that move people, animals or goods within a
/// building or building complex. The IfcTransportElement
/// defines the occurrence of a transport element, that (if given),
/// is expressed by the IfcTransportElementType.
/// EXAMPLE Transportation elements include
/// elevator (lift), escalator, moving walkway, etc.
/// NOTE More detailed equipment that may be a part of a
/// transportation device, like a lifting hook, is defined as
/// IfcDiscreteAccessory
/// Depending on local classification systems transport elements
/// and transportation systems in buildings are either considered as
/// part of a building system, or as part of a building service
/// system. Within IFC they are considered as part of a building
/// system and may have to be mapped appropriately.
/// HISTORY New entity in
/// IFC Release 2x.
/// IFC2x PLATFORM CHANGE The attribute
/// PredefinedType (previously OperationType) is made
/// optional.
/// Type Use Definition
/// IfcTransportElement defines the occuurence of any
/// transportation device, common information about transportation
/// device types (or styles) is handled by
/// IfcTransportElementType. The
/// IfcTransportElementType (if present) may establish the
/// commonÿtype name, usage (or predefined) type, common material
/// layer set, common set of properties and common shape
/// representations (using IfcRepresentationMap). The
/// IfcTransportElementType is attached using the
/// IfcRelDefinedByType.RelatingType objectified relationship
/// and is accessible by the inverse IsTypedBy attribute.
/// If no IfcTransportElementType is attachedÿ(i.e. if only
/// occurrence information is given) the PredefinedType should
/// be provided. If set to .USERDEFINED. a user defined value can be
/// provided by the ObjectType attribute.
/// Property Set Use Definition:
/// The property sets relating to the IfcTransportElement
/// are defined by the IfcPropertySet and attached by the
/// IfcRelDefinesByProperties relationship. It is accessible
/// by the inverse IsDefinedBy relationship. The following
/// property set definitions specific to the
/// IfcTransportElement are part of this IFC release:
/// 
/// Pset_TransportElementCommon: common property
/// set for all transport element occurrences
/// 
/// Pset_TransportElementElevator: specific
/// property set for all occurrences of transport elements with the
/// PredefinedType: ELEVATOR
/// 
/// Containment Use Definition
/// The IfcTransportElement, as any subtype of
/// IfcElement, may have a hierarchical spatial containment
/// relationships that is mandatory in most implementation
/// scenarios.
/// 
/// The IfcTransportElement is placed within the project
/// spatial hierarchy using the objectified relationship
/// IfcRelContainedInSpatialStructure, refering to it by its
/// inverse attribute SELF\IfcElement.ContainedInStructure.
/// Subtypes ofÿIfcSpatialStructureElement are valid spatial
/// containers, with IfcBuilding being the default
/// container.
/// 
/// Geometry Use Definitions:
/// The geometric representation of IfcTransportElement is
/// given by the IfcProductDefinitionShape, allowing multiple
/// geometric representation.
/// Local Placement
/// The local placement for IfcTransportElement is defined
/// in its supertype IfcProduct. It is defined by the
/// IfcLocalPlacement, which defines the local coordinate
/// system that is referenced by all geometric representations.
/// 
/// The PlacementRelTo relationship of
/// IfcLocalPlacement shall point (if given) to the local
/// placement of the same IfcSpatialStructureElement , which
/// is used in the ContainedInStructure inverse attribute, or
/// to a spatial structure element at a higher level, referenced by
/// that.
/// If the relative placement is not used, the absolute placement
/// is defined within the world coordinate system.
/// 
/// SurfaceModel Representation
/// Any IfcTransportElement (so far no further constraints
/// are defined at the level of its subtypes) may be represented as a
/// single or multiple surface models, based on either shell or face
/// based models. Then the following attribute values for the
/// IfcShapeRepresentation holding this geometric
/// representation shall be used:
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'SurfaceModel'
/// 
/// Brep Representation
/// Any IfcTransportElement (so far no further constraints
/// are defined at the level of its subtypes) may be represented as a
/// single or multiple Boundary Representation elements (which are
/// restricted to faceted Brep with or without voids). Then the
/// following attribute values for the IfcShapeRepresentation
/// holding this geometric representation shall be used:
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'Brep'
/// 
/// MappedRepresentation
/// The mapped item, IfcMappedItem, should be used if
/// appropriate as it allows for reusing the geometry definition of
/// the property element type at occurrences of the same equipement
/// type. Then the following attribute values for the
/// IfcShapeRepresentation holding this geometric
/// representation shall be used:
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'MappedRepresentation'
class IFC_PARSE_API IfcTransportElement : public IfcElement {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcTransportElement
    bool hasPredefinedType() const;
    /// Predefined generic types for a transportation element that are specified in an enumeration. There might be property sets defined specifically for each predefined type.
    /// 
    /// IFC2x4 CHANGE  The attribute has been changed to be optional.
    IfcTransportElementTypeEnum::IfcTransportElementTypeEnum PredefinedType() const;
    void setPredefinedType(IfcTransportElementTypeEnum::IfcTransportElementTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcTransportElementTypeEnum; } return IfcElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "PredefinedType"; } return IfcElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcTransportElement (IfcEntityInstanceData* e);
    IfcTransportElement (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcTransportElementTypeEnum::IfcTransportElementTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcTransportElement > list;
};
/// Definition from ISO/CD 10303-42:1992:
/// A trimmed curve is a bounded curve which is created by taking a selected
/// portion, between two identified points, of the associated basis curve.
/// The basis curve itself is unaltered and more than one trimmed curve may
/// reference the same basis curve. Trimming points for the curve may be
/// identified by:
///   parametric value  geometric
/// position  both of the above 
/// At least one of these shall be specified at each
/// end of the
/// curve. The SenseAgreement makes it possible to
/// unambiguously define any segment of a closed curve such as a circle.
/// The combinations of sense and ordered end points make it possible to
/// define four distinct directed segments connecting two different points
/// on a circle or other closed curve. For this purpose cyclic properties
/// of the parameter range are assumed; for example, 370 degrees is
/// equivalent to 10 degrees. 
/// The IfcTrimmedCurve has a parameterization
/// which is inherited from the particular basis curve reference. More
/// precisely the parameter s of the trimmed curve is derived from the
/// parameter of the basis curve as follows: 
///   if SenseAgreement is TRUE: s
/// = t - t1  if SenseAgreement
/// is FALSE: s
/// = t2 - t 
/// In the above equations t1 is
/// the value
/// given by Trim1 or the parameter value corresponding
/// to point 1 and t2 is the value given by Trim2
/// or the parameter value corresponding to point 2. The resultant IfcTrimmedCurve
/// has a parameter ranging from 0 at the first trimming point to |t2
/// - t1| at the second trimming point. 
///   NOTE In case
/// of a closed curve,
/// it may be necessary to increment t1 or t2 by the parametric length for
/// consistency with the sense flag.
/// 
/// NOTE Corresponding ISO 10303 entity: trimmed_curve; As a further IFC restriction, an IfcTrimmedCurve should only trim a IfcLine or IfcConic. Please refer to ISO/IS 10303-42:1994, p. 54 for the final definition of the formal standard.
/// 
/// HISTORY New class in IFC Release 1.0
/// 
/// Informal Propositions:
///   Where both the parameter value and the Cartesian
/// point
/// exist for Trim1 and Trim2 they
/// shall be consistent. (i.e., the BasisCurve
/// evaluated at the parameter value shall coincide with the specified
/// point). When a Cartesian point is specified by Trim1
/// or by Trim2 it shall lie on the BasisCurve.
/// Except the case of a closed BasisCurve
/// where both parameter 1 and parameter 2 exist, they shall be consistent
/// with the sense flag, i.e., (sense = parameter 1 < parameter 2). Or, for every open curve where both
/// parameter 1 and parameter 2 exist, they shall be consistent with the SenseAgreement,
/// i.e., SenseAgreement = (parameter 1 <
/// parameter 2). If both parameter 1
/// and parameter 2 exist, then parameter 1
/// <> parameter 2. For a
/// closed base curve, e.g. IfcCircle or IfcEllipse,
/// this also applies to the cyclic properties, as 360' is equal to 0',
/// parameter 1 = 360' and parameter 2 = 0' are treated as being equal and
/// therefore violating this proposition. When
/// a parameter value is specified by Trim1
/// or Trim2 it shall lie within the parametric range
/// of the BasisCurve.
/// Additional illustration from IAI:
///   The
/// figure above shows the four arcs (dashed blue and
/// green lines with arrow showing different orientations) that can be
/// defined by the same BasisCurve (of type IfcCircle)
/// and the same trimming points (given by Cartesian points and parameter
/// values) by using different assignments to Trim1 and
/// Trim2 and SenseAgreement.  
/// Note: Since the BasisCurve is closed (type IfcCircle),
/// the exception of the informal proposition IP3 applies, i.e. the sense
/// flag is not
/// required to be consistent with the parameter values of Trim1
/// and Trim1, so the rule (sense = parameter 1
/// < parameter 2) may not be fulfilled.
class IFC_PARSE_API IfcTrimmedCurve : public IfcBoundedCurve {
public:
    /// The curve to be trimmed. For curves with multiple representations any parameter values given as Trim1 or Trim2 refer to the master representation of the BasisCurve only.
    IfcCurve* BasisCurve() const;
    void setBasisCurve(IfcCurve* v);
    /// The first trimming point which may be specified as a Cartesian point, as a real parameter or both.
    IfcEntityList::ptr Trim1() const;
    void setTrim1(IfcEntityList::ptr v);
    /// The second trimming point which may be specified as a Cartesian point, as a real parameter or both.
    IfcEntityList::ptr Trim2() const;
    void setTrim2(IfcEntityList::ptr v);
    /// Flag to indicate whether the direction of the trimmed curve agrees with or is opposed to the direction of the basis curve.
    bool SenseAgreement() const;
    void setSenseAgreement(bool v);
    /// Where both parameter and point are present at either end of the curve this indicates the preferred form.
    IfcTrimmingPreference::IfcTrimmingPreference MasterRepresentation() const;
    void setMasterRepresentation(IfcTrimmingPreference::IfcTrimmingPreference v);
    virtual unsigned int getArgumentCount() const { return 5; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_ENTITY_INSTANCE; case 1: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 2: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 3: return IfcUtil::Argument_BOOL; case 4: return IfcUtil::Argument_ENUMERATION; } return IfcBoundedCurve::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcCurve; case 1: return Type::IfcTrimmingSelect; case 2: return Type::IfcTrimmingSelect; case 3: return Type::IfcBoolean; case 4: return Type::IfcTrimmingPreference; } return IfcBoundedCurve::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "BasisCurve"; case 1: return "Trim1"; case 2: return "Trim2"; case 3: return "SenseAgreement"; case 4: return "MasterRepresentation"; } return IfcBoundedCurve::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcTrimmedCurve (IfcEntityInstanceData* e);
    IfcTrimmedCurve (IfcCurve* v1_BasisCurve, IfcEntityList::ptr v2_Trim1, IfcEntityList::ptr v3_Trim2, bool v4_SenseAgreement, IfcTrimmingPreference::IfcTrimmingPreference v5_MasterRepresentation);
    typedef IfcTemplatedEntityList< IfcTrimmedCurve > list;
};
/// The energy conversion device type IfcTubeBundleType defines commonly shared information for occurrences of tube bundles.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a tube bundle specification (i.e. the specific product information, that is common to all occurrences of that product type).  Tube Bundle types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcTubeBundleType are represented by instances of IfcTubeBundle. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcEnergyConversionDeviceType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_TubeBundleTypeCommon 
/// 
/// The following property set definitions are applicable to this entity according to the PredefinedType attribute:  
/// Pset_TubeBundleTypeFinned (FINNED) 
/// 
/// Material Use Definition 
/// The material of the IfcTubeBundleType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Body': Material used for construction of the tubes. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcTubeBundleType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcTubeBundle for standard port definitions.
class IFC_PARSE_API IfcTubeBundleType : public IfcEnergyConversionDeviceType {
public:
    /// Defines the type of tube bundle.
    IfcTubeBundleTypeEnum::IfcTubeBundleTypeEnum PredefinedType() const;
    void setPredefinedType(IfcTubeBundleTypeEnum::IfcTubeBundleTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcEnergyConversionDeviceType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcTubeBundleTypeEnum; } return IfcEnergyConversionDeviceType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcEnergyConversionDeviceType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcTubeBundleType (IfcEntityInstanceData* e);
    IfcTubeBundleType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcTubeBundleTypeEnum::IfcTubeBundleTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcTubeBundleType > list;
};
/// The energy conversion device type IfcUnitaryEquipmentType defines commonly shared information for occurrences of unitary equipments.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a unitary equipment specification (i.e. the specific product information, that is common to all occurrences of that product type).  Unitary Equipment types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcUnitaryEquipmentType are represented by instances of IfcUnitaryEquipment. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcEnergyConversionDeviceType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_UnitaryEquipmentTypeCommon 
/// 
/// Material Use Definition 
/// The material of the IfcUnitaryEquipmentType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.   
/// Composition Use Definition 
/// The IfcUnitaryEquipmentType may be aggregated into components using IfcRelAggregates where RelatingObject refers to the enclosing IfcUnitaryEquipmentType and RelatedObjects contains one or more components.  Components are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Aggregation use is defined for the following predefined types:
/// 
/// (All Types): May contain IfcDistributionElement components.  Unitary equipment (air handlers in particular) may elaborate contained elements such as dampers, fans, coils, sensors, actuators, and controllers.  Such breakdown provides access to component information and tracking of performance history for embedded elements. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcUnitaryEquipmentType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcUnitaryEquipment for standard port definitions.
class IFC_PARSE_API IfcUnitaryEquipmentType : public IfcEnergyConversionDeviceType {
public:
    /// The type of unitary equipment.
    IfcUnitaryEquipmentTypeEnum::IfcUnitaryEquipmentTypeEnum PredefinedType() const;
    void setPredefinedType(IfcUnitaryEquipmentTypeEnum::IfcUnitaryEquipmentTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcEnergyConversionDeviceType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcUnitaryEquipmentTypeEnum; } return IfcEnergyConversionDeviceType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcEnergyConversionDeviceType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcUnitaryEquipmentType (IfcEntityInstanceData* e);
    IfcUnitaryEquipmentType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcUnitaryEquipmentTypeEnum::IfcUnitaryEquipmentTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcUnitaryEquipmentType > list;
};
/// The flow controller type IfcValveType defines commonly shared information for occurrences of valves.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a valve specification (i.e. the specific product information, that is common to all occurrences of that product type).  Valve types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcValveType are represented by instances of IfcValve. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcFlowControllerType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_ValveTypeCommon 
/// 
/// The following property set definitions are applicable to this entity according to the PredefinedType attribute:  
/// Pset_ValveTypeAirRelease (AIRRELEASE) 
/// Pset_ValveTypeDrawOffCock (DRAWOFFCOCK) 
/// Pset_ValveTypeFaucet (FAUCET) 
/// Pset_ValveTypeFlushing (FLUSHING) 
/// Pset_ValveTypeGasTap (GASTAP) 
/// Pset_ValveTypeIsolating (ISOLATING) 
/// Pset_ValveTypeMixing (MIXING) 
/// Pset_ValveTypePressureReducing (PRESSUREREDUCING) 
/// Pset_ValveTypePressureRelief (PRESSURERELIEF) 
/// 
/// Material Use Definition 
/// The material of the IfcValveType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Body': The primary material from which the object is constructed. 
/// 'Operation': Material from which the operating mechanism (gate, globe, plug, needle, clack etc.) of the valve is constructed. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcValveType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcValve for standard port definitions.
class IFC_PARSE_API IfcValveType : public IfcFlowControllerType {
public:
    /// The type of valve.
    IfcValveTypeEnum::IfcValveTypeEnum PredefinedType() const;
    void setPredefinedType(IfcValveTypeEnum::IfcValveTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcFlowControllerType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcValveTypeEnum; } return IfcFlowControllerType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcFlowControllerType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcValveType (IfcEntityInstanceData* e);
    IfcValveType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcValveTypeEnum::IfcValveTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcValveType > list;
};
/// A vibration isolator is a device used to minimize the effects of vibration transmissibility in a building. 
/// 
/// HISTORY  New entity in IFC2x4
/// 
/// Type Use Definition
/// IfcVibrationIsolator defines the occurrence of any vibration isolator; common information about vibration isolator types is handled by IfcVibrationIsolatorType. 
/// The IfcVibrationIsolatorType (if present) may establish the common type name, usage (predefined type), properties, materials, composition, assignments, and representations. 
/// The IfcVibrationIsolatorType is attached using the IfcRelDefinesByType objectified relationship and is accessible by the IsTypedBy inverse attribute. 
/// If the IfcVibrationIsolatorType has aggregated elements, such objects are reflected at the IfcVibrationIsolator occurrence using the IfcRelDefinesByObject relationship.
/// 
/// Property Use Definition
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute. 
/// Property sets may also be specified at the IfcVibrationIsolatorType, defining the common property data for all occurrences of the same type. 
/// They are then accessible by the IsTypedBy inverse attribute pointing to IfcVibrationIsolatorType.HasPropertySets. 
/// If both are given, then the properties directly defined at IfcVibrationIsolator override the properties defined at IfcVibrationIsolatorType. 
/// Refer to the documentation at the supertype IfcElementComponent and ancestors for inherited property set definitions.
/// The following property set definitions are applicable to this entity:
/// Pset_VibrationIsolatorTypeCommon (PSET_TYPEDRIVENOVERRIDE)
/// 
/// Quantity Use Definition
/// The quantities relating to this entity are defined by IfcElementQuantity and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute.
/// The following base quantities are defined and shall be exchanged with the IfcElementQuantity.Name = 'BaseQuantities'. 
/// Other quantities, being subjected to local standard of measurement, may be defined with another string value assigned to Name. 
/// In this case a valid value for MethodOfMeasurement shall be provided. 
/// 
/// Qto_VibrationIsolatorBaseQuantities
/// 
/// Material Use Definition
/// The material of the IfcVibrationIsolator is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship. It is accessible by the HasAssociations inverse attribute. Material information can also be given at the IfcVibrationIsolatorType, defining the common attribute data for all occurrences of the same type. The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used:
/// 
/// Body: The primary material from which the object is constructed.
/// Damping: Material from which the damping element of the vibration isolator is constructed.
class IFC_PARSE_API IfcVibrationIsolator : public IfcElementComponent {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcVibrationIsolator
    bool hasPredefinedType() const;
    IfcVibrationIsolatorTypeEnum::IfcVibrationIsolatorTypeEnum PredefinedType() const;
    void setPredefinedType(IfcVibrationIsolatorTypeEnum::IfcVibrationIsolatorTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcElementComponent::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcVibrationIsolatorTypeEnum; } return IfcElementComponent::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "PredefinedType"; } return IfcElementComponent::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcVibrationIsolator (IfcEntityInstanceData* e);
    IfcVibrationIsolator (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcVibrationIsolatorTypeEnum::IfcVibrationIsolatorTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcVibrationIsolator > list;
};
/// The element component type IfcVibrationIsolatorType defines commonly shared information for occurrences of vibration isolators.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// applicable assignment of process types 
/// 
/// It is used to define a vibration isolator specification (i.e. the specific product information, that is common to all occurrences of that product type).  Vibration Isolator types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcVibrationIsolatorType are represented by instances of IfcVibrationIsolator. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcElementComponentType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_VibrationIsolatorTypeCommon 
/// 
/// Material Use Definition 
/// The material of the IfcVibrationIsolatorType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Damping': Material from which the damping element of the vibration isolator is constructed.
class IFC_PARSE_API IfcVibrationIsolatorType : public IfcElementComponentType {
public:
    /// Defines the type of vibration isolator.
    IfcVibrationIsolatorTypeEnum::IfcVibrationIsolatorTypeEnum PredefinedType() const;
    void setPredefinedType(IfcVibrationIsolatorTypeEnum::IfcVibrationIsolatorTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcElementComponentType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcVibrationIsolatorTypeEnum; } return IfcElementComponentType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcElementComponentType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcVibrationIsolatorType (IfcEntityInstanceData* e);
    IfcVibrationIsolatorType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcVibrationIsolatorTypeEnum::IfcVibrationIsolatorTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcVibrationIsolatorType > list;
};
/// A virtual element is a special element used to provide imaginary boundaries, such as between two adjacent, but not separated, spaces. Virtual elements are usually not displayed and does not have quantities and other measures. Therefore IfcVirtualElement does not have material information and quantities attached.
/// 
/// NOTE The main purpose of IfcVirtualElement is the provision of a virtual space boundary. The IfcVirtualElement may provide the 2D curve or 3D surface representation of the virtual space connection and is referenced by two instances of IfcRelSpaceBoundary, each pointing to one of the two adjacent IfcSpaces.
/// 
/// HISTORY New entity in IFC Release 2x2 Addendum.
/// IFC2x2 CHANGE: The entity IfcVirtualElement has been added. Upward compatibility for file based exchange is guaranteed.
/// 
/// Space Boundary Use Definition
/// The IfcVirtualElement is mainly used to define a virtual boundary between two spaces. Figure 63 describes how to use IfcRelSpaceBoundary in conjunction with IfcVirtualElement to define space boundaries.
/// 
/// Figure 63 — Virtual element space boundaries
/// 
/// Geometry Use Definition
/// The geometric representation of any IfcVirtualElement
/// is given by the IfcProductDefinitionShape and
/// IfcLocalPlacement allowing multiple geometric
/// representations. Included are:
/// Local Placement
/// The local placement for IfcVirtualElement is defined in
/// its supertype IfcProduct. It is defined by the
/// IfcLocalPlacement, which defines the local coordinate
/// system that is referenced by all geometric representations.
/// 
/// The PlacementRelTo relationship of
/// IfcLocalPlacement shall point (if given) to the local
/// placement of the same IfcSpatialStructureElement that is
/// used in the ContainedInStructure inverse attribute or to a
/// referenced spatial structure element at a higher level.
/// If the relative placement is not used, the absolute placement
/// is defined within the world coordinate system.
/// 
/// Geometric Representation
/// Currently, the use of 'FootPrint' and 'Surface' representation
/// is supported.
/// FootPrint Representation
/// The 2D geometric representation of IfcVirtualElement is
/// defined using the 'FootPrint' representation.
/// 
/// IfcShapeRepresentation.RepresentationIdentifier =
/// 'FootPrint'.
/// IfcShapeRepresentation.RepresentationType = 'Curve2D'
/// or 'GeometricCurveSet' .
/// 
/// The following constraints apply to the 2D FootPrint
/// representation:
/// 
/// 'Curve2D': IfcPolyline, IfcTrimmedCurve or
/// IfcCompositeCurve
/// 'GeometricCurveSet': a list of 2D curves within the
/// constraints shown above.
/// 
/// Surface Representation
/// The 3D geometric representation of IfcVirtualElement is
/// defined using a surface geometry.
/// 
/// IfcShapeRepresentation.RepresentationIdentifier =
/// 'Surface'.
/// IfcShapeRepresentation.RepresentationType =
/// 'Surface3D' or 'GeometricSet .
/// 
/// The following constraints apply to the 3D surface
/// representation:
/// 
/// 'Surface3D': IfcSurfaceOfLinearExtrusion,
/// IfcCurveBoundedPlane, IfcCurveBoundedSurface,
/// IfcRectangularTrimmedSurface
/// in case of an
/// IfcSurfaceOfLinearExtrusion
/// 
/// Profile:
/// IfcArbitraryOpenProfileDef
/// Extrusion: The extrusion direction shall be
/// vertically, i.e., along the positive Z Axis of the co-ordinate
/// system of the containing spatial structure element.
/// 
/// in case of an
/// IfcCurveBoundedPlane, IfcCurveBoundedSurface,
/// IfcRectangularTrimmedSurface
/// 
/// Extrusion: The BasisSurface shall be a
/// surface that is upright, i.e. standing perpendicular to the xy
/// place of the co-ordinate system of the containing spatial
/// structure element.
/// 
/// 'GeometricSet': a list of 3D surfaces within the constraints
/// shown above.
class IFC_PARSE_API IfcVirtualElement : public IfcElement {
public:
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcVirtualElement (IfcEntityInstanceData* e);
    IfcVirtualElement (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag);
    typedef IfcTemplatedEntityList< IfcVirtualElement > list;
};
/// Definition from IAI: A voiding feature is a modification of an element which reduces its volume.  Such a feature may be manufactured in different ways, for example by cutting, drilling, or milling of members made of various materials, or by inlays into the formwork of cast members made of materials such as concrete.
/// 
/// The standard use of instances of IfcVoidingFeature is as a part of element type objects (instances of subtypes of IfcElementType).  The part–whole relationship is established by an aggregation relationship object, expressing the decomposition of an element type into one or more additive elements (element parts) and zero or more feature elements.
/// 
/// HISTORY New type in IFC 2x4.
/// 
/// Containment Use Definition:
/// 
/// Voiding features shall have no spatial containment relationship to the spatial structure since they are dependent on element types without spatial containment relationships or on an element occurrence with own spatial containment relationship.
/// 
/// The SELF\IfcElement.ContainedInStructure relationship shall be NIL.
/// 
/// Geometry use definition:
/// 
/// The geometric representation of IfcVoidingFeatureElement is given by the IfcProductDefinitionShape, allowing multiple geometric representation.
/// 
/// Local Placement
/// 
/// The local placement for IfcVoidingFeatureElement is defined in its supertype IfcProduct. It is defined by the IfcLocalPlacement, which defines the local coordinate system that is referenced by all geometric representations.
/// 
/// In case of features which are part of an element type, absolute placement into the type object's implied coordinate system shall be used.
///   In case of features which are voiding an element occurrence, the PlacementRelTo relationship of IfcLocalPlacement shall point to the local placement of the respective element.
/// 
/// Shape representation
/// 
/// Different shape representations may be used, depending on the nature of the feature and information requirements:
/// 
/// Symbolic representations, such as an axis representation, may be used for simple shapes such as holes or edge features.
///   Volumetric representations by means of subtypes of IfcSweptSurface or of IfcCsgPrimitive3D may be used to semi-parametrically model the actual volume of the void created by the feature.  The objects within the shape model of the feature's shape representation can be included into a CSG model within a representation map of the parent element type.
///   Surface representations of cutting planes by means of IfcShellBasedSurfaceModel.  The faces within the surface model may be included into a B-Rep model within a representation map of the parent element type.
/// 
/// Higher-level parameters (geometric and non-geometric) may be provided by property sets based on local agreements.
class IFC_PARSE_API IfcVoidingFeature : public IfcFeatureElementSubtraction {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcVoidingFeature
    bool hasPredefinedType() const;
    /// Qualifies the feature regarding its shape and configuration relative to the voided element.
    IfcVoidingFeatureTypeEnum::IfcVoidingFeatureTypeEnum PredefinedType() const;
    void setPredefinedType(IfcVoidingFeatureTypeEnum::IfcVoidingFeatureTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcFeatureElementSubtraction::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcVoidingFeatureTypeEnum; } return IfcFeatureElementSubtraction::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "PredefinedType"; } return IfcFeatureElementSubtraction::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcVoidingFeature (IfcEntityInstanceData* e);
    IfcVoidingFeature (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcVoidingFeatureTypeEnum::IfcVoidingFeatureTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcVoidingFeature > list;
};
/// Definition from IAI: The element type
/// IfcWallType defines commonly shared information for
/// occurrences of walls. The set of shared information may
/// include:
/// 
/// common properties within shared property sets
/// common material information
/// common material layer definitions
/// common shape representations
/// 
/// NOTE It is illegal to share shape
/// representations as representation maps for occurrences of
/// IfcWallStandardcase.
/// 
/// It is used to define a wall specification (i.e. the specific
/// product information, that is common to all occurrences of that
/// product type). Wall types may be exchanged without being already
/// assigned to occurrences.
/// 
/// NOTE: The product representations are defined
/// as representation maps (at the level of the supertype
/// IfcTypeProduct, which gets assigned by an element
/// occurrence instance through the
/// IfcShapeRepresentation.Item[1] being an
/// IfcMappedItem.
/// 
/// Occurrences of the IfcWallType within building models
/// are represented by instances of IfcWallStandardCase if the
/// IfcBeamType has a single associated
/// IfcMaterialLayerSet; otherwise they are represented by
/// instances of IfcWall, or IfcWallElementedCase.
/// Occurrences of the IfcWallType within structural analysis
/// models are represented by instances of
/// IfcStructuralSurfaceMember, or its applicable
/// subtypes.
/// HISTORY: New entity in
/// Release IFC2x Editon 2.
/// Informal proposition:
/// 
/// The material assignment, if provided using the
/// IfcRelAssociatesMaterial relationship, shall not reference
/// the IfcMaterialLayerSetUsage.
/// 
/// Material Use Definition
/// The material of the IfcWallType is defined by the
/// IfcMaterialLayerSet or as fall back by IfcMaterial
/// and attached by the
/// IfcRelAssociatesMaterial.RelatingMaterial. It is
/// accessible by the inverse HasAssociations
/// relationship.
/// Note: It is illegal to assign an
/// IfcMaterial to an IfcWallType, if there is at least
/// one occurrences. of IfcWallStandardCase for this
/// type.
/// Layer Set Use Definition:
/// The shared material layer set definition is defined by
/// assigning an IfcMaterialLayerSet (see material use
/// definition above). The IfcMaterialLayer refers to one or
/// several of IfcMaterialLayer that is the common for all
/// wall occurrence, if used. It is only applicable if the
/// IfcWallType has only occurrences of type
/// IfcWallStandardCase (see definition of
/// IfcWallStandardCase for further information).
/// NOTE Since each individual instance of
/// IfcWallStandardCase defines its own
/// IfcMaterialLayerSetUsage including the offset from the
/// wall axis, the same IfcWallType can be used independently
/// of the axis alignment of its occurrences.
/// Property Set Use Definition:
/// The shared property sets relating to the IfcWallType
/// are defined by the IfcPropertySet and are attached by the
/// HasPropertySets attribute. The following property set
/// definitions specific to the IfcWallType are part of this
/// IFC release:
/// NOTE There is no differentiation between
/// properties within the property set that are only assignable to
/// IfcWallType and those that are only assignable to
/// IfcWall. If the same property is assigned to the
/// IfcWallType and the IfcWall being an occurrence of
/// the IfcWallType, then the occurrence property overrides
/// the type property.
/// 
/// Pset_WallCommon: common property set for all
/// wall types.
class IFC_PARSE_API IfcWallType : public IfcBuildingElementType {
public:
    /// Identifies the predefined types of a wall element from which the type required may be set.
    IfcWallTypeEnum::IfcWallTypeEnum PredefinedType() const;
    void setPredefinedType(IfcWallTypeEnum::IfcWallTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcBuildingElementType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcWallTypeEnum; } return IfcBuildingElementType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcBuildingElementType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcWallType (IfcEntityInstanceData* e);
    IfcWallType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcWallTypeEnum::IfcWallTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcWallType > list;
};
/// The flow terminal type IfcWasteTerminalType defines commonly shared information for occurrences of waste terminals.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a waste terminal specification (i.e. the specific product information, that is common to all occurrences of that product type).  Waste Terminal types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcWasteTerminalType are represented by instances of IfcWasteTerminal. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcFlowTerminalType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_WasteTerminalTypeCommon 
/// 
/// The following property set definitions are applicable to this entity according to the PredefinedType attribute:  
/// Pset_WasteTerminalTypeFloorTrap (FLOORTRAP) 
/// Pset_WasteTerminalTypeFloorWaste (FLOORWASTE) 
/// Pset_WasteTerminalTypeGullySump (GULLYSUMP) 
/// Pset_WasteTerminalTypeGullyTrap (GULLYTRAP) 
/// Pset_WasteTerminalTypeRoofDrain (ROOFDRAIN) 
/// Pset_WasteTerminalTypeWasteDisposalUnit (WASTEDISPOSALUNIT) 
/// Pset_WasteTerminalTypeWasteTrap (WASTETRAP) 
/// 
/// Material Use Definition 
/// The material of the IfcWasteTerminalType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Body': The primary material from which the object is constructed. 
/// 'Cover': Material from which the cover or grating is constructed. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcWasteTerminalType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcWasteTerminal for standard port definitions.
class IFC_PARSE_API IfcWasteTerminalType : public IfcFlowTerminalType {
public:
    /// Identifies the predefined types of waste terminal from which the type required may be set.
    IfcWasteTerminalTypeEnum::IfcWasteTerminalTypeEnum PredefinedType() const;
    void setPredefinedType(IfcWasteTerminalTypeEnum::IfcWasteTerminalTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcFlowTerminalType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcWasteTerminalTypeEnum; } return IfcFlowTerminalType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcFlowTerminalType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcWasteTerminalType (IfcEntityInstanceData* e);
    IfcWasteTerminalType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcWasteTerminalTypeEnum::IfcWasteTerminalTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcWasteTerminalType > list;
};
/// Definition from IAI: The element type
/// IfcWindowType defines commonly shared information for
/// occurrences of windows. The set of shared information may
/// include:
/// 
/// common properties within shared property sets
/// common material information
/// common partitioning of panels
/// common operation types of panels
/// common shape representations
/// 
/// A window type defines the particular parameter of the lining
/// and one (or several) panels through the
/// IfcWindowLiningProperties and the
/// IfcWindowPanelProperties as predefined property sets
/// applicable to windows only.
/// It is used to define a window specification, or window style
/// (i.e. the specific product information that is common to all
/// occurrences of that window type). Window types may be exchanged
/// without being already assigned to occurrences.
/// Occurrences of the IfcWindowType within building models
/// are represented by instances of IfcWindow or
/// IfcWindowStandardCase.
/// HISTORY New entity in
/// IFC2x4 .
/// NOTE The entity IfcWindowType
/// replaces the previous definition IfcWindowStyle (which is
/// deprecated in IFC2x4).
/// Partitioning type use definition
/// The IfcWindowTypePartitioningEnum defines the general
/// layout of the window type and its symbolic presentation.
/// Depending on the enumerator, the appropriate instances of
/// IfcWindowLiningProperties and
/// IfcWindowPanelProperties are attached in the list of
/// HasPropertySets. The IfcWindowTypePartitioningEnum
/// mainly determines the way of partitioning the window into
/// individual window panels and thereby number and position of
/// window panels.
/// See geometry use definitions at
/// IfcWindowTypePartitioningEnum for the correct usage of
/// panel partitioning and IfcWindowPanelProperties for the
/// opening symbols for different panel operation types.
/// Material Use Definition
/// The material of the IfcWindowType is defined by the
/// IfcMaterialConstituentSet or as fall back by
/// IfcMaterial and attached by the
/// IfcRelAssociatesMaterial.RelatingMaterial. It is
/// accessible by the inverse HasAssociations
/// relationship.
/// The following keywords for
/// IfcMaterialConstituentSet.MaterialConstituents[n].Name
/// shall be used:
/// 
/// 'Lining' - to indicate that the material constituent applies
/// to to the window lining
/// 'Framing' - to indicate that the material constituent applies
/// to to the window panels, if not provided, the 'Lining' material
/// information applied to panels as well
/// 'Glazing' - to indicate that the material constituent applies
/// to to the glazing part
/// 
/// If the fall back single IfcMaterial is referenced, it
/// applies to the lining and framing of the window.
/// Property Set Use Definition:
/// The shared property sets relating to the IfcWindowType
/// are defined by the IfcPropertySet and are attached by the
/// HasPropertySets attribute. The following property set
/// definitions specific to the IfcWindowType are part of this
/// IFC release:
/// NOTE There is no differentiation between
/// properties within the property set that are only assignable to
/// IfcWindowType and those that are only assignable to
/// IfcWindow. If the same property is assigned to the
/// IfcWindowType and the IfcWindow being an occurrence
/// of the IfcWindowType, then the occurrence property
/// overrides the type property.
/// 
/// Pset_WindowCommon: common property set for all
/// window types.
/// Pset_DoorWindowGlazingType: specific property
/// set for the glazing properties of the door type glazing
/// Pset_DoorWindowShadingType: specific property
/// set for the shading properties of the door type shading
/// 
/// Two subtypes of IfcPreDefinedPropertySet are applicable
/// to IfcWindowType:
/// 
/// IfcWindowLiningProperties - a single instance to
/// define the shape parameters of the window lining
/// IfcWindowPanelProperties - one or several instances to
/// define the shape parameters of the window panel(s)
/// 
/// Geometry Use Definitions:
/// The IfcWindowType may define the common shape of window
/// occurrences. The common shape can be defined by
/// 
/// applying shape parameters defined within the associated
/// IfcWindowLiningProperties and
/// IfcWindowPanelProperties applied to the 'Profile'
/// geometric representation. It is only applicable if the
/// IfcWindowType has only occurrences of type
/// IfcWindowStandardCase (See geometric use definition of
/// IfcWindowStandardCase for further information).
/// applying the RepresentationMaps attribute to refer to
/// a list of IfcRepresentationMap's, that allow for multiple
/// geometric representations (e.g. with
/// IfcShapeRepresentation's having an
/// RepresentationIdentifier 'Box', 'Profile', 'FootPrint', or
/// 'Body')
/// NOTE The product shape representations are
/// defined as RepresentationMaps (attribute of the supertype
/// IfcTypeProduct), which get assigned by an element
/// occurrence instance through the
/// IfcShapeRepresentation.Item[n] being an
/// IfcMappedItem. See IfcTypeProduct for further
/// information.
/// NOTE The values of attributes
/// RepresentationIdentifier and RepresentationType of
/// IfcShapeRepresentation are restricted in the same way as
/// those for IfcWindow and
/// IfcWindowStandardCase
class IFC_PARSE_API IfcWindowType : public IfcBuildingElementType {
public:
    /// Identifies the predefined types of a window element from which the type required may be set.
    IfcWindowTypeEnum::IfcWindowTypeEnum PredefinedType() const;
    void setPredefinedType(IfcWindowTypeEnum::IfcWindowTypeEnum v);
    /// Type defining the general layout of the window type in terms of the partitioning of panels.
    IfcWindowTypePartitioningEnum::IfcWindowTypePartitioningEnum PartitioningType() const;
    void setPartitioningType(IfcWindowTypePartitioningEnum::IfcWindowTypePartitioningEnum v);
    /// Whether the optional attribute ParameterTakesPrecedence is defined for this IfcWindowType
    bool hasParameterTakesPrecedence() const;
    bool ParameterTakesPrecedence() const;
    void setParameterTakesPrecedence(bool v);
    /// Whether the optional attribute UserDefinedPartitioningType is defined for this IfcWindowType
    bool hasUserDefinedPartitioningType() const;
    std::string UserDefinedPartitioningType() const;
    void setUserDefinedPartitioningType(std::string v);
    virtual unsigned int getArgumentCount() const { return 13; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; case 10: return IfcUtil::Argument_ENUMERATION; case 11: return IfcUtil::Argument_BOOL; case 12: return IfcUtil::Argument_STRING; } return IfcBuildingElementType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcWindowTypeEnum; case 10: return Type::IfcWindowTypePartitioningEnum; case 11: return Type::IfcBoolean; case 12: return Type::IfcLabel; } return IfcBuildingElementType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; case 10: return "PartitioningType"; case 11: return "ParameterTakesPrecedence"; case 12: return "UserDefinedPartitioningType"; } return IfcBuildingElementType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcWindowType (IfcEntityInstanceData* e);
    IfcWindowType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcWindowTypeEnum::IfcWindowTypeEnum v10_PredefinedType, IfcWindowTypePartitioningEnum::IfcWindowTypePartitioningEnum v11_PartitioningType, boost::optional< bool > v12_ParameterTakesPrecedence, boost::optional< std::string > v13_UserDefinedPartitioningType);
    typedef IfcTemplatedEntityList< IfcWindowType > list;
};
/// An IfcWorkCalendar defines working and non-working time periods for tasks and resources. It enables to define both specific time periods, such as from 7:00 till 12:00 on 25th August 2009, as well as repetitive time periods based on frequently used recurrence patterns, such as each Monday from 7:00 till 12:00 between 1st March 2009 and 31st December 2009.
/// 
/// HISTORY  New entity in IFC2x4.
/// 
/// A work calendar is a subtype of IfcControl and thus inherits the feature for controlling other objects through IfcRelAssignsToControl, which is used to define a work calendar for tasks (IfcTask) and resources (IfcResource). It also inherits a name and description attribute, whereas a name shall be given and a description may be given as an indication of its content and usage.
/// 
/// The definition of time periods can be derived from a base calendar and/or modified/defined by a set of working times and non-working exception times. All time periods defined by IfcWorkCalendar.ExceptionTimes override the time periods inherited from the base calendar (base calendar is defined as the next applicable calendar for the task or resource). Thus, exception times replace the working times from the base calendar.
/// 
/// The base calendar of a work calendar is defined by IfcRelAssignsToControl, where IfcRelAssignsToControl.RelatingControl is linked with the base calendar and IfcRelAssignsToControl.RelatedObjects is linked with work calendars that are derived from the base calendar. Although not restricted by the IfcRelAssignsToControl relationship it is only allowed to have one base calendar.
/// 
/// Figure 17 shows the definition of a work calendar, which is defined by a set of work times and exception times. The work times are defined as recurring patterns with optional boundaries (applying from and/or to a specific date). The shown example defines a simple work calendar with working times Monday to Thursday 8:00 to 12:00 and 13:00 to 17:00, Friday 8:00 to 14:00 and as exception every 1st Monday in a month the work starts one hour later - i.e. the working time on every 1st Monday in a month is overriden to be 9:00 to 12:00 and 13:00 to 17:00. Both the working time and the exception time is valid for the period of 01.09.2010 till 30.08.2011.
/// 
/// Figure 17 — Work calendar instantiation
class IFC_PARSE_API IfcWorkCalendar : public IfcControl {
public:
    /// Whether the optional attribute WorkingTimes is defined for this IfcWorkCalendar
    bool hasWorkingTimes() const;
    /// Set of times periods that are regarded as an initial set-up
    ///   of working times. Exception times can then further restrict
    ///   these working times.
    IfcTemplatedEntityList< IfcWorkTime >::ptr WorkingTimes() const;
    void setWorkingTimes(IfcTemplatedEntityList< IfcWorkTime >::ptr v);
    /// Whether the optional attribute ExceptionTimes is defined for this IfcWorkCalendar
    bool hasExceptionTimes() const;
    /// Set of times periods that define exceptions (non-working
    ///   times) for the given working times including the base
    ///   calendar, if provided.
    IfcTemplatedEntityList< IfcWorkTime >::ptr ExceptionTimes() const;
    void setExceptionTimes(IfcTemplatedEntityList< IfcWorkTime >::ptr v);
    /// Whether the optional attribute PredefinedType is defined for this IfcWorkCalendar
    bool hasPredefinedType() const;
    /// Identifies the predefined types of a work calendar from which 
    ///   the type required may be set.
    /// 
    /// Added in IFC 2x4
    IfcWorkCalendarTypeEnum::IfcWorkCalendarTypeEnum PredefinedType() const;
    void setPredefinedType(IfcWorkCalendarTypeEnum::IfcWorkCalendarTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 6: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 7: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 8: return IfcUtil::Argument_ENUMERATION; } return IfcControl::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 6: return Type::IfcWorkTime; case 7: return Type::IfcWorkTime; case 8: return Type::IfcWorkCalendarTypeEnum; } return IfcControl::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 6: return "WorkingTimes"; case 7: return "ExceptionTimes"; case 8: return "PredefinedType"; } return IfcControl::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcWorkCalendar (IfcEntityInstanceData* e);
    IfcWorkCalendar (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, boost::optional< std::string > v6_Identification, boost::optional< IfcTemplatedEntityList< IfcWorkTime >::ptr > v7_WorkingTimes, boost::optional< IfcTemplatedEntityList< IfcWorkTime >::ptr > v8_ExceptionTimes, boost::optional< IfcWorkCalendarTypeEnum::IfcWorkCalendarTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcWorkCalendar > list;
};
/// An IfcWorkControl is an abstract supertype which captures information that is common to both IfcWorkPlan and IfcWorkSchedule.
/// 
/// HISTORY  New class in IFC 2x
/// 
/// CHANGE IFC2x4  Corrected assignment of resources to work control in documentation. Assignment of tasks to work control updated based on changes of task time definitions and the introduction of a summary task. Identifier has been renamed (now Identification) and promoted to supertype IfcControl
/// 
/// A work control may have resources assigned to it, this is
///   handled by the IfcRelAssignsToControl relationship.
///   A work control should also define a context that gives
///   further information about its usage. If no special context
///   information is required then the IfcProject instance
///   as a global context should be used instead. An explicit
///   link between the work control and the IfcProject via
///   IfcRelDeclares should then be provided.
/// 
/// From IFC2x4 onwards the assignment of tasks to the work
///   control is handled by the IfcRelAssignsToControl
///   relationship. IfcRelAssignsTasks as used in previous
///   IFC releases has been deleted and can not be used any
///   longer. Another change in IFC2x4 is that it is not
///   necessary to assign each task to a work control as it is
///   regarded to be sufficient if the summary task (root task in
///   the task hierarchy defined through IfcRelNests
///   relationships) is assigned to a work control.
/// 
/// The attribute IfcWorkControl.Purpose is used to
///   define the purpose of either a work schedule or a work
///   plan. In the case of IfcWorkPlan, the purpose
///   attribute can be used to determine if the work plan is for
///   cost estimating, task scheduling or some other defined
///   purpose.
/// 
/// Property set use definition
/// 
/// The property sets relating to the IfcWorkControl are
///   defined by IfcPropertySet and attached by the
///   IfcRelDefinesByProperties relationship. It is
///   accessible by the inverse IsDefinedBy relationship.
///   The following property set definition specific to the
///   IfcWorkControl and its subtype are part of this IFC
///   release:
/// 
/// Pset_WorkControlCommon: common
///   property set for work control
class IFC_PARSE_API IfcWorkControl : public IfcControl {
public:
    /// The date that the plan is created.
    std::string CreationDate() const;
    void setCreationDate(std::string v);
    /// Whether the optional attribute Creators is defined for this IfcWorkControl
    bool hasCreators() const;
    /// The authors of the work plan.
    IfcTemplatedEntityList< IfcPerson >::ptr Creators() const;
    void setCreators(IfcTemplatedEntityList< IfcPerson >::ptr v);
    /// Whether the optional attribute Purpose is defined for this IfcWorkControl
    bool hasPurpose() const;
    /// A description of the purpose of the work schedule.
    std::string Purpose() const;
    void setPurpose(std::string v);
    /// Whether the optional attribute Duration is defined for this IfcWorkControl
    bool hasDuration() const;
    /// The total duration of the entire work schedule.
    std::string Duration() const;
    void setDuration(std::string v);
    /// Whether the optional attribute TotalFloat is defined for this IfcWorkControl
    bool hasTotalFloat() const;
    /// The total time float of the entire work schedule.
    std::string TotalFloat() const;
    void setTotalFloat(std::string v);
    /// The start time of the schedule.
    std::string StartTime() const;
    void setStartTime(std::string v);
    /// Whether the optional attribute FinishTime is defined for this IfcWorkControl
    bool hasFinishTime() const;
    /// The finish time of the schedule.
    std::string FinishTime() const;
    void setFinishTime(std::string v);
    virtual unsigned int getArgumentCount() const { return 13; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 6: return IfcUtil::Argument_STRING; case 7: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 8: return IfcUtil::Argument_STRING; case 9: return IfcUtil::Argument_STRING; case 10: return IfcUtil::Argument_STRING; case 11: return IfcUtil::Argument_STRING; case 12: return IfcUtil::Argument_STRING; } return IfcControl::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 6: return Type::IfcDateTime; case 7: return Type::IfcPerson; case 8: return Type::IfcLabel; case 9: return Type::IfcDuration; case 10: return Type::IfcDuration; case 11: return Type::IfcDateTime; case 12: return Type::IfcDateTime; } return IfcControl::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 6: return "CreationDate"; case 7: return "Creators"; case 8: return "Purpose"; case 9: return "Duration"; case 10: return "TotalFloat"; case 11: return "StartTime"; case 12: return "FinishTime"; } return IfcControl::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcWorkControl (IfcEntityInstanceData* e);
    IfcWorkControl (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, boost::optional< std::string > v6_Identification, std::string v7_CreationDate, boost::optional< IfcTemplatedEntityList< IfcPerson >::ptr > v8_Creators, boost::optional< std::string > v9_Purpose, boost::optional< std::string > v10_Duration, boost::optional< std::string > v11_TotalFloat, std::string v12_StartTime, boost::optional< std::string > v13_FinishTime);
    typedef IfcTemplatedEntityList< IfcWorkControl > list;
};
/// An IfcWorkPlan represents work plans in a construction or a facilities management project.
/// 
/// HISTORY: New Entity in IFC 2.0
/// 
/// A work plan contains a set of work schedules for different
///   purposes (including construction and facilities
///   management). Contained work schedules are defined through
///   the IfcRelAggregates relationship. Through
///   inheritance from IfcWorkControl it is also possible
///   to define references to activities (for example, IfcTask)
///   and resources used in the work plan.
/// 
/// A work plan has information such as start date, finish
///   date, total free float, and so on. IfcWorkPlan can
///   also refer to the construction project represented by the
///   single IfcProject instance (please also check the
///   definition of IfcWorkControl).
/// 
/// Figure 18 shows the backbone structure of a work plan that
///   defines (1) contained work schedules through
///   IfcRelAggregates and (2), if not assigned otherwise
///   to contained work schedules, assigned tasks and resources
///   through IfcRelAssignsToControl.
/// 
/// Figure 18 — Work plan relationships
class IFC_PARSE_API IfcWorkPlan : public IfcWorkControl {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcWorkPlan
    bool hasPredefinedType() const;
    /// Identifies the predefined types of a work plan from which 
    ///   the type required may be set.
    IfcWorkPlanTypeEnum::IfcWorkPlanTypeEnum PredefinedType() const;
    void setPredefinedType(IfcWorkPlanTypeEnum::IfcWorkPlanTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 14; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 13: return IfcUtil::Argument_ENUMERATION; } return IfcWorkControl::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 13: return Type::IfcWorkPlanTypeEnum; } return IfcWorkControl::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 13: return "PredefinedType"; } return IfcWorkControl::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcWorkPlan (IfcEntityInstanceData* e);
    IfcWorkPlan (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, boost::optional< std::string > v6_Identification, std::string v7_CreationDate, boost::optional< IfcTemplatedEntityList< IfcPerson >::ptr > v8_Creators, boost::optional< std::string > v9_Purpose, boost::optional< std::string > v10_Duration, boost::optional< std::string > v11_TotalFloat, std::string v12_StartTime, boost::optional< std::string > v13_FinishTime, boost::optional< IfcWorkPlanTypeEnum::IfcWorkPlanTypeEnum > v14_PredefinedType);
    typedef IfcTemplatedEntityList< IfcWorkPlan > list;
};
/// An IfcWorkSchedule
///   represents a task schedule of a work plan, which in turn
///   can contain a set of schedules for different purposes.
/// 
/// HISTORY: New Entity in IFC
///   Release 2.0
/// 
/// Assignment Use Definition
/// 
/// An IfcWorkSchedule controls a set of tasks and
///   resources defined through IfcRelAssignsToControl.
///   Additionally, through the IfcWorkControl abstract
///   supertype, the actors creating the schedule can be
///   specified and schedule time information such as start time,
///   finish time, and total float of the schedule can also be
///   specified.
/// 
/// Declaration Use Definition
/// 
/// IfcWorkSchedule can reference a project (the
///   single IfcProject instance) via
///   IfcRelDeclares. The documents of the
///   IfcWorkSchedule can be referenced by the
///   IfcRelAssociatesDocuments relationship. 
/// 
/// Composition Use Definition
///   A work schedule can include other work schedules as sub-items
///   through IfcRelNests relationship. If not included in
///   another work schedule it might be a part of a work plan
///   (IfcWorkPlan) defined through
///   IfcRelAggregates relationship.
/// 
/// Figure 19 shows the backbone structure of a work schedule
///   that defines (1) a context through IfcRelDeclares
///   (not necessarily the project) and (2) controls tasks
///   (typically the schedule summary task) and resources. Please
///   note that a work calendar shall be assigned to the summary
///   task and not the work schedule.
/// 
/// Figure 19 — Work schedule relationships
class IFC_PARSE_API IfcWorkSchedule : public IfcWorkControl {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcWorkSchedule
    bool hasPredefinedType() const;
    /// Identifies the predefined types of a work schedule from which 
    ///   the type required may be set.
    IfcWorkScheduleTypeEnum::IfcWorkScheduleTypeEnum PredefinedType() const;
    void setPredefinedType(IfcWorkScheduleTypeEnum::IfcWorkScheduleTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 14; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 13: return IfcUtil::Argument_ENUMERATION; } return IfcWorkControl::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 13: return Type::IfcWorkScheduleTypeEnum; } return IfcWorkControl::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 13: return "PredefinedType"; } return IfcWorkControl::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcWorkSchedule (IfcEntityInstanceData* e);
    IfcWorkSchedule (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, boost::optional< std::string > v6_Identification, std::string v7_CreationDate, boost::optional< IfcTemplatedEntityList< IfcPerson >::ptr > v8_Creators, boost::optional< std::string > v9_Purpose, boost::optional< std::string > v10_Duration, boost::optional< std::string > v11_TotalFloat, std::string v12_StartTime, boost::optional< std::string > v13_FinishTime, boost::optional< IfcWorkScheduleTypeEnum::IfcWorkScheduleTypeEnum > v14_PredefinedType);
    typedef IfcTemplatedEntityList< IfcWorkSchedule > list;
};
/// Definition from IAI: A zone isÿa group of spaces,
/// partial spaces or other zones. Zone structures may not be
/// hierarchical (in contrary to the spatial structure of a project -
/// see IfcSpatialStructureElement), i.e. one individual
/// IfcSpace may be associated with zero, one, or several
/// IfcZone's. IfcSpace's are grouped into an
/// IfcZone by using the objectified relationship
/// IfcRelAssignsToGroup as specified at the supertype
/// IfcGroup.
/// NOTE ÿCertain use cases may restrict the
/// freedom of non hierarchical relationships. In some building
/// service use cases the zone denotes aÿview based delimited volume
/// for the purpose of analysis and calculation. This type of zone
/// cannot overlap with respect to that analysis, but may overlap
/// otherwise.
/// An IfcZone is a spatial system under which individual
/// IfcSpace's (and other IfcZone's) are grouped. In
/// contrary to the IfcSpatialZone entity, IfcZone is a
/// mere grouping, it can not define an own geometric representation
/// and placement. Therefore it cannot be used for spatial zones
/// having a different shape and size compared to the shape and size
/// of aggregated spaces.
/// NOTEÿ The IfcZone is regarded as the
/// spatial system (as compared to the building service, electrical,
/// or analytical system), the name remains IfcZone for
/// compatibility reasons, instead of using a proper naming
/// convention, like IfcSpatialSystem.
/// NOTE ÿOne of the purposes of a zone is to
/// define a fire compartmentation. In this case it defines the
/// geometric information about the fire compartment (through the
/// contained spaces) and information, whether this compartment is
/// ventilated or sprinkler protected. In addition the fire risk code
/// and the hazard type can be added, the coding is normally defined
/// within a national fire regulation. All that information is
/// available within the relevant property sets. Again, if an
/// independent shape has to be provided to the fire compartment,
/// then the entity IfcSpatialZone shall be
/// used.
/// RECOMMENDATIONÿ In case of a zone denoting a
/// (fire) compartment, the following types should be used, if
/// applicable, as values of the ObjectType attribute:
/// 
/// FireCompartment - a zone of spaces, collected to
/// represent a single fire compartment.
/// ElevatorShaft - a collection of spaces within an
/// elevator, potentially going through many storeys.
/// RisingDuct
/// RunningDuct
/// 
/// Additional classifications of the IfcZone, as provided
/// by a national classification system, can be assigned by using the
/// IfcRelAssociatesClassification relationship, accessible
/// via the inverse attribute HasAssociations. The
/// IfcZone can be assigned to a spatial structure element, it
/// refers to, e.g. to a particular IfcBuildingStorey by using
/// the IfcRelServicesBuildings relationship, accessible via
/// the inverse attribute ServicesBuilding.
/// HISTORYÿ New entity in
/// IFC Release 1.0
/// IFC2x4 CHANGEÿ The entity is now
/// subtyped from IfcSystem (not its supertype
/// IfcGroup) with upward compatibility for file based
/// exchange.
/// Property Set Use Definition:
/// The property sets relating to the IfcZone are defined
/// by the IfcPropertySet and attached by the
/// IfcRelDefinesByProperties relationship. It is accessible
/// by the inverse IsDefinedBy relationship. The following
/// property set definitions specific to the IfcZone are part
/// of this IFC release:
/// 
/// Pset_ZoneCommon: common property set for all
/// types of zone
/// Pset_SpaceFireSafetyRequirements: common
/// property set for all types of zones to capture the fire safety
/// requirements
/// Pset_SpaceLightingRequirements: common
/// property set for all types of zones to capture the lighting
/// requirements
/// Pset_SpaceOccupancyRequirements: common
/// property set for all types of zones to capture the occupancy
/// requirements
/// Pset_SpaceThermalRequirements: common
/// property set for all types of zones to capture the thermal
/// requirements
class IFC_PARSE_API IfcZone : public IfcSystem {
public:
    /// Whether the optional attribute LongName is defined for this IfcZone
    bool hasLongName() const;
    /// Long name for a zone, used for informal purposes. It should be used, if available, in conjunction with the inherited Name attribute.
    /// 
    /// NOTE  In many scenarios the Name attribute refers to the short name or number of a zone, and the LongName refers to the full name.
    /// 
    /// IFC2x4 CHANGE The attribute has been added at the end of the entity definition.
    std::string LongName() const;
    void setLongName(std::string v);
    virtual unsigned int getArgumentCount() const { return 6; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 5: return IfcUtil::Argument_STRING; } return IfcSystem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 5: return Type::IfcLabel; } return IfcSystem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 5: return "LongName"; } return IfcSystem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcZone (IfcEntityInstanceData* e);
    IfcZone (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, boost::optional< std::string > v6_LongName);
    typedef IfcTemplatedEntityList< IfcZone > list;
};
/// A request is the act or instance of asking for something, such as a request for information, bid submission, or performance of work. 
/// 
/// Requests may take many forms depending on the need including fault reports for maintenance, requests for small works, and purchase requests (where these are to be made through a help desk or buying function). 
/// 
/// HISTORY: New entity in IFC2x2 
/// IFC2x4 CHANGE  RequestID renamed to Identification and promoted to supertype IfcControl, attributes PredefinedType, Status, and LongDescription added.
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the IfcRelDefinesByProperties relationship. They are accessible by the IsDefinedBy inverse attribute.  Refer to the documentation at the supertype IfcControl and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_ActionRequest 
/// 
/// Declaration Use Definition 
/// The IfcActionRequest may be declared within the project using the IfcRelDeclares relationship where RelatingContext refers to the single IfcProject and RelatedDefinitions contains the IfcActionRequest.  Alternatively, if the IfcActionRequest is aggregated within an IfcWorkPlan, then it shall not have a direct declaration relationship (whereas the containing work plan may have a declaration relationship). 
/// 
/// Composition Use Definition 
/// As shown in Figure 155, an IfcActionRequest may be aggregated into components using IfcRelAggregates where RelatingObject refers to the enclosing IfcActionRequest and RelatedObjects contains one or more components.  Aggregation use is defined for the following predefined types:
/// 
/// (All Types): May contain IfcCostSchedule components.  A cost schedule may indicate costs and quantities where the cost schedule type may designate whether rates and/or quantities are estimated or final.  Such cost schedule may have assigned cost items indicating detail, where each cost item may have assigned products, processes, or resources. 
/// 
/// The IfcActionRequest may be nested into sub-items using IfcRelNests where RelatingObject refers to the enclosing IfcActionRequest and RelatedObjects contains one or more sub-items.  Nesting use is defined for the following predefined types:
/// 
/// (All Types): May contain IfcActionRequest sub-items.  A request may be nested into follow-up requests, in order of issue. 
/// 
/// Figure 155 — Action request composition
/// 
/// Assignment Use Definition 
/// As shown in Figure 156, an IfcActionRequest may be assigned to the following entities using relationships as indicated: 
/// 
/// IfcActor (IfcRelAssignsToActor): Person or organization issuing the request such as a tenant or owner. 
/// 
/// The IfcActionRequest may have assignments of its own using the IfcRelAssignsToControl relationship where RelatingControl refers to the IfcActionRequest and RelatedObjects contains one or more objects of the following types:  
/// IfcActor: Person or organization(s) fulfilling the request such as a facilities manager or contractor.
/// 
/// Figure 156 — Action request assignment
/// 
/// Approval Use Definition 
/// Approvals may be associated to indicate the status of acceptance or rejection using the IfcRelAssociatesApproval relationship where RelatingApproval refers to an IfcApproval and RelatedObjects contains the IfcActionRequest.  Approvals may be split into sub-approvals using IfcApprovalRelationship to track approval status separately for each party where RelatingApproval refers to the higher-level approval and RelatedApprovals contains one or more lower-level approvals.  The hierarchy of approvals implies sequencing such that a higher-level approval is not executed until all of its lower-level approvals have been accepted.
class IFC_PARSE_API IfcActionRequest : public IfcControl {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcActionRequest
    bool hasPredefinedType() const;
    /// Identifies the predefined type of sources through which a request can be made.
    /// 
    /// IFC2x4 CHANGE  The attribute has been added.
    IfcActionRequestTypeEnum::IfcActionRequestTypeEnum PredefinedType() const;
    void setPredefinedType(IfcActionRequestTypeEnum::IfcActionRequestTypeEnum v);
    /// Whether the optional attribute Status is defined for this IfcActionRequest
    bool hasStatus() const;
    /// The status currently assigned to the request.  Possible values include:
    /// Hold: wait to see if further requests are received before deciding on action
    /// NoAction: no action is required on this request
    /// Schedule: plan action to take place as part of maintenance or other task planning/scheduling
    /// Urgent: take action immediately
    /// 
    /// IFC2x4 CHANGE  The attribute has been added.
    std::string Status() const;
    void setStatus(std::string v);
    /// Whether the optional attribute LongDescription is defined for this IfcActionRequest
    bool hasLongDescription() const;
    /// Detailed description of the permit.
    /// 
    /// IFC2x4 CHANGE  The attribute has been added.
    std::string LongDescription() const;
    void setLongDescription(std::string v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 6: return IfcUtil::Argument_ENUMERATION; case 7: return IfcUtil::Argument_STRING; case 8: return IfcUtil::Argument_STRING; } return IfcControl::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 6: return Type::IfcActionRequestTypeEnum; case 7: return Type::IfcLabel; case 8: return Type::IfcText; } return IfcControl::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 6: return "PredefinedType"; case 7: return "Status"; case 8: return "LongDescription"; } return IfcControl::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcActionRequest (IfcEntityInstanceData* e);
    IfcActionRequest (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, boost::optional< std::string > v6_Identification, boost::optional< IfcActionRequestTypeEnum::IfcActionRequestTypeEnum > v7_PredefinedType, boost::optional< std::string > v8_Status, boost::optional< std::string > v9_LongDescription);
    typedef IfcTemplatedEntityList< IfcActionRequest > list;
};
/// The flow controller type IfcAirTerminalBoxType defines commonly shared information for occurrences of air boxes.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a air box specification (i.e. the specific product information, that is common to all occurrences of that product type).  Air Box types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcAirTerminalBoxType are represented by instances of IfcAirTerminalBox. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcFlowControllerType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_AirTerminalBoxTypeCommon 
/// 
/// Material Use Definition 
/// The material of the IfcAirTerminalBoxType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Body': The primary material from which the object is constructed. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcAirTerminalBoxType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcAirTerminalBox for standard port definitions.
class IFC_PARSE_API IfcAirTerminalBoxType : public IfcFlowControllerType {
public:
    /// The air terminal box type.
    IfcAirTerminalBoxTypeEnum::IfcAirTerminalBoxTypeEnum PredefinedType() const;
    void setPredefinedType(IfcAirTerminalBoxTypeEnum::IfcAirTerminalBoxTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcFlowControllerType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcAirTerminalBoxTypeEnum; } return IfcFlowControllerType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcFlowControllerType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcAirTerminalBoxType (IfcEntityInstanceData* e);
    IfcAirTerminalBoxType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcAirTerminalBoxTypeEnum::IfcAirTerminalBoxTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcAirTerminalBoxType > list;
};
/// The flow terminal type IfcAirTerminalType defines commonly shared information for occurrences of air terminals.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a air terminal specification (i.e. the specific product information, that is common to all occurrences of that product type).  Air Terminal types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcAirTerminalType are represented by instances of IfcAirTerminal. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcFlowTerminalType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_AirTerminalTypeCommon 
/// 
/// Material Use Definition 
/// The material of the IfcAirTerminalType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Body': The primary material from which the object is constructed. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcAirTerminalType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcAirTerminal for standard port definitions.
class IFC_PARSE_API IfcAirTerminalType : public IfcFlowTerminalType {
public:
    IfcAirTerminalTypeEnum::IfcAirTerminalTypeEnum PredefinedType() const;
    void setPredefinedType(IfcAirTerminalTypeEnum::IfcAirTerminalTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcFlowTerminalType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcAirTerminalTypeEnum; } return IfcFlowTerminalType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcFlowTerminalType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcAirTerminalType (IfcEntityInstanceData* e);
    IfcAirTerminalType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcAirTerminalTypeEnum::IfcAirTerminalTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcAirTerminalType > list;
};
/// The energy conversion device type IfcAirToAirHeatRecoveryType defines commonly shared information for occurrences of air-to-air heat recovery devices.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a air-to-air heat recovery device specification (i.e. the specific product information, that is common to all occurrences of that product type).  Air-To-Air Heat Recovery Device types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcAirToAirHeatRecoveryType are represented by instances of IfcAirToAirHeatRecovery. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcEnergyConversionDeviceType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_AirToAirHeatRecoveryTypeCommon 
/// 
/// Material Use Definition 
/// The material of the IfcAirToAirHeatRecoveryType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Media': The primary media material used for heat transfer. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcAirToAirHeatRecoveryType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcAirToAirHeatRecovery for standard port definitions.
class IFC_PARSE_API IfcAirToAirHeatRecoveryType : public IfcEnergyConversionDeviceType {
public:
    /// Defines the type of air to air heat recovery device.
    IfcAirToAirHeatRecoveryTypeEnum::IfcAirToAirHeatRecoveryTypeEnum PredefinedType() const;
    void setPredefinedType(IfcAirToAirHeatRecoveryTypeEnum::IfcAirToAirHeatRecoveryTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcEnergyConversionDeviceType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcAirToAirHeatRecoveryTypeEnum; } return IfcEnergyConversionDeviceType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcEnergyConversionDeviceType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcAirToAirHeatRecoveryType (IfcEntityInstanceData* e);
    IfcAirToAirHeatRecoveryType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcAirToAirHeatRecoveryTypeEnum::IfcAirToAirHeatRecoveryTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcAirToAirHeatRecoveryType > list;
};
/// An asset is a uniquely identifiable grouping of elements acting as a single entity that has a financial value or that can be operated on as a single unit. 
/// 
/// An asset is generally the level of granularity at which maintenance operations are undertaken. An asset is a group that can contain one or more elements. Whilst the financial value of a component or element can be defined, financial value is also defined for accounting purposes at the level of the asset.  There are a number of actors that can be associated with an asset, each actor having a role. Actors within the scope of the project are indicated using the IfcRelAssignsToActor relationship in which case roles should be defined through the IfcActorRole class; otherwise principal actors are identified as attributes of the class. In the existence of both, direct attributes take precedence.  There are a number of costs that can be associated with an asset, each cost having a role. These are specified through the OriginalValue, CurrentValue, TotalReplacementCost and DepreciatedValue attributes.
/// 
/// HISTORY: New entity in IFC2x.  In IFC2x4, all attributes made optional and date values changed to use IfcDate.
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the IfcRelDefinesByProperties relationship. They are accessible by the IsDefinedBy inverse attribute.  Refer to the documentation at the supertype IfcGroup and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_Asset 
/// 
/// Classification Use Definition 
/// Classifications may be applied using IfcRelAssociatesClassification where RelatedObjects contains the  IfcAsset and RelatingClassification refers to an IfcClassification or IfcClassificationReference. 
/// 
/// IfcClassificationReference: The operating function of an asset within an organization may be particularly valuable in situations where one organization provides and maintains core services and another organization adds and maintains terminal services. It can classify who owns and is responsible for the asset. Operating function can be designated through the use of one or more classification references. 
/// 
/// Assignment Use Definition 
///   The IfcAsset may be assigned to the following entities using relationships as indicated: 
/// 
/// IfcActor (IfcRelAssignsToActor): Indicates the actor who owns, uses, or is responsible for the asset (as indicated by role in relationship), if such actor is within the scope of the project.   
/// IfcCostItem (IfcRelAssignsToControl): Indicates a cost item encompassing the asset. 
/// 
/// The IfcAsset may have assignments of its own using the IfcRelAssignsToGroup relationship where RelatingGroup refers to the IfcAsset and RelatedObjects contains one or more objects of the following types:  
/// IfcElement: Physical elements that comprise the asset.
class IFC_PARSE_API IfcAsset : public IfcGroup {
public:
    /// Whether the optional attribute Identification is defined for this IfcAsset
    bool hasIdentification() const;
    /// A unique identification assigned to an asset that enables its differentiation from other assets.
    /// NOTE: The asset identifier is unique within the asset register. It differs from the globally unique id assigned to the instance of an entity populating a database.
    std::string Identification() const;
    void setIdentification(std::string v);
    /// Whether the optional attribute OriginalValue is defined for this IfcAsset
    bool hasOriginalValue() const;
    /// The cost value of the asset at the time of purchase.
    IfcCostValue* OriginalValue() const;
    void setOriginalValue(IfcCostValue* v);
    /// Whether the optional attribute CurrentValue is defined for this IfcAsset
    bool hasCurrentValue() const;
    /// The current cost value of the asset.
    IfcCostValue* CurrentValue() const;
    void setCurrentValue(IfcCostValue* v);
    /// Whether the optional attribute TotalReplacementCost is defined for this IfcAsset
    bool hasTotalReplacementCost() const;
    /// The total cost of replacement of the asset.
    IfcCostValue* TotalReplacementCost() const;
    void setTotalReplacementCost(IfcCostValue* v);
    /// Whether the optional attribute Owner is defined for this IfcAsset
    bool hasOwner() const;
    /// The name of the person or organization that 'owns' the asset.
    IfcActorSelect* Owner() const;
    void setOwner(IfcActorSelect* v);
    /// Whether the optional attribute User is defined for this IfcAsset
    bool hasUser() const;
    /// The name of the person or organization that 'uses' the asset.
    IfcActorSelect* User() const;
    void setUser(IfcActorSelect* v);
    /// Whether the optional attribute ResponsiblePerson is defined for this IfcAsset
    bool hasResponsiblePerson() const;
    /// The person designated to be responsible for the asset.
    /// NOTE: In some regulations (for example, UK Health and Safety at Work Act, Electricity at Work Regulations), management of assets must have a person identified as being responsible and to whom regulatory, insurance and other organizations communicate. In places where there is not a legal requirement, the responsible person would be the asset manager but would not have a legal status.
    IfcPerson* ResponsiblePerson() const;
    void setResponsiblePerson(IfcPerson* v);
    /// Whether the optional attribute IncorporationDate is defined for this IfcAsset
    bool hasIncorporationDate() const;
    /// The date on which an asset was incorporated into the works, installed, constructed, erected or completed.
    /// NOTE: This is the date on which an asset is considered to start depreciating.
    /// 
    /// IFC2x4 CHANGE Type changed from IfcDateTimeSelect.
    std::string IncorporationDate() const;
    void setIncorporationDate(std::string v);
    /// Whether the optional attribute DepreciatedValue is defined for this IfcAsset
    bool hasDepreciatedValue() const;
    /// The current value of an asset within the accounting rules and procedures of an organization.
    IfcCostValue* DepreciatedValue() const;
    void setDepreciatedValue(IfcCostValue* v);
    virtual unsigned int getArgumentCount() const { return 14; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 5: return IfcUtil::Argument_STRING; case 6: return IfcUtil::Argument_ENTITY_INSTANCE; case 7: return IfcUtil::Argument_ENTITY_INSTANCE; case 8: return IfcUtil::Argument_ENTITY_INSTANCE; case 9: return IfcUtil::Argument_ENTITY_INSTANCE; case 10: return IfcUtil::Argument_ENTITY_INSTANCE; case 11: return IfcUtil::Argument_ENTITY_INSTANCE; case 12: return IfcUtil::Argument_STRING; case 13: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcGroup::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 5: return Type::IfcIdentifier; case 6: return Type::IfcCostValue; case 7: return Type::IfcCostValue; case 8: return Type::IfcCostValue; case 9: return Type::IfcActorSelect; case 10: return Type::IfcActorSelect; case 11: return Type::IfcPerson; case 12: return Type::IfcDate; case 13: return Type::IfcCostValue; } return IfcGroup::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 5: return "Identification"; case 6: return "OriginalValue"; case 7: return "CurrentValue"; case 8: return "TotalReplacementCost"; case 9: return "Owner"; case 10: return "User"; case 11: return "ResponsiblePerson"; case 12: return "IncorporationDate"; case 13: return "DepreciatedValue"; } return IfcGroup::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcAsset (IfcEntityInstanceData* e);
    IfcAsset (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, boost::optional< std::string > v6_Identification, IfcCostValue* v7_OriginalValue, IfcCostValue* v8_CurrentValue, IfcCostValue* v9_TotalReplacementCost, IfcActorSelect* v10_Owner, IfcActorSelect* v11_User, IfcPerson* v12_ResponsiblePerson, boost::optional< std::string > v13_IncorporationDate, IfcCostValue* v14_DepreciatedValue);
    typedef IfcTemplatedEntityList< IfcAsset > list;
};
/// The flow terminal type IfcAudioVisualApplianceType defines commonly shared information for occurrences of audio-visual appliances.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a audio-visual appliance specification (i.e. the specific product information, that is common to all occurrences of that product type).  Audio-Visual Appliance types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcAudioVisualApplianceType are represented by instances of IfcAudioVisualAppliance. 
/// 
/// HISTORY: New entity in IFC2x4 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcFlowTerminalType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_AudioVisualApplianceTypeCommon 
/// Pset_ElectricalDeviceCommon 
/// 
/// The following property set definitions are applicable to this entity according to the PredefinedType attribute:  
/// Pset_AudioVisualApplianceTypeAmplifier (AMPLIFIER) 
/// Pset_AudioVisualApplianceTypeCamera (CAMERA) 
/// Pset_AudioVisualApplianceTypeDisplay (DISPLAY) 
/// Pset_AudioVisualApplianceTypePlayer (PLAYER) 
/// Pset_AudioVisualApplianceTypeProjector (PROJECTOR) 
/// Pset_AudioVisualApplianceTypeReceiver (RECEIVER) 
/// Pset_AudioVisualApplianceTypeSpeaker (SPEAKER) 
/// Pset_AudioVisualApplianceTypeTuner (TUNER) 
/// 
/// Material Use Definition 
/// The material of the IfcAudioVisualApplianceType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Casing': Material from which the casing is constructed. 
/// 
/// Composition Use Definition 
/// The IfcAudioVisualApplianceType may be aggregated into components using IfcRelAggregates where RelatingObject refers to the enclosing IfcAudioVisualApplianceType and RelatedObjects contains one or more components.  Components are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Aggregation use is defined for the following predefined types:
/// 
/// (All Types): May contain IfcAudioVisualAppliance components.   
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcAudioVisualApplianceType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcAudioVisualAppliance for standard port definitions.
class IFC_PARSE_API IfcAudioVisualApplianceType : public IfcFlowTerminalType {
public:
    /// Identifies the predefined types of audio-visual appliance from which the type required may be set.
    IfcAudioVisualApplianceTypeEnum::IfcAudioVisualApplianceTypeEnum PredefinedType() const;
    void setPredefinedType(IfcAudioVisualApplianceTypeEnum::IfcAudioVisualApplianceTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcFlowTerminalType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcAudioVisualApplianceTypeEnum; } return IfcFlowTerminalType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcFlowTerminalType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcAudioVisualApplianceType (IfcEntityInstanceData* e);
    IfcAudioVisualApplianceType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcAudioVisualApplianceTypeEnum::IfcAudioVisualApplianceTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcAudioVisualApplianceType > list;
};
/// Definition from ISO/CD 10303-42:1992: A B-spline curve is a piecewise parametric polynomial or rational curve described in terms of control points and basis functions. The B-spline curve has been selected as the most stable format to represent all types of polynomial or rational parametric curves. With appropriate attribute values it is capable of representing single span or spline curves of explicit polynomial, rational, Bezier or B-spline type. 
/// 
/// Interpretation of the data is as follows: 
/// 
/// All weights shall be positive and the curve is given by 
/// 
/// k+1 
///   = number of control points 
/// 
/// Pi 
///   = control points 
/// 
/// wi 
///   = weights 
/// 
/// d 
///   = degree 
/// 
/// The knot array is an array of (k+d+2) real numbers
///   [u-d ... uk+1], such that for
///   all indices j in [-d,k], uj <=
///   uj+1. This array is obtained from the knot data list by
///   repeating each multiple knot according to the multiplicity. N
///   di, the ith normalized B-spline basis function
///   of degree d, is defined on the subset [ui-d, ... ,
///   ui+1] of this array. 
/// 
/// Let L denote the number of distinct values among the
///   d+k+2 knots in the knot array; L will be referred to as
///   the 'upper index on knots'. Let mj denote the multiplicity
///   (number of repetitions) of the jth distinct knot. Then
/// 
/// All knot multiplicities except the first and the last shall be in
///   the range 1 ... degree; the first and last may have a maximum value of degree +
///   1. In evaluating the basis functions, a knot u of e.g. multiplicity 3 is
///   interpreted as a string u, u, u, in the knot array. The B-spline curve
///   has 3 special subtypes (Note: only 1, Bezier curve, included in this IFC
///   release) where the knots and knot multiplicities are derived to provide
///   simple default capabilities. 
///   Logical flag is provided to indicate whether the curve self
///   intersects or not. 
/// 
/// Figure 277 (from ISO 10303-42) illustrates a B-spline curve.
/// 
/// Figure 277 — B-spline curve
/// 
/// NOTE  Corresponding ISO 10303 entity: b_spline_curve. Please refer to ISO/IS 10303-42:1994, p. 45 for the final definition of the formal standard.
/// 
/// HISTORY  New entity in Release IFC2x2.
class IFC_PARSE_API IfcBSplineCurve : public IfcBoundedCurve {
public:
    /// The algebraic degree of the basis functions.
    int Degree() const;
    void setDegree(int v);
    /// The list of control points for the curve.
    IfcTemplatedEntityList< IfcCartesianPoint >::ptr ControlPointsList() const;
    void setControlPointsList(IfcTemplatedEntityList< IfcCartesianPoint >::ptr v);
    /// Used to identify particular types of curve; it is for information only.
    IfcBSplineCurveForm::IfcBSplineCurveForm CurveForm() const;
    void setCurveForm(IfcBSplineCurveForm::IfcBSplineCurveForm v);
    /// Indication of whether the curve is closed; it is for information only.
    bool ClosedCurve() const;
    void setClosedCurve(bool v);
    /// Indication whether the curve self-intersects or not; it is for information only.
    bool SelfIntersect() const;
    void setSelfIntersect(bool v);
    virtual unsigned int getArgumentCount() const { return 5; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 0: return IfcUtil::Argument_INT; case 1: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 2: return IfcUtil::Argument_ENUMERATION; case 3: return IfcUtil::Argument_BOOL; case 4: return IfcUtil::Argument_BOOL; } return IfcBoundedCurve::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 0: return Type::IfcInteger; case 1: return Type::IfcCartesianPoint; case 2: return Type::IfcBSplineCurveForm; case 3: return Type::IfcLogical; case 4: return Type::IfcLogical; } return IfcBoundedCurve::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 0: return "Degree"; case 1: return "ControlPointsList"; case 2: return "CurveForm"; case 3: return "ClosedCurve"; case 4: return "SelfIntersect"; } return IfcBoundedCurve::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcBSplineCurve (IfcEntityInstanceData* e);
    IfcBSplineCurve (int v1_Degree, IfcTemplatedEntityList< IfcCartesianPoint >::ptr v2_ControlPointsList, IfcBSplineCurveForm::IfcBSplineCurveForm v3_CurveForm, bool v4_ClosedCurve, bool v5_SelfIntersect);
    typedef IfcTemplatedEntityList< IfcBSplineCurve > list;
};
/// Definition from ISO 10303:42:1994: This is the type of b-spline curve for which the knot values are explicitly given. This subtype shall be used to represent non-uniform B-spline curves and may be used for other knot types.
/// 
/// Let L denote the number of distinct values amongst the
/// d+k+2 knots in the knot list; L will be
/// referred to as the ‘upper index on knots’. Let
/// mj denote the multiplicity (i.e., number of
/// repetitions) of the jth distinct knot. Then:
/// 
/// All knot multiplicities except the first and the last shall be
/// in the range 1,...,d; the first and last may have a
/// maximum value of d + 1. In evaluating the basis functions,
/// a knot u of, e.g., multiplicity 3 is interpreted as a
/// sequence u, u, u,; in the knot array.
/// 
/// NOTE Corresponding ISO 10303 entity: b_spline_curve_with_knots. Please refer to ISO/IS 10303-42:1994, p. 46 for the final definition of the formal standard.
/// 
/// HISTORY New entity in IFC2x4.
class IFC_PARSE_API IfcBSplineCurveWithKnots : public IfcBSplineCurve {
public:
    /// The multiplicities of the knots. This list defines the number of times each knot in the knots list is to be repeated in constructing the knot array.
    std::vector< int > /*[2:?]*/ KnotMultiplicities() const;
    void setKnotMultiplicities(std::vector< int > /*[2:?]*/ v);
    /// The list of distinct knots used to define the B-spline basis functions.
    std::vector< double > /*[2:?]*/ Knots() const;
    void setKnots(std::vector< double > /*[2:?]*/ v);
    /// The description of the knot type. This is for information only.
    IfcKnotType::IfcKnotType KnotSpec() const;
    void setKnotSpec(IfcKnotType::IfcKnotType v);
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 5: return IfcUtil::Argument_AGGREGATE_OF_INT; case 6: return IfcUtil::Argument_AGGREGATE_OF_DOUBLE; case 7: return IfcUtil::Argument_ENUMERATION; } return IfcBSplineCurve::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 5: return Type::IfcInteger; case 6: return Type::IfcParameterValue; case 7: return Type::IfcKnotType; } return IfcBSplineCurve::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 5: return "KnotMultiplicities"; case 6: return "Knots"; case 7: return "KnotSpec"; } return IfcBSplineCurve::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcBSplineCurveWithKnots (IfcEntityInstanceData* e);
    IfcBSplineCurveWithKnots (int v1_Degree, IfcTemplatedEntityList< IfcCartesianPoint >::ptr v2_ControlPointsList, IfcBSplineCurveForm::IfcBSplineCurveForm v3_CurveForm, bool v4_ClosedCurve, bool v5_SelfIntersect, std::vector< int > /*[2:?]*/ v6_KnotMultiplicities, std::vector< double > /*[2:?]*/ v7_Knots, IfcKnotType::IfcKnotType v8_KnotSpec);
    typedef IfcTemplatedEntityList< IfcBSplineCurveWithKnots > list;
};
/// Definition from IAI: The element type
/// IfcBeamType defines commonly shared information for
/// occurrences of beams. The set of shared information may
/// include:
/// 
/// common properties within shared property sets
/// common material information
/// common profile definitions
/// common shape representations
/// 
/// It is used to define a beam specification, or beam style (i.e.
/// the specific product information that is common to all
/// occurrences of that beam type). Beam types may be exchanged
/// without being already assigned to occurrences.
/// Occurrences of the IfcBeamType within building models
/// are represented by instances of IfcBeamStandardCase if the
/// IfcBeamType has a single associated
/// IfcMaterialProfileSet; otherwise they are represented by
/// instances of IfcBeam. Occurrences of the
/// IfcBeamType within structural analysis models are
/// represented by instances of IfcStructuralCurveMember, or
/// its applicable subtypes.
/// HISTORY New entity in
/// Release IFC2x Edition 2.
/// Material Use Definition
/// The material of the IfcBeamType is defined by the
/// IfcMaterialProfileSet or as fall back by
/// IfcMaterial and attached by the
/// IfcRelAssociatesMaterial.RelatingMaterial. It is
/// accessible by the inverse HasAssociations
/// relationship.
/// Note: It is illegal to assign an
/// IfcMaterial to an IfcBeamType, if there is at least
/// one occurrences. of IfcBeamStandardCase for this
/// type.
/// Property Set Use Definition:
/// The shared property sets relating to the IfcBeamType
/// are defined by the IfcPropertySet and are attached by the
/// HasPropertySets attribute. The following property set
/// definitions specific to the IfcBeamType are part of this
/// IFC release:
/// NOTE There is no differentiation between
/// properties within the property set that are only assignable to
/// IfcBeamType and those that are only assignable to
/// IfcBeam. If the same property is assigned to the
/// IfcBeamType and the IfcBeam being an occurrence of
/// the IfcBeamType, then the occurrence property overrides
/// the type property.
/// 
/// Pset_BeamCommon: common property set for all
/// beam types.
/// 
/// Profile Use Definition:
/// The shared profile definition is defined by assigning an
/// IfcMaterialProfileSet (see material use definition above).
/// The IfcMaterialProfile refers to the subtype of
/// IfcProfileDef that is the common profile for all beam
/// occurrence, if used. It is only applicable if the
/// IfcBeamType has only occurrences of type
/// IfcBeamStandardCase (see definition of
/// IfcBeamStandardCase for further information).
/// NOTE The attribute ProfileName of the
/// IfcProfileDef subtype, referenced in
/// IfcMaterialProfile should contain a standardized profile
/// name according to local standards. However, an additional
/// geometric representation of the profile is necessary (e.g. as
/// IfcExtrudedAreaSolid). An importing application is allowed
/// to check for the existence of the profile name: in case of
/// identifying it as a standardized name, the corresponding profile
/// geometry and possibly other cross sectional properties can be
/// read from a library. Otherwise the geometric representation and
/// possible non geometric IfcProfileProperties have to be
/// used.
/// Geometry Use Definition:
/// The IfcBeamType may define the shared geometric
/// representation for all beam occurrences. The
/// RepresentationMaps attribute refers to a list of
/// IfcRepresentationMap's, that allow for multiple geometric
/// representations (e.g. with IfcShaperepresentation's having
/// an RepresentationIdentifier 'Box', 'Axis', or 'Body'). It
/// is only applicable if the IfcBeamType has only occurrences
/// of type IfcBeam (See geometric use definition of
/// IfcBeam for further information).
/// NOTE If the IfcBeamType has an
/// associated IfcMaterialProfileSet, then no shared geometric
/// representation shall be provided.
/// NOTE The product shape representations are
/// defined as RepresentationMaps (attribute of the supertype
/// IfcTypeProduct), which get assigned by an element
/// occurrence instance through the
/// IfcShapeRepresentation.Item[n] being an
/// IfcMappedItem. See IfcTypeProduct for further
/// information.
/// NOTE The values of attributes
/// RepresentationIdentifier and RepresentationType of
/// IfcShapeRepresentation are restricted in the same way as
/// those for IfcBeam and
/// IfcBeamStandardCase
class IFC_PARSE_API IfcBeamType : public IfcBuildingElementType {
public:
    /// Identifies the predefined types of a beam element from which the type required may be set.
    IfcBeamTypeEnum::IfcBeamTypeEnum PredefinedType() const;
    void setPredefinedType(IfcBeamTypeEnum::IfcBeamTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcBuildingElementType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcBeamTypeEnum; } return IfcBuildingElementType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcBuildingElementType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcBeamType (IfcEntityInstanceData* e);
    IfcBeamType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcBeamTypeEnum::IfcBeamTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcBeamType > list;
};
/// The energy conversion device type IfcBoilerType defines commonly shared information for occurrences of boilers.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a boiler specification (i.e. the specific product information, that is common to all occurrences of that product type).  Boiler types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcBoilerType are represented by instances of IfcBoiler. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcEnergyConversionDeviceType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_BoilerTypeCommon 
/// 
/// The following property set definitions are applicable to this entity according to the PredefinedType attribute:  
/// Pset_BoilerTypeSteam (STEAM) 
/// 
/// Material Use Definition 
/// The material of the IfcBoilerType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Body': The primary material from which the object is constructed. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcBoilerType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcBoiler for standard port definitions.
class IFC_PARSE_API IfcBoilerType : public IfcEnergyConversionDeviceType {
public:
    /// Defines types of boilers.
    IfcBoilerTypeEnum::IfcBoilerTypeEnum PredefinedType() const;
    void setPredefinedType(IfcBoilerTypeEnum::IfcBoilerTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcEnergyConversionDeviceType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcBoilerTypeEnum; } return IfcEnergyConversionDeviceType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcEnergyConversionDeviceType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcBoilerType (IfcEntityInstanceData* e);
    IfcBoilerType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcBoilerTypeEnum::IfcBoilerTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcBoilerType > list;
};
/// Definition from ISO/CD 10303-42:1992ÿ A boundary curve
/// is a type of bounded curve suitable for the definition of a
/// surface boundary.
/// 
/// NOTEÿ Corresponding ISO 10303 entity: boundary_curve. Please refer to ISO/IS 10303-42:1994, p.89 for the final definition of the formal standard.
/// 
/// HISTORYÿ New entity in IFC2x4.
class IFC_PARSE_API IfcBoundaryCurve : public IfcCompositeCurveOnSurface {
public:
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcCompositeCurveOnSurface::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcCompositeCurveOnSurface::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcCompositeCurveOnSurface::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcBoundaryCurve (IfcEntityInstanceData* e);
    IfcBoundaryCurve (IfcTemplatedEntityList< IfcCompositeCurveSegment >::ptr v1_Segments, bool v2_SelfIntersect);
    typedef IfcTemplatedEntityList< IfcBoundaryCurve > list;
};
/// Definition from ISO 6707-1:1989: Major functional part
/// of a building, examples are foundation, floor, roof, wall.
/// The building element comprises all
/// elements that are primarily part of the construction of a
/// building, i.e., its structural and space separating system.
/// EXAMPLEs of building elements are walls,
/// beams, or doors, they are all physically existent and tangible
/// things.
/// The IfcBuildingElement utilizes the following
/// capabilities mainly through inverse attributes referencing
/// objectified relationships:
/// NOTE View definitions and implementer
/// agreements will determine those relationships that have to be
/// supported in actual exchange.
/// 
/// Grouping - being part of a logical group of objects
/// 
/// objectified relationship: IfcRelAssignsToGroup
/// object referenced by relationship: IfcGroup (and
/// subtypes)
/// inverse attribute: HasAssignment
/// 
/// Work processes - reference to work tasks, in which this
/// building element is used
/// 
/// objectified relationship: IfcRelAssignsToProcess
/// object referenced by relationship: IfcProcess (and
/// subtypes)
/// inverse attribute: HasAssignments
/// 
/// Structural member reference - information whether the
/// building element is represented in a structural analysis model by
/// a structural member
/// 
/// objectified relationship: IfcRelAssignsToProduct
/// object referenced by relationship: IfcStructuralMember
/// (and by default IfcStructuralCurveMember)
/// inverse attribute: HasAssignments
/// 
/// Aggregation - aggregated together with other elements to form
/// an aggregate
/// 
/// objectified relationship: IfcRelAggregates
/// object referenced by relationship: IfcElement (and
/// subtypes)
/// inverse attribute (for container): IsDecomposedBy
/// inverse attribute (for contained parts):
/// Decomposes
/// 
/// Material - assignment of material used by this building
/// element
/// 
/// objectified relationship:
/// IfcRelAssociatesMaterial
/// object referenced by relationship: IfcMaterialSelect
/// (and selected items)
/// inverse attribute: HasAssociations
/// 
/// Classification - assigned reference to an external
/// classification
/// 
/// objectified relationship:
/// IfcRelAssociatesClassification
/// object referenced by relationship:
/// IfcClassificationNotationSelect (and selected items,
/// default IfcClassificationReference)
/// inverse attribute: HasAssociations
/// 
/// Library - assigned reference to an external library item
/// reference
/// 
/// objectified relationship:
/// IfcRelAssociatesClassification
/// object referenced by relationship: IfcLibrarySelect
/// (and selected items, default IfcLibraryReference)
/// inverse attribute: HasAssociations
/// 
/// Documentation - assigned reference to an external
/// documentation
/// 
/// objectified relationship:
/// IfcRelAssociatesDocumentation
/// object referenced by relationship: IfcDocumentSelect
/// (and selected items, default IfcDocumentReference)
/// inverse attribute: HasAssociations
/// 
/// Type - reference to the common product type information for
/// the element occurrence
/// 
/// objectified relationship: IfcRelDefinesByType
/// object referenced by relationship:
/// IfcBuildingElementType (and subtypes)
/// inverse attribute: IsTypedBy
/// 
/// Properties - reference to all attached properties, including
/// quantities
/// 
/// objectified relationship:
/// IfcRelDefinesByProperties
/// object referenced by relationship:
/// IfcPropertySetDefinition (default
/// IfcPropertySet)
/// inverse attribute: IsDefinedBy
/// 
/// Connection - connectivity to other elements, including the
/// definition of the joint
/// 
/// objectified relationship: IfcRelConnectsElements
/// object referenced by relationship: IfcElement
/// inverse attribute: ConnectedTo
/// inverse attribute: ConnectedFrom
/// 
/// Realization - information, whether the building element is
/// used to realize a connection (e.g. as a weld in a connection
/// between two members)
/// 
/// objectified relationship:
/// IfcRelConnectsWithRealizingElements
/// object referenced by relationship: IfcElement
/// inverse attribute: IsConnectionRealization
/// 
/// Assignment to spatial structure - hierarchical assignment to
/// the right level within the spatial structure
/// 
/// objectified relationship:
/// IfcRelContainedInSpatialStructure
/// object referenced by relationship:
/// IfcSpatialStructureElement
/// inverse attribute: ContainedInStructure
/// 
/// Reference to spatial structure(s) - non hierarchical
/// reference to one or more elements within the spatial structure
/// (e.g. a curtain wall, being contained in the building, references
/// several stories)
/// 
/// objectified relationship:
/// IfcRelContainedInSpatialStructure
/// object referenced by relationship:
/// IfcSpatialElement
/// inverse attribute: ContainedInStructure
/// 
/// Boundary - provision of space boundaries by this building
/// element
/// 
/// objectified relationship: IfcRelSpaceBoundary
/// object referenced by relationship: IfcSpace
/// inverse attribute: ProvidesBoundaries
/// 
/// Coverings - assignment of covering elements to this building
/// element (note: normally covering elements are assigned to the
/// space, only used for special cases)
/// 
/// objectified relationship:
/// IfcRelCoversBldgElements
/// object referenced by relationship: IfcCovering
/// inverse attribute: HasCoverings
/// 
/// Voids - information, whether the building element includes
/// openings, recesses or other voids
/// 
/// objectified relationship: IfcRelVoidsElement
/// object referenced by relationship:
/// IfcFeatureElementSubtraction (default
/// IfcOpeningElement)
/// inverse attribute: HasOpenings
/// 
/// Projection - information, whether the building element has
/// projections (such as a fascia)
/// 
/// objectified relationship: IfcRelProjectsElement
/// object referenced by relationship:
/// IfcFeatureElementAddition (default
/// IfcProjectionElement)
/// inverse attribute: HasProjections
/// 
/// Filling - information whether the building element is used to
/// fill openings
/// 
/// objectified relationship: IfcRelFillsElement
/// object referenced by relationship:
/// IfcOpeningElement
/// inverse attribute: FillsVoids
/// 
/// HISTORY New entity in IFC Release 1.0
/// 
/// Property Set Use Definition
/// The properties relating to the IfcBuildingElement are
/// defined by the IfcPropertySet and attached by the
/// IfcRelDefinesByProperties. A detailed specification for
/// individual property sets applicable is introduced at the level of
/// subtypes of IfcBuildingElement.
/// NOTE The applicable property sets are provided
/// by an xml property set definition that includes multilingual
/// translations for each property. The xml definition file format,
/// psdXML, can be used to automatically configure the properties for
/// each building element.
/// Quantity Use Definition:
/// The quantities relating to the IfcBuildingElement are
/// defined by the IfcElementQuantity and attached by the
/// IfcRelDefinesByProperties. A detailed specification for
/// individual quantities is introduced at the level of subtypes of
/// IfcBuildingElement.
/// NOTE The applicable element quantities are
/// provided by an xml quantity definition that includes multilingual
/// translations for each quantity. The xml definition file format,
/// qdXML, can be used to automatically configure the quantities for
/// each building element.
/// 
/// Geometry Use Definitions
/// The geometric representation of any IfcBuildingElement
/// is given by the IfcProductDefinitionShape and
/// IfcLocalPlacement allowing multiple geometric
/// representations.
/// Local Placement
/// The local placement for any IfcBuildingElement is
/// defined in its supertype IfcProduct. It is defined by the
/// IfcLocalPlacement, which defines the local coordinate
/// system that is referenced by all geometric representations.
/// Further constraints are defined at the level of its subtypes.
/// Geometric Representations
/// An IfcBuildingElement can be represented by one or
/// several geometric representations. The following representation
/// identifiers are used for building elements 'Box', 'Axis',
/// 'FootPrint', 'Surface', and 'Body'. A detailed specification is
/// introduced at the level of subtypes.
/// NOTE Some subtypes of
/// IfcBuildingElement may exclude one or several geometric
/// representation types, e.g. standard case elements, such as
/// IfcWallStandardCase, do not allow the use of
/// 'SurfaceModel', 'Brep', 'AdvancedBrep', and
/// 'MappedRepresentation'. In addition view definitions and
/// implementer agreements may restrict the use of geometric
/// representation types, e.g. the use of
/// 'AdvancedBrep'.
/// Box Representation
/// Any IfcBuildingElement may be represented as a bounding
/// box, which shows the maximum extend of the body within the
/// coordinated system established by the IfcLocalPlacement.
/// The bounding box representation is the simplest geometric
/// representation available. The following attribute values for the
/// IfcShapeRepresentation holding this geometric
/// representation shall be used:
/// 
/// RepresentationIdentifier : 'Box'
/// RepresentationType : 'BoundingBox'
/// 
/// As shown in Figure 22, the bounding box representation is given by an
/// IfcShapeRepresentation that includes a single item, an
/// IfcBoundingBox.
/// 
/// Figure 22 — Building element box representation
/// 
/// Axis Representation
/// Some IfcBuildingElement may be represented by an axis
/// as an abstract geometric representation. See each subtype for
/// specific guidance. The following attribute values for the
/// IfcShapeRepresentation holding this geometric
/// representation are used:
/// 
/// RepresentationIdentifier : 'Axis'
/// RepresentationType : 'Curve2D', 'Curve3D'
/// 
/// Surface Representation
/// Some IfcBuildingElement may be represented by an
/// surface as an abstract geometric representation. See each subtype
/// for specific guidance. The following attribute values for the
/// IfcShapeRepresentation holding this geometric
/// representation are used:
/// 
/// RepresentationIdentifier : 'Surface'
/// RepresentationType : 'Surface2D', 'Surface3D'
/// 
/// FootPrint Representation
/// Any IfcBuildingElement may be represented by a
/// footprint as a specific floor plan geometric representation. See
/// each subtype for specific guidance. The following attribute
/// values for the IfcShapeRepresentation holding this
/// geometric representation are used:
/// 
/// RepresentationIdentifier : 'FootPrint'
/// RepresentationType : 'GeometricCurveSet',
/// 'Annotation2D'
/// 
/// Body Representation
/// The body representation of any IfcBuildingElement can
/// have the following representation types: 'SurfaceModel', 'Brep',
/// 'AdvancedBrep', and 'MappedRepresentation'. Other representation
/// types might be specified at the level of subtypes.
/// SurfaceModel Representation Type
/// Any IfcBuildingElement (so far no further constraints
/// are defined at the level of its subtypes) may be represented as a
/// single or multiple surface models, based on either shell or face
/// based models. The following attribute values for the
/// IfcShapeRepresentation holding this geometric
/// representation shall be used:
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'SurfaceModel'
/// 
/// In some cases it may be useful to also expose a simple
/// representation as a bounding box representation of the same
/// complex shape.
/// 
/// As shown in Figure 23, the surface model representation is given by an IfcShapeRepresentation, which includes a single item which is either:
/// 
/// IfcShellBasedSurfaceModel, or
/// IfcFaceBasedSurfaceModel.
/// 
/// Figure 23 — Building element surface model representation
/// 
/// Brep Representation Type
/// Any IfcBuildingElement (so far no further constraints
/// are defined at the level of its subtypes) may be represented as a
/// single or multiple Boundary Representation elements (which are
/// restricted to faceted Brep with or without voids). The Brep
/// representation allows for the representation of complex element
/// shape. The following attribute values for the
/// IfcShapeRepresentation holding this geometric
/// representation shall be used:
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'Brep'
/// 
/// In some cases it may be useful to also expose a simple
/// representation as a bounding box representation of the same
/// complex shape.
/// As shown in Figure 24, the Brep representation is given by an IfcShapeRepresentation, which includes one or more items, all of type IfcFacetedBrep.
/// 
/// Figure 24 — Building element body boundary representation
/// 
/// AdvancedBrep Representation Type
/// An IfcBuildingElement (so far no further constraints
/// are defined at the level of its subtypes or by view definitions)
/// may be represented as a single or multiple Boundary
/// Representation elements (which are based on advanced surfaces,
/// usually refered to as NURBS surfaces). The AdvancedBrep
/// representation allows for the representation of complex free-form
/// element shape. The following attribute values for the
/// IfcShapeRepresentation holding this geometric
/// representation shall be used:
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'AdvancedBrep'
/// 
/// In some cases it may be useful to also expose a simple
/// representation as a bounding box representation of the same
/// complex shape.
/// MappedRepresentation Representation Type
/// Any IfcBuildingElement (so far no further constraints
/// are defined at the level of its subtypes) may be represented
/// using the MappedRepresentation. This shall be supported as it
/// allows for reusing the geometry definition of a type at all
/// occurrences of the same type. The following attribute values for
/// the IfcShapeRepresentation holding this geometric
/// representation shall be used:
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'MappedRepresentation'
/// 
/// The same constraints, as given for 'SurfaceModel', 'Brep', and
/// 'AdvancedBrep' geometric representation, shall apply to the
/// MappedRepresentation of the
/// IfcRepresentationMap.
class IFC_PARSE_API IfcBuildingElement : public IfcElement {
public:
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcBuildingElement (IfcEntityInstanceData* e);
    IfcBuildingElement (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag);
    typedef IfcTemplatedEntityList< IfcBuildingElement > list;
};
/// Definition from IAI: Layers or major components as subordinate
/// parts of a building element. Typical usage examples include precast concrete
/// sandwich walls, where the layers may have different geometry representations.
/// In this case the layered material representation does not sufficiently describe
/// the element. Each layer is represented by an own instance of the
/// IfcBuildingElementPart with its own geometry description.
/// 
/// The kind of building element part is further specified by a
/// corresponding instance of IfcBuildingElementPartType,
/// referred to by IfcRelDefinesByType.
/// 
/// HISTORY New entity in IFC Release 2x2
/// 
/// IFC 2x4 change:
/// Moved from from IfcStructuralElementsDomain schema to
/// IfcSharedComponentElements schema, compatible change of supertype,
/// attribute PredefinedType added.
class IFC_PARSE_API IfcBuildingElementPart : public IfcElementComponent {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcBuildingElementPart
    bool hasPredefinedType() const;
    /// Subtype of building element part
    IfcBuildingElementPartTypeEnum::IfcBuildingElementPartTypeEnum PredefinedType() const;
    void setPredefinedType(IfcBuildingElementPartTypeEnum::IfcBuildingElementPartTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcElementComponent::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcBuildingElementPartTypeEnum; } return IfcElementComponent::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "PredefinedType"; } return IfcElementComponent::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcBuildingElementPart (IfcEntityInstanceData* e);
    IfcBuildingElementPart (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcBuildingElementPartTypeEnum::IfcBuildingElementPartTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcBuildingElementPart > list;
};
/// Definition from IAI: The building element part type defines
/// lists of commonly shared property set definitions and representation maps of parts of a building element.
/// 
/// HISTORY New entity in IFC Release 2x4
class IFC_PARSE_API IfcBuildingElementPartType : public IfcElementComponentType {
public:
    /// Subtype of building element part
    IfcBuildingElementPartTypeEnum::IfcBuildingElementPartTypeEnum PredefinedType() const;
    void setPredefinedType(IfcBuildingElementPartTypeEnum::IfcBuildingElementPartTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcElementComponentType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcBuildingElementPartTypeEnum; } return IfcElementComponentType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcElementComponentType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcBuildingElementPartType (IfcEntityInstanceData* e);
    IfcBuildingElementPartType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcBuildingElementPartTypeEnum::IfcBuildingElementPartTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcBuildingElementPartType > list;
};
/// Definition from IAI: The IfcBuildingElementProxy
/// is a proxy definition that provides the same functionality as an
/// IfcBuildingElement, but without having a predefined meaning
/// of the special type of building element, it represents. Proxies can
/// also be used as spatial place holders or provisions, that maybe
/// later replaced by special types of elements.
/// One use of the proxy object is a provision for voids, i.e. where
/// a particular volume of space is requested by some engineering
/// function that might later be accepted or rejected and if accepted
/// potentially transformed into a void within a building element, like
/// a wall opening, or a slab opening. The provision for voids is
/// exchanged as an IfcBuildingElementProxy with the
/// PredefinedType = ProvisionForVoid.
/// Other usages of IfcBuildingElementProxy include:
/// 
/// The IfcBuildingElementProxy can be used to exchange
/// special types of building elements for which the current IFC
/// Release does not yet provide a semantic definition.
/// The IfcBuildingElementProxy can also be used to
/// represent building elements for which the participating
/// applications can not provide additional semantic
/// classification.
/// 
/// HISTORY  New entity
/// in IFC Release 2x.
/// IFC2x4 CHANGE  The attribute
/// CompositionType has been replaced by PredefinedType,
/// being a superset of the enumerators.
/// Type Use Definition
/// The IfcBuildingElementProxy defines the occuurence of any
/// building element, common information about the types (or styles) is
/// handled by IfcBuildingElementProxyType.
/// The IfcBuildingElementProxyType (if present) may
/// establish the common type name, usage (or predefined) type, common
/// material, common set of properties and common shape representations
/// (using IfcRepresentationMap). The
/// IfcBuildingElementProxyType is attached using the
/// IfcRelDefinedByType.RelatingType objectified relationship
/// and is accessible by the inverse IsTypedBy attribute.
/// 
/// NOTE The IfcBuildingElementProxyType can be used
/// to share common information among many occurrences of the same
/// proxy without establishing a particular semantic meaning of the
/// type.
/// 
/// If no IfcBuildingElementProxyType is attached (i.e. if
/// only occurrence information is given) the PredefinedType
/// should be provided. If set to .USERDEFINED. a user defined value
/// can be provided by the ObjectType attribute.
/// Material Use Definition
/// The material of the IfcBuildingElementProxy is defined by
/// IfcMaterial and attached by the
/// IfcRelAssociatesMaterial.RelatingMaterial. It is
/// accessible by the inverse HasAssociations relationship.
/// Note It is illegal to assign an
/// IfcMaterial to an IfcBuildingElementProxy with the
/// PredefinedType = ProvisionForVoid.
/// Material information can also be given at the
/// IfcBuildingElementProxyType, defining the common attribute
/// data for all occurrences of the same type. It is then
/// accessible by the inverse IsTypedBy relationship pointing to
/// IfcBuildingElementProxyType.HasAssociations and via
/// IfcRelAssociatesMaterial.RelatingMaterial to
/// IfcMaterial. If both are given, then the material directly
/// assigned to IfcBuildingElementProxy overrides the material
/// assigned to IfcBuildingElementProxyType.
/// Property Set Use Definition:
/// The property sets relating to the IfcBuildingElementProxy
/// are defined by the IfcPropertySet and attached by the
/// IfcRelDefinesByProperties relationship. It is accessible by
/// the inverse IsDefinedBy relationship. The following property
/// set definitions specific to the IfcBuildingElementProxy are
/// part of this IFC release:
/// 
/// Pset_BuildingElementProxyCommon: common
/// property set for all occurrences of building element proxies.
/// Pset_BuildingElementProxyProvisionForVoid:
/// specific property set for all occurrences of building element proxy
/// with the PredefinedType: PROVISIONFORVOID.
/// 
/// Property sets can also be given at the
/// IfcBuildingElementProxyType, defining the common property
/// data for all occurrences of the same type. It is then
/// accessible by the inverse IsTypedBy relationship pointing to
/// IfcBuildingElementProxyType.HasPropertySets. If both are
/// given, then the properties directly assigned to
/// IfcBuildingElementProxy overrides the properties assigned to
/// IfcBuildingElementProxyType.
/// Containment Use Definition
/// The IfcBuildingElementProxy, as any subtype of
/// IfcBuildingElement, may participate in two different
/// containment relationships. The first (and in most implementation
/// scenarios mandatory) relationship is the hierachical spatial
/// containment, the second (optional) relationship is the aggregation
/// within an element assembly.
/// 
/// The IfcBuildingElementProxy is places within the project
/// spatial hierarchy using the objectified relationship
/// IfcRelContainedInSpatialStructure, refering to it by its
/// inverse attribute SELF\IfcElement.ContainedInStructure.
/// Subtypes of IfcSpatialStructureElement are valid
/// spatial containers, with IfcBuildingStorey being the default
/// container.
/// The IfcBuildingElementProxy may be aggregated into an
/// element assembly using the objectified relationship
/// IfcRelAggregates, refering to it by its inverse attribute
/// SELF\IfcObjectDefinition.Decomposes. Any subtype of
/// IfcElement can be an element assembly, with
/// IfcElementAssembly as a special focus subtype. In this case
/// it should not be additionally contained in the project spatial
/// hierarchy, i.e. SELF\IfcElement.ContainedInStructure
/// should be NIL.
/// 
/// Geometry Use Definition
/// The geometric representation of IfcBuildingElementProxy
/// is given by the IfcProductDefinitionShape, allowing multiple
/// geometric representations. Included are:
/// Local Placement
/// The local placement for any IfcBuildingElementProxy is
/// defined in its supertype IfcProduct. It is defined by the
/// IfcLocalPlacement, which defines the local coordinate system
/// that is referenced by all geometric representations. The local
/// placement can be given relativly.
/// 
/// The PlacementRelTo relationship of
/// IfcLocalPlacement shall point (if given) to the local
/// placement of the same IfcSpatialStructureElement, which is
/// used in the ContainedInStructure inverse attribute, or to a
/// spatial structure element at a higher level, referenced by
/// that.
/// If the relative placement is not used, the absolute placement
/// is defined within the world coordinate system.
/// 
/// Geometric Representation
/// Currently, the 'FootPrint', 'Body', and 'Box' representations
/// are supported. The 'Box' representation includes the representation
/// type 'BoundingBox' and is explained at
/// IfcBuildingElement.
/// FootPrint Representation
/// Any building element proxy may be represented by a geometric
/// curve set, given by a collection of 2D points and curves. The foot
/// pring geometric representation of IfcBuildingElementProxy is
/// defined using the 'FootPrint' representation.
/// 
/// RepresentationIdentifier: 'FootPrint'
/// RepresentationType: 'GeometricCurveSet',
/// 'Annotation2D'
/// 
/// Body Representation
/// The body representation of IfcBuildingElementProxy can be
/// represented using the representation types 'GeometricSet',
/// 'SweptSolid', 'CSG' 'SurfaceModel', 'Brep', and
/// 'MappedRepresentation'. The representation types 'SurfaceModel',
/// 'Brep', and 'MappedRepresentation' are explained at
/// IfcBuildingElement.
/// GeometricSet Representation Type
/// Any building element proxy may be represented by a geometric
/// set, given by a collection of 2D and 3D points, curves, and
/// surfaces. It represents the body of the proxy object, when no
/// topological structure is available. The following attribute values
/// for the IfcShapeRepresentation holding this geometric
/// representation shall be used:
/// 
/// RepresentationIdentifier: 'Body'
/// RepresentationType: 'GeometricSet'
/// 
/// SweptSolid Representation Type
/// Any building element proxy may be represented by swept solid
/// geometry (either by extrusion or by revolution). The following
/// attribute values for the IfcShapeRepresentation holding this
/// geometric representation shall be used:
/// 
/// RepresentationIdentifier: 'Body'
/// RepresentationType: 'SweptSolid'
/// 
/// No further restrictions (e.g., for the profile or extrusion
/// direction) are defined at this level. A single or multiple swept
/// area solid(s) can be the Items of the
/// IfcShapeRepresentation.
/// CSG Representation Type
/// Any building element proxy may be represented by a CSG primitive
/// or CSG tree. The following attribute values for the
/// IfcShapeRepresentation holding this geometric representation
/// shall be used:
/// 
/// RepresentationIdentifier: 'Body'
/// RepresentationType: 'CSG'
/// 
/// No further restrictions (e.g., for the depths of the CSG tree)
/// are defined at this level.
class IFC_PARSE_API IfcBuildingElementProxy : public IfcBuildingElement {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcBuildingElementProxy
    bool hasPredefinedType() const;
    IfcBuildingElementProxyTypeEnum::IfcBuildingElementProxyTypeEnum PredefinedType() const;
    void setPredefinedType(IfcBuildingElementProxyTypeEnum::IfcBuildingElementProxyTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcBuildingElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcBuildingElementProxyTypeEnum; } return IfcBuildingElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "PredefinedType"; } return IfcBuildingElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcBuildingElementProxy (IfcEntityInstanceData* e);
    IfcBuildingElementProxy (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcBuildingElementProxyTypeEnum::IfcBuildingElementProxyTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcBuildingElementProxy > list;
};
/// Definition from IAI:
///   TheÿIfcBuildingElementProxyType defines a list of
///   commonly shared property set definitions of a building
///   element proxy and an optional set of product
///   representations. It is used to define an element
///   specification (i.e. the specific product information, that
///   is common to all occurrences of that product type).
/// 
/// NOTEÿ The product representations are defined as
///   representation maps (at the level of the supertype
///   IfcTypeProduct, which gets assigned by an element
///   occurrence instance through the
///   IfcShapeRepresentation.Item[1] being an
///   IfcMappedItem.
/// 
/// A building element proxy type is used to define the common
///   properties of a certain type of a building element proxy
///   that may be applied to many instances of thatÿtype to
///   assign a specific style. Building element proxy typesÿmay
///   be exchanged without being already assigned to occurrences.
/// 
/// NOTE  Although an building element proxy does not have
///   a predefined ontological meaning the provision of a type may be
///   helpful in sharing information among multiple occurrences. Applications 
///   that provide type information for element types not yet included in the
///   current IFC specification can use the IfcBuildingElementProxyType
///   to exchange such types.
/// 
/// The occurrences of the IfcBuildingElementProxyType
///   are represented by instances of
///   IfcBuildingElementProxy.
/// 
/// HISTORYÿ New entity in
///   Release IFC2x Edition 3.
class IFC_PARSE_API IfcBuildingElementProxyType : public IfcBuildingElementType {
public:
    /// Predefined types to define the particular type of an building element proxy. There may be property set definitions available for each predefined or user defined type.
    IfcBuildingElementProxyTypeEnum::IfcBuildingElementProxyTypeEnum PredefinedType() const;
    void setPredefinedType(IfcBuildingElementProxyTypeEnum::IfcBuildingElementProxyTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcBuildingElementType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcBuildingElementProxyTypeEnum; } return IfcBuildingElementType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcBuildingElementType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcBuildingElementProxyType (IfcEntityInstanceData* e);
    IfcBuildingElementProxyType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcBuildingElementProxyTypeEnum::IfcBuildingElementProxyTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcBuildingElementProxyType > list;
};
/// Definition from IAI: A building system is a
/// group by which building elements are group according to a common
/// function within the building.
/// HISTORY: New entity in
/// IFC 2x4.
/// The group IfcBuildingSystem defines the occurrence of a
/// specialized system for use within the context of a building and
/// finishing fabric. Important functionalities for the description
/// of a building system are derived from supertypes:
/// 
/// From IfcSystem it inherits the ability to couple the
/// building system via IfcRelServicesBuildings to one or more
/// IfcSpatialElement subtypes as necessary.
/// 
/// From IfcGroup it inherits the inverse attribute
/// IsGroupedBy, pointing to the relationship class
/// IfcRelAssignsToGroup. This allows to group building
/// elements (instances of IfcBuildingElement subtypes,
/// IfcFurnishingElement subtype, IfcElementAssembly
/// and IfcTransportElement, ).
/// 
/// From IfcObjectDefinition it inherits the inverse
/// attribute IsDecomposedBy pointing to the relationship
/// class IfcRelAggregates. It provides the hierarchy between
/// the separate (partial) building systems.
/// 
/// Property Set Use Definition:
/// The property sets relating to this entity are defined by the
/// IfcPropertySet and attached by the
/// IfcRelDefinesByProperties relationship. It is accessible
/// by the inverse IsDefinedBy relationship. The following
/// property set definitions specific to this entity are part of this
/// IFC release:
/// 
/// Pset_BuildingSystemCommon: common property
/// set for building system occurrences
class IFC_PARSE_API IfcBuildingSystem : public IfcSystem {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcBuildingSystem
    bool hasPredefinedType() const;
    /// Predefined types of distribution systems.
    IfcBuildingSystemTypeEnum::IfcBuildingSystemTypeEnum PredefinedType() const;
    void setPredefinedType(IfcBuildingSystemTypeEnum::IfcBuildingSystemTypeEnum v);
    /// Whether the optional attribute LongName is defined for this IfcBuildingSystem
    bool hasLongName() const;
    std::string LongName() const;
    void setLongName(std::string v);
    virtual unsigned int getArgumentCount() const { return 7; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 5: return IfcUtil::Argument_ENUMERATION; case 6: return IfcUtil::Argument_STRING; } return IfcSystem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 5: return Type::IfcBuildingSystemTypeEnum; case 6: return Type::IfcLabel; } return IfcSystem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 5: return "PredefinedType"; case 6: return "LongName"; } return IfcSystem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcBuildingSystem (IfcEntityInstanceData* e);
    IfcBuildingSystem (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, boost::optional< IfcBuildingSystemTypeEnum::IfcBuildingSystemTypeEnum > v6_PredefinedType, boost::optional< std::string > v7_LongName);
    typedef IfcTemplatedEntityList< IfcBuildingSystem > list;
};
/// The energy conversion device type IfcBurnerType defines commonly shared information for occurrences of burners.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a burner specification (i.e. the specific product information, that is common to all occurrences of that product type).  Burner types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcBurnerType are represented by instances of IfcBurner. 
/// 
/// HISTORY: New entity in IFC2x4 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcEnergyConversionDeviceType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_BurnerTypeCommon 
/// 
/// Material Use Definition 
/// The material of the IfcBurnerType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Casing': Material from which the casing is constructed. 
/// 'Fuel': Material designed to be burned. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcBurnerType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcBurner for standard port definitions.
class IFC_PARSE_API IfcBurnerType : public IfcEnergyConversionDeviceType {
public:
    IfcBurnerTypeEnum::IfcBurnerTypeEnum PredefinedType() const;
    void setPredefinedType(IfcBurnerTypeEnum::IfcBurnerTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcEnergyConversionDeviceType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcBurnerTypeEnum; } return IfcEnergyConversionDeviceType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcEnergyConversionDeviceType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcBurnerType (IfcEntityInstanceData* e);
    IfcBurnerType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcBurnerTypeEnum::IfcBurnerTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcBurnerType > list;
};
/// The flow fitting type IfcCableCarrierFittingType defines commonly shared information for occurrences of cable carrier fittings.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a cable carrier fitting specification (i.e. the specific product information, that is common to all occurrences of that product type).  Cable Carrier Fitting types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcCableCarrierFittingType are represented by instances of IfcCableCarrierFitting. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcFlowFittingType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_CableCarrierFittingTypeCommon 
/// 
/// Material Use Definition 
/// The material of the IfcCableCarrierFittingType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Body': The primary material from which the object is constructed. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcCableCarrierFittingType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcCableCarrierFitting for standard port definitions.
class IFC_PARSE_API IfcCableCarrierFittingType : public IfcFlowFittingType {
public:
    /// Identifies the predefined types of cable carrier fitting from which the type required may be set.
    IfcCableCarrierFittingTypeEnum::IfcCableCarrierFittingTypeEnum PredefinedType() const;
    void setPredefinedType(IfcCableCarrierFittingTypeEnum::IfcCableCarrierFittingTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcFlowFittingType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcCableCarrierFittingTypeEnum; } return IfcFlowFittingType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcFlowFittingType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCableCarrierFittingType (IfcEntityInstanceData* e);
    IfcCableCarrierFittingType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcCableCarrierFittingTypeEnum::IfcCableCarrierFittingTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcCableCarrierFittingType > list;
};
/// The flow segment type IfcCableCarrierSegmentType defines commonly shared information for occurrences of cable carrier segments.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a cable carrier segment specification (i.e. the specific product information, that is common to all occurrences of that product type).  Cable Carrier Segment types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcCableCarrierSegmentType are represented by instances of IfcCableCarrierSegment. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcFlowSegmentType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_CableCarrierSegmentTypeCommon 
/// 
/// The following property set definitions are applicable to this entity according to the PredefinedType attribute:  
/// Pset_CableCarrierSegmentTypeCableLadderSegment (CABLELADDERSEGMENT) 
/// Pset_CableCarrierSegmentTypeCableTraySegment (CABLETRAYSEGMENT) 
/// Pset_CableCarrierSegmentTypeCableTrunkingSegment (CABLETRUNKINGSEGMENT) 
/// Pset_CableCarrierSegmentTypeConduitSegment (CONDUITSEGMENT) 
/// 
/// Material Use Definition 
/// The material of the IfcCableCarrierSegmentType is defined by IfcMaterialProfileSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialProfileSet.MaterialProfiles[n].Name shall be used: 
/// 
/// 'Body': Material from which the object is constructed. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcCableCarrierSegmentType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcCableCarrierSegment for standard port definitions.
class IFC_PARSE_API IfcCableCarrierSegmentType : public IfcFlowSegmentType {
public:
    /// Identifies the predefined types of cable carrier segment from which the type required may be set.
    IfcCableCarrierSegmentTypeEnum::IfcCableCarrierSegmentTypeEnum PredefinedType() const;
    void setPredefinedType(IfcCableCarrierSegmentTypeEnum::IfcCableCarrierSegmentTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcFlowSegmentType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcCableCarrierSegmentTypeEnum; } return IfcFlowSegmentType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcFlowSegmentType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCableCarrierSegmentType (IfcEntityInstanceData* e);
    IfcCableCarrierSegmentType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcCableCarrierSegmentTypeEnum::IfcCableCarrierSegmentTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcCableCarrierSegmentType > list;
};
/// The flow fitting type IfcCableFittingType defines commonly shared information for occurrences of cable fittings.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a cable fitting specification (i.e. the specific product information, that is common to all occurrences of that product type).  Cable Fitting types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcCableFittingType are represented by instances of IfcCableFitting. 
/// 
/// HISTORY: New entity in IFC2x4 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcFlowFittingType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_CableFittingTypeCommon 
/// Pset_ElectricalDeviceCommon 
/// 
/// Material Use Definition 
/// The material of the IfcCableFittingType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Casing': Material from which the casing is constructed. 
/// 'Conductor': Material from which the conductors are constructed, such as Aluminium or Copper. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcCableFittingType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcCableFitting for standard port definitions.
class IFC_PARSE_API IfcCableFittingType : public IfcFlowFittingType {
public:
    /// Identifies the predefined types of cable fitting from which the type required may be set.
    IfcCableFittingTypeEnum::IfcCableFittingTypeEnum PredefinedType() const;
    void setPredefinedType(IfcCableFittingTypeEnum::IfcCableFittingTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcFlowFittingType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcCableFittingTypeEnum; } return IfcFlowFittingType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcFlowFittingType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCableFittingType (IfcEntityInstanceData* e);
    IfcCableFittingType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcCableFittingTypeEnum::IfcCableFittingTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcCableFittingType > list;
};
/// The flow segment type IfcCableSegmentType defines commonly shared information for occurrences of cable segments.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a cable segment specification (i.e. the specific product information, that is common to all occurrences of that product type).  Cable Segment types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcCableSegmentType are represented by instances of IfcCableSegment. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcFlowSegmentType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_CableSegmentTypeCommon 
/// Pset_ElectricalDeviceCommon 
/// 
/// The following property set definitions are applicable to this entity according to the PredefinedType attribute:  
/// Pset_CableSegmentTypeBusbarSegment (BUSBARSEGMENT) 
/// Pset_CableSegmentTypeCableSegment (CABLESEGMENT) 
/// Pset_CableSegmentTypeConductorSegment (CONDUCTORSEGMENT) 
/// 
/// Material Use Definition 
/// The material of the IfcCableSegmentType is defined by IfcMaterialProfileSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialProfileSet.MaterialProfiles[n].Name shall be used: 
/// 
/// 'Conductor': The material from which the conductor is constructed such as Aluminium or Copper. 
/// 'Insulation': The material from which the insulation is constructed such as PVC, PEX, EPR, etc. 
/// 'Screen': The material from which the screen that covers the sheath is constructed (mantel) such as Aluminium, Copper, Steel , Lead. 
/// 'Sheath': The outer sheathing of the cable which may be color-coded. 
/// 
/// Composition Use Definition 
/// The IfcCableSegmentType may be aggregated into components using IfcRelAggregates where RelatingObject refers to the enclosing IfcCableSegmentType and RelatedObjects contains one or more components.  Components are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Aggregation use is defined for the following predefined types:
/// 
/// CABLESEGMENT: May contain IfcCableSegment components having PredefinedType CORESEGMENT.  Cable segments may be aggregated into cable cores. 
/// CORESEGMENT: May contain IfcCableSegment components having PredefinedType CONDUCTORSEGMENT.  Cable cores may be aggregated into cable conductors. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcCableSegmentType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcCableSegment for standard port definitions.
class IFC_PARSE_API IfcCableSegmentType : public IfcFlowSegmentType {
public:
    /// Identifies the predefined types of cable segment from which the type required may be set.
    IfcCableSegmentTypeEnum::IfcCableSegmentTypeEnum PredefinedType() const;
    void setPredefinedType(IfcCableSegmentTypeEnum::IfcCableSegmentTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcFlowSegmentType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcCableSegmentTypeEnum; } return IfcFlowSegmentType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcFlowSegmentType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCableSegmentType (IfcEntityInstanceData* e);
    IfcCableSegmentType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcCableSegmentTypeEnum::IfcCableSegmentTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcCableSegmentType > list;
};
/// The energy conversion device type IfcChillerType defines commonly shared information for occurrences of chillers.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a chiller specification (i.e. the specific product information, that is common to all occurrences of that product type).  Chiller types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcChillerType are represented by instances of IfcChiller. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcEnergyConversionDeviceType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_ChillerTypeCommon 
/// 
/// Material Use Definition 
/// The material of the IfcChillerType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Casing': Material from which the casing is constructed. 
/// 'Refrigerant': Refrigerant material. 
/// 
/// Composition Use Definition 
/// The IfcChillerType may be aggregated into components using IfcRelAggregates where RelatingObject refers to the enclosing IfcChillerType and RelatedObjects contains one or more components.  Components are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Aggregation use is defined for the following predefined types:
/// 
/// (All Types): May contain IfcDistributionElement components.  Chillers may aggregate distribution flow elements forming a refrigeration cycle (compressor, condenser, valve, evaporator), as well as control elements. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcChillerType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcChiller for standard port definitions.
class IFC_PARSE_API IfcChillerType : public IfcEnergyConversionDeviceType {
public:
    /// Defines the typical types of chillers (e.g., air-cooled, water-cooled, etc.).
    IfcChillerTypeEnum::IfcChillerTypeEnum PredefinedType() const;
    void setPredefinedType(IfcChillerTypeEnum::IfcChillerTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcEnergyConversionDeviceType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcChillerTypeEnum; } return IfcEnergyConversionDeviceType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcEnergyConversionDeviceType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcChillerType (IfcEntityInstanceData* e);
    IfcChillerType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcChillerTypeEnum::IfcChillerTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcChillerType > list;
};
/// Definition from ISO 6707-1:1989: Construction
/// containing one or more flues. Flue: Duct designed to convey the
/// products of combustion to the open air. Chimney stack: Part of
/// the chimney that projects above a roof.
/// Definition from IAI: Chimneys are typically vertical,
/// or as near as vertical, parts of the construction of a building
/// and part of the building fabric. Often constructed by pre-cast or
/// insitu concrete, today seldom by bricks.
/// HISTORY New entity in
/// IFC2x4
/// Property Set Use Definition:
/// The property sets relating to the IfcChimney are
/// defined by the IfcPropertySet and attached by the
/// IfcRelDefinesByProperties relationship. It is accessible
/// by the inverse IsDefinedBy relationship. The following
/// property set definitions specific to the IfcChimney are
/// part of this IFC release:
/// 
/// Pset_ChimneyCommon: common property set for all
/// chimney occurrences.
/// 
/// Property sets can also be given at the IfcChimneyType,
/// defining the common property data for all occurrences of the same
/// type.ÿIt is then accessible by the inverse IsTypedBy relationship pointing to
/// IfcChimneyType.HasPropertySets. If both are given, then
/// the properties directly assigned to IfcChimney overrides
/// the properties assigned to IfcChimneyType.
/// Quantity Use Definition:
/// The quantities relating to the IfcChimney are defined
/// by the IfcElementQuantity and attached by the
/// IfcRelDefinesByProperties. It is accessible by the inverse
/// IsDefinedBy relationship. The following base quantities
/// are defined and should be exchanged with the
/// IfcElementQuantity.MethodOfMeasurement = 'BaseQuantities'.
/// Other quantities can be defined being subjected to local standard
/// of measurement with another string value assigned to Name
/// and a value provided for MethodOfMeasurement. Quanties
/// shall be never assigned to the IfcChimneyType.
/// 
/// Qto_ChimneyBaseQuantities: base quantities
/// for all chimney occurrences.
class IFC_PARSE_API IfcChimney : public IfcBuildingElement {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcChimney
    bool hasPredefinedType() const;
    /// Predefined generic type for a chimney that is specified in an enumeration. There may be a property set given specificly for the predefined types.
    ///   NOTE The PredefinedType shall only be used, if no type object IfcChimneyType is assigned, providing its own IfcChimneyType.PredefinedType.
    IfcChimneyTypeEnum::IfcChimneyTypeEnum PredefinedType() const;
    void setPredefinedType(IfcChimneyTypeEnum::IfcChimneyTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcBuildingElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcChimneyTypeEnum; } return IfcBuildingElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "PredefinedType"; } return IfcBuildingElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcChimney (IfcEntityInstanceData* e);
    IfcChimney (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcChimneyTypeEnum::IfcChimneyTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcChimney > list;
};
/// Definition from ISO/CD 10303-42:1992: An IfcCircle is defined by a radius and the location and orientation of the circle. Interpretation of data should be as follows: 
/// 
/// C = SELF\IfcConic.Position.Location 
///   x = SELF\IfcConic.Position.P[1] 
///   y = SELF\IfcConic.Position.P[2] 
///   z = SELF\IfcConic.Position.P[3] 
///   R = Radius
/// 
/// and the circle is parameterized as  
/// 
/// The parameterization range is 0 £
///   u £2p (or 0
///   £u £
///   360 degree). In the placement coordinate system defined above, the circle is
///   the equation C = 0, where 
/// 
/// The positive sense of the circle at any point is in the tangent direction, T, to the curve at the point, where 
/// 
/// NOTE  A circular arc is defined by using the trimmed curve (IfcTrimmedCurve) entity in conjunction with the circle (IfcCircle) entity as the BasisCurve.
/// 
/// NOTE  Corresponding ISO 10303 entity: circle, please refer to ISO/IS 10303-42:1994, p. 38 for the final definition of the formal standard.
/// 
/// HISTORY  New class in IFC Release 1.0
/// 
/// Figure 278 illustrates the definition of the IfcCircle within the (in this case three-dimensional) position coordinate system. 
/// 
/// Figure 278 — Circle geometry
class IFC_PARSE_API IfcCircle : public IfcConic {
public:
    /// The radius of the circle, which shall be greater than zero.
    double Radius() const;
    void setRadius(double v);
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 1: return IfcUtil::Argument_DOUBLE; } return IfcConic::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 1: return Type::IfcPositiveLengthMeasure; } return IfcConic::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 1: return "Radius"; } return IfcConic::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCircle (IfcEntityInstanceData* e);
    IfcCircle (IfcAxis2Placement* v1_Position, double v2_Radius);
    typedef IfcTemplatedEntityList< IfcCircle > list;
};

class IFC_PARSE_API IfcCivilElement : public IfcElement {
public:
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCivilElement (IfcEntityInstanceData* e);
    IfcCivilElement (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag);
    typedef IfcTemplatedEntityList< IfcCivilElement > list;
};
/// The energy conversion device type IfcCoilType defines commonly shared information for occurrences of coils.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a coil specification (i.e. the specific product information, that is common to all occurrences of that product type).  Coil types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcCoilType are represented by instances of IfcCoil. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcEnergyConversionDeviceType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_CoilTypeCommon 
/// Pset_CoilTypeHydronic 
/// 
/// Material Use Definition 
/// The material of the IfcCoilType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Body': The primary material from which the object is constructed. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcCoilType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcCoil for standard port definitions.
class IFC_PARSE_API IfcCoilType : public IfcEnergyConversionDeviceType {
public:
    /// Defines typical types of coils (e.g., Cooling, Heating, etc.)
    IfcCoilTypeEnum::IfcCoilTypeEnum PredefinedType() const;
    void setPredefinedType(IfcCoilTypeEnum::IfcCoilTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcEnergyConversionDeviceType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcCoilTypeEnum; } return IfcEnergyConversionDeviceType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcEnergyConversionDeviceType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCoilType (IfcEntityInstanceData* e);
    IfcCoilType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcCoilTypeEnum::IfcCoilTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcCoilType > list;
};
/// Definition from ISO 6707-1:1989: Structural member of
/// slender form, usually vertical, that transmits to its base the
/// forces, primarily in compression, that are applied to it.
/// <An IfcColumn is a vertical
/// structural member which often is aligned with a structural grid
/// intersection. It represents a vertical, or nearly vertical,
/// structural member that transmits, through compression, the weight
/// of the structure above to other structural elements below. It
/// represents such a member from an architectural point of view. It
/// is not required to be load bearing.
/// NOTE The representation of a column in a
/// structural analysis model is provided by
/// IfcStructuralCurveMember being part of an
/// IfcStructuralAnalysisModel.
/// 
/// NOTE ÿFor any longitudial structural member, not
/// constrained to be predominately horizontal nor vertical, or where
/// this semantic information is irrelevant, the entity
/// IfcMember exists.
/// The IFC specification provides two entities for column
/// occurrences:
/// 
/// IfcColumnStandardCase used for all occurrences of
/// columns, tthat have a profile defined that is swept along a
/// directrix. The profile might be changed uniformly by a taper
/// definition along the directrix. The profile parameter and its
/// cardinal point of insertion can be fully described by the
/// IfcMaterialProfileSetUsage. These beams are always
/// represented geometricly by an 'Axis' and a 'SweptSolid' or
/// 'AdvancedSweptSolid' shape representation (or by a 'Clipping'
/// geometry based on the swept solid), if a 3D geometric
/// representation is assigned. In addition they have to have a
/// corresponding IfcMaterialProfileSetUsage assigned.
/// NOTEÿ View definitions and implementer
/// agreements may further constrain the applicable geometry types,
/// e.g. by excluding tapering from an IfcColumnStandardCase
/// implementation.
/// 
/// IfcColumn used for all other occurrences of columns,
/// particularly for columns with changing profile sizes along the
/// extrusion, or columns defined by non-linear extrusion, or columns
/// having only 'Brep', or 'SurfaceModel' geometry.
/// 
/// HISTORY New entity in IFC Release 1.0
/// 
/// Type Use Definition
/// IfcColumn defines the occuurence of any column, common
/// information about column types (or styles) is handled by
/// IfcColumnType. The IfcColumnType (if present) may
/// establish the commonÿtype name, usage (or predefined) type,
/// common material layer set, common set of properties and common
/// shape representations (using IfcRepresentationMap). The
/// IfcColumnType is attached using the
/// IfcRelDefinedByType.RelatingType objectified relationship
/// and is accessible by the inverse IsTypedBy attribute.
/// If no IfcColumnType is attachedÿ(i.e. if only
/// occurrence information is given) the PredefinedType should
/// be provided. If set to .USERDEFINED. a user defined value can be
/// provided by the ObjectType attribute.
/// Material Use Definition
/// The material of the IfcColumn is defined by the
/// IfcMaterialProfileSet or as fallback by IfcMaterial
/// and attached by the
/// IfcRelAssociatesMaterial.RelatingMaterial. It is
/// accessible by the inverse HasAssociations
/// relationship.
/// Note: It is illegal to assign an
/// IfcMaterialProfileSetUsage to an IfcColumn. Only
/// the subtype IfcColumnStandardCase supports this
/// concept.
/// Material information can also be given at the
/// IfcColumnType, defining the common attribute data for all
/// occurrences of the same type.ÿIt is then accessible by the
/// inverse IsTypedBy
/// relationship pointing to
/// IfcColumnType.HasAssociations and via
/// IfcRelAssociatesMaterial.RelatingMaterial to
/// IfcMaterialProfileSet or IfcMaterial. If both are
/// given, then the material directly assigned to IfcColumn
/// overrides the material assigned to IfcColumnType.
/// Property Set Use Definition:
/// The property sets relating to the IfcColumn are defined
/// by the IfcPropertySet and attached by the
/// IfcRelDefinesByProperties relationship. It is accessible
/// by the inverse IsDefinedBy relationship. The following
/// property set definitions specific to the IfcColumn are
/// part of this IFC release:
/// 
/// Pset_ColumnCommon: common property set for all
/// column occurrences
/// 
/// Property sets can also be given at the IfcColumnType,
/// defining the common property data for all occurrences of the same
/// type.ÿIt is then accessible by the inverse IsTypedBy relationship pointing to
/// IfcColumnType.HasPropertySets. If both are given, then the
/// properties directly assigned to IfcColumn overrides the
/// properties assigned to IfcColumnType.
/// Quantity Use Definition:
/// The quantities relating to the IfcColumn are defined by
/// the IfcElementQuantity and attached by the
/// IfcRelDefinesByProperties. It is accessible by the inverse
/// IsDefinedBy relationship. The following base quantities
/// are defined and should be exchanged with the
/// IfcElementQuantity.MethodOfMeasurement = 'BaseQuantities'.
/// Other quantities can be defined being subjected to local standard
/// of measurement with another string value assigned to Name
/// and a value provided for MethodOfMeasurement. Quanties
/// shall be never assigned to the IfcColumnType.
/// 
/// Qto_ColumnBaseQuantities: base quantities for
/// all column occurrences.
/// 
/// Containment Use Definition
/// The IfcColumn, as any subtype of
/// IfcBuildingElement, may participate in two different
/// containment relationships. The first (and in most implementation
/// scenarios mandatory) relationship is the hierachical spatial
/// containment, the second (optional) relationship is the
/// aggregation within anÿelement assembly.
/// 
/// The IfcColumn, is places within the project spatial
/// hierarchy using the objectified relationship
/// IfcRelContainedInSpatialStructure, refering to it by its
/// inverse attribute SELF\IfcElement.ContainedInStructure.
/// Subtypes ofÿIfcSpatialStructureElement are valid spatial
/// containers, with IfcBuildingStorey being the default
/// container.
/// The IfcColumn, may be aggregated into an element
/// assembly using the objectified relationship
/// IfcRelAggregates, refering to it by its inverse attribute
/// SELF\IfcObjectDefinition.Decomposes. Any subtype of
/// IfcElement can be an element assembly, with
/// IfcElementAssembly as a special focus subtype. In this
/// case it should not be additionally contained in the project
/// spatial hierarchy,
/// i.e.ÿSELF\IfcElement.ContainedInStructure should be
/// NIL.
/// 
/// Geometry Use Definition
/// The geometric representation of IfcColumn is given by
/// the IfcProductDefinitionShape, allowing multiple geometric
/// representations. Included are:
/// Local Placement
/// The local placement for IfcColumn is defined in its
/// supertype IfcProduct. It is defined by the
/// IfcLocalPlacement, which defines the local coordinate
/// system that is referenced by all geometric representations.
/// 
/// The PlacementRelTo relationship of
/// IfcLocalPlacement shall point (if given) to the local
/// placement of the same IfcSpatialStructureElement, which is
/// used in the ContainedInStructure inverse attribute, or to
/// a spatial structure element at a higher level, referenced by
/// that.
/// If the relative placement is not used, the absolute placement
/// is defined within the world coordinate system.
/// 
/// Geometric Representation
/// Currently, the 'Axis', 'Body',
/// and 'Box' representations are supported. The 'Box' representation
/// includes the representation type 'BoundingBox' and is explained
/// at IfcBuildingElement.
/// Axis Representation
/// The axis geometric representation of IfcColumn is
/// defined using the 'Axis' representation. The following attribute
/// values for the IfcShapeRepresentation holding this
/// geometric representation shall be used:
/// 
/// RepresentationIdentifier : 'Axis'
/// RepresentationType : 'Curve2D', 'Curve3D'
/// 
/// The axis representation can be used to represent the system
/// length of a column that may extent the body length of the
/// column.
/// Body Representation
/// The body representation of IfcColumn can be represented
/// using the representation types 'SweptSolid', 'Clipping',
/// 'AdvancedSweptSolid', 'MappedRepresentation', 'SurfaceModel', and
/// 'Brep'. The representation types 'SurfaceModel' and 'Brep' are
/// explained at IfcBuildingElement.
/// SweptSolid Representation Type
/// The following attribute values for the
/// IfcShapeRepresentation holding this geometric
/// representation shall be used:
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'SweptSolid'
/// 
/// The following additional constraints apply to the 'SweptSolid'
/// representation:
/// 
/// Solid: IfcExtrudedAreaSolid,
/// IfcRevolvedAreaSolid shall be supported
/// Profile: all subtypes of IfcProfileDef (with
/// exception of IfcArbitraryOpenProfileDef)ÿ
/// Extrusion:ÿAll extrusion directions shall be
/// supported
/// 
/// Figure 81 illustrates a 'SweptSolid' geometric representation. There are no restrictions or conventions on
/// how to use the local placement (black), solid of extrusion placement (red) and profile placement (green).
/// 
/// Figure 81 — Column swept solid
/// 
/// Figure 82 illustrates use of a special profile type (here IfcIShapeProfileDef) for the definition of the IfcExtrudedAreaSolid.
/// 
/// Figure 82 — Column extrusion of I-Shape
/// 
/// Clipping Representation Type
/// The following attribute values for the
/// IfcShapeRepresentation holding this geometric
/// representation shall be used:
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'Clipping'
/// 
/// The following constraints apply to the advanced
/// representation:
/// 
/// Solid: see 'SweptSolid' geometric representation
/// Profile: see 'SweptSolid' geometric
/// representation
/// Extrusion: see 'SweptSolid' geometric
/// representation
/// Boolean result: The IfcBooleanClippingResult
/// shall be supported, allowing for Boolean differences between the
/// swept solid (here IfcExtrudedAreaSolid) and one or several
/// IfcHalfSpaceSolid.
/// 
/// Figure 83 illustrates a 'Clipping' geometric representation with use of IfcBooleanClippingResult between
/// an IfcExtrudedAreaSolid and an IfcHalfSpaceSolid to create a clipped body.
/// 
/// Figure 83 — Column clipping
/// 
/// AdvancedSweptSolid Representation Type
/// The following attribute values for the
/// IfcShapeRepresentation holding this geometric
/// representation shall be used:
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'AdvancedSweptSolid'
/// 
/// The following additional constraints apply to the
/// 'AdvancedSweptSolid' representation type:
/// 
/// Solid: IfcSurfaceCurveSweptAreaSolid,
/// IfcFixedReferenceSweptAreaSolid,
/// IfcExtrudedAreaSolidTapered,
/// IfcRevolvedAreaSolidTapered shall be supported.
/// NOTE View definitions and implementer
/// agreements can further constrain the allowed swept solid
/// types.
/// 
/// Profile: see 'SweptSolid' geometric
/// representation
/// Extrusion:ÿnot applicable
/// 
/// MappedRepresentation Representation Type
/// The 'MappedRepresentation' representation type is supported as
/// it allows for reusing the geometry definition of the beam type at
/// all occurrences of the same type. The following attribute values
/// for the IfcShapeRepresentation holding this geometric
/// representation shall be used:
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'MappedRepresentation'
/// 
/// The same constraints, as given for theÿ 'SweptSolid',
/// 'Clipping', 'AdvancedSweptSolid', 'SurfaceModel' and 'Bre'
/// geometric representation, shall apply to the
/// MappedRepresentation of the
/// IfcRepresentationMap.
class IFC_PARSE_API IfcColumn : public IfcBuildingElement {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcColumn
    bool hasPredefinedType() const;
    /// Predefined generic type for a column that is specified in an enumeration. There may be a property set given specificly for the predefined types.
    ///   NOTE The PredefinedType shall only be used, if no type object IfcColumnType is assigned, providing its own IfcColumnType.PredefinedType.
    /// 
    /// IFC2x4 CHANGE  The attribute has been added at the end of the entity definition.
    IfcColumnTypeEnum::IfcColumnTypeEnum PredefinedType() const;
    void setPredefinedType(IfcColumnTypeEnum::IfcColumnTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcBuildingElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcColumnTypeEnum; } return IfcBuildingElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "PredefinedType"; } return IfcBuildingElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcColumn (IfcEntityInstanceData* e);
    IfcColumn (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcColumnTypeEnum::IfcColumnTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcColumn > list;
};
/// The standard column,
/// IfcColumnStandardCase, defines a column with certain
/// constraints for the provision of material usage, parameters and
/// with certain constraints for the geometric representation. The
/// IfcColumnStandardCase handles all cases of columns,
/// that:
/// 
/// have a reference to the IfcMaterialProfileSetUsage
/// defining the material profile association of the column with the
/// cardinal point of its insertion relative to the local
/// placement.
/// are based on a sweep of a planar profile, or set of profiles,
/// as defined by the IfcMaterialProfileSet
/// have an 'Axis' shape representation with constraints provided
/// below in the geometry use definition
/// have a 'Body' shape representation with constraints provided
/// below in the geometry use definition
/// have a start profile, or set of profiles, that is swept along
/// the directrix and might be changed uniformly by a taper
/// definition
/// are consistent in using the correct cardinal point offset of
/// the profile as compared to the 'Axis' and 'Body' shape
/// representation
/// are extruded perpendicular to the profile definition
/// plane
/// 
/// NOTEÿ View definitions and implementer
/// agreements may further constrain the applicable geometry types,
/// e.g. by excluding tapering from an IfcBeamStandardCase
/// implementation.
/// 
/// HISTORY New entity in IFC2x4.
/// 
/// Type Use Definition
/// IfcColumn defines the occuurence of any column, common
/// information about column types (or styles) is handled by
/// IfcColumnType. The IfcColumnType (if present) may
/// establish the commonÿtype name, usage (or predefined) type,
/// common material layer set, common set of properties and common
/// shape representations (using IfcRepresentationMap). The
/// IfcColumnType is attached using the
/// IfcRelDefinedByType.RelatingType objectified relationship
/// and is accessible by the inverse IsDefinedBy
/// attribute.
/// The IfcColumnStandardCase defines in addition that the
/// IfcColumnType should have a unique
/// IfcMaterialProfileSet, that is referenced by the
/// IfcMaterialProfileSetUsage assigned to all occurrences of
/// this column type.
/// 
/// Figure 84 illustrates assignment of IfcMaterialProfileSetUsage and IfcMaterialProfileSet to the IfcColumnStandardCase as the column occurrence and to the IfcColumnType. The same IfcMaterialProfileSet shall be shared by many occurrences of IfcMaterialProfileSetUsage. This relationship shall be consistent to the relationship between the IfcColumnType and the IfcColumnStandardCase.
/// 
/// Figure 84 — Column profile usage
/// 
/// Figure 85 illustrates cardinal point alignment.
/// NOTEÿ It has to be guaranteed that the use of IfcCardinalPointEnum is consistent to the placement of the
/// extrusion body provided by IfcExtrudedAreaSolid.Position
/// NOTEÿ The cardinal points 7 (top left), and 6 (mid-depth right) are assigned according to the
/// definition at IfcCardinalPointReference
/// 
/// Figure 85 — Column cardinal points
/// 
/// Figure 86 illustrates assignment of a composite profile by using IfcCompositeProfile for geometric representation and several IfcMaterialProfile's within the IfcMaterialProfileSet. The number of IfcMaterialProfile's within the IfcMaterialProfileSet is restricted to maximal 2 and requires the use of IfcExtrudedAreaSolidTapered, or IfcRevolvedAreaSolidTapered for the correct 'Body' shape representation.
/// 
/// Figure 86 — Column composite profiles
/// 
/// Material Use Definition
/// The material of the IfcColumnStandardCase is defined by
/// IfcMaterialProfileSetUsage and attached by the
/// IfcRelAssociatesMaterial.RelatingMaterial. It is
/// accessible by the inverse HasAssociations relationship.
/// Composite profile columns can be represented by refering to
/// several IfcMaterialProfile's within the
/// IfcMaterialProfileSet that is referenced from the
/// IfcMaterialProfileSetUsage.
/// Material information can also be given at the
/// IfcColumnType, defining the common attribute data for all
/// occurrences of the same type. It is then accessible by the
/// inverse IsDefinedBy relationship pointing to
/// IfcColumnType.HasAssociations and via
/// IfcRelAssociatesMaterial.RelatingMaterial. See Type Use
/// Definition for additional agreements for standard
/// columns.
/// Property Set Use Definition:
/// The property sets relating to the IfcColumnStandardCase
/// are defined at the supertype IfcColumn.
/// Quantity Use Definition
/// The quantities relating to the IfcColumnStandardCase
/// are defined at the supertype IfcColumn.
/// Containment Use Definition
/// The containment use definitions relating to the
/// IfcColumnStandardCase are defined at the supertype
/// IfcColumn.
/// Geometry Use Definitions:
/// The geometric representation of IfcColumn is given by
/// the IfcProductDefinitionShape, allowing multiple geometric
/// representations. Included are:
/// Local Placement
/// The use of local placement is defined at the supertype
/// IfcColumn.
/// Geometric Representations
/// The geometric representation of IfcColumnStandardCase
/// is defined using the following multiple shape representations for
/// its definition:
/// 
/// Axis: A three-dimensional open curve (subtype of
/// IfcBoundedCurve) defining the axis for the standard
/// column. The cardinal point is determined by the column axis.
/// Body: A Swept Solid Representation or a CSG
/// representation defining the 3D shape of the standard column.
/// 
/// NOTE It is invalid to exchange a
/// 'SurfaceModel', 'Brep', or 'MappedRepresentation' representation
/// for the 'Body' shape representation of an
/// IfcColumnStandardCase.
/// Axis Representation
/// The axis geometric representation of
/// IfcColumnStandardCase is defined using the 'Axis'
/// representation. The following attribute values for the
/// IfcShapeRepresentation holding this geometric
/// representation shall be used:
/// 
/// RepresentationIdentifier : 'Axis'
/// RepresentationType : 'Curve3D'
/// 
/// The following additional constraints apply to the 'Axis'
/// representation, if the 'Body' shape representation has the
/// RepresentationType : 'SweptSolid':
/// 
/// Axis : IfcPolyline having two Points, or
/// IfcTrimmedCurve with BasisCurve of Type
/// IfcLine.
/// The axis curve lies on the z axis of the object coordinate
/// system
/// 
/// As shown in Figure 87, the axis shall be defined along the z axis of
/// the object coordinate system. The axis representation can be used to
/// represent the system length of a column that may extent the body
/// length of the column.
/// 
/// Figure 87 — Column axis representation
/// 
/// As shown in Figure 88, the axis representation shall be used to represent the cardinal point as the offset between the 'Axis' and the extrusion path of the column. The extrusion path is provided as IfcExtrudedAreaSolid.ExtrudedDirection and should be parallel to the 'Axis'. It has to be guaranteed that the value provided by IfcMaterialProfileSetUsage.CardinalPoint is consistent to the IfcExtrudedAreaSolid.Position.
/// 
/// Figure 88 — Column axis cardinal point
/// 
/// Body Representation
/// The body representation of IfcColumnStandardCase can be
/// represented using the representation types 'SweptSolid',
/// 'Clipping', or 'AdvancedSweptSolid'.
/// SweptSolid Representation Type
/// The following attribute values for the
/// IfcShapeRepresentation holding this geometric
/// representation shall be used:
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'SweptSolid'
/// 
/// The following additional constraints apply to the 'SweptSolid'
/// representation:
/// 
/// Solid: IfcExtrudedAreaSolid,
/// IfcRevolvedAreaSolid shall be supported
/// Profile: all subtypes of IfcProfileDef (with
/// exception of IfcArbitraryOpenProfileDef)
/// Profile Position : For all single profiles, the
/// IfcParameterizedProfileDef.Position shall be NIL, or
/// having Location = 0.,0. and RefDirection =
/// 1.,0.
/// Extrusion:ÿperpendicular to the profile direction. The
/// IfcExtrudedAreaSolid.ExtrudedDirection shall be
/// [0.,0.,1.].
/// Orientation: The y-axis of the profile, as determined
/// by IfcSweptAreaSolid.Position.P[2] shall point to the
/// Y-Axis. It indicates the "role" of the column, a role=0°
/// means y-axis of profile = Y-axis of reference coordinate
/// system.
/// 
/// Figure 89 illustrates a standard geometric representation with cardinal point applied as 5 (mid-depth centre).
/// The following interpretation of dimension parameter applies for rectangular columns:
/// 
/// IfcRectangleProfileDef.YDim interpreted as column width
/// IfcRectangleProfileDef.XDim interpreted as column depth
/// 
/// The following interpretation of dimension parameter applies for circular columns:
/// 
/// IfcCircleProfileDef.Radius interpreted as column radius.
/// 
/// Figure 89 — Column body extrusion
/// 
/// Clipping Representation Type
/// The following attribute values for the
/// IfcShapeRepresentation holding this geometric
/// representation shall be used:
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'Clipping'
/// 
/// The following constraints apply to the advanced
/// representation:
/// 
/// Solid: see 'SweptSolid' geometric representation
/// Profile: see 'SweptSolid' geometric
/// representation
/// Profile Position : see 'SweptSolid' geometric
/// representation
/// Extrusion:ÿsee 'SweptSolid' geometric
/// representation
/// Orientation: see 'SweptSolid' geometric
/// representation
/// Boolean result: The IfcBooleanClippingResult
/// shall be supported, allowing for Boolean differences between the
/// swept solid (here IfcExtrudedAreaSolid) and one or several
/// IfcHalfSpaceSolid (or its subtypes).
/// 
/// Figure 90 illustrates a 'Clipping' geometric representation with use of IfcBooleanClippingResult between
/// an IfcExtrudedAreaSolid and an IfcHalfSpaceSolid to create a clipped body, with cardinal point applied as 2 (bottom centre).
/// 
/// Figure 90 — Column body clipping
/// 
/// AdvancedSweptSolid Representation Type
/// The 'AdvancedSweptSolid' representation type is a valid body
/// representation of IfcColumnStandardCase. The following
/// attribute values for the IfcShapeRepresentation holding
/// this geometric representation shall be used:
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'AdvancedSweptSolid'
/// 
/// The following additional constraints apply to the
/// 'AdvancedSweptSolid' representation type:
/// 
/// Solid: IfcSurfaceCurveSweptAreaSolid,
/// IfcFixedReferenceSweptAreaSolid,
/// IfcExtrudedAreaSolidTapered,
/// IfcRevolvedAreaSolidTapered shall be supported.
/// NOTE View definitions and implementer
/// agreement can further constrain the allowed swept solid
/// types.
/// 
/// Profile: see 'SweptSolid' geometric
/// representation
/// Profile Position : see 'SweptSolid' geometric
/// representation
/// Extrusion:ÿnot applicable
class IFC_PARSE_API IfcColumnStandardCase : public IfcColumn {
public:
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcColumn::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcColumn::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcColumn::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcColumnStandardCase (IfcEntityInstanceData* e);
    IfcColumnStandardCase (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcColumnTypeEnum::IfcColumnTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcColumnStandardCase > list;
};
/// The flow terminal type IfcCommunicationsApplianceType defines commonly shared information for occurrences of communications appliances.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a communications appliance specification (i.e. the specific product information, that is common to all occurrences of that product type).  Communications Appliance types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcCommunicationsApplianceType are represented by instances of IfcCommunicationsAppliance. 
/// 
/// HISTORY: New entity in IFC2x4 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcFlowTerminalType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_CommunicationsApplianceTypeCommon 
/// Pset_ElectricalDeviceCommon 
/// 
/// Material Use Definition 
/// The material of the IfcCommunicationsApplianceType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Casing': Material from which the casing is constructed. 
/// 
/// Composition Use Definition 
/// The IfcCommunicationsApplianceType may be aggregated into components using IfcRelAggregates where RelatingObject refers to the enclosing IfcCommunicationsApplianceType and RelatedObjects contains one or more components.  Components are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Aggregation use is defined for the following predefined types:
/// 
/// COMPUTER: May contain IfcAudioVisualAppliance components.  Computers may be aggregated into audio-visual components such as displays, cameras, speakers, or microphones. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcCommunicationsApplianceType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcCommunicationsAppliance for standard port definitions.
class IFC_PARSE_API IfcCommunicationsApplianceType : public IfcFlowTerminalType {
public:
    /// Identifies the predefined types of communications  appliance from which the type required may be set.
    IfcCommunicationsApplianceTypeEnum::IfcCommunicationsApplianceTypeEnum PredefinedType() const;
    void setPredefinedType(IfcCommunicationsApplianceTypeEnum::IfcCommunicationsApplianceTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcFlowTerminalType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcCommunicationsApplianceTypeEnum; } return IfcFlowTerminalType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcFlowTerminalType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCommunicationsApplianceType (IfcEntityInstanceData* e);
    IfcCommunicationsApplianceType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcCommunicationsApplianceTypeEnum::IfcCommunicationsApplianceTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcCommunicationsApplianceType > list;
};
/// The flow moving device type IfcCompressorType defines commonly shared information for occurrences of compressors.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a compressor specification (i.e. the specific product information, that is common to all occurrences of that product type).  Compressor types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcCompressorType are represented by instances of IfcCompressor. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcFlowMovingDeviceType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_CompressorTypeCommon 
/// 
/// Material Use Definition 
/// The material of the IfcCompressorType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Body': The primary material from which the object is constructed. 
/// 'Refrigerant': Refrigerant material. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcCompressorType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcCompressor for standard port definitions.
class IFC_PARSE_API IfcCompressorType : public IfcFlowMovingDeviceType {
public:
    /// Defines the type of compressor (e.g., hermetic, reciprocating, etc.).
    IfcCompressorTypeEnum::IfcCompressorTypeEnum PredefinedType() const;
    void setPredefinedType(IfcCompressorTypeEnum::IfcCompressorTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcFlowMovingDeviceType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcCompressorTypeEnum; } return IfcFlowMovingDeviceType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcFlowMovingDeviceType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCompressorType (IfcEntityInstanceData* e);
    IfcCompressorType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcCompressorTypeEnum::IfcCompressorTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcCompressorType > list;
};
/// The energy conversion device type IfcCondenserType defines commonly shared information for occurrences of condensers.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a condenser specification (i.e. the specific product information, that is common to all occurrences of that product type).  Condenser types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcCondenserType are represented by instances of IfcCondenser. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcEnergyConversionDeviceType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_CondenserTypeCommon 
/// 
/// Material Use Definition 
/// The material of the IfcCondenserType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Casing': Material from which the casing is constructed. 
/// 'Refrigerant': Refrigerant material. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcCondenserType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcCondenser for standard port definitions.
class IFC_PARSE_API IfcCondenserType : public IfcEnergyConversionDeviceType {
public:
    /// Defines the type of condenser.
    IfcCondenserTypeEnum::IfcCondenserTypeEnum PredefinedType() const;
    void setPredefinedType(IfcCondenserTypeEnum::IfcCondenserTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcEnergyConversionDeviceType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcCondenserTypeEnum; } return IfcEnergyConversionDeviceType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcEnergyConversionDeviceType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCondenserType (IfcEntityInstanceData* e);
    IfcCondenserType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcCondenserTypeEnum::IfcCondenserTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcCondenserType > list;
};
/// IfcConstructionEquipmentResource is usage of construction equipment to assist in the performance of construction. Construction Equipment resources are wholly or partially consumed or occupied in the performance of construction.
/// 
/// HISTORY: New Entity in IFC Release 2.0.  Base type and documentation extended in IFC2x4.
/// 
/// Occurrences of IfcConstructionEquipmentResource are products that are used as resources to assist the process of construction. More specifically, they are products that are standalone items brought to a project to fulfil a particular purpose. Examples might be a tower crane or other mobile crane, a screwing machine, a lifting hoist etc. They are explicitly instances of IfcProduct  and may be drawn from various of the subtype, for instance IfcTransportElement, IfcDiscreteAccessory, IfcProxy (for particular cases where more precise usage details are not available).
/// 
/// A product that is used as an IfcConstructionEquipmentResource is referenced using the IfcRelAssignsToResource.RelatedObjects relationship.
/// 
/// Use definitions for composition, assignment, constraints, time series, and baselines are described at the base type IfcConstructionResource.
/// 
/// Type use definition
/// IfcConstructionEquipmentResource defines the occurrence of any construction equipment resource; common information about construction equipment resource types is handled by IfcConstructionEquipmentResourceType.  The IfcConstructionEquipmentResourceType (if present) may establish the common type name, common properties, and common productivities for various task types using IfcRelAssignsToProcess.  The IfcConstructionEquipmentResourceType is attached using the IfcRelDefinesByType.RelatingType objectified relationship and is accessible by the inverse IsTypedBy attribute.
/// 
/// Quantity use definition
/// The quantities relating to the IfcConstructionEquipmentResource are defined by IfcElementQuantity and attached by the IfcRelDefinesByProperties relationship. It is accessible by the inverse IsDefinedBy relationship. The following base quantities are defined and should be exchanged with the IfcElementQuantity.Name = 'BaseQuantities'. Other quantities can be defined being subjected to local standard of measurement with another string value assigned to Name and a value provided for MethodOfMeasurement.
/// 
/// Qto_ConstructionEquipmentResourceBaseQuantities: base quantities for all construction equipment resources.
/// 
/// Assignment use definition
/// In addition to assignments specified at the base class IfcConstructionResource, a construction equipment resource may have assignments of its own using IfcRelAssignsToResource where RelatingResource refers to the IfcConstructionEquipmentResource and RelatedObjects contains one or more IfcProduct subtypes as shown in Figure 183.  Such relationship indicates the equipment used as input for the resource.  Such products are not contained within a building structure but are referenced within a construction spatial zone, specifically IfcSpatialZone with PredefinedType=CONSTRUCTION, which is aggregated within the IfcProject.  There may be multiple chains of production such that the assigned equipment may have their own task and resource assignments for assembling such equipment.
/// 
/// Figure 183 — Construction equipment resource assignment
class IFC_PARSE_API IfcConstructionEquipmentResource : public IfcConstructionResource {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcConstructionEquipmentResource
    bool hasPredefinedType() const;
    /// Defines types of construction equipment resources.
    /// IFC2x4 New attribute
    IfcConstructionEquipmentResourceTypeEnum::IfcConstructionEquipmentResourceTypeEnum PredefinedType() const;
    void setPredefinedType(IfcConstructionEquipmentResourceTypeEnum::IfcConstructionEquipmentResourceTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 11; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 10: return IfcUtil::Argument_ENUMERATION; } return IfcConstructionResource::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 10: return Type::IfcConstructionEquipmentResourceTypeEnum; } return IfcConstructionResource::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 10: return "PredefinedType"; } return IfcConstructionResource::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcConstructionEquipmentResource (IfcEntityInstanceData* e);
    IfcConstructionEquipmentResource (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, boost::optional< std::string > v6_Identification, boost::optional< std::string > v7_LongDescription, IfcResourceTime* v8_Usage, boost::optional< IfcTemplatedEntityList< IfcAppliedValue >::ptr > v9_BaseCosts, IfcPhysicalQuantity* v10_BaseQuantity, boost::optional< IfcConstructionEquipmentResourceTypeEnum::IfcConstructionEquipmentResourceTypeEnum > v11_PredefinedType);
    typedef IfcTemplatedEntityList< IfcConstructionEquipmentResource > list;
};
/// IfcConstructionMaterialResource identifies a material resource type in a construction project. 
/// 
/// HISTORY: New Entity in IFC Release 2.0. Base type and documentation extended in IFC2x4.
/// 
/// IFC2x4 NOTE: The attribute Suppliers has been deleted; use IfcRelAssignsToResource to assign an IfcActor to fulfill the role as a supplier.  The attribute UsageRatio has been deleted; use BaseQuantityConsumed and BaseQuantityProduced to indicate material usage.
/// 
/// Occurrences of IfcConstructionMaterialResource are consumed (wholly or partially), or occupied during a construction work task (IfcTask). 
/// 
/// Similar to IfcConstructionProductResource, sometimes things such as 5000kg of gravel are already instantiated as an IfcProduct because it is a result of a work task (for example, &#145;transporting gravel&#146;). In this case, the instance of IfcConstructionMaterialResource can be associated with the product instance &#145;5000kg of gravel&#146; to provide more information for resource uses. Nevertheless, IfcConstructionMaterialResource should only be used to represent resource usage (for example &#145;gravel&#146;), but not product substances (for example, &#145;5000kg of gravel&#146;). 
/// Note: This class is not the same as IfcMaterial; the former can typically represent the type of bulk materials such as sand, gravels, nails and so on (note these can be instantiated from IfcProduct as well depending their uses in the system) used in a construction process. The latter is about physical materials used in a physical building element typically with detailed positioning (e.g. offset) and layering information.
/// Quantities for an IfcConstructionMaterialResource are defined through IfcRelDefinesByProperty and use IfcElementQuantity.
/// 
/// Use definitions for composition, assignment, constraints, time series, and baselines are described at the base type IfcConstructionResource.
/// 
/// Type use definition
/// IfcConstructionMaterialResource defines the occurrence of any material resource; common information about material resource types is handled by IfcConstructionMaterialResourceType.  The IfcConstructionMaterialResourceType (if present) may establish the common type name, common properties, and common productivities for various task types using IfcRelAssignsToProcess.  The IfcConstructionMaterialResourceType is attached using the IfcRelDefinesByType.RelatingType objectified relationship and is accessible by the inverse IsTypedBy attribute.
/// 
/// Quantity use definition
/// The quantities relating to the IfcConstructionMaterialResource are defined by IfcElementQuantity and attached by the IfcRelDefinesByProperties relationship. It is accessible by the inverse IsDefinedBy relationship. The following base quantities are defined and should be exchanged with the IfcElementQuantity.Name = 'BaseQuantities'. Other quantities can be defined being subjected to local standard of measurement with another string value assigned to Name and a value provided for MethodOfMeasurement.
/// 
/// Qto_ConstructionMaterialResourceBaseQuantities: base quantities for all construction material resources.
/// 
/// Assignment use definition
/// In addition to assignments specified at the base class IfcConstructionResource, a construction material resource may have assignments of its own using IfcRelAssignsToResource where RelatingResource refers to the IfcConstructionMaterialResource and RelatedObjects contains one or more IfcProduct subtypes as shown in Figure 184.  Such relationship indicates the physical material used as input for the resource.  Such products are not contained within a building structure but are referenced within a construction spatial zone, specifically IfcSpatialZone with PredefinedType=CONSTRUCTION, which is aggregated within the IfcProject.  The IfcGeographicElement object is used to represent the physical material occurrence, which may optionally have placement and representation indicating intended storage on the construction site.  There may be multiple chains of production such that the assigned product material(s) may have their own task and resource assignments for transporting or extracting such material.
/// 
/// Figure 184 — Construction material resource assignment
class IFC_PARSE_API IfcConstructionMaterialResource : public IfcConstructionResource {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcConstructionMaterialResource
    bool hasPredefinedType() const;
    /// Defines types of construction material resources.
    /// IFC2x4 New attribute
    IfcConstructionMaterialResourceTypeEnum::IfcConstructionMaterialResourceTypeEnum PredefinedType() const;
    void setPredefinedType(IfcConstructionMaterialResourceTypeEnum::IfcConstructionMaterialResourceTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 11; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 10: return IfcUtil::Argument_ENUMERATION; } return IfcConstructionResource::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 10: return Type::IfcConstructionMaterialResourceTypeEnum; } return IfcConstructionResource::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 10: return "PredefinedType"; } return IfcConstructionResource::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcConstructionMaterialResource (IfcEntityInstanceData* e);
    IfcConstructionMaterialResource (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, boost::optional< std::string > v6_Identification, boost::optional< std::string > v7_LongDescription, IfcResourceTime* v8_Usage, boost::optional< IfcTemplatedEntityList< IfcAppliedValue >::ptr > v9_BaseCosts, IfcPhysicalQuantity* v10_BaseQuantity, boost::optional< IfcConstructionMaterialResourceTypeEnum::IfcConstructionMaterialResourceTypeEnum > v11_PredefinedType);
    typedef IfcTemplatedEntityList< IfcConstructionMaterialResource > list;
};
/// IfcConstructionProductResource defines the role of a product that is consumed (wholly or partially), or occupied in the performance of construction. 
/// 
/// HISTORY: New Entity in IFC Release 2.0. Renamed from IfcProductResource in IFC 2x.  Base type and documentation extended in IFC2x4.
/// 
/// Occurrences of IfcConstructionProductResource are usage of products to assist the process of construction. More specifically, they are usage of products that result from some construction processes and that are then used as resources to facilitate further construction. For instance, formworks can be instantiated as products resulting from the process &#145;constructing formwork&#146;. However, they are used as resources in the process &#145;pouring concrete&#146; in a later stage of the project. IfcConstructionProductResource occurrences  are explicitly instances of IfcProduct and may be drawn from various of the subtypes, for instance IfcElementComponent, IfcElementAssembly, IfcProxy (for particular cases where more precise usage details are not available).  The product that is used as a construction resource is referenced using the IfcRelAssignsToResource.RelatedObjects relationship. 
/// 
/// Use definitions for composition, assignment, constraints, time series, and baselines are described at the base type IfcConstructionResource.
/// 
/// Type use definition
/// IfcConstructionProductResource defines the occurrence of any product resource; common information about product resource types is handled by IfcConstructionProductResourceType.  The IfcConstructionProductResourceType (if present) may establish the common type name, common properties, and common productivities for various task types using IfcRelAssignsToProcess.  The IfcConstructionProductResourceType is attached using the IfcRelDefinesByType.RelatingType objectified relationship and is accessible by the inverse IsTypedBy attribute.
/// 
/// Assignment use definition
/// In addition to assignments specified at the base class IfcConstructionResource, a construction product resource may have assignments of its own using IfcRelAssignsToResource where RelatingResource refers to the IfcConstructionProductResource and RelatedObjects contains one or more IfcProduct subtypes as shown in Figure 185.  Such relationship indicates the products used as input for the resource.  Such products are not contained within a building structure but are referenced within a construction spatial zone, specifically IfcSpatialZone with PredefinedType=CONSTRUCTION, which is aggregated within the IfcProject.  There may be multiple chains of production such that the assigned products may have their own task and resource assignments.
/// 
/// Figure 185 — Construction product resource assignment
class IFC_PARSE_API IfcConstructionProductResource : public IfcConstructionResource {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcConstructionProductResource
    bool hasPredefinedType() const;
    /// Defines types of construction product resources.
    /// IFC2x4 New attribute
    IfcConstructionProductResourceTypeEnum::IfcConstructionProductResourceTypeEnum PredefinedType() const;
    void setPredefinedType(IfcConstructionProductResourceTypeEnum::IfcConstructionProductResourceTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 11; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 10: return IfcUtil::Argument_ENUMERATION; } return IfcConstructionResource::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 10: return Type::IfcConstructionProductResourceTypeEnum; } return IfcConstructionResource::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 10: return "PredefinedType"; } return IfcConstructionResource::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcConstructionProductResource (IfcEntityInstanceData* e);
    IfcConstructionProductResource (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, boost::optional< std::string > v6_Identification, boost::optional< std::string > v7_LongDescription, IfcResourceTime* v8_Usage, boost::optional< IfcTemplatedEntityList< IfcAppliedValue >::ptr > v9_BaseCosts, IfcPhysicalQuantity* v10_BaseQuantity, boost::optional< IfcConstructionProductResourceTypeEnum::IfcConstructionProductResourceTypeEnum > v11_PredefinedType);
    typedef IfcTemplatedEntityList< IfcConstructionProductResource > list;
};
/// The energy conversion device type IfcCooledBeamType defines commonly shared information for occurrences of cooled beams.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a cooled beam specification (i.e. the specific product information, that is common to all occurrences of that product type).  Cooled Beam types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcCooledBeamType are represented by instances of IfcCooledBeam. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcEnergyConversionDeviceType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_CooledBeamTypeCommon 
/// 
/// The following property set definitions are applicable to this entity according to the PredefinedType attribute:  
/// Pset_CooledBeamTypeActive (ACTIVE) 
/// 
/// Material Use Definition 
/// The material of the IfcCooledBeamType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Body': The primary material from which the object is constructed. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcCooledBeamType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcCooledBeam for standard port definitions.
class IFC_PARSE_API IfcCooledBeamType : public IfcEnergyConversionDeviceType {
public:
    /// Defines the type of cooled beam.
    IfcCooledBeamTypeEnum::IfcCooledBeamTypeEnum PredefinedType() const;
    void setPredefinedType(IfcCooledBeamTypeEnum::IfcCooledBeamTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcEnergyConversionDeviceType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcCooledBeamTypeEnum; } return IfcEnergyConversionDeviceType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcEnergyConversionDeviceType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCooledBeamType (IfcEntityInstanceData* e);
    IfcCooledBeamType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcCooledBeamTypeEnum::IfcCooledBeamTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcCooledBeamType > list;
};
/// The energy conversion device type IfcCoolingTowerType defines commonly shared information for occurrences of cooling towers.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a cooling tower specification (i.e. the specific product information, that is common to all occurrences of that product type).  Cooling Tower types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcCoolingTowerType are represented by instances of IfcCoolingTower. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcEnergyConversionDeviceType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_CoolingTowerTypeCommon 
/// 
/// Material Use Definition 
/// The material of the IfcCoolingTowerType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Casing': Material from which the casing is constructed. 
/// 'Fill': Fill material. 
/// 
/// Composition Use Definition 
/// The IfcCoolingTowerType may be aggregated into components using IfcRelAggregates where RelatingObject refers to the enclosing IfcCoolingTowerType and RelatedObjects contains one or more components.  Components are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Aggregation use is defined for the following predefined types:
/// 
/// MECHANICALFORCEDDRAFT: May contain IfcFan components.  Forces air into the cooling tower. 
/// MECHANICALINDUCEDDRAFT: May contain IfcFan components.  Induces air out of the cooling tower. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcCoolingTowerType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcCoolingTower for standard port definitions.
class IFC_PARSE_API IfcCoolingTowerType : public IfcEnergyConversionDeviceType {
public:
    /// Defines the typical types of cooling towers (e.g., OpenTower, ClosedTower, CrossFlow, etc.).
    IfcCoolingTowerTypeEnum::IfcCoolingTowerTypeEnum PredefinedType() const;
    void setPredefinedType(IfcCoolingTowerTypeEnum::IfcCoolingTowerTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcEnergyConversionDeviceType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcCoolingTowerTypeEnum; } return IfcEnergyConversionDeviceType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcEnergyConversionDeviceType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCoolingTowerType (IfcEntityInstanceData* e);
    IfcCoolingTowerType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcCoolingTowerTypeEnum::IfcCoolingTowerTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcCoolingTowerType > list;
};
/// Definition from ISO 6707-1:1989: term used: Finishing -
/// final coverings and treatments of surfaces and their
/// intersections.
/// A covering is an element which
/// covers some part of another element and is fully dependent on
/// that other element. The IfcCovering defines the occurrence
/// of a covering type, that (if given) is expressed by the
/// IfcCoveringType. Examples of coverings include wall
/// claddings, floorings and suspended ceilings. Coverings are
/// elements with relationships to the covered element and the space
/// on the other side, they may contain openings, assigned by
/// IfcRelVoidsElement, material information, assigned by
/// IfcRelAssociatesMaterial, and others.
/// NOTE A more basic information about claddings,
/// floorings, and ceilings of a space can be attached to
/// IfcSpace's using the Pset_SpaceCommon properties. Then
/// only a name can be provided and the covering quantities would be
/// interpreted from the space quantities.
/// Coverings can be assigned to
/// 
/// a space represented by IfcSpace
/// 
/// using the inverse relationship CoversSpaces pointing
/// to IfcRelCoversSpaces. The space is then accessible via
/// IfcRelCoversSpaces.RelatedSpace. It defines to which space
/// a covering is facing towards.
/// 
/// NOTE The mere containment relationship between an
/// IfcCovering and an IfcSpace is
/// created by using
/// IfcRelContainedInSpatialStructure
/// 
/// a space boundary represented by IfcRelSpaceBoundary
/// 
/// using the inverse relationship ProvidesBoundaries
/// pointing to IfcRelSpaceBoundary. The space is then
/// accessible via IfcRelSpaceBoundary.RelatingSpace.
/// 
/// a building element represented by IfcBuildingElement
/// 
/// using the inverse relationship Covers pointing to
/// IfcRelCoversBldgElements. The building element is then
/// accessible via
/// IfcRelCoversBldgElements.RelatingBuildingElement.
/// 
/// The following guideline shall apply:
/// 
/// (default) if the space has coverings that may not have an own
/// shape representation and no defined relationships to the building
/// elements they cover, then the IfcCovering shall be
/// assigned to IfcSpace using the IfcRelCoversSpaces
/// relationship,
/// if the space has coverings that have an own shape
/// representation and the space has defined space boundaries, then
/// the covering, which relates to that space, may be assigned to the
/// space boundaries using the link
/// toÿIfcRelSpaceBoundary,
/// if the covering does not relate to a space, then the covering
/// should be assigned to the building element or a distribution
/// element using the IfcRelCoversBldgElements
/// relationship.
/// 
/// HISTORY New entity in IFC Release 1.0.
/// IFC2x CHANGE The attribute PredefinedType is now optional and should only be inserted when no type information, given by IfcCoveringType, is assigned to the IfcCovering occurrence by IfcRelDefinesByType.
/// IFC2x4 CHANGE The IfcCovering is restricted to coverings of building elements by having
/// RelatingBuildingElement pointing to IfcBuildingElement.
/// 
/// Type Use Definition
/// The IfcCovering defines the occuurence of any covering,
/// common information about covering types (or styles) is handled by
/// IfcCoveringType. The IfcCoveringType (if present)
/// may establish the commonÿtype name, usage (or predefined) type,
/// common set of properties, common material layer set, and common
/// shape representations (using IfcRepresentationMap). The
/// IfcCoveringType is attached using the
/// IfcRelDefinedByType.RelatingType objectified relationship
/// and is accessible by the inverse IsDefinedBy
/// attribute.
/// As an additional use agreement for standard coverings (i.e.
/// slabs with constant thickness along the extrusion direction), the
/// IfcCoveringType should have a unique
/// IfcMaterialLayerSet, that is referenced by
/// theÿIfcMaterialLayerSetUsage assigned to all occurrences
/// of this covering type.
/// 
/// Figure 91 illustrates assignment of IfcMaterialLayerSetUsage and IfcMaterialLayerSet to the covering type and the covering occurrence.
/// 
/// Figure 91 — Covering material usage
/// 
/// If an IfcCoveringType is assigned to the
/// IfcCovering, the attribute PredefinedType shall not
/// be assigned, or shall be identical to
/// IfcCoveringType.PredefinedType.
/// Property Set Use Definition:
/// The property sets relating to the IfcCovering are
/// defined by the IfcPropertySet and attached by the
/// IfcRelDefinesByProperties relationship. It is accessible
/// by the inverse IsDefinedBy relationship. The following
/// property set definitions specific to the IfcCovering are
/// part of this IFC release:
/// 
/// Pset_CoveringCommon: common property set for all
/// covering occurrences
/// 
/// Pset_CoveringCeiling: specific property set
/// for all occurrences of coverings with the PredefinedType:
/// CEILING
/// Pset_CoveringFlooring: specific property set
/// for all occurrences of coverings with the PredefinedType:
/// FLOORING
/// 
/// Quantity Use Definition:
/// The quantities relating to the IfcCovering are defined
/// by the IfcElementQuantity and attached by the
/// IfcRelDefinesByProperties relationship. It is accessible
/// by the inverse IsDefinedBy relationship. The following
/// base quantities are defined and should be exchanged with the
/// IfcElementQuantity.Name = 'BaseQuantities'. Other
/// quantities can be defined being subjected to local standard of
/// measurement with another string value assigned to Name and
/// a value provided for MethodOfMeasurement. Quantities shall
/// never be assigned to the IfcCoveringType.
/// 
/// Qto_CoveringBaseQuantities: base quantities
/// for all covering occurrences.
/// 
/// Containment Use Definition
/// The IfcCovering has a containment relationship within
/// the hierarchical spatial structure.
/// 
/// The IfcCovering is places within the project spatial
/// hierarchy using the objectified relationship
/// IfcRelContainedInSpatialStructure, referring to it by its
/// inverse attribute SELF\IfcElement.ContainedInStructure.
/// Subtypes of IfcSpatialStructureElement are valid spatial
/// containers, with IfcSpace being the default
/// container.
/// 
/// Geometry Use Definitions
/// The geometric representation of IfcCovering is given by
/// the IfcProductDefinitionShape, allowing multiple geometric
/// representation. Included are:
/// Local Placement
/// The local placement for IfcCovering is defined in its
/// supertype IfcProduct. It is defined by the
/// IfcLocalPlacement, which defines the local coordinate
/// system that is referenced by all geometric representations.
/// 
/// The PlacementRelTo relationship of
/// IfcLocalPlacement shall point (if given) to the same
/// IfcSpatialStructureElement , which is used in the
/// ContainedInStructure inverse attribute, or to a spatial
/// structure element at a higher level, referenced by that.
/// If the IfcCovering, however, is assigned to an
/// IfcBuildingElement, and this element defines its own local
/// placement, than the PlacementRelTo relationship of
/// IfcLocalPlacement shall point (if given) to the local
/// placement of the IfcBuildingElement.
/// If the relative placement is not used, the absolute placement
/// is defined within the world coordinate system.
/// 
/// Geometric Representations
/// The geometric representation of the IfcCovering depends
/// on two criteria:
/// 
/// Does it define an area or a volume?
/// Is the base surface (either the IfcRelSpaceBoundary or
/// the surface of the IfcBuildingElement it relates to) a
/// planar surface or a cylindrical surface?
/// 
/// GeometricSet Representation
/// The 'GeometricSet' geometric representation of
/// IfcCovering supports area definitions as 3D surfaces.ÿ
/// 
/// RepresentationIdentifier : 'Surface'
/// RepresentationType : 'GeometricSet'
/// 
/// The following additional constraints apply to the
/// 'GeometricSet' representation of IfcCovering:
/// 
/// for planar base surfaces - bounded surface
/// representation
/// for cylindrical base surfaces - swept surface
/// representation
/// 
/// Figure 92 illustrates a planar surface representation where the area of IfcCovering is given by an IfcPolyLoop for planar base surfaces (here given by the IfcRelSpaceBoundary).
/// 
/// The implicit planar surface of the IfcPolyLoop shall be identical with the planar surface defined by the IfcRelSpaceBoundary.
/// 
/// Figure 92 — Covering surface planar
/// 
/// Figure 93 illustrates a cylindrical surface representation where the area of the IfcCovering is given by an IfcSurfaceOfLinearExtrusion for cylindrical base surfaces (here given by the IfcRelSpaceBoundary - such as caused by a round wall).
/// 
/// The geometry representation of the IfcCovering is given by the IfcTrimmedCurved (the Curve parameter of the
/// IfcArbitraryOpenProfileDef - in cases of faceted representation also an IfcPolyline). It is extruded within the plane of the base surface using the Depth parameter of the IfcSurfaceOfLinearExtrusion.
/// 
/// Figure 93 — Covering surface cylindrical
/// 
/// SweptSolid Representation
/// The 'SweptSolid' geometric representation of
/// IfcCovering supports volume definitions as 3D solids.ÿ
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'SweptSolid'
/// 
/// The following additional constraints apply to the 'SweptSolid'
/// representation of IfcCovering:
/// 
/// for planar base surfaces - swept area representation
/// for cylindrical base surfaces - swept area
/// representation
/// 
/// Figure 94 illustrates a body representation where the volume of IfcCovering is given by an IfcExtrudedAreaSolid for planar base surfaces (here given by the IfcRelSpaceBoundary).
/// 
/// The extruded area (IfcArbitraryClosedProfileDef) shall be coplanar to the surface defined by the IfcRelSpaceBoundary.
/// 
/// Figure 94 — Covering body planar
/// 
/// Figure 95 illustrates a body representation where the volume of the IfcCovering is given by an IfcExtrudedAreaSolid for cylindrical base surfaces (here given by the IfcRelSpaceBoundary - such as caused by a round wall).
/// 
/// The geometry representation of the IfcCovering is given by the IfcCompositeCurve (the OuterCurve parameter of the
/// IfcArbitraryClosedProfileDef - in cases of faceted representation also a closed IfcPolyline). It is extruded along the plane of the base surface using the Depth parameter of the IfcSurfaceOfLinearExtrusion.
/// 
/// Figure 95 — Covering body circular
class IFC_PARSE_API IfcCovering : public IfcBuildingElement {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcCovering
    bool hasPredefinedType() const;
    /// Predefined types to define the particular type of the covering. There may be property set definitions available for each predefined type.
    IfcCoveringTypeEnum::IfcCoveringTypeEnum PredefinedType() const;
    void setPredefinedType(IfcCoveringTypeEnum::IfcCoveringTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcBuildingElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcCoveringTypeEnum; } return IfcBuildingElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "PredefinedType"; } return IfcBuildingElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcRelCoversSpaces >::ptr CoversSpaces() const; // INVERSE IfcRelCoversSpaces::RelatedCoverings
    IfcTemplatedEntityList< IfcRelCoversBldgElements >::ptr CoversElements() const; // INVERSE IfcRelCoversBldgElements::RelatedCoverings
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCovering (IfcEntityInstanceData* e);
    IfcCovering (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcCoveringTypeEnum::IfcCoveringTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcCovering > list;
};
/// Definition from ISO 6707-1:1989: Non load bearing wall
/// positioned on the outside of a building and enclosing it.
/// A curtain wall is an exterior wall of a building which is
/// an assembly of components, hung from the edge of the floor/roof
/// structure rather than bearing on a floor. Curtain wall is
/// represented as a building element assembly and implemented as a
/// subtype of IfcBuildingElement that uses an
/// IfcRelAggregates relationship.
/// HISTORY New Entity in IFC Release 2.0
/// 
/// Type Use Definition
/// IfcCurtainWall defines the occuurence of any curtain
/// wall, common information about curtain wall types (or styles) is
/// handled by IfcCurtainWallType. The
/// IfcCurtainWallType (if present) may establish the
/// commonÿtype name, usage (or predefined) type, common material
/// information, common set of properties and common shape
/// representations (using IfcRepresentationMap). The
/// IfcCurtainWallType is attached using the
/// IfcRelDefinedByType.RelatingType objectified relationship
/// and is accessible by the inverse IsDefinedBy
/// attribute.
/// If no IfcCurtainWallType is attachedÿ(i.e. if only
/// occurrence information is given) the predefined type may be given
/// by using the ObjectType attribute.
/// NOTE Since the IfcCurtainWall might be
/// represented as an aggregate of parts, e.g. represented by
/// IfcMember, or IfcPlate, these individual parts may
/// have type information attached (represented e.g. by
/// IfcMemberType, or
/// IfcPlateType).
/// Property Set Use Definition:
/// The property sets relating to the IfcCurtainWall are
/// defined by the IfcPropertySet and attached by the
/// IfcRelDefinesByProperties relationship. It is accessible
/// by the inverse IsDefinedBy relationship. The following
/// property set definitions specific to the IfcCurtainWall
/// are part of this IFC release:
/// 
/// Pset_CurtainWallCommon: common property set
/// for all curtain wall occurrences
/// 
/// Quantity Use Definition
/// The quantities relating to the IfcCurtainWall are
/// defined by the IfcElementQuantity and attached by the
/// IfcRelDefinesByProperties relationship. It is accessible
/// by the inverse IsDefinedBy relationship. The following
/// base quantities are defined and should be exchanged with the
/// IfcElementQuantity.Name = 'BaseQuantities'. Other
/// quantities can be defined being subjected to local standard of
/// measurement with another string value assigned to Name and
/// a value provided for MethodOfMeasurement. Quantities shall
/// never be assigned to the IfcCurtainWallType.
/// 
/// Qto_CurtainWallBaseQuantities: base
/// quantities for all curtain wall occurrences.
/// 
/// Geometry Use Definitions:
/// The geometric representation of IfcCurtainWall is given
/// by the IfcProductDefinitionShape, allowing multiple
/// geometric representations. Independent geometric representations,
/// as described below, should only be used when the
/// IfcCurtainWall is not defined as an aggregate. If defined
/// as an aggregate, the geometric representation is the sum of the
/// representations of the components within the aggregate.
/// Local placement
/// The local placement for IfcCurtainWall is defined in
/// its supertype IfcProduct. It is defined by the
/// IfcLocalPlacement, which defines the local coordinate
/// system that is referenced by all geometric representations.
/// 
/// The PlacementRelTo relationship of
/// IfcLocalPlacement shall point (if given) to the same
/// IfcSpatialStructureElement that is used in the
/// ContainedInStructure inverse attribute or to a referenced
/// spatial structure element at a higher level.
/// If the relative placement is not used, the absolute placement
/// is defined within the world coordinate system.
/// 
/// If the IfcCurtainWall establishes an aggregate, then
/// all contained elements (defined by the IsDecomposedBy
/// inverse attribute) shall be placed relative to the
/// IfcCurtainWall.ObjectPlacement.
/// Geometric Representation
/// The geometric representation of IfcCurtainWall is
/// defined using the following multiple shape representations for
/// its definition:
/// 
/// Axis: A two-dimensional open curve (for restrictions see
/// below) defining the axis for the curtain wall.
/// 
/// This is an optional representation for curtain walls.
/// 
/// Body: A surface model or boundary representation model
/// representation defining the 3D shape of the curtain wall.
/// 
/// If the IfcCurtainWall has components (referenced by
/// SELF\IfcObject.IsDecomposedBy) then no independent shape
/// representation with RepresentationType = 'Body' shall be
/// defined. The body of IfcCurtainWall is then geometrically
/// represented by the shape representation of its components. The
/// components are accessed via
/// SELF\IfcObject.IsDecomposedBy[1].RelatedObjects.
/// 
/// If the IfcCurtainWall has no components defined (empty
/// set of SELF\IfcObject.IsDecomposedBy) then the
/// IfcCurtainWall may be represented by an shape
/// representation with the RepresentationIdentifier =
/// 'Body'.
/// 
/// Axis Representation
/// The axis geometric representation of IfcCurtainWall is
/// defined using the 'Axis' representation. The following attribute
/// values for the IfcShapeRepresentation holding this
/// geometric representation shall be used:
/// 
/// RepresentationIdentifier : 'Axis'
/// RepresentationType : 'Curve2D'
/// 
/// The following additional constraints apply to the 'Axis'
/// representation:
/// 
/// Axis : IfcPolyline having two Points, or
/// IfcTrimmedCurve with BasisCurve of Type
/// IfcLine or IfcCircle.
/// 
/// Body Representation
/// The body shape representation of IfcCurtainWall is
/// defined using the 'Body' representation. The following attribute
/// values for the IfcShapeRepresentation holding this
/// geometric representation shall be used:
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'SurfaceModel', 'Brep' and
/// 'MappedRepresentation'
/// 
/// An own 'Body' representation shall only be included if no
/// components of the curtain wall are defined.
class IFC_PARSE_API IfcCurtainWall : public IfcBuildingElement {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcCurtainWall
    bool hasPredefinedType() const;
    /// Predefined generic type for a curtain wall that is specified in an enumeration. There may be a property set given specificly for the predefined types.
    ///   NOTE The PredefinedType shall only be used, if no type object IfcCurtainWallType is assigned, providing its own IfcCurtainWallType.PredefinedType.
    /// 
    /// IFC2x4 CHANGE  The attribute has been added at the end of the entity definition.
    IfcCurtainWallTypeEnum::IfcCurtainWallTypeEnum PredefinedType() const;
    void setPredefinedType(IfcCurtainWallTypeEnum::IfcCurtainWallTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcBuildingElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcCurtainWallTypeEnum; } return IfcBuildingElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "PredefinedType"; } return IfcBuildingElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCurtainWall (IfcEntityInstanceData* e);
    IfcCurtainWall (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcCurtainWallTypeEnum::IfcCurtainWallTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcCurtainWall > list;
};
/// The flow controller type IfcDamperType defines commonly shared information for occurrences of dampers.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a damper specification (i.e. the specific product information, that is common to all occurrences of that product type).  Damper types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcDamperType are represented by instances of IfcDamper. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcFlowControllerType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_DamperTypeCommon 
/// 
/// The following property set definitions are applicable to this entity according to the PredefinedType attribute:  
/// Pset_DamperTypeControlDamper (CONTROLDAMPER) 
/// Pset_DamperTypeFireDamper (FIREDAMPER) 
/// Pset_DamperTypeFireSmokeDamper (FIRESMOKEDAMPER) 
/// Pset_DamperTypeSmokeDamper (SMOKEDAMPER) 
/// 
/// Material Use Definition 
/// The material of the IfcDamperType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Blade': The material from which the damper blades are constructed. 
/// 'Frame': The material from which the damper frame is constructed. 
/// 'Seal': The material from which the damper seals are constructed. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcDamperType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcDamper for standard port definitions.
class IFC_PARSE_API IfcDamperType : public IfcFlowControllerType {
public:
    /// Type of damper.
    IfcDamperTypeEnum::IfcDamperTypeEnum PredefinedType() const;
    void setPredefinedType(IfcDamperTypeEnum::IfcDamperTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcFlowControllerType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcDamperTypeEnum; } return IfcFlowControllerType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcFlowControllerType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcDamperType (IfcEntityInstanceData* e);
    IfcDamperType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcDamperTypeEnum::IfcDamperTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcDamperType > list;
};
/// Definition from IAI: Representation of different kinds of
///   accessories included in or added to elements.  
///   HISTORY New entity in IFC
///   Release 2x2 
/// 
/// IFC 2x4 change:
/// Attribute PredefinedType added.
/// 
/// General usage 
///   The exact type information of the IfcDiscreteAccessory is given
///   in the ObjectType attribute inherited from IfcObject. Standard
///   type designations are provided for guideline below. The list is not exhaustive
///   and the list of definitions may be extended based on local national extensions.
/// 
/// Accessory type 
///   Standard type designation 
///   Description 
/// 
/// Shading devices:
///   'Shading device'
///   Elements specifically designed to provide shading, often fixed
///   externally and sometimes moving (e.g. by rotation)
/// 
/// Corbels as separate components: 
///   'Hidden steel corbel' 
///   Corbel system made from steel components embedded into the master
///   element 
/// 
/// 'Visible steel corbel' 
///   Corbel system made from steel components protruding from the master
///   element 
/// 
/// 'Visible concrete corbel' 
///   Corbel system made as a separate precast concrete component added
///   to the master element 
/// 
/// 'Ladder truss connector' 
///   A fixing device in truss form with straight cross bars in ladder
///   form holding two precast conrete panels together in a sandwich wall panel.
/// 
/// 'Panel suspender' 
///   A straight fixing device holding two precast conrete panels
///   together in a sandwich wall panel. 
/// 
/// Electrical accessories for precast concrete elements: 
///   'Protective plug' 
///   Protective plug used in element for protecting electrical
///   accessories during manufacturing, transportation and assembly. 
/// 
/// Fixing parts: 
///   'Standard fixing plate' 
///   Standard fixing plate. 
/// 
/// 'Edge fixing plate' 
///   Fixing plate attached to the edge of an element. 
/// 
/// 'Corner fixing plate' 
///   Fixing plate attached to the corner of an element. 
/// 
/// 'Slab fixing plate' 
///   Fixing plate for slabs. 
/// 
/// 'Balcony hinge' 
///   Accessory supporting and fixing balconies. 
/// 
/// 'Frame shoe' 
///   Fixing shoe for frames. 
/// 
/// 'Thermo frame' 
///   Thermo frame. 
/// 
/// 'Column shoe' 
///   Fixing shoe for columns. 
/// 
/// 'Wall shoe' 
///   Fixing shoe for walls. 
/// 
/// 'Fixing socket' 
///   Fixing socket. 
/// 
/// Joint accessories: 
///   'Neoprene bearing plate' 
///   Rubber plate used as a bearing in, for example, joints between
///   column corbels and beams. 
/// 
/// 'Working joint reinforcement' 
///   Reinforcement accessory used in working joints. 
/// 
/// 'Expansion joint reinforcement' 
///   Reinforcement accessory used in expansion joints. 
/// 
/// 'Ribbed steel bar extension' 
///   Extension accessory made of a ribbed (reinforcement) bar used in
///   joints. 
/// 
/// 'Steel pin bolt' 
///   Pin bolt used to join together, for example, columns and
///   beams. 
/// 
/// 'Concrete dowel' 
///   Dowel pin used in joints. 
/// 
/// 'Concrete groove' 
///   A groove made in a joint. 
/// 
/// 'Steel plate' 
///   A steel plate used as an accessory in a joint. 
/// 
/// 'Wire loop' 
///   A joint connector accessory made from a wire loop. 
/// 
/// 'Steel loop' 
///   A joint connector accessory made from a steel bar loop. 
/// 
/// 'Sealing strip' 
///   A strip sealing the joint. 
/// 
/// 'Sealing compound' 
///   Sealing compound protecting and sealing the joint. 
/// 
/// Lifting accessories: 
///   'Wire lifting hook' 
///   A lifting aid in the form of a wire loop. 
/// 
/// 'Steel lifting hook' 
///   A lifting aid in the form of a steel bar loop. 
/// 
/// 'Lifting socket' 
///   A lifting aid in the form of a socket. 
/// 
/// 'Steel lifting anchor' 
///   A lifting aid in the form of a steel lifting anchor. 
/// 
/// 'Lifting hole' 
///   A lifting aid in the form of a hole. 
/// 
/// Accessories mainly used in the building services domain: 
///   'Antivibration' 
///   An isolating device to prevent other elements to be effected by
///   vibrations. 
/// 
/// 'Drop rod' 
///   A length of material providing a hanging support to a bracket. Note
///   that a drop rod is considered to include nuts and washers required for
///   securing. 
/// 
/// 'Duct foot' 
///   A base support used to receive a vertical pipe (BS6100 330 3309 -
///   duct foot). 
/// 
/// 'Framing' 
///   A frame placed around a penetration to prevent scraping against the
///   building surface or structure. 
/// 
/// 'Grommet' 
///   An element placed within a penetration that seals the penetration
///   for a particular reason. 
/// 
/// 'Rack' 
///   A set of shelving for the purposes of storage that may be
///   freestanding or bolted to a structure. 
/// 
/// 'Safety part' 
///   A part, typically installed in vertical shafts at each level, to
///   ensure safety from falling when entering the shaft. 
/// 
/// 'Sleeve' 
///   A thin barrier placed between a penetration and a penetrating
///   element. 
/// 
/// 'Support section' 
///   A section of material that is used as an intermediate support upon
///   which multiple brackets can be mounted.
class IFC_PARSE_API IfcDiscreteAccessory : public IfcElementComponent {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcDiscreteAccessory
    bool hasPredefinedType() const;
    /// Subtype of discrete accessory
    IfcDiscreteAccessoryTypeEnum::IfcDiscreteAccessoryTypeEnum PredefinedType() const;
    void setPredefinedType(IfcDiscreteAccessoryTypeEnum::IfcDiscreteAccessoryTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcElementComponent::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcDiscreteAccessoryTypeEnum; } return IfcElementComponent::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "PredefinedType"; } return IfcElementComponent::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcDiscreteAccessory (IfcEntityInstanceData* e);
    IfcDiscreteAccessory (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcDiscreteAccessoryTypeEnum::IfcDiscreteAccessoryTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcDiscreteAccessory > list;
};
/// Definition from IAI: The element type
///   (IfcDiscreteAccessoryType) defines a list of commonly shared property
///   set definitions of a discrete accessory and an optional set of product
///   representations. It is used to define a supporting element mainly within
///   structural and building services domains (i.e. the specific type information
///   common to all occurrences of that type). 
///   The occurrences of the IfcDiscreteAccessoryType are represented
///   by instances of IfcDiscreteAccessory. 
///   The IfcDiscreteAccessoryType is a specialization of the general
///   building element component type to represent different type of structural and
///   building service related auxiliary elements. 
///   HISTORY New entity in IFC
///   Release 2x2 
/// 
/// IFC 2x4 change:
/// Attribute PredefinedType added.
/// 
/// General usage 
///   The exact type information of the IfcDiscreteAccessoryType is
///   given in the ElementType attribute inherited from IfcElementType.
///   Standard type designations are provided for guideline below. The list is not
///   exhaustive and the list of definitions may be extended based on local national
///   extensions.  
/// 
/// Accessory type 
///   Standard type designation 
///   Description 
/// 
/// Shading devices: 
///   'Shading device' 
///   Elements specifically designed to provide shading, often fixed
///   externally and sometimes moving (e.g. by rotation) 
/// 
/// Corbels as separate components: 
///   'Hidden steel corbel' 
///   Corbel system made from steel components embedded into the master
///   element 
/// 
/// 'Visible steel corbel' 
///   Corbel system made from steel components protruding from the master
///   element 
/// 
/// 'Visible concrete corbel' 
///   Corbel system made as a separate precast concrete component added
///   to the master element 
/// 
/// Connecting accessories, for example for sandwich wall panels: 
///   'Diagonal truss connector' 
///   A fixing device in truss form with diagonal cross bars holding two
///   precast conrete panels together in a sandwich wall panel. 
/// 
/// 'Ladder truss connector' 
///   A fixing device in truss form with straight cross bars in ladder
///   form holding two precast conrete panels together in a sandwich wall panel.
/// 
/// 'Panel suspender' 
///   A straight fixing device holding two precast conrete panels
///   together in a sandwich wall panel. 
/// 
/// Electrical accessories for precast concrete elements: 
///   'Protective plug' 
///   Protective plug used in element for protecting electrical
///   accessories during manufacturing, transportation and assembly. 
/// 
/// Fixing parts: 
///   'Standard fixing plate' 
///   Standard fixing plate. 
/// 
/// 'Edge fixing plate' 
///   Fixing plate attached to the edge of an element. 
/// 
/// 'Corner fixing plate' 
///   Fixing plate attached to the corner of an element. 
/// 
/// 'Slab fixing plate' 
///   Fixing plate for slabs. 
/// 
/// 'Balcony hinge' 
///   Accessory supporting and fixing balconies. 
/// 
/// 'Frame shoe' 
///   Fixing shoe for frames. 
/// 
/// 'Thermo frame' 
///   Thermo frame. 
/// 
/// 'Column shoe' 
///   Fixing shoe for columns. 
/// 
/// 'Wall shoe' 
///   Fixing shoe for walls. 
/// 
/// 'Fixing socket' 
///   Fixing socket. 
/// 
/// Joint accessories: 
///   'Neoprene bearing plate' 
///   Rubber plate used as a bearing in, for example, joints between
///   column corbels and beams. 
/// 
/// 'Working joint reinforcement' 
///   Reinforcement accessory used in working joints. 
/// 
/// 'Expansion joint reinforcement' 
///   Reinforcement accessory used in expansion joints. 
/// 
/// 'Ribbed steel bar extension' 
///   Extension accessory made of a ribbed (reinforcement) bar used in
///   joints. 
/// 
/// 'Steel pin bolt' 
///   Pin bolt used to join together, for example, columns and
///   beams. 
/// 
/// 'Concrete dowel' 
///   Dowel pin used in joints. 
/// 
/// 'Concrete groove' 
///   A groove made in a joint. 
/// 
/// 'Steel plate' 
///   A steel plate used as an accessory in a joint. 
/// 
/// 'Wire loop' 
///   A joint connector accessory made from a wire loop. 
/// 
/// 'Steel loop' 
///   A joint connector accessory made from a steel bar loop. 
/// 
/// 'Sealing strip' 
///   A strip sealing the joint. 
/// 
/// 'Sealing compound' 
///   Sealing compound protecting and sealing the joint. 
/// 
/// Lifting accessories: 
///   'Wire lifting hook' 
///   A lifting aid in the form of a wire loop. 
/// 
/// 'Steel lifting hook' 
///   A lifting aid in the form of a steel bar loop. 
/// 
/// 'Lifting socket' 
///   A lifting aid in the form of a socket. 
/// 
/// 'Steel lifting anchor' 
///   A lifting aid in the form of a steel lifting anchor. 
/// 
/// 'Lifting hole' 
///   A lifting aid in the form of a hole. 
/// 
/// Accessories mainly used in the building services domain: 
///   'Antivibration' 
///   An isolating device to prevent other elements to be effected by
///   vibrations. 
/// 
/// 'Drop rod' 
///   A length of material providing a hanging support to a bracket. Note
///   that a drop rod is considered to include nuts and washers required for
///   securing. 
/// 
/// 'Duct foot' 
///   A base support used to receive a vertical pipe (BS6100 330 3309 -
///   duct foot). 
/// 
/// 'Framing' 
///   A frame placed around a penetration to prevent scraping against the
///   building surface or structure. 
/// 
/// 'Grommet' 
///   An element placed within a penetration that seals the penetration
///   for a particular reason. 
/// 
/// 'Rack' 
///   A set of shelving for the purposes of storage that may be
///   freestanding or bolted to a structure. 
/// 
/// 'Safety part' 
///   A part, typically installed in vertical shafts at each level, to
///   ensure safety from falling when entering the shaft. 
/// 
/// 'Sleeve' 
///   A thin barrier placed between a penetration and a penetrating
///   element. 
/// 
/// 'Support section' 
///   A section of material that is used as an intermediate support upon
///   which multiple brackets can be mounted.
class IFC_PARSE_API IfcDiscreteAccessoryType : public IfcElementComponentType {
public:
    /// Subtype of discrete accessory
    IfcDiscreteAccessoryTypeEnum::IfcDiscreteAccessoryTypeEnum PredefinedType() const;
    void setPredefinedType(IfcDiscreteAccessoryTypeEnum::IfcDiscreteAccessoryTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcElementComponentType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcDiscreteAccessoryTypeEnum; } return IfcElementComponentType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcElementComponentType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcDiscreteAccessoryType (IfcEntityInstanceData* e);
    IfcDiscreteAccessoryType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcDiscreteAccessoryTypeEnum::IfcDiscreteAccessoryTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcDiscreteAccessoryType > list;
};
/// The distribution flow element type IfcDistributionChamberElementType defines commonly shared information for occurrences of distribution chamber elements.  The set of shared information may include:
/// 
/// common properties with shared property sets
/// common materials
/// common ports
/// common composition of elements
/// common assignment of process types
/// common representations of shape and style
/// 
/// It is used to define a distribution chamber element specification (i.e. the specific product information, that is common to all occurrences of that product type).  Distribution Chamber Element types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcDistributionChamberElementType are represented by instances of IfcDistributionChamberElement.
/// 
/// HISTORY: New entity in IFC2x2
/// 
/// Property Set Use Definition
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcDistributionFlowElementType and ancestors for inherited property set definitions.
/// The following property set definitions are applicable to this entity:
/// Pset_DistributionChamberElementCommon
/// 
/// The following property set definitions are applicable to this entity according to the PredefinedType attribute: 
/// 
/// Pset_DistributionChamberElementTypeFormedDuct (FORMEDDUCT)
/// Pset_DistributionChamberElementTypeInspectionChamber (INSPECTIONCHAMBER)
/// Pset_DistributionChamberElementTypeInspectionPit (INSPECTIONPIT)
/// Pset_DistributionChamberElementTypeManhole (MANHOLE)
/// Pset_DistributionChamberElementTypeMeterChamber (METERCHAMBER)
/// Pset_DistributionChamberElementTypeSump (SUMP)
/// Pset_DistributionChamberElementTypeTrench (TRENCH)
/// Pset_DistributionChamberElementTypeValveChamber (VALVECHAMBER)
/// 
/// Material Use Definition
/// The material of the IfcDistributionChamberElementType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used:
/// 
/// 'Base': The material from which the base of the duct is constructed.
/// 'Cover': The material from which the access cover to the chamber is constructed.
/// 'Fill': The material that is used to fill the duct (where used).
/// 'Wall': The material from which the wall of the duct is constructed.
class IFC_PARSE_API IfcDistributionChamberElementType : public IfcDistributionFlowElementType {
public:
    /// Predefined types of distribution chambers.
    IfcDistributionChamberElementTypeEnum::IfcDistributionChamberElementTypeEnum PredefinedType() const;
    void setPredefinedType(IfcDistributionChamberElementTypeEnum::IfcDistributionChamberElementTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcDistributionFlowElementType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcDistributionChamberElementTypeEnum; } return IfcDistributionFlowElementType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcDistributionFlowElementType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcDistributionChamberElementType (IfcEntityInstanceData* e);
    IfcDistributionChamberElementType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcDistributionChamberElementTypeEnum::IfcDistributionChamberElementTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcDistributionChamberElementType > list;
};
/// The element type IfcDistributionControlElementType defines a list of commonly shared property set definitions of an element and an optional set of product representations.  It is used to define an element specification (the specific product information that is common to all occurrences of that product type). 
/// 
/// Distribution control element types (or the instantiable subtypes) may be exchanged without being already assigned to occurrences. 
/// 
/// The occurrences of the IfcDistributionControlElementType are represented by instances of IfcDistributionControlElement or its subtypes. 
/// 
/// HISTORY: New entity in IFC Release 2x2.
/// 
/// Declaration Use Definition
/// The IfcDistributionControlElementType may be declared within a project or project library using IfcRelDeclares where RelatingContext refers to the project or library and RelatedDefinitions includes the element type.  Inclusion within IfcProject indicates the type is editable within the direct project and may be available to other referencing projects that may incorporate the type.  Inclusion within IfcProjectLibrary indicates the type is incorporated from a referenced project.  Default units and coordinate systems (used for representations, materials, and property sets) are indicated by the declaring project or library.
/// 
/// Classification Use Definition
/// The IfcDistributionControlElementType may be classified using IfcRelAssociatesClassification where RelatingClassification refers to an IfcClassificationReference indicating a classification notation. Classifications may refer to industry standards such as MasterFormat, OmniFormat, or UniFormat.  Classifications may also refer to organization-specific, project-specific, or system-specific designations.  Classification reference identification schemes are described by IfcClassification.ReferenceTokens.
/// 
/// Document Use Definition
/// The IfcDistributionControlElementType may be documented using IfcRelAssociatesDocument where RelatingDocument refers to an IfcDocumentReference indicating content within a document, or IfcDocumentInformation indicating an entire document. Document information may refer to arbitrary attachments such as text or multimedia, while document references may refer to items within particular formats (such as XML element IDs) where there is need to synchronize document information with model information.  Document reference identification schemes depend on the particular document format.
/// 
/// Library Use Definition
/// The IfcDistributionControlElementType may be published to a model server using IfcRelAssociatesLibrary where RelatingLibrary refers to an IfcLibraryReference indicating the unique identification within the published project.  If the published project is IFC format, then IfcLibraryReference.Identification shall match IfcRoot.GlobalID of the published (master) project, using the same encoding as described for IfcGloballyUniqueId.  Multiple library references may be provided to indicate alternate names and descriptions for particular languages.  If the element type is declared within IfcProject, then IfcLibraryInformation.Location and IfcLibraryInformation.Version indicate the URL and version as last published.  If the element type is declared within IfcProjectLibrary, then the library information indicates the location and version of the definition as last retrieved.
/// 
/// Composition Use Definition
/// The IfcDistributionControlElementType may be decomposed into components using IfcRelAggregates where RelatingObject refers to the enclosing IfcDistributionFlowElementType and RelatedObjects contains one or more components.  For example, a thermostat type may be decomposed into temperature sensors.  Standard types for composition are defined at occurrences for subtypes.
/// 
/// Connection Use Definition
/// The IfcDistributionControlElementType may be connected to other objects as follows using the indicated relationship:
/// 
/// IfcDistributionPort (IfcRelConnectsPortToElement) : Indicates port definitions on the element to be instantiated at occurrences.  Standard port names, types, and directions are defined at occurrences for subtypes.
/// 
/// Assignment Use Definition
///   The IfcDistributionControlElementType may have assignments of its own using the IfcRelAssignsToProduct relationship where RelatingProduct refers to the IfcDistributionControlElementType and RelatedObjects contains one or more objects of the following types: 
/// 
/// IfcTaskType: Indicates task types available to purchase, install, renovate, demolish, operate, or otherwise act upon occurrences of the element type.  Such task types may be instantiated as task occurrences assigned to occurrences of the element type.  Prices (such as for purchasing or shipping) may be established by resource types assigned to task types.
/// IfcProcedureType: Indicates procedure types available to operate occurrences of the element type.  Such procedure types may be instantiated as procedure occurrences assigned to occurrences of the element type.
/// IfcEventType: Indicates event types available to be raised by occurrences of the element, sequenced by procedures to be followed.  Such event types may be instantiated as event occurrences assigned to occurrences of the element type.
/// 
/// Material Use Definition
/// The material of the IfcDistributionControlElementType is defined using one of the following entities:
/// 
/// IfcMaterialConstituentSet: For elements containing multiple materials, this indicates materials at named aspects.
/// 
/// IfcMaterial: For elements comprised of a single material, this indicates the material.
/// 
/// The material is attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.
/// 
/// Representation Use Definition
/// The following shape representations are supported for subtypes of IfcDistributionControlElementType, distinguished by IfcShapeRepresentation.RepresentationIdentifier:
/// 
/// 'Footprint': Represents the 2D footprint outline of the item having IfcShapeRepresentation.RepresentationType of 'GeometricCurveSet' and containing a single IfcGeometricCurveSet consisting of one or more IfcCurve subtypes such as IfcPolyline, IfcTrimmedCurve, IfcCompositeCurve, or IfcCircle.
/// 
/// 'Body': Represents the 3D shape of the item having IfcShapeRepresentation.RepresentationType of 'SurfaceModel', 'SolidModel', or any solid model specializations including 'Brep', 'AdvancedBrep', 'SweptSolid', 'AdvancedSweptSolid', 'CSG', 'Clipping', or 'SectionedSpine').
/// 
/// 'Clearance': Represents the 3D clearance volume of the item having RepresentationType of 'Surface3D'.  Such clearance region indicates space that should not intersect with the 'Body' representation between element occurrences, though may intersect with the 'Clearance' representation of other element occurrences.  The particular use of clearance space may be for safety, maintenance, or other purpose.
/// 
/// NOTE: The product representations are defined as representation maps (at the level of the supertype IfcTypeProduct, which get assigned by an element occurrence instance through the IfcShapeRepresentation.Item[1] being an IfcMappedItem.
class IFC_PARSE_API IfcDistributionControlElementType : public IfcDistributionElementType {
public:
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcDistributionElementType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcDistributionElementType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcDistributionElementType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcDistributionControlElementType (IfcEntityInstanceData* e);
    IfcDistributionControlElementType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType);
    typedef IfcTemplatedEntityList< IfcDistributionControlElementType > list;
};
/// Definition from IAI: Generalization of all elements
/// that participate in a distribution system. Typical examples of
/// IfcDistributionElement are (among others):
/// 
/// building service elements within a heating systems
/// building service elements within a cooling system
/// building service elements within a ventilation system
/// building service elements within a plumbing system
/// 
/// e.g. sanitary elements, fire suppression elements
/// 
/// electrical elements
/// elements within a communication network
/// 
/// The IfcDistributionElement is further specialized in
/// the IFC model. Direct instantiation of
/// IfcDistributionElement without an assigned subtype of
/// IfcDistributionElementType provides the meaning of an
/// distribution element proxy.
/// HISTORY New entity in
/// IFC Release 1.5.
/// IFC2x4 CHANGE The entity is marked
/// as deprecated for instantiation - will be made ABSTRACT after
/// IFC2x4.
/// Relationship Use Definition
/// 
/// Ports - information, whether the distribution element has
/// ports for system connections
/// 
/// objectified relationship:
/// IfcRelConnectsPortToElement
/// object referenced by relationship: IfcPort
/// inverse attribute: HasPorts
/// 
/// Type Use Definition
/// The IfcDistributionElement defines the occurrence of
/// any HVAC, electrical, sanitary or other element within a
/// distribution system. Common information about distribution
/// element types (or styles) is handled by subtypes of
/// IfcDistributionElementType. The
/// IfcDistributionElementType (if present) may establish the
/// common type name, usage (or predefined) type, common material,
/// common set of properties and common shape representations (using
/// IfcRepresentationMap). The
/// IfcDistributionElementType is attached using the
/// IfcRelDefinedByType.RelatingType objectified relationship
/// and is accessible by the inverse IsDefinedBy
/// attribute.
/// The assignment of types to distribution element occurrences is
/// vital for providing the additional meaning, or ontology, of the
/// distribution element. Many specialized type are defined in other
/// schemas of the IFC specification.
/// Quantity Use Definition
/// The quantities relating to the IfcDistributionElement
/// are defined by the IfcElementQuantity and attached by the
/// IfcRelDefinesByProperties. A detailed specification for
/// individual quantities is introduced at the level of subtypes of
/// IfcDistributionElement.
/// Containment Use Definition
/// The IfcDistributionElement may participate in two
/// different containment relationships. The first (and in most
/// implementation scenarios mandatory) relationship is the
/// hierachical spatial containment, the second (optional)
/// relationship is the aggregation within anÿelement assembly.
/// 
/// The IfcDistributionElement is places within the
/// project spatial hierarchy using the objectified relationship
/// IfcRelContainedInSpatialStructure, referring to it by its
/// inverse attribute SELF\IfcElement.ContainedInStructure.
/// Subtypes ofÿIfcSpatialStructureElement are valid spatial
/// containers, with IfcSpace being the default
/// container.
/// The IfcDistributionElement may be aggregated into an
/// element assembly using the objectified relationship
/// IfcRelAggregates, referring to it by its inverse attribute
/// SELF\IfcObjectDefinition.Decomposes. Any subtype of
/// IfcElement can be an element assembly, with
/// IfcElementAssembly as a special focus subtype. In this
/// case it should not be additionally contained in the project
/// spatial hierarchy,
/// i.e.ÿSELF\IfcElement.ContainedInStructure should be
/// NIL.
/// 
/// Geometry Use Definitions
/// The geometric representation of IfcDistributionElement
/// is given by the IfcProductDefinitionShape, allowing
/// multiple geometric representation.
/// Local Placement
/// The local placement for IfcDistributionElement is
/// defined in its supertype IfcProduct. It is defined by the
/// IfcLocalPlacement, which defines the local coordinate
/// system that is referenced by all geometric representations.
/// 
/// The PlacementRelTo relationship of
/// IfcLocalPlacement shall point (if given) to the local
/// placement of the same IfcSpatialStructureElement , which
/// is used in the ContainedInStructure inverse attribute, or
/// to a spatial structure element at a higher level, referenced by
/// that.
/// If the relative placement is not used, the absolute placement
/// is defined within the world coordinate system.
/// 
/// Geometric Representations
/// The geometric representation of IfcDistributionElement
/// is defined using different geometric representation types for the
/// various subtypes. Only general recommendations are given at the
/// level of the supertype, further constraints are defined at the
/// level of its subtypes.
/// 
/// all occurrences of IfcDistributionElement (and its
/// subtypes) should (whenever possible) share a representation map
/// established by the assigned type. The geometric representation of
/// the occurrence is then an IfcMappedItem. The
/// IfcShapeRepresentation has:
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'MappedRepresentation'
/// 
/// The shared geometric representation of the distribution
/// element type (or in some cases of the distribution element)
/// should follow (if applicable) the the following guidelines:
/// 
/// all fixtures (all non distribution flow elements, i.e.
/// everything which is not a duct, a pipe, a cable, or a cable
/// carrier) should be defined by an b-rep geometry. This includes
/// also the complex flow fitting elements (e.g. Y branch or T
/// branch) or distribution flow elements with size changes (e.g.
/// reducer). The IfcShapeRepresentation has:
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'Brep'
/// 
/// if the geometric model consistency of a b-rep shape
/// representation can not be guaranteed (arcwise connected volume
/// bounded by faces, each being connected, oriented, finite, closed
/// 2-manifold), a surface representation based on open shells should
/// be used. The IfcShapeRepresentation then has:
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'SurfaceModel'
/// 
/// all "simple" distribution flow elements (general ducts and
/// pipes) are defined by sweep geometry. The
/// IfcShapeRepresentation has:
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'SweptSolid'
/// 
/// an additional representation type for all "simple"
/// distribution flow elements (general ducts and pipes) is the
/// ability to have a simple line based representation. The
/// IfcShapeRepresentation has:
/// 
/// RepresentationIdentifier : 'FootPrint'
/// RepresentationType : 'GeometricCurveSet'
/// 
/// if only the analytical shape is required for which the exact
/// interpolation between the cross sections is not required, a
/// sectioned spine can be used.
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'SectionedSpine'
class IFC_PARSE_API IfcDistributionElement : public IfcElement {
public:
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcRelConnectsPortToElement >::ptr HasPorts() const; // INVERSE IfcRelConnectsPortToElement::RelatedElement
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcDistributionElement (IfcEntityInstanceData* e);
    IfcDistributionElement (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag);
    typedef IfcTemplatedEntityList< IfcDistributionElement > list;
};
/// The distribution element IfcDistributionFlowElement defines occurrence elements of a distribution system that facilitate the distribution of energy or matter, such as air, water or power.
/// 
/// EXAMPLEs of distribution flow elements are ducts, pipes, wires, fittings, and equipment.
/// 
/// HISTORY: New entity in IFC R2.0.
/// 
/// Type Use Definition
/// IfcDistributionFlowElement defines the occurrence of any distribution flow element; common information about distribution flow element types is handled by IfcDistributionFlowElementType.  The IfcDistributionFlowElementType (if present) may establish the common type name, usage (predefined type), properties, materials, ports, composition, assignments, and representations.  The IfcDistributionFlowElementType is attached using the IfcRelDefinesByType objectified relationship and is accessible by the IsTypedBy inverse attribute.  If the IfcDistributionFlowElementType has ports or aggregated elements, such objects are reflected at the IfcDistributionFlowElement occurrence using the IfcRelDefinesByObject relationship.  Direct instantiation of IfcDistributionFlowElement with IfcObject.ObjectType asserted provides the meaning of a distribution flow element proxy.
/// 
/// Property Set Use Definition
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the IfcRelDefinesByProperties relationship. They are accessible by the IsDefinedBy inverse attribute.  Property sets may also be specified at the IfcDistributionFlowElementType, defining the common property data for all occurrences of the same type.  They are then accessible by the IsTypedBy inverse attribute pointing to IfcDistributionFlowElementType.HasPropertySets. If both are given, then the properties directly defined at IfcDistributionFlowElement override the properties defined at IfcDistributionFlowElementType.  Refer to the documentation at the supertype IfcDistributionElement and ancestors for inherited property set definitions.
/// 
/// Composition Use Definition
/// The IfcDistributionFlowElement may be decomposed into components using IfcRelAggregates where RelatingObject refers to the enclosing IfcDistributionFlowElement and RelatedObjects contains one or more components.  For example, a cable may be decomposed into wires.  Standard types for composition are defined at subtypes.
/// 
/// Connection Use Definition
/// The IfcDistributionFlowElement may be connected to other objects as follows using the indicated relationship:
/// 
/// IfcSpatialStructureElement (IfcRelContainedInSpatialStructure) : Indicates the spatial location containing the element.
/// IfcElement (IfcRelConnectsElements) : Indicates physical connectivity with another element (but not embedding or flow transmission), such as a light fixture hanging from a ceiling (IfcCovering), or a junction box having a cover plate (IfcDiscreteAccessory).  IfcRelConnectsElements.RelatingElement refers to the anchored side (ceiling for fixture, junction box for cover).
/// IfcElement (IfcRelInterferesElements) : Indicates interference with another element and precedence, such as a pipe going through a wall.
/// IfcOpening (IfcRelFillsElement) : Indicates embedding an element within another element (implying a cutout), such as an air terminal or junction box embedded within a wall.
/// IfcDistributionPort (IfcRelConnectsPortToElement) : Indicates ports on the element which may be connected to other elements for flow distribution of solids, liquids, gas, or electricity.  Standard port names, types, and directions are defined at subtypes.
/// IfcDistributionControlElement (IfcRelFlowControlElements) : Indicates a control element that senses or controls some aspect of the flow element, such as a level sensor for a tank or an actuator for a valve.
/// 
/// Assignment Use Definition
/// The IfcDistributionFlowElement may be assigned to the following entities using relationships as indicated:
/// 
/// IfcDistributionSystem (IfcRelAssignsToGroup): Indicates a system containing interconnected devices.
/// IfcPerformanceHistory (IfcRelAssignsToControl): Indicates realtime or historical infomation captured for the device.
/// 
/// The IfcDistributionFlowElement may have assignments of its own using the IfcRelAssignsToProduct relationship where RelatingProduct refers to the IfcDistributionFlowElement and RelatedObjects contains one or more objects of the following types: 
/// 
/// IfcTask: Indicates tasks used to purchase, install, renovate, demolish, operate, or otherwise act upon the element.  If the element has a type, available task types are assigned to the element type.
/// IfcProcedure: Indicates procedures used to operate the element.  If the element has a type, available procedure types are assigned to the element type.
/// IfcEvent: Indicates events raised by the element, sequenced by procedures to be followed.  If the element has a type, available event types are assigned to the element type.
/// 
/// Material Use Definition
/// The material of the IfcDistributionFlowElement is defined using one of the following entities:
/// 
/// IfcMaterialProfileSetUsage: For parametric segments, this defines the cross section and alignment to the 'Axis' representation, from which the 'Body' representation may be generated.
/// 
/// IfcMaterialProfileSet: For non-parametric segments (having fixed length or path), this may define the cross section for analysis purposes, however the 'Body' representation is independently generated.
/// 
/// IfcMaterialConstituentSet: For elements containing multiple materials, this indicates materials at named aspects.
/// 
/// IfcMaterial: For elements comprised of a single material, this indicates the material.
/// 
/// The material is attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.  Material information can also be given at the IfcDistributionFlowElementType, defining the common attribute data for all occurrences of the same type.  Standard names and material types are defined at subtypes.
/// 
/// Representation Use Definition
/// The following shape representations are supported for subtypes of IfcDistributionFlowElement, distinguished by IfcShapeRepresentation.RepresentationIdentifier:
/// 
/// 'Axis': Represents the 3D flow path of the item having IfcShapeRepresentation.RepresentationType of 'Curve3D' and containing a single IfcBoundedCurve subtype such as IfcPolyline, IfcTrimmedCurve, or IfcCompositeCurve.  For elements containing directional ports (IfcDistributionPort with FlowDirection of SOURCE or SINK), the direction of the curve indicates direction of flow where a SINK port is positioned at the start of the curve and a SOURCE port is positioned at the end of the curve.  This representation is most applicable to flow segments (pipes, ducts, cables), however may be used at other elements to define a primary flow path if applicable. 
/// 
/// 'Footprint': Represents the 2D footprint outline of the item having IfcShapeRepresentation.RepresentationType of  'GeometricCurveSet' and containing a single IfcGeometricCurveSet consisting of one or more IfcCurve subtypes such as IfcPolyline, IfcTrimmedCurve, IfcCompositeCurve, or IfcCircle.
/// 
/// 'Body': Represents the 3D shape of the item having IfcShapeRepresentation.RepresentationType of 'SurfaceModel', 'SolidModel', or any solid model specializations including 'Brep', 'AdvancedBrep', 'SweptSolid', 'AdvancedSweptSolid', 'CSG', 'Clipping', or 'SectionedSpine').
/// 
/// 'Clearance': Represents the 3D clearance volume of the item having RepresentationType of 'Surface3D'.  Such clearance region indicates space that should not intersect with the 'Body' representation of other elements, though may intersect with the 'Clearance' representation of other elements.  The particular use of clearance space may be for safety, maintenance, or other purpose.
/// 
/// 'Lighting': Represents the light emission of the item having IfcShapeRepresentation.RepresentationType of 'LightSource' and containing one or more IfcLightSource subtypes.  This representation is most applicable to lamps and light fixtures, however may be used at other elements that emit light.
/// 
/// For all representations, if a IfcDistributionFlowElement occurrence is defined by a IfcDistributionFlowElementType having a representation of the same identifier, then 'MappedRepresentation' should be used at the occurrence unless overridden.
/// 
/// If materials are defined, geometry of each representation (most typically the 'Body' representation) may be organized into shape aspects where styles may be derived by correlating IfcShapeAspect.Name to a corresponding material (IfcMaterialConstituent.Name or IfcMaterialProfile.Name).
/// 
/// Representations are further defined at subtypes; for example, parametric flow segments align material profiles with the 'Axis' representation.
class IFC_PARSE_API IfcDistributionFlowElement : public IfcDistributionElement {
public:
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcDistributionElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcDistributionElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcDistributionElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcRelFlowControlElements >::ptr HasControlElements() const; // INVERSE IfcRelFlowControlElements::RelatingFlowElement
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcDistributionFlowElement (IfcEntityInstanceData* e);
    IfcDistributionFlowElement (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag);
    typedef IfcTemplatedEntityList< IfcDistributionFlowElement > list;
};
/// A distribution port is an inlet or outlet of a product through which a particular substance may flow.
/// 
/// Distribution ports are used for passage of solid, liquid, or gas substances, as well as electricity for power or communications.  Flow segments (pipes, ducts, cables) may be used to connect ports across products.  Distribution ports are defined by system type and flow direction such that for two ports to be connected, they must share the same system type and have opposite flow directions (one side being a SOURCE and the other being a SINK).  Ports are similar to openings in that they do not have any visible geometry; such geometry is captured at the shape representation of the enclosing element or element type.  Ports may have shape representations that indicate the position, orientation, and cross-section of the connection.
/// 
/// HISTORY: New entity in IFC2x2
/// 
/// Property Set Use Definition
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the IfcRelDefinesByProperties relationship. They are accessible by the IsDefinedBy inverse attribute.  Refer to the documentation at the supertype IfcPort and ancestors for inherited property set definitions.
/// The following property set definitions are applicable to this entity:
/// 
/// Pset_DistributionPortCommon
/// 
/// The following property set definitions are applicable to this entity according to the PredefinedType attribute: 
/// 
/// Pset_DistributionPortTypeAirConditioning (AIRCONDITIONING)
/// Pset_DistributionPortTypeAudioVisual (AUDIOVISUAL)
/// Pset_DistributionPortTypeData (DATA)
/// Pset_DistributionPortTypeDomesticColdWater (DOMESTICCOLDWATER)
/// Pset_DistributionPortTypeDomesticHotWater (DOMESTICHOTWATER)
/// Pset_DistributionPortTypeDrainage (DRAINAGE)
/// Pset_DistributionPortTypeElectrical (ELECTRICAL)
/// Pset_DistributionPortTypeFireProtection (FIREPROTECTION)
/// Pset_DistributionPortTypeGas (GAS)
/// Pset_DistributionPortTypeHeating (HEATING)
/// Pset_DistributionPortTypeOil (OIL)
/// Pset_DistributionPortTypeSewage (SEWAGE)
/// Pset_DistributionPortTypeSignal (SIGNAL)
/// Pset_DistributionPortTypeTelephone (TELEPHONE)
/// 
/// The following property set definitions are applicable to IfcPerformanceHistory, for which objects are assigned:
/// 
/// Pset_DistributionPortPHistoryAirConditioning (AIRCONDITIONING)
/// Pset_DistributionPortPHistoryControl (CONTROL)
/// Pset_DistributionPortPHistoryData (DATA)
/// Pset_DistributionPortPHistoryElectrical (ELECTRICAL)
/// Pset_DistributionPortPHistoryGas (GAS)
/// Pset_DistributionPortPHistoryHeating (HEATING)
/// Pset_DistributionPortPHistoryOil (OIL)
/// Pset_DistributionPortPHistorySignal (SIGNAL)
/// 
/// Material Use Definition
/// The material of the IfcDistributionPort is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used:
/// 
/// 'Media': The solid, liquid, or gas media passing through the port.
/// 
/// Composition Use Definition
/// The IfcDistributionPort may be decomposed into components using IfcRelAggregates where RelatingObject refers to the enclosing IfcDistributionPort and RelatedObjects contains one or more components.  Composition use is defined for the following predefined types:
/// 
/// AUDIOVISUAL: May contain IfcDistributionPort components having PredefinedType AUDIOVISUAL.  If needed, audio-visual ports may be aggregated into specific streams (channels).CONTROL: May contain IfcDistributionPort components having PredefinedType SIGNAL.  If needed, control ports may be aggregated into signal lines for indicating pinout specification.DATA: May contain IfcDistributionPort components having PredefinedType SIGNAL.  If needed, data ports may be aggregated into signal lines for indicating pinout specification.ELECTRICAL: May contain IfcDistributionPort components having PredefinedType SIGNAL.  If needed, electrical ports may be aggregated into modulated signals for data or lighting control.ELECTROACCOUSTIC: May contain IfcDistributionPort components having PredefinedType ELECTROACCOUSTIC.  If needed, speaker ports may be aggregated into streams (channels) for each speaker.TELEPHONE: May contain IfcDistributionPort components having PredefinedType TELEPHONE.  If needed, telephone ports may be aggregated for each line.
/// 
/// Connection Use Definition
/// The IfcDistributionPort may be connected to other objects as follows using the indicated relationship:
/// 
/// IfcDistributionElement (IfcRelConnectsPortToElement) : Indicates the host element or element type containing the port.
/// IfcDistributionPort (IfcRelConnectsPorts) : Indicates a connection to another port having the same type and opposite flow direction.  
/// For port connections between elements, 
/// the RelatingPort is set to a port having FlowDirection=SOURCE and 
/// the RelatedPort is set to a port having FlowDirection=SINK.  
/// For aggregation scenarios, ports on a device may be mapped to aggregated devices within, 
/// in which case ports on the outer device indicate a single FlowDirection but have an additional connection internally 
/// to a port on an aggregated inner device.  
/// Refer to IfcUnitaryEquipment for an example.
/// 
/// Figure 149 illustrates distribution port connectivity.
/// 
/// Figure 149 — Distribution port connectivity
/// 
/// Assignment Use Definition
///   The IfcDistributionPort may be assigned to the following entities using relationships as indicated:
/// 
/// IfcDistributionSystem (IfcRelAssignsToGroup): Indicates a system containing interconnected devices.
/// IfcPerformanceHistory (IfcRelAssignsToControl): Indicates realtime or historical infomation captured for the device.
/// 
/// The IfcDistributionPort may have assignments of its own using the IfcRelAssignsToProduct relationship where RelatingProduct refers to the IfcDistributionPort and RelatedObjects contains one or more objects of the following types: 
/// IfcDistributionSystem: Indicates a system that is hosted by the port, as the origination.
/// 
/// Representation Use Definition
/// The representation of IfcDistributionPort is given by IfcProductDefinitionShape, allowing multiple shape and topology representations.  Included are:
/// 
/// IfcShapeRepresentation: The optional shape representation describes the connection volume and supports indication of the port position and orientation.  The position is typically the midpoint of the physical connection, and the orientation points in the flow direction normal to the physical connection. Upon connecting elements through ports with rigid connections, each object is aligned such that the effective Location, Axis, and RefDirection of each port is aligned to be equal.
/// 
/// 'Body': The shape of the port.
class IFC_PARSE_API IfcDistributionPort : public IfcPort {
public:
    /// Whether the optional attribute FlowDirection is defined for this IfcDistributionPort
    bool hasFlowDirection() const;
    /// Enumeration that identifies if this port is a Sink (inlet), a Source (outlet) or both a SinkAndSource.
    IfcFlowDirectionEnum::IfcFlowDirectionEnum FlowDirection() const;
    void setFlowDirection(IfcFlowDirectionEnum::IfcFlowDirectionEnum v);
    /// Whether the optional attribute PredefinedType is defined for this IfcDistributionPort
    bool hasPredefinedType() const;
    /// Enumeration that identifies the system type.  If a system type is defined, the port may only be connected to other ports having the same system type.
    IfcDistributionPortTypeEnum::IfcDistributionPortTypeEnum PredefinedType() const;
    void setPredefinedType(IfcDistributionPortTypeEnum::IfcDistributionPortTypeEnum v);
    /// Whether the optional attribute SystemType is defined for this IfcDistributionPort
    bool hasSystemType() const;
    IfcDistributionSystemEnum::IfcDistributionSystemEnum SystemType() const;
    void setSystemType(IfcDistributionSystemEnum::IfcDistributionSystemEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 7: return IfcUtil::Argument_ENUMERATION; case 8: return IfcUtil::Argument_ENUMERATION; case 9: return IfcUtil::Argument_ENUMERATION; } return IfcPort::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 7: return Type::IfcFlowDirectionEnum; case 8: return Type::IfcDistributionPortTypeEnum; case 9: return Type::IfcDistributionSystemEnum; } return IfcPort::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 7: return "FlowDirection"; case 8: return "PredefinedType"; case 9: return "SystemType"; } return IfcPort::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcDistributionPort (IfcEntityInstanceData* e);
    IfcDistributionPort (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< IfcFlowDirectionEnum::IfcFlowDirectionEnum > v8_FlowDirection, boost::optional< IfcDistributionPortTypeEnum::IfcDistributionPortTypeEnum > v9_PredefinedType, boost::optional< IfcDistributionSystemEnum::IfcDistributionSystemEnum > v10_SystemType);
    typedef IfcTemplatedEntityList< IfcDistributionPort > list;
};
/// A distribution system is a network designed to receive, store, maintain, distribute, or control the flow of a distribution media. A common example is a heating hot water system that consists of a pump, a tank, and an interconnected piping system for distributing hot water to terminals.
/// 
/// HISTORY New entity in IFC 2x4.
/// 
/// The group IfcDistributionSystem
/// defines the occurrence of a specialized system for use within the context of building services.
/// 
/// NOTE: For electrical power systems, IfcElectricalCircuit has been used for low-voltage (12-1000 V) power systems and has been deprecated in IFC2x4; IfcDistributionSystem with PredefinedType 'ELECTRICAL' should now be used instead.
/// 
/// Important functionalities for the description of a distribution system are derived from existing IFC entities:
/// 
/// From IfcSystem it inherits the ability to couple the distribution system via IfcRelServicesBuildings to one or more IfcSpatialElement subtypes as necessary.
/// 
/// From IfcGroup it inherits the inverse attribute IsGroupedBy, pointing to the relationship class IfcRelAssignsToGroup. This allows to group distribution elements (instances of IfcDistributionElement subtypes), and in special cases ports directly (instances of IfcDistributionPort).
/// 
/// From IfcObject it inherits the inverse attribute IsDecomposedBy pointing to the relationship class IfcRelAggregates. It provides the hierarchy between the separate (partial) distribution systems.  For example, an electrical main circuit may be aggregated into branch circuits.
/// 
/// Property Set Use Definition:
/// 
/// The property sets relating to this entity are defined by the IfcPropertySet and attached by the IfcRelDefinesByProperties relationship. It is accessible by the inverse IsDefinedBy relationship.  The following property set definitions specific to this entity are part of this IFC release:
/// 
/// Pset_DistributionSystemCommon: common property set for distribution system occurrences
/// 
/// Pset_DistributionSystemTypeElectrical: property set for electrical systems
/// 
/// Pset_DistributionSystemTypeVentilation: property set for ventilation systems
/// 
/// Assignment Use Definition:
/// 
/// For the most common case of an IfcDistributionElement subtype containing ports of a particular PredefinedType that all belong to the same distribution system, the IfcDistributionElement is assigned to the IfcDistributionSystem via the IfcRelAssignsToGroup relationship, where IfcDistributionPort's are implied as part of the corresponding system based on their PredefinedType.  An IfcDistributionElement may belong to multiple systems, however only one IfcDistributionSystem of a particular PredefinedType.
/// 
/// For rare cases where an IfcDistributionElement subtype contains ports of the same PredefinedType yet different ports belong to different systems, alternatively each IfcDistributionPort may be directly assigned to a single IfcDistributionSystem via the IfcRelAssignsToGroup relationship, where the PredefinedType must match.  Such assignment indicates that the IfcDistributionSystem assigned from the IfcDistributionPort overrides any such system of the same PredefinedType assigned from the containing IfcDistributionElement, if any.
/// 
/// Additionally, an IfcDistributionSystem may in turn be assigned to an IfcDistributionPort indicating the host or origination of the system using IfcRelAssignsToProduct.
/// 
/// EXAMPLE: A gas-powered hot water heater may have three ports: GAS, DOMESTICCOLDWATER, and DOMESTICHOTWATER.  The heater is a member of two systems (GAS and DOMESTICCOLDWATER), and hosts one system (DOMESTICHOTWATER) at the corresponding port.
/// 
/// Figure 150 illustrates a distribution system for an electrical circuit.
/// 
/// Figure 150 — Distribution system assignment
class IFC_PARSE_API IfcDistributionSystem : public IfcSystem {
public:
    /// Whether the optional attribute LongName is defined for this IfcDistributionSystem
    bool hasLongName() const;
    /// Long name for a system, used for informal purposes. It should be used, if available, in conjunction with the inherited Name attribute.
    /// 
    /// NOTE  In many scenarios the Name attribute refers to the short name or number of a distribution system or branch circuit, and the LongName refers to a descriptive name.
    std::string LongName() const;
    void setLongName(std::string v);
    /// Whether the optional attribute PredefinedType is defined for this IfcDistributionSystem
    bool hasPredefinedType() const;
    /// Predefined types of distribution systems.
    IfcDistributionSystemEnum::IfcDistributionSystemEnum PredefinedType() const;
    void setPredefinedType(IfcDistributionSystemEnum::IfcDistributionSystemEnum v);
    virtual unsigned int getArgumentCount() const { return 7; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 5: return IfcUtil::Argument_STRING; case 6: return IfcUtil::Argument_ENUMERATION; } return IfcSystem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 5: return Type::IfcLabel; case 6: return Type::IfcDistributionSystemEnum; } return IfcSystem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 5: return "LongName"; case 6: return "PredefinedType"; } return IfcSystem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcDistributionSystem (IfcEntityInstanceData* e);
    IfcDistributionSystem (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, boost::optional< std::string > v6_LongName, boost::optional< IfcDistributionSystemEnum::IfcDistributionSystemEnum > v7_PredefinedType);
    typedef IfcTemplatedEntityList< IfcDistributionSystem > list;
};
/// Definition from ISO 6707-1:1989: Construction for
/// closing an opening, intended primarily for access with hinged,
/// pivoted or sliding operation.
/// The door is a building element
/// that is predominately used to provide controlled access for
/// people and goods. It includes constructions with hinged, pivoted,
/// sliding, and additionally revolving and folding operations. A
/// door consists of a lining and one or several panels.
/// The IfcDoor defines a particular occurrence of a door
/// inserted in the spatial context of a project. A door can:
/// 
/// be inserted as a filler in an opening using the
/// IfcRelFillsElement relationship, then the IfcDoor
/// has an inverse attribute FillsVoids provided,
/// 
/// NOTEÿ View definitions or
/// implementer agreements may restrict the relationship to only
/// include one window (or door) into one opening.
/// 
/// be part of an element assembly, in general an
/// IfcCurtainWall, using the IfcRelAggregates
/// relationship, then the inverse attribute Decomposes is
/// provided.
/// or be a "free standing" door, then the IfcDoor has no
/// inverse attributes FillsVoids or Decomposes
/// provided.
/// 
/// The IFC specification provides two entities for door
/// occurrences:
/// 
/// IfcDoorStandardCase used for all occurrences of doors,
/// that have a 'Profile' shape representation defined to which a set
/// of shape parameters for lining and framing properties apply.
/// Additionally it requires the provision of an IfcDoorType
/// that references one IfcDoorLiningProperties and on to many
/// IfcDoorPanelProperties.
/// 
/// NOTEÿ see
/// IfcDoorStandardCase for all specific constraints imposed
/// by this subtype.
/// 
/// IfcDoor used for all other occurrences of doors,
/// particularly for doors having only 'Brep', or 'SurfaceModel'
/// geometry without applying shape parameters.
/// 
/// The actual parameter of the door and/or its shape are defined
/// by the IfcDoor as the occurrence definition (or project
/// instance), or by the IfcDoorType as the specific definition (or
/// project type). The following parameters are given:
/// 
/// at the IfcDoor or IfcDoorStandardCase for
/// occurrence specific parameters. The IfcDoor
/// specifies:
/// 
/// the door width and height
/// the door opening direction (by the y-axis of the
/// ObjectPlacement)
/// 
/// at the IfcDoorType, to
/// which the IfcDoor is related by the inverse relationship
/// IsDefinedBy pointing to IfcRelDefinesByType, for
/// type parameters common to all occurrences of the same type.
/// 
/// the operation type (single swing, double swing, revolving,
/// etc.)
/// the door hinge side (by using two different styles for right
/// and left opening doors)
/// the construction material type
/// the particular attributes for the lining by the
/// IfcDoorLiningProperties
/// the particular attributes for the panels by theÿ
/// IfcDoorPanelProperties
/// 
/// HISTORY New entity in IFC Release 1.0.
/// IFC2x4 CHANGE The attributes PredefinedType and OperationType are added, the applicable type object has been changed to IfcDoorType.
/// 
/// Material Use Definition
/// The material of the IfcDoor is defined by the
/// IfcMaterialConstituentSet or as fall back by
/// IfcMaterial and attached by the
/// IfcRelAssociatesMaterial.RelatingMaterial. It is
/// accessible by the inverse HasAssociations
/// relationship.
/// The following keywords for
/// IfcMaterialConstituentSet.MaterialConstituents[n].Name
/// shall be used:
/// 
/// 'Lining' - to indicate that the material constituent applies
/// to to the door lining
/// 'Framing' - to indicate that the material constituent applies
/// to to the door panel(s), if not provided, the 'Lining' material
/// information applied to panel(s) as well
/// 'Glazing' - to indicate that the material constituent applies
/// to to the glazing part
/// 
/// If the fall back single IfcMaterial is referenced, it
/// applies to the lining and framing of the door.
/// Property Set Use Definition:
/// The property sets relating to the IfcDoor are defined
/// by the IfcPropertySet and attached by the
/// IfcRelDefinesByProperties relationship. It is accessible
/// by the inverse IsDefinedBy relationship. The following
/// property set definitions specific to the IfcDoor are part
/// of this IFC release:
/// 
/// Pset_DoorCommon: common property set for all
/// door occurrences
/// Pset_DoorWindowGlazingType: specific property
/// set for the glazing properties of the door glazing, if
/// available
/// Pset_DoorWindowShadingType: specific property
/// set for the shading properties of the door glazing, if
/// available
/// 
/// Quantity Use Definition
/// The quantities relating to the IfcDoor are defined by
/// the IfcElementQuantity and attached by the
/// IfcRelDefinesByProperties relationship. It is accessible
/// by the inverse IsDefinedBy relationship. The following
/// base quantities are defined and should be exchanged with the
/// IfcElementQuantity.Name = 'BaseQuantities'. Other
/// quantities can be defined being subjected to local standard of
/// measurement with another string value assigned to
/// MethodOfMeasurement. Quanties shall be never assigned to
/// the IfcDoorType.
/// 
/// Qto_DoorBaseQuantities: base quantities for
/// all door occurrences.
/// 
/// Containment Use Definition
/// The IfcDoor, as any subtype of
/// IfcBuildingElement, may participate in two different
/// containment relationships as shown in Figure 96. The first (and in most implementation
/// scenarios mandatory) relationship is the hierachical spatial
/// containment, the second (optional) relationship is the
/// aggregation within anÿelement assembly.
/// 
/// The IfcDoor is places within the project spatial
/// hierarchy using the objectified relationship
/// IfcRelContainedInSpatialStructure, refering to it by its
/// inverse attribute SELF\IfcElement.ContainedInStructure.
/// Subtypes ofÿIfcSpatialStructureElement are valid spatial
/// containers, with IfcBuildingStorey being the default
/// container.
/// The IfcDoor may be aggregated into an element assembly
/// using the objectified relationship IfcRelAggregates,
/// refering to it by its inverse attribute
/// SELF\IfcObjectDefinition.Decomposes. Doors may be part of
/// an IfcCurtainWall as a special focus subtype. In this case
/// it should not be additionally contained in the project spatial
/// hierarchy, i.e.ÿSELF\IfcElement.ContainedInStructure
/// should be NIL.
/// 
/// NOTE The containment shall be defined independently of the
/// filling relationship, that is, even if the IfcDoor is a
/// filling of an opening established by IfcRelFillsElement,
/// it is also contained in the spatial structure by an
/// IfcRelContainedInSpatialStructure.
/// 
/// Figure 96 — Door containment
/// 
/// Geometry Use Definitions:
/// The geometric representation of IfcDoor is given by the
/// IfcProductDefinitionShape, allowing multiple geometric
/// representations. The IfcDoor, in case of an occurrance
/// object, gets its parameter and shape from the IfcDoorType.
/// If an IfcRepresentationMap (a block definition) is defined
/// for the IfcDoorType, then the IfcDoor inserts it
/// through the IfcMappedItem.
/// Local Placement
/// The local placement for IfcDoor is defined in its
/// supertype IfcProduct. It is defined by the
/// IfcLocalPlacement, which defines the local coordinate
/// system that is referenced by all geometric representations.
/// 
/// The PlacementRelTo relationship of
/// IfcLocalPlacement shall point to the local placement of
/// the same element (if given), in which the IfcDoor is used
/// as a filling (normally an IfcOpeningElement), as provided
/// by the IfcRelFillsElement relationship.
/// If the IfcDoor is not inserted into an
/// IfcOpeningElement, then the PlacementRelTo
/// relationship of IfcLocalPlacement shall point (if given)
/// to the local placement of the same
/// IfcSpatialStructureElement that is used in the
/// ContainedInStructure inverse attribute or to a referenced
/// spatial structure element at a higher level.
/// If the relative placement is not used, the absolute placement
/// is defined within the world coordinate system.
/// 
/// Geometric Representation
/// Theÿgeometric representation of IfcDoor is defined
/// using the following (potentiallyÿmultiple)
/// IfcShapeRepresentation's for its
/// IfcProductDefinitionShape:
/// 
/// Profile: Aÿ'Curve3D'
/// consisting of a single losed curve defining the outer boundary of
/// the door (lining). The door parametric representation uses this
/// profile in order to apply the door lining and panel parameter. If
/// not provided, the profile of the IfcOpeningElement is
/// taken.
/// FootPrint: A 'GeometricCurveSet', or 'Annotation2D'
/// representation defining the 2D shape of the door
/// Body: A 'SweptSolid', 'SurfaceModel', or 'Brep'
/// representation defining the 3D shape of the door.
/// 
/// In addition the parametric representation of a (limited) door
/// shape is available by applying the parameters from
/// IfcDoorType referencing IfcDoorLiningProperties and
/// IfcDoorPanelProperties. The purpose of the parameter is
/// described at those entities and below (door opening operation by
/// door type).
/// Profile -ÿ'Curve3D' representation
/// The door profile is represented by a three-dimensional closed
/// curve within a particular shape representation. The profile is
/// used to apply the parameter of the parametric door
/// representation.ÿThe following attribute values for the
/// IfcShapeRepresentation holding this geometric
/// representation shall be used:
/// 
/// RepresentationIdentifier : 'Profile'
/// RepresentationType : 'Curve3D', only a single closed
/// curve shall be contained in the set of
/// IfcShapeRepresentation.Items.
/// 
/// A 'Profile' representation has to be provided if:
/// 
/// a parametric representation shall be applied to the door
/// AND
/// 
/// theÿdoor is 'free standing', or
/// the opening into which theÿdoor is inserted is not extruded
/// horizontally (i.e. where the opening profile does not match
/// theÿdoor profile)
/// 
/// FootPrint -ÿ'GeometricCurveSet' or 'Annotation2D'
/// representation
/// The door foot print is represented by a set of
/// two-dimensionalÿcurves (or in case of 'Annotation2D' additional
/// hatching and text) within a particular shape representation. The
/// foot print is used for the planview representation of the
/// door.ÿThe following attribute values for the
/// IfcShapeRepresentation holding this geometric
/// representation shall be used:
/// 
/// RepresentationIdentifier : 'FootPrint'
/// RepresentationType : 'GeometricCurveSet', or
/// 'Annotation2D'
/// 
/// Body - 'SweptSolid', 'SurfaceModel', or 'Brep'
/// representation
/// The door body is either represented parameterically (see
/// parametric representation) or by explicit 3D shape. The 3D shape
/// is given by using extrusion geometry, or surface models, or Brep
/// models within a particular shape representation. The body is used
/// for the model view representation of the door.ÿThe following
/// attribute values for the IfcShapeRepresentation holding
/// this geometric representation shall be used:
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'SweptSolid', 'SurfaceModel', or
/// 'Brep'
/// 
/// MappedRepresentation
/// The 'FootPrint' and 'Body' geometric representation of
/// IfcDoor can be shared among several identical doors using
/// the 'MappedRepresentation'. The following attribute values for
/// the IfcShapeRepresentation holding this geometric
/// representation shall be used:
/// 
/// RepresentationIdentifier : 'FootPrint', 'Body'
/// RepresentationType : 'MappedRepresentation'
/// 
/// The same constraints, as given for theÿ 'FootPrint', 'Body'
/// representation identifiers, shall apply to the
/// MappedRepresentation of the
/// IfcRepresentationMap.
/// Parameteric Representation using parameters at
/// IfcDoorType
/// The parameters that defines the shape of the IfcDoor,
/// are given at the IfcDoorType and the property sets, which
/// are included in the IfcDoorType. The IfcDoor only
/// defines the local placement which determines the opening
/// direction of the door. The overall size of
/// the IfcDoor to be used to apply the lining or panel
/// parameter provided by the IfcDoorType is determined by the
/// IfcShapeRepresentation with the RepresentationIdentifier =
/// 'Profile'. Only in case of an IfcDoor inserted into an
/// IfcOpeningElement using the IfcRelFillsElement
/// relatioship, having a horizontal extrusion (along the y-axis of
/// the IfcDoor), the overall size is determined by the
/// extrusion profile of the IfcOpeningElement.
/// NOTE ÿThe OverallWidth and
/// OverallHeight parameters are for informational purpose
/// only.
/// The opening direction is determined by the local placement of
/// IfcDoor and the OperationType of the door
/// style as shown in Figure 97.
/// NOTE ÿThere are different definitions in
/// various countries on what a left opening or left hung or left
/// swing door is (same for right). Therefore the IFC definition may
/// derivate from the local standard and need to be mapped
/// appropriately.
/// 
/// Opening
/// directions
/// 
/// Definitions
/// Reference to other
/// standards
/// 
/// The door panel (for swinging doors) opens
/// always into the direction of the positive Y axis of the local
/// placement. The determination of whether the door opens to the
/// left or to the right is done at the level of the
/// IfcDoorType. Here it is a left side opening door given
/// byÿIfcDoorType.OperationType =
/// SingleSwingLeft
/// refered to as LEFT HAND (LH) in US *
/// 
/// refered to as DIN-R (right hung) in Germany
/// 
/// If the door should open to the other
/// side, then the local placement has to be changed. It is still a
/// left side opening door, given by IfcDoorType.OperationType
/// = SingleSwingLeft
/// refered to as RIGHT HAND REVERSE (RHR) in
/// US *
/// 
/// refered to as DIN-R (right hung) in Germany
/// 
/// If the door panel (for swinging doors)
/// opens to the right, a separate door style needs to be used (here
/// IfcDoorTypee.OperationType = SingleSwingRight) and it
/// always opens into the direction of the positive Y axis of the
/// local placement.ÿ
/// refered to as RIGHT HAND (RH) in US *
/// 
/// refered to as DIN-L (left hung) in Germany
/// 
/// If the door panel (for swinging doors)
/// opens to the right, and into the opposite directions, the local
/// placement of the door need to change. The door style is given by
/// IfcDoorType.OperationType = SingleSwingRight.
/// refered to as LEFT HAND REVERSE (LHR) in
/// US *
/// 
/// refered to as DIN-L (left hung) in Germany
/// 
/// * it assumes that the
/// 'inside/private/primary' space is above (top in the pictures) and
/// the 'outside/public/secondary' space is below (bottom in the
/// pictures).
/// 
/// Figure 97 — Door swing
class IFC_PARSE_API IfcDoor : public IfcBuildingElement {
public:
    /// Whether the optional attribute OverallHeight is defined for this IfcDoor
    bool hasOverallHeight() const;
    /// Overall measure of the height, it reflects the Z Dimension of a bounding box, enclosing the body of the door opening. If omitted, the OverallHeight should be taken from the geometric representation of the IfcOpening in which the door is inserted. 
    /// 
    /// NOTE  The body of the door might be taller then the door opening (e.g. in cases where the door lining includes a casing). In these cases the OverallHeight shall still be given as the door opening height, and not as the total height of the door lining.
    double OverallHeight() const;
    void setOverallHeight(double v);
    /// Whether the optional attribute OverallWidth is defined for this IfcDoor
    bool hasOverallWidth() const;
    /// Overall measure of the width, it reflects the X Dimension of a bounding box, enclosing the body of the door opening. If omitted, the OverallWidth should be taken from the geometric representation of the IfcOpening in which the door is inserted. 
    /// 
    /// NOTE  The body of the door might be wider then the door opening (e.g. in cases where the door lining includes a casing). In these cases the OverallWidth shall still be given as the door opening width, and not as the total width of the door lining.
    double OverallWidth() const;
    void setOverallWidth(double v);
    /// Whether the optional attribute PredefinedType is defined for this IfcDoor
    bool hasPredefinedType() const;
    /// Predefined generic type for a door that is specified in an enumeration. There may be a property set given specificly for the predefined types.
    ///   NOTE The PredefinedType shall only be used, if no type object IfcDoorType is assigned, providing its own IfcDoorType.PredefinedType.
    /// 
    /// IFC2x4 CHANGE  The attribute has been added at the end of the entity definition.
    IfcDoorTypeEnum::IfcDoorTypeEnum PredefinedType() const;
    void setPredefinedType(IfcDoorTypeEnum::IfcDoorTypeEnum v);
    /// Whether the optional attribute OperationType is defined for this IfcDoor
    bool hasOperationType() const;
    /// Type defining the general layout and operation of the door type in terms of the partitioning of panels and panel operations. 
    /// 
    /// NOTE The OperationType shall only be used, if no type object IfcDoorType is assigned, providing its own IfcDoorType.OperationType.
    /// 
    /// IFC2x4 CHANGE  The attribute has been added at the end of the entity definition.
    IfcDoorTypeOperationEnum::IfcDoorTypeOperationEnum OperationType() const;
    void setOperationType(IfcDoorTypeOperationEnum::IfcDoorTypeOperationEnum v);
    /// Whether the optional attribute UserDefinedOperationType is defined for this IfcDoor
    bool hasUserDefinedOperationType() const;
    std::string UserDefinedOperationType() const;
    void setUserDefinedOperationType(std::string v);
    virtual unsigned int getArgumentCount() const { return 13; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_DOUBLE; case 9: return IfcUtil::Argument_DOUBLE; case 10: return IfcUtil::Argument_ENUMERATION; case 11: return IfcUtil::Argument_ENUMERATION; case 12: return IfcUtil::Argument_STRING; } return IfcBuildingElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcPositiveLengthMeasure; case 9: return Type::IfcPositiveLengthMeasure; case 10: return Type::IfcDoorTypeEnum; case 11: return Type::IfcDoorTypeOperationEnum; case 12: return Type::IfcLabel; } return IfcBuildingElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "OverallHeight"; case 9: return "OverallWidth"; case 10: return "PredefinedType"; case 11: return "OperationType"; case 12: return "UserDefinedOperationType"; } return IfcBuildingElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcDoor (IfcEntityInstanceData* e);
    IfcDoor (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< double > v9_OverallHeight, boost::optional< double > v10_OverallWidth, boost::optional< IfcDoorTypeEnum::IfcDoorTypeEnum > v11_PredefinedType, boost::optional< IfcDoorTypeOperationEnum::IfcDoorTypeOperationEnum > v12_OperationType, boost::optional< std::string > v13_UserDefinedOperationType);
    typedef IfcTemplatedEntityList< IfcDoor > list;
};
/// The standard door,
/// IfcDoorStandardCase, defines a door with certain constraints
/// for the provision of operation types, opening directions, frame and
/// lining parameters, and with certain constraints for the geometric
/// representation. The IfcDoorStandardCase handles all cases of
/// doors, that:
/// 
/// are inserted into an opening, represented by
/// IfcOpeningElement, using the IfcRelFillsElement
/// relationship
/// have a local placement relative to this opening, and with the
/// y-axis of the placement pointing into the opening direction
/// have a profile geometry, represented by
/// IfcShapeRepresentation.RepresentationIdentifier="Profile" as
/// a closed curve to which the door parameter apply. The profile
/// represents a rectangle within the xz plane of the local
/// placement
/// have a reference to an IfcDoorType to define the opening
/// direction and the operation type (swinging, sliding, folding, etc.)
/// of the door. The attribute OperationType shall be provided
/// and not being UNDEFINED, and the attribute
/// ParameterTakesPrecedence shall be "TRUE".
/// have an IfcDoorLiningProperties and an
/// IfcDoorPanelProperties instances included in the set of
/// HasPropertySets at IfcDoorType
/// 
/// HISTORY New entity in IFC2x4.
/// 
/// Type Use Definition
/// IfcDoorStandardCase defines the occuurence of any door,
/// common information about door types (or styles) is handled by
/// IfcDoorType. The IfcDoorType (that has to be present)
/// establishes the common type name, usage (opening direction and
/// operation), common set of properties, including shape parameters,
/// like lining thickness panel width, etc. and maybe an additional
/// common shape representations (using IfcRepresentationMap).
/// The IfcDoorType is attached using the
/// IfcRelDefinedByType.RelatingType objectified relationship
/// and is accessible by the inverse IsDefinedBy attribute.
/// Property Set Use Definition:
/// The property sets relating to the IfcDoorStandardCase are
/// defined at the supertype IfcDoor.
/// Quantity Use Definition
/// The quantities relating to the IfcDoorStandardCase are
/// defined at the supertype IfcDoor.
/// Containment Use Definition
/// The containment use definitions relating to the
/// IfcDoorStandardCase are defined at the supertype
/// IfcDoor.
/// Geometry Use Definitions:
/// The geometric representation of IfcDoorStandardCase is
/// given by the IfcProductDefinitionShape, allowing multiple
/// geometric representations. Included are:
/// Local Placement
/// The use of local placement is defined at the supertype
/// IfcDoor.
/// Geometric Representations
/// The geometric representation of IfcDoorStandardCase is
/// defined using the following multiple shape representations for its
/// definition:
/// 
/// Profile: a three-dimensional closed curve within a
/// particular shape representation. The profile is used to apply the
/// parameter of the parametric door representation. The profile around
/// the edges of the opening is used to apply the door lining and door
/// panel shape parameter.
/// MappedRepresentation: A SweptSolid, SurfaceModel, or
/// Brep Representation or a CSG additionally defining the 3D shape of
/// the standard door in addition to the parametric representation by
/// applying the IfcDoorLiningProperties and an the
/// IfcDoorPanelProperties to the Profile representation.
/// 
/// Profile representation
/// The door profile is represented by a three-dimensional closed
/// curve within a particular shape representation. The profile is used
/// to apply the parameter of the parametric door
/// representation. The following attribute values for the
/// IfcShapeRepresentation holding this geometric representation
/// shall be used:
/// 
/// RepresentationIdentifier : 'Profile'
/// RepresentationType : 'Curve3D' or 'GeometricCurveSet',
/// in case of 'GeometricCurveSet' only a single closed curve shall be
/// contained in the set of IfcShapeRepresentation.Items.
/// 
/// The following additional constraints apply to the 'Profile'
/// representation type:
/// 
/// Curve: being an IfcPolyline defining a
/// rectangle.
/// Position: The curve shall lie in the xz plane of the
/// object placement coordinate (the y coordinate values of the
/// IfcCartesianPoint's shall be 0.).
/// 
/// Figure 98 illustrates applying the door lining parameters to the door profile shape representation.  The profile defines the outer boundary to which the door lining parameters relate as:
/// 
/// IfcDoorLiningProperties.LiningDepth starting at distance defined by LiningOffset going into the positive y direction.
/// IfcDoorLiningProperties.LiningThickness offset into the inner side of the rectangle.
/// IfcDoorLiningProperties.LiningOffset distance along the positive y direction to where the LiningDepth applies.
/// IfcDoorLiningProperties.ThresholdThickness starting at the bottom edge of the rectangle into the inner side of the rectangle
/// IfcDoorLiningProperties.ThresholdDepth starting at distance defined by LiningOffset going into the positive y direction.
/// IfcDoorLiningProperties.TransomOffset starting at the bottom edge of the rectangle (along local x axis) into the inner side of the rectangle, distance provided as percentage of overall height. Distance to the centre line of the transom.
/// 
/// Figure 98 — Door profile
class IFC_PARSE_API IfcDoorStandardCase : public IfcDoor {
public:
    virtual unsigned int getArgumentCount() const { return 13; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcDoor::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcDoor::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcDoor::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcDoorStandardCase (IfcEntityInstanceData* e);
    IfcDoorStandardCase (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< double > v9_OverallHeight, boost::optional< double > v10_OverallWidth, boost::optional< IfcDoorTypeEnum::IfcDoorTypeEnum > v11_PredefinedType, boost::optional< IfcDoorTypeOperationEnum::IfcDoorTypeOperationEnum > v12_OperationType, boost::optional< std::string > v13_UserDefinedOperationType);
    typedef IfcTemplatedEntityList< IfcDoorStandardCase > list;
};
/// The flow fitting type IfcDuctFittingType defines commonly shared information for occurrences of duct fittings.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a duct fitting specification (i.e. the specific product information, that is common to all occurrences of that product type).  Duct Fitting types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcDuctFittingType are represented by instances of IfcDuctFitting. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcFlowFittingType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_DuctFittingTypeCommon 
/// 
/// Material Use Definition 
/// The material of the IfcDuctFittingType is defined by IfcMaterialProfileSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialProfileSet.MaterialProfiles[n].Name shall be used: 
/// 
/// 'Body': Material from which the duct fitting is constructed. 
/// 'Coating': The outer coating, if applicable. 
/// 'Insulation': The insulating wrapping, if applicable. 
/// 'Lining': The inner lining, if applicable. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcDuctFittingType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcDuctFitting for standard port definitions.
class IFC_PARSE_API IfcDuctFittingType : public IfcFlowFittingType {
public:
    /// The type of duct fitting.
    IfcDuctFittingTypeEnum::IfcDuctFittingTypeEnum PredefinedType() const;
    void setPredefinedType(IfcDuctFittingTypeEnum::IfcDuctFittingTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcFlowFittingType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcDuctFittingTypeEnum; } return IfcFlowFittingType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcFlowFittingType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcDuctFittingType (IfcEntityInstanceData* e);
    IfcDuctFittingType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcDuctFittingTypeEnum::IfcDuctFittingTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcDuctFittingType > list;
};
/// The flow segment type IfcDuctSegmentType defines commonly shared information for occurrences of duct segments.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a duct segment specification (i.e. the specific product information, that is common to all occurrences of that product type).  Duct Segment types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcDuctSegmentType are represented by instances of IfcDuctSegment. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcFlowSegmentType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_DuctSegmentTypeCommon 
/// 
/// Material Use Definition 
/// The material of the IfcDuctSegmentType is defined by IfcMaterialProfileSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialProfileSet.MaterialProfiles[n].Name shall be used: 
/// 
/// 'Body': Material from which the duct segment is constructed. 
/// 'Coating': The outer coating, if applicable. 
/// 'Insulation': The insulating wrapping, if applicable. 
/// 'Lining': The inner lining, if applicable. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcDuctSegmentType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcDuctSegment for standard port definitions.
class IFC_PARSE_API IfcDuctSegmentType : public IfcFlowSegmentType {
public:
    /// The type of duct segment.
    IfcDuctSegmentTypeEnum::IfcDuctSegmentTypeEnum PredefinedType() const;
    void setPredefinedType(IfcDuctSegmentTypeEnum::IfcDuctSegmentTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcFlowSegmentType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcDuctSegmentTypeEnum; } return IfcFlowSegmentType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcFlowSegmentType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcDuctSegmentType (IfcEntityInstanceData* e);
    IfcDuctSegmentType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcDuctSegmentTypeEnum::IfcDuctSegmentTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcDuctSegmentType > list;
};
/// The flow treatment device type IfcDuctSilencerType defines commonly shared information for occurrences of duct silencers.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a duct silencer specification (i.e. the specific product information, that is common to all occurrences of that product type).  Duct Silencer types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcDuctSilencerType are represented by instances of IfcDuctSilencer. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcFlowTreatmentDeviceType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_DuctSilencerTypeCommon 
/// 
/// Material Use Definition 
/// The material of the IfcDuctSilencerType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Body': The primary material from which the object is constructed. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcDuctSilencerType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcDuctSilencer for standard port definitions.
class IFC_PARSE_API IfcDuctSilencerType : public IfcFlowTreatmentDeviceType {
public:
    /// The type of duct silencer.
    IfcDuctSilencerTypeEnum::IfcDuctSilencerTypeEnum PredefinedType() const;
    void setPredefinedType(IfcDuctSilencerTypeEnum::IfcDuctSilencerTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcFlowTreatmentDeviceType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcDuctSilencerTypeEnum; } return IfcFlowTreatmentDeviceType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcFlowTreatmentDeviceType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcDuctSilencerType (IfcEntityInstanceData* e);
    IfcDuctSilencerType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcDuctSilencerTypeEnum::IfcDuctSilencerTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcDuctSilencerType > list;
};
/// The flow terminal type IfcElectricApplianceType defines commonly shared information for occurrences of electric appliances.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a electric appliance specification (i.e. the specific product information, that is common to all occurrences of that product type).  Electric Appliance types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcElectricApplianceType are represented by instances of IfcElectricAppliance. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcFlowTerminalType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity according to the PredefinedType attribute:  
/// Pset_ElectricalDeviceCommon 
/// Pset_ElectricApplianceTypeCommon 
/// Pset_ElectricApplianceTypeDishwasher (DISHWASHER) 
/// Pset_ElectricApplianceTypeElectricCooker (ELECTRICCOOKER) 
/// 
/// Material Use Definition 
/// The material of the IfcElectricApplianceType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Casing': Material from which the casing is constructed. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcElectricApplianceType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcElectricAppliance for standard port definitions.
class IFC_PARSE_API IfcElectricApplianceType : public IfcFlowTerminalType {
public:
    /// Identifies the predefined types of electrical appliance from which the type required may be set.
    IfcElectricApplianceTypeEnum::IfcElectricApplianceTypeEnum PredefinedType() const;
    void setPredefinedType(IfcElectricApplianceTypeEnum::IfcElectricApplianceTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcFlowTerminalType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcElectricApplianceTypeEnum; } return IfcFlowTerminalType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcFlowTerminalType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcElectricApplianceType (IfcEntityInstanceData* e);
    IfcElectricApplianceType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcElectricApplianceTypeEnum::IfcElectricApplianceTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcElectricApplianceType > list;
};
/// The flow controller type IfcElectricDistributionBoardType defines commonly shared information for occurrences of distribution boards.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a distribution board specification (i.e. the specific product information, that is common to all occurrences of that product type).  Distribution Board types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcElectricDistributionBoardType are represented by instances of IfcElectricDistributionBoard. 
/// 
/// HISTORY: New entity in IFC2x4 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcFlowControllerType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_ElectricalDeviceCommon 
/// Pset_ElectricDistributionBoardTypeCommon 
/// 
/// Material Use Definition 
/// The material of the IfcElectricDistributionBoardType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Casing': Material from which the casing is constructed. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcElectricDistributionBoardType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcElectricDistributionBoard for standard port definitions.
class IFC_PARSE_API IfcElectricDistributionBoardType : public IfcFlowControllerType {
public:
    /// Identifies the predefined types of electric distribution type from which the type required may be set.
    IfcElectricDistributionBoardTypeEnum::IfcElectricDistributionBoardTypeEnum PredefinedType() const;
    void setPredefinedType(IfcElectricDistributionBoardTypeEnum::IfcElectricDistributionBoardTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcFlowControllerType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcElectricDistributionBoardTypeEnum; } return IfcFlowControllerType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcFlowControllerType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcElectricDistributionBoardType (IfcEntityInstanceData* e);
    IfcElectricDistributionBoardType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcElectricDistributionBoardTypeEnum::IfcElectricDistributionBoardTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcElectricDistributionBoardType > list;
};
/// The flow storage device type IfcElectricFlowStorageDeviceType defines commonly shared information for occurrences of electric flow storage devices.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a electric flow storage device specification (i.e. the specific product information, that is common to all occurrences of that product type).  Electric Flow Storage Device types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcElectricFlowStorageDeviceType are represented by instances of IfcElectricFlowStorageDevice. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcFlowStorageDeviceType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_ElectricalDeviceCommon 
/// Pset_ElectricFlowStorageDeviceTypeCommon 
/// 
/// Material Use Definition 
/// The material of the IfcElectricFlowStorageDeviceType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Casing': Material from which the casing is constructed. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcElectricFlowStorageDeviceType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcElectricFlowStorageDevice for standard port definitions.
class IFC_PARSE_API IfcElectricFlowStorageDeviceType : public IfcFlowStorageDeviceType {
public:
    /// Identifies the predefined types of electric flow storage devices from which the type required may be set.
    IfcElectricFlowStorageDeviceTypeEnum::IfcElectricFlowStorageDeviceTypeEnum PredefinedType() const;
    void setPredefinedType(IfcElectricFlowStorageDeviceTypeEnum::IfcElectricFlowStorageDeviceTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcFlowStorageDeviceType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcElectricFlowStorageDeviceTypeEnum; } return IfcFlowStorageDeviceType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcFlowStorageDeviceType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcElectricFlowStorageDeviceType (IfcEntityInstanceData* e);
    IfcElectricFlowStorageDeviceType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcElectricFlowStorageDeviceTypeEnum::IfcElectricFlowStorageDeviceTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcElectricFlowStorageDeviceType > list;
};
/// The energy conversion device type IfcElectricGeneratorType defines commonly shared information for occurrences of electric generators.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a electric generator specification (i.e. the specific product information, that is common to all occurrences of that product type).  Electric Generator types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcElectricGeneratorType are represented by instances of IfcElectricGenerator. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcEnergyConversionDeviceType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_ElectricalDeviceCommon 
/// Pset_ElectricGeneratorTypeCommon 
/// 
/// Material Use Definition 
/// The material of the IfcElectricGeneratorType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Casing': Material from which the casing is constructed. 
/// 
/// Composition Use Definition 
/// The IfcElectricGeneratorType may be aggregated into components using IfcRelAggregates where RelatingObject refers to the enclosing IfcElectricGeneratorType and RelatedObjects contains one or more components.  Components are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Aggregation use is defined for the following predefined types:
/// 
/// ENGINEGENERATOR: May contain IfcEngine components.  Engine-Generator sets may optionally include an engine to indicate specific detail. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcElectricGeneratorType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcElectricGenerator for standard port definitions.
class IFC_PARSE_API IfcElectricGeneratorType : public IfcEnergyConversionDeviceType {
public:
    /// Identifies the predefined types of electric generators from which the type required may be set.
    IfcElectricGeneratorTypeEnum::IfcElectricGeneratorTypeEnum PredefinedType() const;
    void setPredefinedType(IfcElectricGeneratorTypeEnum::IfcElectricGeneratorTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcEnergyConversionDeviceType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcElectricGeneratorTypeEnum; } return IfcEnergyConversionDeviceType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcEnergyConversionDeviceType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcElectricGeneratorType (IfcEntityInstanceData* e);
    IfcElectricGeneratorType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcElectricGeneratorTypeEnum::IfcElectricGeneratorTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcElectricGeneratorType > list;
};
/// The energy conversion device type IfcElectricMotorType defines commonly shared information for occurrences of electric motors.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a electric motor specification (i.e. the specific product information, that is common to all occurrences of that product type).  Electric Motor types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcElectricMotorType are represented by instances of IfcElectricMotor. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcEnergyConversionDeviceType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_ElectricalDeviceCommon 
/// Pset_ElectricMotorTypeCommon 
/// 
/// Material Use Definition 
/// The material of the IfcElectricMotorType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Casing': Material from which the casing is constructed. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcElectricMotorType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcElectricMotor for standard port definitions.
class IFC_PARSE_API IfcElectricMotorType : public IfcEnergyConversionDeviceType {
public:
    /// Identifies the predefined types of electric motor from which the type required may be set.
    IfcElectricMotorTypeEnum::IfcElectricMotorTypeEnum PredefinedType() const;
    void setPredefinedType(IfcElectricMotorTypeEnum::IfcElectricMotorTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcEnergyConversionDeviceType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcElectricMotorTypeEnum; } return IfcEnergyConversionDeviceType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcEnergyConversionDeviceType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcElectricMotorType (IfcEntityInstanceData* e);
    IfcElectricMotorType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcElectricMotorTypeEnum::IfcElectricMotorTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcElectricMotorType > list;
};
/// The flow controller type IfcElectricTimeControlType defines commonly shared information for occurrences of electric time controls.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a electric time control specification (i.e. the specific product information, that is common to all occurrences of that product type).  Electric Time Control types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcElectricTimeControlType are represented by instances of IfcElectricTimeControl. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcFlowControllerType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_ElectricalDeviceCommon 
/// Pset_ElectricTimeControlTypeCommon 
/// 
/// Material Use Definition 
/// The material of the IfcElectricTimeControlType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Casing': Material from which the casing is constructed. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcElectricTimeControlType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcElectricTimeControl for standard port definitions.
class IFC_PARSE_API IfcElectricTimeControlType : public IfcFlowControllerType {
public:
    /// Identifies the predefined types of electrical time control from which the type required may be set.
    IfcElectricTimeControlTypeEnum::IfcElectricTimeControlTypeEnum PredefinedType() const;
    void setPredefinedType(IfcElectricTimeControlTypeEnum::IfcElectricTimeControlTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcFlowControllerType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcElectricTimeControlTypeEnum; } return IfcFlowControllerType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcFlowControllerType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcElectricTimeControlType (IfcEntityInstanceData* e);
    IfcElectricTimeControlType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcElectricTimeControlTypeEnum::IfcElectricTimeControlTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcElectricTimeControlType > list;
};
/// The distribution flow element IfcEnergyConversionDevice defines 
///   the occurrence of a device used to perform
///   energy conversion or heat transfer and typically participates
///   in a flow distribution system. Its type is defined by IfcEnergyConversionDeviceType 
///   or its subtypes.
/// 
/// HISTORY: New entity in IFC R2.0.
/// 
/// IFC 2x4 NOTE: This entity has been deprecated for instantiation and will become ABSTRACT in a future release; new subtypes should now be used instead.
class IFC_PARSE_API IfcEnergyConversionDevice : public IfcDistributionFlowElement {
public:
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcDistributionFlowElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcDistributionFlowElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcDistributionFlowElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcEnergyConversionDevice (IfcEntityInstanceData* e);
    IfcEnergyConversionDevice (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag);
    typedef IfcTemplatedEntityList< IfcEnergyConversionDevice > list;
};
/// An engine is a device that converts fuel into mechanical energy through combustion. 
/// 
/// HISTORY  New entity in IFC2x4
/// 
/// Type Use Definition
/// IfcEngine defines the occurrence of any engine; common information about engine types is handled by IfcEngineType. 
/// The IfcEngineType (if present) may establish the common type name, usage (predefined type), properties, materials, ports, composition, assignments, and representations. 
/// The IfcEngineType is attached using the IfcRelDefinesByType objectified relationship and is accessible by the IsTypedBy inverse attribute. 
/// If the IfcEngineType has ports or aggregated elements, such objects are reflected at the IfcEngine occurrence using the IfcRelDefinesByObject relationship.
/// 
/// Property Use Definition
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute. 
/// Property sets may also be specified at the IfcEngineType, defining the common property data for all occurrences of the same type. 
/// They are then accessible by the IsTypedBy inverse attribute pointing to IfcEngineType.HasPropertySets. 
/// If both are given, then the properties directly defined at IfcEngine override the properties defined at IfcEngineType. 
/// Refer to the documentation at the supertype IfcEnergyConversionDevice and ancestors for inherited property set definitions.
/// The following property set definitions are applicable to this entity:
/// Pset_EngineTypeCommon (PSET_TYPEDRIVENOVERRIDE)
/// 
/// Quantity Use Definition
/// The quantities relating to this entity are defined by IfcElementQuantity and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute.
/// The following base quantities are defined and shall be exchanged with the IfcElementQuantity.Name = 'BaseQuantities'. 
/// Other quantities, being subjected to local standard of measurement, may be defined with another string value assigned to Name. 
/// In this case a valid value for MethodOfMeasurement shall be provided. 
/// 
/// Qto_EngineBaseQuantities
/// 
/// Material Use Definition
/// The material of the IfcEngine is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship. It is accessible by the HasAssociations inverse attribute. Material information can also be given at the IfcEngineType, defining the common attribute data for all occurrences of the same type. The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used:
/// 
/// Body: The primary material from which the object is constructed.
/// 
/// Port Use Definition
/// The distribution ports relating to the IfcEngine are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship. 
///   If the engine occurrence is defined by IfcEngineType, then the port occurrences must reflect those defined at the IfcEngineType using the IfcRelDefinesByObject relationship.
///   Ports are specific to the IfcEngine PredefinedType as follows indicated by the IfcDistributionPort Name, PredefinedType, and FlowDirection:
/// 
/// Fuel (GAS, SINK): The fuel inlet.
/// Drive (NOTDEFINED, SOURCE): Connection to the driven source.
class IFC_PARSE_API IfcEngine : public IfcEnergyConversionDevice {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcEngine
    bool hasPredefinedType() const;
    IfcEngineTypeEnum::IfcEngineTypeEnum PredefinedType() const;
    void setPredefinedType(IfcEngineTypeEnum::IfcEngineTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcEnergyConversionDevice::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcEngineTypeEnum; } return IfcEnergyConversionDevice::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "PredefinedType"; } return IfcEnergyConversionDevice::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcEngine (IfcEntityInstanceData* e);
    IfcEngine (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcEngineTypeEnum::IfcEngineTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcEngine > list;
};
/// An evaporative cooler is a device that cools air by saturating it with water vapor. 
/// 
/// HISTORY  New entity in IFC2x4
/// 
/// Type Use Definition
/// IfcEvaporativeCooler defines the occurrence of any evaporative cooler; common information about evaporative cooler types is handled by IfcEvaporativeCoolerType. 
/// The IfcEvaporativeCoolerType (if present) may establish the common type name, usage (predefined type), properties, materials, ports, composition, assignments, and representations. 
/// The IfcEvaporativeCoolerType is attached using the IfcRelDefinesByType objectified relationship and is accessible by the IsTypedBy inverse attribute. 
/// If the IfcEvaporativeCoolerType has ports or aggregated elements, such objects are reflected at the IfcEvaporativeCooler occurrence using the IfcRelDefinesByObject relationship.
/// 
/// Property Use Definition
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute. 
/// Property sets may also be specified at the IfcEvaporativeCoolerType, defining the common property data for all occurrences of the same type. 
/// They are then accessible by the IsTypedBy inverse attribute pointing to IfcEvaporativeCoolerType.HasPropertySets. 
/// If both are given, then the properties directly defined at IfcEvaporativeCooler override the properties defined at IfcEvaporativeCoolerType. 
/// Refer to the documentation at the supertype IfcEnergyConversionDevice and ancestors for inherited property set definitions.
/// The following property set definitions are applicable to this entity:
/// Pset_EvaporativeCoolerPHistory (PSET_PERFORMANCEDRIVEN)
/// Pset_EvaporativeCoolerTypeCommon (PSET_TYPEDRIVENOVERRIDE)
/// 
/// Quantity Use Definition
/// The quantities relating to this entity are defined by IfcElementQuantity and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute.
/// The following base quantities are defined and shall be exchanged with the IfcElementQuantity.Name = 'BaseQuantities'. 
/// Other quantities, being subjected to local standard of measurement, may be defined with another string value assigned to Name. 
/// In this case a valid value for MethodOfMeasurement shall be provided. 
/// 
/// Qto_EvaporativeCoolerBaseQuantities
/// 
/// Material Use Definition
/// The material of the IfcEvaporativeCooler is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship. It is accessible by the HasAssociations inverse attribute. Material information can also be given at the IfcEvaporativeCoolerType, defining the common attribute data for all occurrences of the same type. The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used:
/// 
/// Body: The primary material from which the object is constructed.
/// Media: Heat exchanger media material.
/// 
/// Port Use Definition
/// The distribution ports relating to the IfcEvaporativeCooler are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship. 
///   If the evaporative cooler occurrence is defined by IfcEvaporativeCoolerType, then the port occurrences must reflect those defined at the IfcEvaporativeCoolerType using the IfcRelDefinesByObject relationship.
///   Ports are specific to the IfcEvaporativeCooler PredefinedType as follows indicated by the IfcDistributionPort Name, PredefinedType, and FlowDirection:
/// 
/// WaterIn (DOMESTICCOLDWATER, SINK): Incoming water.
/// AirIn (AIRCONDITIONING, SINK): Incoming air.
/// AirOut (AIRCONDITIONING, SOURCE): Outgoing air saturated with vapor.
class IFC_PARSE_API IfcEvaporativeCooler : public IfcEnergyConversionDevice {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcEvaporativeCooler
    bool hasPredefinedType() const;
    IfcEvaporativeCoolerTypeEnum::IfcEvaporativeCoolerTypeEnum PredefinedType() const;
    void setPredefinedType(IfcEvaporativeCoolerTypeEnum::IfcEvaporativeCoolerTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcEnergyConversionDevice::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcEvaporativeCoolerTypeEnum; } return IfcEnergyConversionDevice::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "PredefinedType"; } return IfcEnergyConversionDevice::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcEvaporativeCooler (IfcEntityInstanceData* e);
    IfcEvaporativeCooler (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcEvaporativeCoolerTypeEnum::IfcEvaporativeCoolerTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcEvaporativeCooler > list;
};
/// An evaporator is a device in which a liquid refrigerent is vaporized and absorbs heat from the surrounding fluid. 
/// 
/// HISTORY  New entity in IFC2x4
/// 
/// Type Use Definition
/// IfcEvaporator defines the occurrence of any evaporator; common information about evaporator types is handled by IfcEvaporatorType. 
/// The IfcEvaporatorType (if present) may establish the common type name, usage (predefined type), properties, materials, ports, composition, assignments, and representations. 
/// The IfcEvaporatorType is attached using the IfcRelDefinesByType objectified relationship and is accessible by the IsTypedBy inverse attribute. 
/// If the IfcEvaporatorType has ports or aggregated elements, such objects are reflected at the IfcEvaporator occurrence using the IfcRelDefinesByObject relationship.
/// 
/// Property Use Definition
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute. 
/// Property sets may also be specified at the IfcEvaporatorType, defining the common property data for all occurrences of the same type. 
/// They are then accessible by the IsTypedBy inverse attribute pointing to IfcEvaporatorType.HasPropertySets. 
/// If both are given, then the properties directly defined at IfcEvaporator override the properties defined at IfcEvaporatorType. 
/// Refer to the documentation at the supertype IfcEnergyConversionDevice and ancestors for inherited property set definitions.
/// The following property set definitions are applicable to this entity:
/// Pset_EvaporatorPHistory (PSET_PERFORMANCEDRIVEN)
/// Pset_EvaporatorTypeCommon (PSET_TYPEDRIVENOVERRIDE)
/// 
/// Quantity Use Definition
/// The quantities relating to this entity are defined by IfcElementQuantity and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute.
/// The following base quantities are defined and shall be exchanged with the IfcElementQuantity.Name = 'BaseQuantities'. 
/// Other quantities, being subjected to local standard of measurement, may be defined with another string value assigned to Name. 
/// In this case a valid value for MethodOfMeasurement shall be provided. 
/// 
/// Qto_EvaporatorBaseQuantities
/// 
/// Material Use Definition
/// The material of the IfcEvaporator is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship. It is accessible by the HasAssociations inverse attribute. Material information can also be given at the IfcEvaporatorType, defining the common attribute data for all occurrences of the same type. The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used:
/// 
/// Body: The primary material from which the object is constructed.
/// Refrigerant: Refrigerant material.
/// 
/// Port Use Definition
/// The distribution ports relating to the IfcEvaporator are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship. 
///   If the evaporator occurrence is defined by IfcEvaporatorType, then the port occurrences must reflect those defined at the IfcEvaporatorType using the IfcRelDefinesByObject relationship.
///   Ports are specific to the IfcEvaporator PredefinedType as follows indicated by the IfcDistributionPort Name, PredefinedType, and FlowDirection:
/// 
/// DIRECTEXPANSION
/// 
/// RefrigerantIn (REFRIGERATION, SINK): Liquid refrigerant entering the evaporator.
/// RefrigerantOut (REFRIGERATION, SOURCE): Vapor refrigerant leaving the evaporator.
/// AirIn (AIRCONDITIONING, SINK): Air return entering the evaporator.
/// AirOut (AIRCONDITIONING, SOURCE): Air supply leaving the evaporator.
/// 
/// FLOODEDSHELLANDTUBE
/// 
/// RefrigerantIn (REFRIGERATION, SINK): Liquid refrigerant entering the evaporator.
/// RefrigerantOut (REFRIGERATION, SOURCE): Vapor refrigerant leaving the evaporator.
/// ChilledWaterIn (CHILLEDWATER, SINK): Chilled water return entering the evaporator.
/// ChilledWaterOut (CHILLEDWATER, SOURCE): Chilled water supply leaving the evaporator.
/// ChilledWaterIn (CHILLEDWATER, SINK): Chilled water return entering the evaporator.
/// ChilledWaterOut (CHILLEDWATER, SOURCE): Chilled water supply leaving the evaporator.
/// 
/// SHELLANDCOIL
/// 
/// RefrigerantIn (REFRIGERATION, SINK): Liquid refrigerant entering the evaporator.
/// RefrigerantOut (REFRIGERATION, SOURCE): Vapor refrigerant leaving the evaporator.
/// 
/// Figure 223 illustrates evaporator port use.
/// Figure 223 — Evaporator port use
class IFC_PARSE_API IfcEvaporator : public IfcEnergyConversionDevice {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcEvaporator
    bool hasPredefinedType() const;
    IfcEvaporatorTypeEnum::IfcEvaporatorTypeEnum PredefinedType() const;
    void setPredefinedType(IfcEvaporatorTypeEnum::IfcEvaporatorTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcEnergyConversionDevice::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcEvaporatorTypeEnum; } return IfcEnergyConversionDevice::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "PredefinedType"; } return IfcEnergyConversionDevice::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcEvaporator (IfcEntityInstanceData* e);
    IfcEvaporator (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcEvaporatorTypeEnum::IfcEvaporatorTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcEvaporator > list;
};
/// Definition from IAI: The external spatial element
/// defines external regions at the building site. Those regions can
/// be defined:
/// 
/// logically - e.g. an instance of
/// IfcExternalSpatialElement could represent the air space
/// around the building without having an own shape representation,
/// or
/// physically - e.g. an instance of
/// IfcExternalSpatialElement could represent the sloping
/// ground around the building to identify the part of the external
/// building envelop that is below ground.
/// 
/// HISTORY New entity in
/// IFC2x4.
class IFC_PARSE_API IfcExternalSpatialElement : public IfcExternalSpatialStructureElement {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcExternalSpatialElement
    bool hasPredefinedType() const;
    /// Predefined generic types for an external spatial element that are specified in an enumeration. There might be property sets defined specifically for each predefined type.
    IfcExternalSpatialElementTypeEnum::IfcExternalSpatialElementTypeEnum PredefinedType() const;
    void setPredefinedType(IfcExternalSpatialElementTypeEnum::IfcExternalSpatialElementTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcExternalSpatialStructureElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcExternalSpatialElementTypeEnum; } return IfcExternalSpatialStructureElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "PredefinedType"; } return IfcExternalSpatialStructureElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcRelSpaceBoundary >::ptr BoundedBy() const; // INVERSE IfcRelSpaceBoundary::RelatingSpace
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcExternalSpatialElement (IfcEntityInstanceData* e);
    IfcExternalSpatialElement (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_LongName, boost::optional< IfcExternalSpatialElementTypeEnum::IfcExternalSpatialElementTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcExternalSpatialElement > list;
};
/// The flow moving device type IfcFanType defines commonly shared information for occurrences of fans.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a fan specification (i.e. the specific product information, that is common to all occurrences of that product type).  Fan types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcFanType are represented by instances of IfcFan. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcFlowMovingDeviceType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_FanTypeCommon 
/// Pset_FanTypeSmokeControl 
/// 
/// Material Use Definition 
/// The material of the IfcFanType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Housing': The material used to construct the fan housing. 
/// 'Wheel': The material used to construct the fan wheel. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcFanType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcFan for standard port definitions.
class IFC_PARSE_API IfcFanType : public IfcFlowMovingDeviceType {
public:
    /// Defines the type of fan typically used in building services.
    IfcFanTypeEnum::IfcFanTypeEnum PredefinedType() const;
    void setPredefinedType(IfcFanTypeEnum::IfcFanTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcFlowMovingDeviceType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcFanTypeEnum; } return IfcFlowMovingDeviceType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcFlowMovingDeviceType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcFanType (IfcEntityInstanceData* e);
    IfcFanType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcFanTypeEnum::IfcFanTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcFanType > list;
};
/// The flow treatment device type IfcFilterType defines commonly shared information for occurrences of filters.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a filter specification (i.e. the specific product information, that is common to all occurrences of that product type).  Filter types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcFilterType are represented by instances of IfcFilter. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcFlowTreatmentDeviceType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_FilterTypeCommon 
/// 
/// The following property set definitions are applicable to this entity according to the PredefinedType attribute:  
/// Pset_FilterTypeAirParticleFilter (AIRPARTICLEFILTER) 
/// 
/// Material Use Definition 
/// The material of the IfcFilterType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Media': The material that is used for filtering particulates from the fluid. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcFilterType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcFilter for standard port definitions.
class IFC_PARSE_API IfcFilterType : public IfcFlowTreatmentDeviceType {
public:
    /// The type of air filter.
    IfcFilterTypeEnum::IfcFilterTypeEnum PredefinedType() const;
    void setPredefinedType(IfcFilterTypeEnum::IfcFilterTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcFlowTreatmentDeviceType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcFilterTypeEnum; } return IfcFlowTreatmentDeviceType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcFlowTreatmentDeviceType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcFilterType (IfcEntityInstanceData* e);
    IfcFilterType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcFilterTypeEnum::IfcFilterTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcFilterType > list;
};
/// The flow terminal type IfcFireSuppressionTerminalType defines commonly shared information for occurrences of fire suppression terminals.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a fire suppression terminal specification (i.e. the specific product information, that is common to all occurrences of that product type).  Fire Suppression Terminal types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcFireSuppressionTerminalType are represented by instances of IfcFireSuppressionTerminal. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcFlowTerminalType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_FireSuppressionTerminalTypeCommon 
/// 
/// The following property set definitions are applicable to this entity according to the PredefinedType attribute:  
/// Pset_FireSuppressionTerminalTypeBreechingInlet (BREECHINGINLET) 
/// Pset_FireSuppressionTerminalTypeFireHydrant (FIREHYDRANT) 
/// Pset_FireSuppressionTerminalTypeHoseReel (HOSEREEL) 
/// Pset_FireSuppressionTerminalTypeSprinkler (SPRINKLER) 
/// 
/// Material Use Definition 
/// The material of the IfcFireSuppressionTerminalType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Body': The primary material from which the object is constructed. 
/// 'Deflector': The material used to construct the deflector plate. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcFireSuppressionTerminalType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcFireSuppressionTerminal for standard port definitions.
class IFC_PARSE_API IfcFireSuppressionTerminalType : public IfcFlowTerminalType {
public:
    /// Identifies the predefined types of fire suppression terminal from which the type required may be set.
    IfcFireSuppressionTerminalTypeEnum::IfcFireSuppressionTerminalTypeEnum PredefinedType() const;
    void setPredefinedType(IfcFireSuppressionTerminalTypeEnum::IfcFireSuppressionTerminalTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcFlowTerminalType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcFireSuppressionTerminalTypeEnum; } return IfcFlowTerminalType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcFlowTerminalType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcFireSuppressionTerminalType (IfcEntityInstanceData* e);
    IfcFireSuppressionTerminalType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcFireSuppressionTerminalTypeEnum::IfcFireSuppressionTerminalTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcFireSuppressionTerminalType > list;
};
/// The distribution flow element IfcFlowController defines
///   the occurrence of elements of a distribution system that 
///   are used to regulate flow through a distribution system. 
///   Examples include dampers, valves, switches, and relays. Its type is defined by 
///   IfcFlowControllerType or subtypes.
/// 
/// HISTORY: New entity in IFC R2.0.
/// 
/// IFC 2x4 NOTE: This entity has been deprecated for instantiation and will become ABSTRACT in a future release; new subtypes should now be used instead.
class IFC_PARSE_API IfcFlowController : public IfcDistributionFlowElement {
public:
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcDistributionFlowElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcDistributionFlowElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcDistributionFlowElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcFlowController (IfcEntityInstanceData* e);
    IfcFlowController (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag);
    typedef IfcTemplatedEntityList< IfcFlowController > list;
};
/// The distribution flow element IfcFlowFitting defines the occurrence of a junction or transition in a flow distribution system, such as an elbow or tee. Its type is defined by IfcFlowFittingType or its subtypes.
/// 
/// HISTORY: New entity in IFC R2.0.
/// 
/// IFC 2x4 NOTE: This entity has been deprecated for instantiation and will become ABSTRACT in a future release; new subtypes should now be used instead.
class IFC_PARSE_API IfcFlowFitting : public IfcDistributionFlowElement {
public:
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcDistributionFlowElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcDistributionFlowElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcDistributionFlowElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcFlowFitting (IfcEntityInstanceData* e);
    IfcFlowFitting (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag);
    typedef IfcTemplatedEntityList< IfcFlowFitting > list;
};
/// The distribution control element type IfcFlowInstrumentType defines commonly shared information for occurrences of flow instruments.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a flow instrument specification (i.e. the specific product information, that is common to all occurrences of that product type).  Flow Instrument types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcFlowInstrumentType are represented by instances of IfcFlowInstrument. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcDistributionControlElementType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_FlowInstrumentTypeCommon 
/// 
/// The following property set definitions are applicable to this entity according to the PredefinedType attribute:  
/// Pset_FlowInstrumentTypePressureGauge (PRESSUREGAUGE) 
/// Pset_FlowInstrumentTypeThermometer (THERMOMETER) 
/// 
/// Material Use Definition 
/// The material of the IfcFlowInstrumentType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Casing': Material from which the casing is constructed. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcFlowInstrumentType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcFlowInstrument for standard port definitions.
class IFC_PARSE_API IfcFlowInstrumentType : public IfcDistributionControlElementType {
public:
    /// Identifies the predefined types of flow instrument from which the type required may be set.
    IfcFlowInstrumentTypeEnum::IfcFlowInstrumentTypeEnum PredefinedType() const;
    void setPredefinedType(IfcFlowInstrumentTypeEnum::IfcFlowInstrumentTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcDistributionControlElementType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcFlowInstrumentTypeEnum; } return IfcDistributionControlElementType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcDistributionControlElementType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcFlowInstrumentType (IfcEntityInstanceData* e);
    IfcFlowInstrumentType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcFlowInstrumentTypeEnum::IfcFlowInstrumentTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcFlowInstrumentType > list;
};
/// A flow meter is a device that is used to measure the flow rate in a system. 
/// 
/// HISTORY  New entity in IFC2x4
/// 
/// Type Use Definition
/// IfcFlowMeter defines the occurrence of any flow meter; common information about flow meter types is handled by IfcFlowMeterType. 
/// The IfcFlowMeterType (if present) may establish the common type name, usage (predefined type), properties, materials, ports, composition, assignments, and representations. 
/// The IfcFlowMeterType is attached using the IfcRelDefinesByType objectified relationship and is accessible by the IsTypedBy inverse attribute. 
/// If the IfcFlowMeterType has ports or aggregated elements, such objects are reflected at the IfcFlowMeter occurrence using the IfcRelDefinesByObject relationship.
/// 
/// Property Use Definition
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute. 
/// Property sets may also be specified at the IfcFlowMeterType, defining the common property data for all occurrences of the same type. 
/// They are then accessible by the IsTypedBy inverse attribute pointing to IfcFlowMeterType.HasPropertySets. 
/// If both are given, then the properties directly defined at IfcFlowMeter override the properties defined at IfcFlowMeterType. 
/// Refer to the documentation at the supertype IfcFlowController and ancestors for inherited property set definitions.
/// The following property set definitions are applicable to this entity:
/// (All Types)
/// 
/// Pset_FlowMeterOccurrence (PSET_OCCURRENCEDRIVEN)
/// Pset_FlowMeterTypeCommon (PSET_TYPEDRIVENOVERRIDE)
/// 
/// ENERGYMETER
/// 
/// Pset_FlowMeterTypeEnergyMeter (PSET_TYPEDRIVENOVERRIDE)
/// 
/// GASMETER
/// 
/// Pset_FlowMeterTypeGasMeter (PSET_TYPEDRIVENOVERRIDE)
/// 
/// OILMETER
/// 
/// Pset_FlowMeterTypeOilMeter (PSET_TYPEDRIVENOVERRIDE)
/// 
/// WATERMETER
/// 
/// Pset_FlowMeterTypeWaterMeter (PSET_TYPEDRIVENOVERRIDE)
/// 
/// Quantity Use Definition
/// The quantities relating to this entity are defined by IfcElementQuantity and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute.
/// The following base quantities are defined and shall be exchanged with the IfcElementQuantity.Name = 'BaseQuantities'. 
/// Other quantities, being subjected to local standard of measurement, may be defined with another string value assigned to Name. 
/// In this case a valid value for MethodOfMeasurement shall be provided. 
/// 
/// Qto_FlowMeterBaseQuantities
/// 
/// Material Use Definition
/// The material of the IfcFlowMeter is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship. It is accessible by the HasAssociations inverse attribute. Material information can also be given at the IfcFlowMeterType, defining the common attribute data for all occurrences of the same type. The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used:
/// 
/// Body: The primary material from which the object is constructed.
/// 
/// Port Use Definition
/// The distribution ports relating to the IfcFlowMeter are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship. 
///   If the flow meter occurrence is defined by IfcFlowMeterType, then the port occurrences must reflect those defined at the IfcFlowMeterType using the IfcRelDefinesByObject relationship.
///   Ports are specific to the IfcFlowMeter PredefinedType as follows indicated by the IfcDistributionPort Name, PredefinedType, and FlowDirection:
/// 
/// ENERGYMETER
/// 
/// Inlet (ELECTRICAL, SINK): Inlet from utility.
/// Outlet (ELECTRICAL, SOURCE): Measured use.
/// 
/// GASMETER
/// 
/// Inlet (GAS, SINK): Inlet from utility.
/// Outlet (GAS, SOURCE): Measured use.
/// 
/// OILMETER
/// 
/// Inlet (OIL, SINK): Inlet from utility.
/// Outlet (OIL, SOURCE): Measured use.
/// 
/// WATERMETER
/// 
/// Inlet (DOMESTICCOLDWATER, SINK): Inlet from utility.
/// Outlet (DOMESTICCOLDWATER, SOURCE): Measured use.
/// 
/// Figure 226 illustrates flow meter port use.
/// Figure 226 — Flow meter port use
class IFC_PARSE_API IfcFlowMeter : public IfcFlowController {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcFlowMeter
    bool hasPredefinedType() const;
    IfcFlowMeterTypeEnum::IfcFlowMeterTypeEnum PredefinedType() const;
    void setPredefinedType(IfcFlowMeterTypeEnum::IfcFlowMeterTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcFlowController::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcFlowMeterTypeEnum; } return IfcFlowController::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "PredefinedType"; } return IfcFlowController::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcFlowMeter (IfcEntityInstanceData* e);
    IfcFlowMeter (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcFlowMeterTypeEnum::IfcFlowMeterTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcFlowMeter > list;
};
/// The distribution flow element IfcFlowMovingDevice defines the occurrence of an apparatus used to distribute, circulate or perform conveyance of fluids, including liquids and gases (such as a pump or fan), and typically participates in a flow distribution system. Its type is defined by IfcFlowMovingDeviceType or its subtypes.
/// 
/// HISTORY: New entity in IFC R2x.
/// 
/// IFC 2x4 NOTE: This entity has been deprecated for instantiation and will become ABSTRACT in a future release; new subtypes should now be used instead.
class IFC_PARSE_API IfcFlowMovingDevice : public IfcDistributionFlowElement {
public:
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcDistributionFlowElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcDistributionFlowElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcDistributionFlowElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcFlowMovingDevice (IfcEntityInstanceData* e);
    IfcFlowMovingDevice (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag);
    typedef IfcTemplatedEntityList< IfcFlowMovingDevice > list;
};
/// The distribution flow element IfcFlowSegment defines the occurrence of a segment of a flow distribution system.
/// 
/// HISTORY: New entity in IFC R2.0.
/// IFC 2x4 NOTE: This entity has been deprecated for instantiation and will become ABSTRACT in a future release; new subtypes should now be used instead.        
/// 
/// The IfcFlowSegment defines a particular occurrence of a segment inserted in the spatial context of a project. The parameters defining the type of the segment and/or its shape are defined by the IfcFlowSegmentType, which is related by the inverse relationship IsDefinedBy pointing to IfcRelDefinesByType.
/// 
/// Material Use Definition
/// The material of the IfcFlowSegment is defined using one of the following entities:
/// 
/// IfcMaterialProfileSetUsage : for parametric segments, this defines the cross section and alignment to the 'Axis' representation, from which the 'Body' representation may be generated.
/// 
/// IfcMaterialProfileSet : for non-parametric segments (having fixed length or path), this may define the cross section for analysis purposes, however the 'Body' representation is independently generated.
/// 
/// IfcMaterialConstituentSet : for elements containing multiple materials where profiles are not applicable, this indicates materials at named parts.
/// 
/// IfcMaterial : for elements comprised of a single material where profiles are not applicable, this indicates the material.
/// 
/// The material is attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.  Material information can also be given at the IfcFlowSegmentType, defining the common attribute data for all occurrences of the same type.  Standard names and material types are defined at subtypes.
/// 
/// Representation Use Definition
/// 
/// Standard representations are defined at the supertype IfcDistrubutionFlowElement.  For parametric flow segments where IfcMaterialProfileSetUsage is defined and an 'Axis' representation is defined, then the 'Body' representation may be generated using the 'SweptSolid' or 'AdvancedSweptSolid' representation types by sweeping the profile(s) along the axis.
class IFC_PARSE_API IfcFlowSegment : public IfcDistributionFlowElement {
public:
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcDistributionFlowElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcDistributionFlowElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcDistributionFlowElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcFlowSegment (IfcEntityInstanceData* e);
    IfcFlowSegment (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag);
    typedef IfcTemplatedEntityList< IfcFlowSegment > list;
};
/// The distribution flow element IfcFlowStorageDevice defines
///   the occurrence of a device that participates in a distribution
///   system and is used for temporary storage of a fluid
///   such as a liquid or a gas (e.g., tank). Its type is defined by 
/// 
/// IfcFlowStorageDeviceType or its subtypes.
/// 
/// HISTORY: New entity in IFC R2x.
/// 
/// IFC 2x4 NOTE: This entity has been deprecated for instantiation and will become ABSTRACT in a future release; new subtypes should now be used instead.
class IFC_PARSE_API IfcFlowStorageDevice : public IfcDistributionFlowElement {
public:
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcDistributionFlowElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcDistributionFlowElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcDistributionFlowElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcFlowStorageDevice (IfcEntityInstanceData* e);
    IfcFlowStorageDevice (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag);
    typedef IfcTemplatedEntityList< IfcFlowStorageDevice > list;
};
/// The distribution flow element IfcFlowTerminal defines the
///   occurrence of a permanently attached element that acts as a terminus or 
///   beginning of a distribution system (e.g., air outlet, drain, 
///   water closet, sink, etc.). A terminal is typically a point
///   at which a system interfaces with an external environment.
///   Its type is defined by IfcFlowTerminalType or
///   its subtypes.
/// 
/// HISTORY: New entity in IFC R2.0.
/// 
/// IFC 2x4 NOTE: This entity has been deprecated for instantiation and will become ABSTRACT in a future release; new subtypes should now be used instead.
class IFC_PARSE_API IfcFlowTerminal : public IfcDistributionFlowElement {
public:
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcDistributionFlowElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcDistributionFlowElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcDistributionFlowElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcFlowTerminal (IfcEntityInstanceData* e);
    IfcFlowTerminal (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag);
    typedef IfcTemplatedEntityList< IfcFlowTerminal > list;
};
/// The distribution flow element IfcFlowTreatmentDevice defines the occurrence of a device typically used to remove unwanted matter from a fluid, either liquid or gas, and typically participates in a flow distribution system.  Its type is defined by IfcFlowTreatmentDeviceType or its subtypes.
/// 
/// HISTORY: New entity in IFC R2x.
/// 
/// IFC 2x4 NOTE: This entity has been deprecated for instantiation and will become ABSTRACT in a future release; new subtypes should now be used instead.
class IFC_PARSE_API IfcFlowTreatmentDevice : public IfcDistributionFlowElement {
public:
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcDistributionFlowElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcDistributionFlowElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcDistributionFlowElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcFlowTreatmentDevice (IfcEntityInstanceData* e);
    IfcFlowTreatmentDevice (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag);
    typedef IfcTemplatedEntityList< IfcFlowTreatmentDevice > list;
};
/// A footing is a part of the foundation of a structure that spreads and transmits the load to the soil, either directly or via piles.
/// 
/// HISTORY New entity in IFC2x2
/// 
/// Note, slab foundations are not instantiated as IfcFooting but as IfcSlab or IfcSlabStandardCase with a predefined type of IfcSlabTypeEnum.BASESLAB.
/// 
/// Property Set Use Definition
/// 
/// The following property set definitions are part of this IFC release:
/// 
/// Pset_FootingCommon: common property set for all footing occurrences.
///   Pset_ReinforcementBarCountOfIndependentFooting: property set for independent IfcFooting occurrences.
///   Pset_ReinforcementBarPitchOfContinuousFooting: property set for continuous IfcFooting occurrences.
/// 
/// Quantity Use Definition 
///   The quantities relating to this entity are defined by IfcElementQuantity and attached by the IfcRelDefinesByProperties relationship. They are accessible by the IsDefinedBy inverse attribute. The following base quantities are defined and should be exchanged with the IfcElementQuantity.Name = 'BaseQuantities'. Other quantities, being subjected to local standard of measurement, can be defined with another string value assigned to Name. In this case a valid value for MethodOfMeasurement has to be provided.  
/// 
/// Qto_FootingBaseQuantities 
/// 
/// Geometry Use Definition
/// 
/// Local placement and product representations are defined by the supertype IfcBuildingElement.  Standard representations as defined at IfcBeamStandardCase or IfcSlabStandardCase should be used when applicable.
class IFC_PARSE_API IfcFooting : public IfcBuildingElement {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcFooting
    bool hasPredefinedType() const;
    /// The generic type of the footing.
    /// 
    /// IFC 2x4 change:  Attribute made optional.  Type information can be provided by IfcRelDefinesByType and IfcFootingType.
    IfcFootingTypeEnum::IfcFootingTypeEnum PredefinedType() const;
    void setPredefinedType(IfcFootingTypeEnum::IfcFootingTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcBuildingElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcFootingTypeEnum; } return IfcBuildingElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "PredefinedType"; } return IfcBuildingElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcFooting (IfcEntityInstanceData* e);
    IfcFooting (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcFootingTypeEnum::IfcFootingTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcFooting > list;
};
/// A heat exchanger is a device used to provide heat transfer between non-mixing media such as plate and shell and tube heat exchangers.
/// IfcHeatExchanger is commonly used on water-side distribution systems to recover energy from a liquid to another liquid (typically water-based), whereas IfcAirToAirHeatRecovery is commonly used on air-side distribution systems to recover energy from a gas to a gas (usually air). 
/// 
/// HISTORY  New entity in IFC2x4
/// 
/// Type Use Definition
/// IfcHeatExchanger defines the occurrence of any heat exchanger; common information about heat exchanger types is handled by IfcHeatExchangerType. 
/// The IfcHeatExchangerType (if present) may establish the common type name, usage (predefined type), properties, materials, ports, composition, assignments, and representations. 
/// The IfcHeatExchangerType is attached using the IfcRelDefinesByType objectified relationship and is accessible by the IsTypedBy inverse attribute. 
/// If the IfcHeatExchangerType has ports or aggregated elements, such objects are reflected at the IfcHeatExchanger occurrence using the IfcRelDefinesByObject relationship.
/// 
/// Property Use Definition
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute. 
/// Property sets may also be specified at the IfcHeatExchangerType, defining the common property data for all occurrences of the same type. 
/// They are then accessible by the IsTypedBy inverse attribute pointing to IfcHeatExchangerType.HasPropertySets. 
/// If both are given, then the properties directly defined at IfcHeatExchanger override the properties defined at IfcHeatExchangerType. 
/// Refer to the documentation at the supertype IfcEnergyConversionDevice and ancestors for inherited property set definitions.
/// The following property set definitions are applicable to this entity:
/// (All Types)
/// 
/// Pset_HeatExchangerTypeCommon (PSET_TYPEDRIVENOVERRIDE)
/// 
/// PLATE
/// 
/// Pset_HeatExchangerTypePlate (PSET_TYPEDRIVENOVERRIDE)
/// 
/// Quantity Use Definition
/// The quantities relating to this entity are defined by IfcElementQuantity and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute.
/// The following base quantities are defined and shall be exchanged with the IfcElementQuantity.Name = 'BaseQuantities'. 
/// Other quantities, being subjected to local standard of measurement, may be defined with another string value assigned to Name. 
/// In this case a valid value for MethodOfMeasurement shall be provided. 
/// 
/// Qto_HeatExchangerBaseQuantities
/// 
/// Material Use Definition
/// The material of the IfcHeatExchanger is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship. It is accessible by the HasAssociations inverse attribute. Material information can also be given at the IfcHeatExchangerType, defining the common attribute data for all occurrences of the same type. The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used:
/// 
/// Body: The primary material from which the object is constructed.
/// 
/// Port Use Definition
/// The distribution ports relating to the IfcHeatExchanger are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship. 
///   If the heat exchanger occurrence is defined by IfcHeatExchangerType, then the port occurrences must reflect those defined at the IfcHeatExchangerType using the IfcRelDefinesByObject relationship.
///   Ports are specific to the IfcHeatExchanger PredefinedType as follows indicated by the IfcDistributionPort Name, PredefinedType, and FlowDirection:
/// 
/// HeatingInlet (NOTDEFINED, SINK): Inlet of substance to be heated.
/// HeatingOutlet (NOTDEFINED, SOURCE): Outlet of substance to be heated.
/// CoolingInlet (NOTDEFINED, SINK): Inlet of substance to be cooled.
/// CoolingOutlet (NOTDEFINED, SOURCE): Outlet of substance to be cooled.
class IFC_PARSE_API IfcHeatExchanger : public IfcEnergyConversionDevice {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcHeatExchanger
    bool hasPredefinedType() const;
    IfcHeatExchangerTypeEnum::IfcHeatExchangerTypeEnum PredefinedType() const;
    void setPredefinedType(IfcHeatExchangerTypeEnum::IfcHeatExchangerTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcEnergyConversionDevice::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcHeatExchangerTypeEnum; } return IfcEnergyConversionDevice::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "PredefinedType"; } return IfcEnergyConversionDevice::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcHeatExchanger (IfcEntityInstanceData* e);
    IfcHeatExchanger (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcHeatExchangerTypeEnum::IfcHeatExchangerTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcHeatExchanger > list;
};
/// A humidifier is a device that adds moisture into the air. 
/// 
/// HISTORY  New entity in IFC2x4
/// 
/// Type Use Definition
/// IfcHumidifier defines the occurrence of any humidifier; common information about humidifier types is handled by IfcHumidifierType. 
/// The IfcHumidifierType (if present) may establish the common type name, usage (predefined type), properties, materials, ports, composition, assignments, and representations. 
/// The IfcHumidifierType is attached using the IfcRelDefinesByType objectified relationship and is accessible by the IsTypedBy inverse attribute. 
/// If the IfcHumidifierType has ports or aggregated elements, such objects are reflected at the IfcHumidifier occurrence using the IfcRelDefinesByObject relationship.
/// 
/// Property Use Definition
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute. 
/// Property sets may also be specified at the IfcHumidifierType, defining the common property data for all occurrences of the same type. 
/// They are then accessible by the IsTypedBy inverse attribute pointing to IfcHumidifierType.HasPropertySets. 
/// If both are given, then the properties directly defined at IfcHumidifier override the properties defined at IfcHumidifierType. 
/// Refer to the documentation at the supertype IfcEnergyConversionDevice and ancestors for inherited property set definitions.
/// The following property set definitions are applicable to this entity:
/// Pset_HumidifierPHistory (PSET_PERFORMANCEDRIVEN)
/// Pset_HumidifierTypeCommon (PSET_TYPEDRIVENOVERRIDE)
/// 
/// Quantity Use Definition
/// The quantities relating to this entity are defined by IfcElementQuantity and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute.
/// The following base quantities are defined and shall be exchanged with the IfcElementQuantity.Name = 'BaseQuantities'. 
/// Other quantities, being subjected to local standard of measurement, may be defined with another string value assigned to Name. 
/// In this case a valid value for MethodOfMeasurement shall be provided. 
/// 
/// Qto_HumidifierBaseQuantities
/// 
/// Material Use Definition
/// The material of the IfcHumidifier is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship. It is accessible by the HasAssociations inverse attribute. Material information can also be given at the IfcHumidifierType, defining the common attribute data for all occurrences of the same type. The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used:
/// 
/// Body: The primary material from which the object is constructed.
/// 
/// Port Use Definition
/// The distribution ports relating to the IfcHumidifier are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship. 
///   If the humidifier occurrence is defined by IfcHumidifierType, then the port occurrences must reflect those defined at the IfcHumidifierType using the IfcRelDefinesByObject relationship.
///   Ports are specific to the IfcHumidifier PredefinedType as follows indicated by the IfcDistributionPort Name, PredefinedType, and FlowDirection:
/// 
/// WaterIn (DOMESTICCOLDWATER, SINK): Incoming water.
/// AirIn (AIRCONDITIONING, SINK): Incoming air.
/// AirOut (AIRCONDITIONING, SOURCE): Outgoing air saturated with vapor.
class IFC_PARSE_API IfcHumidifier : public IfcEnergyConversionDevice {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcHumidifier
    bool hasPredefinedType() const;
    IfcHumidifierTypeEnum::IfcHumidifierTypeEnum PredefinedType() const;
    void setPredefinedType(IfcHumidifierTypeEnum::IfcHumidifierTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcEnergyConversionDevice::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcHumidifierTypeEnum; } return IfcEnergyConversionDevice::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "PredefinedType"; } return IfcEnergyConversionDevice::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcHumidifier (IfcEntityInstanceData* e);
    IfcHumidifier (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcHumidifierTypeEnum::IfcHumidifierTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcHumidifier > list;
};
/// An interceptor is a device designed and installed in order to separate and retain deleterious, hazardous or undesirable matter while permitting normal sewage or liquids to discharge into a collection system by gravity. 
/// 
/// HISTORY  New entity in IFC2x4
/// 
/// Type Use Definition
/// IfcInterceptor defines the occurrence of any interceptor; common information about interceptor types is handled by IfcInterceptorType. 
/// The IfcInterceptorType (if present) may establish the common type name, usage (predefined type), properties, materials, ports, composition, assignments, and representations. 
/// The IfcInterceptorType is attached using the IfcRelDefinesByType objectified relationship and is accessible by the IsTypedBy inverse attribute. 
/// If the IfcInterceptorType has ports or aggregated elements, such objects are reflected at the IfcInterceptor occurrence using the IfcRelDefinesByObject relationship.
/// 
/// Property Use Definition
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute. 
/// Property sets may also be specified at the IfcInterceptorType, defining the common property data for all occurrences of the same type. 
/// They are then accessible by the IsTypedBy inverse attribute pointing to IfcInterceptorType.HasPropertySets. 
/// If both are given, then the properties directly defined at IfcInterceptor override the properties defined at IfcInterceptorType. 
/// Refer to the documentation at the supertype IfcFlowTreatmentDevice and ancestors for inherited property set definitions.
/// The following property set definitions are applicable to this entity:
/// (All Types)
/// 
/// Pset_InterceptorTypeCommon (PSET_TYPEDRIVENOVERRIDE)
/// 
/// GREASE
/// 
/// Pset_InterceptorTypeGrease (PSET_TYPEDRIVENOVERRIDE)
/// 
/// OIL
/// 
/// Pset_InterceptorTypeOil (PSET_TYPEDRIVENOVERRIDE)
/// 
/// PETROL
/// 
/// Pset_InterceptorTypePetrol (PSET_TYPEDRIVENOVERRIDE)
/// 
/// Quantity Use Definition
/// The quantities relating to this entity are defined by IfcElementQuantity and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute.
/// The following base quantities are defined and shall be exchanged with the IfcElementQuantity.Name = 'BaseQuantities'. 
/// Other quantities, being subjected to local standard of measurement, may be defined with another string value assigned to Name. 
/// In this case a valid value for MethodOfMeasurement shall be provided. 
/// 
/// Qto_InterceptorBaseQuantities
/// 
/// Material Use Definition
/// The material of the IfcInterceptor is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship. It is accessible by the HasAssociations inverse attribute. Material information can also be given at the IfcInterceptorType, defining the common attribute data for all occurrences of the same type. The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used:
/// 
/// Body: The primary material from which the object is constructed.
/// Cover: Material from which the cover or grating is constructed.
/// Strainer: Material from which the strainer is constructed.
/// 
/// Port Use Definition
/// The distribution ports relating to the IfcInterceptor are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship. 
///   If the interceptor occurrence is defined by IfcInterceptorType, then the port occurrences must reflect those defined at the IfcInterceptorType using the IfcRelDefinesByObject relationship.
///   Ports are specific to the IfcInterceptor PredefinedType as follows indicated by the IfcDistributionPort Name, PredefinedType, and FlowDirection:
/// 
/// Inlet (DRAINAGE, SINK): Inlet drainage.
/// Outlet (DRAINAGE, SOURCE): Outlet drainage.
class IFC_PARSE_API IfcInterceptor : public IfcFlowTreatmentDevice {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcInterceptor
    bool hasPredefinedType() const;
    IfcInterceptorTypeEnum::IfcInterceptorTypeEnum PredefinedType() const;
    void setPredefinedType(IfcInterceptorTypeEnum::IfcInterceptorTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcFlowTreatmentDevice::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcInterceptorTypeEnum; } return IfcFlowTreatmentDevice::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "PredefinedType"; } return IfcFlowTreatmentDevice::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcInterceptor (IfcEntityInstanceData* e);
    IfcInterceptor (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcInterceptorTypeEnum::IfcInterceptorTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcInterceptor > list;
};
/// A junction box is an enclosure within which cables are connected.
/// Cables may be members of an electrical circuit (for electrical power systems) or be information carriers (in a telecommunications system). A junction box is typically intended to conceal a cable junction from sight, eliminate tampering or provide a safe place for electrical connection. 
/// 
/// HISTORY  New entity in IFC2x4
/// 
/// Type Use Definition
/// IfcJunctionBox defines the occurrence of any junction box; common information about junction box types is handled by IfcJunctionBoxType. 
/// The IfcJunctionBoxType (if present) may establish the common type name, usage (predefined type), properties, materials, ports, composition, assignments, and representations. 
/// The IfcJunctionBoxType is attached using the IfcRelDefinesByType objectified relationship and is accessible by the IsTypedBy inverse attribute. 
/// If the IfcJunctionBoxType has ports or aggregated elements, such objects are reflected at the IfcJunctionBox occurrence using the IfcRelDefinesByObject relationship.
/// Figure 200 illustrates junction box type use.
/// Figure 200 — Junction box type use
/// 
/// Property Use Definition
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute. 
/// Property sets may also be specified at the IfcJunctionBoxType, defining the common property data for all occurrences of the same type. 
/// They are then accessible by the IsTypedBy inverse attribute pointing to IfcJunctionBoxType.HasPropertySets. 
/// If both are given, then the properties directly defined at IfcJunctionBox override the properties defined at IfcJunctionBoxType. 
/// Refer to the documentation at the supertype IfcFlowFitting and ancestors for inherited property set definitions.
/// The following property set definitions are applicable to this entity:
/// Pset_JunctionBoxTypeCommon (PSET_TYPEDRIVENOVERRIDE)
/// 
/// Quantity Use Definition
/// The quantities relating to this entity are defined by IfcElementQuantity and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute.
/// The following base quantities are defined and shall be exchanged with the IfcElementQuantity.Name = 'BaseQuantities'. 
/// Other quantities, being subjected to local standard of measurement, may be defined with another string value assigned to Name. 
/// In this case a valid value for MethodOfMeasurement shall be provided. 
/// 
/// Qto_JunctionBoxBaseQuantities
/// 
/// Material Use Definition
/// The material of the IfcJunctionBox is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship. It is accessible by the HasAssociations inverse attribute. Material information can also be given at the IfcJunctionBoxType, defining the common attribute data for all occurrences of the same type. The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used:
/// 
/// Casing: Material from which the casing is constructed.
/// 
/// Connection Use Definition
/// The IfcJunctionBox may be connected to other objects as follows using the indicated relationship:
/// 
/// IfcDiscreteAccessory (IfcRelConnectsElements): Indicates a cover plate for the junction box, having ObjectType 'JunctionBoxCoverPlate'.
/// IfcOpeningElement (IfcRelFillsElements): Indicates embedding the junction box in a building element such as a wall.
/// 
/// Port Use Definition
/// The distribution ports relating to the IfcJunctionBox are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship. 
///   If the junction box occurrence is defined by IfcJunctionBoxType, then the port occurrences must reflect those defined at the IfcJunctionBoxType using the IfcRelDefinesByObject relationship.
///   Ports are specific to the IfcJunctionBox PredefinedType as follows indicated by the IfcDistributionPort Name, PredefinedType, and FlowDirection:
/// 
/// DATA
/// 
/// Line#1 (DATA, SINK): A data line, typically a cable connecting from a network router communications device.
/// Line#2 (DATA, SINK): A data line, typically a cable connecting from a network router communications device.
/// Gang#1 (DATA, SOURCE): A slot to house a data outlet containing one or more jacks, ordered from left-to-right.
/// Gang#2 (DATA, SOURCE): A slot to house a data outlet containing one or more jacks, ordered from left-to-right.
/// 
/// POWER
/// 
/// Line (ELECTRICAL, SINK): The electrical supply line, typically a cable connecting from another junction box or from a protective device within a distribution board.
/// Load (ELECTRICAL, SOURCE): The next load in the circuit, typically a cable connecting to another junction box.
/// Gang#1 (ELECTRICAL, SOURCE): A slot to house a switch or outlet, ordered from left-to-right.
/// Gang#2 (ELECTRICAL, SOURCE): A slot to house a switch or outlet, ordered from left-to-right.
/// Gang#3 (ELECTRICAL, SOURCE): A slot to house a switch or outlet, ordered from left-to-right.
/// Gang#4 (ELECTRICAL, SOURCE): A slot to house a switch or outlet, ordered from left-to-right.
/// 
/// Figure 201 illustrates junction box port use.
/// Figure 201 — Junction box port use
class IFC_PARSE_API IfcJunctionBox : public IfcFlowFitting {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcJunctionBox
    bool hasPredefinedType() const;
    IfcJunctionBoxTypeEnum::IfcJunctionBoxTypeEnum PredefinedType() const;
    void setPredefinedType(IfcJunctionBoxTypeEnum::IfcJunctionBoxTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcFlowFitting::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcJunctionBoxTypeEnum; } return IfcFlowFitting::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "PredefinedType"; } return IfcFlowFitting::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcJunctionBox (IfcEntityInstanceData* e);
    IfcJunctionBox (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcJunctionBoxTypeEnum::IfcJunctionBoxTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcJunctionBox > list;
};
/// A lamp is an artificial light source such as a light bulb or tube. 
/// 
/// HISTORY  New entity in IFC2x4
/// 
/// Type Use Definition
/// IfcLamp defines the occurrence of any lamp; common information about lamp types is handled by IfcLampType. 
/// The IfcLampType (if present) may establish the common type name, usage (predefined type), properties, materials, ports, composition, assignments, and representations. 
/// The IfcLampType is attached using the IfcRelDefinesByType objectified relationship and is accessible by the IsTypedBy inverse attribute. 
/// If the IfcLampType has ports or aggregated elements, such objects are reflected at the IfcLamp occurrence using the IfcRelDefinesByObject relationship.
/// Figure 202 illustrates lamp type use.
/// Figure 202 — Lamp type use
/// 
/// Property Use Definition
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute. 
/// Property sets may also be specified at the IfcLampType, defining the common property data for all occurrences of the same type. 
/// They are then accessible by the IsTypedBy inverse attribute pointing to IfcLampType.HasPropertySets. 
/// If both are given, then the properties directly defined at IfcLamp override the properties defined at IfcLampType. 
/// Refer to the documentation at the supertype IfcFlowTerminal and ancestors for inherited property set definitions.
/// The following property set definitions are applicable to this entity:
/// Pset_LampTypeCommon (PSET_TYPEDRIVENOVERRIDE)
/// 
/// Quantity Use Definition
/// The quantities relating to this entity are defined by IfcElementQuantity and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute.
/// The following base quantities are defined and shall be exchanged with the IfcElementQuantity.Name = 'BaseQuantities'. 
/// Other quantities, being subjected to local standard of measurement, may be defined with another string value assigned to Name. 
/// In this case a valid value for MethodOfMeasurement shall be provided. 
/// 
/// Qto_LampBaseQuantities
/// 
/// Material Use Definition
/// The material of the IfcLamp is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship. It is accessible by the HasAssociations inverse attribute. Material information can also be given at the IfcLampType, defining the common attribute data for all occurrences of the same type. The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used:
/// 
/// Bulb: Material from which the bulb is constructed such as glass.
/// Conductor: Material from which the conductor is constructed.
/// Filament: Material from which the filament is constructed.
/// 
/// Port Use Definition
/// The distribution ports relating to the IfcLamp are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship. 
///   If the lamp occurrence is defined by IfcLampType, then the port occurrences must reflect those defined at the IfcLampType using the IfcRelDefinesByObject relationship.
///   Ports are specific to the IfcLamp PredefinedType as follows indicated by the IfcDistributionPort Name, PredefinedType, and FlowDirection:
/// 
/// Socket (LIGHTING, SINK): The socket providing electricity.
/// 
/// Figure 203 illustrates lamp port use.
/// Figure 203 — Lamp port use
class IFC_PARSE_API IfcLamp : public IfcFlowTerminal {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcLamp
    bool hasPredefinedType() const;
    IfcLampTypeEnum::IfcLampTypeEnum PredefinedType() const;
    void setPredefinedType(IfcLampTypeEnum::IfcLampTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcFlowTerminal::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcLampTypeEnum; } return IfcFlowTerminal::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "PredefinedType"; } return IfcFlowTerminal::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcLamp (IfcEntityInstanceData* e);
    IfcLamp (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcLampTypeEnum::IfcLampTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcLamp > list;
};
/// A light fixture is a container that is designed for the purpose of housing one or more lamps and optionally devices that control, restrict or vary their emission. 
/// 
/// HISTORY  New entity in IFC2x4
/// 
/// Type Use Definition
/// IfcLightFixture defines the occurrence of any light fixture; common information about light fixture types is handled by IfcLightFixtureType. 
/// The IfcLightFixtureType (if present) may establish the common type name, usage (predefined type), properties, materials, ports, composition, assignments, and representations. 
/// The IfcLightFixtureType is attached using the IfcRelDefinesByType objectified relationship and is accessible by the IsTypedBy inverse attribute. 
/// If the IfcLightFixtureType has ports or aggregated elements, such objects are reflected at the IfcLightFixture occurrence using the IfcRelDefinesByObject relationship.
/// Figure 204 illustrates light fixture type use.
/// Figure 204 — Light fixture type use
/// 
/// Property Use Definition
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute. 
/// Property sets may also be specified at the IfcLightFixtureType, defining the common property data for all occurrences of the same type. 
/// They are then accessible by the IsTypedBy inverse attribute pointing to IfcLightFixtureType.HasPropertySets. 
/// If both are given, then the properties directly defined at IfcLightFixture override the properties defined at IfcLightFixtureType. 
/// Refer to the documentation at the supertype IfcFlowTerminal and ancestors for inherited property set definitions.
/// The following property set definitions are applicable to this entity:
/// (All Types)
/// 
/// Pset_LightFixtureTypeCommon (PSET_TYPEDRIVENOVERRIDE)
/// Pset_LightFixtureTypeThermal (PSET_TYPEDRIVENOVERRIDE)
/// 
/// SECURITYLIGHTING
/// 
/// Pset_LightFixtureTypeSecurityLighting (PSET_TYPEDRIVENOVERRIDE)
/// 
/// Quantity Use Definition
/// The quantities relating to this entity are defined by IfcElementQuantity and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute.
/// The following base quantities are defined and shall be exchanged with the IfcElementQuantity.Name = 'BaseQuantities'. 
/// Other quantities, being subjected to local standard of measurement, may be defined with another string value assigned to Name. 
/// In this case a valid value for MethodOfMeasurement shall be provided. 
/// 
/// Qto_LightFixtureBaseQuantities
/// 
/// Material Use Definition
/// The material of the IfcLightFixture is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship. It is accessible by the HasAssociations inverse attribute. Material information can also be given at the IfcLightFixtureType, defining the common attribute data for all occurrences of the same type. The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used:
/// 
/// Casing: Material from which the casing is constructed.
/// 
/// Connection Use Definition
/// The IfcLightFixture may be connected to other objects as follows using the indicated relationship:
/// 
/// IfcCovering (IfcRelConnectsElements): Indicates a suspended ceiling anchoring the light fixture.
/// IfcOpeningElement (IfcRelFillsElements): Indicates embedding the light fixture in a building element such as a suspended ceiling.
/// 
/// Port Use Definition
/// The distribution ports relating to the IfcLightFixture are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship. 
///   If the light fixture occurrence is defined by IfcLightFixtureType, then the port occurrences must reflect those defined at the IfcLightFixtureType using the IfcRelDefinesByObject relationship.
///   Ports are specific to the IfcLightFixture PredefinedType as follows indicated by the IfcDistributionPort Name, PredefinedType, and FlowDirection:
/// 
/// Line (ELECTRICAL, SINK): The power supply line, typically a cable connected to a switch. 
/// Socket#1 (LIGHTING, SOURCE): A lamp socket within the light fixture.
/// Socket#2 (LIGHTING, SOURCE): A lamp socket within the light fixture.
/// Socket#3 (LIGHTING, SOURCE): A lamp socket within the light fixture.
/// Socket#4 (LIGHTING, SOURCE): A lamp socket within the light fixture.
/// Socket#5 (LIGHTING, SOURCE): A lamp socket within the light fixture.
/// Socket#6 (LIGHTING, SOURCE): A lamp socket within the light fixture.
/// Socket#7 (LIGHTING, SOURCE): A lamp socket within the light fixture.
/// Socket#8 (LIGHTING, SOURCE): A lamp socket within the light fixture.
/// 
/// Figure 205 illustrates light fixture port use.
/// Figure 205 — Light fixture port use
class IFC_PARSE_API IfcLightFixture : public IfcFlowTerminal {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcLightFixture
    bool hasPredefinedType() const;
    IfcLightFixtureTypeEnum::IfcLightFixtureTypeEnum PredefinedType() const;
    void setPredefinedType(IfcLightFixtureTypeEnum::IfcLightFixtureTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcFlowTerminal::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcLightFixtureTypeEnum; } return IfcFlowTerminal::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "PredefinedType"; } return IfcFlowTerminal::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcLightFixture (IfcEntityInstanceData* e);
    IfcLightFixture (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcLightFixtureTypeEnum::IfcLightFixtureTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcLightFixture > list;
};
/// A medical device is attached to a medical piping system and operates upon medical gases to perform a specific function. Medical gases include medical air, medical vacuum, oxygen, carbon dioxide, nitrogen, and nitrous oxide.
/// Outlets for medical gasses should use IfcValve with PredefinedType equal to GASTAP, containing an IfcDistributionPort with FlowDirection=SINK and PredefinedType equal to COMPRESSEDAIR, VACUUM, or CHEMICAL, and having property sets on the port further indicating the gas type and pressure. Tanks for medical gasses should use IfcTank with PredefinedType equal to PRESSUREVESSEL, containing an IfcDistributionPort with FlowDirection=SOURCE and PredefinedType=CHEMICAL, and having property sets on the port further indicating the gas type and pressure range. 
/// 
/// HISTORY  New entity in IFC2x4
/// 
/// Type Use Definition
/// IfcMedicalDevice defines the occurrence of any medical device; common information about medical device types is handled by IfcMedicalDeviceType. 
/// The IfcMedicalDeviceType (if present) may establish the common type name, usage (predefined type), properties, materials, ports, composition, assignments, and representations. 
/// The IfcMedicalDeviceType is attached using the IfcRelDefinesByType objectified relationship and is accessible by the IsTypedBy inverse attribute. 
/// If the IfcMedicalDeviceType has ports or aggregated elements, such objects are reflected at the IfcMedicalDevice occurrence using the IfcRelDefinesByObject relationship.
/// 
/// Property Use Definition
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute. 
/// Property sets may also be specified at the IfcMedicalDeviceType, defining the common property data for all occurrences of the same type. 
/// They are then accessible by the IsTypedBy inverse attribute pointing to IfcMedicalDeviceType.HasPropertySets. 
/// If both are given, then the properties directly defined at IfcMedicalDevice override the properties defined at IfcMedicalDeviceType. 
/// Refer to the documentation at the supertype IfcFlowTerminal and ancestors for inherited property set definitions.
/// The following property set definitions are applicable to this entity:
/// Pset_MedicalDeviceTypeCommon (PSET_TYPEDRIVENOVERRIDE)
/// 
/// Quantity Use Definition
/// The quantities relating to this entity are defined by IfcElementQuantity and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute.
/// The following base quantities are defined and shall be exchanged with the IfcElementQuantity.Name = 'BaseQuantities'. 
/// Other quantities, being subjected to local standard of measurement, may be defined with another string value assigned to Name. 
/// In this case a valid value for MethodOfMeasurement shall be provided. 
/// 
/// Qto_MedicalDeviceBaseQuantities
/// 
/// Material Use Definition
/// The material of the IfcMedicalDevice is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship. It is accessible by the HasAssociations inverse attribute. Material information can also be given at the IfcMedicalDeviceType, defining the common attribute data for all occurrences of the same type. The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used:
/// 
/// Body: The primary material from which the object is constructed.
/// 
/// Port Use Definition
/// The distribution ports relating to the IfcMedicalDevice are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship. 
///   If the medical device occurrence is defined by IfcMedicalDeviceType, then the port occurrences must reflect those defined at the IfcMedicalDeviceType using the IfcRelDefinesByObject relationship.
///   Ports are specific to the IfcMedicalDevice PredefinedType as follows indicated by the IfcDistributionPort Name, PredefinedType, and FlowDirection:
/// 
/// VACUUMSTATION
/// 
/// Power (ELECTRICAL, SINK): Receives electrical power.
/// VacuumOut (VACUUM, SOURCE): Provides suction.
class IFC_PARSE_API IfcMedicalDevice : public IfcFlowTerminal {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcMedicalDevice
    bool hasPredefinedType() const;
    IfcMedicalDeviceTypeEnum::IfcMedicalDeviceTypeEnum PredefinedType() const;
    void setPredefinedType(IfcMedicalDeviceTypeEnum::IfcMedicalDeviceTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcFlowTerminal::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcMedicalDeviceTypeEnum; } return IfcFlowTerminal::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "PredefinedType"; } return IfcFlowTerminal::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcMedicalDevice (IfcEntityInstanceData* e);
    IfcMedicalDevice (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcMedicalDeviceTypeEnum::IfcMedicalDeviceTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcMedicalDevice > list;
};
/// An IfcMember is a
/// structural member designed to carry loads between or beyond
/// points of support. It is not required to be load bearing. The
/// orientation of the member (being horizontal, vertical or sloped)
/// is not relevant to its definition (in contrary to IfcBeam
/// and IfcColumn). An IfcMember represents a linear
/// structural element from an architectural or structural modeling
/// point of view and shall be used if it cannot be expressed more
/// specifically as either an IfcBeam or an
/// IfcColumn.
/// NOTE The representation of a member in a
/// structural analysis model is provided by
/// IfcStructuralCurveMember being part of an
/// IfcStructuralAnalysisModel.
/// The IFC specification provides two entities for member
/// occurrences:
/// 
/// IfcMemberStandardCase used for all occurrences of
/// members, that have a profile defined that is swept along a
/// directrix. The profile might be changed uniformly by a taper
/// definition along the directrix. The profile parameter and its
/// cardinal point of insertion can be fully described by the
/// IfcMaterialProfileSetUsage. These beams are always
/// represented geometricly by an 'Axis' and a 'SweptSolid' or
/// 'AdvancedSweptSolid' shape representation (or by a 'Clipping'
/// geometry based on the swept solid), if a 3D geometric
/// representation is assigned. In addition they have to have a
/// corresponding IfcMaterialProfileSetUsage assigned.
/// NOTEÿ View definitions and implementer
/// agreements may further constrain the applicable geometry types,
/// e.g. by excluding tapering from an IfcMemberStandardCase
/// implementation.
/// 
/// IfcMember used for all other occurrences of members,
/// particularly for members with changing profile sizes along the
/// extrusion, or members defined by non-linear extrusion, or members
/// having only 'Brep', or 'SurfaceModel' geometry.
/// 
/// HISTORY New entity in
/// IFC Release 2x2 Addendum.
/// Type Use Definition
/// IfcMember defines the occuurence of any member, common
/// information about member types (or styles) is handled by
/// IfcMemberType. The IfcMemberType (if present) may
/// establish the commonÿtype name, usage (or predefined) type,
/// common material profile set, common set of properties and common
/// shape representations (using IfcRepresentationMap). The
/// IfcMemberType is attached using the
/// IfcRelDefinedByType.RelatingType objectified relationship
/// and is accessible by the inverse IsTypedBy attribute.
/// If no IfcMemberType is attachedÿ(i.e. if only
/// occurrence information is given) the PredefinedType should
/// be provided. If set to .USERDEFINED. a user defined value can be
/// provided by the ObjectType attribute.
/// Material Use Definition
/// The material of the IfcMember is defined by the
/// IfcMaterialProfileSet or as fallback by IfcMaterial
/// and attached by the
/// IfcRelAssociatesMaterial.RelatingMaterial. It is
/// accessible by the inverse HasAssociations relationship.
/// Material information can also be given at
/// theÿIfcMemberType, defining the common attribute data for
/// all occurrences of the same type.ÿIt is then accessible by the
/// inverse <IsTypedBy
/// relationship pointing to IfcMemberType.HasAssociations and
/// via IfcRelAssociatesMaterial.RelatingMaterial to
/// IfcMaterialProfileSet or IfcMaterial. If both are
/// given, then the material directly assigned to IfcMember
/// overrides the material assigned toÿIfcMemberType.
/// Property Set Use Definition
/// The property sets relating to the IfcMember are defined
/// by the IfcPropertySet and attached by the
/// IfcRelDefinesByProperties relationship. It is accessible
/// by the inverse IsDefinedBy relationship. The following
/// property set definitions specific to the IfcMember are
/// part of this IFC release:
/// 
/// Pset_MemberCommon: common property set for all
/// member occurrences
/// 
/// Quantity Use Definition
/// The quantities relating to the IfcMember and
/// IfcMemberStandardCase are defined by the
/// IfcElementQuantity and attached by the
/// IfcRelDefinesByProperties relationship. It is accessible
/// by the inverse IsDefinedBy relationship. The following
/// base quantities are defined and should be exchanged with the
/// IfcElementQuantity.Name = 'BaseQuantities'. Other
/// quantities can be defined being subjected to local standard of
/// measurement with another string value assigned to Name and
/// a value provided for MethodOfMeasurement. Quanties shall
/// be never assigned to the IfcMemberType.
/// 
/// Qto_MemberBaseQuantities: base quantities for
/// all member occurrences.
/// 
/// Containment Use Definition
/// The IfcMember, as any subtype of
/// IfcBuildingElement, may participate in two different
/// containment relationships. The first (and in most implementation
/// scenarios mandatory) relationship is the hierachical spatial
/// containment, the second (optional) relationship is the
/// aggregation within anÿelement assembly.
/// 
/// The IfcMember is places within the project spatial
/// hierarchy using the objectified relationship
/// IfcRelContainedInSpatialStructure, refering to it by its
/// inverse attribute SELF\IfcElement.ContainedInStructure.
/// Subtypes ofÿIfcSpatialStructureElement are valid spatial
/// containers, with IfcBuildingStorey being the default
/// container.
/// The IfcMember may be aggregated into an element
/// assembly using the objectified relationship
/// IfcRelAggregates, refering to it by its inverse attribute
/// SELF\IfcObjectDefinition.Decomposes. Any subtype of
/// IfcElement can be an element assembly, with
/// IfcElementAssembly as a special focus subtype. In this
/// case it should not be additionally contained in the project
/// spatial hierarchy, i.e.
/// SELF\IfcElement.ContainedInStructure should be
/// NIL.
/// 
/// Geometry Use Definition
/// The geometric representation of IfcMember is given by
/// the IfcProductDefinitionShape, allowing multiple geometric
/// representations. Included are:
/// Local Placement
/// The local placement for IfcMember is defined in its
/// supertype IfcProduct. It is defined by the
/// IfcLocalPlacement, which defines the local coordinate
/// system that is referenced by all geometric representations.
/// 
/// The PlacementRelTo relationship of
/// IfcLocalPlacement shall point (if given) to the local
/// placement of the same IfcSpatialStructureElement, which is
/// used in the ContainedInStructure inverse attribute, or to
/// a spatial structure element at a higher level, referenced by
/// that.
/// If the relative placement is not used, the absolute placement
/// is defined within the world coordinate system.
/// 
/// Geometric Representation
/// Currently, the 'Axis', 'Body',
/// and 'Box' representations are supported. The 'Box' representation
/// includes the representation type 'BoundingBox' and is explained
/// at IfcBuildingElement.
/// Axis Representation
/// The axis geometric representation of IfcMember is
/// defined using the 'Axis' representation. The following attribute
/// values for the IfcShapeRepresentation holding this
/// geometric representation shall be used:
/// 
/// RepresentationIdentifier : 'Axis'
/// RepresentationType : 'Curve2D', 'Curve3D'
/// 
/// The axis representation can be used to represent the system
/// length of a member that may extent the body length of the
/// member.
/// Body Representation
/// The body representation of IfcBeam can be represented
/// using the representation types 'SweptSolid', 'Clipping',
/// 'AdvancedSweptSolid', 'MappedRepresentation', 'SurfaceModel', and
/// 'Brep'. The representation types 'SurfaceModel' and 'Brep' are
/// explained at IfcBuildingElement.
/// SweptSolid Representation Type
/// The following attribute values for the
/// IfcShapeRepresentation holding this geometric
/// representation shall be used:
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'SweptSolid'
/// 
/// The following additional constraints apply to the 'SweptSolid'
/// representation:
/// 
/// Solid: IfcExtrudedAreaSolid,
/// IfcRevolvedAreaSolid shall be supported
/// Profile: all subtypes of IfcProfileDef (with
/// exception of IfcArbitraryOpenProfileDef)ÿ
/// Extrusion: All extrusion directions shall be
/// supported.
/// 
/// Figure 99 illustrates a 'SweptSolid' geometric representation.  There are no restrictions or conventions on
/// how to use the local placement (black), solid of extrusion placement (red) and profile placement (green).
/// 
/// Figure 99 — Member swept solid
/// 
/// Clipping Representation Type
/// The following attribute values for the
/// IfcShapeRepresentation holding this geometric
/// representation shall be used:
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'Clipping'
/// 
/// The following constraints apply to the advanced
/// representation:
/// 
/// Solid: see 'SweptSolid' geometric representation
/// Profile: see 'SweptSolid' geometric
/// representation
/// Extrusion:ÿsee 'SweptSolid' geometric
/// representation
/// Boolean result: The IfcBooleanClippingResult
/// shall be supported, allowing for Boolean differences between the
/// swept solid (here IfcExtrudedAreaSolid) and one or several
/// IfcHalfSpaceSolid (or its subtypes).
/// 
/// Figure 100 illustrates a 'Clipping' geometric representation with use of IfcBooleanClippingResult between an IfcExtrudedAreaSolid and an IfcHalfSpaceSolid to create a clipped body.
/// 
/// Figure 100 — Member clipping
/// 
/// AdvancedSweptSolid Representation Type
/// The following attribute values for the
/// IfcShapeRepresentation holding this geometric
/// representation shall be used:
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'AdvancedSweptSolid'
/// 
/// The following additional constraints apply to the
/// 'AdvancedSweptSolid' representation type:
/// 
/// Solid: IfcSurfaceCurveSweptAreaSolid,
/// IfcFixedReferenceSweptAreaSolid,
/// IfcExtrudedAreaSolidTapered,
/// IfcRevolvedAreaSolidTapered shall be supported.
/// NOTE View definitions and implementer
/// agreements can further constrain the allowed swept solid
/// types.
/// 
/// Profile: see 'SweptSolid' geometric
/// representation
/// Extrusion:ÿnot applicable
/// 
/// MappedRepresentation Representation Type
/// The 'MappedRepresentation' representation type is supported as
/// it allows for reusing the geometry definition of the beam type at
/// all occurrences of the same type. The following attribute values
/// for the IfcShapeRepresentation holding this geometric
/// representation shall be used:
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'MappedRepresentation'
/// 
/// The same constraints, as given for theÿ 'SweptSolid',
/// 'Clipping', 'AdvancedSweptSolid', 'SurfaceModel' and 'Bre'
/// geometric representation, shall apply to the
/// MappedRepresentation of the
/// IfcRepresentationMap.
class IFC_PARSE_API IfcMember : public IfcBuildingElement {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcMember
    bool hasPredefinedType() const;
    /// Predefined generic type for a member that is specified in an enumeration. There may be a property set given for the predefined types.
    ///   NOTE The PredefinedType shall only be used, if no type object IfcMemberType is assigned, providing its own IfcMemberType.PredefinedType.
    /// 
    /// IFC2x4 CHANGE  The attribute has been added at the end of the entity definition.
    IfcMemberTypeEnum::IfcMemberTypeEnum PredefinedType() const;
    void setPredefinedType(IfcMemberTypeEnum::IfcMemberTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcBuildingElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcMemberTypeEnum; } return IfcBuildingElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "PredefinedType"; } return IfcBuildingElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcMember (IfcEntityInstanceData* e);
    IfcMember (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcMemberTypeEnum::IfcMemberTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcMember > list;
};
/// The standard member,
/// IfcMemberStandardCase, defines a member with certain
/// constraints for the provision of material usage, parameters and
/// with certain constraints for the geometric representation. The
/// IfcMemberStandardCase handles all cases of members,
/// that:
/// 
/// have a reference to the IfcMaterialProfileSetUsage
/// defining the material profile association of the member with the
/// cardinal point of its insertion relative to the local
/// placement.
/// are based on a sweep of a planar profile, or set of profiles,
/// as defined by the IfcMaterialProfileSet
/// have an 'Axis' shape representation with constraints provided
/// below in the geometry use definition
/// have a 'Body' shape representation with constraints provided
/// below in the geometry use definition
/// have a start profile, or set of profiles, that is swept along
/// the directrix and might be changed uniformly by a taper
/// definition
/// are consistent in using the correct cardinal point offset of
/// the profile as compared to the 'Axis' and 'Body' shape
/// representation
/// are extruded perpendicular to the profile definition
/// plane
/// 
/// NOTEÿ View definitions and implementer
/// agreements may further constrain the applicable geometry types,
/// e.g. by excluding tapering from an IfcMemberStandardCase
/// implementation.
/// 
/// HISTORY New entity in IFC2x4.
/// 
/// Type Use Definition
/// IfcMember defines the occuurence of any member, common
/// information about member types (or styles) is handled by
/// IfcMemberType. The IfcMemberType (if present) may
/// establish the commonÿtype name, usage (or predefined) type,
/// common material layer set, common set of properties and common
/// shape representations (using IfcRepresentationMap). The
/// IfcMemberType is attached using the
/// IfcRelDefinedByType.RelatingType objectified relationship
/// and is accessible by the inverse IsDefinedBy
/// attribute.
/// The IfcMemberStandardCase defines in addition that the
/// IfcMemberType should have a unique
/// IfcMaterialProfileSet, that is referenced by the
/// IfcMaterialProfileSetUsage assigned to all occurrences of
/// this beam type.
/// 
/// Figure 101 illustrates assignment of IfcMaterialProfileSetUsage and IfcMaterialProfileSet to the IfcMemberStandardCase as the member occurrence and to the IfcMemberType. The same IfcMaterialProfileSet shall be shared by many occurrences of IfcMaterialProfileSetUsage. This relationship shall be consistent to the relationship between the IfcMemberType and the IfcMemberStandardCase.
/// 
/// Figure 101 — Member profile usage
/// 
/// Figure 102 illustrates assignment of a composite profile by using IfcCompositeProfile for geometric representation and several IfcMaterialProfile's within the IfcMaterialProfileSet. The number of IfcMaterialProfile's within the IfcMaterialProfileSet is restricted to maximal 2 and
/// requires the use of IfcExtrudedAreaSolidTapered, or IfcRevolvedAreaSolidTapered for the correct 'Body' shape representation.
/// 
/// Figure 102 — Member composite profiles
/// 
/// Material Use Definition
/// The material of the IfcMemberStandardCase is defined by
/// IfcMaterialProfileSetUsage and attached by the
/// IfcRelAssociatesMaterial.RelatingMaterial. It is
/// accessible by the inverse HasAssociations relationship.
/// Composite profile members can be represented by refering to
/// several IfcMaterialProfile's within the
/// IfcMaterialProfileSet that is referenced from the
/// IfcMaterialProfileSetUsage.
/// Material information can also be given at the
/// IfcMemberType, defining the common attribute data for all
/// occurrences of the same type. It is then accessible by the
/// inverse IsDefinedBy relationship pointing to
/// IfcMemberType.HasAssociations and via
/// IfcRelAssociatesMaterial.RelatingMaterial. See Type Use
/// Definition for additional agreements for standard
/// members.
/// Property Set Use Definition:
/// The property sets relating to the IfcMemberStandardCase
/// are defined at the supertype IfcMember.
/// Quantity Use Definition
/// The quantities relating to the IfcMemberStandardCase
/// are defined at the supertype IfcMember.
/// Containment Use Definition
/// The containment use definitions relating to the
/// IfcMemberStandardCase are defined at the supertype
/// IfcMember.
/// Geometry Use Definitions:
/// The geometric representation of IfcMemberStandardCase
/// is given by the IfcProductDefinitionShape, allowing
/// multiple geometric representations. Included are:
/// Local Placement
/// The use of local placement is defined at the supertype
/// IfcMember.
/// Geometric Representations
/// The geometric representation of IfcMemberStandardCase
/// is defined using the following multiple shape representations for
/// its definition:
/// 
/// Axis: A two- or three dimensional open curve
/// (IfcBoundedCurve) defining the axis for the standard
/// member. The cardinal point is determined by the member axis.
/// Body: A Swept Solid Representation or a CSG
/// representation defining the 3D shape of the standard member.
/// 
/// NOTE It is invalid to exchange a
/// 'SurfaceModel', 'Brep', or 'MappedRepresentation' representation
/// for the 'Body' shape representation of an
/// IfcMemberStandardCase.
/// Axis Representation
/// The axis geometric representation of
/// IfcMemberStandardCase is defined using the 'Axis'
/// representation. The following attribute values for the
/// IfcShapeRepresentation holding this geometric
/// representation shall be used:
/// 
/// RepresentationIdentifier : 'Axis'
/// RepresentationType : 'Curve2D', or 'Curve3D'
/// 
/// The following additional constraints apply to the 'Axis'
/// representation:
/// 
/// Axis : IfcPolyline having two Points, or
/// IfcTrimmedCurve with BasisCurve of Type
/// IfcLine.
/// 
/// As shown in Figure 103, the axis representation can be used to represent the system length of a member that may extent the body length of the member.
/// 
/// Figure 103 — Member axis representation
/// 
/// As shown in Figure 104, the axis representation shall be used to represent the cardinal point as the offset between the 'Axis' and the extrusion path of the member. The extrusion path is provided as IfcExtrudedAreaSolid.ExtrudedDirection and should be parallel to the 'Axis'.  It has to be guaranteed that the value provided by IfcMaterialProfileSetUsage.CardinalPoint is consistent to the IfcExtrudedAreaSolid.Position.
/// 
/// Figure 104 — Member axis cardinal point
/// 
/// Body Representation
/// The body representation of IfcMemberStandardCase can be
/// represented using the representation types 'SweptSolid',
/// 'Clipping', or 'AdvancedSweptSolid'.
/// SweptSolid Representation Type
/// The standard geometric representation of
/// IfcMemberStandardCase is defined using the 'SweptSolid'
/// representation. The following attribute values for the
/// IfcShapeRepresentation holding this geometric
/// representation shall be used:
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'SweptSolid'
/// 
/// The following additional constraints apply to the 'SweptSolid'
/// representation:
/// 
/// Solid: IfcExtrudedAreaSolid,
/// IfcRevolvedAreaSolid shall be supported
/// Profile: all subtypes of IfcProfileDef (with
/// exception of IfcArbitraryOpenProfileDef)
/// Profile Position : For all single profiles, the
/// IfcParameterizedProfileDef.Position shall be NIL, or
/// having Location = 0.,0. and RefDirection =
/// 1.,0.
/// Extrusion:ÿperpendicular to the profile
/// direction.
/// Orientation: The y-axis of the profile, as determined
/// by IfcSweptAreaSolid.Position.P[2] shall point to the
/// Z-Axis. It indicates the "role" of the column, a role=0°
/// means y-axis of profile = Z-axis of reference coordinate system.
/// In the exception of a vertical member, the y-axis shall point to
/// the Y-axis.
/// 
/// Figure 105 illustrates a 'SweptSolid' geometric representation with cardinal point applied as 1 (bottom left).
/// The following interpretation of dimension parameter applies for rectangular members:
/// 
/// IfcRectangleProfileDef.YDim interpreted as member width
/// IfcRectangleProfileDef.XDim interpreted as member depth
/// 
/// The following interpretation of dimension parameter applies for circular members:
/// 
/// IfcCircleProfileDef.Radius interpreted as beam radius.
/// 
/// Figure 105 — Member body extrusion
/// 
/// Clipping Representation Type
/// The advanced geometric representation of
/// IfcMemberStandardCase is defined using the 'Clipping'
/// geometry. The following attribute values for the
/// IfcShapeRepresentation holding this geometric
/// representation shall be used:
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'Clipping'
/// 
/// The following constraints apply to the advanced
/// representation:
/// 
/// Solid: see 'SweptSolid' geometric representation
/// Profile: see 'SweptSolid' geometric
/// representation
/// Profile Position : see 'SweptSolid' geometric
/// representation
/// Extrusion:ÿsee 'SweptSolid' geometric
/// representation
/// Boolean result: The IfcBooleanClippingResult
/// shall be supported, allowing for Boolean differences between the
/// swept solid (here IfcExtrudedAreaSolid) and one or several
/// IfcHalfSpaceSolid (or its subtypes).
/// 
/// Figure 106 illustrates an advanced geometric representation with use of IfcBooleanClippingResult between
/// an IfcExtrudedAreaSolid and an IfcHalfSpaceSolid to create a clipped body, with cardinal point applied as 4 (mid-depth left).
/// 
/// Figure 06 — Member body clipping
/// 
/// AdvancedSweptSolid Representation Type
/// The 'AdvancedSweptSolid' representation type is a valid body
/// representation of IfcMemberStandardCase. The following
/// attribute values for the IfcShapeRepresentation holding
/// this geometric representation shall be used:
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'AdvancedSweptSolid'
/// 
/// The following additional constraints apply to the
/// 'AdvancedSweptSolid' representation type:
/// 
/// Solid: IfcSurfaceCurveSweptAreaSolid,
/// IfcFixedReferenceSweptAreaSolid,
/// IfcExtrudedAreaSolidTapered,
/// IfcRevolvedAreaSolidTapered shall be supported.
/// NOTE View definitions and implementer
/// agreement can further constrain the allowed swept solid
/// types.
/// NOTE Using IfcExtrudedAreaSolidTapered,
/// or IfcRevolvedAreaSolidTapered requires the use of two
/// IfcMaterialProfile's within the
/// IfcMaterialProfileSet assinged to the
/// IfcBeamStandardCase
/// 
/// Profile: see 'SweptSolid' geometric
/// representation
/// Profile Position : see 'SweptSolid' geometric
/// representation
/// Extrusion:ÿnot applicable
class IFC_PARSE_API IfcMemberStandardCase : public IfcMember {
public:
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcMember::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcMember::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcMember::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcMemberStandardCase (IfcEntityInstanceData* e);
    IfcMemberStandardCase (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcMemberTypeEnum::IfcMemberTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcMemberStandardCase > list;
};
/// A motor connection provides the means for connecting a motor as the driving device to the driven device. 
/// 
/// HISTORY  New entity in IFC2x4
/// 
/// Type Use Definition
/// IfcMotorConnection defines the occurrence of any motor connection; common information about motor connection types is handled by IfcMotorConnectionType. 
/// The IfcMotorConnectionType (if present) may establish the common type name, usage (predefined type), properties, materials, ports, composition, assignments, and representations. 
/// The IfcMotorConnectionType is attached using the IfcRelDefinesByType objectified relationship and is accessible by the IsTypedBy inverse attribute. 
/// If the IfcMotorConnectionType has ports or aggregated elements, such objects are reflected at the IfcMotorConnection occurrence using the IfcRelDefinesByObject relationship.
/// 
/// Property Use Definition
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute. 
/// Property sets may also be specified at the IfcMotorConnectionType, defining the common property data for all occurrences of the same type. 
/// They are then accessible by the IsTypedBy inverse attribute pointing to IfcMotorConnectionType.HasPropertySets. 
/// If both are given, then the properties directly defined at IfcMotorConnection override the properties defined at IfcMotorConnectionType. 
/// Refer to the documentation at the supertype IfcEnergyConversionDevice and ancestors for inherited property set definitions.
/// The following property set definitions are applicable to this entity:
/// Pset_MotorConnectionTypeCommon (PSET_TYPEDRIVENOVERRIDE)
/// 
/// Quantity Use Definition
/// The quantities relating to this entity are defined by IfcElementQuantity and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute.
/// The following base quantities are defined and shall be exchanged with the IfcElementQuantity.Name = 'BaseQuantities'. 
/// Other quantities, being subjected to local standard of measurement, may be defined with another string value assigned to Name. 
/// In this case a valid value for MethodOfMeasurement shall be provided. 
/// 
/// Qto_MotorConnectionBaseQuantities
/// 
/// Material Use Definition
/// The material of the IfcMotorConnection is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship. It is accessible by the HasAssociations inverse attribute. Material information can also be given at the IfcMotorConnectionType, defining the common attribute data for all occurrences of the same type. The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used:
/// 
/// Casing: Material from which the casing is constructed.
/// 
/// Port Use Definition
/// The distribution ports relating to the IfcMotorConnection are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship. 
///   If the motor connection occurrence is defined by IfcMotorConnectionType, then the port occurrences must reflect those defined at the IfcMotorConnectionType using the IfcRelDefinesByObject relationship.
///   Ports are specific to the IfcMotorConnection PredefinedType as follows indicated by the IfcDistributionPort Name, PredefinedType, and FlowDirection:
/// 
/// Motor (NOTDEFINED, SINK): Connection from the motor.
/// Drive (NOTDEFINED, SOURCE): Connection to the driven device.
class IFC_PARSE_API IfcMotorConnection : public IfcEnergyConversionDevice {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcMotorConnection
    bool hasPredefinedType() const;
    IfcMotorConnectionTypeEnum::IfcMotorConnectionTypeEnum PredefinedType() const;
    void setPredefinedType(IfcMotorConnectionTypeEnum::IfcMotorConnectionTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcEnergyConversionDevice::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcMotorConnectionTypeEnum; } return IfcEnergyConversionDevice::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "PredefinedType"; } return IfcEnergyConversionDevice::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcMotorConnection (IfcEntityInstanceData* e);
    IfcMotorConnection (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcMotorConnectionTypeEnum::IfcMotorConnectionTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcMotorConnection > list;
};
/// Definition from ISO/CD 10303-42:1992ÿ This is a special subtype of boundary curve which has the additional semantics of defining an outer boundary of a surface. No more than one such curve shall be included in the set of boundaries of a curve bounded surface.
/// 
/// NOTEÿ Corresponding ISO 10303 entity: outer_boundary_curve. Please refer to ISO/IS 10303-42:1994, p.89 for the final definition of the formal standard.
/// 
/// HISTORYÿ New entity in IFC2x4.
class IFC_PARSE_API IfcOuterBoundaryCurve : public IfcBoundaryCurve {
public:
    virtual unsigned int getArgumentCount() const { return 2; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcBoundaryCurve::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcBoundaryCurve::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcBoundaryCurve::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcOuterBoundaryCurve (IfcEntityInstanceData* e);
    IfcOuterBoundaryCurve (IfcTemplatedEntityList< IfcCompositeCurveSegment >::ptr v1_Segments, bool v2_SelfIntersect);
    typedef IfcTemplatedEntityList< IfcOuterBoundaryCurve > list;
};
/// An outlet is a device installed at a point to receive one or more inserted plugs for electrical power or communications.
/// Power outlets are commonly connected within a junction box; data outlets may be directly connected to a wall. For power outlets sharing the same circuit within a junction box, the ports should indicate the logical wiring relationship to the enclosing junction box, even though they may be physically connected to a cable going to another outlet, switch, or fixture. 
/// 
/// HISTORY  New entity in IFC2x4
/// 
/// Type Use Definition
/// IfcOutlet defines the occurrence of any outlet; common information about outlet types is handled by IfcOutletType. 
/// The IfcOutletType (if present) may establish the common type name, usage (predefined type), properties, materials, ports, composition, assignments, and representations. 
/// The IfcOutletType is attached using the IfcRelDefinesByType objectified relationship and is accessible by the IsTypedBy inverse attribute. 
/// If the IfcOutletType has ports or aggregated elements, such objects are reflected at the IfcOutlet occurrence using the IfcRelDefinesByObject relationship.
/// Figure 206 illustrates outlet type use.
/// Figure 206 — Outlet type use
/// 
/// Property Use Definition
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute. 
/// Property sets may also be specified at the IfcOutletType, defining the common property data for all occurrences of the same type. 
/// They are then accessible by the IsTypedBy inverse attribute pointing to IfcOutletType.HasPropertySets. 
/// If both are given, then the properties directly defined at IfcOutlet override the properties defined at IfcOutletType. 
/// Refer to the documentation at the supertype IfcFlowTerminal and ancestors for inherited property set definitions.
/// The following property set definitions are applicable to this entity:
/// Pset_OutletTypeCommon (PSET_TYPEDRIVENOVERRIDE)
/// 
/// Quantity Use Definition
/// The quantities relating to this entity are defined by IfcElementQuantity and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute.
/// The following base quantities are defined and shall be exchanged with the IfcElementQuantity.Name = 'BaseQuantities'. 
/// Other quantities, being subjected to local standard of measurement, may be defined with another string value assigned to Name. 
/// In this case a valid value for MethodOfMeasurement shall be provided. 
/// 
/// Qto_OutletBaseQuantities
/// 
/// Material Use Definition
/// The material of the IfcOutlet is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship. It is accessible by the HasAssociations inverse attribute. Material information can also be given at the IfcOutletType, defining the common attribute data for all occurrences of the same type. The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used:
/// 
/// Casing: Material from which the casing is constructed.
/// Conductor: Material from which the conductors are constructed.
/// Surface: Material from which the outer plate is constructed.
/// 
/// Port Use Definition
/// The distribution ports relating to the IfcOutlet are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship. 
///   If the outlet occurrence is defined by IfcOutletType, then the port occurrences must reflect those defined at the IfcOutletType using the IfcRelDefinesByObject relationship.
///   Ports are specific to the IfcOutlet PredefinedType as follows indicated by the IfcDistributionPort Name, PredefinedType, and FlowDirection:
/// 
/// DATAOUTLET
/// 
/// Line#1 (DATA, SINK): A data line, connecting to a cable commonly originating from a port on a router.
/// Line#2 (DATA, SINK): A data line, connecting to a cable commonly originating from a port on a router.
/// Jack#1 (DATA, SOURCE): Jacks in order of layout, going to the right and then down, which may accept a cable.
/// Jack#2 (DATA, SOURCE): Jacks in order of layout, going to the right and then down, which may accept a cable.
/// 
/// POWEROUTLET
/// 
/// Line (ELECTRICAL, SINK): The source of power, which may refer to a port on a junction box.
/// Jack#1 (ELECTRICAL, SOURCE): Upper jack, accepting a plug from an appliance or fixture.
/// Jack#2 (ELECTRICAL, SOURCE): Lower jack, accepting a plug from an appliance or fixture.
/// 
/// TELEPHONEOUTLET
/// 
/// Line#1 (DATA, SINK): A telephone line, connecting to a cable originating from a telecommunications distribution board.
/// Line#2 (DATA, SINK): A telephone line, connecting to a cable originating from a telecommunications distribution board.
/// Jack#1 (DATA, SOURCE): Jacks in order of layout, going to the right and then down, which may accept a cable.
/// Jack#2 (DATA, SOURCE): Jacks in order of layout, going to the right and then down, which may accept a cable.
/// 
/// Figure 207 illustrates outlet port use.
/// Figure 207 — Outlet port use
class IFC_PARSE_API IfcOutlet : public IfcFlowTerminal {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcOutlet
    bool hasPredefinedType() const;
    IfcOutletTypeEnum::IfcOutletTypeEnum PredefinedType() const;
    void setPredefinedType(IfcOutletTypeEnum::IfcOutletTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcFlowTerminal::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcOutletTypeEnum; } return IfcFlowTerminal::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "PredefinedType"; } return IfcFlowTerminal::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcOutlet (IfcEntityInstanceData* e);
    IfcOutlet (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcOutletTypeEnum::IfcOutletTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcOutlet > list;
};
/// A pile is a slender timber, concrete, or steel structural element, driven, jetted, or otherwise embedded on end in the ground for the purpose of supporting a load.
/// 
/// HISTORY New entity in IFC2x2
/// 
/// Property Set Use Definition
/// 
/// The following property set definitions are part of this IFC release:
/// 
/// Pset_PileCommon: common property set for all pile occurrences.
/// 
/// Quantity Use Definition 
///   The quantities relating to this entity are defined by IfcElementQuantity and attached by the IfcRelDefinesByProperties relationship. They are accessible by the IsDefinedBy inverse attribute. The following base quantities are defined and should be exchanged with the IfcElementQuantity.Name = 'BaseQuantities'. Other quantities, being subjected to local standard of measurement, can be defined with another string value assigned to Name. In this case a valid value for MethodOfMeasurement has to be provided.  
/// 
/// Qto_PileBaseQuantities 
/// 
/// Geometry Use Definition
/// 
/// Local placement and product representations are defined by the supertype IfcBuildingElement.  Standard representations as defined at IfcColumnStandardCase should be used when applicable.
class IFC_PARSE_API IfcPile : public IfcBuildingElement {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcPile
    bool hasPredefinedType() const;
    /// The predefined generic type of the pile according to function.
    /// 
    /// IFC 2x4 change:  Attribute made optional.  Type information can be provided by IfcRelDefinesByType and IfcPileType.
    IfcPileTypeEnum::IfcPileTypeEnum PredefinedType() const;
    void setPredefinedType(IfcPileTypeEnum::IfcPileTypeEnum v);
    /// Whether the optional attribute ConstructionType is defined for this IfcPile
    bool hasConstructionType() const;
    /// General designator for how the pile is constructed.
    /// 
    /// IFC 2x4 change:  Material profile association capability by means of IfcRelAssociatesMaterial has been added.  The attribute ConstructionType should not be used whenever its information can be provided by a material profile set, either associated with the IfcPile object or, if present, with a corresponding instance of IfcPileType.
    IfcPileConstructionEnum::IfcPileConstructionEnum ConstructionType() const;
    void setConstructionType(IfcPileConstructionEnum::IfcPileConstructionEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; case 9: return IfcUtil::Argument_ENUMERATION; } return IfcBuildingElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcPileTypeEnum; case 9: return Type::IfcPileConstructionEnum; } return IfcBuildingElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "PredefinedType"; case 9: return "ConstructionType"; } return IfcBuildingElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPile (IfcEntityInstanceData* e);
    IfcPile (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcPileTypeEnum::IfcPileTypeEnum > v9_PredefinedType, boost::optional< IfcPileConstructionEnum::IfcPileConstructionEnum > v10_ConstructionType);
    typedef IfcTemplatedEntityList< IfcPile > list;
};
/// A pipe fitting is a junction or transition in a piping flow distribution system or used to connect pipe segments, resulting changes in flow characteristics to the fluid such as direction or flow rate. 
/// 
/// HISTORY  New entity in IFC2x4
/// 
/// Type Use Definition
/// IfcPipeFitting defines the occurrence of any pipe fitting; common information about pipe fitting types is handled by IfcPipeFittingType. 
/// The IfcPipeFittingType (if present) may establish the common type name, usage (predefined type), properties, materials, ports, composition, assignments, and representations. 
/// The IfcPipeFittingType is attached using the IfcRelDefinesByType objectified relationship and is accessible by the IsTypedBy inverse attribute. 
/// If the IfcPipeFittingType has ports or aggregated elements, such objects are reflected at the IfcPipeFitting occurrence using the IfcRelDefinesByObject relationship.
/// 
/// Property Use Definition
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute. 
/// Property sets may also be specified at the IfcPipeFittingType, defining the common property data for all occurrences of the same type. 
/// They are then accessible by the IsTypedBy inverse attribute pointing to IfcPipeFittingType.HasPropertySets. 
/// If both are given, then the properties directly defined at IfcPipeFitting override the properties defined at IfcPipeFittingType. 
/// Refer to the documentation at the supertype IfcFlowFitting and ancestors for inherited property set definitions.
/// The following property set definitions are applicable to this entity:
/// (All Types)
/// 
/// Pset_PipeFittingOccurrence (PSET_OCCURRENCEDRIVEN)
/// Pset_PipeFittingPHistory (PSET_PERFORMANCEDRIVEN)
/// Pset_PipeFittingTypeCommon (PSET_TYPEDRIVENOVERRIDE)
/// 
/// BEND
/// 
/// Pset_PipeFittingTypeBend (PSET_TYPEDRIVENOVERRIDE)
/// 
/// JUNCTION
/// 
/// Pset_PipeFittingTypeJunction (PSET_TYPEDRIVENOVERRIDE)
/// 
/// Quantity Use Definition
/// The quantities relating to this entity are defined by IfcElementQuantity and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute.
/// The following base quantities are defined and shall be exchanged with the IfcElementQuantity.Name = 'BaseQuantities'. 
/// Other quantities, being subjected to local standard of measurement, may be defined with another string value assigned to Name. 
/// In this case a valid value for MethodOfMeasurement shall be provided. 
/// 
/// Qto_PipeFittingBaseQuantities
/// 
/// Material Use Definition
/// The material of the IfcPipeFitting is defined by IfcMaterialProfileSetUsage or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship. It is accessible by the HasAssociations inverse attribute. Material information can also be given at the IfcPipeFittingType, defining the common attribute data for all occurrences of the same type. The following keywords for IfcMaterialProfileSet.MaterialProfiles[n].Name shall be used:
/// 
/// Body: Material from which the pipe fitting is constructed.
/// Coating: The outer coating, if applicable.
/// Insulation: The insulating wrapping, if applicable.
/// Lining: The inner lining, if applicable.
/// 
/// Port Use Definition
/// The distribution ports relating to the IfcPipeFitting are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship. 
///   If the pipe fitting occurrence is defined by IfcPipeFittingType, then the port occurrences must reflect those defined at the IfcPipeFittingType using the IfcRelDefinesByObject relationship.
///   Ports are specific to the IfcPipeFitting PredefinedType as follows indicated by the IfcDistributionPort Name, PredefinedType, and FlowDirection:
/// 
/// BEND
/// 
/// Inlet (NOTDEFINED, SINK): The flow inlet.
/// Outlet (NOTDEFINED, SOURCE): The flow outlet.
/// 
/// CONNECTOR
/// 
/// Inlet (NOTDEFINED, SINK): The flow inlet.
/// Outlet (NOTDEFINED, SOURCE): The flow outlet.
/// 
/// ENTRY
/// 
/// Outlet (NOTDEFINED, SOURCE): The flow outlet.
/// 
/// EXIT
/// 
/// Inlet (NOTDEFINED, SINK): The flow inlet.
/// 
/// JUNCTION
/// 
/// Inlet (NOTDEFINED, SINK): The flow inlet.
/// Outlet#1 (NOTDEFINED, SOURCE): The first flow outlet.
/// Outlet#2 (NOTDEFINED, SOURCE): The second flow outlet.
/// 
/// OBSTRUCTION
/// 
/// Inlet (NOTDEFINED, SINK): The flow inlet.
/// Outlet (NOTDEFINED, SOURCE): The flow outlet.
/// 
/// Figure 227 illustrates pipe fitting port use.
/// Figure 227 — Pipe fitting port use
class IFC_PARSE_API IfcPipeFitting : public IfcFlowFitting {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcPipeFitting
    bool hasPredefinedType() const;
    IfcPipeFittingTypeEnum::IfcPipeFittingTypeEnum PredefinedType() const;
    void setPredefinedType(IfcPipeFittingTypeEnum::IfcPipeFittingTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcFlowFitting::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcPipeFittingTypeEnum; } return IfcFlowFitting::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "PredefinedType"; } return IfcFlowFitting::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPipeFitting (IfcEntityInstanceData* e);
    IfcPipeFitting (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcPipeFittingTypeEnum::IfcPipeFittingTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcPipeFitting > list;
};
/// A pipe segment is used to typically join two sections of a piping network. 
/// 
/// HISTORY  New entity in IFC2x4
/// 
/// Type Use Definition
/// IfcPipeSegment defines the occurrence of any pipe segment; common information about pipe segment types is handled by IfcPipeSegmentType. 
/// The IfcPipeSegmentType (if present) may establish the common type name, usage (predefined type), properties, materials, ports, composition, assignments, and representations. 
/// The IfcPipeSegmentType is attached using the IfcRelDefinesByType objectified relationship and is accessible by the IsTypedBy inverse attribute. 
/// If the IfcPipeSegmentType has ports or aggregated elements, such objects are reflected at the IfcPipeSegment occurrence using the IfcRelDefinesByObject relationship.
/// 
/// Property Use Definition
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute. 
/// Property sets may also be specified at the IfcPipeSegmentType, defining the common property data for all occurrences of the same type. 
/// They are then accessible by the IsTypedBy inverse attribute pointing to IfcPipeSegmentType.HasPropertySets. 
/// If both are given, then the properties directly defined at IfcPipeSegment override the properties defined at IfcPipeSegmentType. 
/// Refer to the documentation at the supertype IfcFlowSegment and ancestors for inherited property set definitions.
/// The following property set definitions are applicable to this entity:
/// (All Types)
/// 
/// Pset_PipeConnectionFlanged (PSET_OCCURRENCEDRIVEN)
/// Pset_PipeSegmentOccurrence (PSET_OCCURRENCEDRIVEN)
/// Pset_PipeSegmentPHistory (PSET_PERFORMANCEDRIVEN)
/// Pset_PipeSegmentTypeCommon (PSET_TYPEDRIVENOVERRIDE)
/// 
/// CULVERT
/// 
/// Pset_PipeSegmentTypeCulvert (PSET_TYPEDRIVENOVERRIDE)
/// 
/// GUTTER
/// 
/// Pset_PipeSegmentTypeGutter (PSET_TYPEDRIVENOVERRIDE)
/// 
/// Quantity Use Definition
/// The quantities relating to this entity are defined by IfcElementQuantity and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute.
/// The following base quantities are defined and shall be exchanged with the IfcElementQuantity.Name = 'BaseQuantities'. 
/// Other quantities, being subjected to local standard of measurement, may be defined with another string value assigned to Name. 
/// In this case a valid value for MethodOfMeasurement shall be provided. 
/// 
/// Qto_PipeSegmentBaseQuantities
/// 
/// Material Use Definition
/// The material of the IfcPipeSegment is defined by IfcMaterialProfileSetUsage or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship. It is accessible by the HasAssociations inverse attribute. Material information can also be given at the IfcPipeSegmentType, defining the common attribute data for all occurrences of the same type. The following keywords for IfcMaterialProfileSet.MaterialProfiles[n].Name shall be used:
/// 
/// Body: Material from which the duct fitting is constructed.
/// Coating: The outer coating, if applicable.
/// Insulation: The insulating wrapping, if applicable.
/// Lining: The inner lining, if applicable.
/// 
/// Port Use Definition
/// The distribution ports relating to the IfcPipeSegment are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship. 
///   If the pipe segment occurrence is defined by IfcPipeSegmentType, then the port occurrences must reflect those defined at the IfcPipeSegmentType using the IfcRelDefinesByObject relationship.
///   Ports are specific to the IfcPipeSegment PredefinedType as follows indicated by the IfcDistributionPort Name, PredefinedType, and FlowDirection:
/// 
/// Inlet (NOTDEFINED, SINK): The flow inlet.
/// Outlet (NOTDEFINED, SOURCE): The flow outlet.
/// 
/// Figure 228 illustrates pipe segment port use.
/// Figure 228 — Pipe segment port use
class IFC_PARSE_API IfcPipeSegment : public IfcFlowSegment {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcPipeSegment
    bool hasPredefinedType() const;
    IfcPipeSegmentTypeEnum::IfcPipeSegmentTypeEnum PredefinedType() const;
    void setPredefinedType(IfcPipeSegmentTypeEnum::IfcPipeSegmentTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcFlowSegment::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcPipeSegmentTypeEnum; } return IfcFlowSegment::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "PredefinedType"; } return IfcFlowSegment::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPipeSegment (IfcEntityInstanceData* e);
    IfcPipeSegment (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcPipeSegmentTypeEnum::IfcPipeSegmentTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcPipeSegment > list;
};
/// Definition from IAI: An IfcPlate is a planar and
/// often flat part with constant thickness. A plate can be a
/// structural part carrying loads between or beyond points of
/// support, however it is not required to be load bearing.ÿThe
/// location of the plate (being horizontal, vertical or sloped) is
/// not relevant to its definition (in contrary to IfcWall and
/// IfcSlab (as floor slab)).ÿ
/// NOTE ÿPlates areÿnormally made of steel, other
/// metallic material, or by glass panels. However the definition of
/// IfcPlate is material independent and specific material
/// information shall be handled by using
/// IfcAssociatesMaterial to assign a material specification
/// to the IfcPlate.ÿ
/// 
/// NOTE ÿAlthough not necessarily, plates are often add-on
/// parts. This is represented by the IfcRelAggregates
/// decomposition mechanism used to aggregate parts, such as
/// IfcPlate, into a container element, e.g.
/// IfcElementAssembly, or IfcCurtainWall.ÿ
/// 
/// NOTE The representation of a plate in a structural
/// analysis model is provided by IfcStructuralSurfaceMember
/// being part of an
/// IfcStructuralAnalysisModel.
/// An instance IfcPlate should preferably get its
/// geometric representation and material assignment through the type
/// definition by IfcPlateType assigned using the
/// IfcRelDefinesByType relationship. This allows identical
/// plates in a construction to be represented by the same instance
/// of IfcPlateType.
/// A plate may have openings, such as voids or recesses. They are
/// defined by an IfcOpeningElement attached to the plate
/// using the inverse relationship HasOpenings pointing to
/// IfcRelVoidsElement. The position number of a plate as
/// often used in steel construction is assigned through the
/// attribute IfcElement.Tag
/// The IFC specification provides two entities for plate
/// occurrences:
/// 
/// IfcPlateStandardCase used for all occurrences of
/// plates, that are prismatic and where the thickness parameter can
/// be fully described by the IfcMaterialLayerSetUsage. These
/// plates are always represented geometrically by a 'SweptSolid'
/// geometry (or by a 'Clipping' geometry based on 'SweptSolid'), if
/// a 3D geometric representation is assigned. In addition they have
/// to have a corresponding IfcMaterialLayerSetUsage
/// assigned.
/// IfcPlate used for all other occurrences of plates,
/// particularly for plates with changing thickness, or plates with
/// non planar surfaces, and plates having only 'SurfaceModel' or
/// 'Brep' geometry.
/// 
/// HISTORY New entity in
/// IFC Release 2x2
/// Type Use Definition
/// The IfcPlate defines the occuurence of any plate,
/// common information about plate types (or styles) is handled by
/// IfcPlateType. The IfcPlateType (if present) may
/// establish the commonÿtype name, usage (or predefined) type,
/// common set of properties, common material layer set, and common
/// shape representations (using IfcRepresentationMap). The
/// IfcPlateType is attached using the
/// IfcRelDefinedByType.RelatingType objectified relationship
/// and is accessible by the inverse IsTypedBy attribute.
/// If no IfcPlateType is attachedÿ(i.e. if only occurrence
/// information is given) the PredefinedType should be
/// provided. If set to .USERDEFINED. a user defined value can be
/// provided by the ObjectType attribute.
/// Material Use Definition
/// The material of the IfcPlate is defined by
/// IfcMaterialLayerSet, or IfcMaterial and attached by
/// the IfcRelAssociatesMaterial.RelatingMaterial. It
/// is accessible by the inverse HasAssociations
/// relationship.
/// NOTE It is illegal to assign an
/// IfcMaterialLayerSetUsage to an IfcPlate. Only the
/// subtype IfcPlateStandardCase supports this
/// concept.
/// Material information can also be given at the
/// IfcPlateType, defining the common attribute data for all
/// occurrences of the same type.ÿIt is then accessible by the
/// inverse IsTypedBy
/// relationship pointing to IfcPlateType.HasAssociations and
/// via IfcRelAssociatesMaterial.RelatingMaterial.
/// Property Set Use Definition
/// The property sets relating to the IfcPlate are defined
/// by the IfcPropertySet and attached by the
/// IfcRelDefinesByProperties relationship. It is accessible
/// by the inverse IsDefinedBy relationship. The following
/// property set definitions specific to the IfcPlate are part
/// of this IFC release:
/// 
/// Pset_PlateCommon: common property set for all plate
/// occurrences
/// 
/// Quantity Use Definition
/// The quantities relating to the IfcPlate and
/// IfcPlateStandardCase are defined by the
/// IfcElementQuantity and attached by the
/// IfcRelDefinesByProperties relationship. It is accessible
/// by the inverse IsDefinedBy relationship. The following
/// base quantities are defined and should be exchanged with the
/// IfcElementQuantity.Name = 'BaseQuantities'. Other
/// quantities can be defined being subjected to local standard of
/// measurement with another string value assigned to Name and
/// a value provided for MethodOfMeasurement. Quanties shall
/// be never assigned to the IfcPlateType.
/// 
/// Qto_PlateBaseQuantities: base quantities for
/// all plate occurrences.
/// 
/// Containment Use Definitions
/// The IfcPlate, as any subtype of
/// IfcBuildingElement, may participate in two different
/// containment relationships. The first (and in most implementation
/// scenarios mandatory) relationship is the hierachical spatial
/// containment, the second relationship is the aggregation within
/// anÿelement assembly.
/// 
/// TheÿIfcPlate is places within the project spatial
/// hierarchy using the objectified relationship
/// IfcRelContainedInSpatialStructure, referring to it by its
/// inverse attribute SELF\IfcElement.ContainedInStructure.
/// Subtypes ofÿIfcSpatialStructureElement are valid spatial
/// containers, with IfcBuildingStorey being the default
/// container.
/// TheÿIfcPlate may be aggregated into an element
/// assembly using the objectified relationship
/// IfcRelAggregates, referring to it by its inverse attribute
/// SELF\IfcObjectDefinition.Decomposes. Any subtype of
/// IfcElement can be an element assembly, with
/// IfcElementAssembly as a special focus subtype. In this
/// case, no additional relationship to the spatial hierarchy shall
/// be given (i.e.ÿSELF\IfcElement.ContainedInStructure =
/// NIL), the relationship to the spatial container is handled by the
/// element assembly.
/// 
/// Geometry Use Definition
/// The geometric representation of IfcPlate is
/// given by the IfcProductDefinitionShape, allowing multiple
/// geometric representations. Included are:
/// Local Placement
/// The local placement for IfcPlate is defined in
/// its supertype IfcProduct. It is defined by the
/// IfcLocalPlacement, which defines the local coordinate
/// system that is referenced by all geometric representations.
/// 
/// The PlacementRelTo relationship of
/// IfcLocalPlacement shall point (if given) to the local
/// placement of the same IfcSpatialStructureElement, which is
/// used in the ContainedInStructure inverse attribute, or to
/// a spatial structure element at a higher level, referenced by
/// that.
/// 
/// If the IfcPlate is part of an assembly, the
/// PlacementRelTo relationship of IfcLocalPlacement
/// shall point to the local placement of the container element, e.g.
/// IfcElementAssembly,
/// 
/// If the relative placement is not used, the absolute placement
/// is defined within the world coordinate system.
/// 
/// Geometric Representation
/// Currently, the 'Surface',
/// 'FootPrint', 'Body', and 'Box'
/// representations are supported. The 'Box' representation includes
/// the representation type 'BoundingBox' and is explained at
/// IfcBuildingElement.
/// Surface Representation
/// The surfacic geometric representation of IfcPlate is
/// defined using the 'Surface' representation.
/// 
/// RepresentationIdentifier : 'Surface'
/// RepresentationType : 'Surface3D'
/// 
/// NOTE The 'Surface' can be used to define a
/// surfacic model of the building (e.g. for analytical purposes, or
/// for reduced Level of Detail representation).
/// Body Representation
/// The body representation of IfcPlate can be represented
/// using the representation types 'SweptSolid', 'Clipping',
/// 'MappedRepresentation', 'SurfaceModel', and 'Brep'. The
/// representation types 'SurfaceModel' and 'Brep' are explained at
/// IfcBuildingElement.
/// SweptSolid Representation Type
/// The following attribute values for the
/// IfcShapeRepresentation holding this geometric
/// representation shall be used:
/// If a corresponding material definition using
/// IfcMaterialLayerSetUsage can be assigned, the subtype
/// IfcPlateStandardCase shall be used.
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'SweptSolid'
/// 
/// The following additional constraints apply to the swept solid
/// representation:
/// 
/// Solid: IfcExtrudedAreaSolid is required,
/// Profile: IfcArbitraryClosedProfileDef,
/// IfcArbitraryProfileDefWithVoids, IfcRectangleProfileDef,
/// IfcCircleProfileDef, IfcEllipseProfileDef shall be
/// supported.
/// Extrusion: The profile can be extruded perpendicularly
/// or non-perpendicularly to the plane of the swept profile.
/// 
/// Clipping Representation Type
/// The following attribute values for the
/// IfcShapeRepresentation holding this geometric
/// representation shall be used:
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'Clipping'
/// 
/// MappedRepresentation Representation Type
/// The 'MappedRepresentation' shall be supported as it allows for
/// reusing the geometry definition of the member type at all
/// occurrences of the same type. The following attribute values for
/// the IfcShapeRepresentation holding this geometric
/// representation shall be used:
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'MappedRepresentation'
/// 
/// The same constraints, as given for the 'SweptSolid',
/// 'Clipping', 'SurfaceModel', and 'Brep' geometric representation,
/// shall apply to the MappedRepresentation of the
/// IfcRepresentationMap.
class IFC_PARSE_API IfcPlate : public IfcBuildingElement {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcPlate
    bool hasPredefinedType() const;
    /// Predefined generic type for a plate that is specified in an enumeration. There may be a property set given specificly for the predefined types.
    ///   NOTE The PredefinedType shall only be used, if no type object IfcPlateType is assigned, providing its own IfcPlateType.PredefinedType.
    /// 
    /// IFC2x4 CHANGE  The attribute has been added at the end of the entity definition.
    IfcPlateTypeEnum::IfcPlateTypeEnum PredefinedType() const;
    void setPredefinedType(IfcPlateTypeEnum::IfcPlateTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcBuildingElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcPlateTypeEnum; } return IfcBuildingElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "PredefinedType"; } return IfcBuildingElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPlate (IfcEntityInstanceData* e);
    IfcPlate (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcPlateTypeEnum::IfcPlateTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcPlate > list;
};
/// The standard plate,
/// IfcPlateStandardCase, defines a plate with certain
/// constraints for the provision of material usage, parameters and
/// with certain constraints for the geometric representation. The
/// IfcPlateStandardCase handles all cases of plates, that:
/// 
/// have a reference to the IfcMaterialLayerSetUsage
/// defining the material layers of the plate with thicknesses
/// are based on an extrusion of a planar surface as defined by the
/// plate profile
/// have a constant thickness along the extrusion direction
/// are consistent in using the correct material layer set offset
/// to the base planar surface in regard to the shape
/// representation
/// are extruded perpendicular to the plane surface
/// 
/// The definitions of plate openings and niches are the same as
/// given at the supertype IfcPlate. The same agreements to the
/// special types of plates, as defined in the PredefinedType
/// attribute apply as well.
/// HISTORY New entity in
/// IFC2x Edition 4.
/// Type Use Definition
/// The IfcPlateStandardCase defines the occuurence of any
/// plate, common information about plate types (or styles) is handled
/// by IfcPlateType. The IfcPlateType (if present) may
/// establish the common type name, usage (or predefined) type,
/// common set of properties, common material layer set, and common
/// shape representations (using IfcRepresentationMap). The
/// IfcPlateType is attached using the
/// IfcRelDefinedByType.RelatingType objectified relationship
/// and is accessible by the inverse IsDefinedBy attribute.
/// The IfcPlateStandardCase defines in addition that the
/// IfcPlateType should have a unique
/// IfcMaterialLayerSet, that is referenced by
/// the IfcMaterialLayerSetUsage assigned to all
/// occurrences of this plate type.
/// 
/// Figure 107 illustrates assignment of IfcMaterialLayerSetUsage and IfcMaterialLayerSet to the IfcPlateStandardCase as the plate occurrence and to the IfcPlateType. The same IfcMaterialLayerSet shall be shared by many occurrences of IfcMaterialLayerSetUsage. This relationship shall be consistent to the relationship between the IfcPlateType and the IfcPlateStandardCase.
/// 
///  
/// Figure 107 — Plate type definition
/// 
/// Material Use Definition
/// The material of the IfcPlateStandardCase is defined by
/// IfcMaterialLayerSetUsage and attached by the
/// IfcRelAssociatesMaterial.RelatingMaterial. It is
/// accessible by the inverse HasAssociations relationship.
/// Multi-layer plates can be represented by refering to several
/// IfcMaterialLayer's within the IfcMaterialLayerSet
/// that is referenced from the
/// IfcMaterialLayerSetUsage. 
/// Material information can also be given at the
/// IfcPlateType, defining the common attribute data for all
/// occurrences of the same type. It is then accessible by the
/// inverse IsDefinedBy relationship pointing to
/// IfcPlateType.HasAssociations and via
/// IfcRelAssociatesMaterial.RelatingMaterial. See Type Use
/// Definition for additional agreements for standard plates.
/// 
/// As shown in Figure 108, the following conventions shall be met:
/// 
/// The reference coordinate system is the coordinate system established by the IfcExtrudedAreaSolid.Position.
/// The reference plane is the plane defined by the extruded profile of IfcExtrudedAreaSolid.SweptSolid. The IfcMaterialLayerSetUsage.OffsetFromReferenceLine is given as a distance from this plane.
/// The IfcMaterialLayerSetUsage.DirectionSense defines how the IfcMaterialLayer's are assigned to the reference plane. POSITIVE means in direction to the positive z-axis of the reference coordinate system.
/// The IfcMaterialLayerSetUsage.OffsetFromReferenceLine is the distance parallel to the reference plane and always perpendicular to the base (XY) plane of the reference coordinate system. This is independent of a potential non-perpendicular extrusion given by IfcExtrudedAreaSolid.ExtrudedDirection <> 0.,0.,1. A positive value of IfcMaterialLayerSetUsage.OffsetFromReferenceLine would then point into the positive z-axis of the reference coordinate system.
/// The Thickness of each IfcMaterialLayer shall be the parallel distance (measured perpendicular to the base plane). The TotalThickness of the IfcMaterialLayerSet is the sum of all layer thicknesses and in case of a perpendicular extrusion identical with IfcExtrudedAreaSolid.Depth
/// The IfcMaterialLayerSetUsage.LayerSetDirection i always AXIS3.
/// 
/// Figure 108 — Plate material layers
/// 
/// Property Set Use Definition:
/// The property sets relating to the IfcPlateStandardCase
/// are defined at the supertype IfcPlate.
/// Quantity Use Definition
/// The quantities relating to the IfcPlateStandardCase are
/// defined at the supertype IfcPlate.
/// Containment Use Definition
/// The containment use definitions relating to the
/// IfcPlateStandardCase are defined at the supertype
/// IfcPlate.
/// Geometry Use Definitions
/// The geometric representation of IfcPlateStandardCase is
/// given by the IfcProductDefinitionShape, allowing multiple
/// geometric representation. Included are:
/// Local Placement
/// The use of local placement is defined at the supertype
/// IfcPlate.
/// Geometric Representations
/// Currently, the use of 'SweptSolid' and 'Clipping'
/// representations is supported. In addition the general
/// representation type 'BoundingBox' is allowed. The geometry use
/// definitions for 'BoundingBox', is explained at
/// IfcBuildingElement.
/// SweptSolid Representation
/// The following attribute values for the
/// IfcShapeRepresentation holding this geometric representation
/// shall be used for the 'SweptSolid' representation:
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'SweptSolid'
/// 
/// The following additional constraints apply to the swept solid
/// representation:
/// 
/// Solid: IfcExtrudedAreaSolid is required,
/// Profile: IfcArbitraryClosedProfileDef,
/// IfcRectangleProfileDef, IfcRoundedRectangleProfileDef,
/// IfcCircleProfileDef, IfcEllipseProfileDef shall be
/// supported.
/// Extrusion: The profile can be extruded perpendicularly
/// or non-perpendicularly to the plane of the swept profile.
/// Material: The definition of the
/// IfcMaterialLayerSetUsage, particularly of the
/// OffsetFromReferenceLine and the
/// ForLayerSet.TotalThickness, has to be consistent to the
/// 'SweptSolid' representation.
/// 
/// Figure 109 illustrates a 'SweptSolid' geometric representation.
/// NOTE The following interpretation of dimension parameter applies for polygonal plates (in ground floor view):
/// 
/// IfcArbitraryClosedProfileDef.OuterCurve: closed bounded curve interpreted as area (or foot print) of the plate.
/// 
/// Figure 109 — Plate body extrusion
/// 
/// Clipping representation
/// The 'Clipping' geometric representation of
/// IfcSlabStandardCase is defined using the swept area geometry
/// with additional clippings applied. The following attribute values
/// for the IfcShapeRepresentation holding this geometric
/// representation shall be used:
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'Clipping'
/// 
/// The following constraints apply to the 'Clipping'
/// representation:
/// 
/// Solid: see 'SweptSolid' shape representation,
/// Profile: see 'SweptSolid' shape
/// representation,
/// Extrusion: see 'SweptSolid' shape
/// representation,
/// Material: see 'SweptSolid' shape
/// representation,
/// Boolean result: The IfcBooleanClippingResult
/// shall be supported, allowing for Boolean differences between the
/// swept solid (here IfcExtrudedAreaSolid) and one or several
/// IfcHalfSpaceSolid.
/// 
/// Figure 110 illustrates a 'Clipping' geometric representation with definition of a plate using advanced geometric representation. The profile is extruded non-perpendicular and the plate body is clipped at the eave.
/// 
/// Figure 110 — Plate body clipping
class IFC_PARSE_API IfcPlateStandardCase : public IfcPlate {
public:
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcPlate::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcPlate::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcPlate::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPlateStandardCase (IfcEntityInstanceData* e);
    IfcPlateStandardCase (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcPlateTypeEnum::IfcPlateTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcPlateStandardCase > list;
};
/// A protective device breaks an electrical circuit when a stated electric current that passes through it is exceeded.
/// A protective device provides protection against electrical current only (not as a general protective device). It may be used to represent the complete set of elements including both the tripping unit and the breaking unit that provide the protection. This may be particularly useful at earlier stages of design where the approach to breaking the electrical supply may be determined but the method of tripping may not. Alternatively, this entity may be used to specifically represent the breaking unit alone (in which case the tripping unit will also be specifically identified). This entity is specific to dedicated protective devices and excludes electrical outlets that may have circuit protection. 
/// 
/// HISTORY  New entity in IFC2x4
/// 
/// Type Use Definition
/// IfcProtectiveDevice defines the occurrence of any protective device; common information about protective device types is handled by IfcProtectiveDeviceType. 
/// The IfcProtectiveDeviceType (if present) may establish the common type name, usage (predefined type), properties, materials, ports, composition, assignments, and representations. 
/// The IfcProtectiveDeviceType is attached using the IfcRelDefinesByType objectified relationship and is accessible by the IsTypedBy inverse attribute. 
/// If the IfcProtectiveDeviceType has ports or aggregated elements, such objects are reflected at the IfcProtectiveDevice occurrence using the IfcRelDefinesByObject relationship.
/// 
/// Property Use Definition
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute. 
/// Property sets may also be specified at the IfcProtectiveDeviceType, defining the common property data for all occurrences of the same type. 
/// They are then accessible by the IsTypedBy inverse attribute pointing to IfcProtectiveDeviceType.HasPropertySets. 
/// If both are given, then the properties directly defined at IfcProtectiveDevice override the properties defined at IfcProtectiveDeviceType. 
/// Refer to the documentation at the supertype IfcFlowController and ancestors for inherited property set definitions.
/// The following property set definitions are applicable to this entity:
/// (All Types)
/// 
/// Pset_ProtectiveDeviceBreakerUnitI2TCurve (PSET_TYPEDRIVENOVERRIDE)
/// Pset_ProtectiveDeviceBreakerUnitI2TFuseCurve (PSET_TYPEDRIVENOVERRIDE)
/// Pset_ProtectiveDeviceBreakerUnitIPICurve (PSET_TYPEDRIVENOVERRIDE)
/// Pset_ProtectiveDeviceBreakerUnitTypeMotorProtection (PSET_TYPEDRIVENOVERRIDE)
/// Pset_ProtectiveDeviceTrippingCurve (PSET_TYPEDRIVENOVERRIDE)
/// Pset_ProtectiveDeviceTypeCommon (PSET_TYPEDRIVENOVERRIDE)
/// 
/// CIRCUITBREAKER
/// 
/// Pset_ProtectiveDeviceBreakerUnitTypeMCB (PSET_TYPEDRIVENOVERRIDE)
/// Pset_ProtectiveDeviceTypeCircuitBreaker (PSET_TYPEDRIVENOVERRIDE)
/// 
/// EARTHLEAKAGECIRCUITBREAKER
/// 
/// Pset_ProtectiveDeviceTypeEarthLeakageCircuitBreaker (PSET_TYPEDRIVENOVERRIDE)
/// 
/// FUSEDISCONNECTOR
/// 
/// Pset_ProtectiveDeviceTypeFuseDisconnector (PSET_TYPEDRIVENOVERRIDE)
/// 
/// RESIDUALCURRENTCIRCUITBREAKER
/// 
/// Pset_ProtectiveDeviceTypeResidualCurrentCircuitBreaker (PSET_TYPEDRIVENOVERRIDE)
/// 
/// RESIDUALCURRENTSWITCH
/// 
/// Pset_ProtectiveDeviceTypeResidualCurrentSwitch (PSET_TYPEDRIVENOVERRIDE)
/// 
/// VARISTOR
/// 
/// Pset_ProtectiveDeviceTypeVaristor (PSET_TYPEDRIVENOVERRIDE)
/// 
/// Quantity Use Definition
/// The quantities relating to this entity are defined by IfcElementQuantity and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute.
/// The following base quantities are defined and shall be exchanged with the IfcElementQuantity.Name = 'BaseQuantities'. 
/// Other quantities, being subjected to local standard of measurement, may be defined with another string value assigned to Name. 
/// In this case a valid value for MethodOfMeasurement shall be provided. 
/// 
/// Qto_ProtectiveDeviceBaseQuantities
/// 
/// Material Use Definition
/// The material of the IfcProtectiveDevice is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship. It is accessible by the HasAssociations inverse attribute. Material information can also be given at the IfcProtectiveDeviceType, defining the common attribute data for all occurrences of the same type. The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used:
/// 
/// Casing: Material from which the casing is constructed.
/// 
/// Port Use Definition
/// The distribution ports relating to the IfcProtectiveDevice are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship. 
///   If the protective device occurrence is defined by IfcProtectiveDeviceType, then the port occurrences must reflect those defined at the IfcProtectiveDeviceType using the IfcRelDefinesByObject relationship.
///   Ports are specific to the IfcProtectiveDevice PredefinedType as follows indicated by the IfcDistributionPort Name, PredefinedType, and FlowDirection:
/// 
/// CIRCUITBREAKER
/// 
/// Line (ELECTRICAL, SINK): The supply line, typically connected from a slot in a distribution board.
/// Load (ELECTRICAL, SOURCE): The load protected by this device, typically a cable connected to a device or the first junction box of a circuit.
class IFC_PARSE_API IfcProtectiveDevice : public IfcFlowController {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcProtectiveDevice
    bool hasPredefinedType() const;
    IfcProtectiveDeviceTypeEnum::IfcProtectiveDeviceTypeEnum PredefinedType() const;
    void setPredefinedType(IfcProtectiveDeviceTypeEnum::IfcProtectiveDeviceTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcFlowController::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcProtectiveDeviceTypeEnum; } return IfcFlowController::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "PredefinedType"; } return IfcFlowController::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcProtectiveDevice (IfcEntityInstanceData* e);
    IfcProtectiveDevice (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcProtectiveDeviceTypeEnum::IfcProtectiveDeviceTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcProtectiveDevice > list;
};
/// The distribution control element type IfcProtectiveDeviceTrippingUnitType defines commonly shared information for occurrences of protective device tripping units.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a protective device tripping unit specification (i.e. the specific product information, that is common to all occurrences of that product type).  Protective Device Tripping Unit types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcProtectiveDeviceTrippingUnitType are represented by instances of IfcProtectiveDeviceTrippingUnit. 
/// 
/// HISTORY: New entity in IFC2x4 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcDistributionControlElementType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_ElectricalDeviceCommon 
/// Pset_ProtectiveDeviceTrippingCurve 
/// Pset_ProtectiveDeviceTrippingFunctionGCurve 
/// Pset_ProtectiveDeviceTrippingFunctionICurve 
/// Pset_ProtectiveDeviceTrippingFunctionLCurve 
/// Pset_ProtectiveDeviceTrippingFunctionSCurve 
/// Pset_ProtectiveDeviceTrippingUnitCurrentAdjustment 
/// Pset_ProtectiveDeviceTrippingUnitTimeAdjustment 
/// Pset_ProtectiveDeviceTrippingUnitTypeCommon 
/// 
/// The following property set definitions are applicable to this entity according to the PredefinedType attribute:  
/// Pset_ProtectiveDeviceTrippingUnitTypeElectroMagnetic (ELECTROMAGNETIC) 
/// Pset_ProtectiveDeviceTrippingUnitTypeElectronic (ELECTRONIC) 
/// Pset_ProtectiveDeviceTrippingUnitTypeResidualCurrent (RESIDUALCURRENT) 
/// Pset_ProtectiveDeviceTrippingUnitTypeThermal (THERMAL) 
/// 
/// Material Use Definition 
/// The material of the IfcProtectiveDeviceTrippingUnitType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Casing': Material from which the casing is constructed. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcProtectiveDeviceTrippingUnitType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcProtectiveDeviceTrippingUnit for standard port definitions.
class IFC_PARSE_API IfcProtectiveDeviceTrippingUnitType : public IfcDistributionControlElementType {
public:
    /// Identifies the predefined types of protective device tripping unit types from which the type required may be set.
    IfcProtectiveDeviceTrippingUnitTypeEnum::IfcProtectiveDeviceTrippingUnitTypeEnum PredefinedType() const;
    void setPredefinedType(IfcProtectiveDeviceTrippingUnitTypeEnum::IfcProtectiveDeviceTrippingUnitTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcDistributionControlElementType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcProtectiveDeviceTrippingUnitTypeEnum; } return IfcDistributionControlElementType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcDistributionControlElementType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcProtectiveDeviceTrippingUnitType (IfcEntityInstanceData* e);
    IfcProtectiveDeviceTrippingUnitType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcProtectiveDeviceTrippingUnitTypeEnum::IfcProtectiveDeviceTrippingUnitTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcProtectiveDeviceTrippingUnitType > list;
};
/// A pump is a device which imparts mechanical work on fluids or slurries to move them through a channel or pipeline. A typical use of a pump is to circulate chilled water or heating hot water in a building services distribution system. 
/// 
/// HISTORY  New entity in IFC2x4
/// 
/// Type Use Definition
/// IfcPump defines the occurrence of any pump; common information about pump types is handled by IfcPumpType. 
/// The IfcPumpType (if present) may establish the common type name, usage (predefined type), properties, materials, ports, composition, assignments, and representations. 
/// The IfcPumpType is attached using the IfcRelDefinesByType objectified relationship and is accessible by the IsTypedBy inverse attribute. 
/// If the IfcPumpType has ports or aggregated elements, such objects are reflected at the IfcPump occurrence using the IfcRelDefinesByObject relationship.
/// 
/// Property Use Definition
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute. 
/// Property sets may also be specified at the IfcPumpType, defining the common property data for all occurrences of the same type. 
/// They are then accessible by the IsTypedBy inverse attribute pointing to IfcPumpType.HasPropertySets. 
/// If both are given, then the properties directly defined at IfcPump override the properties defined at IfcPumpType. 
/// Refer to the documentation at the supertype IfcFlowMovingDevice and ancestors for inherited property set definitions.
/// The following property set definitions are applicable to this entity:
/// Pset_PumpOccurrence (PSET_OCCURRENCEDRIVEN)
/// Pset_PumpPHistory (PSET_PERFORMANCEDRIVEN)
/// Pset_PumpTypeCommon (PSET_TYPEDRIVENOVERRIDE)
/// 
/// Quantity Use Definition
/// The quantities relating to this entity are defined by IfcElementQuantity and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute.
/// The following base quantities are defined and shall be exchanged with the IfcElementQuantity.Name = 'BaseQuantities'. 
/// Other quantities, being subjected to local standard of measurement, may be defined with another string value assigned to Name. 
/// In this case a valid value for MethodOfMeasurement shall be provided. 
/// 
/// Qto_PumpBaseQuantities
/// 
/// Material Use Definition
/// The material of the IfcPump is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship. It is accessible by the HasAssociations inverse attribute. Material information can also be given at the IfcPumpType, defining the common attribute data for all occurrences of the same type. The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used:
/// 
/// Body: The primary material from which the object is constructed.
/// Impeller: Material from which the impeller of the pump is constructed. In the case of a positive displacement pump, the piston acts as the impeller. 
/// Seal: Material from which the impeller shaft seal of the pump is constructed.
/// 
/// Port Use Definition
/// The distribution ports relating to the IfcPump are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship. 
///   If the pump occurrence is defined by IfcPumpType, then the port occurrences must reflect those defined at the IfcPumpType using the IfcRelDefinesByObject relationship.
///   Ports are specific to the IfcPump PredefinedType as follows indicated by the IfcDistributionPort Name, PredefinedType, and FlowDirection:
/// 
/// Power (ELECTRICAL, SINK): Receives electrical power.
/// In (NOTDEFINED, SINK): Fluid entering pump.
/// Out (NOTDEFINED, SOURCE): Fluid leaving pump.
/// 
/// Figure 229 illustrates pump port use.
/// Figure 229 — Pump port use
class IFC_PARSE_API IfcPump : public IfcFlowMovingDevice {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcPump
    bool hasPredefinedType() const;
    IfcPumpTypeEnum::IfcPumpTypeEnum PredefinedType() const;
    void setPredefinedType(IfcPumpTypeEnum::IfcPumpTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcFlowMovingDevice::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcPumpTypeEnum; } return IfcFlowMovingDevice::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "PredefinedType"; } return IfcFlowMovingDevice::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcPump (IfcEntityInstanceData* e);
    IfcPump (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcPumpTypeEnum::IfcPumpTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcPump > list;
};
/// Definition of IAI: The railing is a frame assembly
/// adjacent to human circulation spaces and at some space boundaries
/// where it is used in lieu of walls or to compliment walls.
/// Designed to aid humans, either as an optional physical support,
/// or to prevent injury by falling.
/// HISTORY New Entity in
/// IFC Release 2.0
/// Type Use Definition
/// IfcRailing defines the occuurence of any railing,
/// common information about railing types (or styles) is handled by
/// IfcRailingType. The IfcRailingType (if present) may
/// establish the commonÿtype name, usage (or predefined) type,
/// common material, common set of properties and common shape
/// representations (using IfcRepresentationMap). The
/// IfcRailingType is attached using the
/// IfcRelDefinedByType.RelatingType objectified relationship
/// and is accessible by the inverse IsDefinedBy
/// attribute.
/// Material Use Definition
/// The material of the IfcRailing is defined by the
/// IfcMaterial and attached by the
/// IfcRelAssociatesMaterial.RelatingMaterial. It is
/// accessible by the inverse HasAssociations
/// relationship.
/// Material information can also be given at the
/// IfcRailingType, defining the common attribute data for all
/// occurrences of the same type.ÿIt is then accessible by the
/// inverse IsDefinedBy relationship pointing to
/// IfcRailingType.HasAssociations and via
/// IfcRelAssociatesMaterial.RelatingMaterial to
/// IfcMaterial. If both are given, then the material directly
/// assigned to IfcRailing overrides the material assigned to
/// IfcRailingType.
/// Property Set Use Definition
/// The property sets relating to the IfcRailing are
/// defined by the IfcPropertySet and attached by the
/// IfcRelDefinesByProperties relationship. It is accessible
/// by the inverse IsDefinedBy relationship. The following
/// property set definitions specific to the IfcRailing are
/// part of this IFC release:
/// 
/// Pset_RailingCommon: common property set for all
/// railing occurrences
/// 
/// Quantity Use Definition
/// The quantities relating to the IfcRailing are defined
/// by the IfcElementQuantity and attached by the
/// IfcRelDefinesByProperties relationship. It is accessible
/// by the inverse IsDefinedBy relationship. The following
/// base quantities are defined and should be exchanged with the
/// IfcElementQuantity.MethodOfMeasurement = 'BaseQuantities'.
/// Other quantities can be defined being subjected to local standard
/// of measurement with another string value assigned to
/// MethodOfMeasurement.
/// 
/// Qto_RailingBaseQuantities: base quantities
/// for all railing occurrences.
/// 
/// Containment Use Definition
/// The IfcRailing, as any subtype of
/// IfcBuildingElement, may participate in two different
/// containment relationships. The first (and in most implementation
/// scenarios mandatory) relationship is the hierachical spatial
/// containment, the second (optional) relationship is the
/// aggregation within anÿelement assembly.
/// 
/// The IfcRailing is places within the project spatial
/// hierarchy using the objectified relationship
/// IfcRelContainedInSpatialStructure, refering to it by its
/// inverse attribute SELF\IfcElement.ContainedInStructure.
/// Subtypes ofÿIfcSpatialStructureElement are valid spatial
/// containers, with IfcBuildingStorey being the default
/// container.
/// The IfcRailing may be aggregated into an element
/// assembly using the objectified relationship
/// IfcRelAggregates, refering to it by its inverse attribute
/// SELF\IfcObjectDefinition.Decomposes. Any subtype of
/// IfcElement can be an element assembly, with
/// IfcStair, or IfcRamp as a special focus subtypes.
/// In this case it should not be additionally contained in the
/// project spatial hierarchy,
/// i.e.ÿSELF\IfcElement.ContainedInStructure should be
/// NIL.
/// 
/// Geometry Use Definition
/// The geometric representation of IfcRailing is given by
/// the IfcProductDefinitionShape, allowing multiple geometric
/// representations. Included are:
/// Local placement
/// The local placement for IfcRailing is defined in its
/// supertype IfcProduct. It is defined by the
/// IfcLocalPlacement, which defines the local coordinate
/// system that is referenced by all geometric representations.
/// 
/// The PlacementRelTo relationship of
/// IfcLocalPlacement shall point (if given) to the same
/// IfcSpatialStructureElement that is used in the
/// ContainedInStructure inverse attribute or to a referenced
/// spatial structure element at a higher level
/// If the IfcRailing, however, is used by an
/// IfcStair or IfcRamp, and this container class
/// defines its own local placement, then the PlacementRelTo
/// relationship of IfcLocalPlacement shall point to the local
/// placement of IfcStair or IfcRamp.
/// If the relative placement is not used, the absolute placement
/// is defined within the world coordinate system.
/// 
/// Geometric Representation
/// Currently, the 'Axis', 'Body',
/// and 'Box' representations are supported. The 'Box' representation
/// includes the representation type 'BoundingBox' and is explained
/// at IfcBuildingElement.
/// Axis Representation
/// The axis geometric representation of IfcRailing is
/// defined using the 'Axis' representation. The following attribute
/// values for the IfcShapeRepresentation holding this
/// geometric representation shall be used:
/// 
/// RepresentationIdentifier : 'Axis'
/// RepresentationType : 'Curve2D', 'Curve3D'
/// 
/// Body Representation
/// Currently the use of 'SurfaceModel', 'Brep' and
/// 'MappedRepresentation' representations of IfcRailing are
/// supported. The conventions to use these representations are given
/// at the level of the supertype, IfcBuildingElement. No
/// further constraints or provisions on how to use the
/// representation types are defined for IfcRailing.
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'SurfaceModel', 'Brep',
/// 'MappedRepresentation'
class IFC_PARSE_API IfcRailing : public IfcBuildingElement {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcRailing
    bool hasPredefinedType() const;
    /// Predefined generic types for a railing that are specified in an enumeration. There may be a property set given for the predefined types.
    ///   NOTE: The use of the predefined type directly at the occurrence object level of IfcRailing is only permitted, if no type object IfcRailingType is assigned.
    ///   IFC2x PLATFORM CHANGE: The attribute has been changed into an OPTIONAL attribute.
    IfcRailingTypeEnum::IfcRailingTypeEnum PredefinedType() const;
    void setPredefinedType(IfcRailingTypeEnum::IfcRailingTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcBuildingElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcRailingTypeEnum; } return IfcBuildingElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "PredefinedType"; } return IfcBuildingElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRailing (IfcEntityInstanceData* e);
    IfcRailing (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcRailingTypeEnum::IfcRailingTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcRailing > list;
};
/// Definition from ISO 6707-1:1989: Inclined way or floor
/// joining two surfaces at different levels.
/// A ramp is a vertical passageway which
/// provides a human circulation link between one floor level and
/// another floor level at a different elevation. It may include a
/// landing as an intermediate floor slab. A ramp normally does not
/// include steps (stepped ramps are out of scope for this IFC
/// Release).
/// The ramp is a container entity that aggregates all components
/// of the ramp, it represents. The aggregation is handled via the
/// IfcRelAggregates relationship, relating an IfcRamp
/// with the related flights (IfcRampFlight) and landings
/// (IfcSlab with type 'Landing'). Railings belonging to the
/// ramp may be included into the aggregation as
/// IfcRailing.
/// 
/// HISTORY New Entity in IFC Release 2.0.
/// IFC2x4 CHANGE Attribute ShapeType renamed to PredefinedType
/// 
/// Type Use Definition
/// IfcRamp defines the occuurence of any ramp, common
/// information about ramp types (or styles) is handled by
/// IfcRampType. The IfcRampType (if present) may
/// establish the commonÿtype name, usage (or predefined) type,
/// common material, common set of properties and common shape
/// representations (using IfcRepresentationMap). The
/// IfcRampType is attached using the
/// IfcRelDefinedByType.RelatingType objectified relationship
/// and is accessible by the inverse IsDefinedBy
/// attribute.
/// NOTE Since the IfcRamp might be
/// represented as an aggregate of parts, e.g. represented by
/// IfcRampFlight, or IfcSlab, these individual parts
/// may have type information attached (represented e.g. by
/// IfcRampFlightType, or
/// IfcSlabType).
/// Material Use Definition
/// The material of the IfcRamp is defined by the
/// IfcMaterial and attached by the
/// IfcRelAssociatesMaterial.RelatingMaterial. It is
/// accessible by the inverse HasAssociations
/// relationship.
/// Material information can also be given at the
/// IfcRampType, defining the common attribute data for all
/// occurrences of the same type.ÿIt is then accessible by the
/// inverse IsDefinedBy relationship pointing to
/// IfcRampType.HasAssociations and via
/// IfcRelAssociatesMaterial.RelatingMaterial to
/// IfcMaterial. If both are given, then the material directly
/// assigned to IfcRamp overrides the material assigned to
/// IfcRampType.
/// Property Set Use Definition:
/// The property sets relating to the IfcRamp are defined
/// by the IfcPropertySet and attached by the
/// IfcRelDefinesByProperties relationship. It is accessible
/// by the inverse IsDefinedBy relationship. The following
/// property set definitions specific to the IfcRamp are part
/// of this IFC release:
/// 
/// Pset_RampCommon: common property set for all
/// ramp occurrences
/// 
/// Quantity Use Definition
/// The quantities relating to the IfcRamp are defined by
/// the IfcElementQuantity and attached by the
/// IfcRelDefinesByProperties relationship. It is accessible
/// by the inverse IsDefinedBy relationship. The following
/// base quantities are defined and should be exchanged with the
/// IfcElementQuantity.MethodOfMeasurement = 'BaseQuantities'.
/// Other quantities can be defined being subjected to local standard
/// of measurement with another string value assigned to Name
/// and a value provided for MethodOfMeasurement. Quantities
/// shall never be assigned to the IfcRampType.
/// The individual quantities shall only be given at
/// IfcRamp, it is not decomposed into the individual parts,
/// IfcRampFlight and IfcSlab.
/// 
/// Qto_RampBaseQuantities: base quantities for
/// all ramp occurrences.
/// 
/// Geometry Use Definitions:
/// The geometric representation of IfcRamp is given by the
/// IfcProductDefinitionShape, allowing multiple geometric
/// representations. Independent geometric representations should
/// only be used when the IfcRamp is not defined as an
/// aggregate. If defined as an aggregate, the geometric
/// representation is the sum of the representation of the components
/// within the aggregate.
/// Local placement
/// The local placement for IfcRamp is defined in its
/// supertype IfcProduct. It is defined by the
/// IfcLocalPlacement, which defines the local coordinate
/// system that is referenced by all geometric representations.
/// 
/// The PlacementRelTo relationship of
/// IfcLocalPlacement shall point (if given) to the local
/// placement of the same IfcSpatialStructureElement that is
/// used in the ContainedInStructure inverse attribute or to a
/// referenced spatial structure element at a higher level.
/// If the relative placement is not used, the absolute placement
/// is defined within the world coordinate system.
/// 
/// If the LocalPlacement is given for the IfcRamp,
/// then all components, which are aggregated to the ramp should use
/// this placement as their relative placement.
/// Geometric representations
/// Geometric representation by own shape
/// representation
/// If the IfcRamp has no components defined (empty set of
/// SELF\IfcProduct.IsDecomposedBy) then the IfcRamp
/// may be represented by an own IfcShapeRepresentation with
/// the following values:
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'SweptSolid', 'Clipping',
/// 'SurfaceModel', or 'Brep'
/// 
/// The conventions to use these representations are provided at
/// IfcBuildingElement. No further constraints or provisions
/// on how to use the representation types are defined for
/// IfcRamp.
/// Geometric representation by aggregated elements
/// If the IfcRamp has components (referenced by
/// SELF\IfcProduct.IsDecomposedBy) then no independent
/// geometric representation shall be defined for the IfcRamp.
/// The IfcRamp is then geometrically represented by the
/// geometric representation of its components. The components are
/// accessed via
/// SELF\IfcProduct.IsDecomposedBy[1].RelatedObjects.
/// 
/// Figure 111 illustrates IfcRamp defining the local placement for all components.
/// 
/// Figure 111 — Ramp placement
class IFC_PARSE_API IfcRamp : public IfcBuildingElement {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcRamp
    bool hasPredefinedType() const;
    /// Predefined shape types for a ramp that are specified in an enumeration.
    /// 
    /// NOTE The PredefinedType shall only be used, if no type object IfcRampType is assigned, providing its own IfcRampType.PredefinedType.
    /// 
    /// IFC2x4 CHANGE  The attribute has been renamed from ShapeType and changed to be OPTIONAL with upward compatibility for file based exchange.
    IfcRampTypeEnum::IfcRampTypeEnum PredefinedType() const;
    void setPredefinedType(IfcRampTypeEnum::IfcRampTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcBuildingElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcRampTypeEnum; } return IfcBuildingElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "PredefinedType"; } return IfcBuildingElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRamp (IfcEntityInstanceData* e);
    IfcRamp (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcRampTypeEnum::IfcRampTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcRamp > list;
};
/// A ramp is an inclined slab segment, normally
/// providing a human circulation link between two landings, floors or
/// slabs at different elevations.
/// An IfcRampFlight is normally aggregated by an
/// IfcRamp through the IfcRelAggregates relationship,
/// the ramp flight is then included in the set of
/// IfcRelAggregates.RelatedObjects. An IfcRampFlight
/// normally connects the floor slab of zero to two different storeys
/// (or partial storeys or landings) within a building. The connection
/// relationship between the IfcRampFlight and the
/// IfcSlab is expressed using the IfcRelConnectsElements
/// relationship.
/// HISTORY New Entity in IFC Release 2.0.
/// 
/// Type Use Definition
/// IfcRampFlight defines the occurrence of any ramp flight,
/// common information about ramp flight types (or styles) is handled
/// by IfcRampFlightType. The IfcRampFlightType (if
/// present) may establish the common type name, usage (or
/// predefined) type, common material layer set, common set of
/// properties and common shape representations (using
/// IfcRepresentationMap). The IfcRampFlightType is
/// attached using the IfcRelDefinedByType.RelatingType
/// objectified relationship and is accessible by the inverse
/// IsDefinedBy attribute.
/// Material Use Definition
/// The material of the IfcRampFlight is defined by the
/// IfcMaterial and attached by the
/// IfcRelAssociatesMaterial.RelatingMaterial. It is
/// accessible by the inverse HasAssociations relationship.
/// Property Set Use Definition:
/// The property sets relating to the IfcRampFlight are
/// defined by the IfcPropertySet and attached by the
/// IfcRelDefinesByProperties relationship. It is accessible by
/// the inverse IsDefinedBy relationship. The following property
/// set definitions specific to the IfcRampFlight are part of
/// this IFC release:
/// 
/// Pset_RampFlightCommon: common property set for all
/// ramp flight occurrences
/// 
/// Quantity Use Definition
/// The quantities relating to the IfcRampFlight are defined
/// by the IfcElementQuantity and attached by the
/// IfcRelDefinesByProperties relationship. It is accessible by
/// the inverse IsDefinedBy relationship. The following base
/// quantities are defined and should be exchanged with the
/// IfcElementQuantity.Name = 'BaseQuantities'. Other quantities
/// can be defined being subjected to local standard of measurement
/// with another string value assigned to Name and a value
/// provided for MethodOfMeasurement. Quantities shall never be
/// assigned to the IfcRampFlightType.
/// 
/// Qto_RampFlightBaseQuantities: base quantities
/// for all ramp flight occurrences.
/// 
/// Containment Use Definition
/// The IfcRampFlight, as any subtype of
/// IfcBuildingElement, may participate in two different
/// containment relationships. The first relationship is the
/// hierachical spatial containment, the second relationship is the
/// aggregation within an element assembly.
/// 
/// The IfcRampFlight is placed within the project spatial
/// hierarchy using the objectified relationship
/// IfcRelContainedInSpatialStructure, refering to it by its
/// inverse attribute SELF\IfcElement.ContainedInStructure.
/// Subtypes of IfcSpatialStructureElement are valid
/// spatial containers, with IfcBuildingStorey being the default
/// container.
/// The IfcRampFlight may be aggregated into an element
/// assembly using the objectified relationship
/// IfcRelAggregates, refering to it by its inverse attribute
/// SELF\IfcObjectDefinition.Decomposes. Any subtype of
/// IfcElement can be an element assembly, with IfcRamp
/// as a special focus subtype. In this case it should not be
/// additionally contained in the project spatial hierarchy,
/// i.e. SELF\IfcElement.ContainedInStructure should be
/// NIL.
/// 
/// Geometry Use Definition
/// The geometric representation of IfcRampFlight is given by
/// the IfcProductDefinitionShape, allowing multiple geometric
/// representations. Included are:
/// Local placement
/// The local placement for IfcRampFlight is defined in its
/// supertype IfcProduct. It is defined by the
/// IfcLocalPlacement, which defines the local coordinate system
/// that is referenced by all geometric representations.
/// 
/// The PlacementRelTo relationship of
/// IfcLocalPlacement shall point (if given) to the local
/// placement of the same IfcSpatialStructureElement that is
/// used in the ContainedInStructure inverse attribute or to a
/// referenced spatial structure element at a higher level.
/// If the IfcRampFlight, however, is used by an
/// IfcRamp, and this container class defines its own local
/// placement, then the PlacementRelTo relationship of
/// IfcLocalPlacement shall point to the local placement of the
/// IfcRamp.
/// 
/// Geometric Representations
/// Currently, the 'Axis', 'FootPrint', 'Body', and 'Box'
/// representations are supported. The 'Box' representation includes
/// the representation type 'BoundingBox' and is explained at
/// IfcBuildingElement.
/// 
/// Axis: A two-dimensional open curve
/// IfcBoundedCurve defining the walking line for the ramp
/// flight.
/// FootPrint: A geometric curve set defining the footing
/// print, including the boundary of the ramp flight.
/// Body: A solid representation defining the 3D shape of
/// the ramp flight
/// 
/// Axis Representation
/// The walking line is represented by a two-dimensional open curve
/// as the axis. The curve is directed into the upward direction
/// (direction has to be interpreted as specified at the subtypes of
/// IfcCurve). The following attribute values for the
/// IfcShapeRepresentation holding this geometric representation
/// shall be used:
/// 
/// RepresentationIdentifier : 'Axis'
/// RepresentationType : 'Curve2D'
/// 
/// Figure 112 illustrates the axis representation which has the following constraints:
/// 
/// In case of straight flights the curve shall be a single item of type IfcPolyline.
/// In case of winding flights the curve shall be a single item of type IfcCompositeCurve.
/// In case of a curved flight or a spiral flight the curve shall be a single item of type IfcTrimmedCurve.
/// 
/// Figure 112 — Ramp flight axis
/// 
/// FootPrint Representation
/// The flight foot print, including the flight boundary is represented by a two-dimensional geometric curve set. The following attribute values for the IfcShapeRepresentation holding this geometric representation shall be used:
/// 
/// RepresentationIdentifier : 'FootPrint'
/// RepresentationType : 'GeometricCurveSet'
/// 
/// Figure 113 illustrates the footprint representation which has the following constraints:
/// 
/// In case of straight flights the curve set shall consist of a single item of type IfcPolyline.
/// In case of winding flights or curved flights the curve set shall consists of a single item of type
/// IfcCompositeCurve.
/// In case of a spiral flight the curve set shall consists of a single item of type IfcConic or
/// IfcPolyline.
/// 
/// Figure 113 — Ramp flight footprint
/// 
/// Body Representation
/// The body representation of IfcRampFlight can be
/// represented using the representation types 'SweptSolid',
/// 'SurfaceModel', 'Brep', and 'MappedRepresentation'. The general
/// usage of representation is are explained at
/// IfcBuildingElement. For further constraints on the
/// 'SweptSolid' the representation types see below..
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'SweptSolid', 'SurfaceModel',
/// 'Brep', 'MappedRepresentation'
/// 
/// SweptSolid Representation Type
/// The 'SweptSolid' representation type is a valid body
/// representation of IfcRampFlight is defined using the swept
/// area geometry. The following attribute values for the
/// IfcShapeRepresentation holding this geometric representation
/// shall be used:
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'SweptSolid'
/// 
/// The following additional constraints apply to the 'SweptSolid'
/// representation type:
/// 
/// Solid: IfcExtrudedAreaSolid is required,
/// Profile: IfcRectangleProfileDef and
/// IfcArbitraryClosedProfileDef shall be supported.
/// Extrusion: The profile shall be extruded in any
/// direction relative to the XY plane of the position coordinate
/// system of the IfcExtrudedAreaSolid. Therefore
/// non-perpendicular sweep operation has to be supported. It might be
/// further constrained to be in the direction of the global z-axis in
/// implementers agreements.
/// 
/// Figure 114 illustrates the body representation.
/// 
/// Figure 114 — Ramp flight body
class IFC_PARSE_API IfcRampFlight : public IfcBuildingElement {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcRampFlight
    bool hasPredefinedType() const;
    /// Predefined generic type for a ramp flight that is specified in an enumeration. There may be a property set given specificly for the predefined types.
    ///   NOTE The PredefinedType shall only be used, if no type object IfcRampFlightType is assigned, providing its own IfcRampFlightType.PredefinedType.
    /// 
    /// IFC2x4 CHANGE  The attribute has been added at the end of the entity definition.
    IfcRampFlightTypeEnum::IfcRampFlightTypeEnum PredefinedType() const;
    void setPredefinedType(IfcRampFlightTypeEnum::IfcRampFlightTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcBuildingElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcRampFlightTypeEnum; } return IfcBuildingElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "PredefinedType"; } return IfcBuildingElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRampFlight (IfcEntityInstanceData* e);
    IfcRampFlight (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcRampFlightTypeEnum::IfcRampFlightTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcRampFlight > list;
};
/// A rational B-spline curve with knots is a B-spline curve
/// described in terms of control points and basic functions. It
/// describes weights in addition to the control points defined at the
/// supertype IfcBSplineCurve.
/// 
/// NOTE: The
/// IfcRationalBSplineCurveWithKnots is an entity that had been
/// adopted from ISO 10303, Industrial automation systems and
/// integration — Product data representation and exchange, Part
/// 42: Integrated generic resource: Geometric and topological
/// representation.
/// 
/// NOTE: The specific subtype
/// IfcRationalBSplineCurveWithKnots has been introduced to
/// avoid the complexity of ANDOR subtype relationships in the ISO
/// 10303-42 specification
/// 
/// All weights shall be positive and the curve is given by:
/// 
/// where
/// 
/// k+1
/// number of control points
/// 
/// Pi
/// control points
/// 
/// wi
/// weights
/// 
/// d
/// degree
/// 
/// NOTE  Corresponding ISO 10303 entity: rational_b_spline_curve. Please refer to ISO/IS 10303-42:1994, p. 45 for the final definition of the formal standard.
/// 
/// HISTORY  New entity in IFC2x4.
class IFC_PARSE_API IfcRationalBSplineCurveWithKnots : public IfcBSplineCurveWithKnots {
public:
    /// The supplied values of the weights.
    std::vector< double > /*[2:?]*/ WeightsData() const;
    void setWeightsData(std::vector< double > /*[2:?]*/ v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_AGGREGATE_OF_DOUBLE; } return IfcBSplineCurveWithKnots::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcReal; } return IfcBSplineCurveWithKnots::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "WeightsData"; } return IfcBSplineCurveWithKnots::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRationalBSplineCurveWithKnots (IfcEntityInstanceData* e);
    IfcRationalBSplineCurveWithKnots (int v1_Degree, IfcTemplatedEntityList< IfcCartesianPoint >::ptr v2_ControlPointsList, IfcBSplineCurveForm::IfcBSplineCurveForm v3_CurveForm, bool v4_ClosedCurve, bool v5_SelfIntersect, std::vector< int > /*[2:?]*/ v6_KnotMultiplicities, std::vector< double > /*[2:?]*/ v7_Knots, IfcKnotType::IfcKnotType v8_KnotSpec, std::vector< double > /*[2:?]*/ v9_WeightsData);
    typedef IfcTemplatedEntityList< IfcRationalBSplineCurveWithKnots > list;
};
/// Definition from IAI: A steel bar, usually with manufactured deformations in the surface,
/// used in concrete and masonry construction to provide additional strength.  A single instance
/// of this class may represent one or many of actual rebars, for example a row of rebars.
/// 
/// HISTORY New entity in IFC Release 2x2
/// 
/// IFC 2x4 CHANGE All attributes removed; information now provided by IfcReinforcingBarType.
/// 
/// Geometry Use Definition
/// 
/// The geometric representation of IfcReinforcingBar is given by the IfcProductDefinitionShape,
/// allowing multiple geometric representations. Included are:
/// 
/// Local Placement
/// The use of local placement is defined at the supertype IfcElementComponent.
/// 
/// Multiple Mapped Representation
/// See supertype IfcElementComponent.  This method of representation allows for several rebars
/// represented by a single instance of IfcReinforcingBar.  The representation map should contain
/// one IfcSweptDiskSolidPolygonal.
/// 
/// An IfcElementQuantity,
/// attached via IfcRelDefinesByProperties, should contain an IfcQuantityCount named 'Count'
/// with the number rebars and, if this is a regularly spaced arrangement of rebars, an
/// IfcQuantityLength named 'Spacing' which expresses the center-to-center distances of bars.
/// 
/// Simplified Geometric Representation
/// Simplified geometric representations may be used based on local agreements.
class IFC_PARSE_API IfcReinforcingBar : public IfcReinforcingElement {
public:
    /// Whether the optional attribute NominalDiameter is defined for this IfcReinforcingBar
    bool hasNominalDiameter() const;
    double NominalDiameter() const;
    void setNominalDiameter(double v);
    /// Whether the optional attribute CrossSectionArea is defined for this IfcReinforcingBar
    bool hasCrossSectionArea() const;
    double CrossSectionArea() const;
    void setCrossSectionArea(double v);
    /// Whether the optional attribute BarLength is defined for this IfcReinforcingBar
    bool hasBarLength() const;
    double BarLength() const;
    void setBarLength(double v);
    /// Whether the optional attribute PredefinedType is defined for this IfcReinforcingBar
    bool hasPredefinedType() const;
    /// The predefined type is always BAR.
    IfcReinforcingBarTypeEnum::IfcReinforcingBarTypeEnum PredefinedType() const;
    void setPredefinedType(IfcReinforcingBarTypeEnum::IfcReinforcingBarTypeEnum v);
    /// Whether the optional attribute BarSurface is defined for this IfcReinforcingBar
    bool hasBarSurface() const;
    IfcReinforcingBarSurfaceEnum::IfcReinforcingBarSurfaceEnum BarSurface() const;
    void setBarSurface(IfcReinforcingBarSurfaceEnum::IfcReinforcingBarSurfaceEnum v);
    virtual unsigned int getArgumentCount() const { return 14; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_DOUBLE; case 10: return IfcUtil::Argument_DOUBLE; case 11: return IfcUtil::Argument_DOUBLE; case 12: return IfcUtil::Argument_ENUMERATION; case 13: return IfcUtil::Argument_ENUMERATION; } return IfcReinforcingElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcPositiveLengthMeasure; case 10: return Type::IfcAreaMeasure; case 11: return Type::IfcPositiveLengthMeasure; case 12: return Type::IfcReinforcingBarTypeEnum; case 13: return Type::IfcReinforcingBarSurfaceEnum; } return IfcReinforcingElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "NominalDiameter"; case 10: return "CrossSectionArea"; case 11: return "BarLength"; case 12: return "PredefinedType"; case 13: return "BarSurface"; } return IfcReinforcingElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcReinforcingBar (IfcEntityInstanceData* e);
    IfcReinforcingBar (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_SteelGrade, boost::optional< double > v10_NominalDiameter, boost::optional< double > v11_CrossSectionArea, boost::optional< double > v12_BarLength, boost::optional< IfcReinforcingBarTypeEnum::IfcReinforcingBarTypeEnum > v13_PredefinedType, boost::optional< IfcReinforcingBarSurfaceEnum::IfcReinforcingBarSurfaceEnum > v14_BarSurface);
    typedef IfcTemplatedEntityList< IfcReinforcingBar > list;
};
/// Definition from IAI: A steel bar, usually with manufactured deformations in the surface,
/// used in concrete and masonry construction to provide additional strength.
/// 
/// HISTORY New entity in IFC Release 2x4
/// 
/// Material Use Definition:
/// 
/// An associated material denotes the steel grade, preferrably by material classification.
/// 
/// Geometry Use Definition:
/// 
/// The IfcReinforcingBarType may define the shared geometric representation for all rebar occurrences. The RepresentationMaps attribute refers to a list of IfcRepresentationMap's, that allow for multiple geometric representations (e.g. with IfcShapeRepresentation's having an RepresentationIdentifier 'Box', 'Axis', or 'Body').
/// 
/// A 'Body' representation map should contain one IfcSweptDiskSolidPolygonal.
/// 
/// Simplified geometric representations may be used based on local agreements.
class IFC_PARSE_API IfcReinforcingBarType : public IfcReinforcingElementType {
public:
    /// The predefined type is always BAR.
    IfcReinforcingBarTypeEnum::IfcReinforcingBarTypeEnum PredefinedType() const;
    void setPredefinedType(IfcReinforcingBarTypeEnum::IfcReinforcingBarTypeEnum v);
    /// Whether the optional attribute NominalDiameter is defined for this IfcReinforcingBarType
    bool hasNominalDiameter() const;
    /// The nominal diameter defining the cross-section size of the reinforcing bar.
    double NominalDiameter() const;
    void setNominalDiameter(double v);
    /// Whether the optional attribute CrossSectionArea is defined for this IfcReinforcingBarType
    bool hasCrossSectionArea() const;
    /// The effective cross-section area of the reinforcing bar.
    double CrossSectionArea() const;
    void setCrossSectionArea(double v);
    /// Whether the optional attribute BarLength is defined for this IfcReinforcingBarType
    bool hasBarLength() const;
    /// The total length of the reinforcing bar. The total length of bended bars are calculated according to local standards with corrections for the bends.
    double BarLength() const;
    void setBarLength(double v);
    /// Whether the optional attribute BarSurface is defined for this IfcReinforcingBarType
    bool hasBarSurface() const;
    /// Indicator for whether the bar surface is plain or textured.
    IfcReinforcingBarSurfaceEnum::IfcReinforcingBarSurfaceEnum BarSurface() const;
    void setBarSurface(IfcReinforcingBarSurfaceEnum::IfcReinforcingBarSurfaceEnum v);
    /// Whether the optional attribute BendingShapeCode is defined for this IfcReinforcingBarType
    bool hasBendingShapeCode() const;
    std::string BendingShapeCode() const;
    void setBendingShapeCode(std::string v);
    /// Whether the optional attribute BendingParameters is defined for this IfcReinforcingBarType
    bool hasBendingParameters() const;
    IfcEntityList::ptr BendingParameters() const;
    void setBendingParameters(IfcEntityList::ptr v);
    virtual unsigned int getArgumentCount() const { return 16; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; case 10: return IfcUtil::Argument_DOUBLE; case 11: return IfcUtil::Argument_DOUBLE; case 12: return IfcUtil::Argument_DOUBLE; case 13: return IfcUtil::Argument_ENUMERATION; case 14: return IfcUtil::Argument_STRING; case 15: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; } return IfcReinforcingElementType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcReinforcingBarTypeEnum; case 10: return Type::IfcPositiveLengthMeasure; case 11: return Type::IfcAreaMeasure; case 12: return Type::IfcPositiveLengthMeasure; case 13: return Type::IfcReinforcingBarSurfaceEnum; case 14: return Type::IfcLabel; case 15: return Type::IfcBendingParameterSelect; } return IfcReinforcingElementType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; case 10: return "NominalDiameter"; case 11: return "CrossSectionArea"; case 12: return "BarLength"; case 13: return "BarSurface"; case 14: return "BendingShapeCode"; case 15: return "BendingParameters"; } return IfcReinforcingElementType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcReinforcingBarType (IfcEntityInstanceData* e);
    IfcReinforcingBarType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcReinforcingBarTypeEnum::IfcReinforcingBarTypeEnum v10_PredefinedType, boost::optional< double > v11_NominalDiameter, boost::optional< double > v12_CrossSectionArea, boost::optional< double > v13_BarLength, boost::optional< IfcReinforcingBarSurfaceEnum::IfcReinforcingBarSurfaceEnum > v14_BarSurface, boost::optional< std::string > v15_BendingShapeCode, boost::optional< IfcEntityList::ptr > v16_BendingParameters);
    typedef IfcTemplatedEntityList< IfcReinforcingBarType > list;
};
/// Definition from ISO 6707-1:1989: Construction enclosing the building from above.
/// The IfcRoof is a description of the total roof. It acts as a container entity, that aggregates all components of the roof, it represents. The aggregation is handled via the IfcRelAggregates relationship, relating an IfcRoof with the related roof elements, like slabs (represented by IfcSlab), rafters and purlins (represented by IfcBeam), or other included roofs, such as dormers (represented by IfcRoof).
/// 
/// HISTORY New Entity in IFC Release 2.0.
/// IFC2x4 CHANGE Attribute ShapeType renamed to PredefinedType.
/// 
/// Property Set Use Definition:
/// The property sets relating to the IfcRoof are defined
/// by the IfcPropertySet and attached by the
/// IfcRelDefinesByProperties relationship. It is accessible
/// by the inverse IsDefinedBy relationship. The following
/// property set definitions specific to the IfcRoof are part
/// of this IFC release:
/// 
/// Pset_RoofCommon: common property set for all
/// roof occurrences
/// 
/// The quantities relating to the IfcRoof are defined by
/// the IfcElementQuantity and attached by the
/// IfcRelDefinesByProperties relationship. It is accessible
/// by the inverse IsDefinedBy relationship. The following
/// base quantities are defined and should be exchanged with the
/// IfcElementQuantity.MethodOfMeasurement = 'BaseQuantities'.
/// Other quantities can be defined being subjected to local standard
/// of measurement with another string value assigned to Name
/// and a value provided for MethodOfMeasurement. Quantities
/// shall never be assigned to the IfcRoofType.
/// The individual quantities shall only be given at
/// IfcRoof, it is not decomposed into the individual parts,
/// e.g. IfcSlab as roof slabs.
/// 
/// Qto_RoofBaseQuantities: base quantities for
/// all roof occurrences.
/// 
/// Containment Use Definition
/// The IfcRoof, as any subtype of
/// IfcBuildingElement, may participate in two different
/// containment relationships. The first (and in most implementation
/// scenarios mandatory) relationship is the hierachical spatial
/// containment, the second (optional) relationship is the
/// aggregation within an element assembly.
/// 
/// The IfcRoof is placed within the project spatial
/// hierarchy using the objectified relationship
/// IfcRelContainedInSpatialStructure, referring to it by its
/// inverse attribute SELF\IfcElement.ContainedInStructure.
/// Subtypes of IfcSpatialStructureElement are valid spatial
/// containers, with IfcBuildingStorey being the default
/// container.
/// The IfcRoof may be aggregated into an element assembly
/// using the objectified relationship IfcRelAggregates,
/// referring to it by its inverse attribute
/// SELF\IfcObjectDefinition.Decomposes. Any subtype of
/// IfcElement can be an element assembly, with
/// IfcRoof, the overall roof, as a special focus subtype. In
/// this case it should not be additionally contained in the project
/// spatial hierarchy, i.e.
/// SELF\IfcElement.ContainedInStructure should be NIL.
/// 
/// NOTEÿ A roof contained in another roof could
/// be the representation of a dormer.
/// The IfcRoof may be an aggregate i.e. being composed by
/// other elements and acting as an assembly using the objectified
/// relationship IfcRelAggregates, referring to it by its
/// inverse attribute SELF\IfcObjectDefinition.IsDecomposedBy.
/// Components of a roof are described by instances of subtypes of
/// IfcBuildingElement (e.g. IfcSlab, IfcBeam,
/// IfcColumn, IfcBuildingElementPart) that are
/// aggregated to form a complex roof. In this case, the contained
/// elements should not be additionally contained in the project
/// spatial hierarchy, i.e. the inverse attribute
/// SELF\IfcElement.ContainedInStructure of the aggregated
/// elements should be NIL.
/// 
/// Figure 118 illustrates roof containment, where only the IfcRoof as the aggregate
/// is included in the spatial structure.
/// 
/// Figure 118 — Roof containment
/// 
/// Geometry Use Definitions:
/// The geometric representation of IfcRoof is given by the
/// IfcProductDefinitionShape, allowing multiple geometric
/// representations. Independent geometric representations should
/// only be used when the IfcRoof is not defined as an
/// aggregate. If defined as an aggregate, the geometric
/// representation is the sum of the representation of the components
/// within the aggregate.
/// NOTEÿ View definitions and implementer
/// agreements may restrict the IfcRoof to not have an
/// independent geometry, but to always require aggregated elements
/// to represent the shape of the roof.
/// NOTE If the IfcRoof has aggregated elements to
/// represent the shape of the roof, then only those elements shall
/// have openings, not the IfcRoof
/// itself.
/// Local Position
/// The local placement for IfcRoof is defined in its
/// supertype IfcProduct. It is defined by the
/// IfcLocalPlacement, which defines the local coordinate
/// system that is referenced by all geometric representations.
/// 
/// The PlacementRelTo relationship of
/// IfcLocalPlacement shall point (if given) to the local
/// placement of the same IfcSpatialStructureElement that is
/// used in the ContainedInStructure inverse attribute or to a
/// referenced spatial structure element at a higher level..
/// If the relative placement is not used, the absolute placement
/// is defined within the world coordinate system.
/// 
/// If the LocalPlacement is given for the IfcRoof,
/// then all components, which are aggregated to the roof should use
/// this placement as their relative placement.
/// Geometric Representation
/// The IfcRoof may have an independent geometric representation
/// or may be an aggregate with elements holding the geometric
/// representation of the roof.
/// Geometric representation by own shape
/// representation
/// If the IfcRoof has no components defined (empty set of
/// SELF\IfcObject.IsDecomposedBy) then the IfcRoof may
/// be represented by an independent IfcShapeRepresentation.
/// The following attribute values for the IfcShapeRepresentation
/// holding this geometric representation shall be used:
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'SweptSolid', 'Clipping',
/// 'SurfaceModel', or 'Brep'
/// 
/// Geometric representation by aggregated elements
/// If the IfcRoof has components (referenced by
/// SELF\IfcObject.IsDecomposedBy) then no independent
/// geometric representation shall defined for the IfcRoof.
/// The IfcRoof is then geometrically represented by the
/// geometric representation of its components. The components are
/// accessed via
/// SELF\IfcObject.IsDecomposedBy[1].RelatedObjects. The
/// geometric representations that are supported for the aggregated
/// elements are defined with each element. See geometric use
/// definition for IfcSlab, IfcBeam, IfcColumn,
/// IfcBuildingElementPart and other subtypes of
/// IfcBuildingElement.
/// 
/// Figure 119 illustrates roof placement, with an IfcRoof defining the local placement for all aggregated elements.
/// 
/// Figure 119 — Roof placement
class IFC_PARSE_API IfcRoof : public IfcBuildingElement {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcRoof
    bool hasPredefinedType() const;
    /// Predefined shape types for a roof that are specified in an enumeration.
    /// 
    /// IFC2x4 CHANGE  The attribute has been renamed from ShapeType and changed to be OPTIONAL with upward compatibility for file based exchange.
    IfcRoofTypeEnum::IfcRoofTypeEnum PredefinedType() const;
    void setPredefinedType(IfcRoofTypeEnum::IfcRoofTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcBuildingElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcRoofTypeEnum; } return IfcBuildingElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "PredefinedType"; } return IfcBuildingElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcRoof (IfcEntityInstanceData* e);
    IfcRoof (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcRoofTypeEnum::IfcRoofTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcRoof > list;
};
/// A sanitary terminal is a fixed appliance or terminal usually supplied with water and used for drinking, cleaning or foul water disposal or that is an item of equipment directly used with such an appliance or terminal. 
/// 
/// HISTORY  New entity in IFC2x4
/// 
/// Type Use Definition
/// IfcSanitaryTerminal defines the occurrence of any sanitary terminal; common information about sanitary terminal types is handled by IfcSanitaryTerminalType. 
/// The IfcSanitaryTerminalType (if present) may establish the common type name, usage (predefined type), properties, materials, ports, composition, assignments, and representations. 
/// The IfcSanitaryTerminalType is attached using the IfcRelDefinesByType objectified relationship and is accessible by the IsTypedBy inverse attribute. 
/// If the IfcSanitaryTerminalType has ports or aggregated elements, such objects are reflected at the IfcSanitaryTerminal occurrence using the IfcRelDefinesByObject relationship.
/// 
/// Property Use Definition
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute. 
/// Property sets may also be specified at the IfcSanitaryTerminalType, defining the common property data for all occurrences of the same type. 
/// They are then accessible by the IsTypedBy inverse attribute pointing to IfcSanitaryTerminalType.HasPropertySets. 
/// If both are given, then the properties directly defined at IfcSanitaryTerminal override the properties defined at IfcSanitaryTerminalType. 
/// Refer to the documentation at the supertype IfcFlowTerminal and ancestors for inherited property set definitions.
/// The following property set definitions are applicable to this entity:
/// (All Types)
/// 
/// Pset_SanitaryTerminalTypeCommon (PSET_TYPEDRIVENOVERRIDE)
/// 
/// BATH
/// 
/// Pset_SanitaryTerminalTypeBath (PSET_TYPEDRIVENOVERRIDE)
/// 
/// BIDET
/// 
/// Pset_SanitaryTerminalTypeBidet (PSET_TYPEDRIVENOVERRIDE)
/// 
/// CISTERN
/// 
/// Pset_SanitaryTerminalTypeCistern (PSET_TYPEDRIVENOVERRIDE)
/// 
/// SANITARYFOUNTAIN
/// 
/// Pset_SanitaryTerminalTypeSanitaryFountain (PSET_TYPEDRIVENOVERRIDE)
/// 
/// SHOWER
/// 
/// Pset_SanitaryTerminalTypeShower (PSET_TYPEDRIVENOVERRIDE)
/// 
/// SINK
/// 
/// Pset_SanitaryTerminalTypeSink (PSET_TYPEDRIVENOVERRIDE)
/// 
/// TOILETPAN
/// 
/// Pset_SanitaryTerminalTypeToiletPan (PSET_TYPEDRIVENOVERRIDE)
/// 
/// URINAL
/// 
/// Pset_SanitaryTerminalTypeUrinal (PSET_TYPEDRIVENOVERRIDE)
/// 
/// WASHHANDBASIN
/// 
/// Pset_SanitaryTerminalTypeWashHandBasin (PSET_TYPEDRIVENOVERRIDE)
/// 
/// Quantity Use Definition
/// The quantities relating to this entity are defined by IfcElementQuantity and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute.
/// The following base quantities are defined and shall be exchanged with the IfcElementQuantity.Name = 'BaseQuantities'. 
/// Other quantities, being subjected to local standard of measurement, may be defined with another string value assigned to Name. 
/// In this case a valid value for MethodOfMeasurement shall be provided. 
/// 
/// Qto_SanitaryTerminalBaseQuantities
/// 
/// Material Use Definition
/// The material of the IfcSanitaryTerminal is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship. It is accessible by the HasAssociations inverse attribute. Material information can also be given at the IfcSanitaryTerminalType, defining the common attribute data for all occurrences of the same type. The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used:
/// 
/// Body: The primary material from which the object is constructed.
/// 
/// Port Use Definition
/// The distribution ports relating to the IfcSanitaryTerminal are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship. 
///   If the sanitary terminal occurrence is defined by IfcSanitaryTerminalType, then the port occurrences must reflect those defined at the IfcSanitaryTerminalType using the IfcRelDefinesByObject relationship.
///   Ports are specific to the IfcSanitaryTerminal PredefinedType as follows indicated by the IfcDistributionPort Name, PredefinedType, and FlowDirection:
/// 
/// BATH
/// 
/// ColdWater (DOMESTICCOLDWATER, SINK): Cold water supply.
/// HotWater (DOMESTICHOTWATER, SINK): Hot water supply.
/// Drainage (DRAINAGE, SOURCE): Drainage.
/// 
/// BIDET
/// 
/// ColdWater (DOMESTICCOLDWATER, SINK): Cold water supply.
/// HotWater (DOMESTICHOTWATER, SINK): Hot water supply.
/// Drainage (DRAINAGE, SOURCE): Drainage.
/// 
/// CISTERN
/// 
/// ColdWater (DOMESTICCOLDWATER, SINK): Cold water supply.
/// HotWater (DOMESTICHOTWATER, SINK): Hot water supply.
/// 
/// SANITARYFOUNTAIN
/// 
/// ColdWater (DOMESTICCOLDWATER, SINK): Cold water supply.
/// HotWater (DOMESTICHOTWATER, SINK): Hot water supply.
/// 
/// SHOWER
/// 
/// ColdWater (DOMESTICCOLDWATER, SINK): Cold water supply.
/// HotWater (DOMESTICHOTWATER, SINK): Hot water supply.
/// Drainage (DRAINAGE, SOURCE): Drainage.
/// 
/// SINK
/// 
/// ColdWater (DOMESTICCOLDWATER, SINK): Cold water supply.
/// HotWater (DOMESTICHOTWATER, SINK): Hot water supply.
/// Drainage (DRAINAGE, SOURCE): Drainage.
/// 
/// TOILETPAN
/// 
/// ColdWater (DOMESTICCOLDWATER, SINK): Cold water supply.
/// HotWater (DOMESTICHOTWATER, SINK): Hot water supply.
/// 
/// URINAL
/// 
/// ColdWater (DOMESTICCOLDWATER, SINK): Cold water supply.
/// HotWater (DOMESTICHOTWATER, SINK): Hot water supply.
/// 
/// WASHHANDBASIN
/// 
/// ColdWater (DOMESTICCOLDWATER, SINK): Cold water supply.
/// HotWater (DOMESTICHOTWATER, SINK): Hot water supply.
/// Drainage (DRAINAGE, SOURCE): Drainage.
class IFC_PARSE_API IfcSanitaryTerminal : public IfcFlowTerminal {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcSanitaryTerminal
    bool hasPredefinedType() const;
    IfcSanitaryTerminalTypeEnum::IfcSanitaryTerminalTypeEnum PredefinedType() const;
    void setPredefinedType(IfcSanitaryTerminalTypeEnum::IfcSanitaryTerminalTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcFlowTerminal::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcSanitaryTerminalTypeEnum; } return IfcFlowTerminal::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "PredefinedType"; } return IfcFlowTerminal::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcSanitaryTerminal (IfcEntityInstanceData* e);
    IfcSanitaryTerminal (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcSanitaryTerminalTypeEnum::IfcSanitaryTerminalTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcSanitaryTerminal > list;
};
/// The distribution control element type IfcSensorType defines commonly shared information for occurrences of sensors.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a sensor specification (i.e. the specific product information, that is common to all occurrences of that product type).  Sensor types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcSensorType are represented by instances of IfcSensor. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcDistributionControlElementType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_SensorTypeCommon 
/// 
/// The following property set definitions are applicable to this entity according to the PredefinedType attribute:  
/// Pset_SensorTypeConductanceSensor (CONDUCTANCESENSOR) 
/// Pset_SensorTypeContactSensor (CONTACTSENSOR) 
/// Pset_SensorTypeFireSensor (FIRESENSOR) 
/// Pset_SensorTypeFlowSensor (FLOWSENSOR) 
/// Pset_SensorTypeGasSensor (GASSENSOR) 
/// Pset_SensorTypeHeatSensor (HEATSENSOR) 
/// Pset_SensorTypeHumiditySensor (HUMIDITYSENSOR) 
/// Pset_SensorTypeIonConcentrationSensor (IONCONCENTRATIONSENSOR) 
/// Pset_SensorTypeLevelSensor (LEVELSENSOR) 
/// Pset_SensorTypeLightSensor (LIGHTSENSOR) 
/// Pset_SensorTypeMoistureSensor (MOISTURESENSOR) 
/// Pset_SensorTypeMovementSensor (MOVEMENTSENSOR) 
/// Pset_SensorTypePHSensor (PHSENSOR) 
/// Pset_SensorTypePressureSensor (PRESSURESENSOR) 
/// Pset_SensorTypeRadiationSensor (RADIATIONSENSOR) 
/// Pset_SensorTypeRadioactivitySensor (RADIOACTIVITYSENSOR) 
/// Pset_SensorTypeSmokeSensor (SMOKESENSOR) 
/// Pset_SensorTypeSoundSensor (SOUNDSENSOR) 
/// Pset_SensorTypeTemperatureSensor (TEMPERATURESENSOR) 
/// Pset_SensorTypeWindSensor (WINDSENSOR) 
/// 
/// Material Use Definition 
/// The material of the IfcSensorType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Casing': Material from which the casing is constructed. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcSensorType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcSensor for standard port definitions.
class IFC_PARSE_API IfcSensorType : public IfcDistributionControlElementType {
public:
    /// Identifies the predefined types of sensor from which the type required may be set.
    IfcSensorTypeEnum::IfcSensorTypeEnum PredefinedType() const;
    void setPredefinedType(IfcSensorTypeEnum::IfcSensorTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcDistributionControlElementType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcSensorTypeEnum; } return IfcDistributionControlElementType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcDistributionControlElementType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcSensorType (IfcEntityInstanceData* e);
    IfcSensorType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcSensorTypeEnum::IfcSensorTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcSensorType > list;
};
/// Definition from IAI: Shading devices are purpose built
/// devices to protect from the sunlight, from natural light, or
/// screening them from view. Shading devices can form part of the
/// facade or can be mounted inside the building, they can be fixed
/// or operable.
/// NOTE Also other building elements such as
/// protruding slabs or balconies can act as shading devices. Those
/// elements however have another primary purpose and are defined as
/// IfcSlab or by other subtypes of IfcBuildingElement.
/// The particular additional purpose as a shading device is provided
/// by assigning the property set Pset_ElementShading to those
/// building elements.
/// HISTORY New entity in
/// IFC2x4
class IFC_PARSE_API IfcShadingDevice : public IfcBuildingElement {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcShadingDevice
    bool hasPredefinedType() const;
    /// Predefined generic type for a shading device that is specified in an enumeration. There may be a property set given specificly for the predefined types.
    ///   NOTE The PredefinedType shall only be used, if no type object IfcShadingDeviceType is assigned, providing its own IfcShadingDeviceType.PredefinedType.
    IfcShadingDeviceTypeEnum::IfcShadingDeviceTypeEnum PredefinedType() const;
    void setPredefinedType(IfcShadingDeviceTypeEnum::IfcShadingDeviceTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcBuildingElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcShadingDeviceTypeEnum; } return IfcBuildingElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "PredefinedType"; } return IfcBuildingElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcShadingDevice (IfcEntityInstanceData* e);
    IfcShadingDevice (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcShadingDeviceTypeEnum::IfcShadingDeviceTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcShadingDevice > list;
};
/// A slab is a component of the
/// construction that normally encloses a space vertically. The slab
/// may provide the lower support (floor) or upper construction (roof
/// slab) in any space in a building. It shall be noted, that only
/// the core or constructional part of this construction is
/// considered to be a slap. The upper finish (flooring, roofing) and
/// the lower finish (ceiling, suspended ceiling) are considered to
/// be coverings. A special type of slab is the landing, described as
/// a floor section to which one or more stair flights or ramp
/// flights connect.
/// NOTE There is a representation of slabs for
/// structural analysis provided by a proper subtype of
/// IfcStructuralMember being part of the
/// IfcStructuralAnalysisModel.
/// 
/// NOTE ÿAn arbitrary planar element to which this semantic
/// information is not applicable or irrelevant shall be modeled as
/// IfcPlate.
/// A slab may have openings, such as floor openings, or recesses.
/// They are defined by an IfcOpeningElement attached to the
/// slab using the inverse relationship HasOpenings pointing
/// to IfcRelVoidsElement.
/// The IFC specification provides three entities for slab
/// occurrences:
/// 
/// IfcSlabStandardCase used for all occurrences of slabs,
/// that are prismatic and where the thickness parameter can be fully
/// described by the IfcMaterialLayerSetUsage. These slabs are
/// always represented geometrically by a 'SweptSolid' geometry (or
/// by a 'Clipping' geometry based on 'SweptSolid'), if a 3D
/// geometric representation is assigned. In addition they have to
/// have a corresponding IfcMaterialLayerSetUsage
/// assigned.
/// IfcSlabElementedCase used for occurrences of slabs
/// which are aggregated from subordinate elements, following
/// specific decomposition rules expressed by the mandatory use of
/// IfcRelAggregates relationship.
/// IfcSlab used for all other occurrences of slabs,
/// particularly for slabs with changing thickness, or slabs with non
/// planar surfaces, and slabs having only 'SweptSolid' or 'Brep'
/// geometry.
/// 
/// HISTORY New entity in IFC Release 2.0, it is a merger of the two previous entities
/// IfcFloor, IfcRoofSlab, introduced in IFC Release 1.0
/// 
/// Type Use Definition
/// The IfcSlab defines the occurrence of any slab, common
/// information about slab types (or styles) is handled by
/// IfcSlabType. The IfcSlabType (if present) may
/// establish the commonÿtype name, usage (or predefined) type,
/// common set of properties, common material layer set, and common
/// shape representations (using IfcRepresentationMap). The
/// IfcSlabType is attached using the
/// IfcRelDefinedByType.RelatingType objectified relationship
/// and is accessible by the inverse IsTypedBy attribute.
/// If no IfcSlabType is attachedÿ(i.e. if only occurrence
/// information is given) the PredefinedType should be
/// provided. Values of the enumeration are .FLOOR. (the default),
/// .ROOF., .LANDING., .BASESLAB. If set to .USERDEFINED. a user
/// defined value can be provided by the ObjectType
/// attribute.
/// Material Use Definition
/// The material of the IfcSlab is defined by
/// IfcMaterialLayerSet, or IfcMaterial and attached by
/// the IfcRelAssociatesMaterial.RelatingMaterial. It
/// is accessible by the inverse HasAssociations relationship.
/// Multi-layer slabs can be represented by referring to several
/// IfcMaterialLayer's within the
/// IfcMaterialLayerSet.
/// NOTE It is illegal to assign an
/// IfcMaterialLayerSetUsage to an IfcSlab. Only the
/// subtype IfcSlabStandardCase supports this
/// concept.
/// NOTE Prismatic slabs, where the main face of
/// the slab is extruded along the slab thickness, are exchanged as
/// IfcSlabStandardCase, The material for
/// IfcSlabStandardCase shall be defined
/// byÿIfcMaterialLayerSetUsage. Multi-layer slabs can be
/// represented by referring to several IfcMaterialLayer's
/// within the IfcMaterialLayerSet.ÿ
/// Material information can also be given at the
/// IfcSlabType, defining the common attribute data for all
/// occurrences of the same type.ÿIt is then accessible by the
/// inverse IsTypedBy
/// relationship pointing to IfcSlabType.HasAssociations and
/// via IfcRelAssociatesMaterial.RelatingMaterial.
/// Property Set Use Definition:
/// The property sets relating to the IfcSlab are defined
/// by the IfcPropertySet and attached by the
/// IfcRelDefinesByProperties relationship. It is accessible
/// by the inverse IsDefinedBy relationship. The following
/// property set definitions specific to the IfcSlab are part
/// of this IFC release:
/// 
/// Pset_SlabCommon: common property set for all
/// slab occurrences
/// 
/// Property sets can also be given at the IfcSlabType,
/// defining the common property data for all occurrences of the same
/// type.ÿIt is then accessible by the inverse IsTypedBy relationship pointing to
/// IfcSlabType.HasPropertySets. If both are given, then the
/// properties directly assigned to IfcSlab overrides the
/// properties assigned to IfcSlabType.
/// Quantity Use Definition
/// The quantities relating to the IfcSlab and
/// IfcSlabStandardCase are defined by the
/// IfcElementQuantity and attached by the
/// IfcRelDefinesByProperties relationship. It is accessible
/// by the inverse IsDefinedBy relationship. The following
/// base quantities are defined and should be exchanged with the
/// IfcElementQuantity.Name = 'BaseQuantities'. Other
/// quantities can be defined being subjected to local standard of
/// measurement with another string value assigned to Name and
/// a value provided for MethodOfMeasurement. Quantities shall
/// never be assigned to the IfcSlabType.
/// 
/// Qto_SlabBaseQuantities: base quantities for
/// all slab occurrences.
/// 
/// Containment Use Definition
/// The IfcSlab, as any subtype of
/// IfcBuildingElement, may participate in two different
/// containment relationships. The first (and in most implementation
/// scenarios mandatory) relationship is the hierarchical spatial
/// containment, the second (optional) relationship is the
/// aggregation within anÿelement assembly.
/// 
/// TheÿIfcSlab is places within the project spatial
/// hierarchy using the objectified relationship
/// IfcRelContainedInSpatialStructure, referring to it by its
/// inverse attribute SELF\IfcElement.ContainedInStructure.
/// Subtypes ofÿIfcSpatialStructureElement are valid spatial
/// containers, with IfcBuildingStorey being the default
/// container.
/// TheÿIfcSlab may be aggregated into an element assembly
/// using the objectified relationship IfcRelAggregates,
/// referring to it by its inverse attribute
/// SELF\IfcObjectDefinition.Decomposes. Any subtype of
/// IfcElement can be an element assembly, with
/// IfcElementAssembly as a special focus subtype.
/// In this case it should not be additionally contained in the
/// project spatial hierarchy,
/// i.e.ÿSELF\IfcElement.ContainedInStructure should be
/// NIL.
/// 
/// The IfcSlabÿmay also be an aggregate i.e. being
/// composed by other elements and acting as an assembly using the
/// objectified relationship IfcRelAggregates, referring to it
/// by its inverse attribute
/// SELF\IfcObjectDefinition.IsDecomposedBy. Components of a
/// slab are described by instances of subtypes of
/// IfcBuildingElement, with IfcBuildingElementPart as
/// a special focus subtype that are aggregated to form a complex
/// slab. In this case, the contained elements should not be
/// additionally contained in the project spatial hierarchy, i.e. the
/// inverse attribute SELF\IfcElement.ContainedInStructure of
/// IfcBuildingElementPart (or other subtypes of
/// IfcBuildingElement) should be NIL.
/// Geometry Use Definition
/// The geometric representation of IfcSlab is given by the
/// IfcProductDefinitionShape, allowing multiple geometric
/// representation. Included are:
/// NOTE. If the IfcSlab is of type Landing
/// and is used within an IfcStair or IfcRamp, the
/// special agreements to handle stair and ramp geometry will also
/// affect the geometric representation of the
/// IfcSlab.
/// Local Placement
/// The local placement for IfcSlab is defined in its
/// supertype IfcProduct. It is defined by the
/// IfcLocalPlacement, which defines the local coordinate
/// system that is referenced by all geometric representations.
/// 
/// The PlacementRelTo relationship of
/// IfcLocalPlacement shall point (if given) to the placement
/// of the local placement of the same
/// IfcSpatialStructureElement that is used in the
/// ContainedInStructure inverse attribute or to a referenced
/// spatial structure element at a higher level.
/// If the IfcSlab is of type Landing and is used by an
/// IfcStair or IfcRamp, and this container class
/// defines its own local placement, then the PlacementRelTo
/// relationship of IfcLocalPlacement shall point (if given)
/// to the local placement of the aggregate.
/// If the relative placement is not used, the absolute placement
/// is defined within the world coordinate system.
/// 
/// Geometric Representation
/// Currently, the 'Surface',
/// 'FootPrint', 'Body', and 'Box'
/// representations are supported. The 'Box' representation includes
/// the representation type 'BoundingBox' and is explained at
/// IfcBuildingElement.
/// Surface Representation
/// The surfacic geometric representation of IfcSlab is
/// defined using the 'Surface' representation.
/// 
/// RepresentationIdentifier : 'Surface'
/// RepresentationType : 'Surface3D'
/// 
/// NOTE The 'Surface' can be used to define a
/// surfacic model of the building (e.g. for analytical purposes, or
/// for reduced Level of Detail representation).
/// Body Representation
/// The body representation of IfcSlab can be represented
/// using the representation types 'SweptSolid', 'Clipping',
/// 'SurfaceModel', and 'Brep'. The representation types
/// 'SurfaceModel' and 'Brep' are explained at
/// IfcBuildingElement.
/// SweptSolid Representation Type
/// The following attribute values for the
/// IfcShapeRepresentation holding this geometric
/// representation shall be used:
/// If a corresponding material definition using
/// IfcMaterialLayerSetUsage can be assigned, the subtype
/// IfcSlabStandardCase shall be used.
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'SweptSolid'
/// 
/// The following additional constraints apply to the swept solid
/// representation:
/// 
/// Solid: IfcExtrudedAreaSolid is required,
/// Profile: IfcArbitraryClosedProfileDef,
/// IfcRectangleProfileDef, IfcCircleProfileDef,
/// IfcEllipseProfileDef shall be supported.
/// Extrusion: The profile can be extruded perpendicularly
/// or non-perpendicularly to the plane of the swept profile.
/// 
/// Figure 120 illustrates a 'SweptSolid' geometric representation.
/// NOTE The following interpretation of dimension parameter applies for polygonal slabs (in ground floor view):
/// 
/// IfcArbitraryClosedProfileDef.OuterCurve: closed bounded curve interpreted as area (or foot print) of the slab.
/// 
/// Figure 120 — Slab body extrusion
/// 
/// Clipping Representation Type
/// The following attribute values for the
/// IfcShapeRepresentation holding this geometric
/// representation shall be used:
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'Clipping'
/// 
/// The following constraints apply to the 'Clipping'
/// representation:
/// 
/// Solid: see 'SweptSolid' shape representation,
/// Profile:ÿsee 'SweptSolid' shape representation,
/// Extrusion:ÿsee 'SweptSolid' shape representation,
/// Boolean result: The IfcBooleanClippingResult
/// shall be supported, allowing for Boolean differences between the
/// swept solid (here IfcExtrudedAreaSolid) and one or several
/// IfcHalfSpaceSolid.
/// 
/// Figure 121 illustrates a 'Clipping' geometric representation with definition of a roof slab using advanced
/// geometric representation. The profile is extruded non-perpendicular and the slab body is clipped at the eave.
/// 
/// Figure 121 — Slab body clipping
class IFC_PARSE_API IfcSlab : public IfcBuildingElement {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcSlab
    bool hasPredefinedType() const;
    /// Predefined generic type for a slab that is specified in an enumeration. There may be a property set given specifically for the predefined types.
    ///   NOTE The PredefinedType shall only be used, if no type object IfcSlabType is assigned, providing its own IfcSlabType.PredefinedType.
    /// 
    /// FC2x PLATFORM CHANGE: The attribute has been changed into an OPTIONAL attribute.
    IfcSlabTypeEnum::IfcSlabTypeEnum PredefinedType() const;
    void setPredefinedType(IfcSlabTypeEnum::IfcSlabTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcBuildingElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcSlabTypeEnum; } return IfcBuildingElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "PredefinedType"; } return IfcBuildingElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcSlab (IfcEntityInstanceData* e);
    IfcSlab (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcSlabTypeEnum::IfcSlabTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcSlab > list;
};
/// The IfcSlabElementedCase
/// defines a slab with certain constraints for the provision of its
/// components. The IfcSlabElementedCase handles all cases of
/// slabs, that are decomposed into parts:ÿ
/// 
/// having components being assigned to the
/// IfcSlabElementedCase using the IfcRelAggregates
/// relationship accessible by the inverse relationship
/// IsDecomposedBy.
/// applying the constraint that the parts within the
/// decomposition shall be of type IfcBeam, IfcMember,
/// IfcPlate, IfcBuildingElementPart or
/// IfcBuildingElementProxy.
/// 
/// HISTORY New entity in
/// IFC2x4.
/// Property Set Use Definition:
/// The property sets relating to the IfcSlabElementedCase
/// are defined at the supertype IfcSlab.
/// NOTE The parts within the decomposition
/// relationship may define their own property
/// sets.
/// Quantity Use Definition:
/// The quantities relating to the IfcSlabElementedCase are
/// defined at the supertype IfcSlab.
/// NOTE The parts within the decomposition
/// relationship may define their own individual
/// quantities.
/// 
/// Voiding Use Definition:
/// 
/// As shown in Figure 122, openings within the composite slab are directly assigned to IfcSlabElementedCase using IfcRelVoidsElement pointing to IfcOpeningElement and apply to all aggregated parts. If individual parts have cutting and other voiding features, then the decomposed parts have a separate voiding relationship IfcRelVoidsElement pointing to IfcVoidingFeature.
/// 
/// Figure 122 — Slab elemented voiding
/// 
/// Decomposition Use Definition:
/// The following guidance is provided for the components of the
/// IfcSlabElementedCase. The following component entity types
/// should be used:
/// 
/// Precast hollow core slabs
/// 
/// double tee or plank components : IfcBeam
/// topping : IfcBuildingElementPart
/// others : IfcBuildingElementPart
/// 
/// Geometry Use Definitions:
/// The geometric representation of IfcSlabElementedCase is
/// given by the IfcProductDefinitionShape, allowing multiple
/// geometric representation. Included are:
/// Local Placement
/// The use of local placement is defined at the supertype
/// IfcSlab. The local placement of the
/// IfcSlabElementedCase defines the parent coordinate systems
/// for the parts within the decomposition. All parts shall be
/// positioned relative to the IfcSlabElementedCase.
/// Geometric Representation
/// The standard geometric representation of
/// IfcSlabElementedCase is defined using the following
/// multiple shape representations for its definition:
/// 
/// Surface: A three-dimensional surface being a subtype
/// of IfcBoundedSurface defining the reference surface for
/// the elemented slab. It maybe used as a simplified representation
/// directly at the elemented slab.
/// 
/// NOTEÿ It is invalid to exhange a 'Body' shape
/// representation of an IfcSlabElementedCase. The body
/// geometry is defined by the parts within the
/// decomposition.
/// Surface Representation
/// The surfacic geometric representation of
/// IfcSlabElementedCase is defined using the 'Surface'
/// representation.
/// 
/// RepresentationIdentifier : 'Surface'
/// RepresentationType : 'Surface3D'
/// 
/// NOTE The 'Surface' can be used to define a
/// surfacic model of the building (e.g. for analytical purposes, or
/// for reduced Level of Detail representation). It should suppress
/// the geometric details of the parts in the
/// decomposition.
class IFC_PARSE_API IfcSlabElementedCase : public IfcSlab {
public:
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcSlab::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcSlab::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcSlab::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcSlabElementedCase (IfcEntityInstanceData* e);
    IfcSlabElementedCase (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcSlabTypeEnum::IfcSlabTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcSlabElementedCase > list;
};
/// The standard slab,
/// IfcSlabStandardCase, defines a slab with certain constraints
/// for the provision of material usage, parameters and with certain
/// constraints for the geometric representation. The
/// IfcSlabStandardCase handles all cases of slabs, that:
/// 
/// have a reference to the IfcMaterialLayerSetUsage
/// defining the material layers of the slab with thicknesses
/// are based on an extrusion of a planar surface as defined by the
/// slab profile
/// have a constant thickness along the extrusion direction
/// are consistent in using the correct material layer set offset
/// to the base planar surface in regard to the shape
/// representation
/// are extruded either perpendicular or slanted to the plane
/// surface
/// 
/// The definitions of slab openings and niches are the same as
/// given at the supertype IfcSlab. The same agreements to the
/// special types of slabs, as defined in the PredefinedType
/// attribute apply as well.
/// HISTORY New entity in
/// IFC2x Edition 4.
/// Type Use Definition
/// The IfcSlabStandardCase defines the occuurence of any
/// slab, common information about slab types (or styles) is handled by
/// IfcSlabType. The IfcSlabType (if present) may
/// establish the common type name, usage (or predefined) type,
/// common set of properties, common material layer set, and common
/// shape representations (using IfcRepresentationMap). The
/// IfcSlabType is attached using the
/// IfcRelDefinedByType.RelatingType objectified relationship
/// and is accessible by the inverse IsDefinedBy attribute.
/// The IfcSlabStandardCase defines in addition that the
/// IfcSlabType should have a unique IfcMaterialLayerSet,
/// that is referenced by the IfcMaterialLayerSetUsage
/// assigned to all occurrences of this slab type.
/// 
/// Figure 123 illustrates assignment of IfcMaterialLayerSetUsage and IfcMaterialLayerSet to the IfcSlabStandardCase as the slab occurrence and to the IfcSlabType. The same IfcMaterialLayerSet shall be shared by many occurrences of IfcMaterialLayerSetUsage. This relationship shall be consistent to the relationship between the IfcSlabType and the IfcSlabStandardCase.
/// 
/// Figure 123 — Slab type definition
/// 
/// Material Use Definition
/// The material of the IfcSlabStandardCase is defined by
/// IfcMaterialLayerSetUsage and attached by the
/// IfcRelAssociatesMaterial.RelatingMaterial. It is
/// accessible by the inverse HasAssociations relationship.
/// Multi-layer slabs can be represented by refering to several
/// IfcMaterialLayer's within the IfcMaterialLayerSet
/// that is referenced from the
/// IfcMaterialLayerSetUsage. 
/// Material information can also be given at the
/// IfcSlabType, defining the common attribute data for all
/// occurrences of the same type. It is then accessible by the
/// inverse IsDefinedBy relationship pointing to
/// IfcSlabType.HasAssociations and via
/// IfcRelAssociatesMaterial.RelatingMaterial. See Type Use
/// Definition for additional agreements for standard slabs.
/// 
/// Figure 123 illustrates slab material usage, where the following conventions shall be met:
/// 
/// The reference coordinate system is the coordinate system established by the IfcExtrudedAreaSolid.Position.
/// The reference plane is the plane defined by the extruded profile of IfcExtrudedAreaSolid.SweptSolid. The IfcMaterialLayerSetUsage.OffsetFromReferenceLine is given as a distance from this plane.
/// The IfcMaterialLayerSetUsage.DirectionSense defines how the IfcMaterialLayer's are assigned to the reference plane. POSITIVE means in direction to the positive z-axis of the reference coordinate system.
/// The IfcMaterialLayerSetUsage.OffsetFromReferenceLine is the distance parallel to the reference plane and always perpendicular to the base (XY) plane of the reference coordinate system. This is independent of a potential non-perpendicular extrusion given by IfcExtrudedAreaSolid.ExtrudedDirection <> 0.,0.,1. A positive value of IfcMaterialLayerSetUsage.OffsetFromReferenceLine would then point into the positive z-axis of the reference coordinate system.
/// The Thickness of each IfcMaterialLayer shall be the parallel distance (measured perpendicular to the base plane). The TotalThickness of the IfcMaterialLayerSet is the sum of all layer thicknesses and in case of a perpendicular extrusion identical with IfcExtrudedAreaSolid.Depth
/// The IfcMaterialLayerSetUsage.LayerSetDirection is always AXIS3.
/// 
/// Figure 124 — Slab material layers
/// 
/// Property Set Use Definition:
/// The property sets relating to the IfcSlabStandardCase are
/// defined at the supertype IfcSlab.
/// Quantity Use Definition
/// The quantities relating to the IfcSlabStandardCase are
/// defined at the supertype IfcSlab.
/// Containment Use Definition
/// The containment use definitions relating to the
/// IfcSlabStandardCase are defined at the supertype
/// IfcSlab.
/// 
/// Geometry Use Definitions
/// The geometric representation of IfcSlabStandardCase is
/// given by the IfcProductDefinitionShape, allowing multiple
/// geometric representation. Included are:
/// 
/// NOTE If the IfcSlabStandardCase is of type Landing
/// and is used within an IfcStair or IfcRamp, the
/// special agreements to handle stair and ramp geometry will also
/// affect the geometric representation of the
/// IfcSlabStandardCase.
/// 
/// Local Placement
/// The use of local placement is defined at the supertype
/// IfcSlab.
/// Geometric Representations
/// Currently, the use of 'SweptSolid' and 'Clipping'
/// representations is supported. In addition the general
/// representation type 'BoundingBox' is allowed. The geometry use
/// definitions for 'BoundingBox', is explained at
/// IfcBuildingElement.
/// SweptSolid Representation
/// The following attribute values for the
/// IfcShapeRepresentation holding this geometric representation
/// shall be used for the 'SweptSolid' representation:
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'SweptSolid'
/// 
/// The following additional constraints apply to the swept solid
/// representation:
/// 
/// Solid: IfcExtrudedAreaSolid is required,
/// Profile: IfcArbitraryClosedProfileDef,
/// IfcRectangleProfileDef, IfcCircleProfileDef,
/// IfcEllipseProfileDef shall be supported.
/// Extrusion: The profile can be extruded perpendicularly
/// or non-perpendicularly to the plane of the swept profile.
/// Material: The definition of the
/// IfcMaterialLayerSetUsage, particularly of the
/// OffsetFromReferenceLine and the
/// ForLayerSet.TotalThickness, has to be consistent to the
/// 'SweptSolid' representation.
/// 
/// Figure 125 illustrates a 'SweptSolid' geometric representation.
/// NOTE The following interpretation of dimension parameter applies for polygonal slabs (in ground floor view):
/// 
/// IfcArbitraryClosedProfileDef.OuterCurve: closed bounded curve interpreted as area (or foot print) of the slab.
/// 
/// Figure 125 — Slab body extrusion
/// 
/// Clipping representation
/// The 'Clipping' geometric representation of
/// IfcSlabStandardCase is defined using the swept area geometry
/// with additional clippings applied. The following attribute values
/// for the IfcShapeRepresentation holding this geometric
/// representation shall be used:
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'Clipping'
/// 
/// The following constraints apply to the 'Clipping'
/// representation:
/// 
/// Solid: see 'SweptSolid' shape representation,
/// Profile: see 'SweptSolid' shape
/// representation,
/// Extrusion: see 'SweptSolid' shape
/// representation,
/// Material: see 'SweptSolid' shape
/// representation,
/// Boolean result: The IfcBooleanClippingResult
/// shall be supported, allowing for Boolean differences between the
/// swept solid (here IfcExtrudedAreaSolid) and one or several
/// IfcHalfSpaceSolid.
/// 
/// Figure 126 illustrates a 'Clipping' geometric representation with definition of a roof slab using advanced geometric representation. The profile is extruded non-perpendicular and the slab body is clipped at the eave.
/// 
/// Figure 126 — Slab body clipping
class IFC_PARSE_API IfcSlabStandardCase : public IfcSlab {
public:
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcSlab::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcSlab::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcSlab::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcSlabStandardCase (IfcEntityInstanceData* e);
    IfcSlabStandardCase (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcSlabTypeEnum::IfcSlabTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcSlabStandardCase > list;
};
/// A solar device converts solar radiation into other energy such as electric current or thermal energy. 
/// 
/// HISTORY  New entity in IFC2x4
/// 
/// Type Use Definition
/// IfcSolarDevice defines the occurrence of any solar device; common information about solar device types is handled by IfcSolarDeviceType. 
/// The IfcSolarDeviceType (if present) may establish the common type name, usage (predefined type), properties, materials, ports, composition, assignments, and representations. 
/// The IfcSolarDeviceType is attached using the IfcRelDefinesByType objectified relationship and is accessible by the IsTypedBy inverse attribute. 
/// If the IfcSolarDeviceType has ports or aggregated elements, such objects are reflected at the IfcSolarDevice occurrence using the IfcRelDefinesByObject relationship.
/// 
/// Property Use Definition
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute. 
/// Property sets may also be specified at the IfcSolarDeviceType, defining the common property data for all occurrences of the same type. 
/// They are then accessible by the IsTypedBy inverse attribute pointing to IfcSolarDeviceType.HasPropertySets. 
/// If both are given, then the properties directly defined at IfcSolarDevice override the properties defined at IfcSolarDeviceType. 
/// Refer to the documentation at the supertype IfcEnergyConversionDevice and ancestors for inherited property set definitions.
/// The following property set definitions are applicable to this entity:
/// Pset_SolarDeviceTypeCommon (PSET_TYPEDRIVENOVERRIDE)
/// 
/// Quantity Use Definition
/// The quantities relating to this entity are defined by IfcElementQuantity and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute.
/// The following base quantities are defined and shall be exchanged with the IfcElementQuantity.Name = 'BaseQuantities'. 
/// Other quantities, being subjected to local standard of measurement, may be defined with another string value assigned to Name. 
/// In this case a valid value for MethodOfMeasurement shall be provided. 
/// 
/// Qto_SolarDeviceBaseQuantities
/// 
/// Material Use Definition
/// The material of the IfcSolarDevice is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship. It is accessible by the HasAssociations inverse attribute. Material information can also be given at the IfcSolarDeviceType, defining the common attribute data for all occurrences of the same type. The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used:
/// 
/// Casing: Material from which the casing is constructed.
/// 
/// Port Use Definition
/// The distribution ports relating to the IfcSolarDevice are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship. 
///   If the solar device occurrence is defined by IfcSolarDeviceType, then the port occurrences must reflect those defined at the IfcSolarDeviceType using the IfcRelDefinesByObject relationship.
///   Ports are specific to the IfcSolarDevice PredefinedType as follows indicated by the IfcDistributionPort Name, PredefinedType, and FlowDirection:
/// 
/// SOLARCOLLECTOR
/// 
/// Heating (HEATING, SOURCE): Incoming water.
/// Heating (HEATING, SINK): Outgoing heated water.
/// 
/// SOLARPANEL
/// 
/// PowerGeneration (POWERGENERATION, SOURCE): Converted electrical power.
class IFC_PARSE_API IfcSolarDevice : public IfcEnergyConversionDevice {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcSolarDevice
    bool hasPredefinedType() const;
    IfcSolarDeviceTypeEnum::IfcSolarDeviceTypeEnum PredefinedType() const;
    void setPredefinedType(IfcSolarDeviceTypeEnum::IfcSolarDeviceTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcEnergyConversionDevice::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcSolarDeviceTypeEnum; } return IfcEnergyConversionDevice::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "PredefinedType"; } return IfcEnergyConversionDevice::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcSolarDevice (IfcEntityInstanceData* e);
    IfcSolarDevice (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcSolarDeviceTypeEnum::IfcSolarDeviceTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcSolarDevice > list;
};
/// Space heaters utilize a combination of radiation and/or natural convection using a heating source such as electricity, steam or hot water to heat a limited space or area. Examples of space heaters include radiators, convectors, baseboard and finned-tube heaters.
/// IfcUnitaryEquipment should be used for packaged units supporting a combination of heating, cooling, and/or dehumidification; IfcCoil should be used for coil-based floor heating. 
/// 
/// HISTORY  New entity in IFC2x4
/// 
/// Type Use Definition
/// IfcSpaceHeater defines the occurrence of any space heater; common information about space heater types is handled by IfcSpaceHeaterType. 
/// The IfcSpaceHeaterType (if present) may establish the common type name, usage (predefined type), properties, materials, ports, composition, assignments, and representations. 
/// The IfcSpaceHeaterType is attached using the IfcRelDefinesByType objectified relationship and is accessible by the IsTypedBy inverse attribute. 
/// If the IfcSpaceHeaterType has ports or aggregated elements, such objects are reflected at the IfcSpaceHeater occurrence using the IfcRelDefinesByObject relationship.
/// 
/// Property Use Definition
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute. 
/// Property sets may also be specified at the IfcSpaceHeaterType, defining the common property data for all occurrences of the same type. 
/// They are then accessible by the IsTypedBy inverse attribute pointing to IfcSpaceHeaterType.HasPropertySets. 
/// If both are given, then the properties directly defined at IfcSpaceHeater override the properties defined at IfcSpaceHeaterType. 
/// Refer to the documentation at the supertype IfcFlowTerminal and ancestors for inherited property set definitions.
/// The following property set definitions are applicable to this entity:
/// (All Types)
/// 
/// Pset_SpaceHeaterPHistory (PSET_PERFORMANCEDRIVEN)
/// Pset_SpaceHeaterTypeCommon (PSET_TYPEDRIVENOVERRIDE)
/// 
/// CONVECTOR
/// 
/// Pset_SpaceHeaterTypeConvector (PSET_TYPEDRIVENOVERRIDE)
/// 
/// RADIATOR
/// 
/// Pset_SpaceHeaterTypeRadiator (PSET_TYPEDRIVENOVERRIDE)
/// 
/// Quantity Use Definition
/// The quantities relating to this entity are defined by IfcElementQuantity and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute.
/// The following base quantities are defined and shall be exchanged with the IfcElementQuantity.Name = 'BaseQuantities'. 
/// Other quantities, being subjected to local standard of measurement, may be defined with another string value assigned to Name. 
/// In this case a valid value for MethodOfMeasurement shall be provided. 
/// 
/// Qto_SpaceHeaterBaseQuantities
/// 
/// Material Use Definition
/// The material of the IfcSpaceHeater is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship. It is accessible by the HasAssociations inverse attribute. Material information can also be given at the IfcSpaceHeaterType, defining the common attribute data for all occurrences of the same type. The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used:
/// 
/// Body: The primary material from which the object is constructed.
/// 
/// Port Use Definition
/// The distribution ports relating to the IfcSpaceHeater are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship. 
///   If the space heater occurrence is defined by IfcSpaceHeaterType, then the port occurrences must reflect those defined at the IfcSpaceHeaterType using the IfcRelDefinesByObject relationship.
///   Ports are specific to the IfcSpaceHeater PredefinedType as follows indicated by the IfcDistributionPort Name, PredefinedType, and FlowDirection:
/// 
/// CONVECTOR
/// 
/// Power (ELECTRICAL, SINK): Receives electrical power.
/// 
/// RADIATOR
/// 
/// Inlet (HEATING, SINK): Water or steam supply.
/// Outlet (HEATING, SOURCE): Water or steam return.
/// 
/// Figure 230 illustrates space heater port use.
/// Figure 230 — Space heater port use
class IFC_PARSE_API IfcSpaceHeater : public IfcFlowTerminal {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcSpaceHeater
    bool hasPredefinedType() const;
    IfcSpaceHeaterTypeEnum::IfcSpaceHeaterTypeEnum PredefinedType() const;
    void setPredefinedType(IfcSpaceHeaterTypeEnum::IfcSpaceHeaterTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcFlowTerminal::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcSpaceHeaterTypeEnum; } return IfcFlowTerminal::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "PredefinedType"; } return IfcFlowTerminal::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcSpaceHeater (IfcEntityInstanceData* e);
    IfcSpaceHeater (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcSpaceHeaterTypeEnum::IfcSpaceHeaterTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcSpaceHeater > list;
};
/// A stack terminal is placed at the top of a ventilating stack (such as to prevent ingress by birds or rainwater) or rainwater pipe (to act as a collector or hopper for discharge from guttering). 
/// 
/// HISTORY  New entity in IFC2x4
/// 
/// Type Use Definition
/// IfcStackTerminal defines the occurrence of any stack terminal; common information about stack terminal types is handled by IfcStackTerminalType. 
/// The IfcStackTerminalType (if present) may establish the common type name, usage (predefined type), properties, materials, ports, composition, assignments, and representations. 
/// The IfcStackTerminalType is attached using the IfcRelDefinesByType objectified relationship and is accessible by the IsTypedBy inverse attribute. 
/// If the IfcStackTerminalType has ports or aggregated elements, such objects are reflected at the IfcStackTerminal occurrence using the IfcRelDefinesByObject relationship.
/// 
/// Property Use Definition
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute. 
/// Property sets may also be specified at the IfcStackTerminalType, defining the common property data for all occurrences of the same type. 
/// They are then accessible by the IsTypedBy inverse attribute pointing to IfcStackTerminalType.HasPropertySets. 
/// If both are given, then the properties directly defined at IfcStackTerminal override the properties defined at IfcStackTerminalType. 
/// Refer to the documentation at the supertype IfcFlowTerminal and ancestors for inherited property set definitions.
/// The following property set definitions are applicable to this entity:
/// Pset_StackTerminalTypeCommon (PSET_TYPEDRIVENOVERRIDE)
/// 
/// Quantity Use Definition
/// The quantities relating to this entity are defined by IfcElementQuantity and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute.
/// The following base quantities are defined and shall be exchanged with the IfcElementQuantity.Name = 'BaseQuantities'. 
/// Other quantities, being subjected to local standard of measurement, may be defined with another string value assigned to Name. 
/// In this case a valid value for MethodOfMeasurement shall be provided. 
/// 
/// Qto_StackTerminalBaseQuantities
/// 
/// Material Use Definition
/// The material of the IfcStackTerminal is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship. It is accessible by the HasAssociations inverse attribute. Material information can also be given at the IfcStackTerminalType, defining the common attribute data for all occurrences of the same type. The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used:
/// 
/// Body: The primary material from which the object is constructed.
/// 
/// Port Use Definition
/// The distribution ports relating to the IfcStackTerminal are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship. 
///   If the stack terminal occurrence is defined by IfcStackTerminalType, then the port occurrences must reflect those defined at the IfcStackTerminalType using the IfcRelDefinesByObject relationship.
///   Ports are specific to the IfcStackTerminal PredefinedType as follows indicated by the IfcDistributionPort Name, PredefinedType, and FlowDirection:
/// 
/// BIRDCAGE
/// 
/// Exhaust (EXHAUST, SINK): Exhaust inlet.
/// 
/// COWL
/// 
/// Exhaust (EXHAUST, SINK): Exhaust inlet.
/// 
/// RAINWATERHOPPER
/// 
/// Rain (RAINWATER, SOURCE): Rainwater outlet.
class IFC_PARSE_API IfcStackTerminal : public IfcFlowTerminal {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcStackTerminal
    bool hasPredefinedType() const;
    IfcStackTerminalTypeEnum::IfcStackTerminalTypeEnum PredefinedType() const;
    void setPredefinedType(IfcStackTerminalTypeEnum::IfcStackTerminalTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcFlowTerminal::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcStackTerminalTypeEnum; } return IfcFlowTerminal::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "PredefinedType"; } return IfcFlowTerminal::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcStackTerminal (IfcEntityInstanceData* e);
    IfcStackTerminal (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcStackTerminalTypeEnum::IfcStackTerminalTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcStackTerminal > list;
};
/// Definition from ISO 6707-1:1989: Construction comprising
/// a succession of horizontal stages (steps or landings) that make it
/// possible to pass on foot to other levels.
/// A stair is a vertical passageway allowing
/// occupants to walk (step) from one floor level to another floor
/// level at a different elevation. It may include a landing as an
/// intermediate floor slab. The stair should either be
/// represented:
/// 
/// as a stair assembly entity that aggregates all components
/// (stair flight, landing, etc. with own representations), or
/// as a single stair entity without decomposition including all
/// representation directly at the stair entity.
/// 
/// In case of a stair container, the aggregation is handled via the
/// IfcRelAggregates relationship, relating an IfcStair
/// with the related IfcStairFlight's and landings (represented
/// by IfcSlab with IfcSlab.PredefinedType = 'LANDING').
/// IfcRailing's belonging to the stair may be included into the
/// aggregation as well.
/// 
/// HISTORY New Entity in IFC Release 2.0.
/// IFC2x4 CHANGE Attribute ShapeType renamed to PredefinedType.
/// 
/// Type Use Definition
/// IfcStair defines the occurrence of any stair, common
/// information about stair types (or styles) is handled by
/// IfcStairType. The IfcStairType (if present) may
/// establish the common type name, usage (or predefined) type, common
/// material, common set of properties and common shape representations
/// (using IfcRepresentationMap). The IfcStairType is
/// attached using the IfcRelDefinedByType.RelatingType
/// objectified relationship and is accessible by the inverse
/// IsDefinedBy attribute.
/// NOTE Since the IfcStair might be
/// represented as an aggregate of parts, e.g. represented by
/// IfcStairFlight, or IfcSlab, these individual parts
/// may have type information attached (represented e.g. by
/// IfcStairFlightType, or
/// IfcSlabType).
/// Material Use Definition
/// The material of the IfcStair is defined by the
/// IfcMaterial and attached by the
/// IfcRelAssociatesMaterial.RelatingMaterial. It is
/// accessible by the inverse HasAssociations relationship.
/// Material information can also be given at the
/// IfcStairType, defining the common attribute data for all
/// occurrences of the same type. It is then accessible by the inverse
/// IsDefinedBy relationship pointing to
/// IfcStair.HasAssociations and via
/// IfcRelAssociatesMaterial.RelatingMaterial to
/// IfcMaterial. If both are given, then the material directly
/// assigned to IfcStair overrides the material assigned to
/// IfcStairType.
/// 
/// Property Set Use Definition:
/// The property sets relating to the IfcStair are defined by
/// the IfcPropertySet and attached by the
/// IfcRelDefinesByProperties relationship. It is accessible by
/// the inverse IsDefinedBy relationship. The following property
/// set definitions specific to the IfcStair are part of this
/// IFC release:
/// 
/// Pset_StairCommon: common property set for all
/// stair occurrences
/// 
/// Figure 127 shows the use of property sets Pset_StairCommon and
/// Pset_StairFlightCommon for the various stair properties.
/// 
/// Figure 127 — Stair properties
/// 
/// Geometry Use Definitions:
/// The geometric representation of IfcStair is given by the
/// IfcProductDefinitionShape, allowing multiple geometric
/// representation. Independent geometric representations should only
/// be used when the IfcStair is not defined as an aggregate. If
/// defined as an aggregate, the geometric representation is the sum of
/// the representation of the components within the aggregate.
/// Local placement
/// The local placement for IfcStair is defined in its
/// supertype IfcProduct. It is defined by the
/// IfcLocalPlacement, which defines the local coordinate system
/// that is referenced by all geometric representations.
/// 
/// The PlacementRelTo relationship of
/// IfcLocalPlacement shall point (if given) to the local
/// placement of the same IfcSpatialStructureElement that is
/// used in the ContainedInStructure inverse attribute or to a
/// referenced spatial structure element at a higher level.
/// If the relative placement is not used, the absolute placement
/// is defined within the world coordinate system.
/// 
/// If the LocalPlacement is given for the IfcStair,
/// then all components, which are aggregated to the stair should use
/// this placement as their relative placement.
/// Geometric Representation
/// Currently, the 'Axis', 'FootPrint', 'Body', and 'Box'
/// representations are supported. The 'Box' representation includes
/// the representation type 'BoundingBox' and is explained at
/// IfcBuildingElement.
/// 
/// Axis: A two-dimensional open curve
/// IfcBoundedCurve defining the walking line for the
/// stair.
/// FootPrint: A geometric curve set defining the footing
/// print, including the boundary of the stair.
/// Body: A solid representation defining the 3D shape of
/// the stair.
/// 
/// Axis Representation
/// The walking line is represented by a two-dimensional open curve
/// as the axis. The curve is directed into the upward direction
/// (direction has to be interpreted as specified at the subtypes of
/// IfcCurve). The following attribute values for the
/// IfcShapeRepresentation holding this geometric representation
/// shall be used:
/// 
/// RepresentationIdentifier : 'Axis'
/// RepresentationType : 'Curve2D'
/// 
/// NOTE  The 'Axis' representation of IfcStair
/// may be provided even if the IfcStair has components with own
/// shape representations.
/// 
/// FootPrint Representation
/// The stair foot print, including the stair boundary is
/// represented by a two-dimensional geometric curve set. The following
/// attribute values for the IfcShapeRepresentation holding this
/// geometric representation shall be used:
/// 
/// RepresentationIdentifier : 'FootPrint'
/// RepresentationType : 'GeometricCurveSet'
/// 
/// NOTE  The 'Footprint' representation of
/// IfcStair may be provided even if the IfcStair has
/// components with own shape representations.
/// 
/// Body Representation
/// The body representation of IfcStair can be represented
/// using the representation types 'SweptSolid', 'SurfaceModel',
/// 'Brep', and 'MappedRepresentation'. The general usage of
/// representation is are explained at IfcBuildingElement. No
/// further constraints or provisions on how to use the representation
/// types are defined for IfcStairFlight.
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'SweptSolid', 'SurfaceModel',
/// 'Brep', 'MappedRepresentation'
/// 
/// The 'Body' representation shall only be provided if the
/// IfcStair has no components defined (empty set of
/// SELF\IfcObject.IsDecomposedBy) or if the components defined
/// no not carry an own 'Body' representation.
/// Geometric representation by aggregated elements
/// If the IfcStair has components (referenced by
/// SELF\IfcObject.IsDecomposedBy) with own 'Body'
/// representation, then no 'Body' representation shall defined for the
/// IfcStair. The IfcStair shape is then represented by
/// the geometric representation of its components. The components are
/// accessed via
/// SELF\IfcObject.IsDecomposedBy[1].RelatedObjects.
/// 
/// Figure 128 illustrates stair placement, where the IfcStair defines the local placement for all components and the common 'Axis' representation, and each component has its own 'Body' representation.
/// 
/// Figure 128 — Stair placement
class IFC_PARSE_API IfcStair : public IfcBuildingElement {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcStair
    bool hasPredefinedType() const;
    /// Predefined shape types for a stair that are specified in an enumeration.
    /// 
    /// IFC2x4 CHANGE  The attribute has been renamed from ShapeType and changed to be OPTIONAL with upward compatibility for file based exchange.
    IfcStairTypeEnum::IfcStairTypeEnum PredefinedType() const;
    void setPredefinedType(IfcStairTypeEnum::IfcStairTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcBuildingElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcStairTypeEnum; } return IfcBuildingElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "PredefinedType"; } return IfcBuildingElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcStair (IfcEntityInstanceData* e);
    IfcStair (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcStairTypeEnum::IfcStairTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcStair > list;
};
/// A stair flight is an assembly of
/// building components in a single "run" of stair steps (not
/// interrupted by a landing). The stair steps and any stringers are
/// included in the stair flight. A winder is also regarded a part of
/// a stair flight.
/// An IfcStairFlight is normally aggregated by an
/// IfcStair through the IfcRelAggregates relationship,
/// the stair flight is then included in the set of
/// IfcRelAggregates.RelatedObjects. An IfcStairFlight
/// normally connects the floor slab of zero to two different storeys
/// (or partial storeys, or landings) within a building. The
/// connection relationship between the IfcStairFlight and the
/// IfcSlab is expressed using the
/// IfcRelConnectsElements relationship.
/// 
/// HISTORY: New Entity in IFC Release 2.0.
/// 
/// Type Use Definition
/// IfcStairFlight defines the occurrence of any stair
/// flight, common information about stair flight types (or styles)
/// is handled by IfcStairFlightType. The
/// IfcStairFlightType (if present) may establish the
/// commonÿtype name, usage (or predefined) type, common material
/// layer set, common set of properties and common shape
/// representations (using IfcRepresentationMap). The
/// IfcStairFlightType is attached using the
/// IfcRelDefinedByType.RelatingType objectified relationship
/// and is accessible by the inverse IsDefinedBy
/// attribute.
/// Material Use Definition
/// The material of the IfcStairFlight is defined by the
/// IfcMaterial and attached by the
/// IfcRelAssociatesMaterial.RelatingMaterial. It is
/// accessible by the inverse HasAssociations
/// relationship.
/// Property Set Use Definition:
/// The property sets relating to the IfcStairFlight are
/// defined by the IfcPropertySet and attached by the
/// IfcRelDefinesByProperties relationship. It is accessible
/// by the inverse IsDefinedBy relationship. The following
/// property set definitions specific to the IfcStairFlight
/// are part of this IFC release:
/// 
/// Pset_StairFlightCommon: common property set
/// for all stair flight occurrences
/// 
/// Quantity Use Definition
/// The quantities relating to the IfcStairFlight are
/// defined by the IfcElementQuantity and attached by the
/// IfcRelDefinesByProperties relationship. It is accessible
/// by the inverse IsDefinedBy relationship. The following
/// base quantities are defined and should be exchanged with the
/// IfcElementQuantity.Name = 'BaseQuantities'. Other
/// quantities can be defined being subjected to local standard of
/// measurement with another string value assigned to Name and
/// a value provided for MethodOfMeasurement. Quantities shall
/// never be assigned to the IfcStairFlightType.
/// 
/// Qto_StairFlightBaseQuantities: base
/// quantities for all stair flight occurrences.
/// 
/// Containment Use Definition
/// The IfcStairFlight, as any subtype of
/// IfcBuildingElement, may participate in two different
/// containment relationships. The first relationship is the
/// hierachical spatial containment, the second relationship is the
/// aggregation within anÿelement assembly.
/// 
/// The IfcStairFlight is placed within the project
/// spatial hierarchy using the objectified relationship
/// IfcRelContainedInSpatialStructure, refering to it by its
/// inverse attribute SELF\IfcElement.ContainedInStructure.
/// Subtypes ofÿIfcSpatialStructureElement are valid spatial
/// containers, with IfcBuildingStorey being the default
/// container.
/// The IfcStairFlight may be aggregated into an element
/// assembly using the objectified relationship
/// IfcRelAggregates, refering to it by its inverse attribute
/// SELF\IfcObjectDefinition.Decomposes. Any subtype of
/// IfcElement can be an element assembly, with
/// IfcStair as a special focus subtype. In this case it
/// shall not be additionally contained in the project spatial
/// hierarchy, i.e.ÿSELF\IfcElement.ContainedInStructure
/// shall be NIL.
/// 
/// Geometry Use Definition
/// The geometric representation of IfcStairFlight is given
/// by the IfcProductDefinitionShape, allowing multiple
/// geometric representation. Included are:
/// Local placement
/// The local placement for IfcStairFlight is defined in
/// its supertype IfcProduct. It is defined by the
/// IfcLocalPlacement, which defines the local coordinate
/// system that is referenced by all geometric representations.
/// 
/// The PlacementRelTo relationship of
/// IfcLocalPlacement shall point (if given) to the local
/// placement of the same IfcSpatialStructureElement that is
/// used in the ContainedInStructure inverse attribute or to a
/// referenced spatial structure element at a higher level.
/// If the IfcStairFlight, however, is used by an
/// IfcStair, and this container class defines its own local
/// placement, then the PlacementRelTo relationship of
/// IfcLocalPlacement shall point to the local placement of
/// the IfcStair.
/// 
/// Geometric Representations
/// Currently, the 'Axis', 'FootPrint', 'Body', and 'Box'
/// representations are supported. The 'Box' representation includes
/// the representation type 'BoundingBox' and is explained at
/// IfcBuildingElement.
/// 
/// Axis: A two-dimensional open curve
/// IfcBoundedCurve defining the walking line for the stair
/// flight.
/// FootPrint: A geometric curve set defining the footing
/// print, including the boundary of the stair flight.
/// Body: A solid representation defining the 3D shape of
/// the stair flight
/// 
/// Axis Representation
/// The walking line is represented by a two-dimensional open
/// curve as the axis. The curve is directed into the upward
/// direction (direction has to be interpreted as specified at the
/// subtypes of IfcCurve). The following attribute values for
/// the IfcShapeRepresentation holding this geometric
/// representation shall be used:
/// 
/// RepresentationIdentifier : 'Axis'
/// RepresentationType : 'Curve2D'
/// 
/// Figure 129 illustrates the axis representation which has the following constraints:
/// 
/// In case of straight flights the curve shall be a single item of type IfcPolyline.
/// In case of winding flights the curve shall be a single item of type IfcCompositeCurve.
/// In case of a curved flight or a spiral flight the curve shall be a single item of type IfcTrimmedCurve.
/// 
/// Figure 129 — Stair flight axis
/// 
/// FootPrint Representation
/// The flight foot print, including the flight boundary is
/// represented by a two-dimensional geometric curve set. The
/// following attribute values for the IfcShapeRepresentation
/// holding this geometric representation shall be used:
/// 
/// RepresentationIdentifier : 'FootPrint'
/// RepresentationType : 'GeometricCurveSet'
/// 
/// Figure 130 illustrates the footprint representation which has the following constraints:
/// 
/// In case of straight flights the curve set shall consists of a single item of type IfcPolyline.
/// In case of winding flights or curved flights the curve set shall consists of a single item of type IfcCompositeCurve.
/// In case of a spiral flight the curve set shall consists of a single item of type IfcConic or IfcPolyline.
/// 
/// Figure 130 — Stair flight footprint
/// 
/// Body Representation
/// The body representation of IfcStairFlight can be represented using the representation types 'SweptSolid', 'SurfaceModel', 'Brep', and 'MappedRepresentation'. The general usage of representation is are explained at
/// IfcBuildingElement. No further constraints or provisions on how to use the representation types are defined for
/// IfcStairFlight.
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'SweptSolid', 'SurfaceModel', 'Brep', 'MappedRepresentation'
/// 
/// Figure 131 illustrates the body representation.
/// 
/// Figure 131 — Stair flight body
class IFC_PARSE_API IfcStairFlight : public IfcBuildingElement {
public:
    /// Whether the optional attribute NumberOfRisers is defined for this IfcStairFlight
    bool hasNumberOfRisers() const;
    int NumberOfRisers() const;
    void setNumberOfRisers(int v);
    /// Whether the optional attribute NumberOfTreads is defined for this IfcStairFlight
    bool hasNumberOfTreads() const;
    /// Number of treads included in the stair flight.
    /// 
    /// IFC2x4 CHANGE  The attribute has been deprecated it shall only be exposed with a NIL value. Use Pset_StairFlightCommon.NumberOfTreads instead.
    int NumberOfTreads() const;
    void setNumberOfTreads(int v);
    /// Whether the optional attribute RiserHeight is defined for this IfcStairFlight
    bool hasRiserHeight() const;
    /// Vertical distance from tread to tread. The riser height is supposed to be equal for all stairs in a stair flight.
    /// 
    /// IFC2x4 CHANGE  The attribute has been deprecated it shall only be exposed with a NIL value. Use Pset_StairFlightCommon.RiserHeight instead.
    double RiserHeight() const;
    void setRiserHeight(double v);
    /// Whether the optional attribute TreadLength is defined for this IfcStairFlight
    bool hasTreadLength() const;
    /// Horizontal distance from the front to the back of the tread. The tread length is supposed to be equal for all steps of the stair flight.
    /// 
    /// IFC2x4 CHANGE  The attribute has been deprecated it shall only be exposed with a NIL value. Use Pset_StairFlightCommon.TreadLength instead.
    double TreadLength() const;
    void setTreadLength(double v);
    /// Whether the optional attribute PredefinedType is defined for this IfcStairFlight
    bool hasPredefinedType() const;
    /// Predefined generic type for a stair flight that is specified in an enumeration. There may be a property set given specificly for the predefined types.
    ///   NOTE The PredefinedType shall only be used, if no type object IfcStairFlightType is assigned, providing its own IfcStairFlightType.PredefinedType.
    /// 
    /// IFC2x4 CHANGE  The attribute has been added at the end of the entity definition.
    IfcStairFlightTypeEnum::IfcStairFlightTypeEnum PredefinedType() const;
    void setPredefinedType(IfcStairFlightTypeEnum::IfcStairFlightTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 13; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_INT; case 9: return IfcUtil::Argument_INT; case 10: return IfcUtil::Argument_DOUBLE; case 11: return IfcUtil::Argument_DOUBLE; case 12: return IfcUtil::Argument_ENUMERATION; } return IfcBuildingElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcInteger; case 9: return Type::IfcInteger; case 10: return Type::IfcPositiveLengthMeasure; case 11: return Type::IfcPositiveLengthMeasure; case 12: return Type::IfcStairFlightTypeEnum; } return IfcBuildingElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "NumberOfRisers"; case 9: return "NumberOfTreads"; case 10: return "RiserHeight"; case 11: return "TreadLength"; case 12: return "PredefinedType"; } return IfcBuildingElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcStairFlight (IfcEntityInstanceData* e);
    IfcStairFlight (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< int > v9_NumberOfRisers, boost::optional< int > v10_NumberOfTreads, boost::optional< double > v11_RiserHeight, boost::optional< double > v12_TreadLength, boost::optional< IfcStairFlightTypeEnum::IfcStairFlightTypeEnum > v13_PredefinedType);
    typedef IfcTemplatedEntityList< IfcStairFlight > list;
};
/// Definition from IAI: The IfcStructuralAnalysisModel is used to assemble all information needed to represent a structural analysis model.  It encompasses certain general properties (such as analysis type), references to all contained structural members, structural supports or connections, as well as loads and the respective load results.
/// 
/// Important functionalities for the description of an analysis model are derived from existing IFC entities:
/// 
/// From IfcSystem it inherits the ability to couple the analysis model via IfcRelServicesBuildings to one or more IfcBuildings as necessary.
///   From IfcGroup it inherits the inverse attribute IsGroupedBy, pointing to the relationship class IfcRelAssignsToGroup.  This allows to group structural members (instances of IfcStructuralMember), and supports (instances of IfcStructuralConnection) which belong to a specific analysis model.
///   NOTE:  Loads (as instances of IfcStructuralAction) are not included through IsGroupedBy.  Loads are assigned through the LoadedBy attribute relationship, using load groups as a grouping mechanism.  Only top-level load groups should be referenced via LoadedBy, i.e. load combinations if any load combinations exist, or load cases if no load combinations exist in this analysis model.
///   NOTE:  Results (as instances of IfcStructuralReaction) are not included through IsGroupedBy.  Results are assigned through the HasResults attribute relationship, using result groups as a grouping mechanism.
/// 
/// From IfcObject it inherits the inverse attribute IsDecomposedBy pointing to the relationship class IfcRelNests. It provides the hierarchy between the separate (partial) analysis models.
/// 
/// HISTORY: New entity in IFC 2x2.
/// 
/// IFC 2x4 change:  Attribute SharedPlacement and informal propositions added, allowing for easy retrieval of the common object placement and for specification of the analysis model's coordiante system before any structural item is instantiated.  WHERE rule added.
/// 
/// Informal propositions:
/// 
/// If one or more structural item (instance of a subtype of IfcStructuralItem) is grouped into an IfcStructuralAnalysisModel, the attribute SharedPlacement shall be provided with a value.
///   The ObjectPlacements of all structural items which are grouped into the same instance of IfcStructuralAnalysisModel shall refer to the same instance of IfcObjectPlacement as IfcStructuralAnalysisModel.SharedPlacement.
/// 
/// NOTE  This rule is necessary to achieve consistent topology representations.  The topology representations of structural items in an analysis model are meant to share vertices and edges und must therefore have the same object placement.
/// 
/// NOTE  A structural item may be grouped into more than one analysis model.  In this case, all these models must use the same instance of IfcObjectPlacement.
class IFC_PARSE_API IfcStructuralAnalysisModel : public IfcSystem {
public:
    /// Defines the type of the structural analysis model.
    IfcAnalysisModelTypeEnum::IfcAnalysisModelTypeEnum PredefinedType() const;
    void setPredefinedType(IfcAnalysisModelTypeEnum::IfcAnalysisModelTypeEnum v);
    /// Whether the optional attribute OrientationOf2DPlane is defined for this IfcStructuralAnalysisModel
    bool hasOrientationOf2DPlane() const;
    /// If the selected model type (PredefinedType) describes a 2D system, the orientation defines
    /// the analysis plane (P[1], P[2]) and the normal to the analysis plane (P[3]).  This is needed because
    /// structural items and activities are always defined in three-dimensional space even if they are
    /// meant to be analysed in a two-dimensional manner.
    /// 
    /// In case of predefined type IN_PLANE_LOADING_2D, the analysis is to be performed within the
    /// projection into the P[1], P[2] plane.
    /// In case of predefined type OUT_PLANE_LOADING_2D, only the P[3] component of loads and their
    /// effects is meant to be analyzed.  This is used for beam grids and for typical slab analyses.
    /// In case of predefined type LOADING_3D, OrientationOf2DPlane shall be omitted.
    IfcAxis2Placement3D* OrientationOf2DPlane() const;
    void setOrientationOf2DPlane(IfcAxis2Placement3D* v);
    /// Whether the optional attribute LoadedBy is defined for this IfcStructuralAnalysisModel
    bool hasLoadedBy() const;
    /// References to all load groups to be analyzed.
    IfcTemplatedEntityList< IfcStructuralLoadGroup >::ptr LoadedBy() const;
    void setLoadedBy(IfcTemplatedEntityList< IfcStructuralLoadGroup >::ptr v);
    /// Whether the optional attribute HasResults is defined for this IfcStructuralAnalysisModel
    bool hasHasResults() const;
    /// References to all result groups available for this structural analysis model.
    IfcTemplatedEntityList< IfcStructuralResultGroup >::ptr HasResults() const;
    void setHasResults(IfcTemplatedEntityList< IfcStructuralResultGroup >::ptr v);
    /// Whether the optional attribute SharedPlacement is defined for this IfcStructuralAnalysisModel
    bool hasSharedPlacement() const;
    /// Object placement which shall be common to all items and activities which are grouped into this instance of IfcStructuralAnalysisModel.  This placement establishes a coordinate system which is referred to as 'global coordinate system' in use definitions of various classes of structural items and activities.
    /// 
    /// NOTE  Most commonly, but not necessarily, the SharedPlacement is an IfcLocalPlacement whose z axis is parallel with the z axis of the IfcProject's world coordinate system and directed like the WCS z axis (i.e. pointing "upwards") or directed against the WCS z axis (i.e. points "downwards").
    /// 
    /// NOTE  Per informal proposition, this attribute is not optional as soon as at least one IfcStructuralItem is grouped into the instance of IfcStructuralAnalysisModel.
    IfcObjectPlacement* SharedPlacement() const;
    void setSharedPlacement(IfcObjectPlacement* v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 5: return IfcUtil::Argument_ENUMERATION; case 6: return IfcUtil::Argument_ENTITY_INSTANCE; case 7: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 8: return IfcUtil::Argument_AGGREGATE_OF_ENTITY_INSTANCE; case 9: return IfcUtil::Argument_ENTITY_INSTANCE; } return IfcSystem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 5: return Type::IfcAnalysisModelTypeEnum; case 6: return Type::IfcAxis2Placement3D; case 7: return Type::IfcStructuralLoadGroup; case 8: return Type::IfcStructuralResultGroup; case 9: return Type::IfcObjectPlacement; } return IfcSystem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 5: return "PredefinedType"; case 6: return "OrientationOf2DPlane"; case 7: return "LoadedBy"; case 8: return "HasResults"; case 9: return "SharedPlacement"; } return IfcSystem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcStructuralAnalysisModel (IfcEntityInstanceData* e);
    IfcStructuralAnalysisModel (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcAnalysisModelTypeEnum::IfcAnalysisModelTypeEnum v6_PredefinedType, IfcAxis2Placement3D* v7_OrientationOf2DPlane, boost::optional< IfcTemplatedEntityList< IfcStructuralLoadGroup >::ptr > v8_LoadedBy, boost::optional< IfcTemplatedEntityList< IfcStructuralResultGroup >::ptr > v9_HasResults, IfcObjectPlacement* v10_SharedPlacement);
    typedef IfcTemplatedEntityList< IfcStructuralAnalysisModel > list;
};
/// Definition from IAI: A load case is a load group, commonly used to group loads from the same action source.
/// 
/// HISTORY: New entity in IFC 2x4.
class IFC_PARSE_API IfcStructuralLoadCase : public IfcStructuralLoadGroup {
public:
    /// Whether the optional attribute SelfWeightCoefficients is defined for this IfcStructuralLoadCase
    bool hasSelfWeightCoefficients() const;
    /// The self weight coefficients specify ratios at which loads due to weight of members shall be included in the load case.  These loads are not explicitly modeled as instances of IfcStructuralAction.  Instead they shall be calculated according to geometry, section, and material of each member.
    /// 
    /// The three components of the self weight vector correspond with the x,y,z directions of the so-called global coordinates, i.e. the directions of the shared ObjectPlacement of all items in an IfcStructuralAnalysisModel.  For example, if the object placement defines a z axis which is upright like the IfcProject's world coordinate system, then the self weight coefficients would typically be [0.,0.,-1.] in a load case of dead loads with self weight.
    /// 
    /// The overall coefficient in the inherited attribute Coefficient shall not be applied to SelfWeightCoefficients of the same instance of IfcStructuralLoadCase.  It only applies to actions and load groups which are grouped below the load case, not to the load case's computed self weight.
    std::vector< double > /*[3:3]*/ SelfWeightCoefficients() const;
    void setSelfWeightCoefficients(std::vector< double > /*[3:3]*/ v);
    virtual unsigned int getArgumentCount() const { return 11; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 10: return IfcUtil::Argument_AGGREGATE_OF_DOUBLE; } return IfcStructuralLoadGroup::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 10: return Type::IfcRatioMeasure; } return IfcStructuralLoadGroup::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 10: return "SelfWeightCoefficients"; } return IfcStructuralLoadGroup::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcStructuralLoadCase (IfcEntityInstanceData* e);
    IfcStructuralLoadCase (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcLoadGroupTypeEnum::IfcLoadGroupTypeEnum v6_PredefinedType, IfcActionTypeEnum::IfcActionTypeEnum v7_ActionType, IfcActionSourceTypeEnum::IfcActionSourceTypeEnum v8_ActionSource, boost::optional< double > v9_Coefficient, boost::optional< std::string > v10_Purpose, boost::optional< std::vector< double > /*[3:3]*/ > v11_SelfWeightCoefficients);
    typedef IfcTemplatedEntityList< IfcStructuralLoadCase > list;
};
/// Definition from IAI: Defines an action with constant value which is distributed over a surface.
/// 
/// HISTORY: New entity in IFC 2x2.
/// 
/// IFC 2x4 change:  Intermediate supertype IfcStructuralSurfaceAction inserted.  Derived attribute PredefinedType added.
/// 
/// NOTE  Like its supertype IfcStructuralSurfaceAction, this action type may also act on curved faces.
class IFC_PARSE_API IfcStructuralPlanarAction : public IfcStructuralSurfaceAction {
public:
    virtual unsigned int getArgumentCount() const { return 12; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcStructuralSurfaceAction::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcStructuralSurfaceAction::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcStructuralSurfaceAction::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcStructuralPlanarAction (IfcEntityInstanceData* e);
    IfcStructuralPlanarAction (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, IfcStructuralLoad* v8_AppliedLoad, IfcGlobalOrLocalEnum::IfcGlobalOrLocalEnum v9_GlobalOrLocal, boost::optional< bool > v10_DestabilizingLoad, boost::optional< IfcProjectedOrTrueLengthEnum::IfcProjectedOrTrueLengthEnum > v11_ProjectedOrTrue, IfcStructuralSurfaceActivityTypeEnum::IfcStructuralSurfaceActivityTypeEnum v12_PredefinedType);
    typedef IfcTemplatedEntityList< IfcStructuralPlanarAction > list;
};
/// A switch is used in a cable distribution system (electrical circuit) to control or modulate the flow of electricity.
/// Switches include those used for electrical power, communications, audio-visual, or other distribution system types as determined by the available ports. 
/// 
/// HISTORY  New entity in IFC2x4
/// 
/// Type Use Definition
/// IfcSwitchingDevice defines the occurrence of any switching device; common information about switching device types is handled by IfcSwitchingDeviceType. 
/// The IfcSwitchingDeviceType (if present) may establish the common type name, usage (predefined type), properties, materials, ports, composition, assignments, and representations. 
/// The IfcSwitchingDeviceType is attached using the IfcRelDefinesByType objectified relationship and is accessible by the IsTypedBy inverse attribute. 
/// If the IfcSwitchingDeviceType has ports or aggregated elements, such objects are reflected at the IfcSwitchingDevice occurrence using the IfcRelDefinesByObject relationship.
/// Figure 208 illustrates switching device type use.
/// Figure 208 — Switching device type use
/// 
/// Property Use Definition
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute. 
/// Property sets may also be specified at the IfcSwitchingDeviceType, defining the common property data for all occurrences of the same type. 
/// They are then accessible by the IsTypedBy inverse attribute pointing to IfcSwitchingDeviceType.HasPropertySets. 
/// If both are given, then the properties directly defined at IfcSwitchingDevice override the properties defined at IfcSwitchingDeviceType. 
/// Refer to the documentation at the supertype IfcFlowController and ancestors for inherited property set definitions.
/// The following property set definitions are applicable to this entity:
/// (All Types)
/// 
/// Pset_SwitchingDeviceTypeCommon (PSET_TYPEDRIVENOVERRIDE)
/// Pset_SwitchingDeviceTypePHistory (PSET_PERFORMANCEDRIVEN)
/// 
/// CONTACTOR
/// 
/// Pset_SwitchingDeviceTypeContactor (PSET_TYPEDRIVENOVERRIDE)
/// 
/// DIMMERSWITCH
/// 
/// Pset_SwitchingDeviceTypeDimmerSwitch (PSET_TYPEDRIVENOVERRIDE)
/// 
/// EMERGENCYSTOP
/// 
/// Pset_SwitchingDeviceTypeEmergencyStop (PSET_TYPEDRIVENOVERRIDE)
/// 
/// KEYPAD
/// 
/// Pset_SwitchingDeviceTypeKeypad (PSET_TYPEDRIVENOVERRIDE)
/// 
/// MOMENTARYSWITCH
/// 
/// Pset_SwitchingDeviceTypeMomentarySwitch (PSET_TYPEDRIVENOVERRIDE)
/// 
/// SELECTORSWITCH
/// 
/// Pset_SwitchingDeviceTypeSelectorSwitch (PSET_TYPEDRIVENOVERRIDE)
/// 
/// STARTER
/// 
/// Pset_SwitchingDeviceTypeStarter (PSET_TYPEDRIVENOVERRIDE)
/// 
/// SWITCHDISCONNECTOR
/// 
/// Pset_SwitchingDeviceTypeSwitchDisconnector (PSET_TYPEDRIVENOVERRIDE)
/// 
/// TOGGLESWITCH
/// 
/// Pset_SwitchingDeviceTypeToggleSwitch (PSET_TYPEDRIVENOVERRIDE)
/// 
/// Quantity Use Definition
/// The quantities relating to this entity are defined by IfcElementQuantity and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute.
/// The following base quantities are defined and shall be exchanged with the IfcElementQuantity.Name = 'BaseQuantities'. 
/// Other quantities, being subjected to local standard of measurement, may be defined with another string value assigned to Name. 
/// In this case a valid value for MethodOfMeasurement shall be provided. 
/// 
/// Qto_SwitchingDeviceBaseQuantities
/// 
/// Material Use Definition
/// The material of the IfcSwitchingDevice is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship. It is accessible by the HasAssociations inverse attribute. Material information can also be given at the IfcSwitchingDeviceType, defining the common attribute data for all occurrences of the same type. The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used:
/// 
/// Casing: Material from which the casing is constructed.
/// Conductor: Material from which the conductors are constructed.
/// Surface: Material from which the switch surface is constructed.
/// 
/// Port Use Definition
/// The distribution ports relating to the IfcSwitchingDevice are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship. 
///   If the switching device occurrence is defined by IfcSwitchingDeviceType, then the port occurrences must reflect those defined at the IfcSwitchingDeviceType using the IfcRelDefinesByObject relationship.
///   Ports are specific to the IfcSwitchingDevice PredefinedType as follows indicated by the IfcDistributionPort Name, PredefinedType, and FlowDirection:
/// 
/// Line (ELECTRICAL, SINK): The supply line.
/// Load (ELECTRICAL, SOURCE): The load controlled by the switch.
/// 
/// Figure 209 illustrates switching device port use.
/// Figure 209 — Switching device port use
class IFC_PARSE_API IfcSwitchingDevice : public IfcFlowController {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcSwitchingDevice
    bool hasPredefinedType() const;
    IfcSwitchingDeviceTypeEnum::IfcSwitchingDeviceTypeEnum PredefinedType() const;
    void setPredefinedType(IfcSwitchingDeviceTypeEnum::IfcSwitchingDeviceTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcFlowController::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcSwitchingDeviceTypeEnum; } return IfcFlowController::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "PredefinedType"; } return IfcFlowController::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcSwitchingDevice (IfcEntityInstanceData* e);
    IfcSwitchingDevice (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcSwitchingDeviceTypeEnum::IfcSwitchingDeviceTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcSwitchingDevice > list;
};
/// A tank is a vessel or container in which a fluid or gas is stored for later use. 
/// 
/// HISTORY  New entity in IFC2x4
/// 
/// Type Use Definition
/// IfcTank defines the occurrence of any tank; common information about tank types is handled by IfcTankType. 
/// The IfcTankType (if present) may establish the common type name, usage (predefined type), properties, materials, ports, composition, assignments, and representations. 
/// The IfcTankType is attached using the IfcRelDefinesByType objectified relationship and is accessible by the IsTypedBy inverse attribute. 
/// If the IfcTankType has ports or aggregated elements, such objects are reflected at the IfcTank occurrence using the IfcRelDefinesByObject relationship.
/// 
/// Property Use Definition
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute. 
/// Property sets may also be specified at the IfcTankType, defining the common property data for all occurrences of the same type. 
/// They are then accessible by the IsTypedBy inverse attribute pointing to IfcTankType.HasPropertySets. 
/// If both are given, then the properties directly defined at IfcTank override the properties defined at IfcTankType. 
/// Refer to the documentation at the supertype IfcFlowStorageDevice and ancestors for inherited property set definitions.
/// The following property set definitions are applicable to this entity:
/// (All Types)
/// 
/// Pset_TankOccurrence (PSET_OCCURRENCEDRIVEN)
/// Pset_TankTypeCommon (PSET_TYPEDRIVENOVERRIDE)
/// 
/// EXPANSION
/// 
/// Pset_TankTypeExpansion (PSET_TYPEDRIVENOVERRIDE)
/// 
/// PREFORMED
/// 
/// Pset_TankTypePreformed (PSET_TYPEDRIVENOVERRIDE)
/// 
/// PRESSUREVESSEL
/// 
/// Pset_TankTypePressureVessel (PSET_TYPEDRIVENOVERRIDE)
/// 
/// SECTIONAL
/// 
/// Pset_TankTypeSectional (PSET_TYPEDRIVENOVERRIDE)
/// 
/// Quantity Use Definition
/// The quantities relating to this entity are defined by IfcElementQuantity and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute.
/// The following base quantities are defined and shall be exchanged with the IfcElementQuantity.Name = 'BaseQuantities'. 
/// Other quantities, being subjected to local standard of measurement, may be defined with another string value assigned to Name. 
/// In this case a valid value for MethodOfMeasurement shall be provided. 
/// 
/// Qto_TankBaseQuantities
/// 
/// Material Use Definition
/// The material of the IfcTank is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship. It is accessible by the HasAssociations inverse attribute. Material information can also be given at the IfcTankType, defining the common attribute data for all occurrences of the same type. The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used:
/// 
/// Body: The primary material from which the object is constructed.
/// 
/// Port Use Definition
/// The distribution ports relating to the IfcTank are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship. 
///   If the tank occurrence is defined by IfcTankType, then the port occurrences must reflect those defined at the IfcTankType using the IfcRelDefinesByObject relationship.
///   Ports are specific to the IfcTank PredefinedType as follows indicated by the IfcDistributionPort Name, PredefinedType, and FlowDirection:
/// 
/// Inlet (NOTDEFINED, SINK): Inlet.
/// Outlet (NOTDEFINED, SOURCE): Outlet.
class IFC_PARSE_API IfcTank : public IfcFlowStorageDevice {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcTank
    bool hasPredefinedType() const;
    IfcTankTypeEnum::IfcTankTypeEnum PredefinedType() const;
    void setPredefinedType(IfcTankTypeEnum::IfcTankTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcFlowStorageDevice::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcTankTypeEnum; } return IfcFlowStorageDevice::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "PredefinedType"; } return IfcFlowStorageDevice::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcTank (IfcEntityInstanceData* e);
    IfcTank (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcTankTypeEnum::IfcTankTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcTank > list;
};
/// A transformer is an inductive stationary device that transfers electrical energy from one circuit to another.
/// IfcTransformer is used to transform electric power; conversion of electric signals for other purposes is handled at other entities: IfcController converts arbitrary signals, IfcAudioVisualAppliance converts signals for audio or video streams, and IfcCommunicationsAppliance converts signals for data or other communications usage. 
/// 
/// HISTORY  New entity in IFC2x4
/// 
/// Type Use Definition
/// IfcTransformer defines the occurrence of any transformer; common information about transformer types is handled by IfcTransformerType. 
/// The IfcTransformerType (if present) may establish the common type name, usage (predefined type), properties, materials, ports, composition, assignments, and representations. 
/// The IfcTransformerType is attached using the IfcRelDefinesByType objectified relationship and is accessible by the IsTypedBy inverse attribute. 
/// If the IfcTransformerType has ports or aggregated elements, such objects are reflected at the IfcTransformer occurrence using the IfcRelDefinesByObject relationship.
/// 
/// Property Use Definition
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute. 
/// Property sets may also be specified at the IfcTransformerType, defining the common property data for all occurrences of the same type. 
/// They are then accessible by the IsTypedBy inverse attribute pointing to IfcTransformerType.HasPropertySets. 
/// If both are given, then the properties directly defined at IfcTransformer override the properties defined at IfcTransformerType. 
/// Refer to the documentation at the supertype IfcEnergyConversionDevice and ancestors for inherited property set definitions.
/// The following property set definitions are applicable to this entity:
/// Pset_TransformerTypeCommon (PSET_TYPEDRIVENOVERRIDE)
/// 
/// Quantity Use Definition
/// The quantities relating to this entity are defined by IfcElementQuantity and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute.
/// The following base quantities are defined and shall be exchanged with the IfcElementQuantity.Name = 'BaseQuantities'. 
/// Other quantities, being subjected to local standard of measurement, may be defined with another string value assigned to Name. 
/// In this case a valid value for MethodOfMeasurement shall be provided. 
/// 
/// Qto_TransformerBaseQuantities
/// 
/// Material Use Definition
/// The material of the IfcTransformer is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship. It is accessible by the HasAssociations inverse attribute. Material information can also be given at the IfcTransformerType, defining the common attribute data for all occurrences of the same type. The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used:
/// 
/// Casing: Material from which the casing is constructed.
/// 
/// Port Use Definition
/// The distribution ports relating to the IfcTransformer are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship. 
///   If the transformer occurrence is defined by IfcTransformerType, then the port occurrences must reflect those defined at the IfcTransformerType using the IfcRelDefinesByObject relationship.
///   Ports are specific to the IfcTransformer PredefinedType as follows indicated by the IfcDistributionPort Name, PredefinedType, and FlowDirection:
/// 
/// Line (ELECTRICAL, SINK): Line to be transformed.
/// Load (ELECTRICAL, SOURCE): Transformed load.
class IFC_PARSE_API IfcTransformer : public IfcEnergyConversionDevice {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcTransformer
    bool hasPredefinedType() const;
    IfcTransformerTypeEnum::IfcTransformerTypeEnum PredefinedType() const;
    void setPredefinedType(IfcTransformerTypeEnum::IfcTransformerTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcEnergyConversionDevice::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcTransformerTypeEnum; } return IfcEnergyConversionDevice::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "PredefinedType"; } return IfcEnergyConversionDevice::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcTransformer (IfcEntityInstanceData* e);
    IfcTransformer (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcTransformerTypeEnum::IfcTransformerTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcTransformer > list;
};
/// A tube bundle is a device consisting of tubes and bundles of tubes used for heat transfer and contained typically within other energy conversion devices, such as a chiller or coil. 
/// 
/// HISTORY  New entity in IFC2x4
/// 
/// Type Use Definition
/// IfcTubeBundle defines the occurrence of any tube bundle; common information about tube bundle types is handled by IfcTubeBundleType. 
/// The IfcTubeBundleType (if present) may establish the common type name, usage (predefined type), properties, materials, ports, composition, assignments, and representations. 
/// The IfcTubeBundleType is attached using the IfcRelDefinesByType objectified relationship and is accessible by the IsTypedBy inverse attribute. 
/// If the IfcTubeBundleType has ports or aggregated elements, such objects are reflected at the IfcTubeBundle occurrence using the IfcRelDefinesByObject relationship.
/// 
/// Property Use Definition
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute. 
/// Property sets may also be specified at the IfcTubeBundleType, defining the common property data for all occurrences of the same type. 
/// They are then accessible by the IsTypedBy inverse attribute pointing to IfcTubeBundleType.HasPropertySets. 
/// If both are given, then the properties directly defined at IfcTubeBundle override the properties defined at IfcTubeBundleType. 
/// Refer to the documentation at the supertype IfcEnergyConversionDevice and ancestors for inherited property set definitions.
/// The following property set definitions are applicable to this entity:
/// (All Types)
/// 
/// Pset_TubeBundleTypeCommon (PSET_TYPEDRIVENOVERRIDE)
/// 
/// FINNED
/// 
/// Pset_TubeBundleTypeFinned (PSET_TYPEDRIVENOVERRIDE)
/// 
/// Quantity Use Definition
/// The quantities relating to this entity are defined by IfcElementQuantity and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute.
/// The following base quantities are defined and shall be exchanged with the IfcElementQuantity.Name = 'BaseQuantities'. 
/// Other quantities, being subjected to local standard of measurement, may be defined with another string value assigned to Name. 
/// In this case a valid value for MethodOfMeasurement shall be provided. 
/// 
/// Qto_TubeBundleBaseQuantities
/// 
/// Material Use Definition
/// The material of the IfcTubeBundle is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship. It is accessible by the HasAssociations inverse attribute. Material information can also be given at the IfcTubeBundleType, defining the common attribute data for all occurrences of the same type. The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used:
/// 
/// Body: The primary material from which the object is constructed.
/// 
/// Port Use Definition
/// The distribution ports relating to the IfcTubeBundle are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship. 
///   If the tube bundle occurrence is defined by IfcTubeBundleType, then the port occurrences must reflect those defined at the IfcTubeBundleType using the IfcRelDefinesByObject relationship.
///   Ports are specific to the IfcTubeBundle PredefinedType as follows indicated by the IfcDistributionPort Name, PredefinedType, and FlowDirection:
/// 
/// Inlet (NOTDEFINED, SINK): Inlet.
/// Outlet (NOTDEFINED, SOURCE): Outlet.
class IFC_PARSE_API IfcTubeBundle : public IfcEnergyConversionDevice {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcTubeBundle
    bool hasPredefinedType() const;
    IfcTubeBundleTypeEnum::IfcTubeBundleTypeEnum PredefinedType() const;
    void setPredefinedType(IfcTubeBundleTypeEnum::IfcTubeBundleTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcEnergyConversionDevice::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcTubeBundleTypeEnum; } return IfcEnergyConversionDevice::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "PredefinedType"; } return IfcEnergyConversionDevice::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcTubeBundle (IfcEntityInstanceData* e);
    IfcTubeBundle (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcTubeBundleTypeEnum::IfcTubeBundleTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcTubeBundle > list;
};
/// The distribution control element type IfcUnitaryControlElementType defines commonly shared information for occurrences of unitary control elements.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a unitary control element specification (i.e. the specific product information, that is common to all occurrences of that product type).  Unitary Control Element types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcUnitaryControlElementType are represented by instances of IfcUnitaryControlElement. 
/// 
/// HISTORY: New entity in IFC2x4 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcDistributionControlElementType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_UnitaryControlElementTypeCommon 
/// 
/// Material Use Definition 
/// The material of the IfcUnitaryControlElementType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Casing': Material from which the casing is constructed. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcUnitaryControlElementType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcUnitaryControlElement for standard port definitions.
class IFC_PARSE_API IfcUnitaryControlElementType : public IfcDistributionControlElementType {
public:
    /// Identifies the predefined types of unitary control element from which the type required may be set.
    IfcUnitaryControlElementTypeEnum::IfcUnitaryControlElementTypeEnum PredefinedType() const;
    void setPredefinedType(IfcUnitaryControlElementTypeEnum::IfcUnitaryControlElementTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcDistributionControlElementType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcUnitaryControlElementTypeEnum; } return IfcDistributionControlElementType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcDistributionControlElementType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcUnitaryControlElementType (IfcEntityInstanceData* e);
    IfcUnitaryControlElementType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcUnitaryControlElementTypeEnum::IfcUnitaryControlElementTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcUnitaryControlElementType > list;
};
/// Unitary equipment typically combine a number of components into a single product, such as air handlers, pre-packaged rooftop air-conditioning units, and split systems. 
/// 
/// HISTORY  New entity in IFC2x4
/// 
/// Type Use Definition
/// IfcUnitaryEquipment defines the occurrence of any unitary equipment; common information about unitary equipment types is handled by IfcUnitaryEquipmentType. 
/// The IfcUnitaryEquipmentType (if present) may establish the common type name, usage (predefined type), properties, materials, ports, composition, assignments, and representations. 
/// The IfcUnitaryEquipmentType is attached using the IfcRelDefinesByType objectified relationship and is accessible by the IsTypedBy inverse attribute. 
/// If the IfcUnitaryEquipmentType has ports or aggregated elements, such objects are reflected at the IfcUnitaryEquipment occurrence using the IfcRelDefinesByObject relationship.
/// 
/// Property Use Definition
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute. 
/// Property sets may also be specified at the IfcUnitaryEquipmentType, defining the common property data for all occurrences of the same type. 
/// They are then accessible by the IsTypedBy inverse attribute pointing to IfcUnitaryEquipmentType.HasPropertySets. 
/// If both are given, then the properties directly defined at IfcUnitaryEquipment override the properties defined at IfcUnitaryEquipmentType. 
/// Refer to the documentation at the supertype IfcEnergyConversionDevice and ancestors for inherited property set definitions.
/// The following property set definitions are applicable to this entity:
/// (All Types)
/// 
/// Pset_UnitaryEquipmentTypeCommon (PSET_TYPEDRIVENOVERRIDE)
/// 
/// AIRCONDITIONINGUNIT
/// 
/// Pset_UnitaryEquipmentTypeAirConditioningUnit (PSET_TYPEDRIVENOVERRIDE)
/// 
/// AIRHANDLER
/// 
/// Pset_UnitaryEquipmentTypeAirHandler (PSET_TYPEDRIVENOVERRIDE)
/// 
/// Quantity Use Definition
/// The quantities relating to this entity are defined by IfcElementQuantity and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute.
/// The following base quantities are defined and shall be exchanged with the IfcElementQuantity.Name = 'BaseQuantities'. 
/// Other quantities, being subjected to local standard of measurement, may be defined with another string value assigned to Name. 
/// In this case a valid value for MethodOfMeasurement shall be provided. 
/// 
/// Qto_UnitaryEquipmentBaseQuantities
/// 
/// Material Use Definition
/// The material of the IfcUnitaryEquipment is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship. It is accessible by the HasAssociations inverse attribute. Material information can also be given at the IfcUnitaryEquipmentType, defining the common attribute data for all occurrences of the same type. The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used:
/// 
/// Body: The primary material from which the object is constructed.
/// 
/// Composition Use Definition
/// The IfcUnitaryEquipment may be aggregated into components using IfcRelAggregates where RelatingObject refers to the enclosing IfcUnitaryEquipment and RelatedObjects contains one or more components. Aggregation use is defined for the following predefined types:
/// 
/// May contain IfcDistributionElement components. Unitary equipment (air handlers in particular) may elaborate contained elements such as dampers, fans, coils, sensors, actuators, and controllers. Such breakdown provides access to component information and tracking of performance history for embedded elements.
/// 
/// Figure 231 illustrates unitary equipment composition use.
/// Figure 231 — Unitary equipment composition use
/// 
/// Port Use Definition
/// The distribution ports relating to the IfcUnitaryEquipment are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship. 
///   If the unitary equipment occurrence is defined by IfcUnitaryEquipmentType, then the port occurrences must reflect those defined at the IfcUnitaryEquipmentType using the IfcRelDefinesByObject relationship.
///   Ports are specific to the IfcUnitaryEquipment PredefinedType as follows indicated by the IfcDistributionPort Name, PredefinedType, and FlowDirection:
/// 
/// AIRHANDLER
/// 
/// ReturnAirIn (AIRCONDITIONING, SINK): Return air entering mixture or exhausted.
/// SupplyAirOut (AIRCONDITIONING, SOURCE): Chilled supply air.
/// OutsideAirIn (VENTILATION, SINK): Outside air entering mixture.
/// ExhaustAirOut (EXHAUST, SOURCE): Exhaust air leaving to outside.
/// ChilledWaterIn (CHILLEDWATER, SINK): Chilled water entering cooling coil.
/// ChilledWaterOut (CHILLEDWATER, SOURCE): Chilled water leaving cooling coil.
/// HeatingIn (HEATING, SINK): Steam entering heating coil.
/// HeatingOut (HEATING, SOURCE): Steam leaving heating coil.
/// Power (ELECTRICAL, SINK): Electrical power source.
/// Control (CONTROL, SINK): Control system communication.
/// 
/// Figure 232 illustrates unitary equipment port use.
/// Figure 232 — Unitary equipment port use
class IFC_PARSE_API IfcUnitaryEquipment : public IfcEnergyConversionDevice {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcUnitaryEquipment
    bool hasPredefinedType() const;
    IfcUnitaryEquipmentTypeEnum::IfcUnitaryEquipmentTypeEnum PredefinedType() const;
    void setPredefinedType(IfcUnitaryEquipmentTypeEnum::IfcUnitaryEquipmentTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcEnergyConversionDevice::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcUnitaryEquipmentTypeEnum; } return IfcEnergyConversionDevice::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "PredefinedType"; } return IfcEnergyConversionDevice::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcUnitaryEquipment (IfcEntityInstanceData* e);
    IfcUnitaryEquipment (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcUnitaryEquipmentTypeEnum::IfcUnitaryEquipmentTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcUnitaryEquipment > list;
};
/// A valve is used in a building services piping distribution system to control or modulate the flow of the fluid. 
/// 
/// HISTORY  New entity in IFC2x4
/// 
/// Type Use Definition
/// IfcValve defines the occurrence of any valve; common information about valve types is handled by IfcValveType. 
/// The IfcValveType (if present) may establish the common type name, usage (predefined type), properties, materials, ports, composition, assignments, and representations. 
/// The IfcValveType is attached using the IfcRelDefinesByType objectified relationship and is accessible by the IsTypedBy inverse attribute. 
/// If the IfcValveType has ports or aggregated elements, such objects are reflected at the IfcValve occurrence using the IfcRelDefinesByObject relationship.
/// 
/// Property Use Definition
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute. 
/// Property sets may also be specified at the IfcValveType, defining the common property data for all occurrences of the same type. 
/// They are then accessible by the IsTypedBy inverse attribute pointing to IfcValveType.HasPropertySets. 
/// If both are given, then the properties directly defined at IfcValve override the properties defined at IfcValveType. 
/// Refer to the documentation at the supertype IfcFlowController and ancestors for inherited property set definitions.
/// The following property set definitions are applicable to this entity:
/// (All Types)
/// 
/// Pset_ValvePHistory (PSET_PERFORMANCEDRIVEN)
/// Pset_ValveTypeCommon (PSET_TYPEDRIVENOVERRIDE)
/// 
/// AIRRELEASE
/// 
/// Pset_ValveTypeAirRelease (PSET_TYPEDRIVENOVERRIDE)
/// 
/// DRAWOFFCOCK
/// 
/// Pset_ValveTypeDrawOffCock (PSET_TYPEDRIVENOVERRIDE)
/// 
/// FAUCET
/// 
/// Pset_ValveTypeFaucet (PSET_TYPEDRIVENOVERRIDE)
/// 
/// FLUSHING
/// 
/// Pset_ValveTypeFlushing (PSET_TYPEDRIVENOVERRIDE)
/// 
/// GASTAP
/// 
/// Pset_ValveTypeGasTap (PSET_TYPEDRIVENOVERRIDE)
/// 
/// ISOLATING
/// 
/// Pset_ValveTypeIsolating (PSET_TYPEDRIVENOVERRIDE)
/// 
/// MIXING
/// 
/// Pset_ValveTypeMixing (PSET_TYPEDRIVENOVERRIDE)
/// 
/// PRESSUREREDUCING
/// 
/// Pset_ValveTypePressureReducing (PSET_TYPEDRIVENOVERRIDE)
/// 
/// PRESSURERELIEF
/// 
/// Pset_ValveTypePressureRelief (PSET_TYPEDRIVENOVERRIDE)
/// 
/// Quantity Use Definition
/// The quantities relating to this entity are defined by IfcElementQuantity and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute.
/// The following base quantities are defined and shall be exchanged with the IfcElementQuantity.Name = 'BaseQuantities'. 
/// Other quantities, being subjected to local standard of measurement, may be defined with another string value assigned to Name. 
/// In this case a valid value for MethodOfMeasurement shall be provided. 
/// 
/// Qto_ValveBaseQuantities
/// 
/// Material Use Definition
/// The material of the IfcValve is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship. It is accessible by the HasAssociations inverse attribute. Material information can also be given at the IfcValveType, defining the common attribute data for all occurrences of the same type. The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used:
/// 
/// Body: The primary material from which the object is constructed.
/// Operation: Material from which the operating mechanism (such as gate, globe, plug, needle, or clack) of the valve is constructed.
/// 
/// Connection Use Definition
/// The IfcValve may be connected to other objects as follows using the indicated relationship:
/// 
/// IfcActuator (IfcRelFlowControlElements): Indicates an actuator operating on the valve.
/// 
/// Port Use Definition
/// The distribution ports relating to the IfcValve are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship. 
///   If the valve occurrence is defined by IfcValveType, then the port occurrences must reflect those defined at the IfcValveType using the IfcRelDefinesByObject relationship.
///   Ports are specific to the IfcValve PredefinedType as follows indicated by the IfcDistributionPort Name, PredefinedType, and FlowDirection:
/// 
/// AIRRELEASE
/// 
/// Inlet (NOTDEFINED, SINK): Incoming fluid.
/// 
/// ANTIVACUUM
/// 
/// Outlet (NOTDEFINED, SOURCE): Outgoing fluid.
/// 
/// CHANGEOVER
/// 
/// Inlet (NOTDEFINED, SINK): Incoming fluid.
/// Outlet#1 (NOTDEFINED, SOURCE): Switched outgoing fluid.
/// Outlet#2 (NOTDEFINED, SOURCE): Switched outgoing fluid.
/// 
/// CHECK
/// 
/// Inlet (NOTDEFINED, SINK): Incoming fluid.
/// Outlet (NOTDEFINED, SOURCE): Outgoing fluid.
/// 
/// COMMISSIONING
/// 
/// Inlet (NOTDEFINED, SINK): Incoming fluid.
/// Outlet (NOTDEFINED, SOURCE): Outgoing fluid.
/// 
/// DIVERTING
/// 
/// Inlet (NOTDEFINED, SINK): Incoming fluid.
/// Outlet#1 (NOTDEFINED, SOURCE): Outgoing fluid.
/// Outlet#2 (NOTDEFINED, SOURCE): Outgoing fluid.
/// 
/// DOUBLECHECK
/// 
/// Inlet (NOTDEFINED, SINK): Incoming fluid.
/// Outlet (NOTDEFINED, SOURCE): Outgoing fluid.
/// 
/// DOUBLEREGULATING
/// 
/// Inlet (NOTDEFINED, SINK): Incoming fluid.
/// Outlet (NOTDEFINED, SOURCE): Outgoing fluid.
/// 
/// DRAWOFFCOCK
/// 
/// Inlet (NOTDEFINED, SINK): Incoming fluid.
/// 
/// FAUCET
/// 
/// Inlet (NOTDEFINED, SINK): Incoming fluid.
/// 
/// FLUSHING
/// 
/// Inlet (NOTDEFINED, SINK): Incoming fluid.
/// Outlet (NOTDEFINED, SOURCE): Outgoing fluid.
/// 
/// GASCOCK
/// 
/// Inlet (NOTDEFINED, SINK): Incoming fluid.
/// 
/// GASTAP
/// 
/// Inlet (NOTDEFINED, SINK): Incoming fluid.
/// 
/// ISOLATING
/// 
/// Inlet (NOTDEFINED, SINK): Incoming fluid.
/// Outlet (NOTDEFINED, SOURCE): Outgoing fluid.
/// 
/// MIXING
/// 
/// Inlet#1 (NOTDEFINED, SINK): Incoming fluid to be mixed.
/// Inlet#2 (NOTDEFINED, SINK): Incoming fluid to be mixed.
/// Outlet (NOTDEFINED, SOURCE): Outgoing fluid.
/// 
/// PRESSUREREDUCING
/// 
/// Inlet (NOTDEFINED, SINK): Incoming fluid.
/// Outlet (NOTDEFINED, SOURCE): Outgoing fluid.
/// 
/// PRESSURERELIEF
/// 
/// Inlet (NOTDEFINED, SINK): Incoming fluid.
/// 
/// REGULATING
/// 
/// Inlet (NOTDEFINED, SINK): Incoming fluid.
/// Outlet (NOTDEFINED, SOURCE): Outgoing fluid.
/// 
/// SAFETYCUTOFF
/// 
/// Inlet (NOTDEFINED, SINK): Incoming fluid.
/// Outlet (NOTDEFINED, SOURCE): Outgoing fluid.
/// 
/// STEAMTRAP
/// 
/// Inlet (NOTDEFINED, SINK): Incoming fluid.
/// Outlet (NOTDEFINED, SOURCE): Outgoing fluid.
/// 
/// STOPCOCK
/// 
/// Inlet (DOMESTICCOLDWATER, SINK): Incoming fluid.
/// 
/// Figure 233 illustrates valve port use.
/// Figure 233 — Valve port use
class IFC_PARSE_API IfcValve : public IfcFlowController {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcValve
    bool hasPredefinedType() const;
    IfcValveTypeEnum::IfcValveTypeEnum PredefinedType() const;
    void setPredefinedType(IfcValveTypeEnum::IfcValveTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcFlowController::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcValveTypeEnum; } return IfcFlowController::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "PredefinedType"; } return IfcFlowController::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcValve (IfcEntityInstanceData* e);
    IfcValve (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcValveTypeEnum::IfcValveTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcValve > list;
};
/// Definition from ISO 6707-1:1989: Vertical construction
/// usually in masonry or in concrete which bounds or subdivides a
/// construction works and fulfils a load bearing or retaining
/// function.
/// Definition from IAI: The wall represents a vertical
/// construction that bounds or subdivides spaces. Wall are usually
/// vertical, or nearly vertical, planar elements, often designed to
/// bear structural loads. A wall is howeverÿnot required to be load
/// bearing.
/// NOTE NOTE There is a representation of walls
/// for structural analysis provided by a proper subtype of
/// IfcStructuralMember being part of the
/// IfcStructuralAnalysisModel.
/// 
/// NOTE An arbitrary planar element to which this semantic
/// information is not applicable, e.g. is not predominantly
/// vertical, shall be modeled as
/// IfcPlate
/// A wall may have openings, such as wall openings, openings used
/// for windows or doors, or niches and recesses. They are defined by
/// an IfcOpeningElement attached to the wall using the
/// inverse relationship HasOpenings pointing to
/// IfcRelVoidsElement.
/// The IFC specification provides two entities for wall
/// occurrences:
/// 
/// IfcWallStandardCase ÿused for all occurrences of
/// walls, that have a non-changing thickness along the wall path and
/// where the thickness parameter can be fully described by a
/// material layer set. These walls are always represented
/// geometrically by an 'Axis' and a 'SweptSolid' shape
/// representation (or by a 'Clipping' geometry based on
/// 'SweptSolid'), if a 3D geometric representation is assigned. In
/// addition they have to have a corresponding
/// IfcMaterialProfileSetUsage assigned.
/// IfcWallElementedCase used for occurrences of walls
/// which are aggregated from subordinate elements, following
/// specific decomposition rules expressed by the mandatory use of
/// IfcRelAggregates relationship.
/// IfcWall ÿused for all other occurrences of wall,
/// particularly for walls with changing thickness along the wall
/// path (e.g. polygonal walls), or walls with a non-rectangular
/// cross sections (e.g. L-shaped retaining walls), and walls having
/// an extrusion axis that is unequal to the global Z axis of the
/// project (i.e. non-vertical walls), or walls having only 'Brep',
/// or 'SurfaceModel' geometry.
/// 
/// HISTORY New entity in
/// IFC Release 1.0
/// Type Use Definition
/// IfcWall defines the occurrence of any wall, common
/// information aboutÿwall types (or styles) is handled by
/// IfcWallType. The IfcWallType (if present) may
/// establish the commonÿtype name, usage (or predefined) type,
/// common material layer set, common set of properties and common
/// shape representations (using IfcRepresentationMap). The
/// IfcWallType is attached using the
/// IfcRelDefinedByType.RelatingType objectified relationship
/// and is accessible by the inverse IsTypedBy attribute.
/// If no IfcWallType is attachedÿ(i.e. if only occurrence
/// information is given) the PredefinedType should be
/// provided. If set to .USERDEFINED. a user defined value can be
/// provided by the ObjectType attribute.
/// Material Use Definition
/// The material of the IfcWall is defined by
/// IfcMaterialLayerSet and attached by the
/// IfcRelAssociatesMaterial.RelatingMaterial. It is
/// accessible by the inverse HasAssociations relationship.
/// Multi-layer walls can be represented by referring to several
/// IfcMaterialLayer's within the
/// IfcMaterialLayerSet.ÿ
/// Note: It is illegal to assign an
/// IfcMaterialLayerSetUsage to an IfcWall. Only the
/// subtype IfcWallStandardCase supports this
/// concept.
/// Material information can also be given at the
/// IfcWallType, defining the common attribute data for all
/// occurrences of the same type.ÿIt is then in addition accessible
/// by the inverse IsTypedBy
/// relationship pointing to IfcWallType.HasAssociations and
/// via IfcRelAssociatesMaterial.RelatingMaterial.
/// Property Set Use Definition
/// The property sets relating to the IfcWall are defined
/// by the IfcPropertySet and attached by the
/// IfcRelDefinesByProperties relationship. It is accessible
/// by the inverse IsDefinedBy relationship. The following
/// property set definitions specific to the IfcWall are part
/// of this IFC release:
/// 
/// Pset_WallCommon: common property set for all
/// wall occurrences
/// 
/// Property sets can also be given at the IfcWallType,
/// defining the common property data for all occurrences of the same
/// type.ÿIt is then accessible by the inverse IsTypedBy relationship pointing to
/// IfcWallType.HasPropertySets. If both are given, then the
/// properties directly assigned to IfcWall overrides the
/// properties assigned to IfcWallType.
/// Quantity Use Definition
/// The quantities relating to the IfcWall and
/// IfcWallStandardCase are defined by the
/// IfcElementQuantity and attached by the
/// IfcRelDefinesByProperties relationship. It is accessible
/// by the inverse IsDefinedBy relationship. The following
/// base quantities are defined and should be exchanged with the
/// IfcElementQuantity.Name = 'BaseQuantities'. Other
/// quantities can be defined being subjected to local standard of
/// measurement with another string value assigned to Name and
/// a value provided for MethodOfMeasurement. Quantities shall
/// never be assigned to the IfcWallType.
/// 
/// Qto_WallBaseQuantities: base quantities for
/// all wall occurrences.
/// 
/// Containment Use Definition
/// The IfcWall (and the subtype
/// IfcWallStandardCase) as any subtype of
/// IfcBuildingElement, may participate in two different
/// containment relationships. The first (and in most implementation
/// scenarios mandatory) relationship is the hierarchical spatial
/// containment, the second (optional) relationship is the
/// aggregation within anÿelement assembly.
/// 
/// The IfcWall is places within the project spatial
/// hierarchy using the objectified relationship
/// IfcRelContainedInSpatialStructure, referring to it by its
/// inverse attribute SELF\IfcElement.ContainedInStructure.
/// Subtypes ofÿIfcSpatialStructureElement are valid spatial
/// containers, with IfcBuildingStorey being the default
/// container.
/// TheÿIfcWall may be aggregated into an element assembly
/// using the objectified relationship IfcRelAggregates,
/// referring to it by its inverse attribute
/// SELF\IfcObjectDefinition.Decomposes. Any subtype of
/// IfcElement can be an element assembly, with
/// IfcElementAssembly as a special focus subtype.
/// In this case the wall should not be additionally contained in the
/// project spatial hierarchy,
/// i.e.ÿSELF\IfcElement.ContainedInStructure should be
/// NIL.
/// 
/// TheÿIfcWallÿmay also be an aggregate i.e. being
/// composed by other elements and acting as an assembly using the
/// objectified relationship IfcRelAggregates, referring to it
/// by its inverse attribute
/// SELF\IfcObjectDefinition.IsDecomposedBy. Components of a
/// wall are described by instances of IfcBuildingElementPart
/// that are aggregated to form a complex wall.
/// In this case, the containedÿIfcBuildingElementPart's
/// should not be additionally contained in the project spatial
/// hierarchy, i.e. the inverse attribute
/// SELF\IfcElement.ContainedInStructure of
/// IfcBuildingElementPart should be NIL.
/// Geometry Use Definition
/// The geometric representation of IfcWall is given by the
/// IfcProductDefinitionShape, allowing multiple geometric
/// representation. Included are:
/// Local Placement
/// The local placement for IfcWall is defined in its
/// supertype IfcProduct. It is defined by the
/// IfcLocalPlacement, which defines the local coordinate
/// system that is referenced by all geometric representations.
/// 
/// The PlacementRelTo relationship of
/// IfcLocalPlacement shall point (if given) to the local
/// placement of the same IfcSpatialStructureElement that is
/// used in the ContainedInStructure inverse attribute or to a
/// referenced spatial structure element at a higher level.
/// If the relative placement is not used, the absolute placement
/// is defined within the world coordinate system.
/// 
/// Geometric Representation
/// Currently, the 'Axis', 'Surface',
/// 'FootPrint', 'Body', and 'Box'
/// representations are supported. The 'Box' representation includes
/// the representation type 'BoundingBox' and is explained at
/// IfcBuildingElement.
/// Axis Representation
/// The axis geometric representation of IfcWall is defined
/// using the 'Axis' representation.
/// 
/// RepresentationIdentifier : 'Axis'
/// RepresentationType : 'Curve2D'
/// 
/// NOTE The 'Axis' is not used to locate the
/// material layer set, only the subtype IfcWallStandardCase
/// provides this capability.
/// Surface Representation
/// The surfacic geometric representation of IfcWall is
/// defined using the 'Surface' representation.
/// 
/// RepresentationIdentifier : 'Surface'
/// RepresentationType : 'Surface3D'
/// 
/// NOTE The 'Surface' can be used to define a
/// surfacic model of the building (e.g. for analytical purposes, or
/// for reduced Level of Detail representation).
/// Body Representation
/// The body representation of IfcWall can be represented
/// using the representation types 'SweptSolid', 'Clipping',
/// 'SurfaceModel', and 'Brep'. The representation types
/// 'SurfaceModel' and 'Brep' are explained at
/// IfcBuildingElement.
/// SweptSolid Representation Type
/// The following attribute values for the
/// IfcShapeRepresentation holding this geometric
/// representation shall be used:
/// If the wall body can be described by a
/// vertical extrusion of a polygonal footprint with constant
/// thickness along the axis (where vertical = into the direction of
/// the global Z axis), the subtype IfcWallStandardCase should
/// be used. If the extrusion is not equal to global Z, then the
/// IfcWall should be used.
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'SweptSolid'
/// 
/// The following additional constraints apply to the 'SweptSolid'
/// representation:
/// 
/// Solid: IfcExtrudedAreaSolid is required,
/// Profile: IfcArbitraryClosedProfileDef is
/// required.
/// Extrusion:ÿAll extrusion directions shall be
/// supported.
/// 
/// Clipping Representation Type
/// The following attribute values for the
/// IfcShapeRepresentation holding this geometric
/// representation shall be used:
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'Clipping'
/// 
/// The same additional constraints apply as defined for the
/// 'SweptSolid' representation.
/// Connection Geometry
/// The connection between two walls is represented by the
/// IfcRelConnectsPathElements. The use of the parameter of
/// that relationship object is defined at the level of the subtypes
/// of IfcWall and at the
/// IfcRelConnectsPathElements.
class IFC_PARSE_API IfcWall : public IfcBuildingElement {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcWall
    bool hasPredefinedType() const;
    /// Predefined generic type for a wall that is specified in an enumeration. There may be a property set given specifically for the predefined types.
    ///   NOTE The PredefinedType shall only be used, if no type object IfcWallType is assigned, providing its own IfcWallType.PredefinedType.
    /// 
    /// IFC2x4 CHANGE  The attribute has been added at the end of the entity definition.
    IfcWallTypeEnum::IfcWallTypeEnum PredefinedType() const;
    void setPredefinedType(IfcWallTypeEnum::IfcWallTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcBuildingElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcWallTypeEnum; } return IfcBuildingElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "PredefinedType"; } return IfcBuildingElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcWall (IfcEntityInstanceData* e);
    IfcWall (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcWallTypeEnum::IfcWallTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcWall > list;
};
/// The IfcWallElementedCase
/// defines a wall with certain constraints for the provision of its
/// components. The IfcWallElementedCase handles all cases of
/// walls, that are decomposed into parts:ÿ
/// 
/// having components being assigned to the
/// IfcWallElementedCase using the IfcRelAggregates
/// relationship accessible by the inverse relationship
/// IsDecomposedBy.
/// applying the constraint that the parts within the
/// decomposition shall be of type IfcMember, IfcPlate,
/// IfcBuildingElementPart or
/// IfcBuildingElementProxy.
/// 
/// HISTORY New entity in
/// IFC2x4.
/// Property Set Use Definition:
/// The property sets relating to the IfcWallElementedCase
/// are defined at the supertype IfcWall.
/// NOTE The parts within the decomposition
/// relationship may define their own property
/// sets.
/// Quantity Use Definition:
/// The quantities relating to the IfcWallElementedCase are
/// defined at the supertype IfcWall.
/// NOTE The parts within the decomposition
/// relationship may define their own individual
/// quantities.
/// 
/// Voiding Use Definition:
/// 
/// As shown in Figure 132, openings within the composite wall are directly assigned to IfcWallElementedCase using IfcRelVoidsElement pointing to IfcOpeningElement and apply to all aggregated parts. If individual parts have cutting and other voiding features, then the decomposed parts have a separate voiding relationship IfcRelVoidsElement pointing to IfcVoidingFeature.
/// 
/// Figure 132 — Wall elemented voiding
/// 
/// Decomposition Use Definition:
/// The following guidance is provided for the components of the
/// IfcWallElementedCase. The following component entity types
/// should be used:
/// 
/// Framed Walls
/// 
/// studs : IfcMember
/// plates : IfcMember
/// drywall : IfcPlate
/// wood sheathing : IfcPlate
/// insulation : IfcBuildingElementPart
/// precast panel : IfcBuildingElementPart
/// others : IfcBuildingElementPart
/// 
/// Geometry Use Definitions:
/// The geometric representation of IfcWallElementedCase is
/// given by the IfcProductDefinitionShape, allowing multiple
/// geometric representation. Included are:
/// Local Placement
/// The use of local placement is defined at the supertype
/// IfcWall. The local placement of the
/// IfcWallElementedCase defines the parent coordinate systems
/// for the parts within the decomposition. All parts shall be
/// positioned relative to the IfcWallElementedCase.
/// Geometric Representation
/// The standard geometric representation of
/// IfcWallElementedCase is defined using the following
/// multiple shape representations for its definition:
/// 
/// Axis: A two-dimensional open curve being a subtype of
/// IfcBoundedCurve defining the axis for the elemented wall.
/// It maybe used as a simplified representation directly at the
/// elemented wall.
/// Surface: A three-dimensional surface being a subtype
/// of IfcBoundedSurface defining the reference surface for
/// the elemented wall. It maybe used as a simplified representation
/// directly at the elemented wall.
/// 
/// NOTEÿ It is invalid to exhange a 'Body' shape
/// representation of an IfcWallElementedCase. The body
/// geometry is defined by the parts within the
/// decomposition.
/// Axis Representation
/// The wall axis is represented by a two-dimensional open curve
/// within a particular shape representation.
/// 
/// RepresentationIdentifier : 'Axis'
/// RepresentationType : 'Curve2D'
/// 
/// Surface Representation
/// The surfacic geometric representation of
/// IfcWallElementedCase is defined using the 'Surface'
/// representation.
/// 
/// RepresentationIdentifier : 'Surface'
/// RepresentationType : 'Surface3D'
/// 
/// NOTE The 'Surface' can be used to define a
/// surfacic model of the building (e.g. for analytical purposes, or
/// for reduced Level of Detail representation). It could suppress
/// the geometric details of the parts in the
/// decomposition.
class IFC_PARSE_API IfcWallElementedCase : public IfcWall {
public:
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcWall::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcWall::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcWall::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcWallElementedCase (IfcEntityInstanceData* e);
    IfcWallElementedCase (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcWallTypeEnum::IfcWallTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcWallElementedCase > list;
};
/// The IfcWallStandardCase defines a wall with certain
/// constraints for the provision of parameters and with certain
/// constraints for the geometric representation. The
/// IfcWallStandardCase handles all cases of walls, that are
/// extruded vertically:
/// 
/// along the positive z axis of the wall object coordinate system,
/// and
/// along the positve z axis of the global (world) coordinate
/// system
/// 
/// and have a single thickness along the path for each wall layer,
/// i.e.:
/// 
/// parallel sides for straight walls
/// co-centric sides for curved walls.
/// 
/// and have either:
/// 
/// a straight line axis (straight wall), or
/// a circular arc axis (round wall).
/// 
/// and shall not have
/// 
/// aggregated components, that is, parts aggregated to a wall by IfcRelAggregates
/// shape representation for 'Body' not being an extrusion, or clipped extrusion
/// 
/// The following parameter have to be provided:
/// 
/// Wall height, taken from the depth of extrusion, provided by the geometric representation.
/// Wall thickness, taken from the material layer set usage, attached to the wall
/// Wall offset from axis, taken from the material layer set usage, attached to the wall
/// 
/// The IfcWallStandardCase requires the provision of the
/// wall axis either a straight line that is parallel to the x-axis of
/// the object coordinate system, or a circular arc where the tangent
/// at start is parallel to the x-axis of the object coordinate system.
/// The direction of the wall axis shall be the positive direction of
/// that x-axis.
/// The material of the wall is defined by the
/// IfcMaterialLayerSetUsage and is attached by the
/// IfcRelAssociatesMaterial objectified relationship. It is
/// accessible by the inverse HasAssociations relationship.
/// The material layer set usage has to be given (enforced by where
/// rule).
/// HISTORY New entity in IFC Release 2x.
/// 
/// Type Use Definition
/// The type information relating to the
/// IfcWallStandardCase is defined at the supertype
/// IfcWall. As an additional use agreement for standard
/// walls, the IfcWallType should have a unique
/// IfcMaterialLayerSet, that is referenced by
/// the IfcMaterialLayerSetUsage assigned to all
/// occurrences of this IfcWallType.
/// 
/// Figure 134 illustrates assignment of IfcMaterialLayerSetUsage and IfcMaterialLayerSet to the wall type and the wall occurrence.
/// 
/// Figure 134
/// 
/// Material Use Definition
/// The material of the IfcWallStandardCase is defined by
/// IfcMaterialLayerSetUsage and attached by the
/// IfcRelAssociatesMaterial.RelatingMaterial. It is
/// accessible by the inverse HasAssociations relationship.
/// Multi-layer walls can be represented by refering to several
/// IfcMaterialLayer's within the IfcMaterialLayerSet
/// that is referenced from the
/// IfcMaterialLayerSetUsage. 
/// Material information can also be given at the
/// IfcWallType, defining the common attribute data for all
/// occurrences of the same type. It is then accessible by the
/// inverse IsDefinedBy relationship pointing to
/// IfcSlabType.HasAssociations and via
/// IfcRelAssociatesMaterial.RelatingMaterial. See Type Use
/// Definition for additional agreements for standard slabs.
/// 
/// Figure 134 illustrates material layer usage, where the following conventions shall be met:
/// 
/// The reference coordinate system is the local coordinate system established by the ObjectPlacement of the IfcWallStandardCase.
/// The reference axis is the axis defined by the IfcShapeRepresentation with RepresentationType='Axis' as one of the
/// Representation.Representations of the IfcWallStandardCase.
/// The IfcMaterialLayerSetUsage.OffsetFromReferenceLine is given as a distance from this axis.
/// The IfcMaterialLayerSetUsage.OffsetFromReferenceLine is the distance parallel to the reference axis and always within the base
/// (XY) plane of the reference coordinate system. A positve value of IfcMaterialLayerSetUsage.OffsetFromReferenceLine would
/// then point into the positive y-axis of the reference coordinate system.
/// The IfcMaterialLayerSetUsage.DirectionSense defines how the IfcMaterialLayer's are assigned to the reference axis. POSITIVE means in direction to the positive y-axis of the reference coordinate system.
/// The Thickness of each IfcMaterialLayer is provided starting from the OffsetFromReferenceLine and in the direction given by DirectionSense. It is applied without any gap or overlap between two consecutive layers. The TotalThickness of the IfcMaterialLayerSet is the sum of all layer thicknesses.
/// The IfcMaterialLayerSetUsage.LayerSetDirection is always AXIS2.
/// 
/// Figure 134 — Wall material layers
/// 
/// Property Set Use Definition:
/// The property sets relating to the IfcWallStandardCase
/// are defined at the supertype IfcWall.
/// Quantity Use Definition:
/// The quantities relating to the IfcWallStandardCase are
/// defined at the supertype IfcWall.
/// Geometry Use Definitions:
/// The geometric representation of IfcWallStandardCase is
/// given by the IfcProductDefinitionShape, allowing multiple
/// geometric representation. Included are:
/// Local Placement
/// The use of local placement defining the wall object coordinate
/// system is defined at the supertype IfcWall.
/// Geometric Representation
/// The standard geometric representation of
/// IfcWallStandardCase is defined using the following
/// multiple shape representations for its definition:
/// 
/// Axis: A two-dimensional open curve
/// (IfcBoundedCurve) defining the axis for the standard wall.
/// The material layer offset is measured from the wall axis.
/// Body: A Swept Solid Representation or a CSG
/// representation defining the 3D shape of the standard wall
/// 
/// NOTE  It is invalid to exhange a
/// 'SurfaceModel', or 'Brep' or 'MappedRepresentation' representation
/// for the 'Body' shape representation of an
/// IfcWallStandardCase.
/// Axis Representation
/// The wall axis is represented by a two-dimensional open curve
/// within a particular shape representation. The wall axis is used to
/// apply the material layer set usage parameter to the wall geometry.
/// The following attribute values shall be used
/// 
/// RepresentationIdentifier : 'Axis'
/// RepresentationType : 'Curve2D'
/// 
/// Figure 135 illustrates an axis representation for a straight wall. In case of a straight wall, the set of items shall
/// include a single geometric representation item of type IfcPolyline or IfcTrimmedCurve with the BasisCurve being an IfcLine. The IfcPolyline or IfcTrimmedCurve shall be parallel (here in a special case co-linear) to the x-axis
/// of the object coordinate system. The direction shall be identical to the direction of the x-axis.
/// 
/// Figure 136 illustrates an axis representation for a curved wall. In case of a curved wall, the set of items shall include
/// a single geometric representation item of type IfcTrimmedCurve. The curve shall have a BasisCurve of type IfcCircle. The tangent of the IfcTrimmedCurve shall be parallel at start to the x-axis of the object coordinate system. The direction shall be identical to the direction of the x-axis.
/// 
/// Figure 135 — Wall axis straight
/// Figure 136 — Wall axis curved
/// 
/// Body Representation
/// The body representation of IfcWallStandardCase is
/// defined by using 'SweptSolid' representation for walls without
/// clippings or 'Clipping' representation for walls with clippings
/// (e.g. under sloped roof slabs).
/// SweptSolid Representation Type
/// The following attribute values for the
/// IfcShapeRepresentation holding this geometric
/// representation shall be used:
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'SweptSolid'
/// 
/// The following additional constraints apply to the 'SweptSolid'
/// representation:
/// 
/// Solid: IfcExtrudedAreaSolid is required,
/// Profile: IfcArbitraryClosedProfileDef and
/// IfcRectangleProfileDef shall be supported.
/// Extrusion: The profile shall be extruded vertically,
/// i.e., in the direction of the z-axis of the co-ordinate system of
/// the referred spatial structure element. It might be further
/// constraint to be in the direction of the global z-axis in
/// implementers agreements. The extrusion axis shall be perpendicular
/// to the swept profile, i.e. pointing into the direction of the
/// z-axis of the Position of the IfcExtrudedAreaSolid.
/// 
/// The profile of a wall is described in the ground view and extruded vertically. The profile (also identical with the foot print of the wall) is defined by the IfcArbitraryClosedProfileDef (excluding its subtypes). The profile is given with all wall connections already resolved.
/// 
/// Figure 137 illustrates a body representation for a straight wall. In case of a straight wall, the two sides of the profile shall be parallel to the wall axis, that is, the wall has a single unchanged thickness.
/// 
/// Figure 138 illustrates a body representation for a curved wall. In case of a curved wall, the two sides of the profile shall be parallel (with defined offset) to the wall axis, that is, the wall has a single unchanged thickness.
/// 
/// Figure 137 — Wall body extrusion straight
/// Figure 138 — Wall body extrusion curved
/// 
/// Clipping Representation Type
/// The following attribute values for the
/// IfcShapeRepresentation holding this geometric
/// representation shall be used:
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'Clipping'
/// 
/// The following constraints apply to the 'Clipping'
/// representation:
/// 
/// Solid: see standard geometric representation
/// Profile: see standard geometric representation
/// Extrusion: see standard geometric representation
/// Boolean result: The IfcBooleanClippingResult
/// shall be supported, allowing for Boolean differences between the
/// swept solid (here IfcExtrudedAreaSolid) and one or several
/// IfcHalfSpaceSolid (or subtypes).
/// 
/// Figure 139 illustrates a clipping for a straight wall using an IfcPolygonalBoundedHalfSpace as SecondOperand in
/// the IfcBooleanClippingResult.
/// 
/// Figure 140 illustrates a clipping for a curved wall using an IfcHalfSpaceSolid as SecondOperand in the
/// IfcBooleanClippingResult.
/// 
/// Figure 139 — Wall body clipping straight
/// Figure 140 — Wall body clipping curved
class IFC_PARSE_API IfcWallStandardCase : public IfcWall {
public:
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcWall::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcWall::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcWall::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcWallStandardCase (IfcEntityInstanceData* e);
    IfcWallStandardCase (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcWallTypeEnum::IfcWallTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcWallStandardCase > list;
};
/// A waste terminal has the purpose of collecting or intercepting waste from one or more sanitary terminals or other fluid waste generating equipment and discharging it into a single waste/drainage system.
/// A waste terminal provides for all forms of trap and waste point that collects discharge from a sanitary terminal and discharges it into a waste/drainage subsystem or that collects waste from several terminals and passes it into a single waste/drainage subsystem. This includes the P and S traps from soil sanitary terminals, sinks, and basins as well as floor wastes and gully traps that provide collection points. 
/// 
/// HISTORY  New entity in IFC2x4
/// 
/// Type Use Definition
/// IfcWasteTerminal defines the occurrence of any waste terminal; common information about waste terminal types is handled by IfcWasteTerminalType. 
/// The IfcWasteTerminalType (if present) may establish the common type name, usage (predefined type), properties, materials, ports, composition, assignments, and representations. 
/// The IfcWasteTerminalType is attached using the IfcRelDefinesByType objectified relationship and is accessible by the IsTypedBy inverse attribute. 
/// If the IfcWasteTerminalType has ports or aggregated elements, such objects are reflected at the IfcWasteTerminal occurrence using the IfcRelDefinesByObject relationship.
/// 
/// Property Use Definition
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute. 
/// Property sets may also be specified at the IfcWasteTerminalType, defining the common property data for all occurrences of the same type. 
/// They are then accessible by the IsTypedBy inverse attribute pointing to IfcWasteTerminalType.HasPropertySets. 
/// If both are given, then the properties directly defined at IfcWasteTerminal override the properties defined at IfcWasteTerminalType. 
/// Refer to the documentation at the supertype IfcFlowTerminal and ancestors for inherited property set definitions.
/// The following property set definitions are applicable to this entity:
/// (All Types)
/// 
/// Pset_WasteTerminalTypeCommon (PSET_TYPEDRIVENOVERRIDE)
/// 
/// FLOORTRAP
/// 
/// Pset_WasteTerminalTypeFloorTrap (PSET_TYPEDRIVENOVERRIDE)
/// 
/// FLOORWASTE
/// 
/// Pset_WasteTerminalTypeFloorWaste (PSET_TYPEDRIVENOVERRIDE)
/// 
/// GULLYSUMP
/// 
/// Pset_WasteTerminalTypeGullySump (PSET_TYPEDRIVENOVERRIDE)
/// 
/// GULLYTRAP
/// 
/// Pset_WasteTerminalTypeGullyTrap (PSET_TYPEDRIVENOVERRIDE)
/// 
/// ROOFDRAIN
/// 
/// Pset_WasteTerminalTypeRoofDrain (PSET_TYPEDRIVENOVERRIDE)
/// 
/// WASTEDISPOSALUNIT
/// 
/// Pset_WasteTerminalTypeWasteDisposalUnit (PSET_TYPEDRIVENOVERRIDE)
/// 
/// WASTETRAP
/// 
/// Pset_WasteTerminalTypeWasteTrap (PSET_TYPEDRIVENOVERRIDE)
/// 
/// Quantity Use Definition
/// The quantities relating to this entity are defined by IfcElementQuantity and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute.
/// The following base quantities are defined and shall be exchanged with the IfcElementQuantity.Name = 'BaseQuantities'. 
/// Other quantities, being subjected to local standard of measurement, may be defined with another string value assigned to Name. 
/// In this case a valid value for MethodOfMeasurement shall be provided. 
/// 
/// Qto_WasteTerminalBaseQuantities
/// 
/// Material Use Definition
/// The material of the IfcWasteTerminal is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship. It is accessible by the HasAssociations inverse attribute. Material information can also be given at the IfcWasteTerminalType, defining the common attribute data for all occurrences of the same type. The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used:
/// 
/// Body: The primary material from which the object is constructed.
/// Cover: Material from which the cover or grating is constructed.
/// 
/// Port Use Definition
/// The distribution ports relating to the IfcWasteTerminal are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship. 
///   If the waste terminal occurrence is defined by IfcWasteTerminalType, then the port occurrences must reflect those defined at the IfcWasteTerminalType using the IfcRelDefinesByObject relationship.
///   Ports are specific to the IfcWasteTerminal PredefinedType as follows indicated by the IfcDistributionPort Name, PredefinedType, and FlowDirection:
/// 
/// FLOORTRAP
/// 
/// Inlet (DRAINAGE, SINK): Drainage inlet.
/// Outlet (DRAINAGE, SOURCE): Drainage outlet.
/// 
/// FLOORWASTE
/// 
/// Inlet (WASTE, SOURCE): Waste inlet.
/// Outlet (WASTE, SINK): Waste outlet.
/// 
/// GULLYSUMP
/// 
/// Inlet (WASTE, SINK): Drainage inlet.
/// Outlet (WASTE, SOURCE): Drainage outlet.
/// 
/// GULLYTRAP
/// 
/// Inlet (WASTE, SOURCE): Waste inlet.
/// Outlet (WASTE, SINK): Waste outlet.
/// 
/// ROOFDRAIN
/// 
/// Outlet (RAINWATER, SOURCE): Rainwater.
/// 
/// WASTEDISPOSALUNIT
/// 
/// Inlet (WASTE, SINK): Waste inlet.
/// Outlet (DRAINAGE, SOURCE): Drainage outlet.
/// 
/// WASTETRAP
/// 
/// Inlet (WASTE, SINK): Waste inlet.
/// Outlet (WASTE, SOURCE): Waste outlet.
class IFC_PARSE_API IfcWasteTerminal : public IfcFlowTerminal {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcWasteTerminal
    bool hasPredefinedType() const;
    IfcWasteTerminalTypeEnum::IfcWasteTerminalTypeEnum PredefinedType() const;
    void setPredefinedType(IfcWasteTerminalTypeEnum::IfcWasteTerminalTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcFlowTerminal::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcWasteTerminalTypeEnum; } return IfcFlowTerminal::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "PredefinedType"; } return IfcFlowTerminal::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcWasteTerminal (IfcEntityInstanceData* e);
    IfcWasteTerminal (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcWasteTerminalTypeEnum::IfcWasteTerminalTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcWasteTerminal > list;
};
/// Definition form ISO 6707-1:1989: Construction for
/// closing a vertical or near vertical opening in a wall or pitched
/// roof that will admit light and may admit fresh air.
/// The window is a building element
/// that is predominately used to provide natural light and fresh
/// air. It includes vertical and horizontal opening (e.g. skylights
/// or light domes). It includes constructions with swinging,
/// pivoting, sliding, or revolving panels and fixed panels. A window
/// consists of a lining and one or several panels.
/// The IfcWindow defines a particular occurrence of a
/// window inserted in the spatial context of a project. A window
/// can:
/// 
/// be inserted into an IfcOpeningElement using the
/// IfcRelFillsElement relationship, , then the IfcDoor
/// has an inverse attribute FillsVoids provided,
/// 
/// NOTEÿ View definitions or
/// implementer agreements may restrict the relationship to only
/// include one window (or door) into one opening.
/// 
/// be part of an element assembly, often an
/// IfcCurtainWall, using the IfcRelAggregates
/// relationship, then the inverse attribute Decomposes is
/// provided.
/// or be a "free standing" window, then the IfcWindow has
/// no inverse attributes FillsVoids or Decomposes
/// provided.
/// 
/// The IFC specification provides two entities for window
/// occurrences:
/// 
/// IfcWindowStandardCase used for all occurrences of
/// windows, that have a 'Profile' shape representation defined to
/// which a set of shape parameters for lining and framing properties
/// apply. Additionally it requires the provision of an
/// IfcWindowType that references one
/// IfcWindowLiningProperties and on to many
/// IfcWindowPanelProperties.
/// 
/// NOTEÿ see
/// IfcWindowStandardCase for all specific constraints imposed
/// by this subtype.
/// 
/// IfcWindow used for all other occurrences of windows,
/// particularly for windows having only 'Brep', or 'SurfaceModel'
/// geometry without applying shape parameters.
/// 
/// The actual parameter of the window and/or its shape is defined
/// at the IfcWindow as the occurrence definition (or project
/// instance), or by the IfcWindowType as the specific definition (or
/// project type). The following parameters are given:
/// 
/// at the IfcWindow or IfcWindowStandardCase for
/// occurrence specific parameters. The IfcWindow
/// specifies:
/// 
/// the window width and height
/// the window opening direction (by the y-axis of the
/// ObjectPlacement)
/// 
/// at the IfcWindowType to
/// which the IfcWindow is related by the inverse relationship
/// IsDefinedBy pointing to IfcRelDefinesByType, for
/// type parameters common to all occurrences of the same type.
/// 
/// the partitioning type (single panel, double panel, tripel
/// panel, more panels)
/// the operation type (swing, tilt and turn, pivot revolve,
/// fixed case ment, etc.)
/// the window panel hinge side (by using two different styles
/// for right and left opening windows)
/// the construction material type
/// the particular attributes for the lining by the
/// IfcWindowLiningProperties
/// the particular attributes for the panels by theÿ
/// IfcWindowPanelProperties
/// 
/// HISTORY New entity in IFC Release 1.0.
/// IFC2x4 CHANGE The attributes PredefinedType and OperationType are added, the applicable type object has been changed to IfcDoorType.
/// 
/// Material Use Definition
/// The material of the IfcWindow is defined by the
/// IfcMaterialConstituentSet or as fall back by
/// IfcMaterial and attached by the
/// IfcRelAssociatesMaterial.RelatingMaterial. It is
/// accessible by the inverse HasAssociations
/// relationship.
/// The following keywords for
/// IfcMaterialConstituentSet.MaterialConstituents[n].Name
/// shall be used:
/// 
/// 'Lining' - to indicate that the material constituent applies
/// to to the window lining
/// 'Framing' - to indicate that the material constituent applies
/// to to the window panel(s), if not provided, the 'Lining' material
/// information applied to panel(s) as well
/// 'Glazing' - to indicate that the material constituent applies
/// to to the glazing part
/// 
/// If the fall back single IfcMaterial is referenced, it
/// applies to the lining and framing of the window.
/// Property Set Use Definition:
/// The property sets relating to the IfcWindow are defined
/// by the IfcPropertySet and attached by the
/// IfcRelDefinesByProperties relationship. It is accessible
/// by the inverse IsDefinedBy relationship. The following
/// property set definitions specific to the IfcWindow are
/// part of this IFC release:
/// 
/// Pset_WindowCommon: common property set for all
/// window occurrences
/// Pset_DoorWindowGlazingType: specific property
/// set for the glazing properties of the window glazing, if
/// available
/// Pset_DoorWindowShadingType: specific property
/// set for the shading properties of the window glazing, if
/// available
/// 
/// Quantity Use Definition
/// The quantities relating to the IfcWindow are defined by
/// the IfcElementQuantity and attached by the
/// IfcRelDefinesByProperties relationship. It is accessible
/// by the inverse IsDefinedBy relationship. The following
/// base quantities are defined and should be exchanged with the
/// IfcElementQuantity.Name = 'BaseQuantities'. Other
/// quantities can be defined being subjected to local standard of
/// measurement with another string value assigned to
/// MethodOfMeasurement. Quanties shall be never assigned to
/// the IfcWindowStyle.
/// 
/// Qto_WindowBaseQuantities: base quantities for
/// all window occurrences.
/// 
/// Containment Use Definition
/// 
/// The IfcWindow, as any subtype of
/// IfcBuildingElement, may participate in two different
/// containment relationships. The first (and in most implementation
/// scenarios mandatory) relationship is the hierachical spatial
/// containment, the second (optional) relationship is the
/// aggregation within anÿelement assembly.
/// 
/// The IfcWindow is placed within the project spatial
/// hierarchy using the objectified relationship
/// IfcRelContainedInSpatialStructure, refering to it by its
/// inverse attribute SELF\IfcElement.ContainedInStructure.
/// Subtypes ofÿIfcSpatialStructureElement are valid spatial
/// containers, with IfcBuildingStorey being the default
/// container.
/// The IfcWindow may be aggregated into an element
/// assembly using the objectified relationship
/// IfcRelAggregates, refering to it by its inverse attribute
/// SELF\IfcObjectDefinition.Decomposes. Windows may be part
/// of an IfcCurtainWall as a special focus subtype. In this
/// case it should not be additionally contained in the project
/// spatial hierarchy,
/// i.e.ÿSELF\IfcElement.ContainedInStructure should be
/// NIL.
/// 
/// Figure 141 illustrates window containment.
/// NOTE The containment shall be defined independently of the filling relationship, that is, even if the IfcWindow is a filling of an opening established by IfcRelFillsElement, it is also contained in the spatial structure by an IfcRelContainedInSpatialStructure.
/// 
/// Figure 141 — Window containment
/// 
/// Geometry Use Definitions:
/// The geometric representation of IfcWindow is given by
/// the IfcProductDefinitionShape, allowing multiple geometric
/// representation. The IfcWindow, in case of an occurrence
/// object, gets its parameter and shape from the
/// IfcWindowType. If an IfcRepresentationMap (a block
/// definition) is defined for the IfcWindowType, then the
/// IfcWindow inserts it through the IfcMappedItem
/// (refered to by IfcShapeRepresentation.Items).
/// Local Placement
/// The local placement for IfcWindow is defined in its
/// supertype IfcProduct. It is defined by the
/// IfcLocalPlacement, which defines the local coordinate
/// system that is referenced by all geometric representations.
/// 
/// The PlacementRelTo relationship of
/// IfcLocalPlacement shall point to the local placement of
/// the same element (if given), in which the IfcWindow is
/// used as a filling (normally an IfcOpeningElement), as
/// provided by the IfcRelFillsElement relationship.
/// If the IfcWindow is not inserted into an
/// IfcOpeningElement, then the PlacementRelTo
/// relationship of IfcLocalPlacement shall point (if given)
/// to the local placement of the same
/// IfcSpatialStructureElement that is used in the
/// ContainedInStructure inverse attribute or to a referenced
/// spatial structure element at a higher level.
/// If the relative placement is not used, the absolute placement
/// is defined within the world coordinate system.
/// 
/// Geometric Representation
/// Theÿgeometric representation of IfcWindow is defined
/// using the following (potentiallyÿmultiple)
/// IfcShapeRepresentation's for its
/// IfcProductDefinitionShape:
/// 
/// Profile: Aÿ'Curve3D'
/// consisting of a single losed curve defining the outer boundary of
/// the window (lining). Theÿwindow parametric representation uses
/// this profile in order to apply theÿwindow lining and panel
/// parameter. If not provided, the profile of the
/// IfcOpeningElement is taken.
/// FootPrint: A 'GeometricCurveSet', or 'Annotation2D'
/// representation defining the 2D shape of theÿwindow
/// Body: A 'SweptSolid', 'SurfaceModel', or 'Brep'
/// representation defining the 3D shape of theÿwindow.
/// 
/// In addition the parametric representation of a
/// (limited)ÿwindow shape is available by applying the parameters
/// fromÿIfcWindowType
/// referencingÿIfcWindowLiningProperties
/// andÿIfcWindowPanelProperties. The purpose of the parameter
/// is described at those entities and below (parametric
/// representation).
/// Profile -ÿ'Curve3D' representation
/// Theÿwindow profile is represented by a three-dimensional
/// closed curve within a particular shape representation. The
/// profile is used to apply the parameter of the parametricÿwindow
/// representation.ÿThe following attribute values for the
/// IfcShapeRepresentation holding this geometric
/// representation shall be used:
/// 
/// RepresentationIdentifier : 'Profile'
/// RepresentationType : 'Curve3D', only a single closed
/// curve shall be contained in the set of
/// IfcShapeRepresentation.Items.
/// 
/// A 'Profile' representation has to be provided if:
/// 
/// a parametric representation shall be applied to the
/// windowÿAND
/// 
/// the window is 'free standing', or
/// the opening into which the window is inserted is not extruded
/// horizontally (i.e. where the opening profile does not match the
/// window profile)
/// 
/// FootPrint -ÿ'GeometricCurveSet' or 'Annotation2D'
/// representation
/// Theÿwindow foot print is represented by a set of
/// two-dimensionalÿcurves (or in case of 'Annotation2D' additional
/// hatching and text) within a particular shape representation. The
/// foot print is used for the plan view representation of
/// theÿwindow.ÿThe following attribute values for the
/// IfcShapeRepresentation holding this geometric
/// representation shall be used:
/// 
/// RepresentationIdentifier : 'FootPrint'
/// RepresentationType : 'GeometricCurveSet', or
/// 'Annotation2D'
/// 
/// Body - 'SweptSolid', 'SurfaceModel', or 'Brep'
/// representation
/// Theÿwindow body is either represented parameterically (see
/// parametric representation) or by explicit 3D shape. The 3D shape
/// is given by using extrusion geometry, or surface models, or Brep
/// models within a particular shape representation. The body is used
/// for the model view representation of theÿwindow.ÿThe following
/// attribute values for the IfcShapeRepresentation holding
/// this geometric representation shall be used:
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'SweptSolid', 'SurfaceModel', or
/// 'Brep'
/// 
/// MappedRepresentation
/// The 'FootPrint' and 'Body' geometric representation
/// ofÿIfcWindow can be shared among several identicalÿwindows
/// using the 'MappedRepresentation'. The following attribute values
/// for the IfcShapeRepresentation holding this geometric
/// representation shall be used:
/// 
/// RepresentationIdentifier : 'FootPrint', 'Body'
/// RepresentationType : 'MappedRepresentation'
/// 
/// The same constraints, as given for theÿ 'FootPrint', 'Body'
/// representation identifiers, shall apply to the
/// MappedRepresentation of the
/// IfcRepresentationMap.
/// Parameteric Representation using parameters at
/// IfcWindowType
/// The parameters, which define the shape of the
/// IfcWindow, are given at the IfcWindowType and the
/// property sets, which are included in the IfcWindowType.
/// The IfcWindow only defines the local placement.
/// The overall size of the IfcWindow to
/// be used to apply the lining or panel parameter provided by the
/// IfcWindowType is determined by the IfcShapeRepresentation
/// with the RepresentationIdentifier = 'Profile'. Only in case of an
/// IfcWindow inserted into an IfcOpeningElement using
/// the IfcRelFillsElement relatioship, having a horizontal
/// extrusion (along the y-axis of the IfcDoor), the overall
/// size is determined by the extrusion profile of the
/// IfcOpeningElement.
/// 
/// Figure 142 illustrates the insertion of a window into the IfcOpeningElement by creating an instance of
/// IfcWindow with PartitioningType = DoublePanelHorizontal. The parameters OverallHeight and OverallWidth show the extent of the window in the positive Z and X axis of the local placement of the window. The lining and the transom are created by the given parameters.
/// 
/// Figure 142 — Window placement
/// 
/// Figure 143 illustrates the final window (DoublePanelHorizontal) with first panel having PanelPosition = TOP, OperationType = BOTTOMHUNG and second panel having PanelPosition = BOTTOM and OperationType = TILTANDTURNLEFTHAND.
/// 
/// Figure 143 — Window planes
/// 
/// Window opening operation by window type
/// The parameters that defines the shape of the IfcWindow,
/// are given at the IfcWindowType and the property sets,
/// which are included in the IfcWindowType. The
/// IfcWindow only defines the local placement which
/// determines the opening direction of the window. The overall
/// layout of the IfcWindow is determined by
/// itsÿIfcWindowType.PartitioningType. Each window panel has
/// its own operation type, provided by
/// IfcWindowPanelProperties.OperationType. All window panels
/// are assumed to open into the same direction (if relevant for the
/// particular window panel operation. The hindge side (whether a
/// window opens to the left or to the right) is determined by the
/// IfcWindowPanelProperties.OperationType.
/// NOTE ÿThere are different conventions in
/// different countries on how to show the symbolic presentation of
/// the window panel operation (the "triangles"). Either as seen from
/// the exterior, or from the interior side. The following figures
/// show the symbolics from the exterior side (the convention as used
/// predominately in Europe).
/// 
/// Figure 144 illustrates window operation types.
/// 
/// The window panel (for side hung windows) opens always
/// into the direction of the positive Y axis of the local placement.
/// The determination of whether the window opens to the left or to
/// the right is done at
/// IfcWindowPanelProperties.OperationType. Here it is a left
/// side opening window given byÿOperationType =
/// SideHungLeftHand.
/// 
/// If the window should open to the other side, then the
/// local placement has to be changed. It is still a left hung
/// window, given by IfcWindowPanelProperties.OperationType
/// =ÿSideHungLeftHand.
/// 
/// If the window panel (for side hung windows) opens to
/// the right, a separate window panel style needs to be used (here
/// IfcWindowPanelProperties.OperationType
/// =ÿSideHungRightHand) and it always opens into the direction of
/// the positive Y axis of the local placement.ÿ
/// 
/// If the window should open to the other side, then the
/// local placement has to be changed. It is still a right hung
/// window, given by IfcWindowPanelProperties.OperationType
/// =ÿSideHungRightHand.
/// .
/// 
/// Figure 144 — Window operations
class IFC_PARSE_API IfcWindow : public IfcBuildingElement {
public:
    /// Whether the optional attribute OverallHeight is defined for this IfcWindow
    bool hasOverallHeight() const;
    /// Overall measure of the height, it reflects the Z Dimension of a bounding box, enclosing the body of the window opening. If omitted, the OverallHeight should be taken from the geometric representation of the IfcOpening in which the window is inserted. 
    /// 
    /// NOTE  The body of the window might be taller then the window opening (e.g. in cases where the window lining includes a casing). In these cases the OverallHeight shall still be given as the window opening height, and not as the total height of the window lining.
    double OverallHeight() const;
    void setOverallHeight(double v);
    /// Whether the optional attribute OverallWidth is defined for this IfcWindow
    bool hasOverallWidth() const;
    /// Overall measure of the width, it reflects the X Dimension of a bounding box, enclosing the body of the window opening. If omitted, the OverallWidth should be taken from the geometric representation of the IfcOpening in which the window is inserted. 
    /// 
    /// NOTE  The body of the window might be wider then the window opening (e.g. in cases where the window lining includes a casing). In these cases the OverallWidth shall still be given as the window opening width, and not as the total width of the window lining.
    double OverallWidth() const;
    void setOverallWidth(double v);
    /// Whether the optional attribute PredefinedType is defined for this IfcWindow
    bool hasPredefinedType() const;
    /// Predefined generic type for a window that is specified in an enumeration. There may be a property set given specificly for the predefined types.
    ///   NOTE The PredefinedType shall only be used, if no type object IfcWindowType is assigned, providing its own IfcWindowType.PredefinedType.
    /// 
    /// IFC2x4 CHANGE  The attribute has been added at the end of the entity definition.
    IfcWindowTypeEnum::IfcWindowTypeEnum PredefinedType() const;
    void setPredefinedType(IfcWindowTypeEnum::IfcWindowTypeEnum v);
    /// Whether the optional attribute PartitioningType is defined for this IfcWindow
    bool hasPartitioningType() const;
    /// Type defining the general layout of the window in terms of the partitioning of panels. 
    /// 
    /// NOTE The PartitioningType shall only be used, if no type object IfcWindowType is assigned, providing its own IfcWindowType.PartitioningType.
    /// 
    /// IFC2x4 CHANGE  The attribute has been added at the end of the entity definition.
    IfcWindowTypePartitioningEnum::IfcWindowTypePartitioningEnum PartitioningType() const;
    void setPartitioningType(IfcWindowTypePartitioningEnum::IfcWindowTypePartitioningEnum v);
    /// Whether the optional attribute UserDefinedPartitioningType is defined for this IfcWindow
    bool hasUserDefinedPartitioningType() const;
    std::string UserDefinedPartitioningType() const;
    void setUserDefinedPartitioningType(std::string v);
    virtual unsigned int getArgumentCount() const { return 13; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_DOUBLE; case 9: return IfcUtil::Argument_DOUBLE; case 10: return IfcUtil::Argument_ENUMERATION; case 11: return IfcUtil::Argument_ENUMERATION; case 12: return IfcUtil::Argument_STRING; } return IfcBuildingElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcPositiveLengthMeasure; case 9: return Type::IfcPositiveLengthMeasure; case 10: return Type::IfcWindowTypeEnum; case 11: return Type::IfcWindowTypePartitioningEnum; case 12: return Type::IfcLabel; } return IfcBuildingElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "OverallHeight"; case 9: return "OverallWidth"; case 10: return "PredefinedType"; case 11: return "PartitioningType"; case 12: return "UserDefinedPartitioningType"; } return IfcBuildingElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcWindow (IfcEntityInstanceData* e);
    IfcWindow (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< double > v9_OverallHeight, boost::optional< double > v10_OverallWidth, boost::optional< IfcWindowTypeEnum::IfcWindowTypeEnum > v11_PredefinedType, boost::optional< IfcWindowTypePartitioningEnum::IfcWindowTypePartitioningEnum > v12_PartitioningType, boost::optional< std::string > v13_UserDefinedPartitioningType);
    typedef IfcTemplatedEntityList< IfcWindow > list;
};
/// The standard window,
/// IfcWindowStandardCase, defines a window with certain
/// constraints for the provision of operation types, opening
/// directions, frame and lining parameters, construction types and
/// with certain constraints for the geometric representation. The
/// IfcWindowStandardCase handles all cases of windows,
/// that:
/// 
/// are inserted into an opening, represented by
/// IfcOpeningElement, using the IfcRelFillsElement
/// relationship
/// have a local placement relative to this opening, and with the
/// y-axis of the placement pointing into the opening direction
/// have a profile geometry, represented by
/// IfcShapeRepresentation.RepresentationIdentifier="Profile"
/// as a closed curve to which the window parameter apply. The
/// profile represents a rectangle within the xz plane of the local
/// placement
/// have a reference to an IfcWindowType to define the
/// opening direction and the operation type (swinging, sliding,
/// folding, etc.) of the window. The attribute OperationType
/// shall be provided and not being UNDEFINED, and the attribute
/// ParameterTakesPrecedence shall be "TRUE".
/// have a single IfcWindowLiningProperties and a set of
/// IfcWindowPanelProperties instances included in the set of
/// HasPropertySets at IfcWindowType
/// 
/// HISTORY New entity in IFC2x4.
/// 
/// Type Use Definition
/// IfcWindowStandardCase defines the occuurence of any
/// window, common information about window types (or styles) is
/// handled by IfcWindowType. The IfcWindowType (that
/// has to be present) establishes the common type name, usage
/// (opening direction, configuration and operation), common set of
/// properties, including shape parameters, like lining thickness
/// panel width, etc. and maybe an additional common shape
/// representations (using IfcRepresentationMap). The
/// IfcWindowType is attached using the
/// IfcRelDefinedByType.RelatingType objectified relationship
/// and is accessible by the inverse IsDefinedBy
/// attribute.
/// Property Set Use Definition:
/// The property sets relating to the IfcWindowStandardCase
/// are defined at the supertype IfcWindow.
/// Quantity Use Definition
/// The quantities relating to the IfcWindowStandardCase
/// are defined at the supertype IfcWindow.
/// Containment Use Definition
/// The containment use definitions relating to the
/// IfcWindowStandardCase are defined at the supertype
/// IfcWindow.
/// Geometry Use Definitions:
/// The geometric representation of IfcWindowStandardCase
/// is given by the IfcProductDefinitionShape, allowing
/// multiple geometric representations. Included are:
/// Local Placement
/// The use of local placement is defined at the supertype
/// IfcWindow.
/// Geometric Representations
/// The geometric representation of IfcWindowStandardCase
/// is defined using the following multiple shape representations for
/// its definition:
/// 
/// Profile: a three-dimensional closed curve within a
/// particular shape representation. The profile is used to apply the
/// parameter of the parametric window representation. The profile
/// around the edges of the opening is used to apply the window
/// lining and window panel shape parameter.
/// MappedRepresentation: A SweptSolid, SurfaceModel, or
/// Brep Representation or a CSG additionally defining the 3D shape
/// of the standard window in addition to the parametric
/// representation by applying the IfcWindowLiningProperties
/// and an the IfcWindowPanelProperties to the Profile
/// representation.
/// 
/// RepresentationIdentifier : 'Profile'
/// RepresentationType : 'Curve3D' or 'GeometricCurveSet',
/// in case of 'GeometricCurveSet' only a single closed curve shall
/// be contained in the set of
/// IfcShapeRepresentation.Items.
/// 
/// The following additional constraints apply to the 'Profile'
/// representation type:
/// 
/// Curve: being an IfcPolyline defining a
/// rectangle.
/// Position: The curve shall lie in the xz plane of the
/// object placement coordinate (the y coordinate values of the
/// IfcCartesianPoint's shall be 0.).
/// 
/// As shown in Figure 145, the profile defines the outer boundary to which the window
/// lining parameters relate as:
/// 
/// IfcWindowLiningProperties.LiningDepth starting at
/// distance defined by LiningOffset going into the positive y
/// direction.
/// IfcWindowLiningProperties.LiningThickness offset into
/// the inner side of the rectangle.
/// IfcWindowLiningProperties.LiningOffset distance along
/// the positive y direction to where the LiningDepth
/// applies.
/// IfcWindowLiningProperties.FirstTransomOffset starting
/// at the bottom edge of the rectangle (along local x axis) into the
/// inner side of the rectangle, distance provided as percentage of
/// overall height. Distance to the centre line of the transom.
/// SecondTransomOffset defined accordingly.
/// IfcWindowLiningProperties.FirstMullionOffset starting
/// at the left edge of the rectangle (along local z-axis) into the
/// inner side of the rectangle, distance provided as percentage of
/// overall width. Distance to the centre line of the mullion.
/// SecondMullionOffset defined accordingly.
/// 
/// Figure 145 — Window profile
class IFC_PARSE_API IfcWindowStandardCase : public IfcWindow {
public:
    virtual unsigned int getArgumentCount() const { return 13; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcWindow::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcWindow::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcWindow::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcWindowStandardCase (IfcEntityInstanceData* e);
    IfcWindowStandardCase (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< double > v9_OverallHeight, boost::optional< double > v10_OverallWidth, boost::optional< IfcWindowTypeEnum::IfcWindowTypeEnum > v11_PredefinedType, boost::optional< IfcWindowTypePartitioningEnum::IfcWindowTypePartitioningEnum > v12_PartitioningType, boost::optional< std::string > v13_UserDefinedPartitioningType);
    typedef IfcTemplatedEntityList< IfcWindowStandardCase > list;
};
/// The distribution control element type IfcActuatorType defines commonly shared information for occurrences of actuators.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a actuator specification (i.e. the specific product information, that is common to all occurrences of that product type).  Actuator types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcActuatorType are represented by instances of IfcActuator. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcDistributionControlElementType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity according to the PredefinedType attribute:  
/// Pset_ActuatorTypeCommon 
/// Pset_ActuatorTypeElectricActuator (ELECTRICACTUATOR) 
/// Pset_ActuatorTypeHydraulicActuator (HYDRAULICACTUATOR) 
/// Pset_ActuatorTypeLinearActuation 
/// Pset_ActuatorTypePneumaticActuator (PNEUMATICACTUATOR) 
/// Pset_ActuatorTypeRotationalActuation 
/// 
/// Material Use Definition 
/// The material of the IfcActuatorType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Casing': Material from which the casing is constructed. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcActuatorType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcActuator for standard port definitions.
class IFC_PARSE_API IfcActuatorType : public IfcDistributionControlElementType {
public:
    /// Identifies the predefined types of actuator from which the type required may be set.
    IfcActuatorTypeEnum::IfcActuatorTypeEnum PredefinedType() const;
    void setPredefinedType(IfcActuatorTypeEnum::IfcActuatorTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcDistributionControlElementType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcActuatorTypeEnum; } return IfcDistributionControlElementType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcDistributionControlElementType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcActuatorType (IfcEntityInstanceData* e);
    IfcActuatorType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcActuatorTypeEnum::IfcActuatorTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcActuatorType > list;
};
/// An air terminal is a terminating or origination point for the transfer of air between distribution system(s) and one or more spaces. It can also be used for the transfer of air between adjacent spaces. 
/// 
/// HISTORY  New entity in IFC2x4
/// 
/// Type Use Definition
/// IfcAirTerminal defines the occurrence of any air terminal; common information about air terminal types is handled by IfcAirTerminalType. 
/// The IfcAirTerminalType (if present) may establish the common type name, usage (predefined type), properties, materials, ports, composition, assignments, and representations. 
/// The IfcAirTerminalType is attached using the IfcRelDefinesByType objectified relationship and is accessible by the IsTypedBy inverse attribute. 
/// If the IfcAirTerminalType has ports or aggregated elements, such objects are reflected at the IfcAirTerminal occurrence using the IfcRelDefinesByObject relationship.
/// Figure 210 illustrates air terminal type use.
/// Figure 210 — Air terminal type use
/// 
/// Property Use Definition
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute. 
/// Property sets may also be specified at the IfcAirTerminalType, defining the common property data for all occurrences of the same type. 
/// They are then accessible by the IsTypedBy inverse attribute pointing to IfcAirTerminalType.HasPropertySets. 
/// If both are given, then the properties directly defined at IfcAirTerminal override the properties defined at IfcAirTerminalType. 
/// Refer to the documentation at the supertype IfcFlowTerminal and ancestors for inherited property set definitions.
/// The following property set definitions are applicable to this entity:
/// Pset_AirTerminalOccurrence (PSET_OCCURRENCEDRIVEN)
/// Pset_AirTerminalPHistory (PSET_PERFORMANCEDRIVEN)
/// Pset_AirTerminalTypeCommon (PSET_TYPEDRIVENOVERRIDE)
/// 
/// Quantity Use Definition
/// The quantities relating to this entity are defined by IfcElementQuantity and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute.
/// The following base quantities are defined and shall be exchanged with the IfcElementQuantity.Name = 'BaseQuantities'. 
/// Other quantities, being subjected to local standard of measurement, may be defined with another string value assigned to Name. 
/// In this case a valid value for MethodOfMeasurement shall be provided. 
/// 
/// Qto_AirTerminalBaseQuantities
/// 
/// Material Use Definition
/// The material of the IfcAirTerminal is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship. It is accessible by the HasAssociations inverse attribute. Material information can also be given at the IfcAirTerminalType, defining the common attribute data for all occurrences of the same type. The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used:
/// 
/// Body: The primary material from which the object is constructed.
/// 
/// Port Use Definition
/// The distribution ports relating to the IfcAirTerminal are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship. 
///   If the air terminal occurrence is defined by IfcAirTerminalType, then the port occurrences must reflect those defined at the IfcAirTerminalType using the IfcRelDefinesByObject relationship.
///   Ports are specific to the IfcAirTerminal PredefinedType as follows indicated by the IfcDistributionPort Name, PredefinedType, and FlowDirection:
/// 
/// DIFFUSER
/// 
/// Air (AIRCONDITIONING, SINK): Supply air, typically connected from a duct segment or fitting.
/// 
/// GRILLE
/// 
/// Air (VENTILATION, SOURCE): Return air, typically connected to a duct segment or fitting.
/// 
/// REGISTER
/// 
/// Air (AIRCONDITIONING, SINK): Supply air, typically connected from a duct segment or fitting.
/// 
/// Figure 211 illustrates air terminal port use.
/// Figure 211 — Air terminal port use
class IFC_PARSE_API IfcAirTerminal : public IfcFlowTerminal {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcAirTerminal
    bool hasPredefinedType() const;
    IfcAirTerminalTypeEnum::IfcAirTerminalTypeEnum PredefinedType() const;
    void setPredefinedType(IfcAirTerminalTypeEnum::IfcAirTerminalTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcFlowTerminal::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcAirTerminalTypeEnum; } return IfcFlowTerminal::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "PredefinedType"; } return IfcFlowTerminal::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcAirTerminal (IfcEntityInstanceData* e);
    IfcAirTerminal (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcAirTerminalTypeEnum::IfcAirTerminalTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcAirTerminal > list;
};
/// An air terminal box typically participates in an HVAC duct distribution system and is used to control or modulate the amount of air delivered to its downstream ductwork. An air terminal box type is often referred to as an "air flow regulator". 
/// 
/// HISTORY  New entity in IFC2x4
/// 
/// Type Use Definition
/// IfcAirTerminalBox defines the occurrence of any air terminal box; common information about air terminal box types is handled by IfcAirTerminalBoxType. 
/// The IfcAirTerminalBoxType (if present) may establish the common type name, usage (predefined type), properties, materials, ports, composition, assignments, and representations. 
/// The IfcAirTerminalBoxType is attached using the IfcRelDefinesByType objectified relationship and is accessible by the IsTypedBy inverse attribute. 
/// If the IfcAirTerminalBoxType has ports or aggregated elements, such objects are reflected at the IfcAirTerminalBox occurrence using the IfcRelDefinesByObject relationship.
/// 
/// Property Use Definition
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute. 
/// Property sets may also be specified at the IfcAirTerminalBoxType, defining the common property data for all occurrences of the same type. 
/// They are then accessible by the IsTypedBy inverse attribute pointing to IfcAirTerminalBoxType.HasPropertySets. 
/// If both are given, then the properties directly defined at IfcAirTerminalBox override the properties defined at IfcAirTerminalBoxType. 
/// Refer to the documentation at the supertype IfcFlowController and ancestors for inherited property set definitions.
/// The following property set definitions are applicable to this entity:
/// Pset_AirTerminalBoxPHistory (PSET_PERFORMANCEDRIVEN)
/// Pset_AirTerminalBoxTypeCommon (PSET_TYPEDRIVENOVERRIDE)
/// 
/// Quantity Use Definition
/// The quantities relating to this entity are defined by IfcElementQuantity and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute.
/// The following base quantities are defined and shall be exchanged with the IfcElementQuantity.Name = 'BaseQuantities'. 
/// Other quantities, being subjected to local standard of measurement, may be defined with another string value assigned to Name. 
/// In this case a valid value for MethodOfMeasurement shall be provided. 
/// 
/// Qto_AirTerminalBoxBaseQuantities
/// 
/// Material Use Definition
/// The material of the IfcAirTerminalBox is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship. It is accessible by the HasAssociations inverse attribute. Material information can also be given at the IfcAirTerminalBoxType, defining the common attribute data for all occurrences of the same type. The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used:
/// 
/// Body: The primary material from which the object is constructed.
/// 
/// Port Use Definition
/// The distribution ports relating to the IfcAirTerminalBox are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship. 
///   If the air terminal box occurrence is defined by IfcAirTerminalBoxType, then the port occurrences must reflect those defined at the IfcAirTerminalBoxType using the IfcRelDefinesByObject relationship.
///   Ports are specific to the IfcAirTerminalBox PredefinedType as follows indicated by the IfcDistributionPort Name, PredefinedType, and FlowDirection:
/// 
/// Inlet (AIRCONDITIONING, SINK): Incoming air.
/// Outlet (AIRCONDITIONING, SOURCE): Outgoing regulated air.
class IFC_PARSE_API IfcAirTerminalBox : public IfcFlowController {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcAirTerminalBox
    bool hasPredefinedType() const;
    IfcAirTerminalBoxTypeEnum::IfcAirTerminalBoxTypeEnum PredefinedType() const;
    void setPredefinedType(IfcAirTerminalBoxTypeEnum::IfcAirTerminalBoxTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcFlowController::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcAirTerminalBoxTypeEnum; } return IfcFlowController::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "PredefinedType"; } return IfcFlowController::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcAirTerminalBox (IfcEntityInstanceData* e);
    IfcAirTerminalBox (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcAirTerminalBoxTypeEnum::IfcAirTerminalBoxTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcAirTerminalBox > list;
};
/// An air-to-air heat recovery device employs a counter-flow heat exchanger between inbound and outbound air flow. It is typically used to transfer heat from warmer air in one chamber to cooler air in the second chamber (i.e., typically used to recover heat from the conditioned air being exhausted and the outside air being supplied to a building), resulting in energy savings from reduced heating (or cooling) requirements. 
/// 
/// HISTORY  New entity in IFC2x4
/// 
/// Type Use Definition
/// IfcAirToAirHeatRecovery defines the occurrence of any air to air heat recovery; common information about air to air heat recovery types is handled by IfcAirToAirHeatRecoveryType. 
/// The IfcAirToAirHeatRecoveryType (if present) may establish the common type name, usage (predefined type), properties, materials, ports, composition, assignments, and representations. 
/// The IfcAirToAirHeatRecoveryType is attached using the IfcRelDefinesByType objectified relationship and is accessible by the IsTypedBy inverse attribute. 
/// If the IfcAirToAirHeatRecoveryType has ports or aggregated elements, such objects are reflected at the IfcAirToAirHeatRecovery occurrence using the IfcRelDefinesByObject relationship.
/// 
/// Property Use Definition
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute. 
/// Property sets may also be specified at the IfcAirToAirHeatRecoveryType, defining the common property data for all occurrences of the same type. 
/// They are then accessible by the IsTypedBy inverse attribute pointing to IfcAirToAirHeatRecoveryType.HasPropertySets. 
/// If both are given, then the properties directly defined at IfcAirToAirHeatRecovery override the properties defined at IfcAirToAirHeatRecoveryType. 
/// Refer to the documentation at the supertype IfcEnergyConversionDevice and ancestors for inherited property set definitions.
/// The following property set definitions are applicable to this entity:
/// Pset_AirToAirHeatRecoveryPHistory (PSET_PERFORMANCEDRIVEN)
/// Pset_AirToAirHeatRecoveryTypeCommon (PSET_TYPEDRIVENOVERRIDE)
/// 
/// Quantity Use Definition
/// The quantities relating to this entity are defined by IfcElementQuantity and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute.
/// The following base quantities are defined and shall be exchanged with the IfcElementQuantity.Name = 'BaseQuantities'. 
/// Other quantities, being subjected to local standard of measurement, may be defined with another string value assigned to Name. 
/// In this case a valid value for MethodOfMeasurement shall be provided. 
/// 
/// Qto_AirToAirHeatRecoveryBaseQuantities
/// 
/// Material Use Definition
/// The material of the IfcAirToAirHeatRecovery is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship. It is accessible by the HasAssociations inverse attribute. Material information can also be given at the IfcAirToAirHeatRecoveryType, defining the common attribute data for all occurrences of the same type. The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used:
/// 
/// Body: The primary material from which the object is constructed.
/// Media: The primary media material used for heat transfer.
/// 
/// Port Use Definition
/// The distribution ports relating to the IfcAirToAirHeatRecovery are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship. 
///   If the air to air heat recovery occurrence is defined by IfcAirToAirHeatRecoveryType, then the port occurrences must reflect those defined at the IfcAirToAirHeatRecoveryType using the IfcRelDefinesByObject relationship.
///   Ports are specific to the IfcAirToAirHeatRecovery PredefinedType as follows indicated by the IfcDistributionPort Name, PredefinedType, and FlowDirection:
/// 
/// AirInlet (AIRCONDITIONING, SINK): Cold air in.
/// AirOutlet (AIRCONDITIONING, SOURCE): Colder air out.
/// ExhaustInlet (VENTILATION, SINK): Hot return air in.
/// ExhaustOutlet (VENTILATION, SOURCE): Hotter return air out.
class IFC_PARSE_API IfcAirToAirHeatRecovery : public IfcEnergyConversionDevice {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcAirToAirHeatRecovery
    bool hasPredefinedType() const;
    IfcAirToAirHeatRecoveryTypeEnum::IfcAirToAirHeatRecoveryTypeEnum PredefinedType() const;
    void setPredefinedType(IfcAirToAirHeatRecoveryTypeEnum::IfcAirToAirHeatRecoveryTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcEnergyConversionDevice::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcAirToAirHeatRecoveryTypeEnum; } return IfcEnergyConversionDevice::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "PredefinedType"; } return IfcEnergyConversionDevice::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcAirToAirHeatRecovery (IfcEntityInstanceData* e);
    IfcAirToAirHeatRecovery (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcAirToAirHeatRecoveryTypeEnum::IfcAirToAirHeatRecoveryTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcAirToAirHeatRecovery > list;
};
/// The distribution control element type IfcAlarmType defines commonly shared information for occurrences of alarms.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a alarm specification (i.e. the specific product information, that is common to all occurrences of that product type).  Alarm types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcAlarmType are represented by instances of IfcAlarm. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcDistributionControlElementType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity: 
/// Pset_AlarmTypeCommon 
/// 
/// Material Use Definition 
/// The material of the IfcAlarmType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Casing': Material from which the casing is constructed. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcAlarmType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcAlarm for standard port definitions.
class IFC_PARSE_API IfcAlarmType : public IfcDistributionControlElementType {
public:
    /// Identifies the predefined types of alarm from which the type required may be set.
    IfcAlarmTypeEnum::IfcAlarmTypeEnum PredefinedType() const;
    void setPredefinedType(IfcAlarmTypeEnum::IfcAlarmTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcDistributionControlElementType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcAlarmTypeEnum; } return IfcDistributionControlElementType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcDistributionControlElementType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcAlarmType (IfcEntityInstanceData* e);
    IfcAlarmType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcAlarmTypeEnum::IfcAlarmTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcAlarmType > list;
};
/// An audio-visual appliance is a device that displays, captures, transmits, or receives audio or video.
/// Audio-visual appliances may be fixed in place or may be able to be moved from one space to another. They may require an electrical supply that may be supplied either by an electrical circuit or provided from a local battery source. Audio-visual appliances may be connected to data circuits including specialist circuits for audio visual purposes only. 
/// 
/// HISTORY  New entity in IFC2x4
/// 
/// Type Use Definition
/// IfcAudioVisualAppliance defines the occurrence of any audio visual appliance; common information about audio visual appliance types is handled by IfcAudioVisualApplianceType. 
/// The IfcAudioVisualApplianceType (if present) may establish the common type name, usage (predefined type), properties, materials, ports, composition, assignments, and representations. 
/// The IfcAudioVisualApplianceType is attached using the IfcRelDefinesByType objectified relationship and is accessible by the IsTypedBy inverse attribute. 
/// If the IfcAudioVisualApplianceType has ports or aggregated elements, such objects are reflected at the IfcAudioVisualAppliance occurrence using the IfcRelDefinesByObject relationship.
/// 
/// Property Use Definition
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute. 
/// Property sets may also be specified at the IfcAudioVisualApplianceType, defining the common property data for all occurrences of the same type. 
/// They are then accessible by the IsTypedBy inverse attribute pointing to IfcAudioVisualApplianceType.HasPropertySets. 
/// If both are given, then the properties directly defined at IfcAudioVisualAppliance override the properties defined at IfcAudioVisualApplianceType. 
/// Refer to the documentation at the supertype IfcFlowTerminal and ancestors for inherited property set definitions.
/// The following property set definitions are applicable to this entity:
/// (All Types)
/// 
/// Pset_AudioVisualAppliancePHistory (PSET_PERFORMANCEDRIVEN)
/// Pset_AudioVisualApplianceTypeCommon (PSET_TYPEDRIVENOVERRIDE)
/// 
/// AMPLIFIER
/// 
/// Pset_AudioVisualApplianceTypeAmplifier (PSET_TYPEDRIVENOVERRIDE)
/// 
/// CAMERA
/// 
/// Pset_AudioVisualApplianceTypeCamera (PSET_TYPEDRIVENOVERRIDE)
/// 
/// DISPLAY
/// 
/// Pset_AudioVisualApplianceTypeDisplay (PSET_TYPEDRIVENOVERRIDE)
/// 
/// PLAYER
/// 
/// Pset_AudioVisualApplianceTypePlayer (PSET_TYPEDRIVENOVERRIDE)
/// 
/// PROJECTOR
/// 
/// Pset_AudioVisualApplianceTypeProjector (PSET_TYPEDRIVENOVERRIDE)
/// 
/// RECEIVER
/// 
/// Pset_AudioVisualApplianceTypeReceiver (PSET_TYPEDRIVENOVERRIDE)
/// 
/// SPEAKER
/// 
/// Pset_AudioVisualApplianceTypeSpeaker (PSET_TYPEDRIVENOVERRIDE)
/// 
/// TUNER
/// 
/// Pset_AudioVisualApplianceTypeTuner (PSET_TYPEDRIVENOVERRIDE)
/// 
/// Quantity Use Definition
/// The quantities relating to this entity are defined by IfcElementQuantity and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute.
/// The following base quantities are defined and shall be exchanged with the IfcElementQuantity.Name = 'BaseQuantities'. 
/// Other quantities, being subjected to local standard of measurement, may be defined with another string value assigned to Name. 
/// In this case a valid value for MethodOfMeasurement shall be provided. 
/// 
/// Qto_AudioVisualApplianceBaseQuantities
/// 
/// Material Use Definition
/// The material of the IfcAudioVisualAppliance is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship. It is accessible by the HasAssociations inverse attribute. Material information can also be given at the IfcAudioVisualApplianceType, defining the common attribute data for all occurrences of the same type. The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used:
/// 
/// Casing: Material from which the casing is constructed.
/// 
/// Composition Use Definition
/// The IfcAudioVisualAppliance may be aggregated into components using IfcRelAggregates where RelatingObject refers to the enclosing IfcAudioVisualAppliance and RelatedObjects contains one or more components. Aggregation use is defined for the following predefined types:
/// 
/// May contain IfcAudioVisualAppliance components.
/// 
/// Port Use Definition
/// The distribution ports relating to the IfcAudioVisualAppliance are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship. 
///   If the audio visual appliance occurrence is defined by IfcAudioVisualApplianceType, then the port occurrences must reflect those defined at the IfcAudioVisualApplianceType using the IfcRelDefinesByObject relationship.
///   Ports are specific to the IfcAudioVisualAppliance PredefinedType as follows indicated by the IfcDistributionPort Name, PredefinedType, and FlowDirection:
/// 
/// AMPLIFIER
/// 
/// Power (ELECTRICAL, SINK): Receives electrical power.
/// Input (AUDIOVISUAL, SINK): Input audio.
/// Speakers (ELECTROACCOUSTIC, SOURCE): Audio speaker(s), which may be aggregated for separate speaker channels.
/// 
/// CAMERA
/// 
/// Power (ELECTRICAL, SINK): Receives electrical power.
/// Control (CONTROL, SINK): Receives control signal.
/// Network (DATA, SOURCE): Network access.
/// Output (AUDIOVISUAL, SOURCE): Captured video.
/// 
/// DISPLAY
/// 
/// Power (ELECTRICAL, SINK): Receives electrical power.
/// Control (CONTROL, SINK): Receives control signal.
/// Input#1 (AUDIOVISUAL, SINK): Input audio/video source.
/// Input#2 (AUDIOVISUAL, SINK): Input audio/video source.
/// Input#3 (AUDIOVISUAL, SINK): Input audio/video source.
/// Input#4 (AUDIOVISUAL, SINK): Input audio/video source.
/// Input#5 (AUDIOVISUAL, SINK): Input audio/video source.
/// Input#6 (AUDIOVISUAL, SINK): Input audio/video source.
/// Input#7 (AUDIOVISUAL, SINK): Input audio/video source.
/// Input#8 (AUDIOVISUAL, SINK): Input audio/video source.
/// 
/// MICROPHONE
/// 
/// Power (ELECTRICAL, SINK): Receives electrical power.
/// Output (AUDIOVISUAL, SOURCE): Captured audio.
/// 
/// PLAYER
/// 
/// Power (ELECTRICAL, SINK): Receives electrical power.
/// Control (CONTROL, SINK): Receives control signal.
/// Output (AUDIOVISUAL, SOURCE): Rendered media content.
/// 
/// PROJECTOR
/// 
/// Power (ELECTRICAL, SINK): Receives electrical power.
/// Control (CONTROL, SINK): Receives control signal.
/// Input (AUDIOVISUAL, SOURCE): Input audio/video source.
/// 
/// RECEIVER
/// 
/// Power (ELECTRICAL, SINK): Receives electrical power.
/// Control (CONTROL, SINK): Receives control signal.
/// Network (DATA, SOURCE): Network access.
/// Input#1 (AUDIOVISUAL, SINK): Input audio/video source.
/// Input#2 (AUDIOVISUAL, SINK): Input audio/video source.
/// Input#3 (AUDIOVISUAL, SINK): Input audio/video source.
/// Input#4 (AUDIOVISUAL, SINK): Input audio/video source.
/// Input#5 (AUDIOVISUAL, SINK): Input audio/video source.
/// Input#6 (AUDIOVISUAL, SINK): Input audio/video source.
/// Input#7 (AUDIOVISUAL, SINK): Input audio/video source.
/// Input#8 (AUDIOVISUAL, SINK): Input audio/video source.
/// Output#1 (AUDIOVISUAL, SOURCE): Output audio/video zone.
/// Output#2 (AUDIOVISUAL, SOURCE): Output audio/video zone.
/// Speakers#1 (ELECTROACCOUSTIC, SOURCE): Audio speaker(s), which may be aggregated for separate speaker channels.
/// Speakers#2 (ELECTROACCOUSTIC, SOURCE): Audio speaker(s), which may be aggregated for separate speaker channels.
/// 
/// SPEAKER
/// 
/// Input (ELECTROACCOUSTIC, SINK): Amplified audio input.
/// 
/// SWITCHER
/// 
/// Power (ELECTRICAL, SINK): Receives electrical power.
/// Control (CONTROL, SINK): Receives control signal.
/// Network (DATA, SOURCE): Network access.
/// Input#1 (AUDIOVISUAL, SINK): Input audio/video source.
/// Input#2 (AUDIOVISUAL, SINK): Input audio/video source.
/// Input#3 (AUDIOVISUAL, SINK): Input audio/video source.
/// Input#4 (AUDIOVISUAL, SINK): Input audio/video source.
/// Input#5 (AUDIOVISUAL, SINK): Input audio/video source.
/// Input#6 (AUDIOVISUAL, SINK): Input audio/video source.
/// Input#7 (AUDIOVISUAL, SINK): Input audio/video source.
/// Input#8 (AUDIOVISUAL, SINK): Input audio/video source.
/// Output#1 (AUDIOVISUAL, SOURCE): Output audio/video zone.
/// Output#2 (AUDIOVISUAL, SOURCE): Output audio/video zone.
/// Output#3 (AUDIOVISUAL, SOURCE): Output audio/video zone.
/// Output#4 (AUDIOVISUAL, SOURCE): Output audio/video zone.
/// Output#5 (AUDIOVISUAL, SOURCE): Output audio/video zone.
/// Output#6 (AUDIOVISUAL, SOURCE): Output audio/video zone.
/// Output#7 (AUDIOVISUAL, SOURCE): Output audio/video zone.
/// Output#8 (AUDIOVISUAL, SOURCE): Output audio/video zone.
/// 
/// TELEPHONE
/// 
/// Power (ELECTRICAL, SINK): Receives electrical power.
/// Phone (TELEPHONE, SINK): Telecommunications network.
/// 
/// TUNER
/// 
/// Power (ELECTRICAL, SINK): Receives electrical power.
/// Control (CONTROL, SINK): Receives control signal.
/// Input (TV, SINK): Receives modulated data feed such as satellite, cable, or over-the-air.
/// Output (AUDIOVISUAL, SOURCE): Rendered media content.
class IFC_PARSE_API IfcAudioVisualAppliance : public IfcFlowTerminal {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcAudioVisualAppliance
    bool hasPredefinedType() const;
    IfcAudioVisualApplianceTypeEnum::IfcAudioVisualApplianceTypeEnum PredefinedType() const;
    void setPredefinedType(IfcAudioVisualApplianceTypeEnum::IfcAudioVisualApplianceTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcFlowTerminal::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcAudioVisualApplianceTypeEnum; } return IfcFlowTerminal::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "PredefinedType"; } return IfcFlowTerminal::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcAudioVisualAppliance (IfcEntityInstanceData* e);
    IfcAudioVisualAppliance (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcAudioVisualApplianceTypeEnum::IfcAudioVisualApplianceTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcAudioVisualAppliance > list;
};
/// Definition from ISO 6707-1:1989: Structural member designed to carry loads between or beyond points of support, usually narrow in relation to its length and horizontal or nearly so.
/// 
/// An IfcBeam is a horizontal, or nearly horizontal, structural member that is capable of withstanding load primarily by resisting bending. It represents such a member from an architectural point of view. It is not required to be load bearing.
/// 
/// NOTE  The representation of a beam in a structural analysis model is provided by
/// IfcStructuralCurveMember being part of an IfcStructuralAnalysisModel.
/// 
/// NOTE  For any longitudial structural member, not constrained to be predominately horizontal nor vertical, or where this semantic information is irrelevant, the entity IfcMember should be used.
/// 
/// The IFC specification provides two entities for beam occurrences:
/// 
/// IfcBeamStandardCase used for all occurrences of beams, that have a profile defined that is swept along a directrix. The profile might be changed uniformly by a taper definition along the directrix. The profile parameter and its cardinal point of insertion can be fully described by the IfcMaterialProfileSetUsage. These beams are always represented geometricly by an 'Axis' and a 'SweptSolid' or 'AdvancedSweptSolid' shape representation (or by a 'Clipping' geometry based on the swept solid), if a 3D geometric representation is assigned. In addition they have to have a corresponding IfcMaterialProfileSetUsage assigned.
/// NOTE  View definitions and implementer agreements may further constrain the applicable geometry types, for example, by excluding tapering from an IfcBeamStandardCase implementation.
/// 
/// IfcBeam used for all other occurrences of beams, particularly for beams with changing profile sizes along the extrusion, or beams defined by non-linear extrusion, or beams having only 'Brep', or 'SurfaceModel' geometry.
/// 
/// HISTORY New entity in IFC Release 1.0
/// 
/// Type Use Definition
/// IfcBeam defines the occuurence of any beam, common
/// information about beam types (or styles) is handled by
/// IfcBeamType. The IfcBeamType (if present) may
/// establish the common type name, usage (or predefined) type,
/// common material layer set, common set of properties and common
/// shape representations (using IfcRepresentationMap). The
/// IfcBeamType is attached using the
/// IfcRelDefinedByType.RelatingType objectified relationship
/// and is accessible by the inverse IsTypedBy attribute.
/// If no IfcBeamType is attached (i.e. if only occurrence
/// information is given) the PredefinedType should be provided.
/// If set to .USERDEFINED. a user defined value can be provided by the
/// ObjectType attribute.
/// Material Use Definition
/// The material of the IfcBeam is defined by the
/// IfcMaterialProfileSet or as fallback by IfcMaterial
/// and attached by the
/// IfcRelAssociatesMaterial.RelatingMaterial. It is
/// accessible by the inverse HasAssociations relationship.
/// Note It is illegal to assign an
/// IfcMaterialProfileSetUsage to an IfcBeam. Only the
/// subtype IfcBeamStandardCase supports this
/// concept.
/// Material information can also be given at the
/// IfcBeamType, defining the common attribute data for all
/// occurrences of the same type. It is then accessible by the inverse
/// IsTypedBy relationship pointing
/// to IfcBeamType.HasAssociations and via
/// IfcRelAssociatesMaterial.RelatingMaterial to
/// IfcMaterialProfileSet or IfcMaterial. If both are
/// given, then the material directly assigned to IfcBeam
/// overrides the material assigned to IfcBeamType.
/// Property Set Use Definition
/// The property sets relating to the IfcBeam are defined by
/// the IfcPropertySet and attached by the
/// IfcRelDefinesByProperties relationship. It is accessible by
/// the inverse IsDefinedBy relationship. The following property
/// set definitions specific to the IfcBeam are part of this IFC
/// release:
/// 
/// Pset_BeamCommon: common property set for all
/// beam occurrences
/// 
/// Property sets can also be given at the IfcBeamType,
/// defining the common property data for all occurrences of the same
/// type. It is then accessible by the inverse IsTypedBy relationship pointing to
/// IfcBeamType.HasPropertySets. If both are given, then the
/// properties directly assigned to IfcBeam overrides the
/// properties assigned to IfcBeamType.
/// Quantity Use Definition
/// The quantities relating to the IfcBeam are defined by the
/// IfcElementQuantity and attached by the
/// IfcRelDefinesByProperties relationship. It is accessible by
/// the inverse IsDefinedBy relationship. The following base
/// quantities are defined and should be exchanged with the
/// IfcElementQuantity.Name = 'BaseQuantities'. Other quantities
/// can be defined being subjected to local standard of measurement
/// with another string value assigned to MethodOfMeasurement.
/// Quanties shall be never assigned to the IfcBeamType.
/// 
/// Qto_BeamBaseQuantities: base quantities for all
/// beam occurrences.
/// 
/// Containment Use Definition
/// The IfcBeam, as any subtype of IfcBuildingElement,
/// may participate in two different containment relationships. The
/// first (and in most implementation scenarios mandatory) relationship
/// is the hierachical spatial containment, the second (optional)
/// relationship is the aggregation within an element assembly.
/// 
/// The IfcBeam is places within the project spatial
/// hierarchy using the objectified relationship
/// IfcRelContainedInSpatialStructure, refering to it by its
/// inverse attribute SELF\IfcElement.ContainedInStructure.
/// Subtypes of IfcSpatialStructureElement are valid spatial
/// containers, with IfcBuildingStorey being the default
/// container.
/// The IfcBeam may be aggregated into an element assembly
/// using the objectified relationship IfcRelAggregates,
/// refering to it by its inverse attribute
/// SELF\IfcObjectDefinition.Decomposes. Any subtype of
/// IfcElement can be an element assembly, with
/// IfcElementAssembly as a special focus subtype. In this case
/// it should not be additionally contained in the project spatial
/// hierarchy, i.e. SELF\IfcElement.ContainedInStructure should
/// be NIL.
/// 
/// Geometry Use Definition
/// The geometric representation of IfcBeam is given by the
/// IfcProductDefinitionShape, allowing multiple geometric
/// representations. Included are:
/// Local Placement
/// The local placement for IfcBeam is defined in its
/// supertype IfcProduct. It is defined by the
/// IfcLocalPlacement, which defines the local coordinate system
/// that is referenced by all geometric representations.
/// 
/// The PlacementRelTo relationship of
/// IfcLocalPlacement shall point (if given) to the local
/// placement of the same IfcSpatialStructureElement, which is
/// used in the ContainedInStructure inverse attribute, or to a
/// spatial structure element at a higher level, referenced by that.
/// 
/// Exception: If the IfcBeam is part of an assembly, the
/// PlacementRelTo relationship of IfcLocalPlacement
/// shall point to the local placement of the container element, e.g.
/// IfcElementAssembly,
/// 
/// If the relative placement is not used, the absolute placement
/// is defined within the world coordinate system.
/// 
/// Geometric Representation
/// Currently, the 'Axis', 'Body', and
/// 'Box' representations are supported. The 'Box' representation
/// includes the representation type 'BoundingBox' and is explained at
/// IfcBuildingElement.
/// Axis Representation
/// The axis geometric representation of IfcBeam is defined
/// using the 'Axis' representation.
/// 
/// RepresentationIdentifier : 'Axis'
/// RepresentationType : 'Curve2D', 'Curve3D'
/// 
/// The 'Axis' can be used to represent the system
/// axis and length of a beam that may extent the body
/// length.
/// Body Representation
/// The body representation of IfcBeam can be represented
/// using the representation types 'SweptSolid', 'Clipping',
/// 'AdvancedSweptSolid', 'MappedRepresentation', 'SurfaceModel', and
/// 'Brep'. The representation types 'SurfaceModel' and 'Brep' are
/// explained at IfcBuildingElement.
/// SweptSolid Representation Type
/// The following attribute values for the
/// IfcShapeRepresentation holding this geometric representation
/// shall be used:
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'SweptSolid'
/// 
/// The following additional constraints apply to the 'SweptSolid'
/// representation type:
/// 
/// Solid: IfcExtrudedAreaSolid,
/// IfcRevolvedAreaSolid shall be supported
/// Profile: all subtypes of IfcProfileDef (with
/// exception of IfcArbitraryOpenProfileDef)
/// Extrusion:  All extrusion directions shall be
/// supported.
/// 
/// Figure 71 illustrates the 'SweptSolid' geometric representation.  There are no restrictions or conventions on how to use the local placement (black), solid of extrusion placement (red) and profile placement (green).
/// 
/// Figure 71 — Beam swept solid
/// 
/// Figure 72 illustrates the use of non-perpendicular extrusion to create the IfcExtrudedAreaSolid.
/// 
/// Figure 72 — Beam non-perpendicular extrusion
/// 
/// Clipping Representation Type
/// The following attribute values for the
/// IfcShapeRepresentation holding this geometric representation
/// shall be used:
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'Clipping'
/// 
/// The following constraints apply to the advanced
/// representation:
/// 
/// Solid: see 'SweptSolid' geometric representation
/// Profile: see 'SweptSolid' geometric representation
/// Extrusion: see 'SweptSolid' geometric
/// representation
/// Boolean result: The IfcBooleanClippingResult
/// shall be supported, allowing for Boolean differences between the
/// swept solid (here IfcExtrudedAreaSolid) and one or several
/// IfcHalfSpaceSolid (or its subtypes).
/// 
/// Figure 73 illustrates use of IfcBooleanClippingResult between an IfcExtrudedAreaSolid and an IfcHalfSpaceSolid to create a clipped body.
/// 
/// Figure 73 — Beam clipping
/// 
/// AdvancedSweptSolid Representation Type
/// The following attribute values for the
/// IfcShapeRepresentation holding this geometric representation
/// shall be used:
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'AdvancedSweptSolid'
/// 
/// The following additional constraints apply to the
/// 'AdvancedSweptSolid' representation type:
/// 
/// Solid: IfcSurfaceCurveSweptAreaSolid,
/// IfcFixedReferenceSweptAreaSolid,
/// IfcExtrudedAreaSolidTapered,
/// IfcRevolvedAreaSolidTapered shall be supported.
/// NOTE View definitions and implementer agreement
/// can further constrain the allowed swept solid
/// types.
/// 
/// Profile: see 'SweptSolid' geometric representation
/// Extrusion: not applicable
/// 
/// MappedRepresentation Representation Type
/// The 'MappedRepresentation' representation is supported as it
/// allows for reusing the geometry definition of the beam type at all
/// occurrences of the same type. The following attribute values for
/// the IfcShapeRepresentation holding this geometric
/// representation shall be used:
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'MappedRepresentation'
/// 
/// The same constraints, as given for the 'SweptSolid', 'Clipping',
/// 'AdvancedSweptSolid', 'SurfaceModel', and 'Brep' geometric
/// representation, shall apply to the MappedRepresentation of
/// the IfcRepresentationMap.
class IFC_PARSE_API IfcBeam : public IfcBuildingElement {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcBeam
    bool hasPredefinedType() const;
    /// Predefined generic type for a beam that is specified in an enumeration. There may be a property set given specificly for the predefined types.
    ///   NOTE The PredefinedType shall only be used, if no type object IfcBeamType is assigned, providing its own IfcBeamType.PredefinedType.
    /// 
    /// IFC2x4 CHANGE  The attribute has been added at the end of the entity definition.
    IfcBeamTypeEnum::IfcBeamTypeEnum PredefinedType() const;
    void setPredefinedType(IfcBeamTypeEnum::IfcBeamTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcBuildingElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcBeamTypeEnum; } return IfcBuildingElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "PredefinedType"; } return IfcBuildingElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcBeam (IfcEntityInstanceData* e);
    IfcBeam (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcBeamTypeEnum::IfcBeamTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcBeam > list;
};
/// The standard beam,
/// IfcBeamStandardCase, defines a beam with certain constraints
/// for the provision of material usage, parameters and with certain
/// constraints for the geometric representation. The
/// IfcBeamStandardCase handles all cases of beams, that:
/// 
/// have a reference to the IfcMaterialProfileSetUsage
/// defining the material profile association of the beam with the
/// cardinal point of its insertion relative to the local
/// placement.
/// are consistent in using the correct cardinal point offset of
/// the profile as compared to the 'Axis' and 'Body' shape
/// representation
/// are based on a sweep of a planar profile, or set of profiles,
/// as defined by the IfcMaterialProfileSet
/// have an 'Axis' shape representation with constraints provided
/// below in the geometry use definition
/// have a 'Body' shape representation with constraints provided
/// below in the geometry use definition
/// 
/// are extruded perpendicular to the profile definition plane
/// have a start profile, or set of profiles, that is swept
/// the sweeping operation can be linear extrusion, circular
/// rotation, or a sweep along a directrix
/// the start profile, or set of profiles can be swept unchanged,
/// or might be changed uniformly by a taper definition
/// 
/// NOTE  View definitions and implementer
/// agreements may further constrain the applicable geometry types,
/// e.g. by excluding tapering from an IfcBeamStandardCase
/// implementation.
/// 
/// HISTORY New entity in IFC2x4.
/// 
/// Type Use Definition
/// IfcBeam defines the occurrence of any beam, common
/// information about beam types (or styles) is handled by
/// IfcBeamType. The IfcBeamType (if present) may
/// establish the common type name, usage (or predefined) type, common
/// set of properties, and common material profile set (combining
/// profiles and material of profile). The IfcBeamType is
/// attached using the IfcRelDefinedByType.RelatingType
/// objectified relationship and is accessible by the inverse
/// IsTypedBy attribute.
/// The IfcBeamStandardCase defines in addition that the
/// IfcBeamType should have a unique
/// IfcMaterialProfileSet, that is referenced by the
/// IfcMaterialProfileSetUsage that is assigned to all
/// occurrences of this beam type.
/// 
/// Figure 74 illustrates assignment of IfcMaterialProfileSetUsage and IfcMaterialProfileSet to the IfcBeamStandardCase as the beam occurrence and to the IfcBeamType. The same IfcMaterialProfileSet shall be shared by many occurrences of IfcMaterialProfileSetUsage. This relationship shall be consistent to the relationship between the IfcBeamType and the IfcBeamStandardCase.
/// 
/// Figure 74 — Beam profile usage
/// 
/// Figure 75 illustrates alignment of cardinal points.
/// NOTE  It has to be guaranteed that the use of IfcCardinalPointEnum is consistent to the placement of the extrusion body provided by IfcExtrudedAreaSolid.Position
/// NOTE  The cardinal points 8 (top centre) and 6 (mid-depth right) are assigned according to the definition at IfcCardinalPointReference
/// 
/// Figure 75 — Beam cardinal points
/// 
/// Figure 76 illustrates assignment of a composite profile by using IfcCompositeProfile for geometric representation and several IfcMaterialProfile's within the IfcMaterialProfileSet.
/// 
/// Figure 76 — Beam composite profiles
/// 
/// Material Use Definition
/// The material of the IfcBeamStandardCase is defined by
/// IfcMaterialProfileSetUsage and attached by the
/// IfcRelAssociatesMaterial.RelatingMaterial. It is
/// accessible by the inverse HasAssociations relationship.
/// Composite profile beams can be represented by refering to several
/// IfcMaterialProfile's within the IfcMaterialProfileSet
/// that is referenced from the IfcMaterialProfileSetUsage. See
/// Type Use Definition for additional agreements for material
/// assignement to IfcBeamStandardCase and
/// IfcBeamType.
/// Property Set Use Definition:
/// The property sets relating to the IfcBeamStandardCase are
/// defined at the supertype IfcBeam.
/// Quantity Use Definition
/// The quantities relating to the IfcBeamStandardCase are
/// defined at the supertype IfcBeam.
/// Containment Use Definition
/// The containment use definitions relating to the
/// IfcBeamStandardCase are defined at the supertype
/// IfcBeam.
/// Geometry Use Definitions:
/// The geometric representation of IfcBeamStandardCase is
/// given by the IfcProductDefinitionShape, allowing multiple
/// geometric representations. Included are:
/// Local Placement
/// The general use of local placement is defined at the supertype
/// IfcBeam. The following restriction is imposed:
/// 
/// The local placement shall provide the location and directions
/// for the standard beam, the x/y plane is the plane for the start
/// profile, and the z-axis is the extrusion axis for the beam body (in
/// case of rotation, the tangent direction).
/// 
/// Geometric Representations
/// The geometric representation of IfcBeamStandardCase is
/// defined using the following multiple shape representations for its
/// definition:
/// 
/// Axis: A three dimensional open curve (subtype of
/// IfcBoundedCurve) defining the axis for the standard beam.
/// The cardinal point is determined by the beam axis.
/// Body: A Swept Solid Representation or a CSG clipping
/// representation defining the 3D shape of the standard beam.
/// 
/// NOTE It is invalid to exchange a 'SurfaceModel',
/// 'Brep', or 'MappedRepresentation' representation for the 'Body'
/// shape representation of an
/// IfcBeamStandardCase.
/// Axis Representation
/// The axis geometric representation of IfcBeamStandardCase
/// is defined using the 'Axis' representation. The following attribute
/// values for the IfcShapeRepresentation holding this geometric
/// representation shall be used:
/// 
/// RepresentationIdentifier : 'Axis'
/// RepresentationType : 'Curve3D'
/// 
/// The following additional constraints apply to the 'Axis'
/// representation, if the 'Body' shape representation has the
/// RepresentationType : 'SweptSolid':
/// 
/// Axis :
/// 
/// IfcPolyline having two Points, or
/// IfcTrimmedCurve with BasisCurve of Type
/// IfcLine for 'SweptSolid' provided as
/// IfcExtrudedAreaSolid. The axis curve lies on the z axis of
/// the object coordinate system.
/// IfcTrimmedCurve with BasisCurve of Type
/// IfcCircle for 'SweptSolid' provided as
/// IfcRevolvedAreaSolid. The axis curve lies on the x/z plane
/// of the object coordinate system, the tangent at the start is along
/// the positive z-axis.
/// 
/// As shown in Figure 77, the axis shall be defined along the z axis of the object coordinate system. The axis representation can be used to represent the system length of a beam that may extent the body length of the beam.
/// 
/// Figure 77 — Beam axis representation
/// 
/// As shown in Figure 78, the axis representation shall be used to represent the cardinal point as the offset between the 'Axis' and the extrusion path of the beam. The extrusion path is provided as IfcExtrudedAreaSolid.ExtrudedDirection and should be parallel to the 'Axis' and the z axis. It has to be guaranteed that the value provided by
/// IfcMaterialProfileSetUsage.CardinalPoint is consistent to the IfcExtrudedAreaSolid.Position.
/// 
/// Figure 78 — Beam axis cardinal point
/// 
/// Body Representation
/// The body representation of IfcBeamStandardCase can be
/// represented using the representation types 'SweptSolid',
/// 'Clipping', or 'AdvancedSweptSolid'.
/// SweptSolid Representation Type
/// The following attribute values for the
/// IfcShapeRepresentation holding this geometric representation
/// shall be used:
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'SweptSolid'
/// 
/// The following additional constraints apply to the 'SweptSolid'
/// representation:
/// 
/// Solid: IfcExtrudedAreaSolid,
/// IfcRevolvedAreaSolid shall be supported
/// Solid Position : The IfcSweptAreaSolid.Position
/// shall exclusively been used to correspond to the cardinal point.
/// The x/y offset of the Position represents the cardinal
/// point offset of the profile against the axis. No rotation shall be
/// allowed.
/// Profile: All subtypes of
/// IfcParameterizedProfileDef
/// Profile Position : For all single profiles, the
/// IfcParameterizedProfileDef.Position shall be NIL, or having
/// Location = 0.,0. and RefDirection = 1.,0.
/// Extrusion: Perpendicular to the profile direction.
/// The IfcExtrudedAreaSolid.ExtrudedDirection shall be
/// [0.,0.,1.].
/// Orientation: The y-axis of the profile, as determined by
/// IfcSweptAreaSolid.Position.P[2] shall point upwards. It
/// indicates the "role" of the beam, a role=0° means y-axis of
/// profile pointing upwards.
/// 
/// Figure 79 illustrates a standard geometric representation with cardinal point applied as 1 (bottom left).
/// The following interpretation of dimension parameter applies for rectangular beams with linear extrusions:
/// 
/// IfcRectangleProfileDef.YDim interpreted as beam height
/// IfcRectangleProfileDef.XDim interpreted as beam width
/// 
/// The following interpretation of dimension parameter applies for circular beams:
/// 
/// IfcCircleProfileDef.Radius interpreted as beam radius.
/// 
/// Figure 79 — Beam body extrusion
/// 
/// Clipping Representation Type
/// The following attribute values for the
/// IfcShapeRepresentation holding this geometric representation
/// shall be used:
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'Clipping'
/// 
/// The following constraints apply to the 'Clipping'
/// representation:
/// 
/// Solid : see 'SweptSolid' geometric representation
/// Solid Position : see 'SweptSolid' geometric
/// representation
/// Profile : see 'SweptSolid' geometric representation
/// Profile Position : see 'SweptSolid' geometric
/// representation
/// Extrusion : see 'SweptSolid' geometric
/// representation
/// Orientation : see 'SweptSolid' geometric
/// representation
/// Boolean result: The IfcBooleanClippingResult
/// shall be supported, allowing for Boolean differences between the
/// swept solid (here IfcExtrudedAreaSolid) and one or several
/// IfcHalfSpaceSolid (or its subtypes).
/// 
/// Figure 80 illustrates a 'Clipping' geometric representation with use of IfcBooleanClippingResult between an IfcExtrudedAreaSolid and an IfcHalfSpaceSolid to create a clipped body, with cardinal point applied as 4 (mid-depth left)
/// 
/// Figure 80 — Beam body clipping
/// 
/// AdvancedSweptSolid Representation Type
/// The 'AdvancedSweptSolid' representation type is a valid body
/// representation of IfcBeamStandardCase. The following
/// attribute values for the IfcShapeRepresentation holding this
/// geometric representation shall be used:
/// 
/// RepresentationIdentifier : 'Body'
/// RepresentationType : 'AdvancedSweptSolid'
/// 
/// The following additional constraints apply to the
/// 'AdvancedSweptSolid' representation type:
/// 
/// Solid: IfcSurfaceCurveSweptAreaSolid,
/// IfcFixedReferenceSweptAreaSolid,
/// IfcExtrudedAreaSolidTapered,
/// IfcRevolvedAreaSolidTapered shall be supported.
/// NOTE View definitions and implementer agreement
/// can further constrain the allowed swept solid
/// types.
/// 
/// Solid Position : see 'SweptSolid' geometric
/// representation
/// Profile: see 'SweptSolid' geometric representation
/// Profile Position : see 'SweptSolid' geometric
/// representation
/// Extrusion: not applicable
class IFC_PARSE_API IfcBeamStandardCase : public IfcBeam {
public:
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcBeam::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcBeam::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcBeam::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcBeamStandardCase (IfcEntityInstanceData* e);
    IfcBeamStandardCase (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcBeamTypeEnum::IfcBeamTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcBeamStandardCase > list;
};
/// A boiler is a closed, pressure-rated vessel in which water or other fluid is heated using an energy source such as natural gas, heating oil, or electricity. The fluid in the vessel is then circulated out of the boiler for use in various processes or heating applications.
/// IfcBoiler is a vessel solely used for heating of water or other fluids. Storage vessels, such as for drinking water storage are considered as tanks and use the IfcTank entity. 
/// 
/// HISTORY  New entity in IFC2x4
/// 
/// Type Use Definition
/// IfcBoiler defines the occurrence of any boiler; common information about boiler types is handled by IfcBoilerType. 
/// The IfcBoilerType (if present) may establish the common type name, usage (predefined type), properties, materials, ports, composition, assignments, and representations. 
/// The IfcBoilerType is attached using the IfcRelDefinesByType objectified relationship and is accessible by the IsTypedBy inverse attribute. 
/// If the IfcBoilerType has ports or aggregated elements, such objects are reflected at the IfcBoiler occurrence using the IfcRelDefinesByObject relationship.
/// Figure 212 illustrates boiler type use.
/// Figure 212 — Boiler type use
/// 
/// Property Use Definition
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute. 
/// Property sets may also be specified at the IfcBoilerType, defining the common property data for all occurrences of the same type. 
/// They are then accessible by the IsTypedBy inverse attribute pointing to IfcBoilerType.HasPropertySets. 
/// If both are given, then the properties directly defined at IfcBoiler override the properties defined at IfcBoilerType. 
/// Refer to the documentation at the supertype IfcEnergyConversionDevice and ancestors for inherited property set definitions.
/// The following property set definitions are applicable to this entity:
/// (All Types)
/// 
/// Pset_BoilerPHistory (PSET_PERFORMANCEDRIVEN)
/// Pset_BoilerTypeCommon (PSET_TYPEDRIVENOVERRIDE)
/// 
/// STEAM
/// 
/// Pset_BoilerTypeSteam (PSET_TYPEDRIVENOVERRIDE)
/// 
/// WATER
/// 
/// Pset_BoilerTypeWater (PSET_TYPEDRIVENOVERRIDE)
/// 
/// Quantity Use Definition
/// The quantities relating to this entity are defined by IfcElementQuantity and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute.
/// The following base quantities are defined and shall be exchanged with the IfcElementQuantity.Name = 'BaseQuantities'. 
/// Other quantities, being subjected to local standard of measurement, may be defined with another string value assigned to Name. 
/// In this case a valid value for MethodOfMeasurement shall be provided. 
/// 
/// Qto_BoilerBaseQuantities
/// 
/// Material Use Definition
/// The material of the IfcBoiler is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship. It is accessible by the HasAssociations inverse attribute. Material information can also be given at the IfcBoilerType, defining the common attribute data for all occurrences of the same type. The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used:
/// 
/// Body: The primary material from which the object is constructed.
/// 
/// Port Use Definition
/// The distribution ports relating to the IfcBoiler are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship. 
///   If the boiler occurrence is defined by IfcBoilerType, then the port occurrences must reflect those defined at the IfcBoilerType using the IfcRelDefinesByObject relationship.
///   Ports are specific to the IfcBoiler PredefinedType as follows indicated by the IfcDistributionPort Name, PredefinedType, and FlowDirection:
/// 
/// STEAM
/// 
/// Gas (GAS, SINK): Gas inlet for burner.
/// Exhaust (EXHAUST, SOURCE): Exhaust sent to chimney.
/// Condenser (CONDENSERWATER, SOURCE): Water feed such as from condenser.
/// Heating (HEATING, SOURCE): Steam sent to heating coils and space heaters.
/// 
/// WATER
/// 
/// Gas (GAS, SINK): Gas inlet for burner.
/// Exhaust (EXHAUST, SOURCE): Exhaust sent to chimney.
/// ColdWater (DOMESTICCOLDWATER, SINK): Cold water to be heated.
/// HotWater (DOMESTICHOTWATER, SOURCE): Hot water heated.
/// 
/// Figure 213 illustrates boiler port use.
/// Figure 213 — Boiler port use
class IFC_PARSE_API IfcBoiler : public IfcEnergyConversionDevice {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcBoiler
    bool hasPredefinedType() const;
    IfcBoilerTypeEnum::IfcBoilerTypeEnum PredefinedType() const;
    void setPredefinedType(IfcBoilerTypeEnum::IfcBoilerTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcEnergyConversionDevice::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcBoilerTypeEnum; } return IfcEnergyConversionDevice::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "PredefinedType"; } return IfcEnergyConversionDevice::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcBoiler (IfcEntityInstanceData* e);
    IfcBoiler (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcBoilerTypeEnum::IfcBoilerTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcBoiler > list;
};
/// A burner is a device that converts fuel into heat through combustion. It includes gas, oil, and wood burners. 
/// 
/// HISTORY  New entity in IFC2x4
/// 
/// Type Use Definition
/// IfcBurner defines the occurrence of any burner; common information about burner types is handled by IfcBurnerType. 
/// The IfcBurnerType (if present) may establish the common type name, usage (predefined type), properties, materials, ports, composition, assignments, and representations. 
/// The IfcBurnerType is attached using the IfcRelDefinesByType objectified relationship and is accessible by the IsTypedBy inverse attribute. 
/// If the IfcBurnerType has ports or aggregated elements, such objects are reflected at the IfcBurner occurrence using the IfcRelDefinesByObject relationship.
/// 
/// Property Use Definition
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute. 
/// Property sets may also be specified at the IfcBurnerType, defining the common property data for all occurrences of the same type. 
/// They are then accessible by the IsTypedBy inverse attribute pointing to IfcBurnerType.HasPropertySets. 
/// If both are given, then the properties directly defined at IfcBurner override the properties defined at IfcBurnerType. 
/// Refer to the documentation at the supertype IfcEnergyConversionDevice and ancestors for inherited property set definitions.
/// The following property set definitions are applicable to this entity:
/// Pset_BurnerTypeCommon (PSET_TYPEDRIVENOVERRIDE)
/// 
/// Quantity Use Definition
/// The quantities relating to this entity are defined by IfcElementQuantity and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute.
/// The following base quantities are defined and shall be exchanged with the IfcElementQuantity.Name = 'BaseQuantities'. 
/// Other quantities, being subjected to local standard of measurement, may be defined with another string value assigned to Name. 
/// In this case a valid value for MethodOfMeasurement shall be provided. 
/// 
/// Qto_BurnerBaseQuantities
/// 
/// Material Use Definition
/// The material of the IfcBurner is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship. It is accessible by the HasAssociations inverse attribute. Material information can also be given at the IfcBurnerType, defining the common attribute data for all occurrences of the same type. The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used:
/// 
/// Body: The primary material from which the object is constructed.
/// Fuel: Material designed to be burned.
/// 
/// Port Use Definition
/// The distribution ports relating to the IfcBurner are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship. 
///   If the burner occurrence is defined by IfcBurnerType, then the port occurrences must reflect those defined at the IfcBurnerType using the IfcRelDefinesByObject relationship.
///   Ports are specific to the IfcBurner PredefinedType as follows indicated by the IfcDistributionPort Name, PredefinedType, and FlowDirection:
/// 
/// Gas (GAS, SINK): Gas inlet for burner.
class IFC_PARSE_API IfcBurner : public IfcEnergyConversionDevice {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcBurner
    bool hasPredefinedType() const;
    IfcBurnerTypeEnum::IfcBurnerTypeEnum PredefinedType() const;
    void setPredefinedType(IfcBurnerTypeEnum::IfcBurnerTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcEnergyConversionDevice::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcBurnerTypeEnum; } return IfcEnergyConversionDevice::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "PredefinedType"; } return IfcEnergyConversionDevice::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcBurner (IfcEntityInstanceData* e);
    IfcBurner (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcBurnerTypeEnum::IfcBurnerTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcBurner > list;
};
/// A cable carrier fitting is a fitting that is placed at junction or transition in a cable carrier system. 
/// 
/// HISTORY  New entity in IFC2x4
/// 
/// Type Use Definition
/// IfcCableCarrierFitting defines the occurrence of any cable carrier fitting; common information about cable carrier fitting types is handled by IfcCableCarrierFittingType. 
/// The IfcCableCarrierFittingType (if present) may establish the common type name, usage (predefined type), properties, materials, ports, composition, assignments, and representations. 
/// The IfcCableCarrierFittingType is attached using the IfcRelDefinesByType objectified relationship and is accessible by the IsTypedBy inverse attribute. 
/// If the IfcCableCarrierFittingType has ports or aggregated elements, such objects are reflected at the IfcCableCarrierFitting occurrence using the IfcRelDefinesByObject relationship.
/// 
/// Property Use Definition
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute. 
/// Property sets may also be specified at the IfcCableCarrierFittingType, defining the common property data for all occurrences of the same type. 
/// They are then accessible by the IsTypedBy inverse attribute pointing to IfcCableCarrierFittingType.HasPropertySets. 
/// If both are given, then the properties directly defined at IfcCableCarrierFitting override the properties defined at IfcCableCarrierFittingType. 
/// Refer to the documentation at the supertype IfcFlowFitting and ancestors for inherited property set definitions.
/// The following property set definitions are applicable to this entity:
/// Pset_CableCarrierFittingTypeCommon (PSET_TYPEDRIVENOVERRIDE)
/// 
/// Quantity Use Definition
/// The quantities relating to this entity are defined by IfcElementQuantity and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute.
/// The following base quantities are defined and shall be exchanged with the IfcElementQuantity.Name = 'BaseQuantities'. 
/// Other quantities, being subjected to local standard of measurement, may be defined with another string value assigned to Name. 
/// In this case a valid value for MethodOfMeasurement shall be provided. 
/// 
/// Qto_CableCarrierFittingBaseQuantities
/// 
/// Material Use Definition
/// The material of the IfcCableCarrierFitting is defined by IfcMaterialProfileSetUsage or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship. It is accessible by the HasAssociations inverse attribute. Material information can also be given at the IfcCableCarrierFittingType, defining the common attribute data for all occurrences of the same type. The following keywords for IfcMaterialProfileSet.MaterialProfiles[n].Name shall be used:
/// 
/// Body: The primary material from which the object is constructed.
/// 
/// Port Use Definition
/// The distribution ports relating to the IfcCableCarrierFitting are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship. 
///   If the cable carrier fitting occurrence is defined by IfcCableCarrierFittingType, then the port occurrences must reflect those defined at the IfcCableCarrierFittingType using the IfcRelDefinesByObject relationship.
///   Ports are specific to the IfcCableCarrierFitting PredefinedType as follows indicated by the IfcDistributionPort Name, PredefinedType, and FlowDirection:
/// 
/// BEND
/// 
/// Head (NOTDEFINED, SINK): Head connection.
/// Tail (NOTDEFINED, SOURCE): Tail connection.
/// 
/// CROSS
/// 
/// Head (NOTDEFINED, SINK): Head connection.
/// Tail (NOTDEFINED, SOURCE): Tail connection.
/// Left (NOTDEFINED, SOURCE): Left connection.
/// Right (NOTDEFINED, SOURCE): Right connection.
/// 
/// REDUCER
/// 
/// Head (NOTDEFINED, SINK): Head connection.
/// Tail (NOTDEFINED, SOURCE): Tail connection.
/// 
/// TEE
/// 
/// Head (NOTDEFINED, SINK): Head connection.
/// Left (NOTDEFINED, SOURCE): Left connection.
/// Right (NOTDEFINED, SOURCE): Right connection.
class IFC_PARSE_API IfcCableCarrierFitting : public IfcFlowFitting {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcCableCarrierFitting
    bool hasPredefinedType() const;
    /// Identifies the predefined types of cable carrier fitting from which the type required may be set.
    IfcCableCarrierFittingTypeEnum::IfcCableCarrierFittingTypeEnum PredefinedType() const;
    void setPredefinedType(IfcCableCarrierFittingTypeEnum::IfcCableCarrierFittingTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcFlowFitting::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcCableCarrierFittingTypeEnum; } return IfcFlowFitting::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "PredefinedType"; } return IfcFlowFitting::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCableCarrierFitting (IfcEntityInstanceData* e);
    IfcCableCarrierFitting (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcCableCarrierFittingTypeEnum::IfcCableCarrierFittingTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcCableCarrierFitting > list;
};
/// A cable carrier segment is a flow segment that is specifically used to carry and support cabling. 
/// 
/// HISTORY  New entity in IFC2x4
/// 
/// Type Use Definition
/// IfcCableCarrierSegment defines the occurrence of any cable carrier segment; common information about cable carrier segment types is handled by IfcCableCarrierSegmentType. 
/// The IfcCableCarrierSegmentType (if present) may establish the common type name, usage (predefined type), properties, materials, ports, composition, assignments, and representations. 
/// The IfcCableCarrierSegmentType is attached using the IfcRelDefinesByType objectified relationship and is accessible by the IsTypedBy inverse attribute. 
/// If the IfcCableCarrierSegmentType has ports or aggregated elements, such objects are reflected at the IfcCableCarrierSegment occurrence using the IfcRelDefinesByObject relationship.
/// 
/// Property Use Definition
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute. 
/// Property sets may also be specified at the IfcCableCarrierSegmentType, defining the common property data for all occurrences of the same type. 
/// They are then accessible by the IsTypedBy inverse attribute pointing to IfcCableCarrierSegmentType.HasPropertySets. 
/// If both are given, then the properties directly defined at IfcCableCarrierSegment override the properties defined at IfcCableCarrierSegmentType. 
/// Refer to the documentation at the supertype IfcFlowSegment and ancestors for inherited property set definitions.
/// The following property set definitions are applicable to this entity:
/// (All Types)
/// 
/// Pset_CableCarrierSegmentTypeCommon (PSET_TYPEDRIVENOVERRIDE)
/// 
/// CABLELADDERSEGMENT
/// 
/// Pset_CableCarrierSegmentTypeCableLadderSegment (PSET_TYPEDRIVENOVERRIDE)
/// 
/// CABLETRAYSEGMENT
/// 
/// Pset_CableCarrierSegmentTypeCableTraySegment (PSET_TYPEDRIVENOVERRIDE)
/// 
/// CABLETRUNKINGSEGMENT
/// 
/// Pset_CableCarrierSegmentTypeCableTrunkingSegment (PSET_TYPEDRIVENOVERRIDE)
/// 
/// CONDUITSEGMENT
/// 
/// Pset_CableCarrierSegmentTypeConduitSegment (PSET_TYPEDRIVENOVERRIDE)
/// 
/// Quantity Use Definition
/// The quantities relating to this entity are defined by IfcElementQuantity and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute.
/// The following base quantities are defined and shall be exchanged with the IfcElementQuantity.Name = 'BaseQuantities'. 
/// Other quantities, being subjected to local standard of measurement, may be defined with another string value assigned to Name. 
/// In this case a valid value for MethodOfMeasurement shall be provided. 
/// 
/// Qto_CableCarrierSegmentBaseQuantities
/// 
/// Material Use Definition
/// The material of the IfcCableCarrierSegment is defined by IfcMaterialProfileSetUsage or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship. It is accessible by the HasAssociations inverse attribute. Material information can also be given at the IfcCableCarrierSegmentType, defining the common attribute data for all occurrences of the same type. The following keywords for IfcMaterialProfileSet.MaterialProfiles[n].Name shall be used:
/// 
/// Body: The primary material from which the object is constructed.
/// 
/// Port Use Definition
/// The distribution ports relating to the IfcCableCarrierSegment are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship. 
///   If the cable carrier segment occurrence is defined by IfcCableCarrierSegmentType, then the port occurrences must reflect those defined at the IfcCableCarrierSegmentType using the IfcRelDefinesByObject relationship.
///   Ports are specific to the IfcCableCarrierSegment PredefinedType as follows indicated by the IfcDistributionPort Name, PredefinedType, and FlowDirection:
/// 
/// Head (NOTDEFINED, SINK): Head connection.
/// Tail (NOTDEFINED, SOURCE): Tail connection.
class IFC_PARSE_API IfcCableCarrierSegment : public IfcFlowSegment {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcCableCarrierSegment
    bool hasPredefinedType() const;
    /// Identifies the predefined types of cable carrier segment from which the type required may be set.
    IfcCableCarrierSegmentTypeEnum::IfcCableCarrierSegmentTypeEnum PredefinedType() const;
    void setPredefinedType(IfcCableCarrierSegmentTypeEnum::IfcCableCarrierSegmentTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcFlowSegment::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcCableCarrierSegmentTypeEnum; } return IfcFlowSegment::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "PredefinedType"; } return IfcFlowSegment::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCableCarrierSegment (IfcEntityInstanceData* e);
    IfcCableCarrierSegment (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcCableCarrierSegmentTypeEnum::IfcCableCarrierSegmentTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcCableCarrierSegment > list;
};
/// A cable fitting is a fitting that is placed at a junction, transition or termination in a cable system. 
/// 
/// HISTORY  New entity in IFC2x4
/// 
/// Type Use Definition
/// IfcCableFitting defines the occurrence of any cable fitting; common information about cable fitting types is handled by IfcCableFittingType. 
/// The IfcCableFittingType (if present) may establish the common type name, usage (predefined type), properties, materials, ports, composition, assignments, and representations. 
/// The IfcCableFittingType is attached using the IfcRelDefinesByType objectified relationship and is accessible by the IsTypedBy inverse attribute. 
/// If the IfcCableFittingType has ports or aggregated elements, such objects are reflected at the IfcCableFitting occurrence using the IfcRelDefinesByObject relationship.
/// 
/// Property Use Definition
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute. 
/// Property sets may also be specified at the IfcCableFittingType, defining the common property data for all occurrences of the same type. 
/// They are then accessible by the IsTypedBy inverse attribute pointing to IfcCableFittingType.HasPropertySets. 
/// If both are given, then the properties directly defined at IfcCableFitting override the properties defined at IfcCableFittingType. 
/// Refer to the documentation at the supertype IfcFlowFitting and ancestors for inherited property set definitions.
/// The following property set definitions are applicable to this entity:
/// Pset_CableFittingTypeCommon (PSET_TYPEDRIVENOVERRIDE)
/// 
/// Quantity Use Definition
/// The quantities relating to this entity are defined by IfcElementQuantity and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute.
/// The following base quantities are defined and shall be exchanged with the IfcElementQuantity.Name = 'BaseQuantities'. 
/// Other quantities, being subjected to local standard of measurement, may be defined with another string value assigned to Name. 
/// In this case a valid value for MethodOfMeasurement shall be provided. 
/// 
/// Qto_CableFittingBaseQuantities
/// 
/// Material Use Definition
/// The material of the IfcCableFitting is defined by IfcMaterialProfileSetUsage or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship. It is accessible by the HasAssociations inverse attribute. Material information can also be given at the IfcCableFittingType, defining the common attribute data for all occurrences of the same type. The following keywords for IfcMaterialProfileSet.MaterialProfiles[n].Name shall be used:
/// 
/// Casing: Material from which the casing is constructed.
/// Conductor: Material from which the conductors are constructed, such as Aluminium or Copper.
/// 
/// Connection Use Definition
/// The IfcCableFitting may be connected to other objects as follows using the indicated relationship:
/// 
/// ENTRY
/// 
/// IfcPipeSegment (IfcRelConnectsElements): For equipotential bonding, may represent a clamp that is attached from a pipe or other conducting element of an earthing system.
/// 
/// EXIT
/// 
/// IfcPipeSegment (IfcRelConnectsElements): For equipotential bonding, may represent a clamp that is attached to a pipe or other conducting element of an earthing system.
/// 
/// Port Use Definition
/// The distribution ports relating to the IfcCableFitting are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship. 
///   If the cable fitting occurrence is defined by IfcCableFittingType, then the port occurrences must reflect those defined at the IfcCableFittingType using the IfcRelDefinesByObject relationship.
///   Ports are specific to the IfcCableFitting PredefinedType as follows indicated by the IfcDistributionPort Name, PredefinedType, and FlowDirection:
/// 
/// CONNECTOR
/// 
/// Input (NOTDEFINED, SINK): The input of the connector.
/// Output (NOTDEFINED, SOURCE): The output of the connector.
/// 
/// ENTRY
/// 
/// Output (NOTDEFINED, SOURCE): The output of the connector.
/// 
/// EXIT
/// 
/// Input (NOTDEFINED, SOURCE): The input of the connector.
/// 
/// JUNCTION
/// 
/// Head (NOTDEFINED, SOURCE): The input of the connector.
/// Output#1 (NOTDEFINED, SINK): An output of the connector.
/// Output#2 (NOTDEFINED, SINK): An output of the connector.
/// 
/// TRANSITION
/// 
/// Input (NOTDEFINED, SINK): The input of the connector.
/// Output (NOTDEFINED, SOURCE): The output of the connector.
class IFC_PARSE_API IfcCableFitting : public IfcFlowFitting {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcCableFitting
    bool hasPredefinedType() const;
    /// Identifies the predefined types of cable fitting from which the type required may be set.
    IfcCableFittingTypeEnum::IfcCableFittingTypeEnum PredefinedType() const;
    void setPredefinedType(IfcCableFittingTypeEnum::IfcCableFittingTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcFlowFitting::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcCableFittingTypeEnum; } return IfcFlowFitting::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "PredefinedType"; } return IfcFlowFitting::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCableFitting (IfcEntityInstanceData* e);
    IfcCableFitting (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcCableFittingTypeEnum::IfcCableFittingTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcCableFitting > list;
};
/// A cable segment is a flow segment used to carry electrical power, data, or telecommunications signals.
/// A cable segment is used to typically join two sections of an electrical network or a network of components carrying the electrical service. 
/// 
/// HISTORY  New entity in IFC2x4
/// 
/// Type Use Definition
/// IfcCableSegment defines the occurrence of any cable segment; common information about cable segment types is handled by IfcCableSegmentType. 
/// The IfcCableSegmentType (if present) may establish the common type name, usage (predefined type), properties, materials, ports, composition, assignments, and representations. 
/// The IfcCableSegmentType is attached using the IfcRelDefinesByType objectified relationship and is accessible by the IsTypedBy inverse attribute. 
/// If the IfcCableSegmentType has ports or aggregated elements, such objects are reflected at the IfcCableSegment occurrence using the IfcRelDefinesByObject relationship.
/// 
/// Property Use Definition
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute. 
/// Property sets may also be specified at the IfcCableSegmentType, defining the common property data for all occurrences of the same type. 
/// They are then accessible by the IsTypedBy inverse attribute pointing to IfcCableSegmentType.HasPropertySets. 
/// If both are given, then the properties directly defined at IfcCableSegment override the properties defined at IfcCableSegmentType. 
/// Refer to the documentation at the supertype IfcFlowSegment and ancestors for inherited property set definitions.
/// The following property set definitions are applicable to this entity:
/// (All Types)
/// 
/// Pset_CableSegmentTypeCommon (PSET_TYPEDRIVENOVERRIDE)
/// 
/// BUSBARSEGMENT
/// 
/// Pset_CableSegmentTypeBusBarSegment (PSET_TYPEDRIVENOVERRIDE)
/// 
/// CABLESEGMENT
/// 
/// Pset_CableSegmentTypeCableSegment (PSET_TYPEDRIVENOVERRIDE)
/// 
/// CONDUCTORSEGMENT
/// 
/// Pset_CableSegmentTypeConductorSegment (PSET_TYPEDRIVENOVERRIDE)
/// 
/// CORESEGMENT
/// 
/// Pset_CableSegmentTypeCoreSegment (PSET_TYPEDRIVENOVERRIDE)
/// 
/// Quantity Use Definition
/// The quantities relating to this entity are defined by IfcElementQuantity and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute.
/// The following base quantities are defined and shall be exchanged with the IfcElementQuantity.Name = 'BaseQuantities'. 
/// Other quantities, being subjected to local standard of measurement, may be defined with another string value assigned to Name. 
/// In this case a valid value for MethodOfMeasurement shall be provided. 
/// 
/// Qto_CableSegmentBaseQuantities
/// 
/// Material Use Definition
/// The material of the IfcCableSegment is defined by IfcMaterialProfileSetUsage or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship. It is accessible by the HasAssociations inverse attribute. Material information can also be given at the IfcCableSegmentType, defining the common attribute data for all occurrences of the same type. The following keywords for IfcMaterialProfileSet.MaterialProfiles[n].Name shall be used:
/// 
/// Conductor: Material from which the conductors are constructed, such as Aluminium or Copper.
/// Insulation: The material from which the insulation is constructed such as PVC, PEX, or EPR.
/// Screen: The material from which the screen that covers the sheath is constructed (mantel) such as Aluminium, Copper, Steel, or Lead.
/// Sheath: The outer sheathing of the cable which may be color-coded.
/// 
/// Composition Use Definition
/// The IfcCableSegment may be aggregated into components using IfcRelAggregates where RelatingObject refers to the enclosing IfcCableSegment and RelatedObjects contains one or more components. Aggregation use is defined for the following predefined types:
/// 
/// CABLESEGMENT
/// 
/// May contain IfcCableSegment components having PredefinedType=CORESEGMENT. Cable segments may be aggregated into cable cores.
/// 
/// CORESEGMENT
/// 
/// May contain IfcCableSegment components having PredefinedType=CONDUCTORSEGMENT. Cable cores may be aggregated into cable conductors.
/// 
/// Connection Use Definition
/// The IfcCableSegment may be connected to other objects as follows using the indicated relationship:
/// 
/// IfcCableCarrierSegment (IfcRelConnectsElements): Indicates a cable carrier segment housing the cable. 
/// IfcWall (IfcRelConnectsElements): Indicates a wall housing the cable.
/// 
/// Port Use Definition
/// The distribution ports relating to the IfcCableSegment are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship. 
///   If the cable segment occurrence is defined by IfcCableSegmentType, then the port occurrences must reflect those defined at the IfcCableSegmentType using the IfcRelDefinesByObject relationship.
///   Ports are specific to the IfcCableSegment PredefinedType as follows indicated by the IfcDistributionPort Name, PredefinedType, and FlowDirection:
/// 
/// CABLESEGMENT
/// 
/// Input (NOTDEFINED, SINK): Input end of the cable.
/// Output (NOTDEFINED, SOURCE): Output end of the cable.
/// 
/// CONDUCTORSEGMENT
/// 
/// Input (NOTDEFINED, SINK): Input end of the conductor.
/// Output (NOTDEFINED, SOURCE): Output end of the cable.
class IFC_PARSE_API IfcCableSegment : public IfcFlowSegment {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcCableSegment
    bool hasPredefinedType() const;
    /// Identifies the predefined types of cable segment from which the type required may be set.
    IfcCableSegmentTypeEnum::IfcCableSegmentTypeEnum PredefinedType() const;
    void setPredefinedType(IfcCableSegmentTypeEnum::IfcCableSegmentTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcFlowSegment::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcCableSegmentTypeEnum; } return IfcFlowSegment::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "PredefinedType"; } return IfcFlowSegment::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCableSegment (IfcEntityInstanceData* e);
    IfcCableSegment (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcCableSegmentTypeEnum::IfcCableSegmentTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcCableSegment > list;
};
/// A chiller is a device used to remove heat from a liquid via a vapor-compression or absorption refrigeration cycle to cool a fluid, typically water or a mixture of water and glycol. The chilled fluid is then used to cool and dehumidify air in a building. 
/// 
/// HISTORY  New entity in IFC2x4
/// 
/// Type Use Definition
/// IfcChiller defines the occurrence of any chiller; common information about chiller types is handled by IfcChillerType. 
/// The IfcChillerType (if present) may establish the common type name, usage (predefined type), properties, materials, ports, composition, assignments, and representations. 
/// The IfcChillerType is attached using the IfcRelDefinesByType objectified relationship and is accessible by the IsTypedBy inverse attribute. 
/// If the IfcChillerType has ports or aggregated elements, such objects are reflected at the IfcChiller occurrence using the IfcRelDefinesByObject relationship.
/// 
/// Property Use Definition
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute. 
/// Property sets may also be specified at the IfcChillerType, defining the common property data for all occurrences of the same type. 
/// They are then accessible by the IsTypedBy inverse attribute pointing to IfcChillerType.HasPropertySets. 
/// If both are given, then the properties directly defined at IfcChiller override the properties defined at IfcChillerType. 
/// Refer to the documentation at the supertype IfcEnergyConversionDevice and ancestors for inherited property set definitions.
/// The following property set definitions are applicable to this entity:
/// Pset_ChillerPHistory (PSET_PERFORMANCEDRIVEN)
/// Pset_ChillerTypeCommon (PSET_TYPEDRIVENOVERRIDE)
/// 
/// Quantity Use Definition
/// The quantities relating to this entity are defined by IfcElementQuantity and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute.
/// The following base quantities are defined and shall be exchanged with the IfcElementQuantity.Name = 'BaseQuantities'. 
/// Other quantities, being subjected to local standard of measurement, may be defined with another string value assigned to Name. 
/// In this case a valid value for MethodOfMeasurement shall be provided. 
/// 
/// Qto_ChillerBaseQuantities
/// 
/// Material Use Definition
/// The material of the IfcChiller is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship. It is accessible by the HasAssociations inverse attribute. Material information can also be given at the IfcChillerType, defining the common attribute data for all occurrences of the same type. The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used:
/// 
/// Body: The primary material from which the object is constructed.
/// Refrigerant: Refrigerant material.
/// 
/// Composition Use Definition
/// The IfcChiller may be aggregated into components using IfcRelAggregates where RelatingObject refers to the enclosing IfcChiller and RelatedObjects contains one or more components. Aggregation use is defined for the following predefined types:
/// 
/// May contain IfcDistributionElement components. Chillers may aggregate distribution flow elements forming a refrigeration cycle (compressor, condenser, valve, evaporator), as well as control elements.
/// 
/// Figure 214 illustrates chiller composition use.
/// Figure 214 — Chiller composition use
/// 
/// Port Use Definition
/// The distribution ports relating to the IfcChiller are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship. 
///   If the chiller occurrence is defined by IfcChillerType, then the port occurrences must reflect those defined at the IfcChillerType using the IfcRelDefinesByObject relationship.
///   Ports are specific to the IfcChiller PredefinedType as follows indicated by the IfcDistributionPort Name, PredefinedType, and FlowDirection:
/// 
/// AIRCOOLED
/// 
/// Power (ELECTRICAL, SINK): Receives electrical power.
/// Control (CONTROL, SINK): Control unit accessing internal sensors and actuators.
/// ChilledWaterIn (CHILLEDWATER, SINK): Chilled water return.
/// ChilledWaterOut (CHILLEDWATER, SOURCE): Chilled water supply.
/// VentilationIn (VENTILATION, SINK): Incoming cooler air.
/// VentilationOut (VENTILATION, SOURCE): Outgoing hotter air.
/// 
/// WATERCOOLED
/// 
/// Power (ELECTRICAL, SINK): Receives electrical power.
/// Control (CONTROL, SINK): Control unit accessing internal sensors and actuators.
/// ChilledWaterIn (CHILLEDWATER, SINK): Chilled water return.
/// ChilledWaterOut (CHILLEDWATER, SOURCE): Chilled water supply.
/// CondenserWaterIn (CONDENSERWATER, SINK): Incoming cooled condenser water.
/// CondenserWaterOut (CONDENSERWATER, SOURCE): Outgoing heated condenser water.
/// 
/// Figure 215 illustrates chiller port use.
/// Figure 215 — Chiller port use
class IFC_PARSE_API IfcChiller : public IfcEnergyConversionDevice {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcChiller
    bool hasPredefinedType() const;
    IfcChillerTypeEnum::IfcChillerTypeEnum PredefinedType() const;
    void setPredefinedType(IfcChillerTypeEnum::IfcChillerTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcEnergyConversionDevice::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcChillerTypeEnum; } return IfcEnergyConversionDevice::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "PredefinedType"; } return IfcEnergyConversionDevice::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcChiller (IfcEntityInstanceData* e);
    IfcChiller (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcChillerTypeEnum::IfcChillerTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcChiller > list;
};
/// A coil is a device used to provide heat transfer between non-mixing media. A common example is a cooling coil, which utilizes a finned coil in which circulates chilled water, antifreeze, or refrigerant that is used to remove heat from air moving across the surface of the coil. A coil may be used either for heating or cooling purposes by placing a series of tubes (the coil) carrying a heating or cooling fluid into an airstream. The coil may be constructed from tubes bundled in a serpentine form or from finned tubes that give a extended heat transfer surface.
/// Coils may also be used for non-airflow cases such as embedded in a floor slab. 
/// 
/// HISTORY  New entity in IFC2x4
/// 
/// Type Use Definition
/// IfcCoil defines the occurrence of any coil; common information about coil types is handled by IfcCoilType. 
/// The IfcCoilType (if present) may establish the common type name, usage (predefined type), properties, materials, ports, composition, assignments, and representations. 
/// The IfcCoilType is attached using the IfcRelDefinesByType objectified relationship and is accessible by the IsTypedBy inverse attribute. 
/// If the IfcCoilType has ports or aggregated elements, such objects are reflected at the IfcCoil occurrence using the IfcRelDefinesByObject relationship.
/// 
/// Property Use Definition
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute. 
/// Property sets may also be specified at the IfcCoilType, defining the common property data for all occurrences of the same type. 
/// They are then accessible by the IsTypedBy inverse attribute pointing to IfcCoilType.HasPropertySets. 
/// If both are given, then the properties directly defined at IfcCoil override the properties defined at IfcCoilType. 
/// Refer to the documentation at the supertype IfcEnergyConversionDevice and ancestors for inherited property set definitions.
/// The following property set definitions are applicable to this entity:
/// Pset_CoilOccurrence (PSET_OCCURRENCEDRIVEN)
/// Pset_CoilPHistory (PSET_PERFORMANCEDRIVEN)
/// Pset_CoilTypeCommon (PSET_TYPEDRIVENOVERRIDE)
/// Pset_CoilTypeHydronic (PSET_TYPEDRIVENOVERRIDE)
/// 
/// Quantity Use Definition
/// The quantities relating to this entity are defined by IfcElementQuantity and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute.
/// The following base quantities are defined and shall be exchanged with the IfcElementQuantity.Name = 'BaseQuantities'. 
/// Other quantities, being subjected to local standard of measurement, may be defined with another string value assigned to Name. 
/// In this case a valid value for MethodOfMeasurement shall be provided. 
/// 
/// Qto_CoilBaseQuantities
/// 
/// Material Use Definition
/// The material of the IfcCoil is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship. It is accessible by the HasAssociations inverse attribute. Material information can also be given at the IfcCoilType, defining the common attribute data for all occurrences of the same type. The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used:
/// 
/// Body: The primary material from which the object is constructed.
/// 
/// Port Use Definition
/// The distribution ports relating to the IfcCoil are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship. 
///   If the coil occurrence is defined by IfcCoilType, then the port occurrences must reflect those defined at the IfcCoilType using the IfcRelDefinesByObject relationship.
///   Ports are specific to the IfcCoil PredefinedType as follows indicated by the IfcDistributionPort Name, PredefinedType, and FlowDirection:
/// 
/// DXCOOLINGCOIL
/// 
/// RefrigerantIn (REFRIGERATION, SINK): Refrigerant entering the coil.
/// RefrigerantOut (REFRIGERATION, SOURCE): Refrigerant leaving the coil.
/// AirIn (AIRCONDITIONING, SINK): Air entering the surface of the coil.
/// AirOut (AIRCONDITIONING, SOURCE): Air leaving the surface of the coil.
/// 
/// WATERCOOLINGCOIL
/// 
/// ChilledWaterIn (CHILLEDWATER, SINK): Chilled water entering the coil.
/// ChilledWaterOut (CHILLEDWATER, SOURCE): Chilled water leaving the coil.
/// AirIn (AIRCONDITIONING, SINK): Air entering the surface of the coil.
/// AirOut (AIRCONDITIONING, SOURCE): Air leaving the surface of the coil.
/// 
/// WATERHEATINGCOIL
/// 
/// HeatingIn (HEATING, SINK): Heated water entering the coil.
/// HeatingOut (HEATING, SOURCE): Heated water leaving the coil.
/// AirIn (AIRCONDITIONING, SINK): Air entering the surface of the coil.
/// AirOut (AIRCONDITIONING, SOURCE): Air leaving the surface of the coil.
/// 
/// Figure 216 illustrates coil port use.
/// Figure 216 — Coil port use
class IFC_PARSE_API IfcCoil : public IfcEnergyConversionDevice {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcCoil
    bool hasPredefinedType() const;
    IfcCoilTypeEnum::IfcCoilTypeEnum PredefinedType() const;
    void setPredefinedType(IfcCoilTypeEnum::IfcCoilTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcEnergyConversionDevice::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcCoilTypeEnum; } return IfcEnergyConversionDevice::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "PredefinedType"; } return IfcEnergyConversionDevice::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCoil (IfcEntityInstanceData* e);
    IfcCoil (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcCoilTypeEnum::IfcCoilTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcCoil > list;
};
/// A communications appliance transmits and receives electronic or digital information as data or sound.
/// Communication appliances may be fixed in place or may be able to be moved from one space to another. Communication appliances require an electrical supply that may be supplied either by an electrical circuit or provided from a local battery source. 
/// 
/// HISTORY  New entity in IFC2x4
/// 
/// Type Use Definition
/// IfcCommunicationsAppliance defines the occurrence of any communications appliance; common information about communications appliance types is handled by IfcCommunicationsApplianceType. 
/// The IfcCommunicationsApplianceType (if present) may establish the common type name, usage (predefined type), properties, materials, ports, composition, assignments, and representations. 
/// The IfcCommunicationsApplianceType is attached using the IfcRelDefinesByType objectified relationship and is accessible by the IsTypedBy inverse attribute. 
/// If the IfcCommunicationsApplianceType has ports or aggregated elements, such objects are reflected at the IfcCommunicationsAppliance occurrence using the IfcRelDefinesByObject relationship.
/// 
/// Property Use Definition
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute. 
/// Property sets may also be specified at the IfcCommunicationsApplianceType, defining the common property data for all occurrences of the same type. 
/// They are then accessible by the IsTypedBy inverse attribute pointing to IfcCommunicationsApplianceType.HasPropertySets. 
/// If both are given, then the properties directly defined at IfcCommunicationsAppliance override the properties defined at IfcCommunicationsApplianceType. 
/// Refer to the documentation at the supertype IfcFlowTerminal and ancestors for inherited property set definitions.
/// The following property set definitions are applicable to this entity:
/// Pset_CommunicationsAppliancePHistory (PSET_PERFORMANCEDRIVEN)
/// Pset_CommunicationsApplianceTypeCommon (PSET_TYPEDRIVENOVERRIDE)
/// 
/// Quantity Use Definition
/// The quantities relating to this entity are defined by IfcElementQuantity and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute.
/// The following base quantities are defined and shall be exchanged with the IfcElementQuantity.Name = 'BaseQuantities'. 
/// Other quantities, being subjected to local standard of measurement, may be defined with another string value assigned to Name. 
/// In this case a valid value for MethodOfMeasurement shall be provided. 
/// 
/// Qto_CommunicationsApplianceBaseQuantities
/// 
/// Material Use Definition
/// The material of the IfcCommunicationsAppliance is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship. It is accessible by the HasAssociations inverse attribute. Material information can also be given at the IfcCommunicationsApplianceType, defining the common attribute data for all occurrences of the same type. The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used:
/// 
/// Casing: Material from which the casing is constructed.
/// 
/// Composition Use Definition
/// The IfcCommunicationsAppliance may be aggregated into components using IfcRelAggregates where RelatingObject refers to the enclosing IfcCommunicationsAppliance and RelatedObjects contains one or more components. Aggregation use is defined for the following predefined types:
/// 
/// COMPUTER
/// 
/// May contain IfcAudioVisualAppliance components. Computers may be aggregated into audio-visual components such as displays, cameras, speakers, or microphones.
/// 
/// Connection Use Definition
/// The IfcCommunicationsAppliance may be connected to other objects as follows using the indicated relationship:
/// 
/// IfcSystemFurnitureElement (IfcRelConnectsElements): Servers and other networking equipment may be installed in racks.
/// 
/// Port Use Definition
/// The distribution ports relating to the IfcCommunicationsAppliance are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship. 
///   If the communications appliance occurrence is defined by IfcCommunicationsApplianceType, then the port occurrences must reflect those defined at the IfcCommunicationsApplianceType using the IfcRelDefinesByObject relationship.
///   Ports are specific to the IfcCommunicationsAppliance PredefinedType as follows indicated by the IfcDistributionPort Name, PredefinedType, and FlowDirection:
/// 
/// ANTENNA
/// 
/// Power (ELECTRICAL, SINK): Receives electrical power.
/// Radio (SIGNAL, SINK): Electromagnetic waves.
/// Signal (SIGNAL, SOURCE): The modulated analog signal in a circuit, such as a cable connected to a modem. 
/// 
/// COMPUTER
/// 
/// Power (ELECTRICAL, SINK): Receives electrical power.
/// Network (DATA, SINK): A network connection, may be wired or wireless (implicit antenna), such as a cable connected from a data outlet jack or from a router communications appliance. While communication is bidirectional, the router-end is considered to be the source.
/// Device (CONTROL, SOURCE): A device connection such as USB or serial, which may connect to equipment such as a building automation controller.
/// Display (AUDIOVISUAL, SOURCE): Audio/video output, such as a cable connected to a display, which may be aggregated into separate channels.
/// 
/// FAX
/// 
/// Power (ELECTRICAL, SINK): Receives electrical power.
/// Telephone (TELEPHONE, SINK): Telephone connection.
/// 
/// MODEM
/// 
/// Power (ELECTRICAL, SINK): Receives electrical power.
/// Signal (SIGNAL, SINK): Modulated analog signal, typically a cable connecting from a communications junction box or an antenna.
/// Internet (DATA, SOURCE): Internet data network.
/// Television (TV, SOURCE): Television modulated signal.
/// Telephone (TELEPHONE, SOURCE): Telephone communications.
/// 
/// PRINTER
/// 
/// Power (ELECTRICAL, SINK): Receives electrical power.
/// Network (DATA, SINK): A network connection, may be wired or wireless (implicit antenna), such as a cable connected from a data outlet jack or from a router communications appliance. While communication is bidirectional, the router-end is considered to be the source.
/// 
/// REPEATER
/// 
/// Power (ELECTRICAL, SINK): Receives electrical power.
/// Input (SIGNAL, SINK): The receiving signal.
/// Output (SIGNAL, SOURCE): The transmittes signal.
/// 
/// ROUTER
/// 
/// Power (ELECTRICAL, SINK): Receives electrical power.
/// Uplink (DATA, SINK): Uplink from another network, such as a cable connected to another router or the Internet.
/// Link#1 (DATA, SOURCE): A network link to a routed device such as a cable connecting to a computer.
/// Link#2 (DATA, SOURCE): A network link to a routed device such as a cable connecting to a computer.
/// Link#3 (DATA, SOURCE): A network link to a routed device such as a cable connecting to a computer.
/// Link#4 (DATA, SOURCE): A network link to a routed device such as a cable connecting to a computer.
/// Link#5 (DATA, SOURCE): A network link to a routed device such as a cable connecting to a computer.
/// Link#6 (DATA, SOURCE): A network link to a routed device such as a cable connecting to a computer.
/// Link#7 (DATA, SOURCE): A network link to a routed device such as a cable connecting to a computer.
/// Link#8 (DATA, SOURCE): A network link to a routed device such as a cable connecting to a computer.
class IFC_PARSE_API IfcCommunicationsAppliance : public IfcFlowTerminal {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcCommunicationsAppliance
    bool hasPredefinedType() const;
    IfcCommunicationsApplianceTypeEnum::IfcCommunicationsApplianceTypeEnum PredefinedType() const;
    void setPredefinedType(IfcCommunicationsApplianceTypeEnum::IfcCommunicationsApplianceTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcFlowTerminal::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcCommunicationsApplianceTypeEnum; } return IfcFlowTerminal::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "PredefinedType"; } return IfcFlowTerminal::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCommunicationsAppliance (IfcEntityInstanceData* e);
    IfcCommunicationsAppliance (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcCommunicationsApplianceTypeEnum::IfcCommunicationsApplianceTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcCommunicationsAppliance > list;
};
/// A compressor is a device that compresses a fluid typically used in a refrigeration circuit. 
/// 
/// HISTORY  New entity in IFC2x4
/// 
/// Type Use Definition
/// IfcCompressor defines the occurrence of any compressor; common information about compressor types is handled by IfcCompressorType. 
/// The IfcCompressorType (if present) may establish the common type name, usage (predefined type), properties, materials, ports, composition, assignments, and representations. 
/// The IfcCompressorType is attached using the IfcRelDefinesByType objectified relationship and is accessible by the IsTypedBy inverse attribute. 
/// If the IfcCompressorType has ports or aggregated elements, such objects are reflected at the IfcCompressor occurrence using the IfcRelDefinesByObject relationship.
/// 
/// Property Use Definition
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute. 
/// Property sets may also be specified at the IfcCompressorType, defining the common property data for all occurrences of the same type. 
/// They are then accessible by the IsTypedBy inverse attribute pointing to IfcCompressorType.HasPropertySets. 
/// If both are given, then the properties directly defined at IfcCompressor override the properties defined at IfcCompressorType. 
/// Refer to the documentation at the supertype IfcFlowMovingDevice and ancestors for inherited property set definitions.
/// The following property set definitions are applicable to this entity:
/// Pset_CompressorPHistory (PSET_PERFORMANCEDRIVEN)
/// Pset_CompressorTypeCommon (PSET_TYPEDRIVENOVERRIDE)
/// 
/// Quantity Use Definition
/// The quantities relating to this entity are defined by IfcElementQuantity and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute.
/// The following base quantities are defined and shall be exchanged with the IfcElementQuantity.Name = 'BaseQuantities'. 
/// Other quantities, being subjected to local standard of measurement, may be defined with another string value assigned to Name. 
/// In this case a valid value for MethodOfMeasurement shall be provided. 
/// 
/// Qto_CompressorBaseQuantities
/// 
/// Material Use Definition
/// The material of the IfcCompressor is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship. It is accessible by the HasAssociations inverse attribute. Material information can also be given at the IfcCompressorType, defining the common attribute data for all occurrences of the same type. The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used:
/// 
/// Body: The primary material from which the object is constructed.
/// Refrigerant: Refrigerant material.
/// 
/// Port Use Definition
/// The distribution ports relating to the IfcCompressor are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship. 
///   If the compressor occurrence is defined by IfcCompressorType, then the port occurrences must reflect those defined at the IfcCompressorType using the IfcRelDefinesByObject relationship.
///   Ports are specific to the IfcCompressor PredefinedType as follows indicated by the IfcDistributionPort Name, PredefinedType, and FlowDirection:
/// 
/// RefrigerantIn (REFRIGERATION, SINK): Uncompressed vapor refrigerant entering the compressor.
/// RefrigerantOut (REFRIGERATION, SOURCE): Compressed vapor refrigerant leaving the compressor.
/// 
/// Figure 217 illustrates compressor port use.
/// Figure 217 — Compressor port use
class IFC_PARSE_API IfcCompressor : public IfcFlowMovingDevice {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcCompressor
    bool hasPredefinedType() const;
    IfcCompressorTypeEnum::IfcCompressorTypeEnum PredefinedType() const;
    void setPredefinedType(IfcCompressorTypeEnum::IfcCompressorTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcFlowMovingDevice::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcCompressorTypeEnum; } return IfcFlowMovingDevice::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "PredefinedType"; } return IfcFlowMovingDevice::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCompressor (IfcEntityInstanceData* e);
    IfcCompressor (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcCompressorTypeEnum::IfcCompressorTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcCompressor > list;
};
/// A condenser is a device that is used to dissipate heat, typically by condensing a substance such as a refrigerant from its gaseous to its liquid state. 
/// 
/// HISTORY  New entity in IFC2x4
/// 
/// Type Use Definition
/// IfcCondenser defines the occurrence of any condenser; common information about condenser types is handled by IfcCondenserType. 
/// The IfcCondenserType (if present) may establish the common type name, usage (predefined type), properties, materials, ports, composition, assignments, and representations. 
/// The IfcCondenserType is attached using the IfcRelDefinesByType objectified relationship and is accessible by the IsTypedBy inverse attribute. 
/// If the IfcCondenserType has ports or aggregated elements, such objects are reflected at the IfcCondenser occurrence using the IfcRelDefinesByObject relationship.
/// 
/// Property Use Definition
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute. 
/// Property sets may also be specified at the IfcCondenserType, defining the common property data for all occurrences of the same type. 
/// They are then accessible by the IsTypedBy inverse attribute pointing to IfcCondenserType.HasPropertySets. 
/// If both are given, then the properties directly defined at IfcCondenser override the properties defined at IfcCondenserType. 
/// Refer to the documentation at the supertype IfcEnergyConversionDevice and ancestors for inherited property set definitions.
/// The following property set definitions are applicable to this entity:
/// Pset_CondenserPHistory (PSET_PERFORMANCEDRIVEN)
/// Pset_CondenserTypeCommon (PSET_TYPEDRIVENOVERRIDE)
/// 
/// Quantity Use Definition
/// The quantities relating to this entity are defined by IfcElementQuantity and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute.
/// The following base quantities are defined and shall be exchanged with the IfcElementQuantity.Name = 'BaseQuantities'. 
/// Other quantities, being subjected to local standard of measurement, may be defined with another string value assigned to Name. 
/// In this case a valid value for MethodOfMeasurement shall be provided. 
/// 
/// Qto_CondenserBaseQuantities
/// 
/// Material Use Definition
/// The material of the IfcCondenser is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship. It is accessible by the HasAssociations inverse attribute. Material information can also be given at the IfcCondenserType, defining the common attribute data for all occurrences of the same type. The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used:
/// 
/// Body: The primary material from which the object is constructed.
/// Refrigerant: Refrigerant material.
/// 
/// Port Use Definition
/// The distribution ports relating to the IfcCondenser are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship. 
///   If the condenser occurrence is defined by IfcCondenserType, then the port occurrences must reflect those defined at the IfcCondenserType using the IfcRelDefinesByObject relationship.
///   Ports are specific to the IfcCondenser PredefinedType as follows indicated by the IfcDistributionPort Name, PredefinedType, and FlowDirection:
/// 
/// AIRCOOLED
/// 
/// RefrigerantIn (REFRIGERATION, SINK): Vapor refrigerant entering the condenser.
/// RefrigerantOut (REFRIGERATION, SOURCE): Liquid refrigerant leaving the condenser.
/// CompressedAirIn (COMPRESSEDAIR, SINK): Cooler air entering the condenser.
/// CompressedAirOut (COMPRESSEDAIR, SOURCE): Warmer air leaving the condenser.
/// 
/// EVAPORATIVECOOLED
/// 
/// RefrigerantIn (REFRIGERATION, SINK): Vapor refrigerant entering the condenser.
/// RefrigerantOut (REFRIGERATION, SOURCE): Liquid refrigerant leaving the condenser.
/// CondenserWaterIn (CONDENSERWATER, SINK): Makeup water entering the condenser.
/// CondenserWaterOut (CONDENSERWATER, SOURCE): Purged water leaving the condenser.
/// VentilationIn (VENTILATION, SINK): Air entering the condenser.
/// VentilationOut (VENTILATION, SOURCE): Air leaving the condenser.
/// 
/// WATERCOOLED
/// 
/// RefrigerantIn (REFRIGERATION, SINK): Vapor refrigerant entering the condenser.
/// RefrigerantOut (REFRIGERATION, SOURCE): Liquid refrigerant leaving the condenser.
/// CondenserWaterIn (CONDENSERWATER, SINK): Cooler water entering the condenser, optionally from cooling tower.
/// CondenserWaterOut (CONDENSERWATER, SOURCE): Warmer water leaving the condenser, optionally to cooling tower.
/// 
/// Figure 218 illustrates condenser port use.
/// Figure 218 — Condenser port use
class IFC_PARSE_API IfcCondenser : public IfcEnergyConversionDevice {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcCondenser
    bool hasPredefinedType() const;
    IfcCondenserTypeEnum::IfcCondenserTypeEnum PredefinedType() const;
    void setPredefinedType(IfcCondenserTypeEnum::IfcCondenserTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcEnergyConversionDevice::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcCondenserTypeEnum; } return IfcEnergyConversionDevice::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "PredefinedType"; } return IfcEnergyConversionDevice::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCondenser (IfcEntityInstanceData* e);
    IfcCondenser (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcCondenserTypeEnum::IfcCondenserTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcCondenser > list;
};
/// The distribution control element type IfcControllerType defines commonly shared information for occurrences of controllers.  The set of shared information may include: 
/// 
/// common properties with shared property sets 
/// common representations of shape 
/// common materials 
/// common composition of elements 
/// common ports 
/// applicable assignment of process types 
/// 
/// It is used to define a controller specification (i.e. the specific product information, that is common to all occurrences of that product type).  Controller types may be exchanged without being already assigned to occurrences.
///   Occurrences of IfcControllerType are represented by instances of IfcController. 
/// 
/// HISTORY: New entity in IFC2x2 
/// 
/// Property Set Use Definition 
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the HasPropertySets attribute.  Refer to the documentation at the supertype IfcDistributionControlElementType and ancestors for inherited property set definitions. 
/// The following property set definitions are applicable to this entity according to the PredefinedType attribute:  
/// Pset_ControllerTypeCommon 
/// Pset_ControllerTypeFloating (FLOATING) 
/// Pset_ControllerTypeMultiPosition (MULTIPOSITION) 
/// Pset_ControllerTypeProgrammable (PROGRAMMABLE) 
/// Pset_ControllerTypeProportional (PROPORTIONAL) 
/// Pset_ControllerTypeTwoPosition (TWOPOSITION) 
/// 
/// Material Use Definition 
/// The material of the IfcControllerType is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.    The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used: 
/// 
/// 'Casing': Material from which the casing is constructed. 
/// 
/// Composition Use Definition 
/// The IfcControllerType may be aggregated into components using IfcRelAggregates where RelatingObject refers to the enclosing IfcControllerType and RelatedObjects contains one or more components.  Components are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Aggregation use is defined for the following predefined types:
/// 
/// PROGRAMMABLE: May contain IfcController components.  Programmable Logic Controllers may be decomposed into logical elements for values and operations. 
/// 
/// Port Use Definition 
/// The distribution ports relating to the IfcControllerType type are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship.  Ports are reflected at occurrences of this type using the IfcRelDefinesByObject relationship.  Refer to the documentation at IfcController for standard port definitions.
class IFC_PARSE_API IfcControllerType : public IfcDistributionControlElementType {
public:
    /// Identifies the predefined types of controller from which the type required may be set.
    IfcControllerTypeEnum::IfcControllerTypeEnum PredefinedType() const;
    void setPredefinedType(IfcControllerTypeEnum::IfcControllerTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 10; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 9: return IfcUtil::Argument_ENUMERATION; } return IfcDistributionControlElementType::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 9: return Type::IfcControllerTypeEnum; } return IfcDistributionControlElementType::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 9: return "PredefinedType"; } return IfcDistributionControlElementType::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcControllerType (IfcEntityInstanceData* e);
    IfcControllerType (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ApplicableOccurrence, boost::optional< IfcTemplatedEntityList< IfcPropertySetDefinition >::ptr > v6_HasPropertySets, boost::optional< IfcTemplatedEntityList< IfcRepresentationMap >::ptr > v7_RepresentationMaps, boost::optional< std::string > v8_Tag, boost::optional< std::string > v9_ElementType, IfcControllerTypeEnum::IfcControllerTypeEnum v10_PredefinedType);
    typedef IfcTemplatedEntityList< IfcControllerType > list;
};
/// A cooled beam (or chilled beam) is a device typically used to cool air by circulating a fluid such as chilled water through exposed finned tubes above a space. Typically mounted overhead near or within a ceiling, the cooled beam uses convection to cool the space below it by acting as a heat sink for the naturally rising warm air of the space. Once cooled, the air naturally drops back to the floor where the cycle begins again. 
/// 
/// HISTORY  New entity in IFC2x4
/// 
/// Type Use Definition
/// IfcCooledBeam defines the occurrence of any cooled beam; common information about cooled beam types is handled by IfcCooledBeamType. 
/// The IfcCooledBeamType (if present) may establish the common type name, usage (predefined type), properties, materials, ports, composition, assignments, and representations. 
/// The IfcCooledBeamType is attached using the IfcRelDefinesByType objectified relationship and is accessible by the IsTypedBy inverse attribute. 
/// If the IfcCooledBeamType has ports or aggregated elements, such objects are reflected at the IfcCooledBeam occurrence using the IfcRelDefinesByObject relationship.
/// 
/// Property Use Definition
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute. 
/// Property sets may also be specified at the IfcCooledBeamType, defining the common property data for all occurrences of the same type. 
/// They are then accessible by the IsTypedBy inverse attribute pointing to IfcCooledBeamType.HasPropertySets. 
/// If both are given, then the properties directly defined at IfcCooledBeam override the properties defined at IfcCooledBeamType. 
/// Refer to the documentation at the supertype IfcEnergyConversionDevice and ancestors for inherited property set definitions.
/// The following property set definitions are applicable to this entity:
/// (All Types)
/// 
/// Pset_CooledBeamPHistory (PSET_PERFORMANCEDRIVEN)
/// Pset_CooledBeamTypeCommon (PSET_TYPEDRIVENOVERRIDE)
/// 
/// ACTIVE
/// 
/// Pset_CooledBeamPHistoryActive (PSET_PERFORMANCEDRIVEN)
/// Pset_CooledBeamTypeActive (PSET_TYPEDRIVENOVERRIDE)
/// 
/// Quantity Use Definition
/// The quantities relating to this entity are defined by IfcElementQuantity and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute.
/// The following base quantities are defined and shall be exchanged with the IfcElementQuantity.Name = 'BaseQuantities'. 
/// Other quantities, being subjected to local standard of measurement, may be defined with another string value assigned to Name. 
/// In this case a valid value for MethodOfMeasurement shall be provided. 
/// 
/// Qto_CooledBeamBaseQuantities
/// 
/// Material Use Definition
/// The material of the IfcCooledBeam is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship. It is accessible by the HasAssociations inverse attribute. Material information can also be given at the IfcCooledBeamType, defining the common attribute data for all occurrences of the same type. The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used:
/// 
/// Body: The primary material from which the object is constructed.
/// 
/// Port Use Definition
/// The distribution ports relating to the IfcCooledBeam are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship. 
///   If the cooled beam occurrence is defined by IfcCooledBeamType, then the port occurrences must reflect those defined at the IfcCooledBeamType using the IfcRelDefinesByObject relationship.
///   Ports are specific to the IfcCooledBeam PredefinedType as follows indicated by the IfcDistributionPort Name, PredefinedType, and FlowDirection:
/// 
/// ChilledWaterIn (CHILLEDWATER, SINK): Chilled water entering.
/// ChilledWaterOut (CHILLEDWATER, SOURCE): Chilled water leaving.
class IFC_PARSE_API IfcCooledBeam : public IfcEnergyConversionDevice {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcCooledBeam
    bool hasPredefinedType() const;
    IfcCooledBeamTypeEnum::IfcCooledBeamTypeEnum PredefinedType() const;
    void setPredefinedType(IfcCooledBeamTypeEnum::IfcCooledBeamTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcEnergyConversionDevice::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcCooledBeamTypeEnum; } return IfcEnergyConversionDevice::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "PredefinedType"; } return IfcEnergyConversionDevice::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCooledBeam (IfcEntityInstanceData* e);
    IfcCooledBeam (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcCooledBeamTypeEnum::IfcCooledBeamTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcCooledBeam > list;
};
/// A cooling tower is a device which rejects heat to ambient air by circulating a fluid such as water through it to reduce its temperature by partial evaporation. 
/// 
/// HISTORY  New entity in IFC2x4
/// 
/// Type Use Definition
/// IfcCoolingTower defines the occurrence of any cooling tower; common information about cooling tower types is handled by IfcCoolingTowerType. 
/// The IfcCoolingTowerType (if present) may establish the common type name, usage (predefined type), properties, materials, ports, composition, assignments, and representations. 
/// The IfcCoolingTowerType is attached using the IfcRelDefinesByType objectified relationship and is accessible by the IsTypedBy inverse attribute. 
/// If the IfcCoolingTowerType has ports or aggregated elements, such objects are reflected at the IfcCoolingTower occurrence using the IfcRelDefinesByObject relationship.
/// 
/// Property Use Definition
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute. 
/// Property sets may also be specified at the IfcCoolingTowerType, defining the common property data for all occurrences of the same type. 
/// They are then accessible by the IsTypedBy inverse attribute pointing to IfcCoolingTowerType.HasPropertySets. 
/// If both are given, then the properties directly defined at IfcCoolingTower override the properties defined at IfcCoolingTowerType. 
/// Refer to the documentation at the supertype IfcEnergyConversionDevice and ancestors for inherited property set definitions.
/// The following property set definitions are applicable to this entity:
/// Pset_CoolingTowerPHistory (PSET_PERFORMANCEDRIVEN)
/// Pset_CoolingTowerTypeCommon (PSET_TYPEDRIVENOVERRIDE)
/// 
/// Quantity Use Definition
/// The quantities relating to this entity are defined by IfcElementQuantity and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute.
/// The following base quantities are defined and shall be exchanged with the IfcElementQuantity.Name = 'BaseQuantities'. 
/// Other quantities, being subjected to local standard of measurement, may be defined with another string value assigned to Name. 
/// In this case a valid value for MethodOfMeasurement shall be provided. 
/// 
/// Qto_CoolingTowerBaseQuantities
/// 
/// Material Use Definition
/// The material of the IfcCoolingTower is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship. It is accessible by the HasAssociations inverse attribute. Material information can also be given at the IfcCoolingTowerType, defining the common attribute data for all occurrences of the same type. The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used:
/// 
/// Body: The primary material from which the object is constructed.
/// Fill: Fill material.
/// 
/// Composition Use Definition
/// The IfcCoolingTower may be aggregated into components using IfcRelAggregates where RelatingObject refers to the enclosing IfcCoolingTower and RelatedObjects contains one or more components. Aggregation use is defined for the following predefined types:
/// 
/// MECHANICALFORCEDDRAFT
/// 
/// May contain IfcFan components for forcing air into the cooling tower.
/// 
/// MECHANICALINDUCEDDDRAFT
/// 
/// May contain IfcFan components for inducing air out of the cooling tower.
/// 
/// Port Use Definition
/// The distribution ports relating to the IfcCoolingTower are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship. 
///   If the cooling tower occurrence is defined by IfcCoolingTowerType, then the port occurrences must reflect those defined at the IfcCoolingTowerType using the IfcRelDefinesByObject relationship.
///   Ports are specific to the IfcCoolingTower PredefinedType as follows indicated by the IfcDistributionPort Name, PredefinedType, and FlowDirection:
/// 
/// CondenserWaterIn (CONDENSERWATER, SINK): Warmer water entering the cooling tower.
/// CondenserWaterOut (CONDENSERWATER, SOURCE): Cooler water leaving the cooling tower.
/// 
/// Figure 219 illustrates cooling tower port use.
/// Figure 219 — Cooling tower port use
class IFC_PARSE_API IfcCoolingTower : public IfcEnergyConversionDevice {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcCoolingTower
    bool hasPredefinedType() const;
    IfcCoolingTowerTypeEnum::IfcCoolingTowerTypeEnum PredefinedType() const;
    void setPredefinedType(IfcCoolingTowerTypeEnum::IfcCoolingTowerTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcEnergyConversionDevice::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcCoolingTowerTypeEnum; } return IfcEnergyConversionDevice::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "PredefinedType"; } return IfcEnergyConversionDevice::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcCoolingTower (IfcEntityInstanceData* e);
    IfcCoolingTower (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcCoolingTowerTypeEnum::IfcCoolingTowerTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcCoolingTower > list;
};
/// A damper typically participates in an HVAC duct distribution system and is used to control or modulate the flow of air. 
/// 
/// HISTORY  New entity in IFC2x4
/// 
/// Type Use Definition
/// IfcDamper defines the occurrence of any damper; common information about damper types is handled by IfcDamperType. 
/// The IfcDamperType (if present) may establish the common type name, usage (predefined type), properties, materials, ports, composition, assignments, and representations. 
/// The IfcDamperType is attached using the IfcRelDefinesByType objectified relationship and is accessible by the IsTypedBy inverse attribute. 
/// If the IfcDamperType has ports or aggregated elements, such objects are reflected at the IfcDamper occurrence using the IfcRelDefinesByObject relationship.
/// 
/// Property Use Definition
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute. 
/// Property sets may also be specified at the IfcDamperType, defining the common property data for all occurrences of the same type. 
/// They are then accessible by the IsTypedBy inverse attribute pointing to IfcDamperType.HasPropertySets. 
/// If both are given, then the properties directly defined at IfcDamper override the properties defined at IfcDamperType. 
/// Refer to the documentation at the supertype IfcFlowController and ancestors for inherited property set definitions.
/// The following property set definitions are applicable to this entity:
/// (All Types)
/// 
/// Pset_DamperOccurrence (PSET_OCCURRENCEDRIVEN)
/// Pset_DamperPHistory (PSET_PERFORMANCEDRIVEN)
/// Pset_DamperTypeCommon (PSET_TYPEDRIVENOVERRIDE)
/// 
/// CONTROLDAMPER
/// 
/// Pset_DamperTypeControlDamper (PSET_TYPEDRIVENOVERRIDE)
/// 
/// FIREDAMPER
/// 
/// Pset_DamperTypeFireDamper (PSET_TYPEDRIVENOVERRIDE)
/// 
/// FIRESMOKEDAMPER
/// 
/// Pset_DamperTypeFireSmokeDamper (PSET_TYPEDRIVENOVERRIDE)
/// 
/// SMOKEDAMPER
/// 
/// Pset_DamperTypeSmokeDamper (PSET_TYPEDRIVENOVERRIDE)
/// 
/// Quantity Use Definition
/// The quantities relating to this entity are defined by IfcElementQuantity and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute.
/// The following base quantities are defined and shall be exchanged with the IfcElementQuantity.Name = 'BaseQuantities'. 
/// Other quantities, being subjected to local standard of measurement, may be defined with another string value assigned to Name. 
/// In this case a valid value for MethodOfMeasurement shall be provided. 
/// 
/// Qto_DamperBaseQuantities
/// 
/// Material Use Definition
/// The material of the IfcDamper is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship. It is accessible by the HasAssociations inverse attribute. Material information can also be given at the IfcDamperType, defining the common attribute data for all occurrences of the same type. The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used:
/// 
/// Blade: The material from which the damper blades are constructed.
/// Frame: The material from which the damper frame is constructed.
/// Seal: The material from which the damper seals are constructed.
/// 
/// Connection Use Definition
/// The IfcDamper may be connected to other objects as follows using the indicated relationship:
/// 
/// IfcActuator (IfcRelFlowControlElements): Indicates an actuator operating on the damper.
/// 
/// Port Use Definition
/// The distribution ports relating to the IfcDamper are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship. 
///   If the damper occurrence is defined by IfcDamperType, then the port occurrences must reflect those defined at the IfcDamperType using the IfcRelDefinesByObject relationship.
///   Ports are specific to the IfcDamper PredefinedType as follows indicated by the IfcDistributionPort Name, PredefinedType, and FlowDirection:
/// 
/// AirIn (AIRCONDITIONING, SINK): Air entering damper.
/// AirOut (AIRCONDITIONING, SOURCE): Air leaving damper, with flow regulated according to position of damper.
/// 
/// Figure 220 illustrates damper port use.
/// Figure 220 — Damper port use
class IFC_PARSE_API IfcDamper : public IfcFlowController {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcDamper
    bool hasPredefinedType() const;
    IfcDamperTypeEnum::IfcDamperTypeEnum PredefinedType() const;
    void setPredefinedType(IfcDamperTypeEnum::IfcDamperTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcFlowController::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcDamperTypeEnum; } return IfcFlowController::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "PredefinedType"; } return IfcFlowController::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcDamper (IfcEntityInstanceData* e);
    IfcDamper (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcDamperTypeEnum::IfcDamperTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcDamper > list;
};
/// A distribution chamber element defines a place at which distribution systems and their constituent elements may be inspected or through which they may travel.
/// 
/// An IfcDistributionChamberElement is a formed volume used in a distribution system, such as a sump, trench or manhole. Instances of IfcDistributionSystem or IfcDistributionFlowElement may be related to the IfcDistributionChamberElement enabling their location in or at the chamber to be determined.
/// 
/// HISTORY: New entity in IFC2x2
/// 
/// Type Use Definition
/// IfcDistributionChamberElement defines the occurrence of any distribution chamber element; common information about distribution chamber element types is handled by IfcDistributionChamberElementType.  The IfcDistributionChamberElementType (if present) may establish the common type name, usage (predefined type), properties, materials, ports, composition, assignments, and representations.  The IfcDistributionChamberElementType is attached using the IfcRelDefinesByType objectified relationship and is accessible by the IsTypedBy inverse attribute.  If the IfcDistributionChamberElementType has ports or aggregated elements, such objects are reflected at the IfcDistributionChamberElement occurrence using the IfcRelDefinesByObject relationship.
/// 
/// Property Set Use Definition
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the IfcRelDefinesByProperties relationship. They are accessible by the IsDefinedBy inverse attribute.  Property sets may also be specified at the IfcDistributionChamberElementType, defining the common property data for all occurrences of the same type.  They are then accessible by the IsTypedBy inverse attribute pointing to IfcDistributionChamberElementType.HasPropertySets. If both are given, then the properties directly defined at IfcDistributionChamberElement override the properties defined at IfcDistributionChamberElementType.  Refer to the documentation at the supertype IfcDistributionFlowElement and ancestors for inherited property set definitions.
/// The following property set definitions are applicable to this entity:
/// Pset_DistributionChamberElementCommon
/// 
/// The following property set definitions are applicable to this entity according to the PredefinedType attribute: 
/// Pset_DistributionChamberElementTypeFormedDuct (FORMEDDUCT)
/// Pset_DistributionChamberElementTypeInspectionChamber (INSPECTIONCHAMBER)
/// Pset_DistributionChamberElementTypeInspectionPit (INSPECTIONPIT)
/// Pset_DistributionChamberElementTypeManhole (MANHOLE)
/// Pset_DistributionChamberElementTypeMeterChamber (METERCHAMBER)
/// Pset_DistributionChamberElementTypeSump (SUMP)
/// Pset_DistributionChamberElementTypeTrench (TRENCH)
/// Pset_DistributionChamberElementTypeValveChamber (VALVECHAMBER)
/// 
/// Material Use Definition
/// The material of the IfcDistributionChamberElement is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.  Material information can also be given at the IfcDistributionChamberElementType, defining the common attribute data for all occurrences of the same type.  The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used:
/// 
/// 'Base': The material from which the base of the duct is constructed.
/// 'Cover': The material from which the access cover to the chamber is constructed.
/// 'Fill': The material that is used to fill the duct (where used).
/// 'Wall': The material from which the wall of the duct is constructed.
class IFC_PARSE_API IfcDistributionChamberElement : public IfcDistributionFlowElement {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcDistributionChamberElement
    bool hasPredefinedType() const;
    IfcDistributionChamberElementTypeEnum::IfcDistributionChamberElementTypeEnum PredefinedType() const;
    void setPredefinedType(IfcDistributionChamberElementTypeEnum::IfcDistributionChamberElementTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcDistributionFlowElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcDistributionChamberElementTypeEnum; } return IfcDistributionFlowElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "PredefinedType"; } return IfcDistributionFlowElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcDistributionChamberElement (IfcEntityInstanceData* e);
    IfcDistributionChamberElement (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcDistributionChamberElementTypeEnum::IfcDistributionChamberElementTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcDistributionChamberElement > list;
};

class IFC_PARSE_API IfcDistributionCircuit : public IfcDistributionSystem {
public:
    virtual unsigned int getArgumentCount() const { return 7; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcDistributionSystem::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcDistributionSystem::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcDistributionSystem::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcDistributionCircuit (IfcEntityInstanceData* e);
    IfcDistributionCircuit (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, boost::optional< std::string > v6_LongName, boost::optional< IfcDistributionSystemEnum::IfcDistributionSystemEnum > v7_PredefinedType);
    typedef IfcTemplatedEntityList< IfcDistributionCircuit > list;
};
/// The distribution element IfcDistributionControlElement defines occurrence elements of a building automation control system that are used to impart control over elements of a distribution system.
/// 
/// This class defines elements of a building automation control system. These are typically used to control distribution system elements to maintain  variables such as temperature, humidity, pressure, flow, power, or lighting levels, through the modulation, staging or sequencing of mechanical or electrical devices. The three general functional categories of control elements are as follows:
/// 
/// Impart control over flow control elements (IfcFlowController) in a distribution system such as dampers, valves, or relays, typically through the use of actuation (IfcActuator).
/// Sensing elements (IfcSensor) that measure changes in the controlled variable such as temperature, humidity, pressure, or flow.
/// Controllers (IfcController) typically classified according to the control action they seek to perform and generally responsible for making decisions about the elements under control.
/// 
/// Since this class and its subtypes typically relate to many different distribution flow elements (IfcDistributionFlowElement), the objectified relationship IfcRelFlowControlElements has been provided to relate control and flow elements as required.
/// 
/// IFC2x4 CHANGE: ControlElementId attribute deleted; replaced by classification usage.
/// HISTORY: New entity in IFC R2.0.
/// 
/// Type Use Definition
/// IfcDistributionControlElement defines the occurrence of any distribution control element; common information about distribution control element types is handled by IfcDistributionControlElementType.  The IfcDistributionControlElementType (if present) may establish the common type name, usage (predefined type), properties, materials, ports, composition, assignments, and representations.  The IfcDistributionControlElementType is attached using the IfcRelDefinesByType objectified relationship and is accessible by the IsTypedBy inverse attribute.  If the IfcDistributionControlElementType has ports or aggregated elements, such objects are reflected at the IfcDistributionControlElement occurrence using the IfcRelDefinesByObject relationship.  Direct instantiation of IfcDistributionControlElement with IfcObject.ObjectType asserted provides the meaning of a distribution control element proxy.
/// 
/// Property Set Use Definition
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the IfcRelDefinesByProperties relationship. They are accessible by the IsDefinedBy inverse attribute.  Property sets may also be specified at the IfcDistributionControlElementType, defining the common property data for all occurrences of the same type.  They are then accessible by the IsTypedBy inverse attribute pointing to IfcDistributionControlElementType.HasPropertySets. If both are given, then the properties directly defined at IfcDistributionControlElement override the properties defined at IfcDistributionControlElementType.  Refer to the documentation at the supertype IfcDistributionElement and ancestors for inherited property set definitions.
/// 
/// Classification Use Definition
/// In addition to general product and project classification (UniFormat, etc.), classifications may also be applied to indicate a device address or addressing scheme using IfcRelAssociatesClassification where RelatedObjects contains the  IfcDistributionControlElement and RelatingClassification refers to an IfcClassification or IfcClassificationReference.
/// 
/// IfcClassification: Indicates an addressing scheme managed by the device where ReferenceTokens defines the format of the address to be specified at IfcClassificationReference.ItemReference.  A classification hierarchy may optionally be provided indicating detected or provisioned device addresses.
/// IfcClassificationReference: Indicates the address of the control element where Identification uniquely identifies the element within the control system as determined by the ClassificationSource.  Several examples are illustrated:
/// 
/// 'BACnet': BACnetObjectIdentifier in the decimal form '12.15' (Digital Input #15) indicating type ID and instance ID.
/// 'IP': IP Address in the decimal form '192.168.1.2' such as for an IPv4 network.
/// 'OPC': Hierarchical ItemID in the alphanumeric form 'B204.Tank2.Temperature'
/// 'X-10': Alphabetic and numeric code in the form 'B12' (House B, Device 12) indicating House Code and Device Code.
/// 
/// Figure 147 illustrates classification usage.
/// 
/// Figure 147 — Distribution control classification
/// 
/// Composition Use Definition
/// The IfcDistributionControlElement may be decomposed into components using IfcRelAggregates where RelatingObject refers to the enclosing IfcDistributionControlElement and RelatedObjects contains one or more components.  Likewise, a control element may be aggregated within another element.  For example, a thermostat may contain temperature sensors, and a programmable logic controller may contain virtual (software-based) control elements.  Standard types for composition are defined at subtypes.
/// 
/// Connection Use Definition
/// The IfcDistributionControlElement may be connected to other objects as follows using the indicated relationship:
/// 
/// IfcSpatialStructureElement (IfcRelContainedInSpatialStructure) : Indicates the spatial location containing the element.  If an element is aggregated within another element, then only the top-level element participates in this relationship.
/// IfcElement (IfcRelConnectsElements) : Indicates physical connectivity with another element (but not embedding or flow control), such as a sensor attached to a wall.  IfcRelConnectsElements.RelatingElement refers to the anchored side (for example, wall hosting sensor).
/// IfcDistributionPort (IfcRelConnectsPortToElement) : Indicates ports on the element which may be connected to other elements for control signal transmission or electric power.  Standard port names, types, and directions are defined at subtypes.
/// IfcDistributionFlowElement (IfcRelFlowControlElements) : Indicates a flow element is sensed or controlled by the control element, such as a tank for a level sensor or a valve for an actuator.
/// 
/// Assignment Use Definition
/// The IfcDistributionControlElement may be assigned to the following entities using relationships as indicated:
/// 
/// IfcDistributionSystem (IfcRelAssignsToGroup): Indicates a system containing interconnected devices, where control elements are typically part of a control system having PredefinedType=CONTROL.
/// IfcPerformanceHistory (IfcRelAssignsToControl): Indicates realtime or historical infomation captured for the device.
/// 
/// The IfcDistributionControlElement may have assignments of its own using the IfcRelAssignsToProduct relationship where RelatingProduct refers to the IfcDistributionControlElement and RelatedObjects contains one or more objects of the following types: 
/// 
/// IfcTask: Indicates tasks used to purchase, install, renovate, demolish, operate, or otherwise act upon the element.  If the element has a type, available task types are assigned to the element type.
/// IfcProcedure: Indicates procedures used to operate the element.  If the element has a type, available procedure types are assigned to the element type.
/// IfcEvent: Indicates events raised by the element, sequenced by procedures to be followed.  If the element has a type, available event types are assigned to the element type.
/// 
/// Material Use Definition
/// The material of the IfcDistributionControlElement is defined using one of the following entities:
/// 
/// IfcMaterialConstituentSet: For elements containing multiple materials, this indicates materials at named aspects.
/// 
/// IfcMaterial: For elements comprised of a single material, this indicates the material.
/// 
/// The material is attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship.  It is accessible by the HasAssociations inverse attribute.  Material information can also be given at the IfcDistributionControlElementType, defining the common attribute data for all occurrences of the same type.  Standard names and material types are defined at subtypes.
/// 
/// Representation Use Definition
/// The following shape representations are supported for subtypes of IfcDistributionControlElement, distinguished by IfcShapeRepresentation.RepresentationIdentifier:
/// 
/// 'Footprint': Represents the 2D footprint outline of the item having IfcShapeRepresentation.RepresentationType of 'GeometricCurveSet' and containing a single IfcGeometricCurveSet consisting of one or more IfcCurve subtypes such as IfcPolyline, IfcTrimmedCurve, IfcCompositeCurve, or IfcCircle.
/// 
/// 'Body': Represents the 3D shape of the item having IfcShapeRepresentation.RepresentationType of 'SurfaceModel', 'SolidModel', or any solid model specializations including 'Brep', 'AdvancedBrep', 'SweptSolid', 'AdvancedSweptSolid', 'CSG', 'Clipping', or 'SectionedSpine').
/// 
/// 'Clearance': Represents the 3D clearance volume of the item having RepresentationType of 'Surface3D'.  Such clearance region indicates space that should not intersect with the 'Body' representation of other elements, though may intersect with the 'Clearance' representation of other elements.  The particular use of clearance space may be for safety, maintenance, or other purpose.
/// 
/// For all representations, if a IfcDistributionControlElement occurrence is defined by a IfcDistributionControlElementType having a representation of the same identifier, then 'MappedRepresentation' should be used at the occurrence unless overridden.
/// 
/// If materials are defined, geometry of each representation (most typically the 'Body' representation) may be organized into shape aspects where styles may be derived by correlating IfcShapeAspect.Name to a corresponding material (IfcMaterialConstituent.Name).
class IFC_PARSE_API IfcDistributionControlElement : public IfcDistributionElement {
public:
    virtual unsigned int getArgumentCount() const { return 8; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { return IfcDistributionElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { return IfcDistributionElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { return IfcDistributionElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    IfcTemplatedEntityList< IfcRelFlowControlElements >::ptr AssignedToFlowElement() const; // INVERSE IfcRelFlowControlElements::RelatedControlElements
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcDistributionControlElement (IfcEntityInstanceData* e);
    IfcDistributionControlElement (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag);
    typedef IfcTemplatedEntityList< IfcDistributionControlElement > list;
};
/// A duct fitting is a junction or transition in a ducted flow distribution system or used to connect duct segments, resulting changes in flow characteristics to the fluid such as direction and flow rate. 
/// 
/// HISTORY  New entity in IFC2x4
/// 
/// Type Use Definition
/// IfcDuctFitting defines the occurrence of any duct fitting; common information about duct fitting types is handled by IfcDuctFittingType. 
/// The IfcDuctFittingType (if present) may establish the common type name, usage (predefined type), properties, materials, ports, composition, assignments, and representations. 
/// The IfcDuctFittingType is attached using the IfcRelDefinesByType objectified relationship and is accessible by the IsTypedBy inverse attribute. 
/// If the IfcDuctFittingType has ports or aggregated elements, such objects are reflected at the IfcDuctFitting occurrence using the IfcRelDefinesByObject relationship.
/// 
/// Property Use Definition
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute. 
/// Property sets may also be specified at the IfcDuctFittingType, defining the common property data for all occurrences of the same type. 
/// They are then accessible by the IsTypedBy inverse attribute pointing to IfcDuctFittingType.HasPropertySets. 
/// If both are given, then the properties directly defined at IfcDuctFitting override the properties defined at IfcDuctFittingType. 
/// Refer to the documentation at the supertype IfcFlowFitting and ancestors for inherited property set definitions.
/// The following property set definitions are applicable to this entity:
/// Pset_DuctFittingOccurrence (PSET_OCCURRENCEDRIVEN)
/// Pset_DuctFittingPHistory (PSET_PERFORMANCEDRIVEN)
/// Pset_DuctFittingTypeCommon (PSET_TYPEDRIVENOVERRIDE)
/// 
/// Quantity Use Definition
/// The quantities relating to this entity are defined by IfcElementQuantity and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute.
/// The following base quantities are defined and shall be exchanged with the IfcElementQuantity.Name = 'BaseQuantities'. 
/// Other quantities, being subjected to local standard of measurement, may be defined with another string value assigned to Name. 
/// In this case a valid value for MethodOfMeasurement shall be provided. 
/// 
/// Qto_DuctFittingBaseQuantities
/// 
/// Material Use Definition
/// The material of the IfcDuctFitting is defined by IfcMaterialProfileSetUsage or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship. It is accessible by the HasAssociations inverse attribute. Material information can also be given at the IfcDuctFittingType, defining the common attribute data for all occurrences of the same type. The following keywords for IfcMaterialProfileSet.MaterialProfiles[n].Name shall be used:
/// 
/// Body: Material from which the duct fitting is constructed.
/// Coating: The outer coating, if applicable.
/// Insulation: The insulating wrapping, if applicable.
/// Lining: The inner lining, if applicable.
/// 
/// Port Use Definition
/// The distribution ports relating to the IfcDuctFitting are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship. 
///   If the duct fitting occurrence is defined by IfcDuctFittingType, then the port occurrences must reflect those defined at the IfcDuctFittingType using the IfcRelDefinesByObject relationship.
///   Ports are specific to the IfcDuctFitting PredefinedType as follows indicated by the IfcDistributionPort Name, PredefinedType, and FlowDirection:
/// 
/// BEND
/// 
/// Inlet (NOTDEFINED, SINK): The flow inlet.
/// Outlet (NOTDEFINED, SOURCE): The flow outlet.
/// 
/// CONNECTOR
/// 
/// Inlet (NOTDEFINED, SINK): The flow inlet.
/// Outlet (NOTDEFINED, SOURCE): The flow outlet.
/// 
/// ENTRY
/// 
/// Outlet (NOTDEFINED, SOURCE): The flow outlet.
/// 
/// EXIT
/// 
/// Inlet (NOTDEFINED, SINK): The flow inlet.
/// 
/// JUNCTION
/// 
/// Inlet (NOTDEFINED, SINK): The flow inlet.
/// Outlet#1 (NOTDEFINED, SOURCE): The first flow outlet.
/// Outlet#2 (NOTDEFINED, SOURCE): The second flow outlet.
/// 
/// OBSTRUCTION
/// 
/// Inlet (NOTDEFINED, SINK): The flow inlet.
/// Outlet (NOTDEFINED, SOURCE): The flow outlet.
/// 
/// Figure 221 illustrates duct fitting port use.
/// Figure 221 — Duct fitting port use
class IFC_PARSE_API IfcDuctFitting : public IfcFlowFitting {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcDuctFitting
    bool hasPredefinedType() const;
    IfcDuctFittingTypeEnum::IfcDuctFittingTypeEnum PredefinedType() const;
    void setPredefinedType(IfcDuctFittingTypeEnum::IfcDuctFittingTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcFlowFitting::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcDuctFittingTypeEnum; } return IfcFlowFitting::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "PredefinedType"; } return IfcFlowFitting::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcDuctFitting (IfcEntityInstanceData* e);
    IfcDuctFitting (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcDuctFittingTypeEnum::IfcDuctFittingTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcDuctFitting > list;
};
/// A duct segment is used to typically join two sections of duct network. 
/// 
/// HISTORY  New entity in IFC2x4
/// 
/// Type Use Definition
/// IfcDuctSegment defines the occurrence of any duct segment; common information about duct segment types is handled by IfcDuctSegmentType. 
/// The IfcDuctSegmentType (if present) may establish the common type name, usage (predefined type), properties, materials, ports, composition, assignments, and representations. 
/// The IfcDuctSegmentType is attached using the IfcRelDefinesByType objectified relationship and is accessible by the IsTypedBy inverse attribute. 
/// If the IfcDuctSegmentType has ports or aggregated elements, such objects are reflected at the IfcDuctSegment occurrence using the IfcRelDefinesByObject relationship.
/// 
/// Property Use Definition
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute. 
/// Property sets may also be specified at the IfcDuctSegmentType, defining the common property data for all occurrences of the same type. 
/// They are then accessible by the IsTypedBy inverse attribute pointing to IfcDuctSegmentType.HasPropertySets. 
/// If both are given, then the properties directly defined at IfcDuctSegment override the properties defined at IfcDuctSegmentType. 
/// Refer to the documentation at the supertype IfcFlowSegment and ancestors for inherited property set definitions.
/// The following property set definitions are applicable to this entity:
/// Pset_DuctSegmentOccurrence (PSET_OCCURRENCEDRIVEN)
/// Pset_DuctSegmentPHistory (PSET_PERFORMANCEDRIVEN)
/// Pset_DuctSegmentTypeCommon (PSET_TYPEDRIVENOVERRIDE)
/// 
/// Quantity Use Definition
/// The quantities relating to this entity are defined by IfcElementQuantity and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute.
/// The following base quantities are defined and shall be exchanged with the IfcElementQuantity.Name = 'BaseQuantities'. 
/// Other quantities, being subjected to local standard of measurement, may be defined with another string value assigned to Name. 
/// In this case a valid value for MethodOfMeasurement shall be provided. 
/// 
/// Qto_DuctSegmentBaseQuantities
/// 
/// Material Use Definition
/// The material of the IfcDuctSegment is defined by IfcMaterialProfileSetUsage or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship. It is accessible by the HasAssociations inverse attribute. Material information can also be given at the IfcDuctSegmentType, defining the common attribute data for all occurrences of the same type. The following keywords for IfcMaterialProfileSet.MaterialProfiles[n].Name shall be used:
/// 
/// Body: Material from which the duct fitting is constructed.
/// Coating: The outer coating, if applicable.
/// Insulation: The insulating wrapping, if applicable.
/// Lining: The inner lining, if applicable.
/// 
/// Port Use Definition
/// The distribution ports relating to the IfcDuctSegment are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship. 
///   If the duct segment occurrence is defined by IfcDuctSegmentType, then the port occurrences must reflect those defined at the IfcDuctSegmentType using the IfcRelDefinesByObject relationship.
///   Ports are specific to the IfcDuctSegment PredefinedType as follows indicated by the IfcDistributionPort Name, PredefinedType, and FlowDirection:
/// 
/// Inlet (NOTDEFINED, SINK): The flow inlet.
/// Outlet (NOTDEFINED, SOURCE): The flow outlet.
/// 
/// Figure 222 illustrates duct segment port use.
/// Figure 222 — Duct segment port use
class IFC_PARSE_API IfcDuctSegment : public IfcFlowSegment {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcDuctSegment
    bool hasPredefinedType() const;
    IfcDuctSegmentTypeEnum::IfcDuctSegmentTypeEnum PredefinedType() const;
    void setPredefinedType(IfcDuctSegmentTypeEnum::IfcDuctSegmentTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcFlowSegment::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcDuctSegmentTypeEnum; } return IfcFlowSegment::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "PredefinedType"; } return IfcFlowSegment::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcDuctSegment (IfcEntityInstanceData* e);
    IfcDuctSegment (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcDuctSegmentTypeEnum::IfcDuctSegmentTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcDuctSegment > list;
};
/// A duct silencer is a device that is typically installed inside a duct distribution system for the purpose of reducing the noise levels from air movement, fan noise, etc. in the adjacent space or downstream of the duct silencer device. 
/// 
/// HISTORY  New entity in IFC2x4
/// 
/// Type Use Definition
/// IfcDuctSilencer defines the occurrence of any duct silencer; common information about duct silencer types is handled by IfcDuctSilencerType. 
/// The IfcDuctSilencerType (if present) may establish the common type name, usage (predefined type), properties, materials, ports, composition, assignments, and representations. 
/// The IfcDuctSilencerType is attached using the IfcRelDefinesByType objectified relationship and is accessible by the IsTypedBy inverse attribute. 
/// If the IfcDuctSilencerType has ports or aggregated elements, such objects are reflected at the IfcDuctSilencer occurrence using the IfcRelDefinesByObject relationship.
/// 
/// Property Use Definition
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute. 
/// Property sets may also be specified at the IfcDuctSilencerType, defining the common property data for all occurrences of the same type. 
/// They are then accessible by the IsTypedBy inverse attribute pointing to IfcDuctSilencerType.HasPropertySets. 
/// If both are given, then the properties directly defined at IfcDuctSilencer override the properties defined at IfcDuctSilencerType. 
/// Refer to the documentation at the supertype IfcFlowTreatmentDevice and ancestors for inherited property set definitions.
/// The following property set definitions are applicable to this entity:
/// Pset_DuctSilencerPHistory (PSET_PERFORMANCEDRIVEN)
/// Pset_DuctSilencerTypeCommon (PSET_TYPEDRIVENOVERRIDE)
/// 
/// Quantity Use Definition
/// The quantities relating to this entity are defined by IfcElementQuantity and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute.
/// The following base quantities are defined and shall be exchanged with the IfcElementQuantity.Name = 'BaseQuantities'. 
/// Other quantities, being subjected to local standard of measurement, may be defined with another string value assigned to Name. 
/// In this case a valid value for MethodOfMeasurement shall be provided. 
/// 
/// Qto_DuctSilencerBaseQuantities
/// 
/// Material Use Definition
/// The material of the IfcDuctSilencer is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship. It is accessible by the HasAssociations inverse attribute. Material information can also be given at the IfcDuctSilencerType, defining the common attribute data for all occurrences of the same type. The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used:
/// 
/// Body: The primary material from which the object is constructed.
/// 
/// Port Use Definition
/// The distribution ports relating to the IfcDuctSilencer are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship. 
///   If the duct silencer occurrence is defined by IfcDuctSilencerType, then the port occurrences must reflect those defined at the IfcDuctSilencerType using the IfcRelDefinesByObject relationship.
///   Ports are specific to the IfcDuctSilencer PredefinedType as follows indicated by the IfcDistributionPort Name, PredefinedType, and FlowDirection:
/// 
/// Inlet (NOTDEFINED, SINK): The flow inlet.
/// Outlet (NOTDEFINED, SOURCE): The flow outlet.
class IFC_PARSE_API IfcDuctSilencer : public IfcFlowTreatmentDevice {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcDuctSilencer
    bool hasPredefinedType() const;
    IfcDuctSilencerTypeEnum::IfcDuctSilencerTypeEnum PredefinedType() const;
    void setPredefinedType(IfcDuctSilencerTypeEnum::IfcDuctSilencerTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcFlowTreatmentDevice::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcDuctSilencerTypeEnum; } return IfcFlowTreatmentDevice::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "PredefinedType"; } return IfcFlowTreatmentDevice::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcDuctSilencer (IfcEntityInstanceData* e);
    IfcDuctSilencer (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcDuctSilencerTypeEnum::IfcDuctSilencerTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcDuctSilencer > list;
};
/// A communications appliance transmits and receives electronic or digital information as data or sound.
/// Communication appliances may be fixed in place or may be able to be moved from one space to another. Communication appliances require an electrical supply that may be supplied either by an electrical circuit or provided from a local battery source. 
/// 
/// HISTORY  New entity in IFC2x4
/// 
/// Type Use Definition
/// IfcElectricAppliance defines the occurrence of any electric appliance; common information about electric appliance types is handled by IfcElectricApplianceType. 
/// The IfcElectricApplianceType (if present) may establish the common type name, usage (predefined type), properties, materials, ports, composition, assignments, and representations. 
/// The IfcElectricApplianceType is attached using the IfcRelDefinesByType objectified relationship and is accessible by the IsTypedBy inverse attribute. 
/// If the IfcElectricApplianceType has ports or aggregated elements, such objects are reflected at the IfcElectricAppliance occurrence using the IfcRelDefinesByObject relationship.
/// Figure 196 illustrates electric appliance type use.
/// Figure 196 — Electric appliance type use
/// 
/// Property Use Definition
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute. 
/// Property sets may also be specified at the IfcElectricApplianceType, defining the common property data for all occurrences of the same type. 
/// They are then accessible by the IsTypedBy inverse attribute pointing to IfcElectricApplianceType.HasPropertySets. 
/// If both are given, then the properties directly defined at IfcElectricAppliance override the properties defined at IfcElectricApplianceType. 
/// Refer to the documentation at the supertype IfcFlowTerminal and ancestors for inherited property set definitions.
/// The following property set definitions are applicable to this entity:
/// (All Types)
/// 
/// Pset_ElectricAppliancePHistory (PSET_PERFORMANCEDRIVEN)
/// Pset_ElectricApplianceTypeCommon (PSET_TYPEDRIVENOVERRIDE)
/// 
/// DISHWASHER
/// 
/// Pset_ElectricApplianceTypeDishwasher (PSET_TYPEDRIVENOVERRIDE)
/// 
/// ELECTRICCOOKER
/// 
/// Pset_ElectricApplianceTypeElectricCooker (PSET_TYPEDRIVENOVERRIDE)
/// 
/// Quantity Use Definition
/// The quantities relating to this entity are defined by IfcElementQuantity and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute.
/// The following base quantities are defined and shall be exchanged with the IfcElementQuantity.Name = 'BaseQuantities'. 
/// Other quantities, being subjected to local standard of measurement, may be defined with another string value assigned to Name. 
/// In this case a valid value for MethodOfMeasurement shall be provided. 
/// 
/// Qto_ElectricApplianceBaseQuantities
/// 
/// Material Use Definition
/// The material of the IfcElectricAppliance is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship. It is accessible by the HasAssociations inverse attribute. Material information can also be given at the IfcElectricApplianceType, defining the common attribute data for all occurrences of the same type. The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used:
/// 
/// Casing: Material from which the casing is constructed.
/// 
/// Port Use Definition
/// The distribution ports relating to the IfcElectricAppliance are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship. 
///   If the electric appliance occurrence is defined by IfcElectricApplianceType, then the port occurrences must reflect those defined at the IfcElectricApplianceType using the IfcRelDefinesByObject relationship.
///   Ports are specific to the IfcElectricAppliance PredefinedType as follows indicated by the IfcDistributionPort Name, PredefinedType, and FlowDirection:
/// 
/// DISHWASHER
/// 
/// Power (ELECTRICAL, SINK): Receives electrical power.
/// HotWater (DOMESTICHOTWATER, SINK): Hot water used for washing dishes.
/// 
/// ELECTRICCOOKER
/// 
/// Power (ELECTRICAL, SINK): Receives electrical power.
/// 
/// FREEZER
/// 
/// Power (ELECTRICAL, SINK): Receives electrical power.
/// 
/// FRIDGE_FREEZER
/// 
/// Power (ELECTRICAL, SINK): Receives electrical power.
/// ColdWater (DOMESTICCOLDWATER, SINK): Cold water used for icemaking and/or drinking water.
/// 
/// HANDDRYER
/// 
/// Power (ELECTRICAL, SINK): Receives electrical power.
/// 
/// MICROWAVE
/// 
/// Power (ELECTRICAL, SINK): Receives electrical power.
/// 
/// REFRIGERATOR
/// 
/// Power (ELECTRICAL, SINK): Receives electrical power.
/// 
/// TUMBLEDRYER
/// 
/// Power (ELECTRICAL, SINK): Receives electrical power.
/// Gas (GAS, SINK): Gas source if applicable.
/// Exhaust (EXHAUST, SOURCE): Exhaust air.
/// 
/// WASHINGMACHINE
/// 
/// Power (ELECTRICAL, SINK): Receives electrical power.
/// ColdWater (DOMESTICCOLDWATER, SINK): Cold water used for washing.
/// HotWater (DOMESTICHOTWATER, SINK): Hot water used for washing.
/// Drain (DRAINAGE, SOURCE): Drainage for water.
/// 
/// Figure 197 illustrates electric appliance port use.
/// Figure 197 — Electric appliance port use
class IFC_PARSE_API IfcElectricAppliance : public IfcFlowTerminal {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcElectricAppliance
    bool hasPredefinedType() const;
    IfcElectricApplianceTypeEnum::IfcElectricApplianceTypeEnum PredefinedType() const;
    void setPredefinedType(IfcElectricApplianceTypeEnum::IfcElectricApplianceTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcFlowTerminal::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcElectricApplianceTypeEnum; } return IfcFlowTerminal::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "PredefinedType"; } return IfcFlowTerminal::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcElectricAppliance (IfcEntityInstanceData* e);
    IfcElectricAppliance (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcElectricApplianceTypeEnum::IfcElectricApplianceTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcElectricAppliance > list;
};
/// A distribution board is a flow controller in which instances of electrical devices are brought together at a single place for a particular purpose.
/// A distribution provides a housing for connected electrical distribution elements so that they can be viewed, operated or acted upon from a single place. Each connected item may have its own geometric representation and location. 
/// 
/// HISTORY  New entity in IFC2x4
/// 
/// Type Use Definition
/// IfcElectricDistributionBoard defines the occurrence of any electric distribution board; common information about electric distribution board types is handled by IfcElectricDistributionBoardType. 
/// The IfcElectricDistributionBoardType (if present) may establish the common type name, usage (predefined type), properties, materials, ports, composition, assignments, and representations. 
/// The IfcElectricDistributionBoardType is attached using the IfcRelDefinesByType objectified relationship and is accessible by the IsTypedBy inverse attribute. 
/// If the IfcElectricDistributionBoardType has ports or aggregated elements, such objects are reflected at the IfcElectricDistributionBoard occurrence using the IfcRelDefinesByObject relationship.
/// Figure 198 illustrates electric distribution board type use.
/// Figure 198 — Electric distribution board type use
/// 
/// Property Use Definition
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute. 
/// Property sets may also be specified at the IfcElectricDistributionBoardType, defining the common property data for all occurrences of the same type. 
/// They are then accessible by the IsTypedBy inverse attribute pointing to IfcElectricDistributionBoardType.HasPropertySets. 
/// If both are given, then the properties directly defined at IfcElectricDistributionBoard override the properties defined at IfcElectricDistributionBoardType. 
/// Refer to the documentation at the supertype IfcFlowController and ancestors for inherited property set definitions.
/// The following property set definitions are applicable to this entity:
/// Pset_ElectricDistributionBoardTypeCommon (PSET_TYPEDRIVENOVERRIDE)
/// 
/// Quantity Use Definition
/// The quantities relating to this entity are defined by IfcElementQuantity and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute.
/// The following base quantities are defined and shall be exchanged with the IfcElementQuantity.Name = 'BaseQuantities'. 
/// Other quantities, being subjected to local standard of measurement, may be defined with another string value assigned to Name. 
/// In this case a valid value for MethodOfMeasurement shall be provided. 
/// 
/// Qto_ElectricDistributionBoardBaseQuantities
/// 
/// Material Use Definition
/// The material of the IfcElectricDistributionBoard is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship. It is accessible by the HasAssociations inverse attribute. Material information can also be given at the IfcElectricDistributionBoardType, defining the common attribute data for all occurrences of the same type. The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used:
/// 
/// Casing: Material from which the casing is constructed.
/// 
/// Port Use Definition
/// The distribution ports relating to the IfcElectricDistributionBoard are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship. 
///   If the electric distribution board occurrence is defined by IfcElectricDistributionBoardType, then the port occurrences must reflect those defined at the IfcElectricDistributionBoardType using the IfcRelDefinesByObject relationship.
///   Ports are specific to the IfcElectricDistributionBoard PredefinedType as follows indicated by the IfcDistributionPort Name, PredefinedType, and FlowDirection:
/// 
/// CONSUMERUNIT
/// 
/// Line (ELECTRICAL, SINK): Incoming power, such as a cable connecting from the electrical utility or another distribution board.
/// Ground (EARTHING, SOURCE): Grounding connection, such as a cable connecting to a cable fitting connected to a cold water pipe segment coming from the ground.
/// Circuit#1 (ELECTRICAL, SOURCE): A downstream circuit, typically a circuit breaker protective device.
/// Circuit#2 (ELECTRICAL, SOURCE): A downstream circuit, typically a circuit breaker protective device.
/// Circuit#3 (ELECTRICAL, SOURCE): A downstream circuit, typically a circuit breaker protective device.
/// Circuit#4 (ELECTRICAL, SOURCE): A downstream circuit, typically a circuit breaker protective device.
/// Circuit#5 (ELECTRICAL, SOURCE): A downstream circuit, typically a circuit breaker protective device.
/// Circuit#6 (ELECTRICAL, SOURCE): A downstream circuit, typically a circuit breaker protective device.
/// Circuit#7 (ELECTRICAL, SOURCE): A downstream circuit, typically a circuit breaker protective device.
/// Circuit#8 (ELECTRICAL, SOURCE): A downstream circuit, typically a circuit breaker protective device.
/// 
/// Figure 199 illustrates electric distribution board port use.
/// Figure 199 — Electric distribution board port use
class IFC_PARSE_API IfcElectricDistributionBoard : public IfcFlowController {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcElectricDistributionBoard
    bool hasPredefinedType() const;
    IfcElectricDistributionBoardTypeEnum::IfcElectricDistributionBoardTypeEnum PredefinedType() const;
    void setPredefinedType(IfcElectricDistributionBoardTypeEnum::IfcElectricDistributionBoardTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcFlowController::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcElectricDistributionBoardTypeEnum; } return IfcFlowController::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "PredefinedType"; } return IfcFlowController::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcElectricDistributionBoard (IfcEntityInstanceData* e);
    IfcElectricDistributionBoard (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcElectricDistributionBoardTypeEnum::IfcElectricDistributionBoardTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcElectricDistributionBoard > list;
};
/// An electric flow storage device is a device in which electrical energy is stored and from which energy may be progressively released. 
/// 
/// HISTORY  New entity in IFC2x4
/// 
/// Type Use Definition
/// IfcElectricFlowStorageDevice defines the occurrence of any electric flow storage device; common information about electric flow storage device types is handled by IfcElectricFlowStorageDeviceType. 
/// The IfcElectricFlowStorageDeviceType (if present) may establish the common type name, usage (predefined type), properties, materials, ports, composition, assignments, and representations. 
/// The IfcElectricFlowStorageDeviceType is attached using the IfcRelDefinesByType objectified relationship and is accessible by the IsTypedBy inverse attribute. 
/// If the IfcElectricFlowStorageDeviceType has ports or aggregated elements, such objects are reflected at the IfcElectricFlowStorageDevice occurrence using the IfcRelDefinesByObject relationship.
/// 
/// Property Use Definition
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute. 
/// Property sets may also be specified at the IfcElectricFlowStorageDeviceType, defining the common property data for all occurrences of the same type. 
/// They are then accessible by the IsTypedBy inverse attribute pointing to IfcElectricFlowStorageDeviceType.HasPropertySets. 
/// If both are given, then the properties directly defined at IfcElectricFlowStorageDevice override the properties defined at IfcElectricFlowStorageDeviceType. 
/// Refer to the documentation at the supertype IfcFlowStorageDevice and ancestors for inherited property set definitions.
/// The following property set definitions are applicable to this entity:
/// Pset_ElectricFlowStorageDeviceTypeCommon (PSET_TYPEDRIVENOVERRIDE)
/// 
/// Quantity Use Definition
/// The quantities relating to this entity are defined by IfcElementQuantity and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute.
/// The following base quantities are defined and shall be exchanged with the IfcElementQuantity.Name = 'BaseQuantities'. 
/// Other quantities, being subjected to local standard of measurement, may be defined with another string value assigned to Name. 
/// In this case a valid value for MethodOfMeasurement shall be provided. 
/// 
/// Qto_ElectricFlowStorageDeviceBaseQuantities
/// 
/// Material Use Definition
/// The material of the IfcElectricFlowStorageDevice is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship. It is accessible by the HasAssociations inverse attribute. Material information can also be given at the IfcElectricFlowStorageDeviceType, defining the common attribute data for all occurrences of the same type. The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used:
/// 
/// Casing: Material from which the casing is constructed.
/// 
/// Port Use Definition
/// The distribution ports relating to the IfcElectricFlowStorageDevice are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship. 
///   If the electric flow storage device occurrence is defined by IfcElectricFlowStorageDeviceType, then the port occurrences must reflect those defined at the IfcElectricFlowStorageDeviceType using the IfcRelDefinesByObject relationship.
///   Ports are specific to the IfcElectricFlowStorageDevice PredefinedType as follows indicated by the IfcDistributionPort Name, PredefinedType, and FlowDirection:
/// 
/// Line (ELECTRICAL, SINK): Incoming power used to charge the flow storage device.
/// Load (ELECTRICAL, SOURCE): Outgoing power backed by the flow storage device.
class IFC_PARSE_API IfcElectricFlowStorageDevice : public IfcFlowStorageDevice {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcElectricFlowStorageDevice
    bool hasPredefinedType() const;
    IfcElectricFlowStorageDeviceTypeEnum::IfcElectricFlowStorageDeviceTypeEnum PredefinedType() const;
    void setPredefinedType(IfcElectricFlowStorageDeviceTypeEnum::IfcElectricFlowStorageDeviceTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcFlowStorageDevice::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcElectricFlowStorageDeviceTypeEnum; } return IfcFlowStorageDevice::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "PredefinedType"; } return IfcFlowStorageDevice::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcElectricFlowStorageDevice (IfcEntityInstanceData* e);
    IfcElectricFlowStorageDevice (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcElectricFlowStorageDeviceTypeEnum::IfcElectricFlowStorageDeviceTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcElectricFlowStorageDevice > list;
};
/// An electric generator is an engine that is a machine for converting mechanical energy into electrical energy. 
/// 
/// HISTORY  New entity in IFC2x4
/// 
/// Type Use Definition
/// IfcElectricGenerator defines the occurrence of any electric generator; common information about electric generator types is handled by IfcElectricGeneratorType. 
/// The IfcElectricGeneratorType (if present) may establish the common type name, usage (predefined type), properties, materials, ports, composition, assignments, and representations. 
/// The IfcElectricGeneratorType is attached using the IfcRelDefinesByType objectified relationship and is accessible by the IsTypedBy inverse attribute. 
/// If the IfcElectricGeneratorType has ports or aggregated elements, such objects are reflected at the IfcElectricGenerator occurrence using the IfcRelDefinesByObject relationship.
/// 
/// Property Use Definition
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute. 
/// Property sets may also be specified at the IfcElectricGeneratorType, defining the common property data for all occurrences of the same type. 
/// They are then accessible by the IsTypedBy inverse attribute pointing to IfcElectricGeneratorType.HasPropertySets. 
/// If both are given, then the properties directly defined at IfcElectricGenerator override the properties defined at IfcElectricGeneratorType. 
/// Refer to the documentation at the supertype IfcEnergyConversionDevice and ancestors for inherited property set definitions.
/// The following property set definitions are applicable to this entity:
/// Pset_ElectricGeneratorTypeCommon (PSET_TYPEDRIVENOVERRIDE)
/// 
/// Quantity Use Definition
/// The quantities relating to this entity are defined by IfcElementQuantity and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute.
/// The following base quantities are defined and shall be exchanged with the IfcElementQuantity.Name = 'BaseQuantities'. 
/// Other quantities, being subjected to local standard of measurement, may be defined with another string value assigned to Name. 
/// In this case a valid value for MethodOfMeasurement shall be provided. 
/// 
/// Qto_ElectricGeneratorBaseQuantities
/// 
/// Material Use Definition
/// The material of the IfcElectricGenerator is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship. It is accessible by the HasAssociations inverse attribute. Material information can also be given at the IfcElectricGeneratorType, defining the common attribute data for all occurrences of the same type. The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used:
/// 
/// Casing: Material from which the casing is constructed.
/// 
/// Composition Use Definition
/// The IfcElectricGenerator may be aggregated into components using IfcRelAggregates where RelatingObject refers to the enclosing IfcElectricGenerator and RelatedObjects contains one or more components. Aggregation use is defined for the following predefined types:
/// 
/// ENGINEGENERATOR
/// 
/// May contain IfcEngine components. Engine-Generator sets may optionally include an engine to indicate specific detail.
/// 
/// Port Use Definition
/// The distribution ports relating to the IfcElectricGenerator are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship. 
///   If the electric generator occurrence is defined by IfcElectricGeneratorType, then the port occurrences must reflect those defined at the IfcElectricGeneratorType using the IfcRelDefinesByObject relationship.
///   Ports are specific to the IfcElectricGenerator PredefinedType as follows indicated by the IfcDistributionPort Name, PredefinedType, and FlowDirection:
/// 
/// Load (ELECTRICAL, SOURCE): Outgoing power from generator.
class IFC_PARSE_API IfcElectricGenerator : public IfcEnergyConversionDevice {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcElectricGenerator
    bool hasPredefinedType() const;
    IfcElectricGeneratorTypeEnum::IfcElectricGeneratorTypeEnum PredefinedType() const;
    void setPredefinedType(IfcElectricGeneratorTypeEnum::IfcElectricGeneratorTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcEnergyConversionDevice::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcElectricGeneratorTypeEnum; } return IfcEnergyConversionDevice::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "PredefinedType"; } return IfcEnergyConversionDevice::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcElectricGenerator (IfcEntityInstanceData* e);
    IfcElectricGenerator (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcElectricGeneratorTypeEnum::IfcElectricGeneratorTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcElectricGenerator > list;
};
/// An electric motor is an engine that is a machine for converting electrical energy into mechanical energy. 
/// 
/// HISTORY  New entity in IFC2x4
/// 
/// Type Use Definition
/// IfcElectricMotor defines the occurrence of any electric motor; common information about electric motor types is handled by IfcElectricMotorType. 
/// The IfcElectricMotorType (if present) may establish the common type name, usage (predefined type), properties, materials, ports, composition, assignments, and representations. 
/// The IfcElectricMotorType is attached using the IfcRelDefinesByType objectified relationship and is accessible by the IsTypedBy inverse attribute. 
/// If the IfcElectricMotorType has ports or aggregated elements, such objects are reflected at the IfcElectricMotor occurrence using the IfcRelDefinesByObject relationship.
/// 
/// Property Use Definition
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute. 
/// Property sets may also be specified at the IfcElectricMotorType, defining the common property data for all occurrences of the same type. 
/// They are then accessible by the IsTypedBy inverse attribute pointing to IfcElectricMotorType.HasPropertySets. 
/// If both are given, then the properties directly defined at IfcElectricMotor override the properties defined at IfcElectricMotorType. 
/// Refer to the documentation at the supertype IfcEnergyConversionDevice and ancestors for inherited property set definitions.
/// The following property set definitions are applicable to this entity:
/// Pset_ElectricMotorTypeCommon (PSET_TYPEDRIVENOVERRIDE)
/// 
/// Quantity Use Definition
/// The quantities relating to this entity are defined by IfcElementQuantity and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute.
/// The following base quantities are defined and shall be exchanged with the IfcElementQuantity.Name = 'BaseQuantities'. 
/// Other quantities, being subjected to local standard of measurement, may be defined with another string value assigned to Name. 
/// In this case a valid value for MethodOfMeasurement shall be provided. 
/// 
/// Qto_ElectricMotorBaseQuantities
/// 
/// Material Use Definition
/// The material of the IfcElectricMotor is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship. It is accessible by the HasAssociations inverse attribute. Material information can also be given at the IfcElectricMotorType, defining the common attribute data for all occurrences of the same type. The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used:
/// 
/// Casing: Material from which the casing is constructed.
/// 
/// Port Use Definition
/// The distribution ports relating to the IfcElectricMotor are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship. 
///   If the electric motor occurrence is defined by IfcElectricMotorType, then the port occurrences must reflect those defined at the IfcElectricMotorType using the IfcRelDefinesByObject relationship.
///   Ports are specific to the IfcElectricMotor PredefinedType as follows indicated by the IfcDistributionPort Name, PredefinedType, and FlowDirection:
/// 
/// Line (ELECTRICAL, SINK): Receives electrical power.
/// Drive (NOTDEFINED, SOURCE): Motor connection to a driven device.
class IFC_PARSE_API IfcElectricMotor : public IfcEnergyConversionDevice {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcElectricMotor
    bool hasPredefinedType() const;
    IfcElectricMotorTypeEnum::IfcElectricMotorTypeEnum PredefinedType() const;
    void setPredefinedType(IfcElectricMotorTypeEnum::IfcElectricMotorTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcEnergyConversionDevice::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcElectricMotorTypeEnum; } return IfcEnergyConversionDevice::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "PredefinedType"; } return IfcEnergyConversionDevice::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcElectricMotor (IfcEntityInstanceData* e);
    IfcElectricMotor (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcElectricMotorTypeEnum::IfcElectricMotorTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcElectricMotor > list;
};
/// An electric time control is a device that applies control to the provision or flow of electrical energy over time. 
/// 
/// HISTORY  New entity in IFC2x4
/// 
/// Type Use Definition
/// IfcElectricTimeControl defines the occurrence of any electric time control; common information about electric time control types is handled by IfcElectricTimeControlType. 
/// The IfcElectricTimeControlType (if present) may establish the common type name, usage (predefined type), properties, materials, ports, composition, assignments, and representations. 
/// The IfcElectricTimeControlType is attached using the IfcRelDefinesByType objectified relationship and is accessible by the IsTypedBy inverse attribute. 
/// If the IfcElectricTimeControlType has ports or aggregated elements, such objects are reflected at the IfcElectricTimeControl occurrence using the IfcRelDefinesByObject relationship.
/// 
/// Property Use Definition
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute. 
/// Property sets may also be specified at the IfcElectricTimeControlType, defining the common property data for all occurrences of the same type. 
/// They are then accessible by the IsTypedBy inverse attribute pointing to IfcElectricTimeControlType.HasPropertySets. 
/// If both are given, then the properties directly defined at IfcElectricTimeControl override the properties defined at IfcElectricTimeControlType. 
/// Refer to the documentation at the supertype IfcFlowController and ancestors for inherited property set definitions.
/// The following property set definitions are applicable to this entity:
/// Pset_ElectricTimeControlTypeCommon (PSET_TYPEDRIVENOVERRIDE)
/// 
/// Quantity Use Definition
/// The quantities relating to this entity are defined by IfcElementQuantity and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute.
/// The following base quantities are defined and shall be exchanged with the IfcElementQuantity.Name = 'BaseQuantities'. 
/// Other quantities, being subjected to local standard of measurement, may be defined with another string value assigned to Name. 
/// In this case a valid value for MethodOfMeasurement shall be provided. 
/// 
/// Qto_ElectricTimeControlBaseQuantities
/// 
/// Material Use Definition
/// The material of the IfcElectricTimeControl is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship. It is accessible by the HasAssociations inverse attribute. Material information can also be given at the IfcElectricTimeControlType, defining the common attribute data for all occurrences of the same type. The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used:
/// 
/// Casing: Material from which the casing is constructed.
/// 
/// Port Use Definition
/// The distribution ports relating to the IfcElectricTimeControl are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship. 
///   If the electric time control occurrence is defined by IfcElectricTimeControlType, then the port occurrences must reflect those defined at the IfcElectricTimeControlType using the IfcRelDefinesByObject relationship.
///   Ports are specific to the IfcElectricTimeControl PredefinedType as follows indicated by the IfcDistributionPort Name, PredefinedType, and FlowDirection:
/// 
/// Line (ELECTRICAL, SINK): Receives electrical power.
/// Load (ELECTRICAL, SOURCE): Transmits electrical power according to time.
class IFC_PARSE_API IfcElectricTimeControl : public IfcFlowController {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcElectricTimeControl
    bool hasPredefinedType() const;
    IfcElectricTimeControlTypeEnum::IfcElectricTimeControlTypeEnum PredefinedType() const;
    void setPredefinedType(IfcElectricTimeControlTypeEnum::IfcElectricTimeControlTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcFlowController::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcElectricTimeControlTypeEnum; } return IfcFlowController::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "PredefinedType"; } return IfcFlowController::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcElectricTimeControl (IfcEntityInstanceData* e);
    IfcElectricTimeControl (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcElectricTimeControlTypeEnum::IfcElectricTimeControlTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcElectricTimeControl > list;
};
/// A fan is a device which imparts mechanical work on a gas. A typical usage of a fan is to induce airflow in a building services air distribution system. 
/// 
/// HISTORY  New entity in IFC2x4
/// 
/// Type Use Definition
/// IfcFan defines the occurrence of any fan; common information about fan types is handled by IfcFanType. 
/// The IfcFanType (if present) may establish the common type name, usage (predefined type), properties, materials, ports, composition, assignments, and representations. 
/// The IfcFanType is attached using the IfcRelDefinesByType objectified relationship and is accessible by the IsTypedBy inverse attribute. 
/// If the IfcFanType has ports or aggregated elements, such objects are reflected at the IfcFan occurrence using the IfcRelDefinesByObject relationship.
/// 
/// Property Use Definition
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute. 
/// Property sets may also be specified at the IfcFanType, defining the common property data for all occurrences of the same type. 
/// They are then accessible by the IsTypedBy inverse attribute pointing to IfcFanType.HasPropertySets. 
/// If both are given, then the properties directly defined at IfcFan override the properties defined at IfcFanType. 
/// Refer to the documentation at the supertype IfcFlowMovingDevice and ancestors for inherited property set definitions.
/// The following property set definitions are applicable to this entity:
/// (All Types)
/// 
/// Pset_FanOccurrence (PSET_OCCURRENCEDRIVEN)
/// Pset_FanPHistory (PSET_PERFORMANCEDRIVEN)
/// Pset_FanTypeCommon (PSET_TYPEDRIVENOVERRIDE)
/// Pset_FanTypeSmokeControl (PSET_TYPEDRIVENOVERRIDE)
/// 
/// CENTRIFUGAL
/// 
/// Pset_FanCentrifugal (PSET_TYPEDRIVENOVERRIDE)
/// 
/// Quantity Use Definition
/// The quantities relating to this entity are defined by IfcElementQuantity and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute.
/// The following base quantities are defined and shall be exchanged with the IfcElementQuantity.Name = 'BaseQuantities'. 
/// Other quantities, being subjected to local standard of measurement, may be defined with another string value assigned to Name. 
/// In this case a valid value for MethodOfMeasurement shall be provided. 
/// 
/// Qto_FanBaseQuantities
/// 
/// Material Use Definition
/// The material of the IfcFan is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship. It is accessible by the HasAssociations inverse attribute. Material information can also be given at the IfcFanType, defining the common attribute data for all occurrences of the same type. The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used:
/// 
/// Frame: The material used to construct the fan housing.
/// Wheel: The material used to construct the fan wheel.
/// 
/// Port Use Definition
/// The distribution ports relating to the IfcFan are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship. 
///   If the fan occurrence is defined by IfcFanType, then the port occurrences must reflect those defined at the IfcFanType using the IfcRelDefinesByObject relationship.
///   Ports are specific to the IfcFan PredefinedType as follows indicated by the IfcDistributionPort Name, PredefinedType, and FlowDirection:
/// 
/// In (NOTDEFINED, SINK): Incoming air.
/// Out (NOTDEFINED, SOURCE): Outgoing air.
/// 
/// Figure 224 illustrates fan port use.
/// Figure 224 — Fan port use
class IFC_PARSE_API IfcFan : public IfcFlowMovingDevice {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcFan
    bool hasPredefinedType() const;
    IfcFanTypeEnum::IfcFanTypeEnum PredefinedType() const;
    void setPredefinedType(IfcFanTypeEnum::IfcFanTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcFlowMovingDevice::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcFanTypeEnum; } return IfcFlowMovingDevice::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "PredefinedType"; } return IfcFlowMovingDevice::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcFan (IfcEntityInstanceData* e);
    IfcFan (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcFanTypeEnum::IfcFanTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcFan > list;
};
/// A filter is an apparatus used to remove particulate or gaseous matter from fluids and gases. 
/// 
/// HISTORY  New entity in IFC2x4
/// 
/// Type Use Definition
/// IfcFilter defines the occurrence of any filter; common information about filter types is handled by IfcFilterType. 
/// The IfcFilterType (if present) may establish the common type name, usage (predefined type), properties, materials, ports, composition, assignments, and representations. 
/// The IfcFilterType is attached using the IfcRelDefinesByType objectified relationship and is accessible by the IsTypedBy inverse attribute. 
/// If the IfcFilterType has ports or aggregated elements, such objects are reflected at the IfcFilter occurrence using the IfcRelDefinesByObject relationship.
/// 
/// Property Use Definition
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute. 
/// Property sets may also be specified at the IfcFilterType, defining the common property data for all occurrences of the same type. 
/// They are then accessible by the IsTypedBy inverse attribute pointing to IfcFilterType.HasPropertySets. 
/// If both are given, then the properties directly defined at IfcFilter override the properties defined at IfcFilterType. 
/// Refer to the documentation at the supertype IfcFlowTreatmentDevice and ancestors for inherited property set definitions.
/// The following property set definitions are applicable to this entity:
/// (All Types)
/// 
/// Pset_FilterPHistory (PSET_PERFORMANCEDRIVEN)
/// Pset_FilterTypeCommon (PSET_TYPEDRIVENOVERRIDE)
/// 
/// AIRPARTICLEFILTER
/// 
/// Pset_FilterTypeAirParticleFilter (PSET_TYPEDRIVENOVERRIDE)
/// 
/// COMPRESSEDAIRFILTER
/// 
/// Pset_FilterTypeCompressedAirFilter (PSET_TYPEDRIVENOVERRIDE)
/// 
/// WATERFILTER
/// 
/// Pset_FilterTypeWaterFilter (PSET_TYPEDRIVENOVERRIDE)
/// 
/// Quantity Use Definition
/// The quantities relating to this entity are defined by IfcElementQuantity and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute.
/// The following base quantities are defined and shall be exchanged with the IfcElementQuantity.Name = 'BaseQuantities'. 
/// Other quantities, being subjected to local standard of measurement, may be defined with another string value assigned to Name. 
/// In this case a valid value for MethodOfMeasurement shall be provided. 
/// 
/// Qto_FilterBaseQuantities
/// 
/// Material Use Definition
/// The material of the IfcFilter is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship. It is accessible by the HasAssociations inverse attribute. Material information can also be given at the IfcFilterType, defining the common attribute data for all occurrences of the same type. The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used:
/// 
/// Frame: The material used to construct the filter housing.
/// Media: The material that is used for filtering particulates.
/// 
/// Port Use Definition
/// The distribution ports relating to the IfcFilter are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship. 
///   If the filter occurrence is defined by IfcFilterType, then the port occurrences must reflect those defined at the IfcFilterType using the IfcRelDefinesByObject relationship.
///   Ports are specific to the IfcFilter PredefinedType as follows indicated by the IfcDistributionPort Name, PredefinedType, and FlowDirection:
/// 
/// AIRPARTICLEFILTER
/// 
/// In (AIRCONDITIONING, SINK): Incoming fluid.
/// Out (AIRCONDITIONING, SOURCE): Outgoing fluid.
/// 
/// COMPRESSEDAIRFILTER
/// 
/// In (COMPRESSEDAIR, SINK): Incoming fluid.
/// Out (COMPRESSEDAIR, SOURCE): Outgoing fluid.
/// 
/// ODORFILTER
/// 
/// In (EXHAUST, SINK): Incoming fluid.
/// Out (EXHAUST, SOURCE): Outgoing fluid.
/// 
/// OILFILTER
/// 
/// In (OIL, SINK): Incoming fluid.
/// Out (OIL, SOURCE): Outgoing fluid.
/// 
/// STRAINER
/// 
/// In (DRAINAGE, SINK): Incoming fluid.
/// Out (DRAINAGE, SOURCE): Outgoing fluid.
/// 
/// WATERFILTER
/// 
/// In (DOMESTICCOLDWATER, SINK): Incoming fluid.
/// Out (DOMESTICCOLDWATER, SOURCE): Outgoing fluid.
/// 
/// Figure 225 illustrates filter port use.
/// Figure 225 — Filter port use
class IFC_PARSE_API IfcFilter : public IfcFlowTreatmentDevice {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcFilter
    bool hasPredefinedType() const;
    IfcFilterTypeEnum::IfcFilterTypeEnum PredefinedType() const;
    void setPredefinedType(IfcFilterTypeEnum::IfcFilterTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcFlowTreatmentDevice::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcFilterTypeEnum; } return IfcFlowTreatmentDevice::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "PredefinedType"; } return IfcFlowTreatmentDevice::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcFilter (IfcEntityInstanceData* e);
    IfcFilter (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcFilterTypeEnum::IfcFilterTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcFilter > list;
};
/// A fire suppression terminal has the purpose of delivering a fluid (gas or liquid) that will suppress a fire.
/// A fire suppression terminal provides for all forms of sprinkler, spreader and other form of terminal that is connected to a pipework system and intended to act in the role of suppressing a fire. 
/// 
/// HISTORY  New entity in IFC2x4
/// 
/// Type Use Definition
/// IfcFireSuppressionTerminal defines the occurrence of any fire suppression terminal; common information about fire suppression terminal types is handled by IfcFireSuppressionTerminalType. 
/// The IfcFireSuppressionTerminalType (if present) may establish the common type name, usage (predefined type), properties, materials, ports, composition, assignments, and representations. 
/// The IfcFireSuppressionTerminalType is attached using the IfcRelDefinesByType objectified relationship and is accessible by the IsTypedBy inverse attribute. 
/// If the IfcFireSuppressionTerminalType has ports or aggregated elements, such objects are reflected at the IfcFireSuppressionTerminal occurrence using the IfcRelDefinesByObject relationship.
/// 
/// Property Use Definition
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute. 
/// Property sets may also be specified at the IfcFireSuppressionTerminalType, defining the common property data for all occurrences of the same type. 
/// They are then accessible by the IsTypedBy inverse attribute pointing to IfcFireSuppressionTerminalType.HasPropertySets. 
/// If both are given, then the properties directly defined at IfcFireSuppressionTerminal override the properties defined at IfcFireSuppressionTerminalType. 
/// Refer to the documentation at the supertype IfcFlowTerminal and ancestors for inherited property set definitions.
/// The following property set definitions are applicable to this entity:
/// (All Types)
/// 
/// Pset_FireSuppressionTerminalTypeCommon (PSET_TYPEDRIVENOVERRIDE)
/// 
/// BREECHINGINLET
/// 
/// Pset_FireSuppressionTerminalTypeBreechingInlet (PSET_TYPEDRIVENOVERRIDE)
/// 
/// FIREHYDRANT
/// 
/// Pset_FireSuppressionTerminalTypeFireHydrant (PSET_TYPEDRIVENOVERRIDE)
/// 
/// HOSEREEL
/// 
/// Pset_FireSuppressionTerminalTypeHoseReel (PSET_TYPEDRIVENOVERRIDE)
/// 
/// SPRINKLER
/// 
/// Pset_FireSuppressionTerminalTypeSprinkler (PSET_TYPEDRIVENOVERRIDE)
/// 
/// Quantity Use Definition
/// The quantities relating to this entity are defined by IfcElementQuantity and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute.
/// The following base quantities are defined and shall be exchanged with the IfcElementQuantity.Name = 'BaseQuantities'. 
/// Other quantities, being subjected to local standard of measurement, may be defined with another string value assigned to Name. 
/// In this case a valid value for MethodOfMeasurement shall be provided. 
/// 
/// Qto_FireSuppressionTerminalBaseQuantities
/// 
/// Material Use Definition
/// The material of the IfcFireSuppressionTerminal is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship. It is accessible by the HasAssociations inverse attribute. Material information can also be given at the IfcFireSuppressionTerminalType, defining the common attribute data for all occurrences of the same type. The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used:
/// 
/// Body: The primary material from which the object is constructed.
/// Deflector: The material used to construct the deflector plate.
/// 
/// Port Use Definition
/// The distribution ports relating to the IfcFireSuppressionTerminal are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship. 
///   If the fire suppression terminal occurrence is defined by IfcFireSuppressionTerminalType, then the port occurrences must reflect those defined at the IfcFireSuppressionTerminalType using the IfcRelDefinesByObject relationship.
///   Ports are specific to the IfcFireSuppressionTerminal PredefinedType as follows indicated by the IfcDistributionPort Name, PredefinedType, and FlowDirection:
/// 
/// FIREHYDRANT
/// 
/// Hose (FIREPROTECTION, SOURCE): Fire protection.
/// 
/// SPRINKLER
/// 
/// Line (FIREPROTECTION, SINK): Fire protection.
class IFC_PARSE_API IfcFireSuppressionTerminal : public IfcFlowTerminal {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcFireSuppressionTerminal
    bool hasPredefinedType() const;
    IfcFireSuppressionTerminalTypeEnum::IfcFireSuppressionTerminalTypeEnum PredefinedType() const;
    void setPredefinedType(IfcFireSuppressionTerminalTypeEnum::IfcFireSuppressionTerminalTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcFlowTerminal::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcFireSuppressionTerminalTypeEnum; } return IfcFlowTerminal::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "PredefinedType"; } return IfcFlowTerminal::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcFireSuppressionTerminal (IfcEntityInstanceData* e);
    IfcFireSuppressionTerminal (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcFireSuppressionTerminalTypeEnum::IfcFireSuppressionTerminalTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcFireSuppressionTerminal > list;
};
/// A flow instrument reads and displays the value of a particular property of a system at a point, or displays the difference in the value of a property between two points.
///   Instrumentation is typically for the purpose of determining the value of the property at a point in time. It is not the purpose of an instrument to record or integrate the values over time (although they may be connected to recording devices that do perform such a function). This entity provides for all forms of mechanical flow instrument (thermometers, pressure gauges etc.) and electrical flow instruments (ammeters, voltmeters etc.) 
/// 
/// HISTORY  New entity in IFC2x4
/// 
/// Type Use Definition
/// IfcFlowInstrument defines the occurrence of any flow instrument; common information about flow instrument types is handled by IfcFlowInstrumentType. 
/// The IfcFlowInstrumentType (if present) may establish the common type name, usage (predefined type), properties, materials, ports, composition, assignments, and representations. 
/// The IfcFlowInstrumentType is attached using the IfcRelDefinesByType objectified relationship and is accessible by the IsTypedBy inverse attribute. 
/// If the IfcFlowInstrumentType has ports or aggregated elements, such objects are reflected at the IfcFlowInstrument occurrence using the IfcRelDefinesByObject relationship.
/// 
/// Property Use Definition
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute. 
/// Property sets may also be specified at the IfcFlowInstrumentType, defining the common property data for all occurrences of the same type. 
/// They are then accessible by the IsTypedBy inverse attribute pointing to IfcFlowInstrumentType.HasPropertySets. 
/// If both are given, then the properties directly defined at IfcFlowInstrument override the properties defined at IfcFlowInstrumentType. 
/// Refer to the documentation at the supertype IfcDistributionControlElement and ancestors for inherited property set definitions.
/// The following property set definitions are applicable to this entity:
/// (All Types)
/// 
/// Pset_FlowInstrumentPHistory (PSET_PERFORMANCEDRIVEN)
/// Pset_FlowInstrumentTypeCommon (PSET_TYPEDRIVENOVERRIDE)
/// 
/// PRESSUREGAUGE
/// 
/// Pset_FlowInstrumentTypePressureGauge (PSET_TYPEDRIVENOVERRIDE)
/// 
/// THERMOMETER
/// 
/// Pset_FlowInstrumentTypeThermometer (PSET_TYPEDRIVENOVERRIDE)
/// 
/// Quantity Use Definition
/// The quantities relating to this entity are defined by IfcElementQuantity and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute.
/// The following base quantities are defined and shall be exchanged with the IfcElementQuantity.Name = 'BaseQuantities'. 
/// Other quantities, being subjected to local standard of measurement, may be defined with another string value assigned to Name. 
/// In this case a valid value for MethodOfMeasurement shall be provided. 
/// 
/// Qto_FlowInstrumentBaseQuantities
/// 
/// Material Use Definition
/// The material of the IfcFlowInstrument is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship. It is accessible by the HasAssociations inverse attribute. Material information can also be given at the IfcFlowInstrumentType, defining the common attribute data for all occurrences of the same type. The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used:
/// 
/// Casing: Material from which the casing is constructed.
/// 
/// Port Use Definition
/// The distribution ports relating to the IfcFlowInstrument are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship. 
///   If the flow instrument occurrence is defined by IfcFlowInstrumentType, then the port occurrences must reflect those defined at the IfcFlowInstrumentType using the IfcRelDefinesByObject relationship.
///   Ports are specific to the IfcFlowInstrument PredefinedType as follows indicated by the IfcDistributionPort Name, PredefinedType, and FlowDirection:
/// 
/// Input (SIGNAL, SINK): Receives signal.
class IFC_PARSE_API IfcFlowInstrument : public IfcDistributionControlElement {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcFlowInstrument
    bool hasPredefinedType() const;
    IfcFlowInstrumentTypeEnum::IfcFlowInstrumentTypeEnum PredefinedType() const;
    void setPredefinedType(IfcFlowInstrumentTypeEnum::IfcFlowInstrumentTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcDistributionControlElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcFlowInstrumentTypeEnum; } return IfcDistributionControlElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "PredefinedType"; } return IfcDistributionControlElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcFlowInstrument (IfcEntityInstanceData* e);
    IfcFlowInstrument (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcFlowInstrumentTypeEnum::IfcFlowInstrumentTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcFlowInstrument > list;
};
/// Entity Definition 
/// 
/// HISTORY  New entity in IFC2x4
/// 
/// Type Use Definition
/// IfcProtectiveDeviceTrippingUnit defines the occurrence of any protective device tripping unit; common information about protective device tripping unit types is handled by IfcProtectiveDeviceTrippingUnitType. 
/// The IfcProtectiveDeviceTrippingUnitType (if present) may establish the common type name, usage (predefined type), properties, materials, ports, composition, assignments, and representations. 
/// The IfcProtectiveDeviceTrippingUnitType is attached using the IfcRelDefinesByType objectified relationship and is accessible by the IsTypedBy inverse attribute. 
/// If the IfcProtectiveDeviceTrippingUnitType has ports or aggregated elements, such objects are reflected at the IfcProtectiveDeviceTrippingUnit occurrence using the IfcRelDefinesByObject relationship.
/// 
/// Property Use Definition
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute. 
/// Property sets may also be specified at the IfcProtectiveDeviceTrippingUnitType, defining the common property data for all occurrences of the same type. 
/// They are then accessible by the IsTypedBy inverse attribute pointing to IfcProtectiveDeviceTrippingUnitType.HasPropertySets. 
/// If both are given, then the properties directly defined at IfcProtectiveDeviceTrippingUnit override the properties defined at IfcProtectiveDeviceTrippingUnitType. 
/// Refer to the documentation at the supertype IfcDistributionControlElement and ancestors for inherited property set definitions.
/// The following property set definitions are applicable to this entity:
/// (All Types)
/// 
/// Pset_ProtectiveDeviceTrippingFunctionGCurve (PSET_TYPEDRIVENOVERRIDE)
/// Pset_ProtectiveDeviceTrippingFunctionICurve (PSET_TYPEDRIVENOVERRIDE)
/// Pset_ProtectiveDeviceTrippingFunctionLCurve (PSET_TYPEDRIVENOVERRIDE)
/// Pset_ProtectiveDeviceTrippingFunctionSCurve (PSET_TYPEDRIVENOVERRIDE)
/// Pset_ProtectiveDeviceTrippingUnitCurrentAdjustment (PSET_TYPEDRIVENOVERRIDE)
/// Pset_ProtectiveDeviceTrippingUnitTimeAdjustment (PSET_TYPEDRIVENOVERRIDE)
/// Pset_ProtectiveDeviceTrippingUnitTypeCommon (PSET_TYPEDRIVENOVERRIDE)
/// 
/// ELECTROMAGNETIC
/// 
/// Pset_ProtectiveDeviceTrippingUnitTypeElectroMagnetic (PSET_TYPEDRIVENOVERRIDE)
/// 
/// ELECTRONIC
/// 
/// Pset_ProtectiveDeviceTrippingUnitTypeElectronic (PSET_TYPEDRIVENOVERRIDE)
/// 
/// RESIDUALCURRENT
/// 
/// Pset_ProtectiveDeviceTrippingUnitTypeResidualCurrent (PSET_TYPEDRIVENOVERRIDE)
/// 
/// THERMAL
/// 
/// Pset_ProtectiveDeviceTrippingUnitTypeThermal (PSET_TYPEDRIVENOVERRIDE)
/// 
/// Quantity Use Definition
/// The quantities relating to this entity are defined by IfcElementQuantity and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute.
/// The following base quantities are defined and shall be exchanged with the IfcElementQuantity.Name = 'BaseQuantities'. 
/// Other quantities, being subjected to local standard of measurement, may be defined with another string value assigned to Name. 
/// In this case a valid value for MethodOfMeasurement shall be provided. 
/// 
/// Qto_ProtectiveDeviceTrippingUnitBaseQuantities
class IFC_PARSE_API IfcProtectiveDeviceTrippingUnit : public IfcDistributionControlElement {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcProtectiveDeviceTrippingUnit
    bool hasPredefinedType() const;
    IfcProtectiveDeviceTrippingUnitTypeEnum::IfcProtectiveDeviceTrippingUnitTypeEnum PredefinedType() const;
    void setPredefinedType(IfcProtectiveDeviceTrippingUnitTypeEnum::IfcProtectiveDeviceTrippingUnitTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcDistributionControlElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcProtectiveDeviceTrippingUnitTypeEnum; } return IfcDistributionControlElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "PredefinedType"; } return IfcDistributionControlElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcProtectiveDeviceTrippingUnit (IfcEntityInstanceData* e);
    IfcProtectiveDeviceTrippingUnit (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcProtectiveDeviceTrippingUnitTypeEnum::IfcProtectiveDeviceTrippingUnitTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcProtectiveDeviceTrippingUnit > list;
};
/// A sensor is a device that measures a physical quantity and converts it into a signal which can be read by an observer or by an instrument. 
/// 
/// HISTORY  New entity in IFC2x4
/// 
/// Type Use Definition
/// IfcSensor defines the occurrence of any sensor; common information about sensor types is handled by IfcSensorType. 
/// The IfcSensorType (if present) may establish the common type name, usage (predefined type), properties, materials, ports, composition, assignments, and representations. 
/// The IfcSensorType is attached using the IfcRelDefinesByType objectified relationship and is accessible by the IsTypedBy inverse attribute. 
/// If the IfcSensorType has ports or aggregated elements, such objects are reflected at the IfcSensor occurrence using the IfcRelDefinesByObject relationship.
/// Figure 179 illustrates sensor type use.
/// Figure 179 — Sensor type use
/// 
/// Property Use Definition
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute. 
/// Property sets may also be specified at the IfcSensorType, defining the common property data for all occurrences of the same type. 
/// They are then accessible by the IsTypedBy inverse attribute pointing to IfcSensorType.HasPropertySets. 
/// If both are given, then the properties directly defined at IfcSensor override the properties defined at IfcSensorType. 
/// Refer to the documentation at the supertype IfcDistributionControlElement and ancestors for inherited property set definitions.
/// The following property set definitions are applicable to this entity:
/// (All Types)
/// 
/// Pset_SensorPHistory (PSET_PERFORMANCEDRIVEN)
/// Pset_SensorTypeCommon (PSET_TYPEDRIVENOVERRIDE)
/// 
/// CONDUCTANCESENSOR
/// 
/// Pset_SensorTypeConductanceSensor (PSET_TYPEDRIVENOVERRIDE)
/// 
/// CONTACTSENSOR
/// 
/// Pset_SensorTypeContactSensor (PSET_TYPEDRIVENOVERRIDE)
/// 
/// FIRESENSOR
/// 
/// Pset_SensorTypeFireSensor (PSET_TYPEDRIVENOVERRIDE)
/// 
/// FLOWSENSOR
/// 
/// Pset_SensorTypeFlowSensor (PSET_TYPEDRIVENOVERRIDE)
/// 
/// GASSENSOR
/// 
/// Pset_SensorTypeGasSensor (PSET_TYPEDRIVENOVERRIDE)
/// 
/// HEATSENSOR
/// 
/// Pset_SensorTypeHeatSensor (PSET_TYPEDRIVENOVERRIDE)
/// 
/// HUMIDITYSENSOR
/// 
/// Pset_SensorTypeHumiditySensor (PSET_TYPEDRIVENOVERRIDE)
/// 
/// IONCONCENTRATIONSENSOR
/// 
/// Pset_SensorTypeIonConcentrationSensor (PSET_TYPEDRIVENOVERRIDE)
/// 
/// LEVEL
/// 
/// Pset_SensorTypeLevelSensor (PSET_TYPEDRIVENOVERRIDE)
/// 
/// LIGHTSENSOR
/// 
/// Pset_SensorTypeLightSensor (PSET_TYPEDRIVENOVERRIDE)
/// 
/// MOISTURESENSOR
/// 
/// Pset_SensorTypeMoistureSensor (PSET_TYPEDRIVENOVERRIDE)
/// 
/// MOVEMENTSENSOR
/// 
/// Pset_SensorTypeMovementSensor (PSET_TYPEDRIVENOVERRIDE)
/// 
/// PHSENSOR
/// 
/// Pset_SensorTypePHSensor (PSET_TYPEDRIVENOVERRIDE)
/// 
/// PRESSURESENSOR
/// 
/// Pset_SensorTypePressureSensor (PSET_TYPEDRIVENOVERRIDE)
/// 
/// RADIATIONSENSOR
/// 
/// Pset_SensorTypeRadiationSensor (PSET_TYPEDRIVENOVERRIDE)
/// 
/// RADIOACTIVITYSENSOR
/// 
/// Pset_SensorTypeRadioactivitySensor (PSET_TYPEDRIVENOVERRIDE)
/// 
/// SMOKESENSOR
/// 
/// Pset_SensorTypeSmokeSensor (PSET_TYPEDRIVENOVERRIDE)
/// 
/// SOUNDSENSOR
/// 
/// Pset_SensorTypeSoundSensor (PSET_TYPEDRIVENOVERRIDE)
/// 
/// TEMPERATURESENSOR
/// 
/// Pset_SensorTypeTemperatureSensor (PSET_TYPEDRIVENOVERRIDE)
/// 
/// WINDSENSOR
/// 
/// Pset_SensorTypeWindSensor (PSET_TYPEDRIVENOVERRIDE)
/// 
/// Quantity Use Definition
/// The quantities relating to this entity are defined by IfcElementQuantity and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute.
/// The following base quantities are defined and shall be exchanged with the IfcElementQuantity.Name = 'BaseQuantities'. 
/// Other quantities, being subjected to local standard of measurement, may be defined with another string value assigned to Name. 
/// In this case a valid value for MethodOfMeasurement shall be provided. 
/// 
/// Qto_SensorBaseQuantities
/// 
/// Material Use Definition
/// The material of the IfcSensor is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship. It is accessible by the HasAssociations inverse attribute. Material information can also be given at the IfcSensorType, defining the common attribute data for all occurrences of the same type. The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used:
/// 
/// Casing: Material from which the casing is constructed.
/// 
/// Connection Use Definition
/// The IfcSensor may be connected to other objects as follows using the indicated relationship:
/// 
/// IfcDistributionFlowElement (IfcRelFlowControlElements): Sensors may be connected to a flow element for which an aspect of the fluid or flow is measured.
/// IfcElement (IfcRelConnectsElements): Sensors may be attached to the exterior of an element.
/// 
/// Port Use Definition
/// The distribution ports relating to the IfcSensor are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship. 
///   If the sensor occurrence is defined by IfcSensorType, then the port occurrences must reflect those defined at the IfcSensorType using the IfcRelDefinesByObject relationship.
///   Ports are specific to the IfcSensor PredefinedType as follows indicated by the IfcDistributionPort Name, PredefinedType, and FlowDirection:
/// 
/// Output (SIGNAL, SOURCE): Transmits signal.
/// 
/// Figure 180 illustrates sensor port use.
/// Figure 180 — Sensor port use
class IFC_PARSE_API IfcSensor : public IfcDistributionControlElement {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcSensor
    bool hasPredefinedType() const;
    IfcSensorTypeEnum::IfcSensorTypeEnum PredefinedType() const;
    void setPredefinedType(IfcSensorTypeEnum::IfcSensorTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcDistributionControlElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcSensorTypeEnum; } return IfcDistributionControlElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "PredefinedType"; } return IfcDistributionControlElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcSensor (IfcEntityInstanceData* e);
    IfcSensor (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcSensorTypeEnum::IfcSensorTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcSensor > list;
};
/// A unitary control element combines a number of control components into a single product, such as a thermostat or humidistat.
/// A unitary control element provides a housing for an aggregation of control or electrical distribution elements that, in combination, perform a singular (unitary) purpose. Each item in the aggregation may have its own geometric representation and location. 
/// 
/// HISTORY  New entity in IFC2x4
/// 
/// Type Use Definition
/// IfcUnitaryControlElement defines the occurrence of any unitary control element; common information about unitary control element types is handled by IfcUnitaryControlElementType. 
/// The IfcUnitaryControlElementType (if present) may establish the common type name, usage (predefined type), properties, materials, ports, composition, assignments, and representations. 
/// The IfcUnitaryControlElementType is attached using the IfcRelDefinesByType objectified relationship and is accessible by the IsTypedBy inverse attribute. 
/// If the IfcUnitaryControlElementType has ports or aggregated elements, such objects are reflected at the IfcUnitaryControlElement occurrence using the IfcRelDefinesByObject relationship.
/// Figure 181 illustrates unitary control element type use.
/// Figure 181 — Unitary control element type use
/// 
/// Property Use Definition
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute. 
/// Property sets may also be specified at the IfcUnitaryControlElementType, defining the common property data for all occurrences of the same type. 
/// They are then accessible by the IsTypedBy inverse attribute pointing to IfcUnitaryControlElementType.HasPropertySets. 
/// If both are given, then the properties directly defined at IfcUnitaryControlElement override the properties defined at IfcUnitaryControlElementType. 
/// Refer to the documentation at the supertype IfcDistributionControlElement and ancestors for inherited property set definitions.
/// The following property set definitions are applicable to this entity:
/// Pset_UnitaryControlElementPHistory (PSET_PERFORMANCEDRIVEN)
/// Pset_UnitaryControlElementTypeCommon (PSET_TYPEDRIVENOVERRIDE)
/// 
/// Quantity Use Definition
/// The quantities relating to this entity are defined by IfcElementQuantity and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute.
/// The following base quantities are defined and shall be exchanged with the IfcElementQuantity.Name = 'BaseQuantities'. 
/// Other quantities, being subjected to local standard of measurement, may be defined with another string value assigned to Name. 
/// In this case a valid value for MethodOfMeasurement shall be provided. 
/// 
/// Qto_UnitaryControlElementBaseQuantities
/// 
/// Material Use Definition
/// The material of the IfcUnitaryControlElement is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship. It is accessible by the HasAssociations inverse attribute. Material information can also be given at the IfcUnitaryControlElementType, defining the common attribute data for all occurrences of the same type. The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used:
/// 
/// Casing: Material from which the casing is constructed.
/// 
/// Connection Use Definition
/// The IfcUnitaryControlElement may be connected to other objects as follows using the indicated relationship:
/// 
/// IfcDistributionFlowElement (IfcRelFlowControlElements): Sensors may be connected to a flow element for which an aspect of the fluid or flow is measured.
/// IfcElement (IfcRelConnectsElements): Sensors may be attached to the exterior of an element.
/// 
/// Port Use Definition
/// The distribution ports relating to the IfcUnitaryControlElement are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship. 
///   If the unitary control element occurrence is defined by IfcUnitaryControlElementType, then the port occurrences must reflect those defined at the IfcUnitaryControlElementType using the IfcRelDefinesByObject relationship.
///   Ports are specific to the IfcUnitaryControlElement PredefinedType as follows indicated by the IfcDistributionPort Name, PredefinedType, and FlowDirection:
/// 
/// THERMOSTAT
/// 
/// Control (CONTROL, SOURCE): Receives power (typically 24V), and closes the circuit for Fan, Heat, and Cool. Port may be aggregated into sub-ports: 'Fan'(SIGNAL,SOURCE), 'Heat'(SIGNAL,SOURCE), and 'Cool'(SIGNAL,SOURCE)
/// 
/// Figure 182 illustrates unitary control element port use.
/// Figure 182 — Unitary control element port use
class IFC_PARSE_API IfcUnitaryControlElement : public IfcDistributionControlElement {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcUnitaryControlElement
    bool hasPredefinedType() const;
    IfcUnitaryControlElementTypeEnum::IfcUnitaryControlElementTypeEnum PredefinedType() const;
    void setPredefinedType(IfcUnitaryControlElementTypeEnum::IfcUnitaryControlElementTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcDistributionControlElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcUnitaryControlElementTypeEnum; } return IfcDistributionControlElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "PredefinedType"; } return IfcDistributionControlElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcUnitaryControlElement (IfcEntityInstanceData* e);
    IfcUnitaryControlElement (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcUnitaryControlElementTypeEnum::IfcUnitaryControlElementTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcUnitaryControlElement > list;
};
/// An actuator is a mechanical device for moving or controlling a mechanism or system. An actuator takes energy, usually created by air, electricity, or liquid, and converts that into some kind of motion. 
/// 
/// HISTORY  New entity in IFC2x4
/// 
/// Type Use Definition
/// IfcActuator defines the occurrence of any actuator; common information about actuator types is handled by IfcActuatorType. 
/// The IfcActuatorType (if present) may establish the common type name, usage (predefined type), properties, materials, ports, composition, assignments, and representations. 
/// The IfcActuatorType is attached using the IfcRelDefinesByType objectified relationship and is accessible by the IsTypedBy inverse attribute. 
/// If the IfcActuatorType has ports or aggregated elements, such objects are reflected at the IfcActuator occurrence using the IfcRelDefinesByObject relationship.
/// 
/// Property Use Definition
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute. 
/// Property sets may also be specified at the IfcActuatorType, defining the common property data for all occurrences of the same type. 
/// They are then accessible by the IsTypedBy inverse attribute pointing to IfcActuatorType.HasPropertySets. 
/// If both are given, then the properties directly defined at IfcActuator override the properties defined at IfcActuatorType. 
/// Refer to the documentation at the supertype IfcDistributionControlElement and ancestors for inherited property set definitions.
/// The following property set definitions are applicable to this entity:
/// (All Types)
/// 
/// Pset_ActuatorPHistory (PSET_PERFORMANCEDRIVEN)
/// Pset_ActuatorTypeCommon (PSET_TYPEDRIVENOVERRIDE)
/// Pset_ActuatorTypeLinearActuation (PSET_TYPEDRIVENOVERRIDE)
/// Pset_ActuatorTypeRotationalActuation (PSET_TYPEDRIVENOVERRIDE)
/// 
/// ELECTRICACTUATOR
/// 
/// Pset_ActuatorTypeElectricActuator (PSET_TYPEDRIVENOVERRIDE)
/// 
/// HYDRAULICACTUATOR
/// 
/// Pset_ActuatorTypeHydraulicActuator (PSET_TYPEDRIVENOVERRIDE)
/// 
/// PNEUMATICACTUATOR
/// 
/// Pset_ActuatorTypePneumaticActuator (PSET_TYPEDRIVENOVERRIDE)
/// 
/// Quantity Use Definition
/// The quantities relating to this entity are defined by IfcElementQuantity and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute.
/// The following base quantities are defined and shall be exchanged with the IfcElementQuantity.Name = 'BaseQuantities'. 
/// Other quantities, being subjected to local standard of measurement, may be defined with another string value assigned to Name. 
/// In this case a valid value for MethodOfMeasurement shall be provided. 
/// 
/// Qto_ActuatorBaseQuantities
/// 
/// Material Use Definition
/// The material of the IfcActuator is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship. It is accessible by the HasAssociations inverse attribute. Material information can also be given at the IfcActuatorType, defining the common attribute data for all occurrences of the same type. The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used:
/// 
/// Casing: Material from which the casing is constructed.
/// 
/// Connection Use Definition
/// The IfcActuator may be connected to other objects as follows using the indicated relationship:
/// 
/// IfcFlowController (IfcRelFlowControlElements): Indicates a connected valve, damper, or switch controlled by the actuator.
/// 
/// Port Use Definition
/// The distribution ports relating to the IfcActuator are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship. 
///   If the actuator occurrence is defined by IfcActuatorType, then the port occurrences must reflect those defined at the IfcActuatorType using the IfcRelDefinesByObject relationship.
///   Ports are specific to the IfcActuator PredefinedType as follows indicated by the IfcDistributionPort Name, PredefinedType, and FlowDirection:
/// 
/// Input (SIGNAL, SINK): Receives signal.
class IFC_PARSE_API IfcActuator : public IfcDistributionControlElement {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcActuator
    bool hasPredefinedType() const;
    IfcActuatorTypeEnum::IfcActuatorTypeEnum PredefinedType() const;
    void setPredefinedType(IfcActuatorTypeEnum::IfcActuatorTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcDistributionControlElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcActuatorTypeEnum; } return IfcDistributionControlElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "PredefinedType"; } return IfcDistributionControlElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcActuator (IfcEntityInstanceData* e);
    IfcActuator (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcActuatorTypeEnum::IfcActuatorTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcActuator > list;
};
/// An alarm is a device that signals the existence of a condition or situation that is outside the boundaries of normal expectation or that activates such a device.
///   Alarms include the provision of break glass buttons and manual pull boxes that are used to activate alarms. 
/// 
/// HISTORY  New entity in IFC2x4
/// 
/// Type Use Definition
/// IfcAlarm defines the occurrence of any alarm; common information about alarm types is handled by IfcAlarmType. 
/// The IfcAlarmType (if present) may establish the common type name, usage (predefined type), properties, materials, ports, composition, assignments, and representations. 
/// The IfcAlarmType is attached using the IfcRelDefinesByType objectified relationship and is accessible by the IsTypedBy inverse attribute. 
/// If the IfcAlarmType has ports or aggregated elements, such objects are reflected at the IfcAlarm occurrence using the IfcRelDefinesByObject relationship.
/// 
/// Property Use Definition
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute. 
/// Property sets may also be specified at the IfcAlarmType, defining the common property data for all occurrences of the same type. 
/// They are then accessible by the IsTypedBy inverse attribute pointing to IfcAlarmType.HasPropertySets. 
/// If both are given, then the properties directly defined at IfcAlarm override the properties defined at IfcAlarmType. 
/// Refer to the documentation at the supertype IfcDistributionControlElement and ancestors for inherited property set definitions.
/// The following property set definitions are applicable to this entity:
/// Pset_AlarmPHistory (PSET_PERFORMANCEDRIVEN)
/// Pset_AlarmTypeCommon (PSET_TYPEDRIVENOVERRIDE)
/// 
/// Quantity Use Definition
/// The quantities relating to this entity are defined by IfcElementQuantity and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute.
/// The following base quantities are defined and shall be exchanged with the IfcElementQuantity.Name = 'BaseQuantities'. 
/// Other quantities, being subjected to local standard of measurement, may be defined with another string value assigned to Name. 
/// In this case a valid value for MethodOfMeasurement shall be provided. 
/// 
/// Qto_AlarmBaseQuantities
/// 
/// Material Use Definition
/// The material of the IfcAlarm is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship. It is accessible by the HasAssociations inverse attribute. Material information can also be given at the IfcAlarmType, defining the common attribute data for all occurrences of the same type. The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used:
/// 
/// Casing: Material from which the casing is constructed.
/// 
/// Port Use Definition
/// The distribution ports relating to the IfcAlarm are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship. 
///   If the alarm occurrence is defined by IfcAlarmType, then the port occurrences must reflect those defined at the IfcAlarmType using the IfcRelDefinesByObject relationship.
///   Ports are specific to the IfcAlarm PredefinedType as follows indicated by the IfcDistributionPort Name, PredefinedType, and FlowDirection:
/// 
/// Input (SIGNAL, SINK): Receives signal.
class IFC_PARSE_API IfcAlarm : public IfcDistributionControlElement {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcAlarm
    bool hasPredefinedType() const;
    IfcAlarmTypeEnum::IfcAlarmTypeEnum PredefinedType() const;
    void setPredefinedType(IfcAlarmTypeEnum::IfcAlarmTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcDistributionControlElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcAlarmTypeEnum; } return IfcDistributionControlElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "PredefinedType"; } return IfcDistributionControlElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcAlarm (IfcEntityInstanceData* e);
    IfcAlarm (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcAlarmTypeEnum::IfcAlarmTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcAlarm > list;
};
/// A controller is a device that monitors inputs and controls outputs within a building automation system.
///   A controller may be physical (having placement within a spatial structure) or logical (a software interface or aggregated within a programmable physical controller). 
/// 
/// HISTORY  New entity in IFC2x4
/// 
/// Type Use Definition
/// IfcController defines the occurrence of any controller; common information about controller types is handled by IfcControllerType. 
/// The IfcControllerType (if present) may establish the common type name, usage (predefined type), properties, materials, ports, composition, assignments, and representations. 
/// The IfcControllerType is attached using the IfcRelDefinesByType objectified relationship and is accessible by the IsTypedBy inverse attribute. 
/// If the IfcControllerType has ports or aggregated elements, such objects are reflected at the IfcController occurrence using the IfcRelDefinesByObject relationship.
/// Figure 177 illustrates controller type use.
/// Figure 177 — Controller type use
/// 
/// Property Use Definition
/// The property sets relating to this entity are defined by IfcPropertySet and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute. 
/// Property sets may also be specified at the IfcControllerType, defining the common property data for all occurrences of the same type. 
/// They are then accessible by the IsTypedBy inverse attribute pointing to IfcControllerType.HasPropertySets. 
/// If both are given, then the properties directly defined at IfcController override the properties defined at IfcControllerType. 
/// Refer to the documentation at the supertype IfcDistributionControlElement and ancestors for inherited property set definitions.
/// The following property set definitions are applicable to this entity:
/// (All Types)
/// 
/// Pset_ControllerPHistory (PSET_PERFORMANCEDRIVEN)
/// Pset_ControllerTypeCommon (PSET_TYPEDRIVENOVERRIDE)
/// 
/// FLOATING
/// 
/// Pset_ControllerTypeFloating (PSET_TYPEDRIVENOVERRIDE)
/// 
/// MULTIPOSITION
/// 
/// Pset_ControllerTypeMultiPosition (PSET_TYPEDRIVENOVERRIDE)
/// 
/// PROGRAMMABLE
/// 
/// Pset_ControllerTypeProgrammable (PSET_TYPEDRIVENOVERRIDE)
/// 
/// PROPORTIONAL
/// 
/// Pset_ControllerTypeProportional (PSET_TYPEDRIVENOVERRIDE)
/// 
/// TWOPOSITION
/// 
/// Pset_ControllerTypeTwoPosition (PSET_TYPEDRIVENOVERRIDE)
/// 
/// Quantity Use Definition
/// The quantities relating to this entity are defined by IfcElementQuantity and attached by the IfcRelDefinesByProperties relationship. 
/// They are accessible by the IsDefinedBy inverse attribute.
/// The following base quantities are defined and shall be exchanged with the IfcElementQuantity.Name = 'BaseQuantities'. 
/// Other quantities, being subjected to local standard of measurement, may be defined with another string value assigned to Name. 
/// In this case a valid value for MethodOfMeasurement shall be provided. 
/// 
/// Qto_ControllerBaseQuantities
/// 
/// Composition Use Definition
/// The IfcController may be aggregated into components using IfcRelAggregates where RelatingObject refers to the enclosing IfcController and RelatedObjects contains one or more components. Aggregation use is defined for the following predefined types:
/// 
/// PROGRAMMABLE
/// 
/// May contain IfcController components. Programmable Logic Controllers may be decomposed into logical elements for values and operations.
/// 
/// Material Use Definition
/// The material of the IfcController is defined by IfcMaterialConstituentSet or as a fallback by IfcMaterial, and attached by the RelatingMaterial attribute on the IfcRelAssociatesMaterial relationship. It is accessible by the HasAssociations inverse attribute. Material information can also be given at the IfcControllerType, defining the common attribute data for all occurrences of the same type. The following keywords for IfcMaterialConstituentSet.MaterialConstituents[n].Name shall be used:
/// 
/// Casing: Material from which the casing is constructed.
/// 
/// Port Use Definition
/// The distribution ports relating to the IfcController are defined by IfcDistributionPort and attached by the IfcRelConnectsPortToElement relationship. 
///   If the controller occurrence is defined by IfcControllerType, then the port occurrences must reflect those defined at the IfcControllerType using the IfcRelDefinesByObject relationship.
///   Ports are specific to the IfcController PredefinedType as follows indicated by the IfcDistributionPort Name, PredefinedType, and FlowDirection:
/// 
/// FLOATING
/// 
/// Input (SIGNAL, SINK): Receives the first parameter.
/// Modifier (SIGNAL, SINK): Receives the second parameter (if applicable).
/// Output (SIGNAL, SOURCE): Sets the output value.
/// 
/// MULTIPOSITION
/// 
/// Input (SIGNAL, SINK): Receives the first parameter.
/// Modifier (SIGNAL, SINK): Receives the second parameter (if applicable).
/// Output (SIGNAL, SOURCE): Sets the output value.
/// 
/// PROGRAMMABLE
/// 
/// Power (ELECTRICAL, SINK): Receives electrical power.
/// Control (CONTROL, SINK): Direct communication to the device (e.g. serial port).
/// Data (DATA, SOURCE): Network communication to the device (e.g. TCP/IP network).
/// Input#1 (SIGNAL, SINK): Analog or digital inputs.
/// Output#1 (SIGNAL, SOURCE): Analog or digital outputs.
/// 
/// PROPORTIONAL
/// 
/// Input (SIGNAL, SINK): Receives the first parameter.
/// Modifier (SIGNAL, SINK): Receives the second parameter (if applicable).
/// Output (SIGNAL, SOURCE): Sets the output value.
/// 
/// TWOPOSITION
/// 
/// Input (SIGNAL, SINK): Receives the first parameter.
/// Modifier (SIGNAL, SINK): Receives the second parameter (if applicable).
/// Output (SIGNAL, SOURCE): Sets the output value.
/// 
/// Figure 178 illustrates controller port use.
/// Figure 178 — Controller port use
class IFC_PARSE_API IfcController : public IfcDistributionControlElement {
public:
    /// Whether the optional attribute PredefinedType is defined for this IfcController
    bool hasPredefinedType() const;
    IfcControllerTypeEnum::IfcControllerTypeEnum PredefinedType() const;
    void setPredefinedType(IfcControllerTypeEnum::IfcControllerTypeEnum v);
    virtual unsigned int getArgumentCount() const { return 9; }
    virtual IfcUtil::ArgumentType getArgumentType(unsigned int i) const { switch (i) {case 8: return IfcUtil::Argument_ENUMERATION; } return IfcDistributionControlElement::getArgumentType(i); }
    virtual Type::Enum getArgumentEntity(unsigned int i) const { switch (i) {case 8: return Type::IfcControllerTypeEnum; } return IfcDistributionControlElement::getArgumentEntity(i); }
    virtual const char* getArgumentName(unsigned int i) const { switch (i) {case 8: return "PredefinedType"; } return IfcDistributionControlElement::getArgumentName(i); }
    virtual Argument* getArgument(unsigned int i) const { return entity->getArgument(i); }
    bool is(Type::Enum v) const;
    Type::Enum type() const;
    static Type::Enum Class();
    IfcController (IfcEntityInstanceData* e);
    IfcController (std::string v1_GlobalId, IfcOwnerHistory* v2_OwnerHistory, boost::optional< std::string > v3_Name, boost::optional< std::string > v4_Description, boost::optional< std::string > v5_ObjectType, IfcObjectPlacement* v6_ObjectPlacement, IfcProductRepresentation* v7_Representation, boost::optional< std::string > v8_Tag, boost::optional< IfcControllerTypeEnum::IfcControllerTypeEnum > v9_PredefinedType);
    typedef IfcTemplatedEntityList< IfcController > list;
};

IFC_PARSE_API void InitStringMap();
IFC_PARSE_API IfcUtil::IfcBaseClass* SchemaEntity(IfcEntityInstanceData* e = 0);
}

#endif
