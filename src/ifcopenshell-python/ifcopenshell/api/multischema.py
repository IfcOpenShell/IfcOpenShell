from __future__ import annotations
import ast
import os
import copy
import inspect
from enum import Enum, auto
import warnings
from pathlib import Path
from dataclasses import dataclass, field
from functools import reduce
from typing import cast, Optional, Union, Any, Callable, Type, TypeVar
import ifcopenshell
from ifcopenshell.api import list_actions

wrapper = ifcopenshell.ifcopenshell_wrapper
TASTCALL = TypeVar("TASTCALL", bound=Union[ast.ClassDef, ast.FunctionDef])


class PythonArgType(Enum):  # See PEP 570 and PEP 3102 for reference
    POS_ONLY = auto()       # positional-only, before / in signature
    POS_OR_KW = auto()      # either positional or keyword argument, Python default
    KW_ONLY = auto()        # keyword-only argument, after * in signature
    VARARG = auto()         # *args, variational positional
    KWARG = auto()          # **kwargs, variational keyword


class SignatureType(Enum):
    INIT = auto()           # Signature defined inside __init__ method of Usecase class
    DATACLASS = auto()      # Signature defined as fields of Usecase dataclass


def preamble(version: str, filename_to_edit: str) -> str:
    txt = f"# AUTOGENERATED FILE\n"
    txt += f"# SCHEMA DEFINITION {version}\n\n"
    txt += f"# WARNING: DO NOT EDIT\n"
    txt += f"# EDIT {filename_to_edit} INSTEAD\n"
    txt += f"# AND RUN ifcopenshell.api.multischema.py TO REGENERATE\n\n\n\n"
    return txt


def pascal_to_snake(txt: str) -> str:
    txt = "".join([f"_{char.lower()}" if char.isupper() else char for char in txt]).lstrip("_")
    return txt[1:] if txt[0] == "_" else txt


def snake_to_pascal(txt: str) -> str:
    return txt.replace("_", " ").title().replace(" ", "")


def type_to_str(builtin_type: type) -> str:
    candidates: list[str] = [el for el in dir(__builtins__) if getattr(__builtins__, el) == builtin_type]
    if len(candidates) != 1:
        raise ValueError(f"Type {builtin_type} not found on __builtins__")
    return candidates[0]


def is_dataclass(node: ast.ClassDef) -> bool:
    def is_decorator_dataclass_simple(dec: ast.expr) -> bool:
        return isinstance(dec, ast.Name) and dec.id == "dataclass"

    def is_decorator_dataclass_callable(dec: ast.expr) -> bool:
        return isinstance(dec, ast.Call) and isinstance(dec.func, ast.Name) and dec.func.id == "dataclass"

    return any([
        dec for dec in node.decorator_list
        if is_decorator_dataclass_simple(dec) or is_decorator_dataclass_callable(dec)
    ])


def find_ast_idxs(
        node: ast.AST, on_type: Union[type, tuple[type, ...]], wrn_msg: Optional[str] = None
) -> tuple[int, int, bool]:
    found_items = False
    idx_min, idx_max = -1, -1
    for idx, child in enumerate(ast.iter_child_nodes(node)):
        if not isinstance(child, on_type):
            if found_items:
                break
            else:
                continue
        idx_max = idx
        if not found_items:
            idx_min = idx
            found_items = True
    if idx_min == -1:
        idx_min, idx_max = 0, 0
        if wrn_msg:
            warnings.warn(wrn_msg)
    return idx_min, idx_max, found_items


def alias_in_module(ast_module: ast.Module, alias: str) -> bool:
    for node in ast.walk(ast_module):
        if isinstance(node, ast.Name) and node.id == alias:
            return True
    return False


def get_import_from_module(ast_module: ast.Module, module: str) -> Optional[ast.ImportFrom]:
    for node in ast.walk(ast_module):
        if isinstance(node, ast.ImportFrom) and node.module == module:
            return node
    return None


def add_import_to_module(ast_module: ast.Module, module: str, alias: str) -> None:
    idx_import_min, idx_import_max, found_import = find_ast_idxs(node=ast_module, on_type=(ast.Import, ast.ImportFrom))
    ast_module.body.insert(
        idx_import_max,
        ast.ImportFrom(
            module=module,
            names=[ast.alias(name=alias)],
            level=0
        )
    )


def add_alias_to_import(node: ast.ImportFrom, alias: str) -> None:
    alias_found = False
    for name in node.names:
        if not isinstance(name, ast.alias):
            continue
        if name.name == alias:
            alias_found = True
            break
    if not alias_found:
        node.names.append(ast.alias(name=alias))


def add_import_alias(ast_module: ast.Module, module: str, alias: str) -> None:
    if not alias_in_module(ast_module, alias):
        return
    import_node = get_import_from_module(ast_module, module)
    if import_node:
        add_alias_to_import(import_node, alias)
    else:
        add_import_to_module(ast_module, module, alias)


def get_child_node(parent: ast.AST, child_name: str, child_type: Type[TASTCALL] = ast.FunctionDef) -> TASTCALL:
    matches = [
        cast(TASTCALL, child) for child in ast.iter_child_nodes(parent)
        if isinstance(child, child_type) and child.name == child_name
    ]
    if len(matches) != 1:
        raise LookupError(f"{len(matches)} classes were found for '{child_name}'")
    return matches[0]


@dataclass(slots=True)
class PythonArg:
    argtype: PythonArgType = PythonArgType.POS_OR_KW
    name: Optional[str] = None
    annotation: Optional[Union[AstAnnotation, ast.AST]] = None
    default: Optional[Any] = None
    enforce_none_default: bool = True

    @property
    def ast_arg(self) -> ast.arg:
        arg_data = {"arg": self.name}
        if self.annotation:
            arg_data["annotation"] = self.ast_annotation
        return ast.arg(**arg_data)

    @property
    def ast_annotation(self) -> ast.expr:
        return self.annotation() if isinstance(self.annotation, AstAnnotation) else self.annotation

    @property
    def ast_default(self) -> Optional[ast.AST]:
        if isinstance(self.default, ast.AST):
            return self.default
        elif self.default:
            return cast(ast.AST, ast.Constant(value=self.default))
        elif self.enforce_none_default:
            return cast(ast.AST, ast.Constant(value=None))
        else:
            return None

    @property
    def ast_annassign(self) -> ast.AnnAssign:
        if self.argtype in (PythonArgType.VARARG, PythonArgType.KWARG):
            raise TypeError(f"Attempting to obtain AnnAssign for {self.argtype}")
        kwargs = {
            "target": ast.Name(id=self.name, ctx=ast.Store()),
            "simple": 1
        }
        if self.annotation:
            kwargs["annotation"] = self.ast_annotation
        if default := self.ast_default:
            kwargs["value"] = default
        return ast.AnnAssign(**kwargs)

    @classmethod
    def from_ast_annassign(cls, annassign: ast.AnnAssign) -> PythonArg:
        return cls(
            name=cast(ast.Name, annassign.target).id,
            annotation=cast(ast.AST, annassign.annotation),
            default=annassign.value
        )


@dataclass(slots=True)
class SignatureArgs:
    version: str
    module: str
    action: str
    posonlyargs: list[ast.arg] = field(default_factory=list)
    args: list[ast.arg] = field(default_factory=list)
    kwonlyargs: list[ast.arg] = field(default_factory=list)
    vararg: Optional[ast.arg] = None
    kwarg: Optional[ast.arg] = None
    defaults: list[ast.expr] = field(default_factory=list)
    kw_defaults: list[Optional[ast.Constant]] = field(default_factory=list)
    sigtype: SignatureType = SignatureType.INIT
    docstring: Optional[ast.Expr] = None
    return_annotation: Optional[ast.AST] = None

    @classmethod
    def from_ast_node(
            cls, version: str, module: str, action: str, args: ast.arguments,
            docstring: Optional[ast.Expr] = None, return_annotation: Optional[ast.AST] = None
    ) -> SignatureArgs:
        return cls(
            version=version,
            module=module,
            action=action,
            posonlyargs=args.posonlyargs,
            args=args.args,
            kwonlyargs=args.kwonlyargs,
            vararg=args.vararg,
            kwarg=args.kwarg,
            defaults=args.defaults,
            kw_defaults=args.kw_defaults,
            sigtype=SignatureType.INIT,
            docstring=docstring,
            return_annotation=return_annotation
        )

    def to_ast_node(self) -> ast.arguments:
        return ast.arguments(
            posonlyargs=self.posonlyargs,
            args=self.args,
            kwonlyargs=self.kwonlyargs,
            vararg=self.vararg,
            kwarg=self.kwarg,
            defaults=self.defaults,
            kw_defaults=self.kw_defaults
        )

    @property
    def num_pos_only(self) -> int:
        return len(self.posonlyargs)

    @property
    def num_pos_or_kw(self) -> int:
        return len(self.args)

    @property
    def num_pos(self) -> int:
        return self.num_pos_only + self.num_pos_or_kw

    @property
    def num_kw_only(self) -> int:
        return len(self.kwonlyargs)

    @property
    def num_defaults(self) -> int:
        return len(self.defaults)

    @property
    def num_kw_defaults(self) -> int:
        return len(self.kw_defaults)

    @classmethod
    def from_python_args(
            cls, version: str, module: str, action: str, args: list[PythonArg],
            sigtype: SignatureType = SignatureType.DATACLASS, docstring: Optional[ast.Expr] = None,
            return_annotation: Optional[ast.AST] = None, add_self: bool = False
    ) -> SignatureArgs:
        signature_args = cls(
            version=version, module=module, action=action, sigtype=sigtype, docstring=docstring,
            return_annotation=return_annotation
        )
        if add_self:
            self_argtype = (
                PythonArgType.POS_ONLY
                if any(arg.argtype == PythonArgType.POS_ONLY for arg in args)
                else PythonArgType.POS_OR_KW
            )
            self_arg = PythonArg(argtype=self_argtype, name="self")
            signature_args.add(self_arg)
        for arg in args:
            signature_args.add(arg)
        return signature_args

    def to_python_args(self) -> list[PythonArg]:
        python_args: list[PythonArg] = []

        for idx, arg in enumerate(self.posonlyargs):
            idx_default = self.num_defaults + idx - self.num_pos
            default = None if idx_default < 0 else self.defaults[idx_default]
            python_args.append(
                PythonArg(
                    argtype=PythonArgType.POS_ONLY,
                    name=arg.arg,
                    annotation=arg.annotation,
                    default=default)
            )
        for idx, arg in enumerate(self.args):
            idx_default = self.num_defaults + idx - self.num_pos_or_kw
            default = None if idx_default < 0 else self.defaults[idx_default]
            python_args.append(
                PythonArg(
                    argtype=PythonArgType.POS_OR_KW,
                    name=arg.arg,
                    annotation=arg.annotation,
                    default=default
                )
            )
        for idx, kwarg in enumerate(self.kwonlyargs):
            python_args.append(
                PythonArg(
                    argtype=PythonArgType.KW_ONLY,
                    name=kwarg.arg,
                    annotation=kwarg.annotation,
                    default=self.kw_defaults[idx]
                )
            )
        if self.vararg:
            python_args.append(
                PythonArg(
                    argtype=PythonArgType.VARARG,
                    name=self.vararg.arg
                )
            )
        if self.kwarg:
            python_args.append(
                PythonArg(
                    argtype=PythonArgType.KWARG,
                    name=self.kwarg.arg
                )
            )
        return python_args

    def to_ast_annassigns(self) -> list[ast.AnnAssign]:
        return [python_arg.ast_annassign for python_arg in self.to_python_args()]

    def to_ast_call_arguments(self) -> tuple[list[Union[ast.Name, ast.Starred]], list[ast.keyword]]:
        args, keywords = [], []
        for arg in self.posonlyargs + self.args:
            argname: str = arg.arg
            if argname == "self":
                continue
            if argname == "file":
                continue
            args.append(
                ast.keyword(
                    arg=argname,
                    value=ast.Name(id=argname, ctx=ast.Load())
                )
            )
        if self.vararg:
            args.append(
                ast.Starred(value=ast.Name(id=self.vararg.arg, ctx=ast.Load()), ctx=ast.Load())
            )
        for kwarg in self.kwonlyargs:
            keywords.append(
                ast.keyword(
                    arg=kwarg.arg,
                    value=ast.Name(id=kwarg.arg, ctx=ast.Load())
                )
            )
        if self.kwarg:
            keywords.append(
                ast.keyword(value=ast.Name(id=self.kwarg.arg, ctx=ast.Load()))
            )
        return args, keywords

    def to_ast_api_action_method(self) -> ast.FunctionDef:
        if self.sigtype == SignatureType.INIT:
            signature_args_call = copy.deepcopy(self)
            signature_args_call.remove("file")
        elif self.sigtype == SignatureType.DATACLASS:
            signature_args_call = SignatureArgs(
                version=self.version, module=self.module, action=self.action, docstring=self.docstring,
                return_annotation=self.return_annotation
            )
            python_args = self.to_python_args()
            self_argtype = (
                PythonArgType.POS_ONLY
                if any(arg.argtype == PythonArgType.POS_ONLY for arg in python_args)
                else PythonArgType.POS_OR_KW
            )
            self_arg = PythonArg(argtype=self_argtype, name="self")
            signature_args_call.add(self_arg)
            for arg in self.to_python_args():
                signature_args_call.add(arg)
        signature_args_return = copy.deepcopy(self)
        signature_args_return.remove("self")
        args, keywords = signature_args_return.to_ast_call_arguments()
        docstring = [self.docstring] if self.docstring else []
        return ast.FunctionDef(
            name=self.action,
            args=signature_args_call.to_ast_node(),
            body=[
                *docstring,
                ast.Return(
                    value=ast.Call(
                        func=ast.Attribute(
                            value=ast.Attribute(
                                value=ast.Name(id="ifcopenshell", ctx=ast.Load()),
                                attr="api",
                                ctx=ast.Load()
                            ),
                            attr="run",
                            ctx=ast.Load()
                        ),
                        args=[
                            ast.Constant(value=f"{self.module}.{self.action}"),
                            ast.Attribute(
                                value=ast.Name(id="self", ctx=ast.Load()),
                                attr="file",
                                ctx=ast.Load()
                            ),
                            *args
                        ],
                        keywords=[
                            ast.keyword(
                                arg="on_static_version",
                                value=ast.Attribute(
                                    value=ast.Name(id="self", ctx=ast.Load()),
                                    attr="version",
                                    ctx=ast.Load()
                                )
                            ),
                            *keywords
                        ]
                    )
                )
            ],
            decorator_list=[],
            returns=self.return_annotation
        )

    def add(self, new_arg: PythonArg) -> None:
        position, default_position = self.resolve_insertion_position(new_arg)

        if new_arg.argtype == PythonArgType.POS_ONLY:
            self.posonlyargs.insert(position, new_arg.ast_arg)
            if new_arg.default:
                self.defaults.insert(default_position, new_arg.ast_default)
        elif new_arg.argtype == PythonArgType.POS_OR_KW:
            self.args.insert(position, new_arg.ast_arg)
            if new_arg.default:
                self.defaults.insert(default_position, new_arg.ast_default)
        elif new_arg.argtype == PythonArgType.KW_ONLY:
            self.kwonlyargs.insert(position, new_arg.ast_arg)
            self.kw_defaults.insert(default_position, new_arg.ast_default)
        elif new_arg.argtype == PythonArgType.VARARG:
            if self.vararg:
                raise ValueError(f"Trying to add {new_arg.name}, but vararg already exists")
            self.vararg = new_arg.ast_arg
        elif new_arg.argtype == PythonArgType.KWARG:
            if self.kwarg:
                raise ValueError(f"Trying to add {new_arg.name}, but kwargs already exists")
            self.kwarg = new_arg.ast_arg

    def resolve_insertion_position(self, new_arg: PythonArg) -> tuple[int, int]:
        position, default_position = -1, -1
        if new_arg.argtype in (PythonArgType.VARARG, PythonArgType.KWARG):
            raise TypeError(f"*args and **kwargs are single node arguments")
        elif new_arg.argtype == PythonArgType.KW_ONLY:
            if new_arg.default:
                position = self.num_kw_only
                default_position = self.num_kw_defaults
            else:
                position = self.num_kw_only - self.num_kw_defaults
                default_position = position  # default will be None, and kwarg required
                if position < 0:
                    raise ValueError(f"Invalid number of keyword-only default values")
        elif new_arg.argtype == PythonArgType.POS_OR_KW:
            if new_arg.default:
                position = self.num_pos_or_kw
                default_position = self.num_defaults
            else:
                position = self.num_pos_or_kw - self.num_defaults
                if position < 0:
                    error_txt = f"Positional or keyword argument {new_arg.name} without default value "
                    error_txt += f"cannot be inserted while positional-only arguments with default exist"
                    raise ValueError(error_txt)
        elif new_arg.argtype == PythonArgType.POS_ONLY:
            if new_arg.default:
                position = self.num_pos_only
                default_position = self.num_defaults - self.num_pos_or_kw
                if default_position < 0:
                    error_txt = f"Positional-only argument {new_arg.name} with default value {new_arg.default} "
                    error_txt += f"cannot be inserted while positional or keyword arguments without default exist"
                    raise ValueError(error_txt)
            else:
                position = self.num_pos_only - max(self.num_defaults - self.num_pos_or_kw, 0)
        return position, default_position

    def remove(self, argname: str, strict: bool = False) -> None:
        idx_to_remove = -1
        for idx, arg in enumerate(self.posonlyargs):
            if arg.arg == argname:
                idx_to_remove = idx
                break
        if idx_to_remove != -1:
            idx_default = self.num_defaults + idx_to_remove - self.num_pos
            del self.posonlyargs[idx_to_remove]
            if idx_default >= 0:
                del self.defaults[idx_default]
            return
        idx_to_remove = -1
        for idx, arg in enumerate(self.args):
            if arg.arg == argname:
                idx_to_remove = idx
                break
        if idx_to_remove != -1:
            idx_default = self.num_defaults + idx_to_remove - self.num_pos_or_kw
            del self.args[idx_to_remove]
            if idx_default >= 0:
                del self.defaults[idx_default]
            return
        idx_to_remove = -1
        for idx, arg in enumerate(self.kwonlyargs):
            if arg.arg == argname:
                idx_to_remove = idx
                break
        if idx_to_remove != -1:
            del self.args[idx_to_remove]
            del self.defaults[idx_to_remove]
            return
        if self.vararg and self.vararg.arg == argname:
            self.vararg = None
            return
        if self.kwarg and self.kwarg.arg == argname:
            self.kwarg = None
            return
        if strict:
            raise LookupError(f"Argument '{argname}' was not found and could not be deleted")

    def to_ast_dict(self) -> ast.Dict:
        keys: list[ast.Constant] = []
        values: list[ast.Attribute] = []

        if self.vararg:
            raise ValueError(f"Dict does not support variational positional arguments")

        if self.kwarg:
            txt = f"Attempting to generate a dict with variational keyword arguments, "
            txt += f"but the whole multischema build step is conceived around strong typing. "
            txt += f"Was this really intended?"
            raise NotImplementedError(txt)

        for arg in self.posonlyargs + self.args + self.kwonlyargs:
            # only self.args will contain arguments, since POS_OR_KW default is used when creating a PythonArg

            keys.append(ast.Constant(value=arg.arg))
            values.append(
                ast.Attribute(
                    value=ast.Name(id="self", ctx=ast.Load()),
                    attr=arg.arg,
                    ctx=ast.Load()
                )
            )
        return ast.Dict(keys=keys, values=values)

    def bake_method(self, method_name: str = "schema_attrs") -> ast.FunctionDef:
        return ast.FunctionDef(
            name=method_name,
            args=ast.arguments(
                posonlyargs=[],
                args=[ast.arg(arg="self")],
                kwonlyargs=[],
                kw_defaults=[],
                defaults=[]
            ),
            body=[
                ast.Assign(
                    targets=[ast.Name(id="all_schema_attrs", ctx=ast.Store())],
                    value=self.to_ast_dict()
                ),
                ast.Return(
                    value=ast.DictComp(
                        key=ast.Name(id="key", ctx=ast.Load()),
                        value=ast.Name(id="value", ctx=ast.Load()),
                        generators=[
                            ast.comprehension(
                                target=ast.Tuple(
                                    elts=[
                                        ast.Name(id="key", ctx=ast.Store()),
                                        ast.Name(id="value", ctx=ast.Store())
                                    ],
                                    ctx=ast.Store()
                                ),
                                iter=ast.Call(
                                    func=ast.Attribute(
                                        value=ast.Name(id="all_schema_attrs", ctx=ast.Load()),
                                        attr="items",
                                        ctx=ast.Load()
                                    ),
                                    args=[],
                                    keywords=[]
                                ),
                                ifs=[
                                    ast.Name(id="value", ctx=ast.Load())
                                ],
                                is_async=0
                            )
                        ]
                    )
                )
            ],
            decorator_list=[]
        )

    def bake_api_module_class(self, append_to: Optional[ast.ClassDef] = None) -> ast.ClassDef:
        if not append_to:
            append_to = ast.ClassDef(
                name=f"ApiModule_{self.module}",
                bases=[],
                keywords=[],
                body=[
                    ast.Expr(
                        ast.Constant(value=f"IfcOpenShell API {self.module} module")
                    ),
                    ast.AnnAssign(
                        target=ast.Name(id="file", ctx=ast.Store()),
                        annotation=ast.Attribute(
                            value=ast.Name(id="ifcopenshell", ctx=ast.Load()),
                            attr="file",
                            ctx=ast.Load()),
                        simple=1
                    ),
                    ast.AnnAssign(
                        target=ast.Name(id='version', ctx=ast.Store()),
                        annotation=ast.Name(id='str', ctx=ast.Load()),
                        simple=1
                    ),
                ],
                decorator_list=[
                    ast.Call(
                        func=ast.Name(id="dataclass", ctx=ast.Load()),
                        args=[],
                        keywords=[
                            ast.keyword(
                                arg="slots",
                                value=ast.Constant(value=True)
                            )
                        ]
                    )
                ]
            )

        append_to.body.append(
            cast(ast.stmt, ast.fix_missing_locations(self.to_ast_api_action_method()))
        )
        return ast.fix_missing_locations(append_to)


@dataclass(slots=True)
class AstAnnotation:
    def __call__(self) -> ast.expr:
        ...

    def __or__(self, other: AstAnnotation) -> AstAnnotation:
        if self.__class__.__name__ == other.__class__.__name__ and self == other:
            return self
        return AstAnnotationUnion([self, other])


@dataclass(slots=True)
class AstAnnotationEntityInstance(AstAnnotation):
    def __call__(self) -> ast.Attribute:
        return ast.Attribute(
            value=ast.Name(id="ifcopenshell", ctx=ast.Load()),
            attr="entity_instance",
            ctx=ast.Load()
        )


@dataclass(slots=True)
class AstAnnotationName(AstAnnotation):
    annotation_type: type

    def __call__(self) -> ast.Name:
        return ast.Name(id=type_to_str(self.annotation_type), ctx=ast.Load())


@dataclass(slots=True)
class AstAnnotationConstant(AstAnnotation):
    annotation_value: Any

    def __call__(self) -> ast.Constant:
        return ast.Constant(value=self.annotation_value)


@dataclass(slots=True)
class AstAnnotationAggregation(AstAnnotation):
    aggregation_type: type
    aggregation_content: AstAnnotation

    def __call__(self) -> ast.Subscript:
        return ast.Subscript(
            value=ast.Name(id=type_to_str(self.aggregation_type), ctx=ast.Load()),
            slice=self.aggregation_content(),
            ctx=ast.Load()
        )


@dataclass(slots=True)
class AstAnnotationUnion(AstAnnotation):
    annotations: list[AstAnnotation]
    subscript_name: str = "Union"

    def __call__(self) -> ast.Subscript:
        return ast.Subscript(
            value=ast.Name(id=self.subscript_name, ctx=ast.Load()),
            slice=ast.Tuple(elts=[ann() for ann in self.annotations], ctx=ast.Load()),
            ctx=ast.Load()
        )


@dataclass(slots=True)
class SchemaAttrParser:
    """Parses IFC Schema attributes"""
    ifc_class: str
    defaults: dict[str, Any] = field(default_factory=dict)
    exclude: list[str] = field(default_factory=list)
    version: str = "IFC4"

    def __call__(self) -> list[PythonArg]:
        return self.retrieve_parameters()

    @property
    def schema(self) -> wrapper.schema_definition:
        return wrapper.schema_by_name(self.version)

    def retrieve_parameters(self) -> list[PythonArg]:
        entity = self.schema.declaration_by_name(self.ifc_class)
        parsed_attrs = []
        for attribute in entity.all_attributes():
            if parameter := self.parse_attribute(attribute):
                parsed_attrs.append(parameter)
        return parsed_attrs

    def parse_attribute(self, attribute: wrapper.attribute) -> Optional[PythonArg]:
        name_pascal: str = attribute.name()
        name: str = pascal_to_snake(name_pascal)
        if name in self.exclude:
            return
        default = self.defaults[name_pascal] if name_pascal in self.defaults else None
        type_of_attribute = attribute.type_of_attribute()
        if isinstance(type_of_attribute, wrapper.simple_type):
            annotation = self.parse_simple_type(type_of_attribute)
        elif isinstance(type_of_attribute, wrapper.named_type):
            annotation = self.parse_named_type(type_of_attribute)
        elif isinstance(type_of_attribute, wrapper.aggregation_type):
            annotation = self.parse_aggregation_type(type_of_attribute)
        else:
            warnings.warn(f"Unexpected type of attribute {type(type_of_attribute)}")
            annotation = AstAnnotationConstant(Any)
        annotation = annotation | AstAnnotationConstant(None)
        return PythonArg(name=name, annotation=annotation, default=default, enforce_none_default=True)

    @staticmethod
    def parse_simple_type(simple: wrapper.simple_type) -> AstAnnotation:
        return {
            "string": AstAnnotationName(str),
            "logical": AstAnnotationUnion([
                AstAnnotationName(bool),
                AstAnnotationConstant(None)
            ]),
            "boolean": AstAnnotationName(bool),
            "real": AstAnnotationName(float),
            "number": AstAnnotationUnion([
                AstAnnotationName(int),
                AstAnnotationName(float)
            ]),
            "integer": AstAnnotationName(int),
            "binary": AstAnnotationName(bytes)
        }[simple.declared_type()]

    def parse_named_type(self, named: wrapper.named_type) -> AstAnnotation:
        declared_type = named.declared_type()
        if isinstance(declared_type, wrapper.entity):
            return AstAnnotationEntityInstance()
        elif isinstance(declared_type, wrapper.type_declaration):
            return self.parse_type_declaration(declared_type)
        elif isinstance(declared_type, wrapper.select_type):
            return self.parse_select_type(declared_type)
        elif isinstance(declared_type, wrapper.enumeration_type):
            return AstAnnotationName(str)

    def parse_type_declaration(self, declaration: wrapper.type_declaration) -> AstAnnotation:
        declared_type = declaration.declared_type()
        if isinstance(declared_type, wrapper.simple_type):
            return self.parse_simple_type(declared_type)
        elif isinstance(declared_type, wrapper.named_type):
            return self.parse_named_type(declared_type)
        elif isinstance(declared_type, wrapper.aggregation_type):
            return self.parse_aggregation_type(declared_type)
        elif isinstance(declared_type, wrapper.type_declaration):
            return self.parse_type_declaration(declared_type)

    def parse_aggregation_type(self, aggregation: wrapper.aggregation_type) -> AstAnnotation:
        type_of_element = aggregation.type_of_element()
        type_of_aggregation = aggregation.type_of_aggregation_string()

        if isinstance(type_of_element, wrapper.simple_type):
            element_annotation = self.parse_simple_type(type_of_element)
        elif isinstance(type_of_element, wrapper.named_type):
            element_annotation = self.parse_named_type(type_of_element)
        elif isinstance(type_of_element, wrapper.aggregation_type):
            element_annotation = self.parse_aggregation_type(type_of_element)
        else:
            warnings.warn(f"Unexpected type of element {type(type_of_element)}")
            element_annotation = AstAnnotationConstant(Any)

        if type_of_aggregation == "list":  # ordered w/o repetition, flexible size
            return AstAnnotationAggregation(list, element_annotation)
        elif type_of_aggregation == "set":  # unordered w/o repetition
            return AstAnnotationAggregation(set, element_annotation)
        elif type_of_aggregation == "array":  # ordered and fixed size
            min_size: int = aggregation.bound1()
            max_size: int = aggregation.bound2()
            return AstAnnotationUnion(
                [AstAnnotationUnion(annotations=[element_annotation for _ in range(size)], subscript_name="tuple")
                 for size in (min_size, max_size) if size != -1]
            )

    def parse_select_type(self, select: wrapper.select_type) -> AstAnnotation:
        annotations: set[AstAnnotation] = set()
        for item in select.select_list():
            if isinstance(item, wrapper.entity):
                annotations.add(AstAnnotationEntityInstance())
            elif isinstance(item, wrapper.type_declaration):
                annotations.add(self.parse_type_declaration(item))
            elif isinstance(item, wrapper.select_type):
                annotations.union({self.parse_select_type(item)})
        return reduce(lambda a, b: a | b, annotations)

    @classmethod
    def from_decorator(cls, decorator: ast.Call, version: str = "IFC4") -> SchemaAttrParser:
        ifc_class: Optional[str] = None
        exclude: list[str] = []
        defaults: dict[str, Any] = {}
        for keyword in decorator.keywords:
            if keyword.arg == "ifc_class":
                if not isinstance(keyword.value, ast.Constant):
                    warnings.warn(f"Unexpected ifc_class[{type(keyword.value)}]. Expected ast.Constant")
                    break
                ifc_class = keyword.value.value
            if keyword.arg == "exclude":
                if not isinstance(keyword.value, ast.List):
                    warnings.warn(f"Ignoring exclude[{type(keyword.value)}]. Expected ast.List")
                    continue
                for element in keyword.value.elts:
                    if not isinstance(element, ast.Constant):
                        warnings.warn(f"Ignoring exclude[{type(element)}]. Expected ast.Constant")
                        continue
                    exclude.append(element.value)
            if keyword.arg == "defaults":
                if not isinstance(keyword.value, ast.Dict):
                    warnings.warn(f"Ignoring defaults[{type(keyword.value)}]. Expected ast.Dict")
                    continue
                for key, value in zip(keyword.value.keys, keyword.value.values):
                    if not isinstance(key, ast.Constant):
                        warnings.warn(f"Ignoring default key[{type(key)}]. Expected ast.Constant")
                        continue
                    if not isinstance(value, ast.Constant):
                        warnings.warn(f"Ignoring default value[{type(key)}] for key {key.value}. Expected ast.Constant")
                        continue
                    defaults[key.value] = value.value
        return cls(ifc_class, defaults, exclude, version)


class SchemaAttrsRemover(ast.NodeTransformer):
    schema_decorator_name: str = "with_schema_attrs"

    def visit_ImportFrom(self, node: ast.ImportFrom) -> Optional[ast.ImportFrom]:
        schema_attrs_alias_idx = -1
        for idx, name in enumerate(node.names):
            if not isinstance(name, ast.alias):
                continue
            if name.name == self.schema_decorator_name:
                schema_attrs_alias_idx = idx
                break

        if schema_attrs_alias_idx == -1:
            return node
        elif len(node.names) == 1:
            return None
        else:
            del node.names[schema_attrs_alias_idx]
            return node

    def visit_ClassDef(self, node: ast.ClassDef) -> ast.ClassDef:
        if node.name != "Usecase":
            return node
        with_attrs_decorator_idx = -1
        for idx, decorator in enumerate(node.decorator_list):
            if not isinstance(decorator, ast.Call):
                continue
            if not isinstance(decorator.func, ast.Name):
                continue
            if decorator.func.id != self.schema_decorator_name:
                continue
            with_attrs_decorator_idx = idx
            break
        if with_attrs_decorator_idx != -1:
            del node.decorator_list[with_attrs_decorator_idx]
        return node


class FileHelperRemover(ast.NodeTransformer):
    def visit_FunctionDef(self, node: ast.FunctionDef) -> Optional[ast.FunctionDef]:
        return None if node.name == "file" else node


@dataclass(slots=True)
class SchemaApiActionBuilder:
    module: str
    action: str
    version: str
    api_dir: Path
    _output_dir: Optional[Path] = field(init=False)
    _init_arguments: Optional[SignatureArgs] = field(init=False, default=None)

    def __post_init__(self):
        self._output_dir: Path = self.api_dir.parent / f"api_{self.version}"
        self._output_dir.mkdir(exist_ok=True)

    def __call__(self) -> tuple[ast.Module, SignatureArgs]:
        source: str = open(self.source_path, 'r').read()
        tree: ast.Module = ast.parse(source)
        updated_tree = self.update_usecase(tree)
        self.save(updated_tree)
        return updated_tree, self._init_arguments

    @property
    def source_path(self) -> Path:
        return self.api_dir / self.module / f"{self.action}.py"

    def save(self, tree: ast.Module) -> None:
        try:
            updated_source = ast.unparse(tree)
        except (TypeError, AttributeError):
            warnings.warn(f"Error unparsing abstract syntax tree of {self.module}.{self.action}")
            return

        module_dir = self._output_dir / self.module
        module_dir.mkdir(exist_ok=True)
        with open(module_dir / f"{self.action}.py", "w") as f:
            filename = f"ifcopenshell.api.{self.module}.{self.action}.py"
            f.write(preamble(self.version, filename) + updated_source)

    def update_usecase(self, tree: ast.Module) -> ast.Module:
        usecase_node = self.get_usecase(tree)
        attrs_dec_idx, attrs_decorator = self.get_schema_attrs_decorator(usecase_node)
        schema_args: list[PythonArg] = []
        if attrs_decorator is not None:
            schema_args = SchemaAttrParser.from_decorator(attrs_decorator, version=self.version)()

        sigtype = self.get_signature_type(usecase_node)
        update_usecase_func: Callable[[ast.ClassDef, list[PythonArg]], SignatureArgs] = {
            SignatureType.INIT: self.update_usecase_init,
            SignatureType.DATACLASS: self.update_usecase_dataclass
        }[sigtype]

        self._init_arguments = update_usecase_func(usecase_node, schema_args)
        if schema_args:
            add_import_alias(tree, "typing", "Union")
        schema_attrs_method = SignatureArgs.from_python_args(
            version=self.version, module=self.module, action=self.action, args=schema_args, sigtype=sigtype
        ).bake_method()
        usecase_node.body.append(cast(ast.stmt, schema_attrs_method))
        tree = SchemaAttrsRemover().visit(tree)
        return ast.fix_missing_locations(tree)

    def update_usecase_init(self, usecase_node: ast.ClassDef, schema_args: list[PythonArg]) -> SignatureArgs:
        init_node = self.get_init(usecase_node)
        docstring = self.get_docstring(init_node)
        return_annotation = self.get_usecase_return_annotation(usecase_node)
        signature_args = SignatureArgs.from_ast_node(
            version=self.version, module=self.module, action=self.action, args=init_node.args,
            docstring=docstring, return_annotation=return_annotation
        )
        for schema_arg in schema_args:
            signature_args.add(schema_arg)
        init_node.args = signature_args.to_ast_node()
        return signature_args

    def update_usecase_dataclass(self, usecase_node: ast.ClassDef, schema_args: list[PythonArg]) -> SignatureArgs:
        wrn_msg = f"Dataclass from {self.module}.{self.action} has no signature"
        idx_assign_min, idx_assign_max, found_assigns = find_ast_idxs(
            node=usecase_node, on_type=ast.AnnAssign, wrn_msg=wrn_msg
        )

        dataclass_args = [
            PythonArg.from_ast_annassign(cast(ast.AnnAssign, usecase_node.body[idx]))
            for idx in range(idx_assign_min, idx_assign_max + 1)
        ]
        docstring = self.get_docstring(usecase_node)
        return_annotation = self.get_usecase_return_annotation(usecase_node)
        signature_args = SignatureArgs.from_python_args(
            version=self.version, module=self.module, action=self.action, args=dataclass_args + schema_args,
            sigtype=SignatureType.DATACLASS, docstring=docstring, return_annotation=return_annotation
        )
        annassigns = signature_args.to_ast_annassigns()
        if found_assigns:
            del usecase_node.body[idx_assign_min:idx_assign_max + 1]
        usecase_node.body[idx_assign_min:idx_assign_min] = annassigns
        return signature_args

    def get_usecase(self, tree: ast.Module) -> ast.ClassDef:
        for node in ast.walk(tree):
            if isinstance(node, ast.ClassDef) and node.name == "Usecase":
                return node
        raise RuntimeError(f"{self.module}.{self.action} does not contain a Usecase class")

    @staticmethod
    def get_usecase_return_annotation(usecase: ast.ClassDef) -> ast.AST:
        execute_node = get_child_node(parent=usecase, child_name="execute", child_type=ast.FunctionDef)
        return cast(ast.AST, execute_node.returns)

    @staticmethod
    def get_signature_type(usecase_node: ast.ClassDef) -> SignatureType:
        return SignatureType.DATACLASS if is_dataclass(usecase_node) else SignatureType.INIT

    @staticmethod
    def get_init(node: ast.ClassDef) -> ast.FunctionDef:
        inits = [
            child for child in ast.iter_child_nodes(node)
            if isinstance(child, ast.FunctionDef) and child.name == "__init__"
        ]
        if len(inits) != 1:
            raise LookupError(f"{len(inits)} __init__ methods were found")
        return inits[0]

    @staticmethod
    def get_docstring(node: Union[ast.ClassDef, ast.FunctionDef]) -> Optional[ast.Expr]:
        return node.body[0] if node.body and isinstance(node.body[0], ast.Expr) else None

    @staticmethod
    def is_schema_attrs_decorator(decorator: ast.expr) -> bool:
        if not isinstance(decorator, ast.Call):
            return False
        if not isinstance(decorator.func, ast.Name):
            return False
        if decorator.func.id != "with_schema_attrs":
            return False
        return True

    def get_schema_attrs_decorator(self, node: ast.ClassDef) -> tuple[int, Optional[ast.Call]]:
        idx = -1
        attrs_decorator: Optional[ast.Call] = None
        for idx, decorator in enumerate(node.decorator_list):
            if self.is_schema_attrs_decorator(decorator):
                attrs_decorator = cast(ast.Call, decorator)
                break
        return idx, attrs_decorator


@dataclass(slots=True)
class SchemaApiBuilder:
    version: str
    api_dir: Path

    def __call__(self) -> None:
        file_source: str = open(self.file_path, 'r').read()
        file_tree: ast.Module = ast.parse(file_source)
        file_tree = FileHelperRemover().visit(file_tree)
        file_node = get_child_node(parent=file_tree, child_name="_file", child_type=ast.ClassDef)
        file_init_node = get_child_node(
            parent=cast(ast.AST, file_node), child_name="__init__", child_type=ast.FunctionDef
        )
        idx_class_min, idx_class_max, found_class_items = find_ast_idxs(node=file_tree, on_type=ast.ClassDef)

        for module, actions in list_actions().items():
            module_node: Optional[ast.ClassDef] = None
            for action in actions:
                action_tree, init_arguments = SchemaApiActionBuilder(module, action, self.version, self.api_dir)()
                module_node = init_arguments.bake_api_module_class(append_to=module_node)

            if module_node is None:
                warnings.warn(f"Apparently, API module '{module}' does not contain any actions yet")
                continue

            file_tree.body.insert(
                idx_class_min,
                cast(ast.stmt, ast.fix_missing_locations(module_node))
            )
            file_init_node.body.append(
                cast(ast.stmt, self.to_ast_api_module_assignment(module))
            )

        add_import_alias(ast_module=file_tree, module="typing", alias="Union")
        add_import_alias(ast_module=file_tree, module="typing", alias="Optional")
        add_import_alias(ast_module=file_tree, module="dataclasses", alias="dataclass")
        updated_file_source = preamble(self.version, "ifcopenshell.file.py")
        updated_file_source += ast.unparse(ast.fix_missing_locations(file_tree))
        with open(self.api_dir.parent / f"file_{self.version}.py", "w") as f:
            f.write(updated_file_source)

    @property
    def file_path(self) -> Path:
        return self.api_dir.parent / "file.py"

    @staticmethod
    def to_ast_api_module_assignment(module) -> ast.Assign:
        return ast.Assign(
            targets=[
                ast.Attribute(
                    value=ast.Name(id="self", ctx=ast.Load()),
                    attr=module,
                    ctx=ast.Store()
                )
            ],
            value=ast.Call(
                func=ast.Name(id=f"ApiModule_{module}", ctx=ast.Load()),
                args=[],
                keywords=[
                    ast.keyword(
                        arg="file",
                        value=ast.Name(id="self", ctx=ast.Load())
                    ),
                    ast.keyword(
                        arg="version",
                        value=ast.Attribute(
                            value=ast.Name(id="self", ctx=ast.Load()),
                            attr="schema",
                            ctx=ast.Load()
                        )
                    )
                ]
            )
        )


if __name__ == "__main__":
    api_dir = Path(os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe()))))

    for version in ["IFC2X3", "IFC4", "IFC4X3"]:  # TODO: include every version
        SchemaApiBuilder(version=version, api_dir=api_dir)()
